; ModuleID = 'C:\Users\PaulK\OneDrive\Documents\PL\PyPL\build\build\out_linked.ll'
source_filename = "llvm-link"
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "aarch64-windows-msvc"

%struct._CONTEXT = type { i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i16, i16, i16, i16, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %union.anon, [26 x %struct._M128A], i64, i64, i64, i64, i64, i64 }
%union.anon = type { %struct._XSAVE_FORMAT }
%struct._XSAVE_FORMAT = type { i16, i16, i8, i8, i16, i32, i16, i16, i32, i16, i16, i32, i32, [8 x %struct._M128A], [16 x %struct._M128A], [96 x i8] }
%struct._M128A = type { i64, i64 }

@string_string = internal constant [4 x i8] c"%s\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local global ptr null
@always_one = linkonce thread_local global i1 true
@current_ptr = thread_local global ptr null
@backtrace_string = constant [16 x i8] c"%i: %s - 0x%0X\0A\00"
@wovqv_Warning_Remove_returned_Nil_for_key_ = internal unnamed_addr constant [37 x i8] c"Warning: Remove returned Nil for key ", align 64
@hnbwj_Warning_Remove_returned_wrong_value_for_key_ = internal unnamed_addr constant [45 x i8] c"Warning: Remove returned wrong value for key ", align 64
@khbst_Error_Nil_returned_during_random_hit_test_for_key_ = internal unnamed_addr constant [51 x i8] c"Error: Nil returned during random hit test for key ", align 64
@yylhu__unique_keys_for_random_hit_test = internal unnamed_addr constant [33 x i8] c" unique keys for random hit test.", align 64
@lwoib_Error_Nil_returned_during_sequential_hit_test_for_key_ = internal unnamed_addr constant [55 x i8] c"Error: Nil returned during sequential hit test for key ", align 64
@_parameterization_Pairi32._Bool = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_Bool, ptr null]
@_parameterization_Functioni32._i32_to_Bool = linkonce_odr constant [5 x ptr] [ptr @function_typ, ptr @_parameterization_Bool, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@_parameterization_Functioni32_to_i32 = linkonce_odr constant [4 x ptr] [ptr @function_typ, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@_parameterization_Pairi32._i32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_i32, ptr @_parameterization_i32, ptr null]
@PRNG_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = constant [4 x i32] [i32 15, i32 10, i32 10, i32 0]
@PRNG = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_data_size_PRNG, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedi32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedi32, ptr @PRNG_next_] }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i32_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@f64_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@function_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @buffer_typ, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@Object_hashtbl = constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@_parameterization_Bool = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 10, i32 0]
@Container_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container]
@Container_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Iterator_hashtbl = constant [4 x ptr] [ptr @Iterator, ptr @any_typ, ptr @Container, ptr @Object]
@Iterator_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 13, i32 13]
@Iterable_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Object]
@Iterable_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 35, i32 35]
@Enumeration_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @Enumeration, ptr @Object]
@Enumeration_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 0, i32 64, i32 0, i32 10, i32 64]
@Enumeration = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -2805197119131967777, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Enumeration_hashtbl, ptr @Enumeration_offset_tbl, ptr @_data_size_Enumeration, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Enumeration_field_Enumeration_0, ptr @Enumeration_field_Enumeration_1, ptr @Enumeration_field_iterable, ptr @Enumeration_B_init_iterableIterableT, ptr @Enumeration_B_iterator_, ptr @Enumeration_B_each_fFunctionT_to_Nothing, ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumeration_B_all_fFunctionT_to_Bool, ptr @Enumeration_B_any_fFunctionT_to_Bool, ptr @Enumeration_B_enumerate_, ptr @Enumeration_B_map_fFunctionT_to_U, ptr @Enumeration_B_filter_fFunctionT_to_Bool, ptr @Enumeration_B_chain_otherIterableT, ptr @Enumeration_B_interleave_otherIterableT, ptr @Enumeration_B_zip_otherIterableU, ptr @Enumeration_B_product_otherIterableU, ptr @Enumeration_init_iterableIterableT, ptr @Enumeration_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Enumeration_field_Enumeration_1, ptr @Enumeration_B_iterator_, ptr @Enumeration_B_each_fFunctionT_to_Nothing, ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumeration_B_all_fFunctionT_to_Bool, ptr @Enumeration_B_any_fFunctionT_to_Bool, ptr @Enumeration_B_enumerate_, ptr @Enumeration_B_map_fFunctionT_to_U, ptr @Enumeration_B_filter_fFunctionT_to_Bool, ptr @Enumeration_B_chain_otherIterableT, ptr @Enumeration_B_interleave_otherIterableT, ptr @Enumeration_B_zip_otherIterableU, ptr @Enumeration_B_product_otherIterableU, ptr @Enumeration_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Enumerator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @Enumerator]
@Enumerator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@MapIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @MapIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@MapIterable_offset_tbl = constant [8 x i32] [i32 0, i32 65, i32 10, i32 40, i32 65, i32 0, i32 0, i32 10]
@MapIterable = constant { [3 x i64], [7 x ptr], [55 x ptr] } { [3 x i64] [i64 -7488770571603291722, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterable_hashtbl, ptr @MapIterable_offset_tbl, ptr @_data_size_MapIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [55 x ptr] [ptr @MapIterable_field_MapIterable_0, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_field_iterable, ptr @MapIterable_field_f, ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Bool, ptr @MapIterable_B_any_fFunctionT_to_Bool, ptr @MapIterable_B_enumerate_, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Bool, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Bool, ptr @MapIterable_B_any_fFunctionT_to_Bool, ptr @MapIterable_B_enumerate_, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Bool, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @MapIterator, ptr @Container, ptr null, ptr @Iterator, ptr null, ptr null]
@MapIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 10, i32 21, i32 0, i32 18, i32 0, i32 0]
@FilterIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @FilterIterable, ptr null, ptr @Container, ptr @Iterable, ptr null]
@FilterIterable_offset_tbl = constant [8 x i32] [i32 0, i32 64, i32 10, i32 10, i32 0, i32 64, i32 39, i32 0]
@FilterIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 8498466713076104350, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterable_hashtbl, ptr @FilterIterable_offset_tbl, ptr @_data_size_FilterIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_field_iterable, ptr @FilterIterable_field_f, ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Bool, ptr @FilterIterable_B_any_fFunctionT_to_Bool, ptr @FilterIterable_B_enumerate_, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Bool, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_init_iterableIterableT_fFunctionT_to_Bool, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Bool, ptr @FilterIterable_B_any_fFunctionT_to_Bool, ptr @FilterIterable_B_enumerate_, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Bool, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@FilterIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @FilterIterator, ptr null]
@FilterIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 0, i32 17, i32 10, i32 0]
@FilterIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -1221365496900303883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterator_hashtbl, ptr @FilterIterator_offset_tbl, ptr @_data_size_FilterIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_field_iterator, ptr @FilterIterator_field_f, ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @FilterIterator_B_next_, ptr @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @FilterIterator_next_, ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_B_next_, ptr @FilterIterator_next_] }
@ChainIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ChainIterable, ptr @Container, ptr null, ptr null, ptr @Object]
@ChainIterable_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 10, i32 64, i32 0, i32 0, i32 64]
@ChainIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -2370247058431047815, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterable_hashtbl, ptr @ChainIterable_offset_tbl, ptr @_data_size_ChainIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_field_first, ptr @ChainIterable_field_second, ptr @ChainIterable_B_init_firstIterableT_secondIterableT, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Bool, ptr @ChainIterable_B_any_fFunctionT_to_Bool, ptr @ChainIterable_B_enumerate_, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Bool, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_init_firstIterableT_secondIterableT, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Bool, ptr @ChainIterable_B_any_fFunctionT_to_Bool, ptr @ChainIterable_B_enumerate_, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Bool, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ChainIterator]
@ChainIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@InterleaveIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @InterleaveIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@InterleaveIterable_offset_tbl = constant [8 x i32] [i32 0, i32 64, i32 10, i32 39, i32 64, i32 0, i32 0, i32 10]
@InterleaveIterable = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 4936782714255954462, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterable_hashtbl, ptr @InterleaveIterable_offset_tbl, ptr @_data_size_InterleaveIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_field_first, ptr @InterleaveIterable_field_second, ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Bool, ptr @InterleaveIterable_B_any_fFunctionT_to_Bool, ptr @InterleaveIterable_B_enumerate_, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Bool, ptr @InterleaveIterable_B_any_fFunctionT_to_Bool, ptr @InterleaveIterable_B_enumerate_, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleaveIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleaveIterator, ptr @Iterator, ptr null, ptr null]
@InterleaveIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 0, i32 21, i32 10, i32 18, i32 0, i32 0]
@ZipIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @ZipIterable, ptr @Object]
@ZipIterable_offset_tbl = constant [8 x i32] [i32 10, i32 41, i32 0, i32 0, i32 66, i32 0, i32 10, i32 66]
@ZipIterable = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 35232740166152944, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterable_hashtbl, ptr @ZipIterable_offset_tbl, ptr @_data_size_ZipIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @ZipIterable_field_ZipIterable_0, ptr @ZipIterable_field_ZipIterable_1, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_field_first, ptr @ZipIterable_field_second, ptr @ZipIterable_B_init_firstIterableT_secondIterableU, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Bool, ptr @ZipIterable_B_any_fFunctionT_to_Bool, ptr @ZipIterable_B_enumerate_, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Bool, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_init_firstIterableT_secondIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Bool, ptr @ZipIterable_B_any_fFunctionT_to_Bool, ptr @ZipIterable_B_enumerate_, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Bool, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZipIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ZipIterator]
@ZipIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 22, i32 19, i32 22, i32 0, i32 10, i32 10]
@ProductIterable_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @ProductIterable, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr null]
@ProductIterable_offset_tbl = constant [8 x i32] [i32 66, i32 10, i32 10, i32 66, i32 0, i32 41, i32 0, i32 0]
@ProductIterable = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 4128338911757318636, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterable_hashtbl, ptr @ProductIterable_offset_tbl, ptr @_data_size_ProductIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @ProductIterable_field_ProductIterable_0, ptr @ProductIterable_field_ProductIterable_1, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_field_first, ptr @ProductIterable_field_second, ptr @ProductIterable_B_init_firstIterableT_secondIterableU, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Bool, ptr @ProductIterable_B_any_fFunctionT_to_Bool, ptr @ProductIterable_B_enumerate_, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Bool, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_init_firstIterableT_secondIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Bool, ptr @ProductIterable_B_any_fFunctionT_to_Bool, ptr @ProductIterable_B_enumerate_, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Bool, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @Iterator, ptr null, ptr @Container, ptr @Object, ptr null, ptr @ProductIterator]
@ProductIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 21, i32 0, i32 24, i32 24, i32 0, i32 10]
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@Enumeration_field_iterable = internal constant { ptr, ptr } { ptr @Enumeration_getter_iterable, ptr @Enumeration_setter_iterable }
@Enumerator_field_iterator = internal constant { ptr, ptr } { ptr @Enumerator_getter_iterator, ptr @Enumerator_setter_iterator }
@Enumerator_field_index = internal constant { ptr, ptr } { ptr @Enumerator_getter_index, ptr @Enumerator_setter_index }
@MapIterable_field_iterable = internal constant { ptr, ptr } { ptr @MapIterable_getter_iterable, ptr @MapIterable_setter_iterable }
@MapIterable_field_f = internal constant { ptr, ptr } { ptr @MapIterable_getter_f, ptr @MapIterable_setter_f }
@MapIterator_field_iterator = internal constant { ptr, ptr } { ptr @MapIterator_getter_iterator, ptr @MapIterator_setter_iterator }
@MapIterator_field_f = internal constant { ptr, ptr } { ptr @MapIterator_getter_f, ptr @MapIterator_setter_f }
@FilterIterable_field_iterable = internal constant { ptr, ptr } { ptr @FilterIterable_getter_iterable, ptr @FilterIterable_setter_iterable }
@FilterIterable_field_f = internal constant { ptr, ptr } { ptr @FilterIterable_getter_f, ptr @FilterIterable_setter_f }
@FilterIterator_field_iterator = internal constant { ptr, ptr } { ptr @FilterIterator_getter_iterator, ptr @FilterIterator_setter_iterator }
@FilterIterator_field_f = internal constant { ptr, ptr } { ptr @FilterIterator_getter_f, ptr @FilterIterator_setter_f }
@ChainIterable_field_first = internal constant { ptr, ptr } { ptr @ChainIterable_getter_first, ptr @ChainIterable_setter_first }
@ChainIterable_field_second = internal constant { ptr, ptr } { ptr @ChainIterable_getter_second, ptr @ChainIterable_setter_second }
@ChainIterator_field_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_first, ptr @ChainIterator_setter_first }
@ChainIterator_field_second = internal constant { ptr, ptr } { ptr @ChainIterator_getter_second, ptr @ChainIterator_setter_second }
@ChainIterator_field_on_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_on_first, ptr @ChainIterator_setter_on_first }
@InterleaveIterable_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_first, ptr @InterleaveIterable_setter_first }
@InterleaveIterable_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_second, ptr @InterleaveIterable_setter_second }
@InterleaveIterator_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_first, ptr @InterleaveIterator_setter_first }
@InterleaveIterator_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_second, ptr @InterleaveIterator_setter_second }
@InterleaveIterator_field_on_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_on_first, ptr @InterleaveIterator_setter_on_first }
@ZipIterable_field_first = internal constant { ptr, ptr } { ptr @ZipIterable_getter_first, ptr @ZipIterable_setter_first }
@ZipIterable_field_second = internal constant { ptr, ptr } { ptr @ZipIterable_getter_second, ptr @ZipIterable_setter_second }
@ZipIterator_field_first = internal constant { ptr, ptr } { ptr @ZipIterator_getter_first, ptr @ZipIterator_setter_first }
@ZipIterator_field_second = internal constant { ptr, ptr } { ptr @ZipIterator_getter_second, ptr @ZipIterator_setter_second }
@ProductIterable_field_first = internal constant { ptr, ptr } { ptr @ProductIterable_getter_first, ptr @ProductIterable_setter_first }
@ProductIterable_field_second = internal constant { ptr, ptr } { ptr @ProductIterable_getter_second, ptr @ProductIterable_setter_second }
@ProductIterator_field_first_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_first_iterator, ptr @ProductIterator_setter_first_iterator }
@ProductIterator_field_second_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterator, ptr @ProductIterator_setter_second_iterator }
@ProductIterator_field_second_iterable = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterable, ptr @ProductIterator_setter_second_iterable }
@ProductIterator_field_current_first = internal constant { ptr, ptr } { ptr @ProductIterator_getter_current_first, ptr @ProductIterator_setter_current_first }
@Enumerator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3435222131909153872, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Enumerator_hashtbl, ptr @Enumerator_offset_tbl, ptr @_data_size_Enumerator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Enumerator_field_Enumerator_0, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_field_iterator, ptr @Enumerator_field_index, ptr @Enumerator_B_init_iteratorIteratorT, ptr @Enumerator_B_next_, ptr @Enumerator_init_iteratorIteratorT, ptr @Enumerator_next_, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_B_next_, ptr @Enumerator_next_] }
@MapIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -146553482626734782, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterator_hashtbl, ptr @MapIterator_offset_tbl, ptr @_data_size_MapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @MapIterator_field_MapIterator_0, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_field_iterator, ptr @MapIterator_field_f, ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_B_next_, ptr @MapIterator_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_next_, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_B_next_, ptr @MapIterator_next_] }
@ChainIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6043157723929225452, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterator_hashtbl, ptr @ChainIterator_offset_tbl, ptr @_data_size_ChainIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_field_first, ptr @ChainIterator_field_second, ptr @ChainIterator_field_on_first, ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_B_next_, ptr @ChainIterator_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_next_, ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_B_next_, ptr @ChainIterator_next_] }
@InterleaveIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3924664358248524505, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterator_hashtbl, ptr @InterleaveIterator_offset_tbl, ptr @_data_size_InterleaveIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_field_first, ptr @InterleaveIterator_field_second, ptr @InterleaveIterator_field_on_first, ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_next_, ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_next_] }
@ZipIterator = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 -2141114445739585318, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterator_hashtbl, ptr @ZipIterator_offset_tbl, ptr @_data_size_ZipIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @ZipIterator_field_ZipIterator_0, ptr @ZipIterator_field_ZipIterator_1, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_field_first, ptr @ZipIterator_field_second, ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_B_next_, ptr @ZipIterator_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_next_, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_B_next_, ptr @ZipIterator_next_] }
@ProductIterator = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 1697250377212095568, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterator_hashtbl, ptr @ProductIterator_offset_tbl, ptr @_data_size_ProductIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @ProductIterator_field_ProductIterator_0, ptr @ProductIterator_field_ProductIterator_1, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_field_first_iterator, ptr @ProductIterator_field_second_iterator, ptr @ProductIterator_field_second_iterable, ptr @ProductIterator_field_current_first, ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_B_next_, ptr @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_next_, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_B_next_, ptr @ProductIterator_next_] }
@Collection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr @Collection]
@Collection_offset_tbl = constant [8 x i32] [i32 67, i32 10, i32 0, i32 67, i32 0, i32 42, i32 0, i32 10]
@EnumeratedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr @EnumeratedCollection, ptr null, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@EnumeratedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 103, i32 10, i32 0, i32 128, i32 0, i32 46, i32 128]
@EnumeratedCollection = constant { [3 x i64], [7 x ptr], [118 x ptr] } { [3 x i64] [i64 7081690788784801875, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @EnumeratedCollection_hashtbl, ptr @EnumeratedCollection_offset_tbl, ptr @_data_size_EnumeratedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [118 x ptr] [ptr @EnumeratedCollection_field_EnumeratedCollection_0, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_field_collection, ptr @EnumeratedCollection_B_init_collectionCollectionT, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_init_collectionCollectionT, ptr @EnumeratedCollection_size_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_size_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MappedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr @MappedCollection, ptr @Collection]
@MappedCollection_offset_tbl = constant [8 x i32] [i32 129, i32 10, i32 0, i32 129, i32 0, i32 104, i32 10, i32 47]
@MappedCollection = constant { [3 x i64], [7 x ptr], [119 x ptr] } { [3 x i64] [i64 5460697656559120915, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MappedCollection_hashtbl, ptr @MappedCollection_offset_tbl, ptr @_data_size_MappedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [119 x ptr] [ptr @MappedCollection_field_MappedCollection_0, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_field_collection, ptr @MappedCollection_field_f, ptr @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_init_collectionCollectionT_fFunctionT_to_U, ptr @MappedCollection_size_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_size_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainedCollection_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @Collection, ptr @ChainedCollection, ptr @Container, ptr @Iterable, ptr null]
@ChainedCollection_offset_tbl = constant [8 x i32] [i32 0, i32 128, i32 10, i32 46, i32 10, i32 128, i32 103, i32 0]
@ChainedCollection = constant { [3 x i64], [7 x ptr], [118 x ptr] } { [3 x i64] [i64 -4136536984535342799, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainedCollection_hashtbl, ptr @ChainedCollection_offset_tbl, ptr @_data_size_ChainedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [118 x ptr] [ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_field_first, ptr @ChainedCollection_field_second, ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_size_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_size_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleavedCollection_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleavedCollection, ptr @Iterable, ptr null, ptr @Collection]
@InterleavedCollection_offset_tbl = constant [8 x i32] [i32 128, i32 10, i32 0, i32 128, i32 10, i32 103, i32 0, i32 46]
@InterleavedCollection = constant { [3 x i64], [7 x ptr], [118 x ptr] } { [3 x i64] [i64 8589355597059143861, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleavedCollection_hashtbl, ptr @InterleavedCollection_offset_tbl, ptr @_data_size_InterleavedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [118 x ptr] [ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_field_first, ptr @InterleavedCollection_field_second, ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_size_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_size_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZippedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Collection, ptr @Object, ptr @Container, ptr @ZippedCollection, ptr @Iterable, ptr null, ptr null]
@ZippedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 48, i32 130, i32 130, i32 10, i32 105, i32 0, i32 0]
@ZippedCollection = constant { [3 x i64], [7 x ptr], [120 x ptr] } { [3 x i64] [i64 880335312586431241, i64 4611686018427388513, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZippedCollection_hashtbl, ptr @ZippedCollection_offset_tbl, ptr @_data_size_ZippedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [120 x ptr] [ptr @ZippedCollection_field_ZippedCollection_0, ptr @ZippedCollection_field_ZippedCollection_1, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_field_first, ptr @ZippedCollection_field_second, ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_size_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_size_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ProductCollection, ptr @Container, ptr null, ptr @Collection, ptr @Object]
@ProductCollection_offset_tbl = constant [8 x i32] [i32 10, i32 105, i32 0, i32 10, i32 130, i32 0, i32 48, i32 130]
@ProductCollection = constant { [3 x i64], [7 x ptr], [120 x ptr] } { [3 x i64] [i64 -310975631771072937, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductCollection_hashtbl, ptr @ProductCollection_offset_tbl, ptr @_data_size_ProductCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [120 x ptr] [ptr @ProductCollection_field_ProductCollection_0, ptr @ProductCollection_field_ProductCollection_1, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_field_first, ptr @ProductCollection_field_second, ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_size_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_size_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@EnumeratedCollection_field_collection = internal constant { ptr, ptr } { ptr @EnumeratedCollection_getter_collection, ptr @EnumeratedCollection_setter_collection }
@MappedCollection_field_collection = internal constant { ptr, ptr } { ptr @MappedCollection_getter_collection, ptr @MappedCollection_setter_collection }
@MappedCollection_field_f = internal constant { ptr, ptr } { ptr @MappedCollection_getter_f, ptr @MappedCollection_setter_f }
@ChainedCollection_field_first = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_first, ptr @ChainedCollection_setter_first }
@ChainedCollection_field_second = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_second, ptr @ChainedCollection_setter_second }
@InterleavedCollection_field_first = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_first, ptr @InterleavedCollection_setter_first }
@InterleavedCollection_field_second = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_second, ptr @InterleavedCollection_setter_second }
@ZippedCollection_field_first = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_first, ptr @ZippedCollection_setter_first }
@ZippedCollection_field_second = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_second, ptr @ZippedCollection_setter_second }
@ProductCollection_field_first = internal constant { ptr, ptr } { ptr @ProductCollection_getter_first, ptr @ProductCollection_setter_first }
@ProductCollection_field_second = internal constant { ptr, ptr } { ptr @ProductCollection_getter_second, ptr @ProductCollection_setter_second }
@_parameterization_Character = linkonce_odr constant [2 x ptr] [ptr @Character, ptr null]
@modls_The_size_of_the_collection_being_indexed_was = internal unnamed_addr constant [44 x i8] c"The size of the collection being indexed was", align 64
@wapia_An_outofbounds_error_occurred_while_indexing_into_a_collection = internal unnamed_addr constant [65 x i8] c"An out-of-bounds error occurred while indexing into a collection.", align 128
@_parameterization_i8 = linkonce_odr constant [2 x ptr] [ptr @i8_typ, ptr null]
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 12]
@String_hashtbl = constant [16 x ptr] [ptr @String, ptr @Representable, ptr @Collection, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr null, ptr null, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr null, ptr null, ptr null]
@String_offset_tbl = constant [16 x i32] [i32 10, i32 157, i32 75, i32 10, i32 0, i32 157, i32 0, i32 0, i32 0, i32 132, i32 157, i32 0, i32 0, i32 0, i32 0, i32 0]
@Character_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = constant [4 x i32] [i32 15, i32 0, i32 10, i32 10]
@StringIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @StringIterator, ptr null]
@StringIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 0, i32 17, i32 10, i32 0]
@Exception_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = constant [4 x i32] [i32 27, i32 0, i32 10, i32 10]
@OutOfBounds_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Exception, ptr @OutOfBounds, ptr @Object]
@OutOfBounds_offset_tbl = constant [4 x i32] [i32 10, i32 30, i32 10, i32 47]
@OutOfBoundsDetails_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @OutOfBoundsDetails]
@OutOfBoundsDetails_offset_tbl = constant [4 x i32] [i32 16, i32 0, i32 10, i32 10]
@OutOfBoundsDetails = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 4650630525701360429, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBoundsDetails_hashtbl, ptr @OutOfBoundsDetails_offset_tbl, ptr @_data_size_OutOfBoundsDetails, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @OutOfBoundsDetails_field_bounds, ptr @OutOfBoundsDetails_field_index, ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_B_report_, ptr @OutOfBoundsDetails_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_report_] }
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_length = internal constant { ptr, ptr } { ptr @String_getter_length, ptr @String_setter_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_byte = internal constant { ptr, ptr } { ptr @Character_getter_byte, ptr @Character_setter_byte }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_index, ptr @StringIterator_setter_index }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@Exception_field_stacktrace = internal constant { ptr, ptr } { ptr @Exception_getter_stacktrace, ptr @Exception_setter_stacktrace }
@Exception_field_n_frames = internal constant { ptr, ptr } { ptr @Exception_getter_n_frames, ptr @Exception_setter_n_frames }
@OutOfBounds_field_details = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_details, ptr @OutOfBounds_setter_details }
@OutOfBounds_field_line_number = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_line_number, ptr @OutOfBounds_setter_line_number }
@OutOfBounds_field_file_name = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_file_name, ptr @OutOfBounds_setter_file_name }
@OutOfBounds_field_message = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_message, ptr @OutOfBounds_setter_message }
@OutOfBounds_field_stacktrace = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_stacktrace, ptr @OutOfBounds_setter_stacktrace }
@OutOfBounds_field_n_frames = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_n_frames, ptr @OutOfBounds_setter_n_frames }
@OutOfBoundsDetails_field_bounds = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_bounds, ptr @OutOfBoundsDetails_setter_bounds }
@OutOfBoundsDetails_field_index = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_index, ptr @OutOfBoundsDetails_setter_index }
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@IO_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 20]
@IO = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_data_size_IO, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @IO_B__Self_print_xBool__Self_print_xi32__Self_print_xf64__Self_print_xi8__Self_print_xi64__Self_print_xNil__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xString, ptr @IO__Self_print_xBool, ptr @IO__Self_print_xi32, ptr @IO__Self_print_xf64, ptr @IO__Self_print_xi8, ptr @IO__Self_print_xi64, ptr @IO__Self_print_xNil, ptr @IO__Self_print_xCharacter, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xString] }
@_parameterization_i64 = linkonce_odr constant [2 x ptr] [ptr @i64_typ, ptr null]
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@uagtt_CUsersPaulKOneDriveDocumentsPLPyPLlibarraymini = internal unnamed_addr constant [56 x i8] c"C:\\Users\\PaulK\\OneDrive\\Documents\\PL\\PyPL\\lib\\array.mini", align 64
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@Collection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 1375598993350293883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Collection_hashtbl, ptr @Collection_offset_tbl, ptr @_data_size_Collection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@OutOfBounds = constant { [3 x i64], [7 x ptr], [37 x ptr] } { [3 x i64] [i64 5348403617834207535, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBounds_hashtbl, ptr @OutOfBounds_offset_tbl, ptr @_data_size_OutOfBounds, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [37 x ptr] [ptr @OutOfBounds_field_details, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_field_n_frames, ptr @OutOfBounds_B_init_boundsi32_indexi32, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_print_stacktrace_, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @OutOfBounds_init_boundsi32_indexi32, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @OutOfBounds_print_message_, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_field_n_frames, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_print_stacktrace_, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @OutOfBounds_print_message_] }
@Array_hashtbl = constant [16 x ptr] [ptr null, ptr @Representable, ptr @Collection, ptr @any_typ, ptr null, ptr @Container, ptr @Array, ptr null, ptr null, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr null, ptr null, ptr null]
@Array_offset_tbl = constant [16 x i32] [i32 0, i32 157, i32 75, i32 10, i32 0, i32 157, i32 10, i32 0, i32 0, i32 132, i32 157, i32 0, i32 0, i32 0, i32 0, i32 0]
@Array = constant { [3 x i64], [7 x ptr], [149 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427389773, i64 15], [7 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_data_size_Array, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [149 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_init_, ptr @Array_B_init_capacityi32, ptr @Array_B_init_lengthi32_capacityi32, ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_B_length_, ptr @Array_B_capacity_, ptr @Array_B_append_xT, ptr @Array_B_extend_otherArrayT, ptr @Array_B_reserve_new_capacityi32, ptr @Array_B__index_xi32, ptr @Array_B__set_index_xi32_valueT, ptr @Array_B_unchecked_index_xi32, ptr @Array_B_unchecked_insert_xi32_valueT, ptr @Array_B_size_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_B_repr_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_init_, ptr @Array_init_capacityi32, ptr @Array_init_lengthi32_capacityi32, ptr @Array_init_bufferBufferT_lengthi32_capacityi32, ptr @Array_length_, ptr @Array_capacity_, ptr @Array_append_xT, ptr @Array_extend_otherArrayT, ptr @Array_reserve_new_capacityi32, ptr @Array__index_xi32, ptr @Array__set_index_xi32_valueT, ptr @Array_unchecked_index_xi32, ptr @Array_unchecked_insert_xi32_valueT, ptr @Array_size_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_repr_, ptr @Array_field_Array_0, ptr @Array_B_size_, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_size_, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Bool, ptr @Array_B_any_fFunctionT_to_Bool, ptr @Array_B_enumerate_, ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Bool, ptr @Array_B_chain_otherIterableT_chain_otherCollectionT, ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU_zip_otherCollectionU, ptr @Array_B_product_otherIterableU_product_otherCollectionU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_B_repr_, ptr @Array_repr_] }
@ArrayIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @ArrayIterator, ptr @Iterator, ptr null, ptr null]
@ArrayIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 10, i32 17, i32 0, i32 0]
@ArrayIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_data_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@_parameterization_Bufferi8 = linkonce_odr constant [2 x ptr] [ptr @buffer_typ, ptr null]
@fsifx_CUsersPaulKOneDriveDocumentsPLPyPLlibmapmini = internal unnamed_addr constant [54 x i8] c"C:\\Users\\PaulK\\OneDrive\\Documents\\PL\\PyPL\\lib\\map.mini", align 64
@String = constant { [3 x i64], [7 x ptr], [149 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427389773, i64 15], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [149 x ptr] [ptr @String_field_bytes, ptr @String_field_length, ptr @String_field_capacity, ptr @String_field_String_0, ptr @String_B__Self_from_c_string_c_stringBufferi8, ptr @String_B_init_, ptr @String_B_init_lengthi32_capacityi32, ptr @String_B_init_bytesBufferi8_lengthi32_capacityi32, ptr @String_B_length_, ptr @String_B_capacity_, ptr @String_B_c_string_, ptr @String_B_append_xi8, ptr @String_B_extend_otherString, ptr @String_B_reserve_new_capacityi32, ptr @String_B__EQ_otherString, ptr @String_B_unchecked_index_xi32, ptr @String_B_unchecked_insert_xi32_valuei8, ptr @String_B_copy_, ptr @String_B_size_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_B_repr_, ptr @String__Self_from_c_string_c_stringBufferi8, ptr @String_init_, ptr @String_init_lengthi32_capacityi32, ptr @String_init_bytesBufferi8_lengthi32_capacityi32, ptr @String_length_, ptr @String_capacity_, ptr @String_c_string_, ptr @String_append_xi8, ptr @String_extend_otherString, ptr @String_reserve_new_capacityi32, ptr @String__EQ_otherString, ptr @String_unchecked_index_xi32, ptr @String_unchecked_insert_xi32_valuei8, ptr @String_copy_, ptr @String_size_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_repr_, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_size_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Collection_chain_otherCollectionT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherIterableT_chain_otherCollectionT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_B_repr_, ptr @String_repr_] }
@Character = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @Character_field_byte, ptr @Character_B_init_bytei8, ptr @Character_B_byte_, ptr @Character_init_bytei8, ptr @Character_byte_] }
@StringIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_index, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_] }
@Exception = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_field_stacktrace, ptr @Exception_field_n_frames, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberi32_file_nameString, ptr @Exception_B_print_stacktrace_, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @Exception_print_message_] }
@KeyNotFound_hashtbl = constant [4 x ptr] [ptr @Object, ptr @KeyNotFound, ptr @any_typ, ptr @Exception]
@KeyNotFound_offset_tbl = constant [4 x i32] [i32 44, i32 10, i32 10, i32 27]
@KeyNotFound = constant { [3 x i64], [7 x ptr], [34 x ptr] } { [3 x i64] [i64 2946564862774055400, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @KeyNotFound_hashtbl, ptr @KeyNotFound_offset_tbl, ptr @_data_size_KeyNotFound, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [34 x ptr] [ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_field_n_frames, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_print_stacktrace_, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @Exception_print_message_, ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_field_stacktrace, ptr @KeyNotFound_field_n_frames, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString, ptr @KeyNotFound_B_print_stacktrace_, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_print_stacktrace_, ptr @Exception_report_, ptr @Exception_print_message_] }
@Map_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr null, ptr @Object]
@Map_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 49, i32 10, i32 74, i32 10, i32 0, i32 74]
@HashMap_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr @HashMap, ptr @Object]
@HashMap_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 113, i32 10, i32 138, i32 49, i32 10, i32 138]
@KeyNotFound_field_line_number = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_line_number, ptr @KeyNotFound_setter_line_number }
@KeyNotFound_field_file_name = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_file_name, ptr @KeyNotFound_setter_file_name }
@KeyNotFound_field_message = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_message, ptr @KeyNotFound_setter_message }
@KeyNotFound_field_stacktrace = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_stacktrace, ptr @KeyNotFound_setter_stacktrace }
@KeyNotFound_field_n_frames = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_n_frames, ptr @KeyNotFound_setter_n_frames }
@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Pair = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_init_firstT_secondU, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_] }
@Container = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 9056556090793359372, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Container_hashtbl, ptr @Container_offset_tbl, ptr @_data_size_Container, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388349, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388477, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Map = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5249855671126779970, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Map_hashtbl, ptr @Map_offset_tbl, ptr @_data_size_Map, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@HashMap = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_data_size_HashMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Entry_hashtbl = constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = constant [4 x i32] [i32 10, i32 25, i32 10, i32 0]
@Entry = constant { [3 x i64], [7 x ptr], [15 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_data_size_Entry, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [15 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_primary_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_init_keyK_valueV_primary_hashi32, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_primary_hash_, ptr @Entry_B_to_pair_, ptr @Entry_init_keyK_valueV_primary_hashi32, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_primary_hash_, ptr @Entry_to_pair_] }
@CuckooMap_hashtbl = constant [8 x ptr] [ptr null, ptr @CuckooMap, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr @HashMap, ptr @Object]
@CuckooMap_offset_tbl = constant [8 x i32] [i32 0, i32 10, i32 273, i32 10, i32 298, i32 209, i32 81, i32 298]
@CuckooMap = constant { [3 x i64], [7 x ptr], [288 x ptr] } { [3 x i64] [i64 3547150501766965522, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @CuckooMap_hashtbl, ptr @CuckooMap_offset_tbl, ptr @_data_size_CuckooMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [288 x ptr] [ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_field_table1, ptr @CuckooMap_field_table2, ptr @CuckooMap_field_table_len, ptr @CuckooMap_field_size, ptr @CuckooMap_field_hasher, ptr @CuckooMap_field_eq, ptr @CuckooMap_B__Self_max_displacements_, ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_B_hash1_keyK, ptr @CuckooMap_B_hash2_from_primary_primary_hashi32, ptr @CuckooMap_B_index1_primary_hashi32, ptr @CuckooMap_B_index2_primary_hashi32, ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32, ptr @CuckooMap_B_resize_, ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap__Self_max_displacements_, ptr @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool, ptr @CuckooMap_hash1_keyK, ptr @CuckooMap_hash2_from_primary_primary_hashi32, ptr @CuckooMap_index1_primary_hashi32, ptr @CuckooMap_index2_primary_hashi32, ptr @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32, ptr @CuckooMap_resize_, ptr @CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Bool, ptr @CuckooMap_B_any_fFunctionT_to_Bool, ptr @CuckooMap_B_enumerate_, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Bool, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@CuckooMapIterator_hashtbl = constant [8 x ptr] [ptr @CuckooMapIterator, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr null]
@CuckooMapIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 27, i32 24, i32 27, i32 0, i32 10, i32 0]
@CuckooMapIterator = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 -1975748647346050920, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @CuckooMapIterator_hashtbl, ptr @CuckooMapIterator_offset_tbl, ptr @_data_size_CuckooMapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @CuckooMapIterator_field_CuckooMapIterator_0, ptr @CuckooMapIterator_field_CuckooMapIterator_1, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_field_map_table1, ptr @CuckooMapIterator_field_map_table2, ptr @CuckooMapIterator_field_table_len, ptr @CuckooMapIterator_field_index, ptr @CuckooMapIterator_field_on_second, ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, ptr @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_next_, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_next_] }
@Entry_field_primary_hash = internal constant { ptr, ptr } { ptr @Entry_getter_primary_hash, ptr @Entry_setter_primary_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@CuckooMap_field_table1 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table1, ptr @CuckooMap_setter_table1 }
@CuckooMap_field_table2 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table2, ptr @CuckooMap_setter_table2 }
@CuckooMap_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table_len, ptr @CuckooMap_setter_table_len }
@CuckooMap_field_size = internal constant { ptr, ptr } { ptr @CuckooMap_getter_size, ptr @CuckooMap_setter_size }
@CuckooMap_field_hasher = internal constant { ptr, ptr } { ptr @CuckooMap_getter_hasher, ptr @CuckooMap_setter_hasher }
@CuckooMap_field_eq = internal constant { ptr, ptr } { ptr @CuckooMap_getter_eq, ptr @CuckooMap_setter_eq }
@CuckooMapIterator_field_map_table1 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table1, ptr @CuckooMapIterator_setter_map_table1 }
@CuckooMapIterator_field_map_table2 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table2, ptr @CuckooMapIterator_setter_map_table2 }
@CuckooMapIterator_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_table_len, ptr @CuckooMapIterator_setter_table_len }
@CuckooMapIterator_field_index = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_index, ptr @CuckooMapIterator_setter_index }
@CuckooMapIterator_field_on_second = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_on_second, ptr @CuckooMapIterator_setter_on_second }

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #0 {
  %hash = call i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id)
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_PRNG(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

define { ptr, i160 } @_box_Default(ptr %fat_ptr, ptr %parameterization) {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 4
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr %parameterization, ptr %destination) {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 4
  ret void
}

define { i64, i64 } @_size_Default(ptr %parameterization) {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @PRNG_init_initial_seedi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(120) @PRNG)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %. = call i32 @llvm.smax.i32(i32 %3, i32 1)
  call void %17(ptr %9, i32 %.) #30
  ret void
}

define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(120) @PRNG)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i32 %15(ptr %8) #31
  %17 = mul i32 %16, 1103515245
  %18 = add i32 %17, 12345
  %19 = and i32 %18, 2147483647
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %9)
  %21 = getelementptr i8, ptr %14, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %8, i32 %19) #30
  %23 = load ptr, ptr %5, align 8
  %24 = load ptr, ptr %4, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %24)
  %26 = load i32, ptr %7, align 8
  %27 = sext i32 %26 to i64
  %28 = getelementptr ptr, ptr %24, i64 %27
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call i32 %30(ptr %23) #31
  ret i32 %31
}

define void @set_offset(ptr %fat_ptr, ptr %id_ptr) {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id_of_casted = load i64, ptr %vptr, align 4
  %offset = call i32 @get_offset(ptr %vptr, ptr %id_ptr)
  %destination = getelementptr { ptr, ptr, ptr, i32 }, ptr %fat_ptr, i32 0, i32 3
  store i32 %offset, ptr %destination, align 4
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #4

define i32 @get_offset(ptr %vptr, ptr %id_ptr) {
  %id = load i64, ptr %id_ptr, align 4
  %id_of_casted = load i64, ptr %vptr, align 4
  %hash_coef_ptr = getelementptr i64, ptr %vptr, i32 1
  %tbl_size_ptr = getelementptr i64, ptr %vptr, i32 2
  %offset_tbl_ptr = getelementptr ptr, ptr %vptr, i32 5
  %hash_coef = load i64, ptr %hash_coef_ptr, align 4
  %tbl_size = load i64, ptr %tbl_size_ptr, align 4
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %index = call i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %id)
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %index
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %product, %shifted
  %hash = and i64 %xored, %tbl_size
  %bug = icmp sgt i64 %hash, %tbl_size
  ret i64 %hash
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #5

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define ptr @typegetter_wrapper(ptr %f, ptr nocapture nofree noundef nonnull readonly %0) #8 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull readonly %0) #32
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { i64, i64 } @size_wrapper(ptr %f, ptr nocapture nofree readonly %0) #8 {
  %result = call { i64, i64 } %f(ptr nocapture nofree readonly %0) #32
  ret { i64, i64 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { ptr, i160 } @box_wrapper(ptr %f, ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #8 {
  %result = call { ptr, i160 } %f(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #32
  ret { ptr, i160 } %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @unbox_wrapper(ptr %f, { ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #9 {
  call void %f({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #33
  ret void
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @behavior_wrapper(ptr %f, { ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #10 {
  %result = call ptr %f({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #34
  ret ptr %result
}

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @class_behavior_wrapper(ptr %f, ptr nocapture nofree noundef nonnull %0) #10 {
  %result = call ptr %f(ptr nocapture nofree noundef nonnull %0) #34
  ret ptr %result
}

; Function Attrs: alwaysinline
define ptr @adjust_trampoline(ptr %tramp) #11 {
  %ret = call ptr @llvm.adjust.trampoline(ptr %tramp) #35
  ret ptr %ret
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #12

; Function Attrs: alwaysinline mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc(i64 noundef %size) #13 {
  %result = call noalias ptr @bump_malloc_wrapper(i64 noundef %size) #16
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc_wrapper(i64 noundef %size) #14 {
  %result = call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr @current_ptr) #16
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr %current_ptr) #14 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  ret ptr %current
}

define { i64, i64 } @_data_size_tuple_typ(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 %12, i64 %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add nuw i64 %11, %.reg2mem22.011
  %19 = add nuw i64 %18, %17
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem20.0.lcssa = phi i64 [ 1, %1 ], [ %13, %.lr.ph ]
  %.reg2mem22.0.lcssa = phi i64 [ 0, %1 ], [ %19, %.lr.ph ]
  %24 = urem i64 %.reg2mem22.0.lcssa, %.reg2mem20.0.lcssa
  %25 = icmp eq i64 %24, 0
  %26 = sub nuw i64 %.reg2mem20.0.lcssa, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add nuw i64 %27, %.reg2mem22.0.lcssa
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa, 1
  ret { i64, i64 } %30
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #5

define { i64, i64 } @_data_size_union_typ(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph, %1
  %.in = phi i64 [ %22, %.lr.ph ], [ %3, %1 ]
  %5 = phi i64 [ %20, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011 = phi i64 [ %19, %.lr.ph ], [ 0, %1 ]
  %.reg2mem20.010 = phi i64 [ %13, %.lr.ph ], [ 1, %1 ]
  %6 = inttoptr i64 %.in to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = call { i64, i64 } %9(ptr nonnull %6)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = call i64 @llvm.umax.i64(i64 noundef %12, i64 noundef %.reg2mem20.010)
  %14 = urem i64 %.reg2mem22.011, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = call i64 @llvm.umax.i64(i64 noundef %11, i64 noundef %.reg2mem22.011)
  %19 = call i64 @llvm.umax.i64(i64 noundef %18, i64 noundef %17)
  %20 = add nuw i64 %5, 1
  %21 = getelementptr ptr, ptr %0, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem20.0.lcssa = phi i64 [ 1, %1 ], [ %13, %.lr.ph ]
  %.reg2mem22.0.lcssa = phi i64 [ 0, %1 ], [ %19, %.lr.ph ]
  %right_size = icmp eq i64 %.reg2mem22.0.lcssa, 32
  %flag_size = select i1 %right_size, i64 0, i64 8
  %final_size = add i64 %.reg2mem22.0.lcssa, %flag_size
  %24 = urem i64 %final_size, %.reg2mem20.0.lcssa
  %25 = icmp eq i64 %24, 0
  %26 = sub nuw i64 %.reg2mem20.0.lcssa, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add nuw i64 %27, %final_size
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa, 1
  ret { i64, i64 } %30
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr %1, ptr %dest) {
  %3 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %3, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @_data_size_union_typ(ptr %1)
  %size = extractvalue { i64, i64 } %6, 0
  %7 = icmp sle i64 %size, 16
  %8 = icmp eq i64 %size, 32
  %9 = select i1 %7, ptr %4, ptr %5
  %source = select i1 %8, ptr %3, ptr %9
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %dest, ptr %source, i64 %size, i1 false)
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #15

define ptr @coroutine_create(ptr %func, ptr %arg_passer) {
  %stack = call noalias ptr @virtual_reserve(i64 8388608) #16
  %func_ptr = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %stack, i32 0, i32 0
  store ptr %func, ptr %func_ptr, align 8
  %stack_top = getelementptr i8, ptr %stack, i64 8388512
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %stack, i32 0, i32 1
  %arg_passer_slot = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %stack, i32 0, i32 2
  %into_callee_first_word = getelementptr [3 x ptr], ptr %into_callee_buf, i32 0, i32 0
  %into_callee_second_word = getelementptr [3 x ptr], ptr %into_callee_buf, i32 0, i32 1
  %into_callee_third_word = getelementptr [3 x ptr], ptr %into_callee_buf, i32 0, i32 2
  store i64 %stack_top_aligned, ptr %into_callee_first_word, align 4
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 4
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %stack, i32 0, i32 3
  store i1 false, ptr %is_finished, align 1
  call void @coroutine_trampoline(ptr %into_callee_second_word)
  ret ptr %stack
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0)
define noalias ptr @virtual_reserve(i64 %size) #16 {
  %result = call noalias ptr @VirtualAlloc(ptr null, i64 %size, i32 12288, i32 4) #19
  ret ptr %result
}

define void @coroutine_trampoline(ptr %into_callee_second_word) {
  store ptr blockaddress(@coroutine_trampoline, %trampoline), ptr %into_callee_second_word, align 8
  %result = call i1 @returns_one()
  br i1 %result, label %exit, label %trampoline

trampoline:                                       ; preds = %0
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  %arg_passer_ptr = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %current_coroutine, i32 0, i32 2
  %arg_passer = load ptr, ptr %arg_passer_ptr, align 8
  call void %arg_passer(ptr %current_coroutine)
  %current_coroutine2 = load ptr, ptr @current_coroutine, align 8
  %is_finished_ptr = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %current_coroutine2, i32 0, i32 3
  store i1 true, ptr %is_finished_ptr, align 1
  call void @llvm.eh.sjlj.longjmp(ptr @into_caller_buf) #18
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: noinline
define i1 @returns_one() #17 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #18

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare noalias ptr @VirtualAlloc(ptr, i64, i32, i32) #19

define void @setup_landing_pad() {
  %region = call noalias ptr @virtual_reserve(i64 5368709120) #16
  store ptr %region, ptr @current_ptr, align 8
  %buf_first_word = getelementptr [3 x ptr], ptr @into_caller_buf, i32 0, i32 0
  %buf_second_word = getelementptr [3 x ptr], ptr @into_caller_buf, i32 0, i32 1
  %buf_third_word = getelementptr [3 x ptr], ptr @into_caller_buf, i32 0, i32 2
  %sp = call ptr @llvm.stacksave.p0() #36
  store ptr %sp, ptr %buf_first_word, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr %buf_second_word, align 8
  store ptr %sp, ptr %buf_third_word, align 8
  %current_coroutine = call ptr @coroutine_create(ptr @setup_landing_pad, ptr @arg_passer)
  store ptr %current_coroutine, ptr @current_coroutine, align 8
  %result = call i1 @returns_one()
  br i1 %result, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = call i32 @printf(ptr @string_string, ptr @exception_message)
  %cc = load { ptr }, ptr @current_coroutine, align 8
  call void @report_exception({ ptr } %cc)
  call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #20

define void @arg_passer(ptr %current_coroutine) {
  %func_ptr = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %current_coroutine, i32 0, i32 0
  %func = load ptr, ptr %func_ptr, align 8
  call void %func()
  ret void
}

declare i32 @printf(ptr, ...)

declare void @exit()

define void @assume_offset(ptr %fat_ptr, ptr %id_ptr) {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id_of_casted = load i64, ptr %vptr, align 4
  %offset = call i32 @get_offset(ptr %vptr, ptr %id_ptr)
  %destination = getelementptr { ptr, ptr, ptr, i32 }, ptr %fat_ptr, i32 0, i32 3
  %dest_value = load i32, ptr %destination, align 4
  %slot = alloca i32, align 4
  store i32 %dest_value, ptr %slot, align 4
  %slotval = load i32, ptr %slot, align 4
  %eq = icmp eq i32 %slotval, %offset
  call void @llvm.assume(i1 %eq) #37
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)
declare void @llvm.assume(i1 noundef) #21

; Function Attrs: alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #8 {
  %result = call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #32
  ret i1 %result
}

define void @arg_buffer_filler(ptr %coroutine) {
  ret void
}

define ptr @get_current_coroutine() {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture writeonly %from_buf, ptr %to_buf) #22 {
  %from_buf_first_word = getelementptr [3 x ptr], ptr %from_buf, i32 0, i32 0
  %from_buf_second_word = getelementptr [3 x ptr], ptr %from_buf, i32 0, i32 1
  %from_buf_third_word = getelementptr [3 x ptr], ptr %from_buf, i32 0, i32 2
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = call ptr @llvm.stacksave.p0() #36
  store ptr %sp, ptr %from_buf_first_word, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %is_first_time = call i1 @returns_one()
  br i1 %is_first_time, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #18
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

define void @coroutine_yield(ptr %current_coroutine) {
  %into_callee_buf = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %current_coroutine, i32 0, i32 1
  call preserve_nonecc void @context_switch(ptr nocapture writeonly %into_callee_buf, ptr @into_caller_buf) #38
  ret void
}

; Function Attrs: cold noinline
define void @coroutine_yield_cold(ptr %current_coroutine) #23 {
  call void @coroutine_yield(ptr %current_coroutine)
  ret void
}

define void @coroutine_call(ptr %coroutine) {
  %old_into_caller = load [3 x ptr], ptr @into_caller_buf, align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr { ptr, [3 x ptr], ptr, i1 }, ptr %coroutine, i32 0, i32 1
  call preserve_nonecc void @context_switch(ptr nocapture writeonly @into_caller_buf, ptr %into_callee_buf) #38
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store [3 x ptr] %old_into_caller, ptr @into_caller_buf, align 8
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr %tramp) #24 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr %tramp, i64 16, i32 64, ptr %oldProtect)
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) #24

define void @print_backtrace(ptr %backtrace, i64 %n_frames) {
  %start_indvar = sub i64 %n_frames, 1
  %handle = tail call ptr @GetCurrentProcess()
  %1 = tail call i32 @SymInitialize(ptr %handle, ptr null, i32 1)
  %2 = alloca [344 x i8], align 1
  call void @llvm.memset.p0.i64(ptr %2, i8 0, i64 344, i1 false)
  %3 = getelementptr inbounds i8, ptr %2, i64 80
  store i32 255, ptr %3, align 4
  store i32 88, ptr %2, align 4
  %.not = icmp eq i64 %n_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %0
  %4 = getelementptr inbounds i8, ptr %2, i64 56
  %5 = getelementptr inbounds i8, ptr %2, i64 84
  br label %6

6:                                                ; preds = %6, %.lr.ph
  %indvars.iv = phi i64 [ %start_indvar, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %7 = getelementptr inbounds [100 x ptr], ptr %backtrace, i64 0, i64 %indvars.iv
  %8 = load ptr, ptr %7, align 8
  %9 = ptrtoint ptr %8 to i64
  %10 = call i32 @SymFromAddr(ptr %handle, i64 %9, ptr null, ptr %2)
  %11 = load i64, ptr %4, align 8
  %12 = call i32 (ptr, ...) @printf(ptr @backtrace_string, i64 %indvars.iv, ptr %5, i64 %11)
  %indvars.iv.next = sub nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp slt i64 %indvars.iv.next, 0
  br i1 %exitcond.not, label %._crit_edge, label %6

._crit_edge:                                      ; preds = %6, %0
  %13 = call i32 @SymCleanup(ptr %handle)
  ret void
}

declare ptr @GetCurrentProcess() local_unnamed_addr

declare i32 @SymInitialize(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #25

declare i32 @SymFromAddr(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr

declare i32 @SymCleanup(ptr) local_unnamed_addr

define i64 @capture_backtrace(i64 %max_frames, ptr %backtrace) {
entry:
  %context = alloca %struct._CONTEXT, align 16
  call void @RtlCaptureContext(ptr %context)
  %rip = getelementptr inbounds %struct._CONTEXT, ptr %context, i32 0, i32 37
  %img_base_ptr = alloca i64, align 8
  %0 = alloca ptr, align 8
  %1 = alloca i64, align 8
  %.not = icmp eq i64 %max_frames, 0
  br i1 %.not, label %._crit_edge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %entry
  %.pre = load i64, ptr %rip, align 8
  br label %.lr.ph

.lr.ph:                                           ; preds = %3, %.lr.ph.preheader
  %2 = phi i64 [ %.pre, %.lr.ph.preheader ], [ %6, %3 ]
  %indvars.iv = phi i64 [ 0, %.lr.ph.preheader ], [ %indvars.iv.next, %3 ]
  %n_captured = sub i64 %indvars.iv, 4
  %fentry = call ptr @RtlLookupFunctionEntry(i64 %2, ptr %img_base_ptr, ptr null)
  %img_base = load i64, ptr %img_base_ptr, align 8
  %fentry_null = icmp eq ptr %fentry, null
  %img_base_null = icmp eq i64 %img_base, 0
  %either = or i1 %fentry_null, %img_base_null
  br i1 %either, label %._crit_edge, label %3

3:                                                ; preds = %.lr.ph
  %4 = load i64, ptr %rip, align 8
  %5 = call ptr @RtlVirtualUnwind(i32 0, i64 %img_base, i64 %4, ptr %fentry, ptr %context, ptr %0, ptr %1, ptr null)
  %6 = load i64, ptr %rip, align 8
  %7 = inttoptr i64 %6 to ptr
  %8 = getelementptr inbounds ptr, ptr %backtrace, i64 %indvars.iv
  store ptr %7, ptr %8, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %max_frames
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %3, %.lr.ph, %entry
  %.0.lcssa = phi i64 [ 0, %entry ], [ %n_captured, %.lr.ph ], [ %max_frames, %3 ]
  ret i64 %.0.lcssa
}

declare void @RtlCaptureContext(ptr)

declare ptr @RtlLookupFunctionEntry(i64, ptr, ptr)

declare ptr @RtlVirtualUnwind(i32, i64, i64, ptr, ptr, ptr, ptr, ptr)

define i1 @sxmbvaaqjx(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @axlhmwbuwo(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ytebrvjgff(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @nivqqmixpq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @hnbsvmhnda(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @agkclrhtzs(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @pvnidioudp(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @hbaqvtggfm(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @cfjkgytwfj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @hkbtwjjhqj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @vaxeopwwdi(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @oxgghllhom(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @uvhofywczn(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @drgmnjsbrc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @weyllhhkpb(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @nyfuylfwaq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @genyhirpvr(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @vimoiwpapu(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ewafwzhivv(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) #3 {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @egohsgumaa(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) #3 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr #3 {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca [3 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %16 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %16, i64 8
  store ptr %.fca.1.extract, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %16, i64 16
  store ptr %.fca.2.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %16, i64 24
  store i32 %.fca.3.extract, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %16, ptr noundef nonnull align 8 dereferenceable(1248) @String)
  %20 = load ptr, ptr %16, align 8
  %21 = insertvalue { ptr, i160 } undef, ptr %20, 0
  %22 = load i160, ptr %17, align 8
  %23 = insertvalue { ptr, i160 } %21, i160 %22, 1
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %27 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  %28 = alloca { ptr }, align 8
  store ptr %20, ptr %28, align 8
  %29 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %28)
  call void %29(ptr nonnull %24, { ptr, i160 } %23) #39
  %30 = call ptr @bump_malloc(i64 noundef 15)
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %30, align 1
  %31 = alloca [1 x ptr], align 8
  store ptr @String, ptr %31, align 8
  %32 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %33 = call { i64, i64 } @size_wrapper(ptr %32, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %34 = extractvalue { i64, i64 } %33, 0
  %35 = call ptr @bump_malloc(i64 %34)
  %36 = insertvalue { ptr } undef, ptr %30, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %35, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr undef, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 10, 3
  %40 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr @_parameterization_i32, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %40)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %45 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  %46 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @i32_typ, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @i32_typ, ptr %48, align 8
  %49 = call ptr @behavior_wrapper(ptr %45, { ptr, ptr, ptr, i32 } %39, ptr noundef nonnull align 8 dereferenceable(24) %46)
  call void %49({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull %40, { ptr } %36, i32 14, i32 15) #39
  %50 = ptrtoint ptr %35 to i64
  %.sroa.339.8.insert.ext = zext i64 %50 to i160
  %.sroa.339.8.insert.insert = or disjoint i160 %.sroa.339.8.insert.ext, 3402823669209384634633746074317682114560
  %51 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.339.8.insert.insert, 1
  %52 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %55 = alloca { ptr }, align 8
  store ptr @String, ptr %55, align 8
  %56 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %55)
  call void %56(ptr nonnull %52, { ptr, i160 } %51) #39
  %.sroa.029.0.insert.ext = zext i32 %1 to i160
  %57 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.029.0.insert.ext, 1
  %58 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %58, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %58)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %61 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %61, align 8
  %62 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %61)
  call void %62(ptr nonnull %58, { ptr, i160 } %57) #39
  %63 = call ptr @bump_malloc(i64 noundef 15)
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %63, align 1
  %64 = alloca [1 x ptr], align 8
  store ptr @String, ptr %64, align 8
  %65 = call { i64, i64 } @size_wrapper(ptr %32, ptr noundef nonnull align 8 dereferenceable(8) %64)
  %66 = extractvalue { i64, i64 } %65, 0
  %67 = call ptr @bump_malloc(i64 %66)
  %68 = insertvalue { ptr } undef, ptr %63, 0
  %69 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %67, 1
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr undef, 2
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 10, 3
  %72 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %72, i64 8
  store ptr @_parameterization_i32, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %72, i64 16
  store ptr @_parameterization_i32, ptr %74, align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %72)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %77 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %77, i64 8
  store ptr @i32_typ, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %77, i64 16
  store ptr @i32_typ, ptr %79, align 8
  %80 = call ptr @behavior_wrapper(ptr %45, { ptr, ptr, ptr, i32 } %71, ptr noundef nonnull align 8 dereferenceable(24) %77)
  call void %80({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull %72, { ptr } %68, i32 14, i32 15) #39
  %81 = ptrtoint ptr %67 to i64
  %.sroa.317.8.insert.ext = zext i64 %81 to i160
  %.sroa.317.8.insert.insert = or disjoint i160 %.sroa.317.8.insert.ext, 3402823669209384634633746074317682114560
  %82 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.317.8.insert.insert, 1
  %83 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %83)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %86 = alloca { ptr }, align 8
  store ptr @String, ptr %86, align 8
  %87 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %86)
  call void %87(ptr nonnull %83, { ptr, i160 } %82) #39
  %.sroa.012.0.insert.ext = zext i64 %2 to i160
  %88 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.012.0.insert.ext, 1
  %89 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i64, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %92 = alloca { ptr }, align 8
  store ptr @i64_typ, ptr %92, align 8
  %93 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %92)
  call void %93(ptr nonnull %89, { ptr, i160 } %88) #39
  %94 = call ptr @bump_malloc(i64 noundef 4)
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %94, align 1
  %95 = alloca [1 x ptr], align 8
  store ptr @String, ptr %95, align 8
  %96 = call { i64, i64 } @size_wrapper(ptr %32, ptr noundef nonnull align 8 dereferenceable(8) %95)
  %97 = extractvalue { i64, i64 } %96, 0
  %98 = call ptr @bump_malloc(i64 %97)
  %99 = insertvalue { ptr } undef, ptr %94, 0
  %100 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %98, 1
  %101 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr undef, 2
  %102 = insertvalue { ptr, ptr, ptr, i32 } %101, i32 10, 3
  %103 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %103, i64 8
  store ptr @_parameterization_i32, ptr %104, align 8
  %105 = getelementptr inbounds i8, ptr %103, i64 16
  store ptr @_parameterization_i32, ptr %105, align 8
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %103)
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %108 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %108, align 8
  %109 = getelementptr inbounds i8, ptr %108, i64 8
  store ptr @i32_typ, ptr %109, align 8
  %110 = getelementptr inbounds i8, ptr %108, i64 16
  store ptr @i32_typ, ptr %110, align 8
  %111 = call ptr @behavior_wrapper(ptr %45, { ptr, ptr, ptr, i32 } %102, ptr noundef nonnull align 8 dereferenceable(24) %108)
  call void %111({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr nonnull %103, { ptr } %99, i32 3, i32 4) #39
  %112 = ptrtoint ptr %98 to i64
  %.sroa.3.8.insert.ext = zext i64 %112 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %113 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  %114 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %114, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %114)
  %116 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %117 = alloca { ptr }, align 8
  store ptr @String, ptr %117, align 8
  %118 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %117)
  call void %118(ptr nonnull %114, { ptr, i160 } %113) #39
  %119 = icmp sgt i32 %1, 0
  br i1 %119, label %120, label %._crit_edge

120:                                              ; preds = %3
  %121 = mul i64 %2, 1000000
  %122 = zext nneg i32 %1 to i64
  %123 = sdiv i64 %121, %122
  %124 = call ptr @bump_malloc(i64 noundef 16)
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %124, align 1
  store ptr @String, ptr %4, align 8
  %125 = call { i64, i64 } @size_wrapper(ptr %32, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %126 = extractvalue { i64, i64 } %125, 0
  %127 = call ptr @bump_malloc(i64 %126)
  %128 = insertvalue { ptr } undef, ptr %124, 0
  %129 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %127, 1
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, ptr undef, 2
  %131 = insertvalue { ptr, ptr, ptr, i32 } %130, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %5, align 8
  %132 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %132, align 8
  %133 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr @_parameterization_i32, ptr %133, align 8
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %5)
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %6, align 8
  %136 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %136, align 8
  %137 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr @i32_typ, ptr %137, align 8
  %138 = call ptr @behavior_wrapper(ptr %45, { ptr, ptr, ptr, i32 } %131, ptr noundef nonnull align 8 dereferenceable(24) %6)
  call void %138({ ptr, ptr, ptr, i32 } %131, { ptr, ptr, ptr, i32 } %131, ptr nonnull %5, { ptr } %128, i32 15, i32 16) #39
  %139 = ptrtoint ptr %127 to i64
  %.sroa.379.8.insert.ext = zext i64 %139 to i160
  %.sroa.379.8.insert.insert = or disjoint i160 %.sroa.379.8.insert.ext, 3402823669209384634633746074317682114560
  %140 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.379.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %7, align 8
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %8, align 8
  %143 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %8)
  call void %143(ptr nonnull %7, { ptr, i160 } %140) #39
  %.sroa.073.0.insert.ext = zext i64 %123 to i160
  %144 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.073.0.insert.ext, 1
  store ptr @_parameterization_i64, ptr %9, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i64_typ, ptr %10, align 8
  %147 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %10)
  call void %147(ptr nonnull %9, { ptr, i160 } %144) #39
  %148 = call ptr @bump_malloc(i64 noundef 4)
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %148, align 1
  store ptr @String, ptr %11, align 8
  %149 = call { i64, i64 } @size_wrapper(ptr %32, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %150 = extractvalue { i64, i64 } %149, 0
  %151 = call ptr @bump_malloc(i64 %150)
  %152 = insertvalue { ptr } undef, ptr %148, 0
  %153 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %151, 1
  %154 = insertvalue { ptr, ptr, ptr, i32 } %153, ptr undef, 2
  %155 = insertvalue { ptr, ptr, ptr, i32 } %154, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %12, align 8
  %156 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @_parameterization_i32, ptr %156, align 8
  %157 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %157, align 8
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %12)
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %13, align 8
  %160 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr @i32_typ, ptr %160, align 8
  %161 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %161, align 8
  %162 = call ptr @behavior_wrapper(ptr %45, { ptr, ptr, ptr, i32 } %155, ptr noundef nonnull align 8 dereferenceable(24) %13)
  call void %162({ ptr, ptr, ptr, i32 } %155, { ptr, ptr, ptr, i32 } %155, ptr nonnull %12, { ptr } %152, i32 3, i32 4) #39
  %163 = ptrtoint ptr %151 to i64
  %.sroa.361.8.insert.ext = zext i64 %163 to i160
  %.sroa.361.8.insert.insert = or disjoint i160 %.sroa.361.8.insert.ext, 3402823669209384634633746074317682114560
  %164 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.361.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %14, align 8
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %15, align 8
  %167 = call ptr @class_behavior_wrapper(ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %15)
  call void %167(ptr nonnull %14, { ptr, i160 } %164) #39
  br label %._crit_edge

._crit_edge:                                      ; preds = %120, %3
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [3 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca [3 x ptr], align 8
  %12 = alloca { ptr, ptr, ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca { ptr }, align 8
  %15 = alloca [1 x ptr], align 8
  %16 = alloca [3 x ptr], align 8
  %17 = alloca { ptr, ptr, ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca { ptr }, align 8
  %20 = alloca [1 x ptr], align 8
  %21 = alloca [3 x ptr], align 8
  %22 = alloca { ptr, ptr, ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %25, i64 8
  store ptr @_parameterization_i32, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %25, i64 16
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %25, i64 24
  store ptr @_parameterization_Pairi32._i32, ptr %28, align 8
  %29 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 48), align 8
  %30 = call { i64, i64 } @size_wrapper(ptr %29, ptr noundef nonnull align 8 dereferenceable(32) %25)
  %31 = extractvalue { i64, i64 } %30, 0
  %32 = call ptr @bump_malloc(i64 %31)
  store ptr @_parameterization_i32, ptr %32, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  store ptr @_parameterization_i32, ptr %33, align 8
  %34 = getelementptr i8, ptr %32, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %34, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %32)
  %36 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %36)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %36, ptr noalias nofree noundef nonnull readnone @egohsgumaa, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %37 = call ptr @adjust_trampoline(ptr %36)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %36)
  %39 = insertvalue { ptr } undef, ptr %37, 0
  %40 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %40)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %40, ptr noalias nofree noundef nonnull readnone @ewafwzhivv, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %41 = call ptr @adjust_trampoline(ptr %40)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %40)
  %43 = insertvalue { ptr } undef, ptr %41, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %32, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr undef, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 10, 3
  %47 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %47, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %47)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %51 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 160), align 8
  %52 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @function_typ, ptr %53, align 8
  %54 = call ptr @behavior_wrapper(ptr %51, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 dereferenceable(16) %52)
  call void %54({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %47, { ptr } %39, { ptr } %43) #39
  %55 = call i64 @clock()
  %56 = getelementptr inbounds i8, ptr %3, i64 8
  %57 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 248), align 8
  %58 = getelementptr inbounds i8, ptr %4, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %1
  %.0 = phi i32 [ 0, %1 ], [ %.1, %._crit_edge ]
  %59 = icmp slt i32 %.0, %0
  br i1 %59, label %60, label %._crit_edge

60:                                               ; preds = %._crit_edge1
  %61 = add nsw i32 %.0, 1
  %.sroa.0138.0.insert.ext = zext i32 %.0 to i160
  %62 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0138.0.insert.ext, 1
  %.sroa.0135.0.insert.ext = zext i32 %61 to i160
  %63 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0135.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  store ptr @_parameterization_i32, ptr %56, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %4, align 8
  store ptr @i32_typ, ptr %58, align 8
  %66 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 dereferenceable(16) %4)
  call void %66({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %3, { ptr, i160 } %62, { ptr, i160 } %63) #39
  br label %._crit_edge

._crit_edge:                                      ; preds = %60, %._crit_edge1
  %.1 = phi i32 [ %61, %60 ], [ %.0, %._crit_edge1 ]
  br i1 %59, label %._crit_edge1, label %67

67:                                               ; preds = %._crit_edge
  %68 = call i64 @clock()
  %69 = icmp sgt i32 %0, 0
  br i1 %69, label %._crit_edge2, label %87

._crit_edge2:                                     ; preds = %67
  %70 = add nsw i32 %0, -1
  %.sroa.0124.0.insert.ext = zext nneg i32 %70 to i160
  %71 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0124.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %74 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  store ptr @i32_typ, ptr %6, align 8
  %75 = call ptr @behavior_wrapper(ptr %74, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %76 = call { ptr, i160 } %75({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %5, { ptr, i160 } %71) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %76, 0
  %77 = icmp ne ptr %.fca.0.extract, @nil_typ
  %78 = icmp ne ptr %.fca.0.extract, null
  %.not150 = and i1 %77, %78
  %79 = icmp ne ptr %.fca.0.extract, @nil_typ
  %80 = and i1 %78, %79
  br i1 %80, label %._crit_edge3, label %._crit_edge4

._crit_edge3:                                     ; preds = %._crit_edge2
  %.fca.1.extract = extractvalue { ptr, i160 } %76, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %.not154 = icmp eq i32 %0, %.sroa.2.8.extract.trunc
  %spec.select156 = and i1 %.not154, %.not150
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3, %._crit_edge2
  %.3 = phi i1 [ %spec.select156, %._crit_edge3 ], [ %.not150, %._crit_edge2 ]
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %83 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 256), align 8
  %84 = call ptr @behavior_wrapper(ptr %83, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 %2)
  %85 = call i32 %84({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %2) #39
  %.not155 = icmp eq i32 %85, %0
  %86 = select i1 %.not155, i1 %.3, i1 false
  br label %93

87:                                               ; preds = %67
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %90 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 256), align 8
  %91 = call ptr @behavior_wrapper(ptr %90, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 %2)
  %92 = call i32 %91({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %2) #39
  %.not = icmp eq i32 %92, 0
  br label %93

93:                                               ; preds = %87, %._crit_edge4
  %.reg2mem15.0.in = phi i1 [ %86, %._crit_edge4 ], [ %.not, %87 ]
  %94 = call ptr @bump_malloc(i64 noundef 18)
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %94, align 1
  store ptr @String, ptr %7, align 8
  %95 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %96 = call { i64, i64 } @size_wrapper(ptr %95, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %97 = extractvalue { i64, i64 } %96, 0
  %98 = call ptr @bump_malloc(i64 %97)
  %99 = insertvalue { ptr } undef, ptr %94, 0
  %100 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %98, 1
  %101 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr undef, 2
  %102 = insertvalue { ptr, ptr, ptr, i32 } %101, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %8, align 8
  %103 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @_parameterization_i32, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @_parameterization_i32, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %8)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %107 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %9, align 8
  %108 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @i32_typ, ptr %108, align 8
  %109 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @i32_typ, ptr %109, align 8
  %110 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %102, ptr noundef nonnull align 8 dereferenceable(24) %9)
  call void %110({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr nonnull %8, { ptr } %99, i32 17, i32 18) #39
  %111 = sub i64 %68, %55
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %102, i32 %0, i64 %111)
  %112 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %112, align 1
  store ptr @String, ptr %10, align 8
  %113 = call { i64, i64 } @size_wrapper(ptr %95, ptr noundef nonnull align 8 dereferenceable(8) %10)
  %114 = extractvalue { i64, i64 } %113, 0
  %115 = call ptr @bump_malloc(i64 %114)
  %116 = insertvalue { ptr } undef, ptr %112, 0
  %117 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %115, 1
  %118 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr undef, 2
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %11, align 8
  %120 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_i32, ptr %120, align 8
  %121 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr @_parameterization_i32, ptr %121, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %11)
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %12, align 8
  %124 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @i32_typ, ptr %124, align 8
  %125 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @i32_typ, ptr %125, align 8
  %126 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %119, ptr noundef nonnull align 8 dereferenceable(24) %12)
  call void %126({ ptr, ptr, ptr, i32 } %119, { ptr, ptr, ptr, i32 } %119, ptr nonnull %11, { ptr } %116, i32 18, i32 19) #39
  %127 = ptrtoint ptr %115 to i64
  %.sroa.367.8.insert.ext = zext i64 %127 to i160
  %.sroa.367.8.insert.insert = or disjoint i160 %.sroa.367.8.insert.ext, 3402823669209384634633746074317682114560
  %128 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.367.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %13, align 8
  %129 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13)
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %131 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %14, align 8
  %132 = call ptr @class_behavior_wrapper(ptr %131, ptr noundef nonnull align 8 dereferenceable(8) %14)
  call void %132(ptr nonnull %13, { ptr, i160 } %128) #39
  %133 = call ptr @bump_malloc(i64 noundef 5)
  %134 = insertvalue { ptr } undef, ptr %133, 0
  %. = select i1 %.reg2mem15.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.190 = select i1 %.reg2mem15.0.in, ptr %15, ptr %20
  %.191 = select i1 %.reg2mem15.0.in, ptr %16, ptr %21
  %.192 = select i1 %.reg2mem15.0.in, ptr %17, ptr %22
  %.193 = select i1 %.reg2mem15.0.in, ptr %18, ptr %23
  %.194 = select i1 %.reg2mem15.0.in, ptr %19, ptr %24
  store <4 x i8> %., ptr %133, align 1
  store ptr @String, ptr %.190, align 8
  %135 = call { i64, i64 } @size_wrapper(ptr %95, ptr noundef nonnull align 8 dereferenceable(8) %.190)
  %136 = extractvalue { i64, i64 } %135, 0
  %137 = call ptr @bump_malloc(i64 %136)
  %138 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %137, 1
  %139 = insertvalue { ptr, ptr, ptr, i32 } %138, ptr undef, 2
  %140 = insertvalue { ptr, ptr, ptr, i32 } %139, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %.191, align 8
  %.191.sroa.sel.v = select i1 %.reg2mem15.0.in, ptr %16, ptr %21
  %.191.sroa.sel = getelementptr inbounds i8, ptr %.191.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.191.sroa.sel, align 8
  %.191.sroa.sel203.v = select i1 %.reg2mem15.0.in, ptr %16, ptr %21
  %.191.sroa.sel203 = getelementptr inbounds i8, ptr %.191.sroa.sel203.v, i64 16
  store ptr @_parameterization_i32, ptr %.191.sroa.sel203, align 8
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.191)
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %.192, align 8
  %.192.sroa.sel.v = select i1 %.reg2mem15.0.in, ptr %17, ptr %22
  %.192.sroa.sel = getelementptr inbounds i8, ptr %.192.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.192.sroa.sel, align 8
  %.192.sroa.sel198.v = select i1 %.reg2mem15.0.in, ptr %17, ptr %22
  %.192.sroa.sel198 = getelementptr inbounds i8, ptr %.192.sroa.sel198.v, i64 16
  store ptr @i32_typ, ptr %.192.sroa.sel198, align 8
  %143 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %140, ptr noundef nonnull align 8 dereferenceable(24) %.192)
  call void %143({ ptr, ptr, ptr, i32 } %140, { ptr, ptr, ptr, i32 } %140, ptr nonnull %.191, { ptr } %134, i32 4, i32 5) #39
  %144 = ptrtoint ptr %137 to i64
  %.sroa.3.8.insert.ext = zext i64 %144 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %145 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %.193, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.193)
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %.194, align 8
  %148 = call ptr @class_behavior_wrapper(ptr %131, ptr noundef nonnull align 8 dereferenceable(8) %.194)
  call void %148(ptr nonnull %.193, { ptr, i160 } %145) #39
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #4

declare i64 @clock() local_unnamed_addr #3

define void @benchmark_insert_random(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %.sroa.0242.sroa.0 = alloca i8, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca [3 x ptr], align 8
  %15 = alloca { ptr, ptr, ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca [3 x ptr], align 8
  %18 = alloca { ptr, ptr, ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca [3 x ptr], align 8
  %23 = alloca { ptr, ptr, ptr }, align 8
  %24 = alloca [1 x ptr], align 8
  %25 = alloca { ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca [3 x ptr], align 8
  %28 = alloca { ptr, ptr, ptr }, align 8
  %29 = alloca [1 x ptr], align 8
  %30 = alloca { ptr }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca [3 x ptr], align 8
  %33 = alloca { ptr, ptr, ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca { ptr }, align 8
  %36 = alloca [1 x ptr], align 8
  %37 = alloca { ptr }, align 8
  %38 = alloca [1 x ptr], align 8
  %39 = alloca [3 x ptr], align 8
  %40 = alloca { ptr, ptr, ptr }, align 8
  %41 = alloca [1 x ptr], align 8
  %42 = alloca { ptr }, align 8
  %43 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %43, i64 8
  store ptr @_parameterization_i32, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 16
  store ptr @_parameterization_i32, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %43, i64 24
  store ptr @_parameterization_Pairi32._i32, ptr %46, align 8
  %47 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 48), align 8
  %48 = call { i64, i64 } @size_wrapper(ptr %47, ptr noundef nonnull align 8 dereferenceable(32) %43)
  %49 = extractvalue { i64, i64 } %48, 0
  %50 = call ptr @bump_malloc(i64 %49)
  store ptr @_parameterization_i32, ptr %50, align 8
  %51 = getelementptr i8, ptr %50, i64 8
  store ptr @_parameterization_i32, ptr %51, align 8
  %52 = getelementptr i8, ptr %50, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %50)
  %54 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %54)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %54, ptr noalias nofree noundef nonnull readnone @vimoiwpapu, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %55 = call ptr @adjust_trampoline(ptr %54)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %54)
  %57 = insertvalue { ptr } undef, ptr %55, 0
  %58 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %58)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %58, ptr noalias nofree noundef nonnull readnone @genyhirpvr, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %59 = call ptr @adjust_trampoline(ptr %58)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %58)
  %61 = insertvalue { ptr } undef, ptr %59, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %50, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr undef, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 10, 3
  %65 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %65, align 8
  %66 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %65)
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %69 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 160), align 8
  %70 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %70, i64 8
  store ptr @function_typ, ptr %71, align 8
  %72 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 dereferenceable(16) %70)
  call void %72({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %65, { ptr } %57, { ptr } %61) #39
  %73 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %73, align 8
  %74 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %73)
  %75 = extractvalue { i64, i64 } %74, 0
  %76 = call ptr @bump_malloc(i64 %75)
  %77 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %76, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr undef, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 10, 3
  %80 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %80)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %83 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %83, align 8
  %84 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %79, ptr noundef nonnull align 8 dereferenceable(8) %83)
  call void %84({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull %80, i32 123) #39
  %85 = alloca [2 x ptr], align 8
  store ptr @Array, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %85, i64 8
  store ptr @_parameterization_i32, ptr %86, align 8
  %87 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 48), align 8
  %88 = call { i64, i64 } @size_wrapper(ptr %87, ptr noundef nonnull align 8 dereferenceable(16) %85)
  %89 = extractvalue { i64, i64 } %88, 0
  %90 = call ptr @bump_malloc(i64 %89)
  store ptr @_parameterization_i32, ptr %90, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %90)
  %92 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %90, 1
  %93 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr undef, 2
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 10, 3
  %95 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %95, align 8
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %95)
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  %98 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 128), align 8
  %99 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %99, align 8
  %100 = call ptr @behavior_wrapper(ptr %98, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 dereferenceable(8) %99)
  call void %100({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull %95, i32 %0) #39
  %101 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %101, align 8
  %102 = getelementptr inbounds i8, ptr %101, i64 8
  store ptr @_parameterization_i32, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %101, i64 16
  store ptr @_parameterization_Bool, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %101, i64 24
  store ptr @_parameterization_Pairi32._Bool, ptr %104, align 8
  %105 = call { i64, i64 } @size_wrapper(ptr %47, ptr noundef nonnull align 8 dereferenceable(32) %101)
  %106 = extractvalue { i64, i64 } %105, 0
  %107 = call ptr @bump_malloc(i64 %106)
  store ptr @_parameterization_i32, ptr %107, align 8
  %108 = getelementptr i8, ptr %107, i64 8
  store ptr @_parameterization_Bool, ptr %108, align 8
  %109 = getelementptr i8, ptr %107, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %109, align 8
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %107)
  %111 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %111)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %111, ptr noalias nofree noundef nonnull readnone @nyfuylfwaq, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %112 = call ptr @adjust_trampoline(ptr %111)
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %111)
  %114 = insertvalue { ptr } undef, ptr %112, 0
  %115 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %115)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %115, ptr noalias nofree noundef nonnull readnone @weyllhhkpb, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %116 = call ptr @adjust_trampoline(ptr %115)
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %115)
  %118 = insertvalue { ptr } undef, ptr %116, 0
  %119 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %107, 1
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr undef, 2
  %121 = insertvalue { ptr, ptr, ptr, i32 } %120, i32 10, 3
  %122 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %122, align 8
  %123 = getelementptr inbounds i8, ptr %122, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %122)
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %126 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %126, align 8
  %127 = getelementptr inbounds i8, ptr %126, i64 8
  store ptr @function_typ, ptr %127, align 8
  %128 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %121, ptr noundef nonnull align 8 dereferenceable(16) %126)
  call void %128({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull %122, { ptr } %114, { ptr } %118) #39
  %129 = getelementptr inbounds i8, ptr %3, i64 8
  %130 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 216), align 8
  %131 = getelementptr inbounds i8, ptr %4, i64 8
  %132 = add i32 %0, -1
  %133 = getelementptr inbounds i8, ptr %5, i64 8
  %134 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 248), align 8
  %135 = getelementptr inbounds i8, ptr %6, i64 8
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %._crit_edge, %1
  %.0258 = phi i32 [ 0, %1 ], [ %.1259, %._crit_edge ]
  %.0 = phi i32 [ -1, %1 ], [ %.2, %._crit_edge ]
  %136 = icmp slt i32 %.0258, %0
  br i1 %136, label %._crit_edge1, label %._crit_edge

._crit_edge1:                                     ; preds = %._crit_edge2
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %139 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %79, ptr noundef nonnull align 8 %2)
  %140 = call i32 %139({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull %2) #39
  %.sroa.0252.0.insert.ext = zext i32 %140 to i160
  %141 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0252.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  store ptr @_parameterization_i32, ptr %129, align 8
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3)
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  store ptr @i32_typ, ptr %4, align 8
  store ptr @i32_typ, ptr %131, align 8
  %144 = call ptr @behavior_wrapper(ptr %130, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 dereferenceable(16) %4)
  call void %144({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull %3, i32 %.0258, { ptr, i160 } %141) #39
  %145 = icmp eq i32 %.0258, %132
  %spec.select = select i1 %145, i32 %140, i32 %.0
  store i1 true, ptr %.sroa.0242.sroa.0, align 8
  %.sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.0. = load i8, ptr %.sroa.0242.sroa.0, align 8
  %.sroa.0242.0.insert.ext = zext i8 %.sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.sroa.0.0..sroa.0242.0. to i160
  %146 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0242.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_Bool, ptr %133, align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %6, align 8
  store ptr @bool_typ, ptr %135, align 8
  %149 = call ptr @behavior_wrapper(ptr %134, { ptr, ptr, ptr, i32 } %121, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %149({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull %5, { ptr, i160 } %141, { ptr, i160 } %146) #39
  %150 = add nsw i32 %.0258, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge1, %._crit_edge2
  %.1259 = phi i32 [ %150, %._crit_edge1 ], [ %.0258, %._crit_edge2 ]
  %.2 = phi i32 [ %spec.select, %._crit_edge1 ], [ %.0, %._crit_edge2 ]
  br i1 %136, label %._crit_edge2, label %151

151:                                              ; preds = %._crit_edge
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %154 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 256), align 8
  %155 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %121, ptr noundef nonnull align 8 %2)
  %156 = call i32 %155({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull align 8 %2) #39
  %157 = call i64 @clock()
  %158 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 208), align 8
  %159 = getelementptr inbounds i8, ptr %9, i64 8
  %160 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 248), align 8
  %161 = getelementptr inbounds i8, ptr %10, i64 8
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3, %151
  %.2260 = phi i32 [ 0, %151 ], [ %.3, %._crit_edge3 ]
  %162 = icmp slt i32 %.2260, %0
  br i1 %162, label %163, label %._crit_edge3

163:                                              ; preds = %._crit_edge4
  store ptr @_parameterization_i32, ptr %7, align 8
  %164 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  store ptr @i32_typ, ptr %8, align 8
  %166 = call ptr @behavior_wrapper(ptr %158, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %167 = call { ptr, i160 } %166({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull %7, i32 %.2260) #39
  %.fca.1.extract232 = extractvalue { ptr, i160 } %167, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract232 to i32
  %168 = add i32 %.sroa.1.8.extract.trunc, 1
  %.sroa.0225.0.insert.ext = and i160 %.fca.1.extract232, 4294967295
  %169 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0225.0.insert.ext, 1
  %.sroa.0222.0.insert.ext = zext i32 %168 to i160
  %170 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0222.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %9, align 8
  store ptr @_parameterization_i32, ptr %159, align 8
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9)
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %10, align 8
  store ptr @i32_typ, ptr %161, align 8
  %173 = call ptr @behavior_wrapper(ptr %160, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 dereferenceable(16) %10)
  call void %173({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %9, { ptr, i160 } %169, { ptr, i160 } %170) #39
  %174 = add nsw i32 %.2260, 1
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %163, %._crit_edge4
  %.3 = phi i32 [ %174, %163 ], [ %.2260, %._crit_edge4 ]
  br i1 %162, label %._crit_edge4, label %175

175:                                              ; preds = %._crit_edge3
  %176 = call i64 @clock()
  %177 = icmp sgt i32 %0, 0
  br i1 %177, label %._crit_edge5, label %194

._crit_edge5:                                     ; preds = %175
  %.sroa.0213.0.insert.ext = zext i32 %.2 to i160
  %178 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0213.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %11, align 8
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %181 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  store ptr @i32_typ, ptr %12, align 8
  %182 = call ptr @behavior_wrapper(ptr %181, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 dereferenceable(8) %12)
  %183 = call { ptr, i160 } %182({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %11, { ptr, i160 } %178) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %183, 0
  %184 = icmp ne ptr %.fca.0.extract, @nil_typ
  %185 = icmp ne ptr %.fca.0.extract, null
  %.not271 = and i1 %184, %185
  %186 = icmp ne ptr %.fca.0.extract, @nil_typ
  %187 = and i1 %185, %186
  br i1 %187, label %._crit_edge6, label %._crit_edge7

._crit_edge6:                                     ; preds = %._crit_edge5
  %.fca.1.extract = extractvalue { ptr, i160 } %183, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %188 = add i32 %.2, 1
  %.not275 = icmp eq i32 %188, %.sroa.2.8.extract.trunc
  %spec.select278 = and i1 %.not275, %.not271
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge6, %._crit_edge5
  %.3264 = phi i1 [ %spec.select278, %._crit_edge6 ], [ %.not271, %._crit_edge5 ]
  %189 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %190 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %191 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 %2)
  %192 = call i32 %191({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %2) #39
  %.not276 = icmp eq i32 %192, %156
  %193 = select i1 %.not276, i1 %.3264, i1 false
  br label %199

194:                                              ; preds = %175
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %197 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %64, ptr noundef nonnull align 8 %2)
  %198 = call i32 %197({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %2) #39
  %.not = icmp eq i32 %198, 0
  br label %199

199:                                              ; preds = %194, %._crit_edge7
  %.reg2mem21.0.in = phi i1 [ %193, %._crit_edge7 ], [ %.not, %194 ]
  %200 = call ptr @bump_malloc(i64 noundef 14)
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %200, align 1
  store ptr @String, ptr %13, align 8
  %201 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %202 = call { i64, i64 } @size_wrapper(ptr %201, ptr noundef nonnull align 8 dereferenceable(8) %13)
  %203 = extractvalue { i64, i64 } %202, 0
  %204 = call ptr @bump_malloc(i64 %203)
  %205 = insertvalue { ptr } undef, ptr %200, 0
  %206 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %204, 1
  %207 = insertvalue { ptr, ptr, ptr, i32 } %206, ptr undef, 2
  %208 = insertvalue { ptr, ptr, ptr, i32 } %207, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %14, align 8
  %209 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_i32, ptr %209, align 8
  %210 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr @_parameterization_i32, ptr %210, align 8
  %211 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %14)
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %213 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %15, align 8
  %214 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @i32_typ, ptr %214, align 8
  %215 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr @i32_typ, ptr %215, align 8
  %216 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %208, ptr noundef nonnull align 8 dereferenceable(24) %15)
  call void %216({ ptr, ptr, ptr, i32 } %208, { ptr, ptr, ptr, i32 } %208, ptr nonnull %14, { ptr } %205, i32 13, i32 14) #39
  %217 = sub i64 %176, %157
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %208, i32 %0, i64 %217)
  %218 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %218, align 1
  store ptr @String, ptr %16, align 8
  %219 = call { i64, i64 } @size_wrapper(ptr %201, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %220 = extractvalue { i64, i64 } %219, 0
  %221 = call ptr @bump_malloc(i64 %220)
  %222 = insertvalue { ptr } undef, ptr %218, 0
  %223 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %221, 1
  %224 = insertvalue { ptr, ptr, ptr, i32 } %223, ptr undef, 2
  %225 = insertvalue { ptr, ptr, ptr, i32 } %224, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %17, align 8
  %226 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %226, align 8
  %227 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr @_parameterization_i32, ptr %227, align 8
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %17)
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %18, align 8
  %230 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @i32_typ, ptr %230, align 8
  %231 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @i32_typ, ptr %231, align 8
  %232 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %225, ptr noundef nonnull align 8 dereferenceable(24) %18)
  call void %232({ ptr, ptr, ptr, i32 } %225, { ptr, ptr, ptr, i32 } %225, ptr nonnull %17, { ptr } %222, i32 18, i32 19) #39
  %233 = ptrtoint ptr %221 to i64
  %.sroa.3154.8.insert.ext = zext i64 %233 to i160
  %.sroa.3154.8.insert.insert = or disjoint i160 %.sroa.3154.8.insert.ext, 3402823669209384634633746074317682114560
  %234 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3154.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %19, align 8
  %235 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %236 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %237 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %20, align 8
  %238 = call ptr @class_behavior_wrapper(ptr %237, ptr noundef nonnull align 8 dereferenceable(8) %20)
  call void %238(ptr nonnull %19, { ptr, i160 } %234) #39
  %239 = call ptr @bump_malloc(i64 noundef 5)
  %240 = insertvalue { ptr } undef, ptr %239, 0
  %. = select i1 %.reg2mem21.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.312 = select i1 %.reg2mem21.0.in, ptr %21, ptr %26
  %.313 = select i1 %.reg2mem21.0.in, ptr %22, ptr %27
  %.314 = select i1 %.reg2mem21.0.in, ptr %23, ptr %28
  %.315 = select i1 %.reg2mem21.0.in, ptr %24, ptr %29
  %.316 = select i1 %.reg2mem21.0.in, ptr %25, ptr %30
  store <4 x i8> %., ptr %239, align 1
  store ptr @String, ptr %.312, align 8
  %241 = call { i64, i64 } @size_wrapper(ptr %201, ptr noundef nonnull align 8 dereferenceable(8) %.312)
  %242 = extractvalue { i64, i64 } %241, 0
  %243 = call ptr @bump_malloc(i64 %242)
  %244 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %243, 1
  %245 = insertvalue { ptr, ptr, ptr, i32 } %244, ptr undef, 2
  %246 = insertvalue { ptr, ptr, ptr, i32 } %245, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %.313, align 8
  %.313.sroa.sel.v = select i1 %.reg2mem21.0.in, ptr %22, ptr %27
  %.313.sroa.sel = getelementptr inbounds i8, ptr %.313.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.313.sroa.sel, align 8
  %.313.sroa.sel325.v = select i1 %.reg2mem21.0.in, ptr %22, ptr %27
  %.313.sroa.sel325 = getelementptr inbounds i8, ptr %.313.sroa.sel325.v, i64 16
  store ptr @_parameterization_i32, ptr %.313.sroa.sel325, align 8
  %247 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.313)
  %248 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %.314, align 8
  %.314.sroa.sel.v = select i1 %.reg2mem21.0.in, ptr %23, ptr %28
  %.314.sroa.sel = getelementptr inbounds i8, ptr %.314.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.314.sroa.sel, align 8
  %.314.sroa.sel320.v = select i1 %.reg2mem21.0.in, ptr %23, ptr %28
  %.314.sroa.sel320 = getelementptr inbounds i8, ptr %.314.sroa.sel320.v, i64 16
  store ptr @i32_typ, ptr %.314.sroa.sel320, align 8
  %249 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %246, ptr noundef nonnull align 8 dereferenceable(24) %.314)
  call void %249({ ptr, ptr, ptr, i32 } %246, { ptr, ptr, ptr, i32 } %246, ptr nonnull %.313, { ptr } %240, i32 4, i32 5) #39
  %250 = ptrtoint ptr %243 to i64
  %.sroa.3124.8.insert.ext = zext i64 %250 to i160
  %.sroa.3124.8.insert.insert = or disjoint i160 %.sroa.3124.8.insert.ext, 3402823669209384634633746074317682114560
  %251 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3124.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %.315, align 8
  %252 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.315)
  %253 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %.316, align 8
  %254 = call ptr @class_behavior_wrapper(ptr %237, ptr noundef nonnull align 8 dereferenceable(8) %.316)
  call void %254(ptr nonnull %.315, { ptr, i160 } %251) #39
  %255 = call ptr @bump_malloc(i64 noundef 28)
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %255, align 1
  store ptr @String, ptr %31, align 8
  %256 = call { i64, i64 } @size_wrapper(ptr %201, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %257 = extractvalue { i64, i64 } %256, 0
  %258 = call ptr @bump_malloc(i64 %257)
  %259 = insertvalue { ptr } undef, ptr %255, 0
  %260 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %258, 1
  %261 = insertvalue { ptr, ptr, ptr, i32 } %260, ptr undef, 2
  %262 = insertvalue { ptr, ptr, ptr, i32 } %261, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %32, align 8
  %263 = getelementptr inbounds i8, ptr %32, i64 8
  store ptr @_parameterization_i32, ptr %263, align 8
  %264 = getelementptr inbounds i8, ptr %32, i64 16
  store ptr @_parameterization_i32, ptr %264, align 8
  %265 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %32)
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %33, align 8
  %267 = getelementptr inbounds i8, ptr %33, i64 8
  store ptr @i32_typ, ptr %267, align 8
  %268 = getelementptr inbounds i8, ptr %33, i64 16
  store ptr @i32_typ, ptr %268, align 8
  %269 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %262, ptr noundef nonnull align 8 dereferenceable(24) %33)
  call void %269({ ptr, ptr, ptr, i32 } %262, { ptr, ptr, ptr, i32 } %262, ptr nonnull %32, { ptr } %259, i32 27, i32 28) #39
  %270 = ptrtoint ptr %258 to i64
  %.sroa.3109.8.insert.ext = zext i64 %270 to i160
  %.sroa.3109.8.insert.insert = or disjoint i160 %.sroa.3109.8.insert.ext, 3402823669209384634633746074317682114560
  %271 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3109.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %34, align 8
  %272 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %34)
  %273 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %35, align 8
  %274 = call ptr @class_behavior_wrapper(ptr %237, ptr noundef nonnull align 8 dereferenceable(8) %35)
  call void %274(ptr nonnull %34, { ptr, i160 } %271) #39
  %.sroa.0104.0.insert.ext = zext i32 %156 to i160
  %275 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0104.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %36, align 8
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %37, align 8
  %278 = call ptr @class_behavior_wrapper(ptr %237, ptr noundef nonnull align 8 dereferenceable(8) %37)
  call void %278(ptr nonnull %36, { ptr, i160 } %275) #39
  %279 = call ptr @bump_malloc(i64 noundef 2)
  store <1 x i8> <i8 41>, ptr %279, align 1
  store ptr @String, ptr %38, align 8
  %280 = call { i64, i64 } @size_wrapper(ptr %201, ptr noundef nonnull align 8 dereferenceable(8) %38)
  %281 = extractvalue { i64, i64 } %280, 0
  %282 = call ptr @bump_malloc(i64 %281)
  %283 = insertvalue { ptr } undef, ptr %279, 0
  %284 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %282, 1
  %285 = insertvalue { ptr, ptr, ptr, i32 } %284, ptr undef, 2
  %286 = insertvalue { ptr, ptr, ptr, i32 } %285, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %39, align 8
  %287 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @_parameterization_i32, ptr %287, align 8
  %288 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @_parameterization_i32, ptr %288, align 8
  %289 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %39)
  %290 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %40, align 8
  %291 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr @i32_typ, ptr %291, align 8
  %292 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr @i32_typ, ptr %292, align 8
  %293 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %286, ptr noundef nonnull align 8 dereferenceable(24) %40)
  call void %293({ ptr, ptr, ptr, i32 } %286, { ptr, ptr, ptr, i32 } %286, ptr nonnull %39, { ptr } %283, i32 1, i32 2) #39
  %294 = ptrtoint ptr %282 to i64
  %.sroa.3.8.insert.ext = zext i64 %294 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %295 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %41, align 8
  %296 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  %297 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %42, align 8
  %298 = call ptr @class_behavior_wrapper(ptr %237, ptr noundef nonnull align 8 dereferenceable(8) %42)
  call void %298(ptr nonnull %41, { ptr, i160 } %295) #39
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [2 x ptr], align 8
  %3 = alloca { ptr, ptr }, align 8
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [3 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [1 x ptr], align 8
  %14 = alloca [3 x ptr], align 8
  %15 = alloca { ptr, ptr, ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca [3 x ptr], align 8
  %18 = alloca { ptr, ptr, ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca [3 x ptr], align 8
  %23 = alloca { ptr, ptr, ptr }, align 8
  %24 = alloca [1 x ptr], align 8
  %25 = alloca { ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca [3 x ptr], align 8
  %28 = alloca { ptr, ptr, ptr }, align 8
  %29 = alloca [1 x ptr], align 8
  %30 = alloca { ptr }, align 8
  %31 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %31, i64 8
  store ptr @_parameterization_i32, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %31, i64 16
  store ptr @_parameterization_i32, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %31, i64 24
  store ptr @_parameterization_Pairi32._i32, ptr %34, align 8
  %35 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 48), align 8
  %36 = call { i64, i64 } @size_wrapper(ptr %35, ptr noundef nonnull align 8 dereferenceable(32) %31)
  %37 = extractvalue { i64, i64 } %36, 0
  %38 = call ptr @bump_malloc(i64 %37)
  store ptr @_parameterization_i32, ptr %38, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  store ptr @_parameterization_i32, ptr %39, align 8
  %40 = getelementptr i8, ptr %38, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %38)
  %42 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %42)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %42, ptr noalias nofree noundef nonnull readnone @drgmnjsbrc, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %43 = call ptr @adjust_trampoline(ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %42)
  %45 = insertvalue { ptr } undef, ptr %43, 0
  %46 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %46)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %46, ptr noalias nofree noundef nonnull readnone @uvhofywczn, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %47 = call ptr @adjust_trampoline(ptr %46)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %46)
  %49 = insertvalue { ptr } undef, ptr %47, 0
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %38, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 10, 3
  %53 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %53, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %54, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %53)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %57 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 160), align 8
  %58 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %58, i64 8
  store ptr @function_typ, ptr %59, align 8
  %60 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 dereferenceable(16) %58)
  call void %60({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %53, { ptr } %45, { ptr } %49) #39
  %61 = getelementptr inbounds i8, ptr %2, i64 8
  %62 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 248), align 8
  %63 = getelementptr inbounds i8, ptr %3, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %1
  %.0148 = phi i64 [ 0, %1 ], [ %.1149, %._crit_edge ]
  %.0 = phi i32 [ 0, %1 ], [ %.1, %._crit_edge ]
  %64 = icmp slt i32 %.0, %0
  br i1 %64, label %65, label %._crit_edge

65:                                               ; preds = %._crit_edge1
  %66 = add nsw i32 %.0, 1
  %.sroa.0142.0.insert.ext = zext i32 %.0 to i160
  %67 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0142.0.insert.ext, 1
  %.sroa.0139.0.insert.ext = zext i32 %66 to i160
  %68 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0139.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %2, align 8
  store ptr @_parameterization_i32, ptr %61, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %2)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %3, align 8
  store ptr @i32_typ, ptr %63, align 8
  %71 = call ptr @behavior_wrapper(ptr %62, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 dereferenceable(16) %3)
  call void %71({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %2, { ptr, i160 } %67, { ptr, i160 } %68) #39
  %72 = sext i32 %66 to i64
  %73 = add i64 %.0148, %72
  br label %._crit_edge

._crit_edge:                                      ; preds = %65, %._crit_edge1
  %.1149 = phi i64 [ %73, %65 ], [ %.0148, %._crit_edge1 ]
  %.1 = phi i32 [ %66, %65 ], [ %.0, %._crit_edge1 ]
  br i1 %64, label %._crit_edge1, label %74

74:                                               ; preds = %._crit_edge
  %75 = call i64 @clock()
  %76 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  %77 = load <55 x i8>, ptr @lwoib_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  %78 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %79 = getelementptr inbounds i8, ptr %7, i64 8
  %80 = getelementptr inbounds i8, ptr %7, i64 16
  %81 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  %82 = getelementptr inbounds i8, ptr %8, i64 8
  %83 = getelementptr inbounds i8, ptr %8, i64 16
  %84 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge2, %74
  %.0153 = phi i1 [ true, %74 ], [ %.2155, %._crit_edge2 ]
  %.0150 = phi i64 [ 0, %74 ], [ %.2152, %._crit_edge2 ]
  %.2 = phi i32 [ 0, %74 ], [ %.3, %._crit_edge2 ]
  %85 = icmp slt i32 %.2, %0
  br i1 %85, label %86, label %._crit_edge2

86:                                               ; preds = %._crit_edge3
  %.sroa.0126.0.insert.ext = zext i32 %.2 to i160
  %87 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0126.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %4, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %5, align 8
  %90 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %52, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %91 = call { ptr, i160 } %90({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %4, { ptr, i160 } %87) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %91, 0
  %92 = icmp ne ptr %.fca.0.extract, @nil_typ
  %93 = icmp ne ptr %.fca.0.extract, null
  %.not159 = and i1 %92, %93
  br i1 %.not159, label %94, label %97

94:                                               ; preds = %86
  %.fca.1.extract = extractvalue { ptr, i160 } %91, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %95 = sext i32 %.sroa.2.8.extract.trunc to i64
  %96 = add i64 %.0150, %95
  br label %117

97:                                               ; preds = %86
  %98 = call ptr @bump_malloc(i64 noundef 56)
  store <55 x i8> %77, ptr %98, align 1
  store ptr @String, ptr %6, align 8
  %99 = call { i64, i64 } @size_wrapper(ptr %78, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %100 = extractvalue { i64, i64 } %99, 0
  %101 = call ptr @bump_malloc(i64 %100)
  %102 = insertvalue { ptr } undef, ptr %98, 0
  %103 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %101, 1
  %104 = insertvalue { ptr, ptr, ptr, i32 } %103, ptr undef, 2
  %105 = insertvalue { ptr, ptr, ptr, i32 } %104, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %79, align 8
  store ptr @_parameterization_i32, ptr %80, align 8
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %7)
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %82, align 8
  store ptr @i32_typ, ptr %83, align 8
  %108 = call ptr @behavior_wrapper(ptr %81, { ptr, ptr, ptr, i32 } %105, ptr noundef nonnull align 8 dereferenceable(24) %8)
  call void %108({ ptr, ptr, ptr, i32 } %105, { ptr, ptr, ptr, i32 } %105, ptr nonnull %7, { ptr } %102, i32 55, i32 56) #39
  %109 = ptrtoint ptr %101 to i64
  %.sroa.3101.8.insert.ext = zext i64 %109 to i160
  %.sroa.3101.8.insert.insert = or disjoint i160 %.sroa.3101.8.insert.ext, 3402823669209384634633746074317682114560
  %110 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3101.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %9, align 8
  %111 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %10, align 8
  %113 = call ptr @class_behavior_wrapper(ptr %84, ptr noundef nonnull align 8 dereferenceable(8) %10)
  call void %113(ptr nonnull %9, { ptr, i160 } %110) #39
  store ptr @_parameterization_i32, ptr %11, align 8
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %12, align 8
  %116 = call ptr @class_behavior_wrapper(ptr %84, ptr noundef nonnull align 8 dereferenceable(8) %12)
  call void %116(ptr nonnull %11, { ptr, i160 } %87) #39
  br label %117

117:                                              ; preds = %97, %94
  %.1154 = phi i1 [ %.0153, %94 ], [ false, %97 ]
  %.1151 = phi i64 [ %96, %94 ], [ %.0150, %97 ]
  %118 = add i32 %.2, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %117, %._crit_edge3
  %.2155 = phi i1 [ %.1154, %117 ], [ %.0153, %._crit_edge3 ]
  %.2152 = phi i64 [ %.1151, %117 ], [ %.0150, %._crit_edge3 ]
  %.3 = phi i32 [ %118, %117 ], [ %.2, %._crit_edge3 ]
  br i1 %85, label %._crit_edge3, label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge2
  %119 = call i64 @clock()
  %.not = icmp eq i64 %.2152, %.1149
  %spec.select = select i1 %.not, i1 %.2155, i1 false
  %120 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %120, align 1
  store ptr @String, ptr %13, align 8
  %121 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %122 = call { i64, i64 } @size_wrapper(ptr %121, ptr noundef nonnull align 8 dereferenceable(8) %13)
  %123 = extractvalue { i64, i64 } %122, 0
  %124 = call ptr @bump_malloc(i64 %123)
  %125 = insertvalue { ptr } undef, ptr %120, 0
  %126 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %124, 1
  %127 = insertvalue { ptr, ptr, ptr, i32 } %126, ptr undef, 2
  %128 = insertvalue { ptr, ptr, ptr, i32 } %127, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %14, align 8
  %129 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_i32, ptr %129, align 8
  %130 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr @_parameterization_i32, ptr %130, align 8
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %14)
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %133 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %15, align 8
  %134 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @i32_typ, ptr %134, align 8
  %135 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr @i32_typ, ptr %135, align 8
  %136 = call ptr @behavior_wrapper(ptr %133, { ptr, ptr, ptr, i32 } %128, ptr noundef nonnull align 8 dereferenceable(24) %15)
  call void %136({ ptr, ptr, ptr, i32 } %128, { ptr, ptr, ptr, i32 } %128, ptr nonnull %14, { ptr } %125, i32 18, i32 19) #39
  %137 = sub i64 %119, %75
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %128, i32 %0, i64 %137)
  %138 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %138, align 1
  store ptr @String, ptr %16, align 8
  %139 = call { i64, i64 } @size_wrapper(ptr %121, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %140 = extractvalue { i64, i64 } %139, 0
  %141 = call ptr @bump_malloc(i64 %140)
  %142 = insertvalue { ptr } undef, ptr %138, 0
  %143 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %141, 1
  %144 = insertvalue { ptr, ptr, ptr, i32 } %143, ptr undef, 2
  %145 = insertvalue { ptr, ptr, ptr, i32 } %144, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %17, align 8
  %146 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %146, align 8
  %147 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr @_parameterization_i32, ptr %147, align 8
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %17)
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %18, align 8
  %150 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @i32_typ, ptr %150, align 8
  %151 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @i32_typ, ptr %151, align 8
  %152 = call ptr @behavior_wrapper(ptr %133, { ptr, ptr, ptr, i32 } %145, ptr noundef nonnull align 8 dereferenceable(24) %18)
  call void %152({ ptr, ptr, ptr, i32 } %145, { ptr, ptr, ptr, i32 } %145, ptr nonnull %17, { ptr } %142, i32 18, i32 19) #39
  %153 = ptrtoint ptr %141 to i64
  %.sroa.361.8.insert.ext = zext i64 %153 to i160
  %.sroa.361.8.insert.insert = or disjoint i160 %.sroa.361.8.insert.ext, 3402823669209384634633746074317682114560
  %154 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.361.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %19, align 8
  %155 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %157 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %20, align 8
  %158 = call ptr @class_behavior_wrapper(ptr %157, ptr noundef nonnull align 8 dereferenceable(8) %20)
  call void %158(ptr nonnull %19, { ptr, i160 } %154) #39
  %159 = call ptr @bump_malloc(i64 noundef 5)
  %160 = insertvalue { ptr } undef, ptr %159, 0
  %. = select i1 %spec.select, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.193 = select i1 %spec.select, ptr %21, ptr %26
  %.194 = select i1 %spec.select, ptr %22, ptr %27
  %.195 = select i1 %spec.select, ptr %23, ptr %28
  %.196 = select i1 %spec.select, ptr %24, ptr %29
  %.197 = select i1 %spec.select, ptr %25, ptr %30
  store <4 x i8> %., ptr %159, align 1
  store ptr @String, ptr %.193, align 8
  %161 = call { i64, i64 } @size_wrapper(ptr %121, ptr noundef nonnull align 8 dereferenceable(8) %.193)
  %162 = extractvalue { i64, i64 } %161, 0
  %163 = call ptr @bump_malloc(i64 %162)
  %164 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %163, 1
  %165 = insertvalue { ptr, ptr, ptr, i32 } %164, ptr undef, 2
  %166 = insertvalue { ptr, ptr, ptr, i32 } %165, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %.194, align 8
  %.194.sroa.sel.v = select i1 %spec.select, ptr %22, ptr %27
  %.194.sroa.sel = getelementptr inbounds i8, ptr %.194.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.194.sroa.sel, align 8
  %.194.sroa.sel206.v = select i1 %spec.select, ptr %22, ptr %27
  %.194.sroa.sel206 = getelementptr inbounds i8, ptr %.194.sroa.sel206.v, i64 16
  store ptr @_parameterization_i32, ptr %.194.sroa.sel206, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.194)
  %168 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %.195, align 8
  %.195.sroa.sel.v = select i1 %spec.select, ptr %23, ptr %28
  %.195.sroa.sel = getelementptr inbounds i8, ptr %.195.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.195.sroa.sel, align 8
  %.195.sroa.sel201.v = select i1 %spec.select, ptr %23, ptr %28
  %.195.sroa.sel201 = getelementptr inbounds i8, ptr %.195.sroa.sel201.v, i64 16
  store ptr @i32_typ, ptr %.195.sroa.sel201, align 8
  %169 = call ptr @behavior_wrapper(ptr %133, { ptr, ptr, ptr, i32 } %166, ptr noundef nonnull align 8 dereferenceable(24) %.195)
  call void %169({ ptr, ptr, ptr, i32 } %166, { ptr, ptr, ptr, i32 } %166, ptr nonnull %.194, { ptr } %160, i32 4, i32 5) #39
  %170 = ptrtoint ptr %163 to i64
  %.sroa.3.8.insert.ext = zext i64 %170 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %171 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %.196, align 8
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.196)
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %.197, align 8
  %174 = call ptr @class_behavior_wrapper(ptr %157, ptr noundef nonnull align 8 dereferenceable(8) %.197)
  call void %174(ptr nonnull %.196, { ptr, i160 } %171) #39
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %.sroa.0237.sroa.0 = alloca i8, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca [3 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca { ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca [3 x ptr], align 8
  %20 = alloca { ptr, ptr, ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca [3 x ptr], align 8
  %29 = alloca { ptr, ptr, ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca { ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca [3 x ptr], align 8
  %36 = alloca { ptr, ptr, ptr }, align 8
  %37 = alloca [1 x ptr], align 8
  %38 = alloca [3 x ptr], align 8
  %39 = alloca { ptr, ptr, ptr }, align 8
  %40 = alloca [1 x ptr], align 8
  %41 = alloca { ptr }, align 8
  %42 = alloca [1 x ptr], align 8
  %43 = alloca [3 x ptr], align 8
  %44 = alloca { ptr, ptr, ptr }, align 8
  %45 = alloca [1 x ptr], align 8
  %46 = alloca { ptr }, align 8
  %47 = alloca [1 x ptr], align 8
  %48 = alloca [3 x ptr], align 8
  %49 = alloca { ptr, ptr, ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @_parameterization_i32, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %52, i64 16
  store ptr @_parameterization_i32, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %52, i64 24
  store ptr @_parameterization_Pairi32._i32, ptr %55, align 8
  %56 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 48), align 8
  %57 = call { i64, i64 } @size_wrapper(ptr %56, ptr noundef nonnull align 8 dereferenceable(32) %52)
  %58 = extractvalue { i64, i64 } %57, 0
  %59 = call ptr @bump_malloc(i64 %58)
  store ptr @_parameterization_i32, ptr %59, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  store ptr @_parameterization_i32, ptr %60, align 8
  %61 = getelementptr i8, ptr %59, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %61, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %59)
  %63 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %63)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %63, ptr noalias nofree noundef nonnull readnone @oxgghllhom, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %64 = call ptr @adjust_trampoline(ptr %63)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %63)
  %66 = insertvalue { ptr } undef, ptr %64, 0
  %67 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %67)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %67, ptr noalias nofree noundef nonnull readnone @vaxeopwwdi, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %68 = call ptr @adjust_trampoline(ptr %67)
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %67)
  %70 = insertvalue { ptr } undef, ptr %68, 0
  %71 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %59, 1
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr undef, 2
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, i32 10, 3
  %74 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %74, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %75, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %74)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %78 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 160), align 8
  %79 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr @function_typ, ptr %80, align 8
  %81 = call ptr @behavior_wrapper(ptr %78, { ptr, ptr, ptr, i32 } %73, ptr noundef nonnull align 8 dereferenceable(16) %79)
  call void %81({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull %74, { ptr } %66, { ptr } %70) #39
  %82 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %82, align 8
  %83 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %82)
  %84 = extractvalue { i64, i64 } %83, 0
  %85 = call ptr @bump_malloc(i64 %84)
  %86 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %85, 1
  %87 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr undef, 2
  %88 = insertvalue { ptr, ptr, ptr, i32 } %87, i32 10, 3
  %89 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %89, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %92 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %92, align 8
  %93 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %88, ptr noundef nonnull align 8 dereferenceable(8) %92)
  call void %93({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr nonnull %89, i32 456) #39
  %94 = alloca [2 x ptr], align 8
  store ptr @Array, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %94, i64 8
  store ptr @_parameterization_i32, ptr %95, align 8
  %96 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 48), align 8
  %97 = call { i64, i64 } @size_wrapper(ptr %96, ptr noundef nonnull align 8 dereferenceable(16) %94)
  %98 = extractvalue { i64, i64 } %97, 0
  %99 = call ptr @bump_malloc(i64 %98)
  store ptr @_parameterization_i32, ptr %99, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %99)
  %101 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %99, 1
  %102 = insertvalue { ptr, ptr, ptr, i32 } %101, ptr undef, 2
  %103 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 10, 3
  %104 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %104)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  %107 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 128), align 8
  %108 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %108, align 8
  %109 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 dereferenceable(8) %108)
  call void %109({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull %104, i32 %0) #39
  %110 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr @_parameterization_i32, ptr %111, align 8
  %112 = getelementptr inbounds i8, ptr %110, i64 16
  store ptr @_parameterization_Bool, ptr %112, align 8
  %113 = getelementptr inbounds i8, ptr %110, i64 24
  store ptr @_parameterization_Pairi32._Bool, ptr %113, align 8
  %114 = call { i64, i64 } @size_wrapper(ptr %56, ptr noundef nonnull align 8 dereferenceable(32) %110)
  %115 = extractvalue { i64, i64 } %114, 0
  %116 = call ptr @bump_malloc(i64 %115)
  store ptr @_parameterization_i32, ptr %116, align 8
  %117 = getelementptr i8, ptr %116, i64 8
  store ptr @_parameterization_Bool, ptr %117, align 8
  %118 = getelementptr i8, ptr %116, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %118, align 8
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %116)
  %120 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %120)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %120, ptr noalias nofree noundef nonnull readnone @hkbtwjjhqj, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %121 = call ptr @adjust_trampoline(ptr %120)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %120)
  %123 = insertvalue { ptr } undef, ptr %121, 0
  %124 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %124)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %124, ptr noalias nofree noundef nonnull readnone @cfjkgytwfj, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %125 = call ptr @adjust_trampoline(ptr %124)
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %124)
  %127 = insertvalue { ptr } undef, ptr %125, 0
  %128 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %116, 1
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr undef, 2
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, i32 10, 3
  %131 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %131, align 8
  %132 = getelementptr inbounds i8, ptr %131, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %132, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %131)
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %135 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %135, align 8
  %136 = getelementptr inbounds i8, ptr %135, i64 8
  store ptr @function_typ, ptr %136, align 8
  %137 = call ptr @behavior_wrapper(ptr %78, { ptr, ptr, ptr, i32 } %130, ptr noundef nonnull align 8 dereferenceable(16) %135)
  call void %137({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull %131, { ptr } %123, { ptr } %127) #39
  %138 = mul i32 %0, 10
  %139 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  %140 = getelementptr inbounds i8, ptr %5, i64 8
  %141 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 248), align 8
  %142 = getelementptr inbounds i8, ptr %6, i64 8
  %143 = getelementptr inbounds i8, ptr %7, i64 8
  %144 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 216), align 8
  %145 = getelementptr inbounds i8, ptr %8, i64 8
  %146 = getelementptr inbounds i8, ptr %9, i64 8
  %147 = getelementptr inbounds i8, ptr %10, i64 8
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge1, %1
  %.0288 = phi i64 [ 0, %1 ], [ %.2290, %._crit_edge1 ]
  %.0279 = phi i32 [ 0, %1 ], [ %.2281, %._crit_edge1 ]
  %.0277 = phi i32 [ 0, %1 ], [ %.1278, %._crit_edge1 ]
  %148 = icmp slt i32 %.0279, %0
  %149 = icmp slt i32 %.0277, %138
  %spec.select = select i1 %148, i1 %149, i1 false
  br i1 %spec.select, label %150, label %._crit_edge1

150:                                              ; preds = %._crit_edge3
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %153 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %88, ptr noundef nonnull align 8 %2)
  %154 = call i32 %153({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr nonnull %2) #39
  %.sroa.0265.0.insert.ext = zext i32 %154 to i160
  %155 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0265.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %4, align 8
  %158 = call ptr @behavior_wrapper(ptr %139, { ptr, ptr, ptr, i32 } %130, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %159 = call { ptr, i160 } %158({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull %3, { ptr, i160 } %155) #39
  %.fca.0.extract257 = extractvalue { ptr, i160 } %159, 0
  %160 = icmp eq ptr %.fca.0.extract257, @nil_typ
  %161 = icmp eq ptr %.fca.0.extract257, null
  %162 = or i1 %160, %161
  br i1 %162, label %163, label %._crit_edge2

163:                                              ; preds = %150
  %164 = add i32 %154, 1
  %.sroa.0247.0.insert.ext = zext i32 %164 to i160
  %165 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0247.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %140, align 8
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %6, align 8
  store ptr @i32_typ, ptr %142, align 8
  %168 = call ptr @behavior_wrapper(ptr %141, { ptr, ptr, ptr, i32 } %73, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %168({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull %5, { ptr, i160 } %155, { ptr, i160 } %165) #39
  store ptr @_parameterization_i32, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %143, align 8
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  store ptr @i32_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %145, align 8
  %171 = call ptr @behavior_wrapper(ptr %144, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %171({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull %7, i32 %.0279, { ptr, i160 } %155) #39
  store i1 true, ptr %.sroa.0237.sroa.0, align 8
  %.sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.0. = load i8, ptr %.sroa.0237.sroa.0, align 8
  %.sroa.0237.0.insert.ext = zext i8 %.sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.sroa.0.0..sroa.0237.0. to i160
  %172 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0237.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %9, align 8
  store ptr @_parameterization_Bool, ptr %146, align 8
  %173 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9)
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %10, align 8
  store ptr @bool_typ, ptr %147, align 8
  %175 = call ptr @behavior_wrapper(ptr %141, { ptr, ptr, ptr, i32 } %130, ptr noundef nonnull align 8 dereferenceable(16) %10)
  call void %175({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull %9, { ptr, i160 } %155, { ptr, i160 } %172) #39
  %176 = sext i32 %164 to i64
  %177 = add i64 %.0288, %176
  %178 = add nsw i32 %.0279, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %163, %150
  %.1289 = phi i64 [ %177, %163 ], [ %.0288, %150 ]
  %.1280 = phi i32 [ %178, %163 ], [ %.0279, %150 ]
  %179 = add i32 %.0277, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge2, %._crit_edge3
  %.2290 = phi i64 [ %.1289, %._crit_edge2 ], [ %.0288, %._crit_edge3 ]
  %.2281 = phi i32 [ %.1280, %._crit_edge2 ], [ %.0279, %._crit_edge3 ]
  %.1278 = phi i32 [ %179, %._crit_edge2 ], [ %.0277, %._crit_edge3 ]
  br i1 %spec.select, label %._crit_edge3, label %180

180:                                              ; preds = %._crit_edge1
  %181 = icmp slt i32 %.2281, %0
  br i1 %181, label %182, label %._crit_edge4

182:                                              ; preds = %180
  %183 = call ptr @bump_malloc(i64 noundef 30)
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %183, align 1
  store ptr @String, ptr %11, align 8
  %184 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %185 = call { i64, i64 } @size_wrapper(ptr %184, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %186 = extractvalue { i64, i64 } %185, 0
  %187 = call ptr @bump_malloc(i64 %186)
  %188 = insertvalue { ptr } undef, ptr %183, 0
  %189 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %187, 1
  %190 = insertvalue { ptr, ptr, ptr, i32 } %189, ptr undef, 2
  %191 = insertvalue { ptr, ptr, ptr, i32 } %190, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %12, align 8
  %192 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @_parameterization_i32, ptr %192, align 8
  %193 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %193, align 8
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %12)
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %196 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %13, align 8
  %197 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr @i32_typ, ptr %197, align 8
  %198 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %198, align 8
  %199 = call ptr @behavior_wrapper(ptr %196, { ptr, ptr, ptr, i32 } %191, ptr noundef nonnull align 8 dereferenceable(24) %13)
  call void %199({ ptr, ptr, ptr, i32 } %191, { ptr, ptr, ptr, i32 } %191, ptr nonnull %12, { ptr } %188, i32 29, i32 30) #39
  %200 = ptrtoint ptr %187 to i64
  %.sroa.3218.8.insert.ext = zext i64 %200 to i160
  %.sroa.3218.8.insert.insert = or disjoint i160 %.sroa.3218.8.insert.ext, 3402823669209384634633746074317682114560
  %201 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3218.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %14, align 8
  %202 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %203 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %204 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %15, align 8
  %205 = call ptr @class_behavior_wrapper(ptr %204, ptr noundef nonnull align 8 dereferenceable(8) %15)
  call void %205(ptr nonnull %14, { ptr, i160 } %201) #39
  %.sroa.0212.0.insert.ext = zext i32 %.2281 to i160
  %206 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0212.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %16, align 8
  %207 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %17, align 8
  %209 = call ptr @class_behavior_wrapper(ptr %204, ptr noundef nonnull align 8 dereferenceable(8) %17)
  call void %209(ptr nonnull %16, { ptr, i160 } %206) #39
  %210 = call ptr @bump_malloc(i64 noundef 34)
  %211 = load <33 x i8>, ptr @yylhu__unique_keys_for_random_hit_test, align 64
  store <33 x i8> %211, ptr %210, align 1
  store ptr @String, ptr %18, align 8
  %212 = call { i64, i64 } @size_wrapper(ptr %184, ptr noundef nonnull align 8 dereferenceable(8) %18)
  %213 = extractvalue { i64, i64 } %212, 0
  %214 = call ptr @bump_malloc(i64 %213)
  %215 = insertvalue { ptr } undef, ptr %210, 0
  %216 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %214, 1
  %217 = insertvalue { ptr, ptr, ptr, i32 } %216, ptr undef, 2
  %218 = insertvalue { ptr, ptr, ptr, i32 } %217, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %19, align 8
  %219 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr @_parameterization_i32, ptr %219, align 8
  %220 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr @_parameterization_i32, ptr %220, align 8
  %221 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %19)
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %20, align 8
  %223 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @i32_typ, ptr %223, align 8
  %224 = getelementptr inbounds i8, ptr %20, i64 16
  store ptr @i32_typ, ptr %224, align 8
  %225 = call ptr @behavior_wrapper(ptr %196, { ptr, ptr, ptr, i32 } %218, ptr noundef nonnull align 8 dereferenceable(24) %20)
  call void %225({ ptr, ptr, ptr, i32 } %218, { ptr, ptr, ptr, i32 } %218, ptr nonnull %19, { ptr } %215, i32 33, i32 34) #39
  %226 = ptrtoint ptr %214 to i64
  %.sroa.3200.8.insert.ext = zext i64 %226 to i160
  %.sroa.3200.8.insert.insert = or disjoint i160 %.sroa.3200.8.insert.ext, 3402823669209384634633746074317682114560
  %227 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3200.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %21, align 8
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %22, align 8
  %230 = call ptr @class_behavior_wrapper(ptr %204, ptr noundef nonnull align 8 dereferenceable(8) %22)
  call void %230(ptr nonnull %21, { ptr, i160 } %227) #39
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %182, %180
  %.0287 = phi i32 [ %.2281, %182 ], [ %0, %180 ]
  %231 = call i64 @clock()
  %232 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 208), align 8
  %233 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  %234 = load <51 x i8>, ptr @khbst_Error_Nil_returned_during_random_hit_test_for_key_, align 64
  %235 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %236 = getelementptr inbounds i8, ptr %28, i64 8
  %237 = getelementptr inbounds i8, ptr %28, i64 16
  %238 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  %239 = getelementptr inbounds i8, ptr %29, i64 8
  %240 = getelementptr inbounds i8, ptr %29, i64 16
  %241 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %._crit_edge5, %._crit_edge4
  %.0285 = phi i32 [ 0, %._crit_edge4 ], [ %.1286, %._crit_edge5 ]
  %.0282 = phi i1 [ true, %._crit_edge4 ], [ %.2284, %._crit_edge5 ]
  %.0276 = phi i64 [ 0, %._crit_edge4 ], [ %.2, %._crit_edge5 ]
  %242 = icmp slt i32 %.0285, %.0287
  br i1 %242, label %243, label %._crit_edge5

243:                                              ; preds = %._crit_edge6
  store ptr @_parameterization_i32, ptr %23, align 8
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  store ptr @i32_typ, ptr %24, align 8
  %246 = call ptr @behavior_wrapper(ptr %232, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 dereferenceable(8) %24)
  %247 = call { ptr, i160 } %246({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull %23, i32 %.0285) #39
  %.fca.1.extract185 = extractvalue { ptr, i160 } %247, 1
  %.sroa.0180.0.insert.ext = and i160 %.fca.1.extract185, 4294967295
  %248 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0180.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %25, align 8
  %249 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %250 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %26, align 8
  %251 = call ptr @behavior_wrapper(ptr %233, { ptr, ptr, ptr, i32 } %73, ptr noundef nonnull align 8 dereferenceable(8) %26)
  %252 = call { ptr, i160 } %251({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull %25, { ptr, i160 } %248) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %252, 0
  %253 = icmp ne ptr %.fca.0.extract, @nil_typ
  %254 = icmp ne ptr %.fca.0.extract, null
  %.not294 = and i1 %253, %254
  br i1 %.not294, label %255, label %258

255:                                              ; preds = %243
  %.fca.1.extract = extractvalue { ptr, i160 } %252, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %256 = sext i32 %.sroa.2.8.extract.trunc to i64
  %257 = add i64 %.0276, %256
  br label %278

258:                                              ; preds = %243
  %259 = call ptr @bump_malloc(i64 noundef 52)
  store <51 x i8> %234, ptr %259, align 1
  store ptr @String, ptr %27, align 8
  %260 = call { i64, i64 } @size_wrapper(ptr %235, ptr noundef nonnull align 8 dereferenceable(8) %27)
  %261 = extractvalue { i64, i64 } %260, 0
  %262 = call ptr @bump_malloc(i64 %261)
  %263 = insertvalue { ptr } undef, ptr %259, 0
  %264 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %262, 1
  %265 = insertvalue { ptr, ptr, ptr, i32 } %264, ptr undef, 2
  %266 = insertvalue { ptr, ptr, ptr, i32 } %265, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %28, align 8
  store ptr @_parameterization_i32, ptr %236, align 8
  store ptr @_parameterization_i32, ptr %237, align 8
  %267 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %28)
  %268 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %29, align 8
  store ptr @i32_typ, ptr %239, align 8
  store ptr @i32_typ, ptr %240, align 8
  %269 = call ptr @behavior_wrapper(ptr %238, { ptr, ptr, ptr, i32 } %266, ptr noundef nonnull align 8 dereferenceable(24) %29)
  call void %269({ ptr, ptr, ptr, i32 } %266, { ptr, ptr, ptr, i32 } %266, ptr nonnull %28, { ptr } %263, i32 51, i32 52) #39
  %270 = ptrtoint ptr %262 to i64
  %.sroa.3155.8.insert.ext = zext i64 %270 to i160
  %.sroa.3155.8.insert.insert = or disjoint i160 %.sroa.3155.8.insert.ext, 3402823669209384634633746074317682114560
  %271 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3155.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %30, align 8
  %272 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %273 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %31, align 8
  %274 = call ptr @class_behavior_wrapper(ptr %241, ptr noundef nonnull align 8 dereferenceable(8) %31)
  call void %274(ptr nonnull %30, { ptr, i160 } %271) #39
  store ptr @_parameterization_i32, ptr %32, align 8
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %33, align 8
  %277 = call ptr @class_behavior_wrapper(ptr %241, ptr noundef nonnull align 8 dereferenceable(8) %33)
  call void %277(ptr nonnull %32, { ptr, i160 } %248) #39
  br label %278

278:                                              ; preds = %258, %255
  %.1283 = phi i1 [ %.0282, %255 ], [ false, %258 ]
  %.1 = phi i64 [ %257, %255 ], [ %.0276, %258 ]
  %279 = add i32 %.0285, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %278, %._crit_edge6
  %.1286 = phi i32 [ %279, %278 ], [ %.0285, %._crit_edge6 ]
  %.2284 = phi i1 [ %.1283, %278 ], [ %.0282, %._crit_edge6 ]
  %.2 = phi i64 [ %.1, %278 ], [ %.0276, %._crit_edge6 ]
  br i1 %242, label %._crit_edge6, label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5
  %280 = call i64 @clock()
  %.not = icmp eq i64 %.2, %.2290
  %spec.select295 = select i1 %.not, i1 %.2284, i1 false
  %281 = call ptr @bump_malloc(i64 noundef 15)
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %281, align 1
  store ptr @String, ptr %34, align 8
  %282 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %283 = call { i64, i64 } @size_wrapper(ptr %282, ptr noundef nonnull align 8 dereferenceable(8) %34)
  %284 = extractvalue { i64, i64 } %283, 0
  %285 = call ptr @bump_malloc(i64 %284)
  %286 = insertvalue { ptr } undef, ptr %281, 0
  %287 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %285, 1
  %288 = insertvalue { ptr, ptr, ptr, i32 } %287, ptr undef, 2
  %289 = insertvalue { ptr, ptr, ptr, i32 } %288, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %35, align 8
  %290 = getelementptr inbounds i8, ptr %35, i64 8
  store ptr @_parameterization_i32, ptr %290, align 8
  %291 = getelementptr inbounds i8, ptr %35, i64 16
  store ptr @_parameterization_i32, ptr %291, align 8
  %292 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %35)
  %293 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %294 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %36, align 8
  %295 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr @i32_typ, ptr %295, align 8
  %296 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr @i32_typ, ptr %296, align 8
  %297 = call ptr @behavior_wrapper(ptr %294, { ptr, ptr, ptr, i32 } %289, ptr noundef nonnull align 8 dereferenceable(24) %36)
  call void %297({ ptr, ptr, ptr, i32 } %289, { ptr, ptr, ptr, i32 } %289, ptr nonnull %35, { ptr } %286, i32 14, i32 15) #39
  %298 = sub i64 %280, %231
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %289, i32 %.0287, i64 %298)
  %299 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %299, align 1
  store ptr @String, ptr %37, align 8
  %300 = call { i64, i64 } @size_wrapper(ptr %282, ptr noundef nonnull align 8 dereferenceable(8) %37)
  %301 = extractvalue { i64, i64 } %300, 0
  %302 = call ptr @bump_malloc(i64 %301)
  %303 = insertvalue { ptr } undef, ptr %299, 0
  %304 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %302, 1
  %305 = insertvalue { ptr, ptr, ptr, i32 } %304, ptr undef, 2
  %306 = insertvalue { ptr, ptr, ptr, i32 } %305, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %38, align 8
  %307 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr @_parameterization_i32, ptr %307, align 8
  %308 = getelementptr inbounds i8, ptr %38, i64 16
  store ptr @_parameterization_i32, ptr %308, align 8
  %309 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %38)
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %39, align 8
  %311 = getelementptr inbounds i8, ptr %39, i64 8
  store ptr @i32_typ, ptr %311, align 8
  %312 = getelementptr inbounds i8, ptr %39, i64 16
  store ptr @i32_typ, ptr %312, align 8
  %313 = call ptr @behavior_wrapper(ptr %294, { ptr, ptr, ptr, i32 } %306, ptr noundef nonnull align 8 dereferenceable(24) %39)
  call void %313({ ptr, ptr, ptr, i32 } %306, { ptr, ptr, ptr, i32 } %306, ptr nonnull %38, { ptr } %303, i32 18, i32 19) #39
  %314 = ptrtoint ptr %302 to i64
  %.sroa.3115.8.insert.ext = zext i64 %314 to i160
  %.sroa.3115.8.insert.insert = or disjoint i160 %.sroa.3115.8.insert.ext, 3402823669209384634633746074317682114560
  %315 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3115.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %40, align 8
  %316 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %40)
  %317 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %318 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %41, align 8
  %319 = call ptr @class_behavior_wrapper(ptr %318, ptr noundef nonnull align 8 dereferenceable(8) %41)
  call void %319(ptr nonnull %40, { ptr, i160 } %315) #39
  %320 = call ptr @bump_malloc(i64 noundef 5)
  %321 = insertvalue { ptr } undef, ptr %320, 0
  %. = select i1 %spec.select295, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.329 = select i1 %spec.select295, ptr %42, ptr %47
  %.330 = select i1 %spec.select295, ptr %43, ptr %48
  %.331 = select i1 %spec.select295, ptr %44, ptr %49
  %.332 = select i1 %spec.select295, ptr %45, ptr %50
  %.333 = select i1 %spec.select295, ptr %46, ptr %51
  store <4 x i8> %., ptr %320, align 1
  store ptr @String, ptr %.329, align 8
  %322 = call { i64, i64 } @size_wrapper(ptr %282, ptr noundef nonnull align 8 dereferenceable(8) %.329)
  %323 = extractvalue { i64, i64 } %322, 0
  %324 = call ptr @bump_malloc(i64 %323)
  %325 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %324, 1
  %326 = insertvalue { ptr, ptr, ptr, i32 } %325, ptr undef, 2
  %327 = insertvalue { ptr, ptr, ptr, i32 } %326, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %.330, align 8
  %.330.sroa.sel.v = select i1 %spec.select295, ptr %43, ptr %48
  %.330.sroa.sel = getelementptr inbounds i8, ptr %.330.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.330.sroa.sel, align 8
  %.330.sroa.sel342.v = select i1 %spec.select295, ptr %43, ptr %48
  %.330.sroa.sel342 = getelementptr inbounds i8, ptr %.330.sroa.sel342.v, i64 16
  store ptr @_parameterization_i32, ptr %.330.sroa.sel342, align 8
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.330)
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %.331, align 8
  %.331.sroa.sel.v = select i1 %spec.select295, ptr %44, ptr %49
  %.331.sroa.sel = getelementptr inbounds i8, ptr %.331.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.331.sroa.sel, align 8
  %.331.sroa.sel337.v = select i1 %spec.select295, ptr %44, ptr %49
  %.331.sroa.sel337 = getelementptr inbounds i8, ptr %.331.sroa.sel337.v, i64 16
  store ptr @i32_typ, ptr %.331.sroa.sel337, align 8
  %330 = call ptr @behavior_wrapper(ptr %294, { ptr, ptr, ptr, i32 } %327, ptr noundef nonnull align 8 dereferenceable(24) %.331)
  call void %330({ ptr, ptr, ptr, i32 } %327, { ptr, ptr, ptr, i32 } %327, ptr nonnull %.330, { ptr } %321, i32 4, i32 5) #39
  %331 = ptrtoint ptr %324 to i64
  %.sroa.3.8.insert.ext = zext i64 %331 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %332 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %.332, align 8
  %333 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.332)
  %334 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %.333, align 8
  %335 = call ptr @class_behavior_wrapper(ptr %318, ptr noundef nonnull align 8 dereferenceable(8) %.333)
  call void %335(ptr nonnull %.332, { ptr, i160 } %332) #39
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %.sroa.0340.sroa.0 = alloca i8, align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %14 = alloca [2 x ptr], align 8
  %15 = alloca { ptr, ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca [3 x ptr], align 8
  %18 = alloca { ptr, ptr, ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca [3 x ptr], align 8
  %25 = alloca { ptr, ptr, ptr }, align 8
  %26 = alloca [1 x ptr], align 8
  %27 = alloca { ptr }, align 8
  %28 = alloca [1 x ptr], align 8
  %29 = alloca { ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca [3 x ptr], align 8
  %34 = alloca { ptr, ptr, ptr }, align 8
  %35 = alloca [1 x ptr], align 8
  %36 = alloca [3 x ptr], align 8
  %37 = alloca { ptr, ptr, ptr }, align 8
  %38 = alloca [1 x ptr], align 8
  %39 = alloca { ptr }, align 8
  %40 = alloca [1 x ptr], align 8
  %41 = alloca [3 x ptr], align 8
  %42 = alloca { ptr, ptr, ptr }, align 8
  %43 = alloca [1 x ptr], align 8
  %44 = alloca { ptr }, align 8
  %45 = alloca [1 x ptr], align 8
  %46 = alloca [3 x ptr], align 8
  %47 = alloca { ptr, ptr, ptr }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca [3 x ptr], align 8
  %52 = alloca { ptr, ptr, ptr }, align 8
  %53 = alloca [1 x ptr], align 8
  %54 = alloca { ptr }, align 8
  %55 = alloca [1 x ptr], align 8
  %56 = alloca { ptr }, align 8
  %57 = alloca [1 x ptr], align 8
  %58 = alloca [3 x ptr], align 8
  %59 = alloca { ptr, ptr, ptr }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [1 x ptr], align 8
  %63 = alloca { ptr }, align 8
  %64 = alloca [1 x ptr], align 8
  %65 = alloca [3 x ptr], align 8
  %66 = alloca { ptr, ptr, ptr }, align 8
  %67 = alloca [1 x ptr], align 8
  %68 = alloca { ptr }, align 8
  %69 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %69, i64 8
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %69, i64 16
  store ptr @_parameterization_i32, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %69, i64 24
  store ptr @_parameterization_Pairi32._i32, ptr %72, align 8
  %73 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 48), align 8
  %74 = call { i64, i64 } @size_wrapper(ptr %73, ptr noundef nonnull align 8 dereferenceable(32) %69)
  %75 = extractvalue { i64, i64 } %74, 0
  %76 = call ptr @bump_malloc(i64 %75)
  store ptr @_parameterization_i32, ptr %76, align 8
  %77 = getelementptr i8, ptr %76, i64 8
  store ptr @_parameterization_i32, ptr %77, align 8
  %78 = getelementptr i8, ptr %76, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %78, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %76)
  %80 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %80)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %80, ptr noalias nofree noundef nonnull readnone @hbaqvtggfm, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %81 = call ptr @adjust_trampoline(ptr %80)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %80)
  %83 = insertvalue { ptr } undef, ptr %81, 0
  %84 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %84)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %84, ptr noalias nofree noundef nonnull readnone @pvnidioudp, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %85 = call ptr @adjust_trampoline(ptr %84)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %84)
  %87 = insertvalue { ptr } undef, ptr %85, 0
  %88 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %76, 1
  %89 = insertvalue { ptr, ptr, ptr, i32 } %88, ptr undef, 2
  %90 = insertvalue { ptr, ptr, ptr, i32 } %89, i32 10, 3
  %91 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %91, align 8
  %92 = getelementptr inbounds i8, ptr %91, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %92, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %91)
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %95 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 160), align 8
  %96 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %96, align 8
  %97 = getelementptr inbounds i8, ptr %96, i64 8
  store ptr @function_typ, ptr %97, align 8
  %98 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %90, ptr noundef nonnull align 8 dereferenceable(16) %96)
  call void %98({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr nonnull %91, { ptr } %83, { ptr } %87) #39
  %99 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %99, align 8
  %100 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %99)
  %101 = extractvalue { i64, i64 } %100, 0
  %102 = call ptr @bump_malloc(i64 %101)
  %103 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %102, 1
  %104 = insertvalue { ptr, ptr, ptr, i32 } %103, ptr undef, 2
  %105 = insertvalue { ptr, ptr, ptr, i32 } %104, i32 10, 3
  %106 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %106, align 8
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %106)
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %109 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %109, align 8
  %110 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %105, ptr noundef nonnull align 8 dereferenceable(8) %109)
  call void %110({ ptr, ptr, ptr, i32 } %105, { ptr, ptr, ptr, i32 } %105, ptr nonnull %106, i32 789) #39
  %111 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %111, align 8
  %112 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %111)
  %113 = extractvalue { i64, i64 } %112, 0
  %114 = call ptr @bump_malloc(i64 %113)
  %115 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %114, 1
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr undef, 2
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, i32 10, 3
  %118 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %118, align 8
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %118)
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %121 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %121, align 8
  %122 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %117, ptr noundef nonnull align 8 dereferenceable(8) %121)
  call void %122({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull %118, i32 987) #39
  %123 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %123, align 8
  %124 = getelementptr inbounds i8, ptr %123, i64 8
  store ptr @_parameterization_i32, ptr %124, align 8
  %125 = getelementptr inbounds i8, ptr %123, i64 16
  store ptr @_parameterization_Bool, ptr %125, align 8
  %126 = getelementptr inbounds i8, ptr %123, i64 24
  store ptr @_parameterization_Pairi32._Bool, ptr %126, align 8
  %127 = call { i64, i64 } @size_wrapper(ptr %73, ptr noundef nonnull align 8 dereferenceable(32) %123)
  %128 = extractvalue { i64, i64 } %127, 0
  %129 = call ptr @bump_malloc(i64 %128)
  store ptr @_parameterization_i32, ptr %129, align 8
  %130 = getelementptr i8, ptr %129, i64 8
  store ptr @_parameterization_Bool, ptr %130, align 8
  %131 = getelementptr i8, ptr %129, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %131, align 8
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %129)
  %133 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %133)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %133, ptr noalias nofree noundef nonnull readnone @agkclrhtzs, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %134 = call ptr @adjust_trampoline(ptr %133)
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %133)
  %136 = insertvalue { ptr } undef, ptr %134, 0
  %137 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %137)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %137, ptr noalias nofree noundef nonnull readnone @hnbsvmhnda, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %138 = call ptr @adjust_trampoline(ptr %137)
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %137)
  %140 = insertvalue { ptr } undef, ptr %138, 0
  %141 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %129, 1
  %142 = insertvalue { ptr, ptr, ptr, i32 } %141, ptr undef, 2
  %143 = insertvalue { ptr, ptr, ptr, i32 } %142, i32 10, 3
  %144 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %144, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %145, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %144)
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %148 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %148, align 8
  %149 = getelementptr inbounds i8, ptr %148, i64 8
  store ptr @function_typ, ptr %149, align 8
  %150 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %143, ptr noundef nonnull align 8 dereferenceable(16) %148)
  call void %150({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr nonnull %144, { ptr } %136, { ptr } %140) #39
  %151 = mul i32 %0, 10
  %152 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  %153 = getelementptr inbounds i8, ptr %5, i64 8
  %154 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 248), align 8
  %155 = getelementptr inbounds i8, ptr %6, i64 8
  %156 = getelementptr inbounds i8, ptr %7, i64 8
  %157 = getelementptr inbounds i8, ptr %8, i64 8
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge1, %1
  %.0378 = phi i32 [ 0, %1 ], [ %.2380, %._crit_edge1 ]
  %.0375 = phi i32 [ 0, %1 ], [ %.1376, %._crit_edge1 ]
  %158 = icmp slt i32 %.0378, %0
  %159 = icmp slt i32 %.0375, %151
  %spec.select = select i1 %158, i1 %159, i1 false
  br i1 %spec.select, label %160, label %._crit_edge1

160:                                              ; preds = %._crit_edge3
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %163 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %105, ptr noundef nonnull align 8 %2)
  %164 = call i32 %163({ ptr, ptr, ptr, i32 } %105, { ptr, ptr, ptr, i32 } %105, ptr nonnull %2) #39
  %.sroa.0364.0.insert.ext = zext i32 %164 to i160
  %165 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0364.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %4, align 8
  %168 = call ptr @behavior_wrapper(ptr %152, { ptr, ptr, ptr, i32 } %143, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %169 = call { ptr, i160 } %168({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr nonnull %3, { ptr, i160 } %165) #39
  %.fca.0.extract356 = extractvalue { ptr, i160 } %169, 0
  %170 = icmp eq ptr %.fca.0.extract356, @nil_typ
  %171 = icmp eq ptr %.fca.0.extract356, null
  %172 = or i1 %170, %171
  br i1 %172, label %173, label %._crit_edge2

173:                                              ; preds = %160
  %174 = add i32 %164, 1
  %.sroa.0347.0.insert.ext = zext i32 %174 to i160
  %175 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0347.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %153, align 8
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %177 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %6, align 8
  store ptr @i32_typ, ptr %155, align 8
  %178 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %90, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %178({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr nonnull %5, { ptr, i160 } %165, { ptr, i160 } %175) #39
  store i1 true, ptr %.sroa.0340.sroa.0, align 8
  %.sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.0. = load i8, ptr %.sroa.0340.sroa.0, align 8
  %.sroa.0340.0.insert.ext = zext i8 %.sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.sroa.0.0..sroa.0340.0. to i160
  %179 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0340.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %7, align 8
  store ptr @_parameterization_Bool, ptr %156, align 8
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %8, align 8
  store ptr @bool_typ, ptr %157, align 8
  %182 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %143, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %182({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr nonnull %7, { ptr, i160 } %165, { ptr, i160 } %179) #39
  %183 = add nsw i32 %.0378, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %173, %160
  %.1379 = phi i32 [ %183, %173 ], [ %.0378, %160 ]
  %184 = add i32 %.0375, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge2, %._crit_edge3
  %.2380 = phi i32 [ %.1379, %._crit_edge2 ], [ %.0378, %._crit_edge3 ]
  %.1376 = phi i32 [ %184, %._crit_edge2 ], [ %.0375, %._crit_edge3 ]
  br i1 %spec.select, label %._crit_edge3, label %185

185:                                              ; preds = %._crit_edge1
  store ptr @Array, ptr %9, align 8
  %186 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @_parameterization_i32, ptr %186, align 8
  %187 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 48), align 8
  %188 = call { i64, i64 } @size_wrapper(ptr %187, ptr noundef nonnull align 8 dereferenceable(16) %9)
  %189 = extractvalue { i64, i64 } %188, 0
  %190 = call ptr @bump_malloc(i64 %189)
  store ptr @_parameterization_i32, ptr %190, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %190)
  %192 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %190, 1
  %193 = insertvalue { ptr, ptr, ptr, i32 } %192, ptr undef, 2
  %194 = insertvalue { ptr, ptr, ptr, i32 } %193, i32 10, 3
  store ptr @_parameterization_i32, ptr %10, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  %197 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 128), align 8
  store ptr @i32_typ, ptr %11, align 8
  %198 = call ptr @behavior_wrapper(ptr %197, { ptr, ptr, ptr, i32 } %194, ptr noundef nonnull align 8 dereferenceable(8) %11)
  call void %198({ ptr, ptr, ptr, i32 } %194, { ptr, ptr, ptr, i32 } %194, ptr nonnull %10, i32 %0) #39
  %199 = mul i32 %0, 20
  %200 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  %201 = getelementptr inbounds i8, ptr %14, i64 8
  %202 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 216), align 8
  %203 = getelementptr inbounds i8, ptr %15, i64 8
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5, %185
  %.2377 = phi i32 [ 0, %185 ], [ %.3, %._crit_edge5 ]
  %.0374 = phi i32 [ 0, %185 ], [ %.2, %._crit_edge5 ]
  %204 = icmp slt i32 %.0374, %0
  %205 = icmp slt i32 %.2377, %199
  %spec.select401 = select i1 %204, i1 %205, i1 false
  br i1 %spec.select401, label %206, label %._crit_edge5

206:                                              ; preds = %._crit_edge7
  %207 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %209 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %117, ptr noundef nonnull align 8 %2)
  %210 = call i32 %209({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr nonnull %2) #39
  %.sroa.0302.0.insert.ext = zext i32 %210 to i160
  %211 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0302.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %12, align 8
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  %213 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %13, align 8
  %214 = call ptr @behavior_wrapper(ptr %200, { ptr, ptr, ptr, i32 } %143, ptr noundef nonnull align 8 dereferenceable(8) %13)
  %215 = call { ptr, i160 } %214({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr nonnull %12, { ptr, i160 } %211) #39
  %.fca.0.extract294 = extractvalue { ptr, i160 } %215, 0
  %216 = icmp eq ptr %.fca.0.extract294, @nil_typ
  %217 = icmp eq ptr %.fca.0.extract294, null
  %218 = or i1 %216, %217
  br i1 %218, label %219, label %._crit_edge6

219:                                              ; preds = %206
  store ptr @_parameterization_i32, ptr %14, align 8
  store ptr @_parameterization_i32, ptr %201, align 8
  %220 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %14)
  %221 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  store ptr @i32_typ, ptr %15, align 8
  store ptr @i32_typ, ptr %203, align 8
  %222 = call ptr @behavior_wrapper(ptr %202, { ptr, ptr, ptr, i32 } %194, ptr noundef nonnull align 8 dereferenceable(16) %15)
  call void %222({ ptr, ptr, ptr, i32 } %194, { ptr, ptr, ptr, i32 } %194, ptr nonnull %14, i32 %.0374, { ptr, i160 } %211) #39
  %223 = add nsw i32 %.0374, 1
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %219, %206
  %.1 = phi i32 [ %223, %219 ], [ %.0374, %206 ]
  %224 = add i32 %.2377, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge6, %._crit_edge7
  %.3 = phi i32 [ %224, %._crit_edge6 ], [ %.2377, %._crit_edge7 ]
  %.2 = phi i32 [ %.1, %._crit_edge6 ], [ %.0374, %._crit_edge7 ]
  br i1 %spec.select401, label %._crit_edge7, label %225

225:                                              ; preds = %._crit_edge5
  %226 = icmp slt i32 %.2, %0
  br i1 %226, label %227, label %._crit_edge8

227:                                              ; preds = %225
  %228 = call ptr @bump_malloc(i64 noundef 30)
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %228, align 1
  store ptr @String, ptr %16, align 8
  %229 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %230 = call { i64, i64 } @size_wrapper(ptr %229, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %231 = extractvalue { i64, i64 } %230, 0
  %232 = call ptr @bump_malloc(i64 %231)
  %233 = insertvalue { ptr } undef, ptr %228, 0
  %234 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %232, 1
  %235 = insertvalue { ptr, ptr, ptr, i32 } %234, ptr undef, 2
  %236 = insertvalue { ptr, ptr, ptr, i32 } %235, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %17, align 8
  %237 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %237, align 8
  %238 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr @_parameterization_i32, ptr %238, align 8
  %239 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %17)
  %240 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %241 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %18, align 8
  %242 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @i32_typ, ptr %242, align 8
  %243 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @i32_typ, ptr %243, align 8
  %244 = call ptr @behavior_wrapper(ptr %241, { ptr, ptr, ptr, i32 } %236, ptr noundef nonnull align 8 dereferenceable(24) %18)
  call void %244({ ptr, ptr, ptr, i32 } %236, { ptr, ptr, ptr, i32 } %236, ptr nonnull %17, { ptr } %233, i32 29, i32 30) #39
  %245 = ptrtoint ptr %232 to i64
  %.sroa.3273.8.insert.ext = zext i64 %245 to i160
  %.sroa.3273.8.insert.insert = or disjoint i160 %.sroa.3273.8.insert.ext, 3402823669209384634633746074317682114560
  %246 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3273.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %19, align 8
  %247 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19)
  %248 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %249 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %20, align 8
  %250 = call ptr @class_behavior_wrapper(ptr %249, ptr noundef nonnull align 8 dereferenceable(8) %20)
  call void %250(ptr nonnull %19, { ptr, i160 } %246) #39
  %.sroa.0267.0.insert.ext = zext i32 %.2 to i160
  %251 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0267.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %21, align 8
  %252 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %253 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %22, align 8
  %254 = call ptr @class_behavior_wrapper(ptr %249, ptr noundef nonnull align 8 dereferenceable(8) %22)
  call void %254(ptr nonnull %21, { ptr, i160 } %251) #39
  %255 = call ptr @bump_malloc(i64 noundef 23)
  store <22 x i8> <i8 32, i8 103, i8 117, i8 97, i8 114, i8 97, i8 110, i8 116, i8 101, i8 101, i8 100, i8 32, i8 109, i8 105, i8 115, i8 115, i8 32, i8 107, i8 101, i8 121, i8 115, i8 46>, ptr %255, align 1
  store ptr @String, ptr %23, align 8
  %256 = call { i64, i64 } @size_wrapper(ptr %229, ptr noundef nonnull align 8 dereferenceable(8) %23)
  %257 = extractvalue { i64, i64 } %256, 0
  %258 = call ptr @bump_malloc(i64 %257)
  %259 = insertvalue { ptr } undef, ptr %255, 0
  %260 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %258, 1
  %261 = insertvalue { ptr, ptr, ptr, i32 } %260, ptr undef, 2
  %262 = insertvalue { ptr, ptr, ptr, i32 } %261, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %24, align 8
  %263 = getelementptr inbounds i8, ptr %24, i64 8
  store ptr @_parameterization_i32, ptr %263, align 8
  %264 = getelementptr inbounds i8, ptr %24, i64 16
  store ptr @_parameterization_i32, ptr %264, align 8
  %265 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %24)
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %25, align 8
  %267 = getelementptr inbounds i8, ptr %25, i64 8
  store ptr @i32_typ, ptr %267, align 8
  %268 = getelementptr inbounds i8, ptr %25, i64 16
  store ptr @i32_typ, ptr %268, align 8
  %269 = call ptr @behavior_wrapper(ptr %241, { ptr, ptr, ptr, i32 } %262, ptr noundef nonnull align 8 dereferenceable(24) %25)
  call void %269({ ptr, ptr, ptr, i32 } %262, { ptr, ptr, ptr, i32 } %262, ptr nonnull %24, { ptr } %259, i32 22, i32 23) #39
  %270 = ptrtoint ptr %258 to i64
  %.sroa.3255.8.insert.ext = zext i64 %270 to i160
  %.sroa.3255.8.insert.insert = or disjoint i160 %.sroa.3255.8.insert.ext, 3402823669209384634633746074317682114560
  %271 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3255.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %26, align 8
  %272 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  %273 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %27, align 8
  %274 = call ptr @class_behavior_wrapper(ptr %249, ptr noundef nonnull align 8 dereferenceable(8) %27)
  call void %274(ptr nonnull %26, { ptr, i160 } %271) #39
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %227, %225
  %.0397 = phi i32 [ %.2, %227 ], [ %0, %225 ]
  %275 = call i64 @clock()
  %276 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 208), align 8
  %277 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  br label %._crit_edge10

._crit_edge10:                                    ; preds = %._crit_edge9, %._crit_edge8
  %.0388 = phi i32 [ 0, %._crit_edge8 ], [ %.1389, %._crit_edge9 ]
  %.0385 = phi i32 [ 0, %._crit_edge8 ], [ %.1386, %._crit_edge9 ]
  %.0382 = phi i32 [ 0, %._crit_edge8 ], [ %.1383, %._crit_edge9 ]
  %278 = icmp slt i32 %.0388, %.0397
  br i1 %278, label %.cont219, label %._crit_edge9

.cont219:                                         ; preds = %._crit_edge10
  store ptr @_parameterization_i32, ptr %28, align 8
  %279 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  store ptr @i32_typ, ptr %29, align 8
  %281 = call ptr @behavior_wrapper(ptr %276, { ptr, ptr, ptr, i32 } %194, ptr noundef nonnull align 8 dereferenceable(8) %29)
  %282 = call { ptr, i160 } %281({ ptr, ptr, ptr, i32 } %194, { ptr, ptr, ptr, i32 } %194, ptr nonnull %28, i32 %.0388) #39
  %.fca.1.extract233 = extractvalue { ptr, i160 } %282, 1
  %.sroa.0229.0.insert.ext = and i160 %.fca.1.extract233, 4294967295
  %283 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0229.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %30, align 8
  %284 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %31, align 8
  %286 = call ptr @behavior_wrapper(ptr %277, { ptr, ptr, ptr, i32 } %90, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %287 = call { ptr, i160 } %286({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr nonnull %30, { ptr, i160 } %283) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %287, 0
  %288 = icmp eq ptr %.fca.0.extract, @nil_typ
  %289 = icmp eq ptr %.fca.0.extract, null
  %290 = or i1 %288, %289
  %.0382..0385 = select i1 %290, i32 %.0382, i32 %.0385
  %291 = add i32 %.0382..0385, 1
  %.2387 = select i1 %290, i32 %.0385, i32 %291
  %.2384 = select i1 %290, i32 %291, i32 %.0382
  %292 = add nsw i32 %.0388, 1
  br label %._crit_edge9

._crit_edge9:                                     ; preds = %.cont219, %._crit_edge10
  %.1389 = phi i32 [ %292, %.cont219 ], [ %.0388, %._crit_edge10 ]
  %.1386 = phi i32 [ %.2387, %.cont219 ], [ %.0385, %._crit_edge10 ]
  %.1383 = phi i32 [ %.2384, %.cont219 ], [ %.0382, %._crit_edge10 ]
  br i1 %278, label %._crit_edge10, label %293

293:                                              ; preds = %._crit_edge9
  %294 = call i64 @clock()
  %295 = icmp sgt i32 %.0397, 0
  br i1 %295, label %296, label %300

296:                                              ; preds = %293
  %297 = mul i32 %.1386, 100
  %298 = sdiv i32 %297, %.0397
  %299 = icmp slt i32 %298, 5
  br label %.cont

300:                                              ; preds = %293
  %.not = icmp eq i32 %.1386, 0
  br label %.cont

.cont:                                            ; preds = %300, %296
  %.reg2mem27.0.in = phi i1 [ %299, %296 ], [ %.not, %300 ]
  %301 = call ptr @bump_malloc(i64 noundef 16)
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %301, align 1
  store ptr @String, ptr %32, align 8
  %302 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %303 = call { i64, i64 } @size_wrapper(ptr %302, ptr noundef nonnull align 8 dereferenceable(8) %32)
  %304 = extractvalue { i64, i64 } %303, 0
  %305 = call ptr @bump_malloc(i64 %304)
  %306 = insertvalue { ptr } undef, ptr %301, 0
  %307 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %305, 1
  %308 = insertvalue { ptr, ptr, ptr, i32 } %307, ptr undef, 2
  %309 = insertvalue { ptr, ptr, ptr, i32 } %308, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %33, align 8
  %310 = getelementptr inbounds i8, ptr %33, i64 8
  store ptr @_parameterization_i32, ptr %310, align 8
  %311 = getelementptr inbounds i8, ptr %33, i64 16
  store ptr @_parameterization_i32, ptr %311, align 8
  %312 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %33)
  %313 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %314 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %34, align 8
  %315 = getelementptr inbounds i8, ptr %34, i64 8
  store ptr @i32_typ, ptr %315, align 8
  %316 = getelementptr inbounds i8, ptr %34, i64 16
  store ptr @i32_typ, ptr %316, align 8
  %317 = call ptr @behavior_wrapper(ptr %314, { ptr, ptr, ptr, i32 } %309, ptr noundef nonnull align 8 dereferenceable(24) %34)
  call void %317({ ptr, ptr, ptr, i32 } %309, { ptr, ptr, ptr, i32 } %309, ptr nonnull %33, { ptr } %306, i32 15, i32 16) #39
  %318 = sub i64 %294, %275
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %309, i32 %.0397, i64 %318)
  %319 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %319, align 1
  store ptr @String, ptr %35, align 8
  %320 = call { i64, i64 } @size_wrapper(ptr %302, ptr noundef nonnull align 8 dereferenceable(8) %35)
  %321 = extractvalue { i64, i64 } %320, 0
  %322 = call ptr @bump_malloc(i64 %321)
  %323 = insertvalue { ptr } undef, ptr %319, 0
  %324 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %322, 1
  %325 = insertvalue { ptr, ptr, ptr, i32 } %324, ptr undef, 2
  %326 = insertvalue { ptr, ptr, ptr, i32 } %325, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %36, align 8
  %327 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr @_parameterization_i32, ptr %327, align 8
  %328 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr @_parameterization_i32, ptr %328, align 8
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %36)
  %330 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %37, align 8
  %331 = getelementptr inbounds i8, ptr %37, i64 8
  store ptr @i32_typ, ptr %331, align 8
  %332 = getelementptr inbounds i8, ptr %37, i64 16
  store ptr @i32_typ, ptr %332, align 8
  %333 = call ptr @behavior_wrapper(ptr %314, { ptr, ptr, ptr, i32 } %326, ptr noundef nonnull align 8 dereferenceable(24) %37)
  call void %333({ ptr, ptr, ptr, i32 } %326, { ptr, ptr, ptr, i32 } %326, ptr nonnull %36, { ptr } %323, i32 18, i32 19) #39
  %334 = ptrtoint ptr %322 to i64
  %.sroa.3170.8.insert.ext = zext i64 %334 to i160
  %.sroa.3170.8.insert.insert = or disjoint i160 %.sroa.3170.8.insert.ext, 3402823669209384634633746074317682114560
  %335 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3170.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %38, align 8
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %38)
  %337 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %338 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %39, align 8
  %339 = call ptr @class_behavior_wrapper(ptr %338, ptr noundef nonnull align 8 dereferenceable(8) %39)
  call void %339(ptr nonnull %38, { ptr, i160 } %335) #39
  %340 = call ptr @bump_malloc(i64 noundef 5)
  %341 = insertvalue { ptr } undef, ptr %340, 0
  %. = select i1 %.reg2mem27.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.435 = select i1 %.reg2mem27.0.in, ptr %40, ptr %45
  %.436 = select i1 %.reg2mem27.0.in, ptr %41, ptr %46
  %.437 = select i1 %.reg2mem27.0.in, ptr %42, ptr %47
  %.438 = select i1 %.reg2mem27.0.in, ptr %43, ptr %48
  %.439 = select i1 %.reg2mem27.0.in, ptr %44, ptr %49
  store <4 x i8> %., ptr %340, align 1
  store ptr @String, ptr %.435, align 8
  %342 = call { i64, i64 } @size_wrapper(ptr %302, ptr noundef nonnull align 8 dereferenceable(8) %.435)
  %343 = extractvalue { i64, i64 } %342, 0
  %344 = call ptr @bump_malloc(i64 %343)
  %345 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %344, 1
  %346 = insertvalue { ptr, ptr, ptr, i32 } %345, ptr undef, 2
  %347 = insertvalue { ptr, ptr, ptr, i32 } %346, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %.436, align 8
  %.436.sroa.sel.v = select i1 %.reg2mem27.0.in, ptr %41, ptr %46
  %.436.sroa.sel = getelementptr inbounds i8, ptr %.436.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.436.sroa.sel, align 8
  %.436.sroa.sel448.v = select i1 %.reg2mem27.0.in, ptr %41, ptr %46
  %.436.sroa.sel448 = getelementptr inbounds i8, ptr %.436.sroa.sel448.v, i64 16
  store ptr @_parameterization_i32, ptr %.436.sroa.sel448, align 8
  %348 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.436)
  %349 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %.437, align 8
  %.437.sroa.sel.v = select i1 %.reg2mem27.0.in, ptr %42, ptr %47
  %.437.sroa.sel = getelementptr inbounds i8, ptr %.437.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.437.sroa.sel, align 8
  %.437.sroa.sel443.v = select i1 %.reg2mem27.0.in, ptr %42, ptr %47
  %.437.sroa.sel443 = getelementptr inbounds i8, ptr %.437.sroa.sel443.v, i64 16
  store ptr @i32_typ, ptr %.437.sroa.sel443, align 8
  %350 = call ptr @behavior_wrapper(ptr %314, { ptr, ptr, ptr, i32 } %347, ptr noundef nonnull align 8 dereferenceable(24) %.437)
  call void %350({ ptr, ptr, ptr, i32 } %347, { ptr, ptr, ptr, i32 } %347, ptr nonnull %.436, { ptr } %341, i32 4, i32 5) #39
  %351 = ptrtoint ptr %344 to i64
  %.sroa.3140.8.insert.ext = zext i64 %351 to i160
  %.sroa.3140.8.insert.insert = or disjoint i160 %.sroa.3140.8.insert.ext, 3402823669209384634633746074317682114560
  %352 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3140.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %.438, align 8
  %353 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.438)
  %354 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %.439, align 8
  %355 = call ptr @class_behavior_wrapper(ptr %338, ptr noundef nonnull align 8 dereferenceable(8) %.439)
  call void %355(ptr nonnull %.438, { ptr, i160 } %352) #39
  %356 = call ptr @bump_malloc(i64 noundef 14)
  store <13 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %356, align 1
  store ptr @String, ptr %50, align 8
  %357 = call { i64, i64 } @size_wrapper(ptr %302, ptr noundef nonnull align 8 dereferenceable(8) %50)
  %358 = extractvalue { i64, i64 } %357, 0
  %359 = call ptr @bump_malloc(i64 %358)
  %360 = insertvalue { ptr } undef, ptr %356, 0
  %361 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %359, 1
  %362 = insertvalue { ptr, ptr, ptr, i32 } %361, ptr undef, 2
  %363 = insertvalue { ptr, ptr, ptr, i32 } %362, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %51, align 8
  %364 = getelementptr inbounds i8, ptr %51, i64 8
  store ptr @_parameterization_i32, ptr %364, align 8
  %365 = getelementptr inbounds i8, ptr %51, i64 16
  store ptr @_parameterization_i32, ptr %365, align 8
  %366 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %51)
  %367 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %52, align 8
  %368 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr @i32_typ, ptr %368, align 8
  %369 = getelementptr inbounds i8, ptr %52, i64 16
  store ptr @i32_typ, ptr %369, align 8
  %370 = call ptr @behavior_wrapper(ptr %314, { ptr, ptr, ptr, i32 } %363, ptr noundef nonnull align 8 dereferenceable(24) %52)
  call void %370({ ptr, ptr, ptr, i32 } %363, { ptr, ptr, ptr, i32 } %363, ptr nonnull %51, { ptr } %360, i32 13, i32 14) #39
  %371 = ptrtoint ptr %359 to i64
  %.sroa.3125.8.insert.ext = zext i64 %371 to i160
  %.sroa.3125.8.insert.insert = or disjoint i160 %.sroa.3125.8.insert.ext, 3402823669209384634633746074317682114560
  %372 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3125.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %53, align 8
  %373 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  %374 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %54, align 8
  %375 = call ptr @class_behavior_wrapper(ptr %338, ptr noundef nonnull align 8 dereferenceable(8) %54)
  call void %375(ptr nonnull %53, { ptr, i160 } %372) #39
  %.sroa.0115.0.insert.ext = zext i32 %.1383 to i160
  %376 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0115.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %55, align 8
  %377 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %55)
  %378 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %56, align 8
  %379 = call ptr @class_behavior_wrapper(ptr %338, ptr noundef nonnull align 8 dereferenceable(8) %56)
  call void %379(ptr nonnull %55, { ptr, i160 } %376) #39
  %380 = call ptr @bump_malloc(i64 noundef 9)
  store <8 x i8> <i8 44, i8 32, i8 72, i8 105, i8 116, i8 115, i8 58, i8 32>, ptr %380, align 1
  store ptr @String, ptr %57, align 8
  %381 = call { i64, i64 } @size_wrapper(ptr %302, ptr noundef nonnull align 8 dereferenceable(8) %57)
  %382 = extractvalue { i64, i64 } %381, 0
  %383 = call ptr @bump_malloc(i64 %382)
  %384 = insertvalue { ptr } undef, ptr %380, 0
  %385 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %383, 1
  %386 = insertvalue { ptr, ptr, ptr, i32 } %385, ptr undef, 2
  %387 = insertvalue { ptr, ptr, ptr, i32 } %386, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %58, align 8
  %388 = getelementptr inbounds i8, ptr %58, i64 8
  store ptr @_parameterization_i32, ptr %388, align 8
  %389 = getelementptr inbounds i8, ptr %58, i64 16
  store ptr @_parameterization_i32, ptr %389, align 8
  %390 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %58)
  %391 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %59, align 8
  %392 = getelementptr inbounds i8, ptr %59, i64 8
  store ptr @i32_typ, ptr %392, align 8
  %393 = getelementptr inbounds i8, ptr %59, i64 16
  store ptr @i32_typ, ptr %393, align 8
  %394 = call ptr @behavior_wrapper(ptr %314, { ptr, ptr, ptr, i32 } %387, ptr noundef nonnull align 8 dereferenceable(24) %59)
  call void %394({ ptr, ptr, ptr, i32 } %387, { ptr, ptr, ptr, i32 } %387, ptr nonnull %58, { ptr } %384, i32 8, i32 9) #39
  %395 = ptrtoint ptr %383 to i64
  %.sroa.3103.8.insert.ext = zext i64 %395 to i160
  %.sroa.3103.8.insert.insert = or disjoint i160 %.sroa.3103.8.insert.ext, 3402823669209384634633746074317682114560
  %396 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3103.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %60, align 8
  %397 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %60)
  %398 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %61, align 8
  %399 = call ptr @class_behavior_wrapper(ptr %338, ptr noundef nonnull align 8 dereferenceable(8) %61)
  call void %399(ptr nonnull %60, { ptr, i160 } %396) #39
  %.sroa.098.0.insert.ext = zext i32 %.1386 to i160
  %400 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.098.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %62, align 8
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %62)
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %63, align 8
  %403 = call ptr @class_behavior_wrapper(ptr %338, ptr noundef nonnull align 8 dereferenceable(8) %63)
  call void %403(ptr nonnull %62, { ptr, i160 } %400) #39
  %404 = call ptr @bump_malloc(i64 noundef 2)
  store <1 x i8> <i8 41>, ptr %404, align 1
  store ptr @String, ptr %64, align 8
  %405 = call { i64, i64 } @size_wrapper(ptr %302, ptr noundef nonnull align 8 dereferenceable(8) %64)
  %406 = extractvalue { i64, i64 } %405, 0
  %407 = call ptr @bump_malloc(i64 %406)
  %408 = insertvalue { ptr } undef, ptr %404, 0
  %409 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %407, 1
  %410 = insertvalue { ptr, ptr, ptr, i32 } %409, ptr undef, 2
  %411 = insertvalue { ptr, ptr, ptr, i32 } %410, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %65, align 8
  %412 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr @_parameterization_i32, ptr %412, align 8
  %413 = getelementptr inbounds i8, ptr %65, i64 16
  store ptr @_parameterization_i32, ptr %413, align 8
  %414 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %65)
  %415 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %66, align 8
  %416 = getelementptr inbounds i8, ptr %66, i64 8
  store ptr @i32_typ, ptr %416, align 8
  %417 = getelementptr inbounds i8, ptr %66, i64 16
  store ptr @i32_typ, ptr %417, align 8
  %418 = call ptr @behavior_wrapper(ptr %314, { ptr, ptr, ptr, i32 } %411, ptr noundef nonnull align 8 dereferenceable(24) %66)
  call void %418({ ptr, ptr, ptr, i32 } %411, { ptr, ptr, ptr, i32 } %411, ptr nonnull %65, { ptr } %408, i32 1, i32 2) #39
  %419 = ptrtoint ptr %407 to i64
  %.sroa.3.8.insert.ext = zext i64 %419 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %420 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %67, align 8
  %421 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %67)
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %68, align 8
  %423 = call ptr @class_behavior_wrapper(ptr %338, ptr noundef nonnull align 8 dereferenceable(8) %68)
  call void %423(ptr nonnull %67, { ptr, i160 } %420) #39
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %.sroa.0335.sroa.0 = alloca i8, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca [3 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca { ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca [3 x ptr], align 8
  %20 = alloca { ptr, ptr, ptr }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [1 x ptr], align 8
  %24 = alloca { ptr }, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca [3 x ptr], align 8
  %29 = alloca { ptr, ptr, ptr }, align 8
  %30 = alloca [1 x ptr], align 8
  %31 = alloca { ptr }, align 8
  %32 = alloca [1 x ptr], align 8
  %33 = alloca { ptr }, align 8
  %34 = alloca [1 x ptr], align 8
  %35 = alloca [3 x ptr], align 8
  %36 = alloca { ptr, ptr, ptr }, align 8
  %37 = alloca [1 x ptr], align 8
  %38 = alloca { ptr }, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [1 x ptr], align 8
  %42 = alloca { ptr }, align 8
  %43 = alloca [1 x ptr], align 8
  %44 = alloca { ptr }, align 8
  %45 = alloca [1 x ptr], align 8
  %46 = alloca [3 x ptr], align 8
  %47 = alloca { ptr, ptr, ptr }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca [3 x ptr], align 8
  %50 = alloca { ptr, ptr, ptr }, align 8
  %51 = alloca [1 x ptr], align 8
  %52 = alloca { ptr }, align 8
  %53 = alloca [1 x ptr], align 8
  %54 = alloca [3 x ptr], align 8
  %55 = alloca { ptr, ptr, ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca [1 x ptr], align 8
  %59 = alloca [3 x ptr], align 8
  %60 = alloca { ptr, ptr, ptr }, align 8
  %61 = alloca [1 x ptr], align 8
  %62 = alloca { ptr }, align 8
  %63 = alloca [1 x ptr], align 8
  %64 = alloca [3 x ptr], align 8
  %65 = alloca { ptr, ptr, ptr }, align 8
  %66 = alloca [1 x ptr], align 8
  %67 = alloca { ptr }, align 8
  %68 = alloca [1 x ptr], align 8
  %69 = alloca { ptr }, align 8
  %70 = alloca [1 x ptr], align 8
  %71 = alloca [3 x ptr], align 8
  %72 = alloca { ptr, ptr, ptr }, align 8
  %73 = alloca [1 x ptr], align 8
  %74 = alloca { ptr }, align 8
  %75 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %75, i64 8
  store ptr @_parameterization_i32, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %75, i64 16
  store ptr @_parameterization_i32, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %75, i64 24
  store ptr @_parameterization_Pairi32._i32, ptr %78, align 8
  %79 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 48), align 8
  %80 = call { i64, i64 } @size_wrapper(ptr %79, ptr noundef nonnull align 8 dereferenceable(32) %75)
  %81 = extractvalue { i64, i64 } %80, 0
  %82 = call ptr @bump_malloc(i64 %81)
  store ptr @_parameterization_i32, ptr %82, align 8
  %83 = getelementptr i8, ptr %82, i64 8
  store ptr @_parameterization_i32, ptr %83, align 8
  %84 = getelementptr i8, ptr %82, i64 16
  store ptr @_parameterization_Pairi32._i32, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  %86 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %86)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %86, ptr noalias nofree noundef nonnull readnone @nivqqmixpq, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %87 = call ptr @adjust_trampoline(ptr %86)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %86)
  %89 = insertvalue { ptr } undef, ptr %87, 0
  %90 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %90)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %90, ptr noalias nofree noundef nonnull readnone @ytebrvjgff, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %91 = call ptr @adjust_trampoline(ptr %90)
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %90)
  %93 = insertvalue { ptr } undef, ptr %91, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %82, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr undef, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 10, 3
  %97 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %97, align 8
  %98 = getelementptr inbounds i8, ptr %97, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %97)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %101 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 160), align 8
  %102 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %102, i64 8
  store ptr @function_typ, ptr %103, align 8
  %104 = call ptr @behavior_wrapper(ptr %101, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 dereferenceable(16) %102)
  call void %104({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %97, { ptr } %89, { ptr } %93) #39
  %105 = alloca [1 x ptr], align 8
  store ptr @PRNG, ptr %105, align 8
  %106 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_PRNG, ptr noundef nonnull align 8 dereferenceable(8) %105)
  %107 = extractvalue { i64, i64 } %106, 0
  %108 = call ptr @bump_malloc(i64 %107)
  %109 = insertvalue { ptr, ptr, ptr, i32 } { ptr @PRNG, ptr undef, ptr undef, i32 undef }, ptr %108, 1
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr undef, 2
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, i32 10, 3
  %112 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %112, align 8
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %112)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %115 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %115, align 8
  %116 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_init_initial_seedi32, { ptr, ptr, ptr, i32 } %111, ptr noundef nonnull align 8 dereferenceable(8) %115)
  call void %116({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull %112, i32 101112) #39
  %117 = alloca [2 x ptr], align 8
  store ptr @Array, ptr %117, align 8
  %118 = getelementptr inbounds i8, ptr %117, i64 8
  store ptr @_parameterization_i32, ptr %118, align 8
  %119 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 48), align 8
  %120 = call { i64, i64 } @size_wrapper(ptr %119, ptr noundef nonnull align 8 dereferenceable(16) %117)
  %121 = extractvalue { i64, i64 } %120, 0
  %122 = call ptr @bump_malloc(i64 %121)
  store ptr @_parameterization_i32, ptr %122, align 8
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %122)
  %124 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %122, 1
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, ptr undef, 2
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, i32 10, 3
  %127 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %127, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %127)
  %129 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  %130 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 128), align 8
  %131 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %131, align 8
  %132 = call ptr @behavior_wrapper(ptr %130, { ptr, ptr, ptr, i32 } %126, ptr noundef nonnull align 8 dereferenceable(8) %131)
  call void %132({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull %127, i32 %0) #39
  %133 = alloca [4 x ptr], align 8
  store ptr @CuckooMap, ptr %133, align 8
  %134 = getelementptr inbounds i8, ptr %133, i64 8
  store ptr @_parameterization_i32, ptr %134, align 8
  %135 = getelementptr inbounds i8, ptr %133, i64 16
  store ptr @_parameterization_Bool, ptr %135, align 8
  %136 = getelementptr inbounds i8, ptr %133, i64 24
  store ptr @_parameterization_Pairi32._Bool, ptr %136, align 8
  %137 = call { i64, i64 } @size_wrapper(ptr %79, ptr noundef nonnull align 8 dereferenceable(32) %133)
  %138 = extractvalue { i64, i64 } %137, 0
  %139 = call ptr @bump_malloc(i64 %138)
  store ptr @_parameterization_i32, ptr %139, align 8
  %140 = getelementptr i8, ptr %139, i64 8
  store ptr @_parameterization_Bool, ptr %140, align 8
  %141 = getelementptr i8, ptr %139, i64 16
  store ptr @_parameterization_Pairi32._Bool, ptr %141, align 8
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %139)
  %143 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %143)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %143, ptr noalias nofree noundef nonnull readnone @axlhmwbuwo, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %144 = call ptr @adjust_trampoline(ptr %143)
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %143)
  %146 = insertvalue { ptr } undef, ptr %144, 0
  %147 = call ptr @bump_malloc(i64 noundef 24)
  call void @anoint_trampoline(ptr %147)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %147, ptr noalias nofree noundef nonnull readnone @sxmbvaaqjx, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %148 = call ptr @adjust_trampoline(ptr %147)
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %147)
  %150 = insertvalue { ptr } undef, ptr %148, 0
  %151 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %139, 1
  %152 = insertvalue { ptr, ptr, ptr, i32 } %151, ptr undef, 2
  %153 = insertvalue { ptr, ptr, ptr, i32 } %152, i32 10, 3
  %154 = alloca [2 x ptr], align 8
  store ptr @_parameterization_Functioni32_to_i32, ptr %154, align 8
  %155 = getelementptr inbounds i8, ptr %154, i64 8
  store ptr @_parameterization_Functioni32._i32_to_Bool, ptr %155, align 8
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %154)
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %158 = alloca { ptr, ptr }, align 8
  store ptr @function_typ, ptr %158, align 8
  %159 = getelementptr inbounds i8, ptr %158, i64 8
  store ptr @function_typ, ptr %159, align 8
  %160 = call ptr @behavior_wrapper(ptr %101, { ptr, ptr, ptr, i32 } %153, ptr noundef nonnull align 8 dereferenceable(16) %158)
  call void %160({ ptr, ptr, ptr, i32 } %153, { ptr, ptr, ptr, i32 } %153, ptr nonnull %154, { ptr } %146, { ptr } %150) #39
  %161 = mul i32 %0, 10
  %162 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  %163 = getelementptr inbounds i8, ptr %5, i64 8
  %164 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 248), align 8
  %165 = getelementptr inbounds i8, ptr %6, i64 8
  %166 = getelementptr inbounds i8, ptr %7, i64 8
  %167 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 216), align 8
  %168 = getelementptr inbounds i8, ptr %8, i64 8
  %169 = getelementptr inbounds i8, ptr %9, i64 8
  %170 = getelementptr inbounds i8, ptr %10, i64 8
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge1, %1
  %.0376 = phi i32 [ 0, %1 ], [ %.2378, %._crit_edge1 ]
  %.0374 = phi i32 [ 0, %1 ], [ %.1375, %._crit_edge1 ]
  %171 = icmp slt i32 %.0376, %0
  %172 = icmp slt i32 %.0374, %161
  %spec.select = select i1 %171, i1 %172, i1 false
  br i1 %spec.select, label %173, label %._crit_edge1

173:                                              ; preds = %._crit_edge3
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %175 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @PRNG)
  %176 = call ptr @behavior_wrapper(ptr noundef nonnull @PRNG_B_next_, { ptr, ptr, ptr, i32 } %111, ptr noundef nonnull align 8 %2)
  %177 = call i32 %176({ ptr, ptr, ptr, i32 } %111, { ptr, ptr, ptr, i32 } %111, ptr nonnull %2) #39
  %.sroa.0362.0.insert.ext = zext i32 %177 to i160
  %178 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0362.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %3, align 8
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %3)
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %4, align 8
  %181 = call ptr @behavior_wrapper(ptr %162, { ptr, ptr, ptr, i32 } %153, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %182 = call { ptr, i160 } %181({ ptr, ptr, ptr, i32 } %153, { ptr, ptr, ptr, i32 } %153, ptr nonnull %3, { ptr, i160 } %178) #39
  %.fca.0.extract354 = extractvalue { ptr, i160 } %182, 0
  %183 = icmp eq ptr %.fca.0.extract354, @nil_typ
  %184 = icmp eq ptr %.fca.0.extract354, null
  %185 = or i1 %183, %184
  br i1 %185, label %186, label %._crit_edge2

186:                                              ; preds = %173
  %187 = add i32 %177, 1
  %.sroa.0345.0.insert.ext = zext i32 %187 to i160
  %188 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0345.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %5, align 8
  store ptr @_parameterization_i32, ptr %163, align 8
  %189 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %190 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %6, align 8
  store ptr @i32_typ, ptr %165, align 8
  %191 = call ptr @behavior_wrapper(ptr %164, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %191({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %5, { ptr, i160 } %178, { ptr, i160 } %188) #39
  store ptr @_parameterization_i32, ptr %7, align 8
  store ptr @_parameterization_i32, ptr %166, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  store ptr @i32_typ, ptr %8, align 8
  store ptr @i32_typ, ptr %168, align 8
  %194 = call ptr @behavior_wrapper(ptr %167, { ptr, ptr, ptr, i32 } %126, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %194({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull %7, i32 %.0376, { ptr, i160 } %178) #39
  store i1 true, ptr %.sroa.0335.sroa.0, align 8
  %.sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.0. = load i8, ptr %.sroa.0335.sroa.0, align 8
  %.sroa.0335.0.insert.ext = zext i8 %.sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.sroa.0.0..sroa.0335.0. to i160
  %195 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0335.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %9, align 8
  store ptr @_parameterization_Bool, ptr %169, align 8
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %9)
  %197 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %10, align 8
  store ptr @bool_typ, ptr %170, align 8
  %198 = call ptr @behavior_wrapper(ptr %164, { ptr, ptr, ptr, i32 } %153, ptr noundef nonnull align 8 dereferenceable(16) %10)
  call void %198({ ptr, ptr, ptr, i32 } %153, { ptr, ptr, ptr, i32 } %153, ptr nonnull %9, { ptr, i160 } %178, { ptr, i160 } %195) #39
  %199 = add nsw i32 %.0376, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %186, %173
  %.1377 = phi i32 [ %199, %186 ], [ %.0376, %173 ]
  %200 = add i32 %.0374, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge2, %._crit_edge3
  %.2378 = phi i32 [ %.1377, %._crit_edge2 ], [ %.0376, %._crit_edge3 ]
  %.1375 = phi i32 [ %200, %._crit_edge2 ], [ %.0374, %._crit_edge3 ]
  br i1 %spec.select, label %._crit_edge3, label %201

201:                                              ; preds = %._crit_edge1
  %202 = icmp slt i32 %.2378, %0
  br i1 %202, label %203, label %._crit_edge4

203:                                              ; preds = %201
  %204 = call ptr @bump_malloc(i64 noundef 30)
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %204, align 1
  store ptr @String, ptr %11, align 8
  %205 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %206 = call { i64, i64 } @size_wrapper(ptr %205, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %207 = extractvalue { i64, i64 } %206, 0
  %208 = call ptr @bump_malloc(i64 %207)
  %209 = insertvalue { ptr } undef, ptr %204, 0
  %210 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %208, 1
  %211 = insertvalue { ptr, ptr, ptr, i32 } %210, ptr undef, 2
  %212 = insertvalue { ptr, ptr, ptr, i32 } %211, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %12, align 8
  %213 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @_parameterization_i32, ptr %213, align 8
  %214 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %214, align 8
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %12)
  %216 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %217 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %13, align 8
  %218 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr @i32_typ, ptr %218, align 8
  %219 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %219, align 8
  %220 = call ptr @behavior_wrapper(ptr %217, { ptr, ptr, ptr, i32 } %212, ptr noundef nonnull align 8 dereferenceable(24) %13)
  call void %220({ ptr, ptr, ptr, i32 } %212, { ptr, ptr, ptr, i32 } %212, ptr nonnull %12, { ptr } %209, i32 29, i32 30) #39
  %221 = ptrtoint ptr %208 to i64
  %.sroa.3318.8.insert.ext = zext i64 %221 to i160
  %.sroa.3318.8.insert.insert = or disjoint i160 %.sroa.3318.8.insert.ext, 3402823669209384634633746074317682114560
  %222 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3318.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %14, align 8
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %225 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %15, align 8
  %226 = call ptr @class_behavior_wrapper(ptr %225, ptr noundef nonnull align 8 dereferenceable(8) %15)
  call void %226(ptr nonnull %14, { ptr, i160 } %222) #39
  %.sroa.0312.0.insert.ext = zext i32 %.2378 to i160
  %227 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0312.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %16, align 8
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %16)
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %17, align 8
  %230 = call ptr @class_behavior_wrapper(ptr %225, ptr noundef nonnull align 8 dereferenceable(8) %17)
  call void %230(ptr nonnull %16, { ptr, i160 } %227) #39
  %231 = call ptr @bump_malloc(i64 noundef 30)
  store <29 x i8> <i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %231, align 1
  store ptr @String, ptr %18, align 8
  %232 = call { i64, i64 } @size_wrapper(ptr %205, ptr noundef nonnull align 8 dereferenceable(8) %18)
  %233 = extractvalue { i64, i64 } %232, 0
  %234 = call ptr @bump_malloc(i64 %233)
  %235 = insertvalue { ptr } undef, ptr %231, 0
  %236 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %234, 1
  %237 = insertvalue { ptr, ptr, ptr, i32 } %236, ptr undef, 2
  %238 = insertvalue { ptr, ptr, ptr, i32 } %237, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %19, align 8
  %239 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr @_parameterization_i32, ptr %239, align 8
  %240 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr @_parameterization_i32, ptr %240, align 8
  %241 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %19)
  %242 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %20, align 8
  %243 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @i32_typ, ptr %243, align 8
  %244 = getelementptr inbounds i8, ptr %20, i64 16
  store ptr @i32_typ, ptr %244, align 8
  %245 = call ptr @behavior_wrapper(ptr %217, { ptr, ptr, ptr, i32 } %238, ptr noundef nonnull align 8 dereferenceable(24) %20)
  call void %245({ ptr, ptr, ptr, i32 } %238, { ptr, ptr, ptr, i32 } %238, ptr nonnull %19, { ptr } %235, i32 29, i32 30) #39
  %246 = ptrtoint ptr %234 to i64
  %.sroa.3300.8.insert.ext = zext i64 %246 to i160
  %.sroa.3300.8.insert.insert = or disjoint i160 %.sroa.3300.8.insert.ext, 3402823669209384634633746074317682114560
  %247 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3300.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %21, align 8
  %248 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %249 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %22, align 8
  %250 = call ptr @class_behavior_wrapper(ptr %225, ptr noundef nonnull align 8 dereferenceable(8) %22)
  call void %250(ptr nonnull %21, { ptr, i160 } %247) #39
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %203, %201
  %.0384 = phi i32 [ %.2378, %203 ], [ %0, %201 ]
  %251 = call i64 @clock()
  %252 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 208), align 8
  %253 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 280), align 8
  %254 = load <37 x i8>, ptr @wovqv_Warning_Remove_returned_Nil_for_key_, align 64
  %255 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %256 = getelementptr inbounds i8, ptr %35, i64 8
  %257 = getelementptr inbounds i8, ptr %35, i64 16
  %258 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  %259 = getelementptr inbounds i8, ptr %36, i64 8
  %260 = getelementptr inbounds i8, ptr %36, i64 16
  %261 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  %262 = load <45 x i8>, ptr @hnbwj_Warning_Remove_returned_wrong_value_for_key_, align 64
  %263 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %264 = getelementptr inbounds i8, ptr %28, i64 8
  %265 = getelementptr inbounds i8, ptr %28, i64 16
  %266 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  %267 = getelementptr inbounds i8, ptr %29, i64 8
  %268 = getelementptr inbounds i8, ptr %29, i64 16
  %269 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge5, %._crit_edge4
  %.0382 = phi i32 [ 0, %._crit_edge4 ], [ %.1383, %._crit_edge5 ]
  %.0379 = phi i1 [ true, %._crit_edge4 ], [ %.3, %._crit_edge5 ]
  %.0373 = phi i32 [ 0, %._crit_edge4 ], [ %.2, %._crit_edge5 ]
  %270 = icmp slt i32 %.0382, %.0384
  br i1 %270, label %271, label %._crit_edge5

271:                                              ; preds = %._crit_edge7
  store ptr @_parameterization_i32, ptr %23, align 8
  %272 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %23)
  %273 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  store ptr @i32_typ, ptr %24, align 8
  %274 = call ptr @behavior_wrapper(ptr %252, { ptr, ptr, ptr, i32 } %126, ptr noundef nonnull align 8 dereferenceable(8) %24)
  %275 = call { ptr, i160 } %274({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull %23, i32 %.0382) #39
  %.fca.1.extract283 = extractvalue { ptr, i160 } %275, 1
  %.sroa.0276.0.insert.ext = and i160 %.fca.1.extract283, 4294967295
  %276 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0276.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %25, align 8
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %278 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  store ptr @i32_typ, ptr %26, align 8
  %279 = call ptr @behavior_wrapper(ptr %253, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 dereferenceable(8) %26)
  %280 = call { ptr, i160 } %279({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %25, { ptr, i160 } %276) #39
  %.fca.0.extract268 = extractvalue { ptr, i160 } %280, 0
  %281 = icmp ne ptr %.fca.0.extract268, @nil_typ
  %282 = icmp ne ptr %.fca.0.extract268, null
  %.not388 = and i1 %281, %282
  br i1 %.not388, label %283, label %306

283:                                              ; preds = %271
  %.fca.1.extract269 = extractvalue { ptr, i160 } %280, 1
  %.sroa.2271.8.extract.trunc = trunc i160 %.fca.1.extract269 to i32
  %.sroa.1285.8.extract.trunc = trunc i160 %.fca.1.extract283 to i32
  %284 = add i32 %.sroa.1285.8.extract.trunc, 1
  %.not = icmp eq i32 %284, %.sroa.2271.8.extract.trunc
  br i1 %.not, label %._crit_edge6, label %285

285:                                              ; preds = %283
  %286 = call ptr @bump_malloc(i64 noundef 46)
  store <45 x i8> %262, ptr %286, align 1
  store ptr @String, ptr %27, align 8
  %287 = call { i64, i64 } @size_wrapper(ptr %263, ptr noundef nonnull align 8 dereferenceable(8) %27)
  %288 = extractvalue { i64, i64 } %287, 0
  %289 = call ptr @bump_malloc(i64 %288)
  %290 = insertvalue { ptr } undef, ptr %286, 0
  %291 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %289, 1
  %292 = insertvalue { ptr, ptr, ptr, i32 } %291, ptr undef, 2
  %293 = insertvalue { ptr, ptr, ptr, i32 } %292, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %28, align 8
  store ptr @_parameterization_i32, ptr %264, align 8
  store ptr @_parameterization_i32, ptr %265, align 8
  %294 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %28)
  %295 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %29, align 8
  store ptr @i32_typ, ptr %267, align 8
  store ptr @i32_typ, ptr %268, align 8
  %296 = call ptr @behavior_wrapper(ptr %266, { ptr, ptr, ptr, i32 } %293, ptr noundef nonnull align 8 dereferenceable(24) %29)
  call void %296({ ptr, ptr, ptr, i32 } %293, { ptr, ptr, ptr, i32 } %293, ptr nonnull %28, { ptr } %290, i32 45, i32 46) #39
  %297 = ptrtoint ptr %289 to i64
  %.sroa.3246.8.insert.ext = zext i64 %297 to i160
  %.sroa.3246.8.insert.insert = or disjoint i160 %.sroa.3246.8.insert.ext, 3402823669209384634633746074317682114560
  %298 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3246.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %30, align 8
  %299 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %300 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %31, align 8
  %301 = call ptr @class_behavior_wrapper(ptr %269, ptr noundef nonnull align 8 dereferenceable(8) %31)
  call void %301(ptr nonnull %30, { ptr, i160 } %298) #39
  store ptr @_parameterization_i32, ptr %32, align 8
  %302 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %32)
  %303 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %33, align 8
  %304 = call ptr @class_behavior_wrapper(ptr %269, ptr noundef nonnull align 8 dereferenceable(8) %33)
  call void %304(ptr nonnull %32, { ptr, i160 } %276) #39
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %285, %283
  %.1380 = phi i1 [ false, %285 ], [ %.0379, %283 ]
  %305 = add i32 %.0373, 1
  br label %326

306:                                              ; preds = %271
  %307 = call ptr @bump_malloc(i64 noundef 38)
  store <37 x i8> %254, ptr %307, align 1
  store ptr @String, ptr %34, align 8
  %308 = call { i64, i64 } @size_wrapper(ptr %255, ptr noundef nonnull align 8 dereferenceable(8) %34)
  %309 = extractvalue { i64, i64 } %308, 0
  %310 = call ptr @bump_malloc(i64 %309)
  %311 = insertvalue { ptr } undef, ptr %307, 0
  %312 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %310, 1
  %313 = insertvalue { ptr, ptr, ptr, i32 } %312, ptr undef, 2
  %314 = insertvalue { ptr, ptr, ptr, i32 } %313, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %35, align 8
  store ptr @_parameterization_i32, ptr %256, align 8
  store ptr @_parameterization_i32, ptr %257, align 8
  %315 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %35)
  %316 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %36, align 8
  store ptr @i32_typ, ptr %259, align 8
  store ptr @i32_typ, ptr %260, align 8
  %317 = call ptr @behavior_wrapper(ptr %258, { ptr, ptr, ptr, i32 } %314, ptr noundef nonnull align 8 dereferenceable(24) %36)
  call void %317({ ptr, ptr, ptr, i32 } %314, { ptr, ptr, ptr, i32 } %314, ptr nonnull %35, { ptr } %311, i32 37, i32 38) #39
  %318 = ptrtoint ptr %310 to i64
  %.sroa.3223.8.insert.ext = zext i64 %318 to i160
  %.sroa.3223.8.insert.insert = or disjoint i160 %.sroa.3223.8.insert.ext, 3402823669209384634633746074317682114560
  %319 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3223.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %37, align 8
  %320 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %37)
  %321 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %38, align 8
  %322 = call ptr @class_behavior_wrapper(ptr %261, ptr noundef nonnull align 8 dereferenceable(8) %38)
  call void %322(ptr nonnull %37, { ptr, i160 } %319) #39
  store ptr @_parameterization_i32, ptr %39, align 8
  %323 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %39)
  %324 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %40, align 8
  %325 = call ptr @class_behavior_wrapper(ptr %261, ptr noundef nonnull align 8 dereferenceable(8) %40)
  call void %325(ptr nonnull %39, { ptr, i160 } %276) #39
  br label %326

326:                                              ; preds = %306, %._crit_edge6
  %.2381 = phi i1 [ %.1380, %._crit_edge6 ], [ false, %306 ]
  %.1 = phi i32 [ %305, %._crit_edge6 ], [ %.0373, %306 ]
  %327 = add i32 %.0382, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %326, %._crit_edge7
  %.1383 = phi i32 [ %327, %326 ], [ %.0382, %._crit_edge7 ]
  %.3 = phi i1 [ %.2381, %326 ], [ %.0379, %._crit_edge7 ]
  %.2 = phi i32 [ %.1, %326 ], [ %.0373, %._crit_edge7 ]
  br i1 %270, label %._crit_edge7, label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge5
  %328 = call i64 @clock()
  %.not389 = icmp eq i32 %.2, %.0384
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %330 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %331 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 256), align 8
  %332 = call ptr @behavior_wrapper(ptr %331, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 %2)
  %333 = call i32 %332({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %2) #39
  %.not390 = icmp eq i32 %333, 0
  %334 = select i1 %.not390, i1 %.not389, i1 false
  %spec.select396 = select i1 %334, i1 %.3, i1 false
  %335 = icmp sgt i32 %.0384, 0
  br i1 %335, label %336, label %._crit_edge10

336:                                              ; preds = %._crit_edge8
  store ptr @_parameterization_i32, ptr %41, align 8
  %337 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %41)
  %338 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @Array)
  %339 = load ptr, ptr getelementptr inbounds (i8, ptr @Array, i64 208), align 8
  store ptr @i32_typ, ptr %42, align 8
  %340 = call ptr @behavior_wrapper(ptr %339, { ptr, ptr, ptr, i32 } %126, ptr noundef nonnull align 8 dereferenceable(8) %42)
  %341 = call { ptr, i160 } %340({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr nonnull %41, i32 0) #39
  %.fca.1.extract201 = extractvalue { ptr, i160 } %341, 1
  %.sroa.0197.0.insert.ext = and i160 %.fca.1.extract201, 4294967295
  %342 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0197.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %43, align 8
  %343 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %43)
  %344 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 8 dereferenceable(2360) @CuckooMap)
  %345 = load ptr, ptr getelementptr inbounds (i8, ptr @CuckooMap, i64 264), align 8
  store ptr @i32_typ, ptr %44, align 8
  %346 = call ptr @behavior_wrapper(ptr %345, { ptr, ptr, ptr, i32 } %96, ptr noundef nonnull align 8 dereferenceable(8) %44)
  %347 = call { ptr, i160 } %346({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull %43, { ptr, i160 } %342) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %347, 0
  %348 = icmp eq ptr %.fca.0.extract, @nil_typ
  %349 = icmp eq ptr %.fca.0.extract, null
  %.not393.not = or i1 %348, %349
  %spec.select395 = select i1 %.not393.not, i1 %spec.select396, i1 false
  br label %._crit_edge10

._crit_edge10:                                    ; preds = %336, %._crit_edge8
  %.6 = phi i1 [ %spec.select396, %._crit_edge8 ], [ %spec.select395, %336 ]
  %350 = call ptr @bump_malloc(i64 noundef 14)
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %350, align 1
  store ptr @String, ptr %45, align 8
  %351 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %352 = call { i64, i64 } @size_wrapper(ptr %351, ptr noundef nonnull align 8 dereferenceable(8) %45)
  %353 = extractvalue { i64, i64 } %352, 0
  %354 = call ptr @bump_malloc(i64 %353)
  %355 = insertvalue { ptr } undef, ptr %350, 0
  %356 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %354, 1
  %357 = insertvalue { ptr, ptr, ptr, i32 } %356, ptr undef, 2
  %358 = insertvalue { ptr, ptr, ptr, i32 } %357, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %46, align 8
  %359 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @_parameterization_i32, ptr %359, align 8
  %360 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @_parameterization_i32, ptr %360, align 8
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %46)
  %362 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %363 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %47, align 8
  %364 = getelementptr inbounds i8, ptr %47, i64 8
  store ptr @i32_typ, ptr %364, align 8
  %365 = getelementptr inbounds i8, ptr %47, i64 16
  store ptr @i32_typ, ptr %365, align 8
  %366 = call ptr @behavior_wrapper(ptr %363, { ptr, ptr, ptr, i32 } %358, ptr noundef nonnull align 8 dereferenceable(24) %47)
  call void %366({ ptr, ptr, ptr, i32 } %358, { ptr, ptr, ptr, i32 } %358, ptr nonnull %46, { ptr } %355, i32 13, i32 14) #39
  %367 = sub i64 %328, %251
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %358, i32 %.0384, i64 %367)
  %368 = call ptr @bump_malloc(i64 noundef 19)
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %368, align 1
  store ptr @String, ptr %48, align 8
  %369 = call { i64, i64 } @size_wrapper(ptr %351, ptr noundef nonnull align 8 dereferenceable(8) %48)
  %370 = extractvalue { i64, i64 } %369, 0
  %371 = call ptr @bump_malloc(i64 %370)
  %372 = insertvalue { ptr } undef, ptr %368, 0
  %373 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %371, 1
  %374 = insertvalue { ptr, ptr, ptr, i32 } %373, ptr undef, 2
  %375 = insertvalue { ptr, ptr, ptr, i32 } %374, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %49, align 8
  %376 = getelementptr inbounds i8, ptr %49, i64 8
  store ptr @_parameterization_i32, ptr %376, align 8
  %377 = getelementptr inbounds i8, ptr %49, i64 16
  store ptr @_parameterization_i32, ptr %377, align 8
  %378 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %49)
  %379 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %50, align 8
  %380 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr @i32_typ, ptr %380, align 8
  %381 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr @i32_typ, ptr %381, align 8
  %382 = call ptr @behavior_wrapper(ptr %363, { ptr, ptr, ptr, i32 } %375, ptr noundef nonnull align 8 dereferenceable(24) %50)
  call void %382({ ptr, ptr, ptr, i32 } %375, { ptr, ptr, ptr, i32 } %375, ptr nonnull %49, { ptr } %372, i32 18, i32 19) #39
  %383 = ptrtoint ptr %371 to i64
  %.sroa.3159.8.insert.ext = zext i64 %383 to i160
  %.sroa.3159.8.insert.insert = or disjoint i160 %.sroa.3159.8.insert.ext, 3402823669209384634633746074317682114560
  %384 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3159.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %51, align 8
  %385 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  %386 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %387 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %52, align 8
  %388 = call ptr @class_behavior_wrapper(ptr %387, ptr noundef nonnull align 8 dereferenceable(8) %52)
  call void %388(ptr nonnull %51, { ptr, i160 } %384) #39
  %389 = call ptr @bump_malloc(i64 noundef 5)
  %390 = insertvalue { ptr } undef, ptr %389, 0
  %. = select i1 %.6, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.432 = select i1 %.6, ptr %53, ptr %58
  %.433 = select i1 %.6, ptr %54, ptr %59
  %.434 = select i1 %.6, ptr %55, ptr %60
  %.435 = select i1 %.6, ptr %56, ptr %61
  %.436 = select i1 %.6, ptr %57, ptr %62
  store <4 x i8> %., ptr %389, align 1
  store ptr @String, ptr %.432, align 8
  %391 = call { i64, i64 } @size_wrapper(ptr %351, ptr noundef nonnull align 8 dereferenceable(8) %.432)
  %392 = extractvalue { i64, i64 } %391, 0
  %393 = call ptr @bump_malloc(i64 %392)
  %394 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %393, 1
  %395 = insertvalue { ptr, ptr, ptr, i32 } %394, ptr undef, 2
  %396 = insertvalue { ptr, ptr, ptr, i32 } %395, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %.433, align 8
  %.433.sroa.sel.v = select i1 %.6, ptr %54, ptr %59
  %.433.sroa.sel = getelementptr inbounds i8, ptr %.433.sroa.sel.v, i64 8
  store ptr @_parameterization_i32, ptr %.433.sroa.sel, align 8
  %.433.sroa.sel445.v = select i1 %.6, ptr %54, ptr %59
  %.433.sroa.sel445 = getelementptr inbounds i8, ptr %.433.sroa.sel445.v, i64 16
  store ptr @_parameterization_i32, ptr %.433.sroa.sel445, align 8
  %397 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %.433)
  %398 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %.434, align 8
  %.434.sroa.sel.v = select i1 %.6, ptr %55, ptr %60
  %.434.sroa.sel = getelementptr inbounds i8, ptr %.434.sroa.sel.v, i64 8
  store ptr @i32_typ, ptr %.434.sroa.sel, align 8
  %.434.sroa.sel440.v = select i1 %.6, ptr %55, ptr %60
  %.434.sroa.sel440 = getelementptr inbounds i8, ptr %.434.sroa.sel440.v, i64 16
  store ptr @i32_typ, ptr %.434.sroa.sel440, align 8
  %399 = call ptr @behavior_wrapper(ptr %363, { ptr, ptr, ptr, i32 } %396, ptr noundef nonnull align 8 dereferenceable(24) %.434)
  call void %399({ ptr, ptr, ptr, i32 } %396, { ptr, ptr, ptr, i32 } %396, ptr nonnull %.433, { ptr } %390, i32 4, i32 5) #39
  %400 = ptrtoint ptr %393 to i64
  %.sroa.3129.8.insert.ext = zext i64 %400 to i160
  %.sroa.3129.8.insert.insert = or disjoint i160 %.sroa.3129.8.insert.ext, 3402823669209384634633746074317682114560
  %401 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3129.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %.435, align 8
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.435)
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %.436, align 8
  %404 = call ptr @class_behavior_wrapper(ptr %387, ptr noundef nonnull align 8 dereferenceable(8) %.436)
  call void %404(ptr nonnull %.435, { ptr, i160 } %401) #39
  %405 = call ptr @bump_malloc(i64 noundef 21)
  store <20 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %405, align 1
  store ptr @String, ptr %63, align 8
  %406 = call { i64, i64 } @size_wrapper(ptr %351, ptr noundef nonnull align 8 dereferenceable(8) %63)
  %407 = extractvalue { i64, i64 } %406, 0
  %408 = call ptr @bump_malloc(i64 %407)
  %409 = insertvalue { ptr } undef, ptr %405, 0
  %410 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %408, 1
  %411 = insertvalue { ptr, ptr, ptr, i32 } %410, ptr undef, 2
  %412 = insertvalue { ptr, ptr, ptr, i32 } %411, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %64, align 8
  %413 = getelementptr inbounds i8, ptr %64, i64 8
  store ptr @_parameterization_i32, ptr %413, align 8
  %414 = getelementptr inbounds i8, ptr %64, i64 16
  store ptr @_parameterization_i32, ptr %414, align 8
  %415 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %64)
  %416 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %65, align 8
  %417 = getelementptr inbounds i8, ptr %65, i64 8
  store ptr @i32_typ, ptr %417, align 8
  %418 = getelementptr inbounds i8, ptr %65, i64 16
  store ptr @i32_typ, ptr %418, align 8
  %419 = call ptr @behavior_wrapper(ptr %363, { ptr, ptr, ptr, i32 } %412, ptr noundef nonnull align 8 dereferenceable(24) %65)
  call void %419({ ptr, ptr, ptr, i32 } %412, { ptr, ptr, ptr, i32 } %412, ptr nonnull %64, { ptr } %409, i32 20, i32 21) #39
  %420 = ptrtoint ptr %408 to i64
  %.sroa.3114.8.insert.ext = zext i64 %420 to i160
  %.sroa.3114.8.insert.insert = or disjoint i160 %.sroa.3114.8.insert.ext, 3402823669209384634633746074317682114560
  %421 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3114.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %66, align 8
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %66)
  %423 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %67, align 8
  %424 = call ptr @class_behavior_wrapper(ptr %387, ptr noundef nonnull align 8 dereferenceable(8) %67)
  call void %424(ptr nonnull %66, { ptr, i160 } %421) #39
  %.sroa.0109.0.insert.ext = zext i32 %.2 to i160
  %425 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0109.0.insert.ext, 1
  store ptr @_parameterization_i32, ptr %68, align 8
  %426 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %68)
  %427 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @i32_typ, ptr %69, align 8
  %428 = call ptr @class_behavior_wrapper(ptr %387, ptr noundef nonnull align 8 dereferenceable(8) %69)
  call void %428(ptr nonnull %68, { ptr, i160 } %425) #39
  %429 = call ptr @bump_malloc(i64 noundef 2)
  store <1 x i8> <i8 41>, ptr %429, align 1
  store ptr @String, ptr %70, align 8
  %430 = call { i64, i64 } @size_wrapper(ptr %351, ptr noundef nonnull align 8 dereferenceable(8) %70)
  %431 = extractvalue { i64, i64 } %430, 0
  %432 = call ptr @bump_malloc(i64 %431)
  %433 = insertvalue { ptr } undef, ptr %429, 0
  %434 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %432, 1
  %435 = insertvalue { ptr, ptr, ptr, i32 } %434, ptr undef, 2
  %436 = insertvalue { ptr, ptr, ptr, i32 } %435, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %71, align 8
  %437 = getelementptr inbounds i8, ptr %71, i64 8
  store ptr @_parameterization_i32, ptr %437, align 8
  %438 = getelementptr inbounds i8, ptr %71, i64 16
  store ptr @_parameterization_i32, ptr %438, align 8
  %439 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %71)
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %72, align 8
  %441 = getelementptr inbounds i8, ptr %72, i64 8
  store ptr @i32_typ, ptr %441, align 8
  %442 = getelementptr inbounds i8, ptr %72, i64 16
  store ptr @i32_typ, ptr %442, align 8
  %443 = call ptr @behavior_wrapper(ptr %363, { ptr, ptr, ptr, i32 } %436, ptr noundef nonnull align 8 dereferenceable(24) %72)
  call void %443({ ptr, ptr, ptr, i32 } %436, { ptr, ptr, ptr, i32 } %436, ptr nonnull %71, { ptr } %433, i32 1, i32 2) #39
  %444 = ptrtoint ptr %432 to i64
  %.sroa.3.8.insert.ext = zext i64 %444 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %445 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %73, align 8
  %446 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %73)
  %447 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %74, align 8
  %448 = call ptr @class_behavior_wrapper(ptr %387, ptr noundef nonnull align 8 dereferenceable(8) %74)
  call void %448(ptr nonnull %73, { ptr, i160 } %445) #39
  ret void
}

define noundef i32 @main() local_unnamed_addr #3 {
  %1 = alloca [1 x ptr], align 8
  %2 = alloca [3 x ptr], align 8
  %3 = alloca { ptr, ptr, ptr }, align 8
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [3 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  call void @setup_landing_pad()
  %11 = call ptr @bump_malloc(i64 noundef 23)
  store <22 x i8> <i8 45, i8 45, i8 45, i8 32, i8 77, i8 97, i8 112, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 45, i8 45, i8 45>, ptr %11, align 1
  store ptr @String, ptr %1, align 8
  %12 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %13 = call { i64, i64 } @size_wrapper(ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %14 = extractvalue { i64, i64 } %13, 0
  %15 = call ptr @bump_malloc(i64 %14)
  %16 = insertvalue { ptr } undef, ptr %11, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %15, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr undef, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %2, align 8
  %20 = getelementptr inbounds i8, ptr %2, i64 8
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %2, i64 16
  store ptr @_parameterization_i32, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %2)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %24 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %3, align 8
  %25 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @i32_typ, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %3, i64 16
  store ptr @i32_typ, ptr %26, align 8
  %27 = call ptr @behavior_wrapper(ptr %24, { ptr, ptr, ptr, i32 } %19, ptr noundef nonnull align 8 dereferenceable(24) %3)
  call void %27({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %2, { ptr } %16, i32 22, i32 23) #39
  %28 = ptrtoint ptr %15 to i64
  %.sroa.319.8.insert.ext = zext i64 %28 to i160
  %.sroa.319.8.insert.insert = or disjoint i160 %.sroa.319.8.insert.ext, 3402823669209384634633746074317682114560
  %29 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.319.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %4, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  %32 = load ptr, ptr getelementptr inbounds (i8, ptr @IO, i64 80), align 8
  store ptr @String, ptr %5, align 8
  %33 = call ptr @class_behavior_wrapper(ptr %32, ptr noundef nonnull align 8 dereferenceable(8) %5)
  call void %33(ptr nonnull %4, { ptr, i160 } %29) #39
  call void @benchmark_insert_sequential(i32 noundef 1000000)
  call void @benchmark_insert_random(i32 noundef 1000000)
  call void @benchmark_get_sequential_hit(i32 noundef 1000000)
  call void @benchmark_get_random_hit(i32 noundef 1000000)
  call void @benchmark_get_random_miss(i32 noundef 1000000)
  call void @benchmark_remove_random(i32 noundef 1000000)
  %34 = call ptr @bump_malloc(i64 noundef 28)
  store <27 x i8> <i8 45, i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %34, align 1
  store ptr @String, ptr %6, align 8
  %35 = call { i64, i64 } @size_wrapper(ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %36 = extractvalue { i64, i64 } %35, 0
  %37 = call ptr @bump_malloc(i64 %36)
  %38 = insertvalue { ptr } undef, ptr %34, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %37, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr undef, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %7, align 8
  %42 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %7)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  store ptr @buffer_typ, ptr %8, align 8
  %46 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %47, align 8
  %48 = call ptr @behavior_wrapper(ptr %24, { ptr, ptr, ptr, i32 } %41, ptr noundef nonnull align 8 dereferenceable(24) %8)
  call void %48({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull %7, { ptr } %38, i32 27, i32 28) #39
  %49 = ptrtoint ptr %37 to i64
  %.sroa.3.8.insert.ext = zext i64 %49 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %50 = insertvalue { ptr, i160 } { ptr @String, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  store ptr @_parameterization_String, ptr %9, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @IO)
  store ptr @String, ptr %10, align 8
  %53 = call ptr @class_behavior_wrapper(ptr %32, ptr noundef nonnull align 8 dereferenceable(8) %10)
  call void %53(ptr nonnull %9, { ptr, i160 } %50) #39
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_bool_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

define { ptr, i160 } @_box_bool_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_bool_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_bool_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_bool_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_any_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Object(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IO(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

define ptr @IO_B__Self_print_xBool__Self_print_xi32__Self_print_xf64__Self_print_xi8__Self_print_xi64__Self_print_xNil__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xString(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #29
  %3 = load ptr, ptr %0, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %12 = load i64, ptr @Representable, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %10, i64 %9, i64 %8, i64 %12, i64 noundef ptrtoint (ptr @Representable to i64), ptr %11)
  br i1 %13, label %14, label %.critedge

14:                                               ; preds = %1
  %15 = load i64, ptr %4, align 4
  %16 = load i64, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = load ptr, ptr %7, align 8
  %19 = load i64, ptr @Character, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Character to i64), ptr %18)
  br i1 %20, label %.critedge, label %21

21:                                               ; preds = %14
  %22 = load i64, ptr %4, align 4
  %23 = load i64, ptr %5, align 4
  %24 = load ptr, ptr %6, align 8
  %25 = load ptr, ptr %7, align 8
  %26 = load i64, ptr @String, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 %26, i64 noundef ptrtoint (ptr @String to i64), ptr %25)
  br i1 %27, label %.critedge, label %65

.critedge:                                        ; preds = %21, %14, %1
  %28 = load i64, ptr %4, align 4
  %29 = load i64, ptr %5, align 4
  %30 = load ptr, ptr %6, align 8
  %31 = load ptr, ptr %7, align 8
  %32 = load i64, ptr @Character, align 8
  %33 = call i1 @subtype_test_wrapper(ptr %30, i64 %29, i64 %28, i64 %32, i64 noundef ptrtoint (ptr @Character to i64), ptr %31)
  br i1 %33, label %34, label %.critedge15

34:                                               ; preds = %.critedge
  %35 = load i64, ptr %4, align 4
  %36 = load i64, ptr %5, align 4
  %37 = load ptr, ptr %6, align 8
  %38 = load ptr, ptr %7, align 8
  %39 = load i64, ptr @String, align 8
  %40 = call i1 @subtype_test_wrapper(ptr %37, i64 %36, i64 %35, i64 %39, i64 noundef ptrtoint (ptr @String to i64), ptr %38)
  br i1 %40, label %.critedge15, label %65

.critedge15:                                      ; preds = %34, %.critedge
  %41 = icmp eq ptr %3, @i32_typ
  br i1 %41, label %65, label %42

42:                                               ; preds = %.critedge15
  %43 = icmp eq ptr %3, @nil_typ
  %44 = icmp eq ptr %3, null
  %45 = or i1 %43, %44
  br i1 %45, label %65, label %46

46:                                               ; preds = %42
  %47 = icmp eq ptr %3, @bool_typ
  br i1 %47, label %65, label %48

48:                                               ; preds = %46
  %49 = icmp eq ptr %3, @f64_typ
  br i1 %49, label %65, label %50

50:                                               ; preds = %48
  %51 = load i64, ptr %4, align 4
  %52 = load i64, ptr %5, align 4
  %53 = load ptr, ptr %6, align 8
  %54 = load ptr, ptr %7, align 8
  %55 = load i64, ptr @String, align 8
  %56 = call i1 @subtype_test_wrapper(ptr %53, i64 %52, i64 %51, i64 %55, i64 noundef ptrtoint (ptr @String to i64), ptr %54)
  br i1 %56, label %57, label %.critedge17

57:                                               ; preds = %50
  %58 = load i64, ptr %4, align 4
  %59 = load i64, ptr %5, align 4
  %60 = load ptr, ptr %6, align 8
  %61 = load ptr, ptr %7, align 8
  %62 = call i1 @subtype_test_wrapper(ptr %60, i64 %59, i64 %58, i64 %32, i64 noundef ptrtoint (ptr @Character to i64), ptr %61)
  br i1 %62, label %.critedge17, label %65

.critedge17:                                      ; preds = %57, %50
  %63 = icmp eq ptr %3, @i64_typ
  %64 = select i1 %63, i32 5, i32 4
  br label %65

65:                                               ; preds = %.critedge17, %57, %48, %46, %42, %.critedge15, %34, %21
  %.reg2mem27.0 = phi i32 [ 2, %.critedge15 ], [ 6, %42 ], [ 1, %46 ], [ 3, %48 ], [ %64, %.critedge17 ], [ 9, %57 ], [ 7, %34 ], [ 8, %21 ]
  %66 = zext nneg i32 %.reg2mem27.0 to i64
  %67 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %66
  %68 = getelementptr i8, ptr %67, i64 80
  %69 = load ptr, ptr %68, align 8
  ret ptr %69
}

define void @IO__Self_print_xBool(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %4 = alloca [1 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [3 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr }, align 8
  %.sroa.1.sroa.0 = alloca i8, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %.sroa.1.sroa.0, align 8
  %.sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.8. = load i1, ptr %.sroa.1.sroa.0, align 8
  br i1 %.sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.sroa.0.0..sroa.1.8., label %10, label %33

10:                                               ; preds = %2
  %11 = call ptr @bump_malloc(i64 noundef 5)
  store <4 x i8> <i8 116, i8 114, i8 117, i8 101>, ptr %11, align 1
  store ptr @String, ptr %4, align 8
  %12 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %13 = call { i64, i64 } @size_wrapper(ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %14 = extractvalue { i64, i64 } %13, 0
  %15 = call ptr @bump_malloc(i64 %14)
  %16 = insertvalue { ptr } undef, ptr %11, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %15, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr undef, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %5, align 8
  %20 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr @_parameterization_i32, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %5)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %24 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %6, align 8
  %25 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr @i32_typ, ptr %26, align 8
  %27 = call ptr @behavior_wrapper(ptr %24, { ptr, ptr, ptr, i32 } %19, ptr noundef nonnull align 8 dereferenceable(24) %6)
  call void %27({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %5, { ptr } %16, i32 4, i32 5) #39
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %30 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 160), align 8
  %31 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %19, ptr noundef nonnull align 8 %3)
  %32 = call { ptr } %31({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %3) #39
  br label %56

33:                                               ; preds = %2
  %34 = call ptr @bump_malloc(i64 noundef 6)
  store <5 x i8> <i8 102, i8 97, i8 108, i8 115, i8 101>, ptr %34, align 1
  store ptr @String, ptr %7, align 8
  %35 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %36 = call { i64, i64 } @size_wrapper(ptr %35, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %37 = extractvalue { i64, i64 } %36, 0
  %38 = call ptr @bump_malloc(i64 %37)
  %39 = insertvalue { ptr } undef, ptr %34, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %38, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr undef, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %8, align 8
  %43 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @_parameterization_i32, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @_parameterization_i32, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %8)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %47 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %9, align 8
  %48 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @i32_typ, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @i32_typ, ptr %49, align 8
  %50 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %42, ptr noundef nonnull align 8 dereferenceable(24) %9)
  call void %50({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull %8, { ptr } %39, i32 5, i32 6) #39
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %53 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 160), align 8
  %54 = call ptr @behavior_wrapper(ptr %53, { ptr, ptr, ptr, i32 } %42, ptr noundef nonnull align 8 %3)
  %55 = call { ptr } %54({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull %3) #39
  br label %56

56:                                               ; preds = %33, %10
  %.sink = phi { ptr } [ %55, %33 ], [ %32, %10 ]
  %.fca.0.extract1 = extractvalue { ptr } %.sink, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract1) #39
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi32(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #26 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.sroa.1.8.extract.trunc) #27
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xf64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #26 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @float_string, double %3) #27
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi8(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #26 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  %3 = sext i8 %.sroa.1.8.extract.trunc to i32
  %4 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3) #27
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xi64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #26 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.sroa.1.8.extract.trunc) #27
  ret void
}

define void @IO__Self_print_xNil(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %4 = call ptr @bump_malloc(i64 noundef 4)
  store <3 x i8> <i8 110, i8 105, i8 108>, ptr %4, align 1
  %5 = alloca [1 x ptr], align 8
  store ptr @String, ptr %5, align 8
  %6 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = call ptr @bump_malloc(i64 %8)
  %10 = insertvalue { ptr } undef, ptr %4, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %9, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr undef, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 10, 3
  %14 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_i32, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr @_parameterization_i32, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %14)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %19 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  %20 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @i32_typ, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %20, i64 16
  store ptr @i32_typ, ptr %22, align 8
  %23 = call ptr @behavior_wrapper(ptr %19, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 dereferenceable(24) %20)
  call void %23({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %14, { ptr } %10, i32 3, i32 4) #39
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %26 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 160), align 8
  %27 = call ptr @behavior_wrapper(ptr %26, { ptr, ptr, ptr, i32 } %13, ptr noundef nonnull align 8 %3)
  %28 = call { ptr } %27({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %3) #39
  %.fca.0.extract = extractvalue { ptr } %28, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #39
  ret void
}

define void @IO__Self_print_xCharacter(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %5, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 8 dereferenceable(96) @Character)
  %6 = call ptr @bump_malloc(i64 noundef 2)
  %7 = load ptr, ptr %4, align 8
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %7, 0
  %9 = load ptr, ptr %5, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %9, 1
  %11 = getelementptr inbounds i8, ptr %4, i64 16
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 2
  %14 = getelementptr inbounds i8, ptr %4, i64 24
  %15 = load i32, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %15, 3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %7)
  %19 = sext i32 %15 to i64
  %20 = getelementptr ptr, ptr %7, i64 %19
  %21 = getelementptr i8, ptr %20, i64 16
  %22 = load ptr, ptr %21, align 8
  %23 = call ptr @behavior_wrapper(ptr %22, { ptr, ptr, ptr, i32 } %16, ptr noundef nonnull align 8 %3)
  %24 = call i8 %23({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %3) #39
  store i8 %24, ptr %6, align 1
  %25 = getelementptr i8, ptr %6, i64 1
  store i8 0, ptr %25, align 1
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(2) %6) #39
  ret void
}

define void @IO__Self_print_xRepresentable(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract3, ptr %5, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 8 dereferenceable(72) @Representable)
  %6 = load ptr, ptr %4, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %6, 0
  %8 = load ptr, ptr %5, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %8, 1
  %10 = getelementptr inbounds i8, ptr %4, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %11, 2
  %13 = getelementptr inbounds i8, ptr %4, i64 24
  %14 = load i32, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %14, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef %6)
  %18 = sext i32 %14 to i64
  %19 = getelementptr ptr, ptr %6, i64 %18
  %20 = load ptr, ptr %19, align 8
  %21 = call ptr @behavior_wrapper(ptr %20, { ptr, ptr, ptr, i32 } %15, ptr noundef nonnull align 8 %3)
  %22 = call { ptr, ptr, ptr, i32 } %21({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %3) #39
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %22, 3
  %23 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %23, i64 8
  store ptr %.fca.1.extract, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %23, i64 16
  store ptr %.fca.2.extract, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %23, i64 24
  store i32 %.fca.3.extract, ptr %26, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %23, ptr noundef nonnull align 8 dereferenceable(1248) @String)
  %27 = load ptr, ptr %23, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = load ptr, ptr %24, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %29, 1
  %31 = load ptr, ptr %25, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %31, 2
  %33 = load i32, ptr %26, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %33, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %27)
  %37 = sext i32 %33 to i64
  %38 = getelementptr ptr, ptr %27, i64 %37
  %39 = getelementptr i8, ptr %38, i64 80
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @behavior_wrapper(ptr %40, { ptr, ptr, ptr, i32 } %34, ptr noundef nonnull align 8 %3)
  %42 = call { ptr } %41({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %3) #39
  %.fca.0.extract = extractvalue { ptr } %42, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #39
  ret void
}

define void @IO__Self_print_xString(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %5, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 8 dereferenceable(1248) @String)
  %6 = load ptr, ptr %4, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %6, 0
  %8 = load ptr, ptr %5, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %8, 1
  %10 = getelementptr inbounds i8, ptr %4, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %11, 2
  %13 = getelementptr inbounds i8, ptr %4, i64 24
  %14 = load i32, ptr %13, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %14, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %6)
  %18 = sext i32 %14 to i64
  %19 = getelementptr ptr, ptr %6, i64 %18
  %20 = getelementptr i8, ptr %19, i64 80
  %21 = load ptr, ptr %20, align 8
  %22 = call ptr @behavior_wrapper(ptr %21, { ptr, ptr, ptr, i32 } %15, ptr noundef nonnull align 8 %3)
  %23 = call { ptr } %22({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %3) #39
  %.fca.0.extract = extractvalue { ptr } %23, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #39
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #27

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_String(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @String_field_String_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #28 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #29
  ret ptr @String__Self_from_c_string_c_stringBufferi8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferi8_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_xi8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B_extend_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 400
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 416
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6681222582356018452, i64 noundef ptrtoint (ptr @Character to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 472
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 54, i64 53
  %8 = getelementptr [149 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @String_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Collection, align 8
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %21, label %.critedge, label %28

.critedge:                                        ; preds = %15, %2
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = load i64, ptr @Collection, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 %26, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %28

28:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 57, %.critedge ], [ 56, %15 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %.reg2mem3.0 to i64
  %31 = getelementptr [149 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 8
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 59, %22 ], [ 59, %15 ], [ 58, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [149 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @String_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Collection, align 8
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %21, label %.critedge, label %28

.critedge:                                        ; preds = %15, %2
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = load i64, ptr @Collection, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 %26, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %28

28:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 61, %.critedge ], [ 60, %15 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %.reg2mem3.0 to i64
  %31 = getelementptr [149 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @String_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 8
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 62, %22 ], [ 62, %15 ], [ 63, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [149 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define { ptr, ptr, ptr, i32 } @String__Self_from_c_string_c_stringBufferi8(ptr nocapture nofree readnone %0, { ptr } %1) #3 {
  %3 = alloca [1 x ptr], align 8
  %4 = alloca [3 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr }, align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %2
  %.0 = phi i32 [ 0, %2 ], [ %.1, %._crit_edge ]
  %7 = sext i32 %.0 to i64
  %8 = getelementptr i8, ptr %.fca.0.extract, i64 %7
  %9 = load i8, ptr %8, align 1
  %.not = icmp ne i8 %9, 0
  %10 = zext i1 %.not to i32
  %.1 = add i32 %.0, %10
  br i1 %.not, label %._crit_edge, label %11

11:                                               ; preds = %._crit_edge
  store ptr @String, ptr %3, align 8
  %12 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = call ptr @bump_malloc(i64 %13)
  %15 = add i32 %.1, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %14, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr undef, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %4, align 8
  %19 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @_parameterization_i32, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %4)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  store ptr @buffer_typ, ptr %5, align 8
  %23 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @i32_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %18, ptr noundef nonnull align 8 dereferenceable(24) %5)
  call void %25({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull %4, { ptr } %1, i32 %.1, i32 %15) #39
  store ptr @String, ptr %6, align 8
  %26 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %14, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %6, i64 16
  %28 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 10, ptr %28, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %29 = load ptr, ptr %6, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %29, 0
  %31 = load ptr, ptr %26, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %31, 1
  %33 = load ptr, ptr %27, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 2
  %35 = load i32, ptr %28, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %35, 3
  ret { ptr, ptr, ptr, i32 } %36
}

define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %8 = call ptr @bump_malloc(i64 noundef 1)
  %9 = load ptr, ptr %5, align 8
  %10 = load ptr, ptr %4, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %7, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = insertvalue { ptr } undef, ptr %8, 0
  call void %17(ptr %9, { ptr } %18) #30
  %19 = load ptr, ptr %5, align 8
  %20 = load ptr, ptr %4, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %20)
  %22 = load i32, ptr %7, align 8
  %23 = sext i32 %22 to i64
  %24 = getelementptr ptr, ptr %20, i64 %23
  %25 = getelementptr i8, ptr %24, i64 16
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %19, i32 1) #30
  %29 = load ptr, ptr %5, align 8
  %30 = load ptr, ptr %4, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %30)
  %32 = load i32, ptr %7, align 8
  %33 = sext i32 %32 to i64
  %34 = getelementptr ptr, ptr %30, i64 %33
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %29, i32 0) #30
  ret void
}

define void @String_init_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %10, i32 %3) #30
  %20 = load ptr, ptr %7, align 8
  %21 = load ptr, ptr %6, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %21)
  %23 = load i32, ptr %9, align 8
  %24 = sext i32 %23 to i64
  %25 = getelementptr ptr, ptr %21, i64 %24
  %26 = getelementptr i8, ptr %25, i64 16
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %20, i32 %4) #30
  %30 = load ptr, ptr %7, align 8
  %31 = load ptr, ptr %6, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %31)
  %33 = load i32, ptr %9, align 8
  %34 = sext i32 %33 to i64
  %35 = getelementptr ptr, ptr %31, i64 %34
  %36 = getelementptr i8, ptr %35, i64 16
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call i32 %38(ptr %30) #31
  %40 = sext i32 %39 to i64
  %41 = call ptr @bump_malloc(i64 %40)
  %42 = load ptr, ptr %7, align 8
  %43 = load ptr, ptr %6, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %43)
  %45 = load i32, ptr %9, align 8
  %46 = sext i32 %45 to i64
  %47 = getelementptr ptr, ptr %43, i64 %46
  %48 = load ptr, ptr %47, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = insertvalue { ptr } undef, ptr %41, 0
  call void %50(ptr %42, { ptr } %51) #30
  ret void
}

define void @String_init_bytesBufferi8_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #3 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %11 = load ptr, ptr %8, align 8
  %12 = load ptr, ptr %7, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %12)
  %14 = load i32, ptr %10, align 8
  %15 = sext i32 %14 to i64
  %16 = getelementptr ptr, ptr %12, i64 %15
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %11, { ptr } %3) #30
  %20 = load ptr, ptr %8, align 8
  %21 = load ptr, ptr %7, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %21)
  %23 = load i32, ptr %10, align 8
  %24 = sext i32 %23 to i64
  %25 = getelementptr ptr, ptr %21, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %20, i32 %4) #30
  %30 = load ptr, ptr %8, align 8
  %31 = load ptr, ptr %7, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %31)
  %33 = load i32, ptr %10, align 8
  %34 = sext i32 %33 to i64
  %35 = getelementptr ptr, ptr %31, i64 %34
  %36 = getelementptr i8, ptr %35, i64 16
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  call void %39(ptr %30, i32 %5) #30
  ret void
}

define i32 @String_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  ret i32 %17
}

define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  ret i32 %17
}

define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  %18 = add i32 %17, 1
  %19 = sext i32 %18 to i64
  %20 = call ptr @bump_malloc(i64 %19)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %3
  %.0 = phi i32 [ 0, %3 ], [ %.1, %._crit_edge ]
  %21 = load ptr, ptr %5, align 8
  %22 = load ptr, ptr %4, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %7, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call i32 %29(ptr %21) #31
  %31 = icmp slt i32 %.0, %30
  br i1 %31, label %32, label %._crit_edge

32:                                               ; preds = %._crit_edge1
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %22)
  %34 = load ptr, ptr %26, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %21) #31
  %.fca.0.extract19 = extractvalue { ptr } %36, 0
  %37 = sext i32 %.0 to i64
  %38 = getelementptr i8, ptr %.fca.0.extract19, i64 %37
  %39 = load i8, ptr %38, align 1
  %40 = getelementptr i8, ptr %20, i64 %37
  store i8 %39, ptr %40, align 1
  %41 = add nsw i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %32, %._crit_edge1
  %.1 = phi i32 [ %41, %32 ], [ %.0, %._crit_edge1 ]
  br i1 %31, label %._crit_edge1, label %42

42:                                               ; preds = %._crit_edge
  %43 = load ptr, ptr %5, align 8
  %44 = load ptr, ptr %4, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %44)
  %46 = load i32, ptr %7, align 8
  %47 = sext i32 %46 to i64
  %48 = getelementptr ptr, ptr %44, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = call i32 %51(ptr %43) #31
  %53 = sext i32 %52 to i64
  %54 = getelementptr i8, ptr %20, i64 %53
  store i8 0, ptr %54, align 1
  %55 = insertvalue { ptr } undef, ptr %20, 0
  ret { ptr } %55
}

define { ptr, ptr, ptr, i32 } @String_append_xi8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %8, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %15 = load i32, ptr %11, align 8
  %16 = sext i32 %15 to i64
  %17 = getelementptr ptr, ptr %13, i64 %16
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %12) #31
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %23 = getelementptr i8, ptr %17, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call i32 %25(ptr %12) #31
  %.not = icmp slt i32 %21, %26
  br i1 %.not, label %._crit_edge, label %27

27:                                               ; preds = %4
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %29 = call i32 %25(ptr %12) #31
  %30 = shl i32 %29, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %12, 1
  %33 = load ptr, ptr %10, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %15, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %38 = getelementptr i8, ptr %17, i64 104
  %39 = load ptr, ptr %38, align 8
  store ptr @i32_typ, ptr %6, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %35, ptr noundef nonnull align 8 dereferenceable(8) %6)
  call void %40({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull %5, i32 %30) #39
  br label %._crit_edge

._crit_edge:                                      ; preds = %27, %4
  %41 = load ptr, ptr %9, align 8
  %42 = load ptr, ptr %8, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %42)
  %44 = load i32, ptr %11, align 8
  %45 = sext i32 %44 to i64
  %46 = getelementptr ptr, ptr %42, i64 %45
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %49 = load ptr, ptr %48, align 8
  %50 = call i32 %49(ptr %41) #31
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %42)
  %52 = load ptr, ptr %46, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr } %53(ptr %41) #31
  %.fca.0.extract7 = extractvalue { ptr } %54, 0
  %55 = sext i32 %50 to i64
  %56 = getelementptr i8, ptr %.fca.0.extract7, i64 %55
  store i8 %3, ptr %56, align 1
  %57 = load ptr, ptr %9, align 8
  %58 = load ptr, ptr %8, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %58)
  %60 = load i32, ptr %11, align 8
  %61 = sext i32 %60 to i64
  %62 = getelementptr ptr, ptr %58, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %65 = load ptr, ptr %64, align 8
  %66 = call i32 %65(ptr %57) #31
  %67 = add i32 %66, 1
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %58)
  %69 = getelementptr i8, ptr %64, i64 8
  %70 = load ptr, ptr %69, align 8
  call void %70(ptr %57, i32 %67) #30
  %71 = load ptr, ptr %8, align 8
  store ptr %71, ptr %7, align 8
  %72 = getelementptr inbounds i8, ptr %7, i64 8
  %73 = load ptr, ptr %9, align 8
  store ptr %73, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %7, i64 16
  %75 = load ptr, ptr %10, align 8
  store ptr %75, ptr %74, align 8
  %76 = getelementptr inbounds i8, ptr %7, i64 24
  %77 = load i32, ptr %11, align 8
  store i32 %77, ptr %76, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %78 = load ptr, ptr %7, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = load ptr, ptr %72, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 1
  %82 = load ptr, ptr %74, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %82, 2
  %84 = load i32, ptr %76, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %84, 3
  ret { ptr, ptr, ptr, i32 } %85
}

define { ptr, ptr, ptr, i32 } @String_extend_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %.fca.1.extract12, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr %.fca.2.extract13, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %11, i64 24
  store i32 %.fca.3.extract14, ptr %14, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %11, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr %.fca.1.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr %.fca.2.extract, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %15, i64 24
  store i32 %.fca.3.extract, ptr %18, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %15, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %19 = load ptr, ptr %15, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %19, 0
  %21 = load ptr, ptr %16, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 1
  %23 = load ptr, ptr %17, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %23, 2
  %25 = load i32, ptr %18, align 8
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %25, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %19)
  %29 = sext i32 %25 to i64
  %30 = getelementptr ptr, ptr %19, i64 %29
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %5)
  %34 = call i32 %33({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull %5) #39
  %35 = load ptr, ptr %12, align 8
  %36 = load ptr, ptr %11, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %36)
  %38 = load i32, ptr %14, align 8
  %39 = sext i32 %38 to i64
  %40 = getelementptr ptr, ptr %36, i64 %39
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call i32 %43(ptr %35) #31
  %45 = add i32 %44, %34
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %35, 1
  %48 = load ptr, ptr %13, align 8
  %49 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %48, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %38, 3
  %51 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %36)
  %54 = getelementptr i8, ptr %40, i64 104
  %55 = load ptr, ptr %54, align 8
  %56 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %56, align 8
  %57 = call ptr @behavior_wrapper(ptr %55, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(8) %56)
  call void %57({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %51, i32 %45) #39
  %58 = getelementptr inbounds i8, ptr %8, i64 8
  %59 = getelementptr inbounds i8, ptr %9, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %.0 = phi i32 [ 0, %4 ], [ %.1, %._crit_edge ]
  %60 = icmp slt i32 %.0, %34
  br i1 %60, label %61, label %._crit_edge

61:                                               ; preds = %._crit_edge1
  %62 = add i32 %.0, %44
  %63 = load ptr, ptr %15, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %63, 0
  %65 = load ptr, ptr %16, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %65, 1
  %67 = load ptr, ptr %17, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 2
  %69 = load i32, ptr %18, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 %69, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %63)
  %73 = sext i32 %69 to i64
  %74 = getelementptr ptr, ptr %63, i64 %73
  %75 = getelementptr i8, ptr %74, i64 120
  %76 = load ptr, ptr %75, align 8
  store ptr @i32_typ, ptr %7, align 8
  %77 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %70, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %78 = call i8 %77({ ptr, ptr, ptr, i32 } %70, { ptr, ptr, ptr, i32 } %70, ptr nonnull %6, i32 %.0) #39
  %79 = load ptr, ptr %11, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %79, 0
  %81 = load ptr, ptr %12, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %81, 1
  %83 = load ptr, ptr %13, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %83, 2
  %85 = load i32, ptr %14, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 %85, 3
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr @_parameterization_i8, ptr %58, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %79)
  %89 = sext i32 %85 to i64
  %90 = getelementptr ptr, ptr %79, i64 %89
  %91 = getelementptr i8, ptr %90, i64 128
  %92 = load ptr, ptr %91, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr @i8_typ, ptr %59, align 8
  %93 = call ptr @behavior_wrapper(ptr %92, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(16) %9)
  call void %93({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %8, i32 %62, i8 %78) #39
  %94 = add nsw i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %61, %._crit_edge1
  %.1 = phi i32 [ %94, %61 ], [ %.0, %._crit_edge1 ]
  br i1 %60, label %._crit_edge1, label %95

95:                                               ; preds = %._crit_edge
  %96 = load ptr, ptr %12, align 8
  %97 = load ptr, ptr %11, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %97)
  %99 = load i32, ptr %14, align 8
  %100 = sext i32 %99 to i64
  %101 = getelementptr ptr, ptr %97, i64 %100
  %102 = getelementptr i8, ptr %101, i64 8
  %103 = load ptr, ptr %102, align 8
  %104 = getelementptr i8, ptr %103, i64 8
  %105 = load ptr, ptr %104, align 8
  call void %105(ptr %96, i32 %45) #30
  %106 = load ptr, ptr %11, align 8
  store ptr %106, ptr %10, align 8
  %107 = getelementptr inbounds i8, ptr %10, i64 8
  %108 = load ptr, ptr %12, align 8
  store ptr %108, ptr %107, align 8
  %109 = getelementptr inbounds i8, ptr %10, i64 16
  %110 = load ptr, ptr %13, align 8
  store ptr %110, ptr %109, align 8
  %111 = getelementptr inbounds i8, ptr %10, i64 24
  %112 = load i32, ptr %14, align 8
  store i32 %112, ptr %111, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %113 = load ptr, ptr %10, align 8
  %114 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %113, 0
  %115 = load ptr, ptr %107, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr %115, 1
  %117 = load ptr, ptr %109, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr %117, 2
  %119 = load i32, ptr %111, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } %118, i32 %119, 3
  ret { ptr, ptr, ptr, i32 } %120
}

define void @String_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %9) #31
  %.not = icmp sgt i32 %3, %18
  br i1 %.not, label %19, label %.loopexit

19:                                               ; preds = %4
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %21 = getelementptr i8, ptr %16, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %9, i32 %3) #30
  %23 = load ptr, ptr %6, align 8
  %24 = load ptr, ptr %5, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %24)
  %26 = load i32, ptr %8, align 8
  %27 = sext i32 %26 to i64
  %28 = getelementptr ptr, ptr %24, i64 %27
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %23) #31
  %.fca.0.extract20 = extractvalue { ptr } %31, 0
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %24)
  %33 = getelementptr i8, ptr %28, i64 16
  %34 = load ptr, ptr %33, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %23) #31
  %37 = sext i32 %36 to i64
  %38 = call ptr @bump_malloc(i64 %37)
  %39 = load ptr, ptr %6, align 8
  %40 = load ptr, ptr %5, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %40)
  %42 = load i32, ptr %8, align 8
  %43 = sext i32 %42 to i64
  %44 = getelementptr ptr, ptr %40, i64 %43
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr } undef, ptr %38, 0
  call void %47(ptr %39, { ptr } %48) #30
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %19
  %.0 = phi i32 [ 0, %19 ], [ %.1, %._crit_edge ]
  %49 = load ptr, ptr %6, align 8
  %50 = load ptr, ptr %5, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %50)
  %52 = load i32, ptr %8, align 8
  %53 = sext i32 %52 to i64
  %54 = getelementptr ptr, ptr %50, i64 %53
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  %57 = load ptr, ptr %56, align 8
  %58 = call i32 %57(ptr %49) #31
  %59 = icmp slt i32 %.0, %58
  br i1 %59, label %60, label %._crit_edge

60:                                               ; preds = %._crit_edge1
  %61 = sext i32 %.0 to i64
  %62 = getelementptr i8, ptr %.fca.0.extract20, i64 %61
  %63 = load i8, ptr %62, align 1
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %50)
  %65 = load ptr, ptr %54, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr } %66(ptr %49) #31
  %.fca.0.extract6 = extractvalue { ptr } %67, 0
  %68 = getelementptr i8, ptr %.fca.0.extract6, i64 %61
  store i8 %63, ptr %68, align 1
  %69 = add nsw i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %60, %._crit_edge1
  %.1 = phi i32 [ %69, %60 ], [ %.0, %._crit_edge1 ]
  br i1 %59, label %._crit_edge1, label %.loopexit

.loopexit:                                        ; preds = %._crit_edge, %4
  ret void
}

define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract3, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract4, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract5, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %12 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %.fca.1.extract, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr %.fca.2.extract, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %12, i64 24
  store i32 %.fca.3.extract, ptr %15, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %12, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %16 = load ptr, ptr %9, align 8
  %17 = load ptr, ptr %8, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %17)
  %19 = load i32, ptr %11, align 8
  %20 = sext i32 %19 to i64
  %21 = getelementptr ptr, ptr %17, i64 %20
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call i32 %24(ptr %16) #31
  %26 = load ptr, ptr %12, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %26, 0
  %28 = load ptr, ptr %13, align 8
  %29 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %28, 1
  %30 = load ptr, ptr %14, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %30, 2
  %32 = load i32, ptr %15, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %32, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %26)
  %36 = sext i32 %32 to i64
  %37 = getelementptr ptr, ptr %26, i64 %36
  %38 = getelementptr i8, ptr %37, i64 64
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 %5)
  %41 = call i32 %40({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull %5) #39
  %.not = icmp eq i32 %25, %41
  br i1 %.not, label %.preheader, label %.loopexit

.preheader:                                       ; preds = %78, %4
  %.0 = phi i32 [ %.2, %78 ], [ 0, %4 ]
  %42 = load ptr, ptr %9, align 8
  %43 = load ptr, ptr %8, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %43)
  %45 = load i32, ptr %11, align 8
  %46 = sext i32 %45 to i64
  %47 = getelementptr ptr, ptr %43, i64 %46
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = load ptr, ptr %49, align 8
  %51 = call i32 %50(ptr %42) #31
  %52 = icmp sge i32 %.0, %51
  br i1 %52, label %78, label %53

53:                                               ; preds = %.preheader
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %43)
  %55 = load ptr, ptr %47, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = call { ptr } %56(ptr %42) #31
  %.fca.0.extract16 = extractvalue { ptr } %57, 0
  %58 = sext i32 %.0 to i64
  %59 = getelementptr i8, ptr %.fca.0.extract16, i64 %58
  %60 = load i8, ptr %59, align 1
  %61 = load ptr, ptr %12, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %61, 0
  %63 = load ptr, ptr %13, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %63, 1
  %65 = load ptr, ptr %14, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %65, 2
  %67 = load i32, ptr %15, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, i32 %67, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %61)
  %71 = sext i32 %67 to i64
  %72 = getelementptr ptr, ptr %61, i64 %71
  %73 = getelementptr i8, ptr %72, i64 120
  %74 = load ptr, ptr %73, align 8
  store ptr @i32_typ, ptr %7, align 8
  %75 = call ptr @behavior_wrapper(ptr %74, { ptr, ptr, ptr, i32 } %68, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %76 = call i8 %75({ ptr, ptr, ptr, i32 } %68, { ptr, ptr, ptr, i32 } %68, ptr nonnull %6, i32 %.0) #39
  %.not24 = icmp eq i8 %60, %76
  %77 = zext i1 %.not24 to i32
  %spec.select = add i32 %.0, %77
  br label %78

78:                                               ; preds = %53, %.preheader
  %.reg2mem44.0.off0 = phi i1 [ %.not24, %53 ], [ false, %.preheader ]
  %.2 = phi i32 [ %spec.select, %53 ], [ %.0, %.preheader ]
  br i1 %.reg2mem44.0.off0, label %.preheader, label %.loopexit

.loopexit:                                        ; preds = %78, %4
  %.reg2mem42.0 = phi i1 [ false, %4 ], [ %52, %78 ]
  ret i1 %.reg2mem42.0
}

define i8 @String_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr } %16(ptr %9) #31
  %.fca.0.extract = extractvalue { ptr } %17, 0
  %18 = sext i32 %3 to i64
  %19 = getelementptr i8, ptr %.fca.0.extract, i64 %18
  %20 = load i8, ptr %19, align 1
  ret i8 %20
}

define void @String_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i8 %4) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr } %17(ptr %10) #31
  %.fca.0.extract = extractvalue { ptr } %18, 0
  %19 = sext i32 %3 to i64
  %20 = getelementptr i8, ptr %.fca.0.extract, i64 %19
  store i8 %4, ptr %20, align 1
  ret void
}

define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %8, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %15 = load i32, ptr %11, align 8
  %16 = sext i32 %15 to i64
  %17 = getelementptr ptr, ptr %13, i64 %16
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %12) #31
  %22 = sext i32 %21 to i64
  %23 = call ptr @bump_malloc(i64 %22)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %3
  %.0 = phi i32 [ 0, %3 ], [ %.1, %._crit_edge ]
  %24 = load ptr, ptr %9, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %25)
  %27 = load i32, ptr %11, align 8
  %28 = sext i32 %27 to i64
  %29 = getelementptr ptr, ptr %25, i64 %28
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call i32 %32(ptr %24) #31
  %34 = icmp slt i32 %.0, %33
  br i1 %34, label %35, label %._crit_edge

35:                                               ; preds = %._crit_edge1
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %25)
  %37 = load ptr, ptr %29, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr %24) #31
  %.fca.0.extract27 = extractvalue { ptr } %39, 0
  %40 = sext i32 %.0 to i64
  %41 = getelementptr i8, ptr %.fca.0.extract27, i64 %40
  %42 = load i8, ptr %41, align 1
  %43 = getelementptr i8, ptr %23, i64 %40
  store i8 %42, ptr %43, align 1
  %44 = add nsw i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %35, %._crit_edge1
  %.1 = phi i32 [ %44, %35 ], [ %.0, %._crit_edge1 ]
  br i1 %34, label %._crit_edge1, label %45

45:                                               ; preds = %._crit_edge
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %47)
  %49 = load i32, ptr %11, align 8
  %50 = sext i32 %49 to i64
  %51 = getelementptr ptr, ptr %47, i64 %50
  %52 = getelementptr i8, ptr %51, i64 8
  %53 = load ptr, ptr %52, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call i32 %54(ptr %46) #31
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %47)
  %57 = call i32 %54(ptr %46) #31
  store ptr @String, ptr %4, align 8
  %58 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %59 = extractvalue { i64, i64 } %58, 0
  %60 = call ptr @bump_malloc(i64 %59)
  %61 = load ptr, ptr %9, align 8
  %62 = load ptr, ptr %8, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %62)
  %64 = load i32, ptr %11, align 8
  %65 = sext i32 %64 to i64
  %66 = getelementptr ptr, ptr %62, i64 %65
  %67 = getelementptr i8, ptr %66, i64 8
  %68 = load ptr, ptr %67, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = call i32 %69(ptr %61) #31
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %62)
  %72 = call i32 %69(ptr %61) #31
  %73 = insertvalue { ptr } undef, ptr %23, 0
  %74 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %60, 1
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr undef, 2
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %5, align 8
  %77 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr @_parameterization_i32, ptr %78, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %5)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  store ptr @buffer_typ, ptr %6, align 8
  %81 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr @i32_typ, ptr %82, align 8
  %83 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %76, ptr noundef nonnull align 8 dereferenceable(24) %6)
  call void %83({ ptr, ptr, ptr, i32 } %76, { ptr, ptr, ptr, i32 } %76, ptr nonnull %5, { ptr } %73, i32 %70, i32 %72) #39
  store ptr @String, ptr %7, align 8
  %84 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %60, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %7, i64 16
  %86 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 10, ptr %86, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %87 = load ptr, ptr %7, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %87, 0
  %89 = load ptr, ptr %84, align 8
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, ptr %89, 1
  %91 = load ptr, ptr %85, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } %90, ptr %91, 2
  %93 = load i32, ptr %86, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, i32 %93, 3
  ret { ptr, ptr, ptr, i32 } %94
}

define i32 @String_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  ret i32 %17
}

define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %8 = alloca [1 x ptr], align 8
  store ptr @StringIterator, ptr %8, align 8
  %9 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_StringIterator, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = call ptr @bump_malloc(i64 %10)
  %12 = alloca { ptr, ptr, ptr, i32 }, align 8
  %13 = load ptr, ptr %4, align 8
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds i8, ptr %12, i64 8
  %15 = load ptr, ptr %5, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %12, i64 16
  %17 = load ptr, ptr %6, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %12, i64 24
  %19 = load i32, ptr %7, align 8
  store i32 %19, ptr %18, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %12, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %20 = load ptr, ptr %12, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %14, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %16, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %18, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %11, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr undef, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 10, 3
  %31 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %31)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @StringIterator)
  %34 = alloca { ptr }, align 8
  store ptr %20, ptr %34, align 8
  %35 = call ptr @behavior_wrapper(ptr noundef nonnull @StringIterator_B_init_strString, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 dereferenceable(8) %34)
  call void %35({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %31, { ptr, ptr, ptr, i32 } %27) #39
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @StringIterator, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %11, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 10, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %40 = load ptr, ptr %36, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %40, 0
  %42 = load ptr, ptr %37, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %42, 1
  %44 = load ptr, ptr %38, align 8
  %45 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %44, 2
  %46 = load i32, ptr %39, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %46, 3
  ret { ptr, ptr, ptr, i32 } %47
}

define void @Iterable_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract6, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract7, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract8, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %10 = load ptr, ptr %6, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %10, 0
  %12 = load ptr, ptr %7, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %12, 1
  %14 = load ptr, ptr %8, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %14, 2
  %16 = load i32, ptr %9, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %16, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %10)
  %20 = sext i32 %16 to i64
  %21 = getelementptr ptr, ptr %10, i64 %20
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  %24 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %5)
  %25 = call { ptr, ptr, ptr, i32 } %24({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %5) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 3
  %26 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr %.fca.1.extract, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %26, i64 16
  store ptr %.fca.2.extract, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %26, i64 24
  store i32 %.fca.3.extract, ptr %29, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %26, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %30 = load ptr, ptr %26, align 8
  %31 = load ptr, ptr %27, align 8
  %32 = load ptr, ptr %28, align 8
  %33 = load i32, ptr %29, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %30, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %31, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %32, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %33, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %30)
  %40 = sext i32 %33 to i64
  %41 = getelementptr ptr, ptr %30, i64 %40
  %42 = getelementptr i8, ptr %41, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %43 = load ptr, ptr %42, align 8
  %44 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %37, ptr noundef nonnull align 8 %5)
  %45 = call { ptr, i160 } %44({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull %5) #39
  %.fca.0.extract22 = extractvalue { ptr, i160 } %45, 0
  %46 = load ptr, ptr %7, align 8
  %47 = load ptr, ptr %6, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %47)
  %49 = load i32, ptr %9, align 8
  %50 = sext i32 %49 to i64
  %51 = getelementptr ptr, ptr %47, i64 %50
  %52 = load ptr, ptr %51, align 8
  %53 = call ptr @typegetter_wrapper(ptr %52, ptr %46)
  %54 = icmp ne ptr %.fca.0.extract22, @nil_typ
  %55 = icmp ne ptr %.fca.0.extract22, null
  %.not28 = and i1 %54, %55
  br i1 %.not28, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  call void %.fca.0.extract3({ ptr, i160 } %45)
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1
  ret void
}

define { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) #3 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract13, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract14, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract15, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract16, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract9 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract10 = extractvalue { ptr, i160 } %3, 1
  %.fca.0.extract3 = extractvalue { ptr } %4, 0
  %11 = load ptr, ptr %7, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %11, 0
  %13 = load ptr, ptr %8, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %13, 1
  %15 = load ptr, ptr %9, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %15, 2
  %17 = load i32, ptr %10, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %17, 3
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %11)
  %21 = sext i32 %17 to i64
  %22 = getelementptr ptr, ptr %11, i64 %21
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @behavior_wrapper(ptr %24, { ptr, ptr, ptr, i32 } %18, ptr noundef nonnull align 8 %6)
  %26 = call { ptr, ptr, ptr, i32 } %25({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %6) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %26, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %26, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %26, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %26, 3
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %27, i64 8
  store ptr %.fca.1.extract, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %27, i64 16
  store ptr %.fca.2.extract, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %27, i64 24
  store i32 %.fca.3.extract, ptr %30, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %27, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %31 = load ptr, ptr %27, align 8
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i32, ptr %30, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %32, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %33, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %34, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %31)
  %41 = sext i32 %34 to i64
  %42 = getelementptr ptr, ptr %31, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %5
  %.045 = phi ptr [ %.fca.0.extract9, %5 ], [ %.146, %._crit_edge ]
  %.0 = phi i160 [ %.fca.1.extract10, %5 ], [ %.1, %._crit_edge ]
  %44 = load ptr, ptr %43, align 8
  %45 = call ptr @behavior_wrapper(ptr %44, { ptr, ptr, ptr, i32 } %38, ptr noundef nonnull align 8 %6)
  %46 = call { ptr, i160 } %45({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull %6) #39
  %.fca.0.extract40 = extractvalue { ptr, i160 } %46, 0
  %47 = load ptr, ptr %8, align 8
  %48 = load ptr, ptr %7, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %48)
  %50 = load i32, ptr %10, align 8
  %51 = sext i32 %50 to i64
  %52 = getelementptr ptr, ptr %48, i64 %51
  %53 = load ptr, ptr %52, align 8
  %54 = call ptr @typegetter_wrapper(ptr %53, ptr %47)
  %55 = icmp ne ptr %.fca.0.extract40, @nil_typ
  %56 = icmp ne ptr %.fca.0.extract40, null
  %.not48 = and i1 %55, %56
  br i1 %.not48, label %57, label %._crit_edge

57:                                               ; preds = %._crit_edge1
  %58 = insertvalue { ptr, i160 } undef, ptr %.045, 0
  %59 = insertvalue { ptr, i160 } %58, i160 %.0, 1
  %60 = call { ptr, i160 } %.fca.0.extract3({ ptr, i160 } %59, { ptr, i160 } %46)
  %.fca.0.extract27 = extractvalue { ptr, i160 } %60, 0
  %.fca.1.extract28 = extractvalue { ptr, i160 } %60, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %57, %._crit_edge1
  %.146 = phi ptr [ %.fca.0.extract27, %57 ], [ %.045, %._crit_edge1 ]
  %.1 = phi i160 [ %.fca.1.extract28, %57 ], [ %.0, %._crit_edge1 ]
  br i1 %.not48, label %._crit_edge1, label %61

61:                                               ; preds = %._crit_edge
  %62 = insertvalue { ptr, i160 } undef, ptr %.146, 0
  %63 = insertvalue { ptr, i160 } %62, i160 %.1, 1
  ret { ptr, i160 } %63
}

define noundef i1 @Iterable_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract6, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract7, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract8, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %10 = load ptr, ptr %6, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %10, 0
  %12 = load ptr, ptr %7, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %12, 1
  %14 = load ptr, ptr %8, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %14, 2
  %16 = load i32, ptr %9, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %16, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %10)
  %20 = sext i32 %16 to i64
  %21 = getelementptr ptr, ptr %10, i64 %20
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  %24 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %5)
  %25 = call { ptr, ptr, ptr, i32 } %24({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %5) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 3
  %26 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr %.fca.1.extract, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %26, i64 16
  store ptr %.fca.2.extract, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %26, i64 24
  store i32 %.fca.3.extract, ptr %29, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %26, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %30 = load ptr, ptr %26, align 8
  %31 = load ptr, ptr %27, align 8
  %32 = load ptr, ptr %28, align 8
  %33 = load i32, ptr %29, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %30, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %31, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %32, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %33, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %30)
  %40 = sext i32 %33 to i64
  %41 = getelementptr ptr, ptr %30, i64 %40
  %42 = getelementptr i8, ptr %41, i64 8
  br label %43

43:                                               ; preds = %57, %4
  %44 = load ptr, ptr %42, align 8
  %45 = call ptr @behavior_wrapper(ptr %44, { ptr, ptr, ptr, i32 } %37, ptr noundef nonnull align 8 %5)
  %46 = call { ptr, i160 } %45({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull %5) #39
  %.fca.0.extract25 = extractvalue { ptr, i160 } %46, 0
  %47 = load ptr, ptr %7, align 8
  %48 = load ptr, ptr %6, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %48)
  %50 = load i32, ptr %9, align 8
  %51 = sext i32 %50 to i64
  %52 = getelementptr ptr, ptr %48, i64 %51
  %53 = load ptr, ptr %52, align 8
  %54 = call ptr @typegetter_wrapper(ptr %53, ptr %47)
  %55 = icmp eq ptr %.fca.0.extract25, @nil_typ
  %56 = icmp eq ptr %.fca.0.extract25, null
  %.not28.not = or i1 %55, %56
  br i1 %.not28.not, label %.critedge, label %57

57:                                               ; preds = %43
  %58 = call i1 %.fca.0.extract3({ ptr, i160 } %46)
  br i1 %58, label %43, label %.critedge

.critedge:                                        ; preds = %57, %43
  ret i1 %.not28.not
}

define noundef i1 @Iterable_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract6, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract7, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract8, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %10 = load ptr, ptr %6, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %10, 0
  %12 = load ptr, ptr %7, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %12, 1
  %14 = load ptr, ptr %8, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %14, 2
  %16 = load i32, ptr %9, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %16, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %10)
  %20 = sext i32 %16 to i64
  %21 = getelementptr ptr, ptr %10, i64 %20
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  %24 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %5)
  %25 = call { ptr, ptr, ptr, i32 } %24({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %5) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %25, 3
  %26 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr %.fca.1.extract, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %26, i64 16
  store ptr %.fca.2.extract, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %26, i64 24
  store i32 %.fca.3.extract, ptr %29, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %26, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %30 = load ptr, ptr %26, align 8
  %31 = load ptr, ptr %27, align 8
  %32 = load ptr, ptr %28, align 8
  %33 = load i32, ptr %29, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %30, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %31, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %32, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %33, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %30)
  %40 = sext i32 %33 to i64
  %41 = getelementptr ptr, ptr %30, i64 %40
  %42 = getelementptr i8, ptr %41, i64 8
  br label %43

43:                                               ; preds = %57, %4
  %44 = load ptr, ptr %42, align 8
  %45 = call ptr @behavior_wrapper(ptr %44, { ptr, ptr, ptr, i32 } %37, ptr noundef nonnull align 8 %5)
  %46 = call { ptr, i160 } %45({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull %5) #39
  %.fca.0.extract23 = extractvalue { ptr, i160 } %46, 0
  %47 = load ptr, ptr %7, align 8
  %48 = load ptr, ptr %6, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %48)
  %50 = load i32, ptr %9, align 8
  %51 = sext i32 %50 to i64
  %52 = getelementptr ptr, ptr %48, i64 %51
  %53 = load ptr, ptr %52, align 8
  %54 = call ptr @typegetter_wrapper(ptr %53, ptr %47)
  %55 = icmp ne ptr %.fca.0.extract23, @nil_typ
  %56 = icmp ne ptr %.fca.0.extract23, null
  %.not26 = and i1 %55, %56
  br i1 %.not26, label %57, label %.critedge

57:                                               ; preds = %43
  %58 = call i1 %.fca.0.extract3({ ptr, i160 } %46)
  br i1 %58, label %.critedge, label %43

.critedge:                                        ; preds = %57, %43
  ret i1 %.not26
}

define { ptr, ptr, ptr, i32 } @Collection_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = call ptr @typegetter_wrapper(ptr %14, ptr %8)
  %16 = load ptr, ptr %5, align 8
  %17 = load ptr, ptr %4, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %17)
  %19 = load i32, ptr %7, align 8
  %20 = sext i32 %19 to i64
  %21 = getelementptr ptr, ptr %17, i64 %20
  %22 = load ptr, ptr %21, align 8
  %23 = call ptr @typegetter_wrapper(ptr %22, ptr %16)
  %24 = call ptr @bump_malloc(i64 noundef 32)
  %25 = getelementptr i8, ptr %24, i64 16
  store ptr %23, ptr %25, align 8
  %26 = getelementptr i8, ptr %24, i64 8
  store ptr @_parameterization_i32, ptr %26, align 8
  %27 = getelementptr i8, ptr %24, i64 24
  store ptr null, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %24)
  store ptr @Pair, ptr %24, align 8
  %29 = alloca [3 x ptr], align 8
  store ptr @EnumeratedCollection, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %29, i64 8
  store ptr %15, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %29, i64 16
  store ptr %24, ptr %31, align 8
  %32 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_EnumeratedCollection, ptr noundef nonnull align 8 dereferenceable(24) %29)
  %33 = extractvalue { i64, i64 } %32, 0
  %34 = call ptr @bump_malloc(i64 %33)
  store ptr %15, ptr %34, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %24, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %34)
  %37 = alloca { ptr, ptr, ptr, i32 }, align 8
  %38 = load ptr, ptr %4, align 8
  store ptr %38, ptr %37, align 8
  %39 = getelementptr inbounds i8, ptr %37, i64 8
  %40 = load ptr, ptr %5, align 8
  store ptr %40, ptr %39, align 8
  %41 = getelementptr inbounds i8, ptr %37, i64 16
  %42 = load ptr, ptr %6, align 8
  store ptr %42, ptr %41, align 8
  %43 = getelementptr inbounds i8, ptr %37, i64 24
  %44 = load i32, ptr %7, align 8
  store i32 %44, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %37, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %45 = load ptr, ptr %37, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %45, 0
  %47 = load ptr, ptr %39, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %47, 1
  %49 = load ptr, ptr %41, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 2
  %51 = load i32, ptr %43, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %51, 3
  %53 = insertvalue { ptr, ptr, ptr, i32 } { ptr @EnumeratedCollection, ptr undef, ptr undef, i32 undef }, ptr %34, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr undef, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 10, 3
  %56 = load ptr, ptr %5, align 8
  %57 = load ptr, ptr %4, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %57)
  %59 = load i32, ptr %7, align 8
  %60 = sext i32 %59 to i64
  %61 = getelementptr ptr, ptr %57, i64 %60
  %62 = load ptr, ptr %61, align 8
  %63 = call ptr @typegetter_wrapper(ptr %62, ptr %56)
  %64 = call ptr @bump_malloc(i64 noundef 24)
  %65 = getelementptr i8, ptr %64, i64 8
  store ptr %63, ptr %65, align 8
  %66 = getelementptr i8, ptr %64, i64 16
  store ptr null, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %64)
  store ptr @Collection, ptr %64, align 8
  %68 = alloca [1 x ptr], align 8
  store ptr %64, ptr %68, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %68)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1024) @EnumeratedCollection)
  %71 = alloca { ptr }, align 8
  store ptr %45, ptr %71, align 8
  %72 = call ptr @behavior_wrapper(ptr noundef nonnull @EnumeratedCollection_B_init_collectionCollectionT, { ptr, ptr, ptr, i32 } %55, ptr noundef nonnull align 8 dereferenceable(8) %71)
  call void %72({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull %68, { ptr, ptr, ptr, i32 } %52) #39
  %73 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @EnumeratedCollection, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %73, i64 8
  store ptr %34, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %73, i64 16
  %76 = getelementptr inbounds i8, ptr %73, i64 24
  store i32 10, ptr %76, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %73, ptr noundef nonnull align 8 dereferenceable(56) @Iterable)
  %77 = load ptr, ptr %73, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %77, 0
  %79 = load ptr, ptr %74, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %79, 1
  %81 = load ptr, ptr %75, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %81, 2
  %83 = load i32, ptr %76, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, i32 %83, 3
  ret { ptr, ptr, ptr, i32 } %84
}

define { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readonly %2, { ptr } %3) #3 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract8, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %9)
  %17 = load ptr, ptr %2, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = alloca [3 x ptr], align 8
  store ptr @MappedCollection, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr %16, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %20, i64 16
  store ptr %19, ptr %22, align 8
  %23 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MappedCollection, ptr noundef nonnull align 8 dereferenceable(24) %20)
  %24 = extractvalue { i64, i64 } %23, 0
  %25 = call ptr @bump_malloc(i64 %24)
  store ptr %16, ptr %25, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  store ptr %19, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %25)
  %28 = alloca { ptr, ptr, ptr, i32 }, align 8
  %29 = load ptr, ptr %5, align 8
  store ptr %29, ptr %28, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 8
  %31 = load ptr, ptr %6, align 8
  store ptr %31, ptr %30, align 8
  %32 = getelementptr inbounds i8, ptr %28, i64 16
  %33 = load ptr, ptr %7, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr inbounds i8, ptr %28, i64 24
  %35 = load i32, ptr %8, align 8
  store i32 %35, ptr %34, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %28, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %36 = load ptr, ptr %28, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %38 = load ptr, ptr %30, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 1
  %40 = load ptr, ptr %32, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %40, 2
  %42 = load i32, ptr %34, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %42, 3
  %44 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MappedCollection, ptr undef, ptr undef, i32 undef }, ptr %25, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr undef, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 10, 3
  %47 = load ptr, ptr %6, align 8
  %48 = load ptr, ptr %5, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %48)
  %50 = load i32, ptr %8, align 8
  %51 = sext i32 %50 to i64
  %52 = getelementptr ptr, ptr %48, i64 %51
  %53 = load ptr, ptr %52, align 8
  %54 = call ptr @typegetter_wrapper(ptr %53, ptr %47)
  %55 = call ptr @bump_malloc(i64 noundef 24)
  %56 = getelementptr i8, ptr %55, i64 8
  store ptr %54, ptr %56, align 8
  %57 = getelementptr i8, ptr %55, i64 16
  store ptr null, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %55)
  store ptr @Collection, ptr %55, align 8
  %59 = load ptr, ptr %2, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %6, align 8
  %63 = load ptr, ptr %5, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %63)
  %65 = load i32, ptr %8, align 8
  %66 = sext i32 %65 to i64
  %67 = getelementptr ptr, ptr %63, i64 %66
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %62)
  %70 = call ptr @bump_malloc(i64 noundef 32)
  %71 = getelementptr i8, ptr %70, i64 16
  store ptr %69, ptr %71, align 8
  %72 = getelementptr i8, ptr %70, i64 8
  store ptr %61, ptr %72, align 8
  %73 = getelementptr i8, ptr %70, i64 24
  store ptr null, ptr %73, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %70)
  store ptr @function_typ, ptr %70, align 8
  %75 = alloca [2 x ptr], align 8
  store ptr %55, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %75, i64 8
  store ptr %70, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %75)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1032) @MappedCollection)
  %79 = alloca { ptr, ptr }, align 8
  store ptr %36, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr @function_typ, ptr %80, align 8
  %81 = call ptr @behavior_wrapper(ptr noundef nonnull @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 dereferenceable(16) %79)
  call void %81({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %75, { ptr, ptr, ptr, i32 } %43, { ptr } %3) #39
  %82 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @MappedCollection, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %82, i64 8
  store ptr %25, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %82, i64 16
  %85 = getelementptr inbounds i8, ptr %82, i64 24
  store i32 10, ptr %85, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %82, ptr noundef nonnull align 8 dereferenceable(56) @Iterable)
  %86 = load ptr, ptr %82, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %86, 0
  %88 = load ptr, ptr %83, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %88, 1
  %90 = load ptr, ptr %84, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } %89, ptr %90, 2
  %92 = load i32, ptr %85, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, i32 %92, 3
  ret { ptr, ptr, ptr, i32 } %93
}

define { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readonly %2, { ptr } %3) #3 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract8, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %9)
  %17 = load ptr, ptr %2, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = alloca [3 x ptr], align 8
  store ptr @MapIterable, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr %16, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %20, i64 16
  store ptr %19, ptr %22, align 8
  %23 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MapIterable, ptr noundef nonnull align 8 dereferenceable(24) %20)
  %24 = extractvalue { i64, i64 } %23, 0
  %25 = call ptr @bump_malloc(i64 %24)
  store ptr %16, ptr %25, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  store ptr %19, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %25)
  %28 = alloca { ptr, ptr, ptr, i32 }, align 8
  %29 = load ptr, ptr %5, align 8
  store ptr %29, ptr %28, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 8
  %31 = load ptr, ptr %6, align 8
  store ptr %31, ptr %30, align 8
  %32 = getelementptr inbounds i8, ptr %28, i64 16
  %33 = load ptr, ptr %7, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr inbounds i8, ptr %28, i64 24
  %35 = load i32, ptr %8, align 8
  store i32 %35, ptr %34, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %28, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %36 = load ptr, ptr %28, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %38 = load ptr, ptr %30, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 1
  %40 = load ptr, ptr %32, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %40, 2
  %42 = load i32, ptr %34, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %42, 3
  %44 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterable, ptr undef, ptr undef, i32 undef }, ptr %25, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr undef, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 10, 3
  %47 = load ptr, ptr %6, align 8
  %48 = load ptr, ptr %5, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %48)
  %50 = load i32, ptr %8, align 8
  %51 = sext i32 %50 to i64
  %52 = getelementptr ptr, ptr %48, i64 %51
  %53 = load ptr, ptr %52, align 8
  %54 = call ptr @typegetter_wrapper(ptr %53, ptr %47)
  %55 = call ptr @bump_malloc(i64 noundef 24)
  %56 = getelementptr i8, ptr %55, i64 8
  store ptr %54, ptr %56, align 8
  %57 = getelementptr i8, ptr %55, i64 16
  store ptr null, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %55)
  store ptr @Iterable, ptr %55, align 8
  %59 = load ptr, ptr %2, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %6, align 8
  %63 = load ptr, ptr %5, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %63)
  %65 = load i32, ptr %8, align 8
  %66 = sext i32 %65 to i64
  %67 = getelementptr ptr, ptr %63, i64 %66
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %62)
  %70 = call ptr @bump_malloc(i64 noundef 32)
  %71 = getelementptr i8, ptr %70, i64 16
  store ptr %69, ptr %71, align 8
  %72 = getelementptr i8, ptr %70, i64 8
  store ptr %61, ptr %72, align 8
  %73 = getelementptr i8, ptr %70, i64 24
  store ptr null, ptr %73, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %70)
  store ptr @function_typ, ptr %70, align 8
  %75 = alloca [2 x ptr], align 8
  store ptr %55, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %75, i64 8
  store ptr %70, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %75)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef nonnull align 16 dereferenceable(520) @MapIterable)
  %79 = alloca { ptr, ptr }, align 8
  store ptr %36, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr @function_typ, ptr %80, align 8
  %81 = call ptr @behavior_wrapper(ptr noundef nonnull @MapIterable_B_init_iterableIterableT_fFunctionT_to_U, { ptr, ptr, ptr, i32 } %46, ptr noundef nonnull align 8 dereferenceable(16) %79)
  call void %81({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %75, { ptr, ptr, ptr, i32 } %43, { ptr } %3) #39
  %82 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @MapIterable, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %82, i64 8
  store ptr %25, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %82, i64 16
  %85 = getelementptr inbounds i8, ptr %82, i64 24
  store i32 10, ptr %85, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %82, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %86 = load ptr, ptr %82, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %86, 0
  %88 = load ptr, ptr %83, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %88, 1
  %90 = load ptr, ptr %84, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } %89, ptr %90, 2
  %92 = load i32, ptr %85, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, i32 %92, 3
  ret { ptr, ptr, ptr, i32 } %93
}

define { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract8, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %9)
  %17 = alloca [2 x ptr], align 8
  store ptr @FilterIterable, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %16, ptr %18, align 8
  %19 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_FilterIterable, ptr noundef nonnull align 8 dereferenceable(16) %17)
  %20 = extractvalue { i64, i64 } %19, 0
  %21 = call ptr @bump_malloc(i64 %20)
  store ptr %16, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %23 = alloca { ptr, ptr, ptr, i32 }, align 8
  %24 = load ptr, ptr %5, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr inbounds i8, ptr %23, i64 8
  %26 = load ptr, ptr %6, align 8
  store ptr %26, ptr %25, align 8
  %27 = getelementptr inbounds i8, ptr %23, i64 16
  %28 = load ptr, ptr %7, align 8
  store ptr %28, ptr %27, align 8
  %29 = getelementptr inbounds i8, ptr %23, i64 24
  %30 = load i32, ptr %8, align 8
  store i32 %30, ptr %29, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %23, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %31 = load ptr, ptr %23, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = load ptr, ptr %25, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 1
  %35 = load ptr, ptr %27, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 2
  %37 = load i32, ptr %29, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %37, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterable, ptr undef, ptr undef, i32 undef }, ptr %21, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr undef, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 10, 3
  %42 = load ptr, ptr %6, align 8
  %43 = load ptr, ptr %5, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %43)
  %45 = load i32, ptr %8, align 8
  %46 = sext i32 %45 to i64
  %47 = getelementptr ptr, ptr %43, i64 %46
  %48 = load ptr, ptr %47, align 8
  %49 = call ptr @typegetter_wrapper(ptr %48, ptr %42)
  %50 = call ptr @bump_malloc(i64 noundef 24)
  %51 = getelementptr i8, ptr %50, i64 8
  store ptr %49, ptr %51, align 8
  %52 = getelementptr i8, ptr %50, i64 16
  store ptr null, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %50)
  store ptr @Iterable, ptr %50, align 8
  %54 = load ptr, ptr %6, align 8
  %55 = load ptr, ptr %5, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %55)
  %57 = load i32, ptr %8, align 8
  %58 = sext i32 %57 to i64
  %59 = getelementptr ptr, ptr %55, i64 %58
  %60 = load ptr, ptr %59, align 8
  %61 = call ptr @typegetter_wrapper(ptr %60, ptr %54)
  %62 = call ptr @bump_malloc(i64 noundef 32)
  %63 = getelementptr i8, ptr %62, i64 16
  store ptr %61, ptr %63, align 8
  %64 = getelementptr i8, ptr %62, i64 8
  store ptr @_parameterization_Bool, ptr %64, align 8
  %65 = getelementptr i8, ptr %62, i64 24
  store ptr null, ptr %65, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %62)
  store ptr @function_typ, ptr %62, align 8
  %67 = alloca [2 x ptr], align 8
  store ptr %50, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %62, ptr %68, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %67)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @FilterIterable)
  %71 = alloca { ptr, ptr }, align 8
  store ptr %31, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %71, i64 8
  store ptr @function_typ, ptr %72, align 8
  %73 = call ptr @behavior_wrapper(ptr noundef nonnull @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool, { ptr, ptr, ptr, i32 } %41, ptr noundef nonnull align 8 dereferenceable(16) %71)
  call void %73({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull %67, { ptr, ptr, ptr, i32 } %38, { ptr } %3) #39
  %74 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @FilterIterable, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %74, i64 8
  store ptr %21, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %74, i64 16
  %77 = getelementptr inbounds i8, ptr %74, i64 24
  store i32 10, ptr %77, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %74, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %78 = load ptr, ptr %74, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = load ptr, ptr %75, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 1
  %82 = load ptr, ptr %76, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %82, 2
  %84 = load i32, ptr %77, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %84, 3
  ret { ptr, ptr, ptr, i32 } %85
}

define { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract7, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract8, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract9, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract10, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %13 = load ptr, ptr %6, align 8
  %14 = load ptr, ptr %5, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %8, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @typegetter_wrapper(ptr %19, ptr %13)
  %21 = alloca [2 x ptr], align 8
  store ptr @ChainIterable, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr %20, ptr %22, align 8
  %23 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_ChainIterable, ptr noundef nonnull align 8 dereferenceable(16) %21)
  %24 = extractvalue { i64, i64 } %23, 0
  %25 = call ptr @bump_malloc(i64 %24)
  store ptr %20, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  %28 = load ptr, ptr %5, align 8
  store ptr %28, ptr %27, align 8
  %29 = getelementptr inbounds i8, ptr %27, i64 8
  %30 = load ptr, ptr %6, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr inbounds i8, ptr %27, i64 16
  %32 = load ptr, ptr %7, align 8
  store ptr %32, ptr %31, align 8
  %33 = getelementptr inbounds i8, ptr %27, i64 24
  %34 = load i32, ptr %8, align 8
  store i32 %34, ptr %33, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %27, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %35 = load ptr, ptr %27, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %35, 0
  %37 = load ptr, ptr %29, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %37, 1
  %39 = load ptr, ptr %31, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 2
  %41 = load i32, ptr %33, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %41, 3
  %43 = alloca { ptr, ptr, ptr, i32 }, align 8
  %44 = load ptr, ptr %9, align 8
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 8
  %46 = load ptr, ptr %10, align 8
  store ptr %46, ptr %45, align 8
  %47 = getelementptr inbounds i8, ptr %43, i64 16
  %48 = load ptr, ptr %11, align 8
  store ptr %48, ptr %47, align 8
  %49 = getelementptr inbounds i8, ptr %43, i64 24
  %50 = load i32, ptr %12, align 8
  store i32 %50, ptr %49, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %43, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %51 = load ptr, ptr %43, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %45, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %47, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %49, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterable, ptr undef, ptr undef, i32 undef }, ptr %25, 1
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr undef, 2
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 10, 3
  %62 = load ptr, ptr %6, align 8
  %63 = load ptr, ptr %5, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %63)
  %65 = load i32, ptr %8, align 8
  %66 = sext i32 %65 to i64
  %67 = getelementptr ptr, ptr %63, i64 %66
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %62)
  %70 = call ptr @bump_malloc(i64 noundef 24)
  %71 = getelementptr i8, ptr %70, i64 8
  store ptr %69, ptr %71, align 8
  %72 = getelementptr i8, ptr %70, i64 16
  store ptr null, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %70)
  store ptr @Iterable, ptr %70, align 8
  %74 = load ptr, ptr %6, align 8
  %75 = load ptr, ptr %5, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %75)
  %77 = load i32, ptr %8, align 8
  %78 = sext i32 %77 to i64
  %79 = getelementptr ptr, ptr %75, i64 %78
  %80 = load ptr, ptr %79, align 8
  %81 = call ptr @typegetter_wrapper(ptr %80, ptr %74)
  %82 = call ptr @bump_malloc(i64 noundef 24)
  %83 = getelementptr i8, ptr %82, i64 8
  store ptr %81, ptr %83, align 8
  %84 = getelementptr i8, ptr %82, i64 16
  store ptr null, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  store ptr @Iterable, ptr %82, align 8
  %86 = alloca [2 x ptr], align 8
  store ptr %70, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %86, i64 8
  store ptr %82, ptr %87, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %86)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @ChainIterable)
  %90 = alloca { ptr, ptr }, align 8
  store ptr %35, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %90, i64 8
  store ptr %51, ptr %91, align 8
  %92 = call ptr @behavior_wrapper(ptr noundef nonnull @ChainIterable_B_init_firstIterableT_secondIterableT, { ptr, ptr, ptr, i32 } %61, ptr noundef nonnull align 8 dereferenceable(16) %90)
  call void %92({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull %86, { ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %58) #39
  %93 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ChainIterable, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %93, i64 8
  store ptr %25, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %93, i64 16
  %96 = getelementptr inbounds i8, ptr %93, i64 24
  store i32 10, ptr %96, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %93, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %97 = load ptr, ptr %93, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %94, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %95, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %96, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  ret { ptr, ptr, ptr, i32 } %104
}

define { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract7, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract8, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract9, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract10, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %13 = load ptr, ptr %6, align 8
  %14 = load ptr, ptr %5, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %8, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @typegetter_wrapper(ptr %19, ptr %13)
  %21 = alloca [2 x ptr], align 8
  store ptr @ChainedCollection, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr %20, ptr %22, align 8
  %23 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_ChainedCollection, ptr noundef nonnull align 8 dereferenceable(16) %21)
  %24 = extractvalue { i64, i64 } %23, 0
  %25 = call ptr @bump_malloc(i64 %24)
  store ptr %20, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  %28 = load ptr, ptr %5, align 8
  store ptr %28, ptr %27, align 8
  %29 = getelementptr inbounds i8, ptr %27, i64 8
  %30 = load ptr, ptr %6, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr inbounds i8, ptr %27, i64 16
  %32 = load ptr, ptr %7, align 8
  store ptr %32, ptr %31, align 8
  %33 = getelementptr inbounds i8, ptr %27, i64 24
  %34 = load i32, ptr %8, align 8
  store i32 %34, ptr %33, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %27, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %35 = load ptr, ptr %27, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %35, 0
  %37 = load ptr, ptr %29, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %37, 1
  %39 = load ptr, ptr %31, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 2
  %41 = load i32, ptr %33, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %41, 3
  %43 = alloca { ptr, ptr, ptr, i32 }, align 8
  %44 = load ptr, ptr %9, align 8
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 8
  %46 = load ptr, ptr %10, align 8
  store ptr %46, ptr %45, align 8
  %47 = getelementptr inbounds i8, ptr %43, i64 16
  %48 = load ptr, ptr %11, align 8
  store ptr %48, ptr %47, align 8
  %49 = getelementptr inbounds i8, ptr %43, i64 24
  %50 = load i32, ptr %12, align 8
  store i32 %50, ptr %49, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %43, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %51 = load ptr, ptr %43, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %45, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %47, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %49, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainedCollection, ptr undef, ptr undef, i32 undef }, ptr %25, 1
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr undef, 2
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 10, 3
  %62 = load ptr, ptr %6, align 8
  %63 = load ptr, ptr %5, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %63)
  %65 = load i32, ptr %8, align 8
  %66 = sext i32 %65 to i64
  %67 = getelementptr ptr, ptr %63, i64 %66
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %62)
  %70 = call ptr @bump_malloc(i64 noundef 24)
  %71 = getelementptr i8, ptr %70, i64 8
  store ptr %69, ptr %71, align 8
  %72 = getelementptr i8, ptr %70, i64 16
  store ptr null, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %70)
  store ptr @Collection, ptr %70, align 8
  %74 = load ptr, ptr %6, align 8
  %75 = load ptr, ptr %5, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %75)
  %77 = load i32, ptr %8, align 8
  %78 = sext i32 %77 to i64
  %79 = getelementptr ptr, ptr %75, i64 %78
  %80 = load ptr, ptr %79, align 8
  %81 = call ptr @typegetter_wrapper(ptr %80, ptr %74)
  %82 = call ptr @bump_malloc(i64 noundef 24)
  %83 = getelementptr i8, ptr %82, i64 8
  store ptr %81, ptr %83, align 8
  %84 = getelementptr i8, ptr %82, i64 16
  store ptr null, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  store ptr @Collection, ptr %82, align 8
  %86 = alloca [2 x ptr], align 8
  store ptr %70, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %86, i64 8
  store ptr %82, ptr %87, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %86)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1024) @ChainedCollection)
  %90 = alloca { ptr, ptr }, align 8
  store ptr %35, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %90, i64 8
  store ptr %51, ptr %91, align 8
  %92 = call ptr @behavior_wrapper(ptr noundef nonnull @ChainedCollection_B_init_firstCollectionT_secondCollectionT, { ptr, ptr, ptr, i32 } %61, ptr noundef nonnull align 8 dereferenceable(16) %90)
  call void %92({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull %86, { ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %58) #39
  %93 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ChainedCollection, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %93, i64 8
  store ptr %25, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %93, i64 16
  %96 = getelementptr inbounds i8, ptr %93, i64 24
  store i32 10, ptr %96, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %93, ptr noundef nonnull align 8 dereferenceable(56) @Iterable)
  %97 = load ptr, ptr %93, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %94, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %95, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %96, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  ret { ptr, ptr, ptr, i32 } %104
}

define { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract7, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract8, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract9, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract10, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %13 = load ptr, ptr %6, align 8
  %14 = load ptr, ptr %5, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %8, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @typegetter_wrapper(ptr %19, ptr %13)
  %21 = alloca [2 x ptr], align 8
  store ptr @InterleavedCollection, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr %20, ptr %22, align 8
  %23 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_InterleavedCollection, ptr noundef nonnull align 8 dereferenceable(16) %21)
  %24 = extractvalue { i64, i64 } %23, 0
  %25 = call ptr @bump_malloc(i64 %24)
  store ptr %20, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  %28 = load ptr, ptr %5, align 8
  store ptr %28, ptr %27, align 8
  %29 = getelementptr inbounds i8, ptr %27, i64 8
  %30 = load ptr, ptr %6, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr inbounds i8, ptr %27, i64 16
  %32 = load ptr, ptr %7, align 8
  store ptr %32, ptr %31, align 8
  %33 = getelementptr inbounds i8, ptr %27, i64 24
  %34 = load i32, ptr %8, align 8
  store i32 %34, ptr %33, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %27, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %35 = load ptr, ptr %27, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %35, 0
  %37 = load ptr, ptr %29, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %37, 1
  %39 = load ptr, ptr %31, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 2
  %41 = load i32, ptr %33, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %41, 3
  %43 = alloca { ptr, ptr, ptr, i32 }, align 8
  %44 = load ptr, ptr %9, align 8
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 8
  %46 = load ptr, ptr %10, align 8
  store ptr %46, ptr %45, align 8
  %47 = getelementptr inbounds i8, ptr %43, i64 16
  %48 = load ptr, ptr %11, align 8
  store ptr %48, ptr %47, align 8
  %49 = getelementptr inbounds i8, ptr %43, i64 24
  %50 = load i32, ptr %12, align 8
  store i32 %50, ptr %49, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %43, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %51 = load ptr, ptr %43, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %45, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %47, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %49, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleavedCollection, ptr undef, ptr undef, i32 undef }, ptr %25, 1
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr undef, 2
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 10, 3
  %62 = load ptr, ptr %6, align 8
  %63 = load ptr, ptr %5, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %63)
  %65 = load i32, ptr %8, align 8
  %66 = sext i32 %65 to i64
  %67 = getelementptr ptr, ptr %63, i64 %66
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %62)
  %70 = call ptr @bump_malloc(i64 noundef 24)
  %71 = getelementptr i8, ptr %70, i64 8
  store ptr %69, ptr %71, align 8
  %72 = getelementptr i8, ptr %70, i64 16
  store ptr null, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %70)
  store ptr @Collection, ptr %70, align 8
  %74 = load ptr, ptr %6, align 8
  %75 = load ptr, ptr %5, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %75)
  %77 = load i32, ptr %8, align 8
  %78 = sext i32 %77 to i64
  %79 = getelementptr ptr, ptr %75, i64 %78
  %80 = load ptr, ptr %79, align 8
  %81 = call ptr @typegetter_wrapper(ptr %80, ptr %74)
  %82 = call ptr @bump_malloc(i64 noundef 24)
  %83 = getelementptr i8, ptr %82, i64 8
  store ptr %81, ptr %83, align 8
  %84 = getelementptr i8, ptr %82, i64 16
  store ptr null, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  store ptr @Collection, ptr %82, align 8
  %86 = alloca [2 x ptr], align 8
  store ptr %70, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %86, i64 8
  store ptr %82, ptr %87, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %86)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1024) @InterleavedCollection)
  %90 = alloca { ptr, ptr }, align 8
  store ptr %35, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %90, i64 8
  store ptr %51, ptr %91, align 8
  %92 = call ptr @behavior_wrapper(ptr noundef nonnull @InterleavedCollection_B_init_firstCollectionT_secondCollectionT, { ptr, ptr, ptr, i32 } %61, ptr noundef nonnull align 8 dereferenceable(16) %90)
  call void %92({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull %86, { ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %58) #39
  %93 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @InterleavedCollection, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %93, i64 8
  store ptr %25, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %93, i64 16
  %96 = getelementptr inbounds i8, ptr %93, i64 24
  store i32 10, ptr %96, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %93, ptr noundef nonnull align 8 dereferenceable(56) @Iterable)
  %97 = load ptr, ptr %93, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %94, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %95, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %96, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  ret { ptr, ptr, ptr, i32 } %104
}

define { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract7, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract8, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract9, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract10, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %13 = load ptr, ptr %6, align 8
  %14 = load ptr, ptr %5, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %8, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @typegetter_wrapper(ptr %19, ptr %13)
  %21 = alloca [2 x ptr], align 8
  store ptr @InterleaveIterable, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr %20, ptr %22, align 8
  %23 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_InterleaveIterable, ptr noundef nonnull align 8 dereferenceable(16) %21)
  %24 = extractvalue { i64, i64 } %23, 0
  %25 = call ptr @bump_malloc(i64 %24)
  store ptr %20, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %25)
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  %28 = load ptr, ptr %5, align 8
  store ptr %28, ptr %27, align 8
  %29 = getelementptr inbounds i8, ptr %27, i64 8
  %30 = load ptr, ptr %6, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr inbounds i8, ptr %27, i64 16
  %32 = load ptr, ptr %7, align 8
  store ptr %32, ptr %31, align 8
  %33 = getelementptr inbounds i8, ptr %27, i64 24
  %34 = load i32, ptr %8, align 8
  store i32 %34, ptr %33, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %27, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %35 = load ptr, ptr %27, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %35, 0
  %37 = load ptr, ptr %29, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %37, 1
  %39 = load ptr, ptr %31, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 2
  %41 = load i32, ptr %33, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %41, 3
  %43 = alloca { ptr, ptr, ptr, i32 }, align 8
  %44 = load ptr, ptr %9, align 8
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 8
  %46 = load ptr, ptr %10, align 8
  store ptr %46, ptr %45, align 8
  %47 = getelementptr inbounds i8, ptr %43, i64 16
  %48 = load ptr, ptr %11, align 8
  store ptr %48, ptr %47, align 8
  %49 = getelementptr inbounds i8, ptr %43, i64 24
  %50 = load i32, ptr %12, align 8
  store i32 %50, ptr %49, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %43, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %51 = load ptr, ptr %43, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %45, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %47, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %49, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterable, ptr undef, ptr undef, i32 undef }, ptr %25, 1
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr undef, 2
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 10, 3
  %62 = load ptr, ptr %6, align 8
  %63 = load ptr, ptr %5, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %63)
  %65 = load i32, ptr %8, align 8
  %66 = sext i32 %65 to i64
  %67 = getelementptr ptr, ptr %63, i64 %66
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %62)
  %70 = call ptr @bump_malloc(i64 noundef 24)
  %71 = getelementptr i8, ptr %70, i64 8
  store ptr %69, ptr %71, align 8
  %72 = getelementptr i8, ptr %70, i64 16
  store ptr null, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %70)
  store ptr @Iterable, ptr %70, align 8
  %74 = load ptr, ptr %6, align 8
  %75 = load ptr, ptr %5, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %75)
  %77 = load i32, ptr %8, align 8
  %78 = sext i32 %77 to i64
  %79 = getelementptr ptr, ptr %75, i64 %78
  %80 = load ptr, ptr %79, align 8
  %81 = call ptr @typegetter_wrapper(ptr %80, ptr %74)
  %82 = call ptr @bump_malloc(i64 noundef 24)
  %83 = getelementptr i8, ptr %82, i64 8
  store ptr %81, ptr %83, align 8
  %84 = getelementptr i8, ptr %82, i64 16
  store ptr null, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %82)
  store ptr @Iterable, ptr %82, align 8
  %86 = alloca [2 x ptr], align 8
  store ptr %70, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %86, i64 8
  store ptr %82, ptr %87, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %86)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @InterleaveIterable)
  %90 = alloca { ptr, ptr }, align 8
  store ptr %35, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %90, i64 8
  store ptr %51, ptr %91, align 8
  %92 = call ptr @behavior_wrapper(ptr noundef nonnull @InterleaveIterable_B_init_firstIterableT_secondIterableT, { ptr, ptr, ptr, i32 } %61, ptr noundef nonnull align 8 dereferenceable(16) %90)
  call void %92({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull %86, { ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %58) #39
  %93 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @InterleaveIterable, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %93, i64 8
  store ptr %25, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %93, i64 16
  %96 = getelementptr inbounds i8, ptr %93, i64 24
  store i32 10, ptr %96, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %93, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %97 = load ptr, ptr %93, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %94, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %95, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %96, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  ret { ptr, ptr, ptr, i32 } %104
}

define { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract30, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract31, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract32, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract33, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract23, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract24, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract25, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract26, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %13 = load ptr, ptr %6, align 8
  %14 = load ptr, ptr %5, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %8, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @typegetter_wrapper(ptr %19, ptr %13)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract23)
  %22 = sext i32 %.fca.3.extract26 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract23, i64 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %.fca.1.extract24)
  %26 = load ptr, ptr %6, align 8
  %27 = load ptr, ptr %5, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %27)
  %29 = load i32, ptr %8, align 8
  %30 = sext i32 %29 to i64
  %31 = getelementptr ptr, ptr %27, i64 %30
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %26)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract23)
  %35 = load ptr, ptr %23, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %.fca.1.extract24)
  %37 = call ptr @bump_malloc(i64 noundef 32)
  %38 = getelementptr i8, ptr %37, i64 16
  store ptr %36, ptr %38, align 8
  %39 = getelementptr i8, ptr %37, i64 8
  store ptr %33, ptr %39, align 8
  %40 = getelementptr i8, ptr %37, i64 24
  store ptr null, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %37)
  store ptr @Pair, ptr %37, align 8
  %42 = alloca [4 x ptr], align 8
  store ptr @ZipIterable, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %42, i64 8
  store ptr %20, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  store ptr %25, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %42, i64 24
  store ptr %37, ptr %45, align 8
  %46 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ZipIterable, ptr noundef nonnull align 8 dereferenceable(32) %42)
  %47 = extractvalue { i64, i64 } %46, 0
  %48 = call ptr @bump_malloc(i64 %47)
  store ptr %20, ptr %48, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  store ptr %25, ptr %49, align 8
  %50 = getelementptr i8, ptr %48, i64 16
  store ptr %37, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %48)
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = load ptr, ptr %5, align 8
  store ptr %53, ptr %52, align 8
  %54 = getelementptr inbounds i8, ptr %52, i64 8
  %55 = load ptr, ptr %6, align 8
  store ptr %55, ptr %54, align 8
  %56 = getelementptr inbounds i8, ptr %52, i64 16
  %57 = load ptr, ptr %7, align 8
  store ptr %57, ptr %56, align 8
  %58 = getelementptr inbounds i8, ptr %52, i64 24
  %59 = load i32, ptr %8, align 8
  store i32 %59, ptr %58, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %52, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %60 = load ptr, ptr %52, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %60, 0
  %62 = load ptr, ptr %54, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %62, 1
  %64 = load ptr, ptr %56, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 2
  %66 = load i32, ptr %58, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %66, 3
  %68 = alloca { ptr, ptr, ptr, i32 }, align 8
  %69 = load ptr, ptr %9, align 8
  store ptr %69, ptr %68, align 8
  %70 = getelementptr inbounds i8, ptr %68, i64 8
  %71 = load ptr, ptr %10, align 8
  store ptr %71, ptr %70, align 8
  %72 = getelementptr inbounds i8, ptr %68, i64 16
  %73 = load ptr, ptr %11, align 8
  store ptr %73, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %68, i64 24
  %75 = load i32, ptr %12, align 8
  store i32 %75, ptr %74, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %68, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %76 = load ptr, ptr %68, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %76, 0
  %78 = load ptr, ptr %70, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %78, 1
  %80 = load ptr, ptr %72, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 2
  %82 = load i32, ptr %74, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 %82, 3
  %84 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterable, ptr undef, ptr undef, i32 undef }, ptr %48, 1
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr undef, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 10, 3
  %87 = load ptr, ptr %6, align 8
  %88 = load ptr, ptr %5, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %88)
  %90 = load i32, ptr %8, align 8
  %91 = sext i32 %90 to i64
  %92 = getelementptr ptr, ptr %88, i64 %91
  %93 = load ptr, ptr %92, align 8
  %94 = call ptr @typegetter_wrapper(ptr %93, ptr %87)
  %95 = call ptr @bump_malloc(i64 noundef 24)
  %96 = getelementptr i8, ptr %95, i64 8
  store ptr %94, ptr %96, align 8
  %97 = getelementptr i8, ptr %95, i64 16
  store ptr null, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %95)
  store ptr @Iterable, ptr %95, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract23)
  %100 = load ptr, ptr %23, align 8
  %101 = call ptr @typegetter_wrapper(ptr %100, ptr %.fca.1.extract24)
  %102 = call ptr @bump_malloc(i64 noundef 24)
  %103 = getelementptr i8, ptr %102, i64 8
  store ptr %101, ptr %103, align 8
  %104 = getelementptr i8, ptr %102, i64 16
  store ptr null, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %102)
  store ptr @Iterable, ptr %102, align 8
  %106 = alloca [2 x ptr], align 8
  store ptr %95, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %106, i64 8
  store ptr %102, ptr %107, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %106)
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ZipIterable)
  %110 = alloca { ptr, ptr }, align 8
  store ptr %60, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr %76, ptr %111, align 8
  %112 = call ptr @behavior_wrapper(ptr noundef nonnull @ZipIterable_B_init_firstIterableT_secondIterableU, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(16) %110)
  call void %112({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %106, { ptr, ptr, ptr, i32 } %67, { ptr, ptr, ptr, i32 } %83) #39
  %113 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ZipIterable, ptr %113, align 8
  %114 = getelementptr inbounds i8, ptr %113, i64 8
  store ptr %48, ptr %114, align 8
  %115 = getelementptr inbounds i8, ptr %113, i64 16
  %116 = getelementptr inbounds i8, ptr %113, i64 24
  store i32 10, ptr %116, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %113, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %117 = load ptr, ptr %113, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %117, 0
  %119 = load ptr, ptr %114, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr %119, 1
  %121 = load ptr, ptr %115, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 2
  %123 = load i32, ptr %116, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, i32 %123, 3
  ret { ptr, ptr, ptr, i32 } %124
}

define { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract30, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract31, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract32, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract33, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract23, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract24, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract25, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract26, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %13 = load ptr, ptr %6, align 8
  %14 = load ptr, ptr %5, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %8, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @typegetter_wrapper(ptr %19, ptr %13)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract23)
  %22 = sext i32 %.fca.3.extract26 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract23, i64 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %.fca.1.extract24)
  %26 = load ptr, ptr %6, align 8
  %27 = load ptr, ptr %5, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %27)
  %29 = load i32, ptr %8, align 8
  %30 = sext i32 %29 to i64
  %31 = getelementptr ptr, ptr %27, i64 %30
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %26)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract23)
  %35 = load ptr, ptr %23, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %.fca.1.extract24)
  %37 = call ptr @bump_malloc(i64 noundef 32)
  %38 = getelementptr i8, ptr %37, i64 16
  store ptr %36, ptr %38, align 8
  %39 = getelementptr i8, ptr %37, i64 8
  store ptr %33, ptr %39, align 8
  %40 = getelementptr i8, ptr %37, i64 24
  store ptr null, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %37)
  store ptr @Pair, ptr %37, align 8
  %42 = alloca [4 x ptr], align 8
  store ptr @ZippedCollection, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %42, i64 8
  store ptr %20, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  store ptr %25, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %42, i64 24
  store ptr %37, ptr %45, align 8
  %46 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ZippedCollection, ptr noundef nonnull align 8 dereferenceable(32) %42)
  %47 = extractvalue { i64, i64 } %46, 0
  %48 = call ptr @bump_malloc(i64 %47)
  store ptr %20, ptr %48, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  store ptr %25, ptr %49, align 8
  %50 = getelementptr i8, ptr %48, i64 16
  store ptr %37, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %48)
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = load ptr, ptr %5, align 8
  store ptr %53, ptr %52, align 8
  %54 = getelementptr inbounds i8, ptr %52, i64 8
  %55 = load ptr, ptr %6, align 8
  store ptr %55, ptr %54, align 8
  %56 = getelementptr inbounds i8, ptr %52, i64 16
  %57 = load ptr, ptr %7, align 8
  store ptr %57, ptr %56, align 8
  %58 = getelementptr inbounds i8, ptr %52, i64 24
  %59 = load i32, ptr %8, align 8
  store i32 %59, ptr %58, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %52, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %60 = load ptr, ptr %52, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %60, 0
  %62 = load ptr, ptr %54, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %62, 1
  %64 = load ptr, ptr %56, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 2
  %66 = load i32, ptr %58, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %66, 3
  %68 = alloca { ptr, ptr, ptr, i32 }, align 8
  %69 = load ptr, ptr %9, align 8
  store ptr %69, ptr %68, align 8
  %70 = getelementptr inbounds i8, ptr %68, i64 8
  %71 = load ptr, ptr %10, align 8
  store ptr %71, ptr %70, align 8
  %72 = getelementptr inbounds i8, ptr %68, i64 16
  %73 = load ptr, ptr %11, align 8
  store ptr %73, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %68, i64 24
  %75 = load i32, ptr %12, align 8
  store i32 %75, ptr %74, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %68, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %76 = load ptr, ptr %68, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %76, 0
  %78 = load ptr, ptr %70, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %78, 1
  %80 = load ptr, ptr %72, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 2
  %82 = load i32, ptr %74, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 %82, 3
  %84 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZippedCollection, ptr undef, ptr undef, i32 undef }, ptr %48, 1
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr undef, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 10, 3
  %87 = load ptr, ptr %6, align 8
  %88 = load ptr, ptr %5, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %88)
  %90 = load i32, ptr %8, align 8
  %91 = sext i32 %90 to i64
  %92 = getelementptr ptr, ptr %88, i64 %91
  %93 = load ptr, ptr %92, align 8
  %94 = call ptr @typegetter_wrapper(ptr %93, ptr %87)
  %95 = call ptr @bump_malloc(i64 noundef 24)
  %96 = getelementptr i8, ptr %95, i64 8
  store ptr %94, ptr %96, align 8
  %97 = getelementptr i8, ptr %95, i64 16
  store ptr null, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %95)
  store ptr @Collection, ptr %95, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract23)
  %100 = load ptr, ptr %23, align 8
  %101 = call ptr @typegetter_wrapper(ptr %100, ptr %.fca.1.extract24)
  %102 = call ptr @bump_malloc(i64 noundef 24)
  %103 = getelementptr i8, ptr %102, i64 8
  store ptr %101, ptr %103, align 8
  %104 = getelementptr i8, ptr %102, i64 16
  store ptr null, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %102)
  store ptr @Collection, ptr %102, align 8
  %106 = alloca [2 x ptr], align 8
  store ptr %95, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %106, i64 8
  store ptr %102, ptr %107, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %106)
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1040) @ZippedCollection)
  %110 = alloca { ptr, ptr }, align 8
  store ptr %60, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr %76, ptr %111, align 8
  %112 = call ptr @behavior_wrapper(ptr noundef nonnull @ZippedCollection_B_init_firstCollectionT_secondCollectionU, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(16) %110)
  call void %112({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %106, { ptr, ptr, ptr, i32 } %67, { ptr, ptr, ptr, i32 } %83) #39
  %113 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ZippedCollection, ptr %113, align 8
  %114 = getelementptr inbounds i8, ptr %113, i64 8
  store ptr %48, ptr %114, align 8
  %115 = getelementptr inbounds i8, ptr %113, i64 16
  %116 = getelementptr inbounds i8, ptr %113, i64 24
  store i32 10, ptr %116, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %113, ptr noundef nonnull align 8 dereferenceable(56) @Iterable)
  %117 = load ptr, ptr %113, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %117, 0
  %119 = load ptr, ptr %114, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr %119, 1
  %121 = load ptr, ptr %115, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 2
  %123 = load i32, ptr %116, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, i32 %123, 3
  ret { ptr, ptr, ptr, i32 } %124
}

define { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract30, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract31, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract32, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract33, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract23, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract24, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract25, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract26, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %13 = load ptr, ptr %6, align 8
  %14 = load ptr, ptr %5, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %8, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @typegetter_wrapper(ptr %19, ptr %13)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract23)
  %22 = sext i32 %.fca.3.extract26 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract23, i64 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %.fca.1.extract24)
  %26 = load ptr, ptr %6, align 8
  %27 = load ptr, ptr %5, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %27)
  %29 = load i32, ptr %8, align 8
  %30 = sext i32 %29 to i64
  %31 = getelementptr ptr, ptr %27, i64 %30
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %26)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract23)
  %35 = load ptr, ptr %23, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %.fca.1.extract24)
  %37 = call ptr @bump_malloc(i64 noundef 32)
  %38 = getelementptr i8, ptr %37, i64 16
  store ptr %36, ptr %38, align 8
  %39 = getelementptr i8, ptr %37, i64 8
  store ptr %33, ptr %39, align 8
  %40 = getelementptr i8, ptr %37, i64 24
  store ptr null, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %37)
  store ptr @Pair, ptr %37, align 8
  %42 = alloca [4 x ptr], align 8
  store ptr @ProductIterable, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %42, i64 8
  store ptr %20, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  store ptr %25, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %42, i64 24
  store ptr %37, ptr %45, align 8
  %46 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ProductIterable, ptr noundef nonnull align 8 dereferenceable(32) %42)
  %47 = extractvalue { i64, i64 } %46, 0
  %48 = call ptr @bump_malloc(i64 %47)
  store ptr %20, ptr %48, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  store ptr %25, ptr %49, align 8
  %50 = getelementptr i8, ptr %48, i64 16
  store ptr %37, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %48)
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = load ptr, ptr %5, align 8
  store ptr %53, ptr %52, align 8
  %54 = getelementptr inbounds i8, ptr %52, i64 8
  %55 = load ptr, ptr %6, align 8
  store ptr %55, ptr %54, align 8
  %56 = getelementptr inbounds i8, ptr %52, i64 16
  %57 = load ptr, ptr %7, align 8
  store ptr %57, ptr %56, align 8
  %58 = getelementptr inbounds i8, ptr %52, i64 24
  %59 = load i32, ptr %8, align 8
  store i32 %59, ptr %58, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %52, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %60 = load ptr, ptr %52, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %60, 0
  %62 = load ptr, ptr %54, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %62, 1
  %64 = load ptr, ptr %56, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 2
  %66 = load i32, ptr %58, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %66, 3
  %68 = alloca { ptr, ptr, ptr, i32 }, align 8
  %69 = load ptr, ptr %9, align 8
  store ptr %69, ptr %68, align 8
  %70 = getelementptr inbounds i8, ptr %68, i64 8
  %71 = load ptr, ptr %10, align 8
  store ptr %71, ptr %70, align 8
  %72 = getelementptr inbounds i8, ptr %68, i64 16
  %73 = load ptr, ptr %11, align 8
  store ptr %73, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %68, i64 24
  %75 = load i32, ptr %12, align 8
  store i32 %75, ptr %74, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %68, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %76 = load ptr, ptr %68, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %76, 0
  %78 = load ptr, ptr %70, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %78, 1
  %80 = load ptr, ptr %72, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 2
  %82 = load i32, ptr %74, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 %82, 3
  %84 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterable, ptr undef, ptr undef, i32 undef }, ptr %48, 1
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr undef, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 10, 3
  %87 = load ptr, ptr %6, align 8
  %88 = load ptr, ptr %5, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %88)
  %90 = load i32, ptr %8, align 8
  %91 = sext i32 %90 to i64
  %92 = getelementptr ptr, ptr %88, i64 %91
  %93 = load ptr, ptr %92, align 8
  %94 = call ptr @typegetter_wrapper(ptr %93, ptr %87)
  %95 = call ptr @bump_malloc(i64 noundef 24)
  %96 = getelementptr i8, ptr %95, i64 8
  store ptr %94, ptr %96, align 8
  %97 = getelementptr i8, ptr %95, i64 16
  store ptr null, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %95)
  store ptr @Iterable, ptr %95, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %.fca.0.extract23)
  %100 = load ptr, ptr %23, align 8
  %101 = call ptr @typegetter_wrapper(ptr %100, ptr %.fca.1.extract24)
  %102 = call ptr @bump_malloc(i64 noundef 24)
  %103 = getelementptr i8, ptr %102, i64 8
  store ptr %101, ptr %103, align 8
  %104 = getelementptr i8, ptr %102, i64 16
  store ptr null, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %102)
  store ptr @Iterable, ptr %102, align 8
  %106 = alloca [2 x ptr], align 8
  store ptr %95, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %106, i64 8
  store ptr %102, ptr %107, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %106)
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef nonnull align 16 dereferenceable(528) @ProductIterable)
  %110 = alloca { ptr, ptr }, align 8
  store ptr %60, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr %76, ptr %111, align 8
  %112 = call ptr @behavior_wrapper(ptr noundef nonnull @ProductIterable_B_init_firstIterableT_secondIterableU, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(16) %110)
  call void %112({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %106, { ptr, ptr, ptr, i32 } %67, { ptr, ptr, ptr, i32 } %83) #39
  %113 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ProductIterable, ptr %113, align 8
  %114 = getelementptr inbounds i8, ptr %113, i64 8
  store ptr %48, ptr %114, align 8
  %115 = getelementptr inbounds i8, ptr %113, i64 16
  %116 = getelementptr inbounds i8, ptr %113, i64 24
  store i32 10, ptr %116, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %113, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %117 = load ptr, ptr %113, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %117, 0
  %119 = load ptr, ptr %114, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr %119, 1
  %121 = load ptr, ptr %115, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 2
  %123 = load i32, ptr %116, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, i32 %123, 3
  ret { ptr, ptr, ptr, i32 } %124
}

define { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract30, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract31, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract32, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract33, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract23, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract24, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract25, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract26, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %13 = load ptr, ptr %6, align 8
  %14 = load ptr, ptr %5, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %8, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr @typegetter_wrapper(ptr %19, ptr %13)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract23)
  %22 = sext i32 %.fca.3.extract26 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract23, i64 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %.fca.1.extract24)
  %26 = load ptr, ptr %6, align 8
  %27 = load ptr, ptr %5, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %27)
  %29 = load i32, ptr %8, align 8
  %30 = sext i32 %29 to i64
  %31 = getelementptr ptr, ptr %27, i64 %30
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @typegetter_wrapper(ptr %32, ptr %26)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract23)
  %35 = load ptr, ptr %23, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %.fca.1.extract24)
  %37 = call ptr @bump_malloc(i64 noundef 32)
  %38 = getelementptr i8, ptr %37, i64 16
  store ptr %36, ptr %38, align 8
  %39 = getelementptr i8, ptr %37, i64 8
  store ptr %33, ptr %39, align 8
  %40 = getelementptr i8, ptr %37, i64 24
  store ptr null, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %37)
  store ptr @Pair, ptr %37, align 8
  %42 = alloca [4 x ptr], align 8
  store ptr @ProductCollection, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %42, i64 8
  store ptr %20, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  store ptr %25, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %42, i64 24
  store ptr %37, ptr %45, align 8
  %46 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ProductCollection, ptr noundef nonnull align 8 dereferenceable(32) %42)
  %47 = extractvalue { i64, i64 } %46, 0
  %48 = call ptr @bump_malloc(i64 %47)
  store ptr %20, ptr %48, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  store ptr %25, ptr %49, align 8
  %50 = getelementptr i8, ptr %48, i64 16
  store ptr %37, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %48)
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = load ptr, ptr %5, align 8
  store ptr %53, ptr %52, align 8
  %54 = getelementptr inbounds i8, ptr %52, i64 8
  %55 = load ptr, ptr %6, align 8
  store ptr %55, ptr %54, align 8
  %56 = getelementptr inbounds i8, ptr %52, i64 16
  %57 = load ptr, ptr %7, align 8
  store ptr %57, ptr %56, align 8
  %58 = getelementptr inbounds i8, ptr %52, i64 24
  %59 = load i32, ptr %8, align 8
  store i32 %59, ptr %58, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %52, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %60 = load ptr, ptr %52, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %60, 0
  %62 = load ptr, ptr %54, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %62, 1
  %64 = load ptr, ptr %56, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 2
  %66 = load i32, ptr %58, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %66, 3
  %68 = alloca { ptr, ptr, ptr, i32 }, align 8
  %69 = load ptr, ptr %9, align 8
  store ptr %69, ptr %68, align 8
  %70 = getelementptr inbounds i8, ptr %68, i64 8
  %71 = load ptr, ptr %10, align 8
  store ptr %71, ptr %70, align 8
  %72 = getelementptr inbounds i8, ptr %68, i64 16
  %73 = load ptr, ptr %11, align 8
  store ptr %73, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %68, i64 24
  %75 = load i32, ptr %12, align 8
  store i32 %75, ptr %74, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %68, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %76 = load ptr, ptr %68, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %76, 0
  %78 = load ptr, ptr %70, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %78, 1
  %80 = load ptr, ptr %72, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 2
  %82 = load i32, ptr %74, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 %82, 3
  %84 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductCollection, ptr undef, ptr undef, i32 undef }, ptr %48, 1
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr undef, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 10, 3
  %87 = load ptr, ptr %6, align 8
  %88 = load ptr, ptr %5, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %88)
  %90 = load i32, ptr %8, align 8
  %91 = sext i32 %90 to i64
  %92 = getelementptr ptr, ptr %88, i64 %91
  %93 = load ptr, ptr %92, align 8
  %94 = call ptr @typegetter_wrapper(ptr %93, ptr %87)
  %95 = call ptr @bump_malloc(i64 noundef 24)
  %96 = getelementptr i8, ptr %95, i64 8
  store ptr %94, ptr %96, align 8
  %97 = getelementptr i8, ptr %95, i64 16
  store ptr null, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %95)
  store ptr @Collection, ptr %95, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %.fca.0.extract23)
  %100 = load ptr, ptr %23, align 8
  %101 = call ptr @typegetter_wrapper(ptr %100, ptr %.fca.1.extract24)
  %102 = call ptr @bump_malloc(i64 noundef 24)
  %103 = getelementptr i8, ptr %102, i64 8
  store ptr %101, ptr %103, align 8
  %104 = getelementptr i8, ptr %102, i64 16
  store ptr null, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %102)
  store ptr @Collection, ptr %102, align 8
  %106 = alloca [2 x ptr], align 8
  store ptr %95, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %106, i64 8
  store ptr %102, ptr %107, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %106)
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1040) @ProductCollection)
  %110 = alloca { ptr, ptr }, align 8
  store ptr %60, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr %76, ptr %111, align 8
  %112 = call ptr @behavior_wrapper(ptr noundef nonnull @ProductCollection_B_init_firstCollectionT_secondCollectionU, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(16) %110)
  call void %112({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %106, { ptr, ptr, ptr, i32 } %67, { ptr, ptr, ptr, i32 } %83) #39
  %113 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ProductCollection, ptr %113, align 8
  %114 = getelementptr inbounds i8, ptr %113, i64 8
  store ptr %48, ptr %114, align 8
  %115 = getelementptr inbounds i8, ptr %113, i64 16
  %116 = getelementptr inbounds i8, ptr %113, i64 24
  store i32 10, ptr %116, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %113, ptr noundef nonnull align 8 dereferenceable(56) @Iterable)
  %117 = load ptr, ptr %113, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %117, 0
  %119 = load ptr, ptr %114, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr %119, 1
  %121 = load ptr, ptr %115, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 2
  %123 = load i32, ptr %116, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, i32 %123, 3
  ret { ptr, ptr, ptr, i32 } %124
}

define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %9 = load ptr, ptr %4, align 8
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 8
  %11 = load ptr, ptr %5, align 8
  store ptr %11, ptr %10, align 8
  %12 = getelementptr inbounds i8, ptr %8, i64 16
  %13 = load ptr, ptr %6, align 8
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds i8, ptr %8, i64 24
  %15 = load i32, ptr %7, align 8
  store i32 %15, ptr %14, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %16 = load ptr, ptr %8, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %16, 0
  %18 = load ptr, ptr %10, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %18, 1
  %20 = load ptr, ptr %12, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %20, 2
  %22 = load i32, ptr %14, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %22, 3
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 232
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Container(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductCollection_field_ProductCollection_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Pair, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 264
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [120 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ProductCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 30, %21 ], [ 30, %14 ], [ 31, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [120 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 32, %.critedge ], [ 33, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [120 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 34, %21 ], [ 34, %14 ], [ 35, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [120 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 37, %.critedge ], [ 36, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [120 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define void @ProductCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1040) @ProductCollection)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 32
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define i32 @ProductCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract13, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract15, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract17, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1040) @ProductCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract3, ptr %19, align 8
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep6 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract5, ptr %.fca.1.gep6, align 8
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep8 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract7, ptr %.fca.2.gep8, align 8
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep10 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract9, ptr %.fca.3.gep10, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep6, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep8, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep10, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %36 = load ptr, ptr %6, align 8
  %37 = load ptr, ptr %5, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %37)
  %39 = load i32, ptr %8, align 8
  %40 = sext i32 %39 to i64
  %41 = getelementptr ptr, ptr %37, i64 %40
  %42 = getelementptr i8, ptr %41, i64 32
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %36) #31
  %46 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  store ptr %.fca.0.extract, ptr %46, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %46, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %46, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %46, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %46, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %49 = load ptr, ptr %.fca.1.gep, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 1
  %51 = load ptr, ptr %.fca.2.gep, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %51, 2
  %53 = load i32, ptr %.fca.3.gep, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %53, 3
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %47)
  %57 = sext i32 %53 to i64
  %58 = getelementptr ptr, ptr %47, i64 %57
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = call ptr @behavior_wrapper(ptr %60, { ptr, ptr, ptr, i32 } %54, ptr noundef nonnull align 8 %4)
  %62 = call i32 %61({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull %4) #39
  %63 = mul i32 %62, %35
  ret i32 %63
}

define { ptr, ptr, ptr, i32 } @ProductCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract51, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract53, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract55, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract57, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1040) @ProductCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract43, ptr %19, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep46, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep48, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep50, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract33, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract35, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract37, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 32
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %40) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract23, ptr %50, align 8
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep26 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract25, ptr %.fca.1.gep26, align 8
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep28 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract27, ptr %.fca.2.gep28, align 8
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep30 = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract29, ptr %.fca.3.gep30, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %51 = load ptr, ptr %6, align 8
  %52 = load ptr, ptr %5, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %52)
  %54 = load i32, ptr %8, align 8
  %55 = sext i32 %54 to i64
  %56 = getelementptr ptr, ptr %52, i64 %55
  %57 = load ptr, ptr %56, align 8
  %58 = call ptr @typegetter_wrapper(ptr %57, ptr %51)
  %59 = load ptr, ptr %6, align 8
  %60 = load ptr, ptr %5, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %60)
  %62 = load i32, ptr %8, align 8
  %63 = sext i32 %62 to i64
  %64 = getelementptr ptr, ptr %60, i64 %63
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  %67 = call ptr @typegetter_wrapper(ptr %66, ptr %59)
  %68 = load ptr, ptr %6, align 8
  %69 = load ptr, ptr %5, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %69)
  %71 = load i32, ptr %8, align 8
  %72 = sext i32 %71 to i64
  %73 = getelementptr ptr, ptr %69, i64 %72
  %74 = load ptr, ptr %73, align 8
  %75 = call ptr @typegetter_wrapper(ptr %74, ptr %68)
  %76 = load ptr, ptr %6, align 8
  %77 = load ptr, ptr %5, align 8
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %77)
  %79 = load i32, ptr %8, align 8
  %80 = sext i32 %79 to i64
  %81 = getelementptr ptr, ptr %77, i64 %80
  %82 = getelementptr i8, ptr %81, i64 8
  %83 = load ptr, ptr %82, align 8
  %84 = call ptr @typegetter_wrapper(ptr %83, ptr %76)
  %85 = call ptr @bump_malloc(i64 noundef 32)
  %86 = getelementptr i8, ptr %85, i64 16
  store ptr %84, ptr %86, align 8
  %87 = getelementptr i8, ptr %85, i64 8
  store ptr %75, ptr %87, align 8
  %88 = getelementptr i8, ptr %85, i64 24
  store ptr null, ptr %88, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %85)
  store ptr @Pair, ptr %85, align 8
  %90 = alloca [4 x ptr], align 8
  store ptr @ProductIterator, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %90, i64 8
  store ptr %58, ptr %91, align 8
  %92 = getelementptr inbounds i8, ptr %90, i64 16
  store ptr %67, ptr %92, align 8
  %93 = getelementptr inbounds i8, ptr %90, i64 24
  store ptr %85, ptr %93, align 8
  %94 = load ptr, ptr getelementptr inbounds (i8, ptr @ProductIterator, i64 48), align 8
  %95 = call { i64, i64 } @size_wrapper(ptr %94, ptr noundef nonnull align 8 dereferenceable(32) %90)
  %96 = extractvalue { i64, i64 } %95, 0
  %97 = call ptr @bump_malloc(i64 %96)
  store ptr %58, ptr %97, align 8
  %98 = getelementptr i8, ptr %97, i64 8
  store ptr %67, ptr %98, align 8
  %99 = getelementptr i8, ptr %97, i64 16
  store ptr %85, ptr %99, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %97)
  %101 = load ptr, ptr %6, align 8
  %102 = load ptr, ptr %5, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %102)
  %104 = load i32, ptr %8, align 8
  %105 = sext i32 %104 to i64
  %106 = getelementptr ptr, ptr %102, i64 %105
  %107 = getelementptr i8, ptr %106, i64 24
  %108 = load ptr, ptr %107, align 8
  %109 = load ptr, ptr %108, align 8
  %110 = call { ptr, ptr, ptr, i32 } %109(ptr %101) #31
  %111 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %110, 0
  store ptr %.fca.0.extract9, ptr %111, align 8
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %110, 1
  %.fca.1.gep12 = getelementptr inbounds i8, ptr %111, i64 8
  store ptr %.fca.1.extract11, ptr %.fca.1.gep12, align 8
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %110, 2
  %.fca.2.gep14 = getelementptr inbounds i8, ptr %111, i64 16
  store ptr %.fca.2.extract13, ptr %.fca.2.gep14, align 8
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %110, 3
  %.fca.3.gep16 = getelementptr inbounds i8, ptr %111, i64 24
  store i32 %.fca.3.extract15, ptr %.fca.3.gep16, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %111, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %112 = load ptr, ptr %111, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %112, 0
  %114 = load ptr, ptr %.fca.1.gep12, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %114, 1
  %116 = load ptr, ptr %.fca.2.gep14, align 8
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %116, 2
  %118 = load i32, ptr %.fca.3.gep16, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } %117, i32 %118, 3
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %112)
  %122 = sext i32 %118 to i64
  %123 = getelementptr ptr, ptr %112, i64 %122
  %124 = getelementptr i8, ptr %123, i64 16
  %125 = load ptr, ptr %124, align 8
  %126 = call ptr @behavior_wrapper(ptr %125, { ptr, ptr, ptr, i32 } %119, ptr noundef nonnull align 8 %4)
  %127 = call { ptr, ptr, ptr, i32 } %126({ ptr, ptr, ptr, i32 } %119, { ptr, ptr, ptr, i32 } %119, ptr nonnull %4) #39
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %127, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %127, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %127, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %127, 3
  %128 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %128, align 8
  %129 = getelementptr inbounds i8, ptr %128, i64 8
  store ptr %.fca.1.extract3, ptr %129, align 8
  %130 = getelementptr inbounds i8, ptr %128, i64 16
  store ptr %.fca.2.extract5, ptr %130, align 8
  %131 = getelementptr inbounds i8, ptr %128, i64 24
  store i32 %.fca.3.extract7, ptr %131, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %128, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %132 = load ptr, ptr %6, align 8
  %133 = load ptr, ptr %5, align 8
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %133)
  %135 = load i32, ptr %8, align 8
  %136 = sext i32 %135 to i64
  %137 = getelementptr ptr, ptr %133, i64 %136
  %138 = getelementptr i8, ptr %137, i64 32
  %139 = load ptr, ptr %138, align 8
  %140 = load ptr, ptr %139, align 8
  %141 = call { ptr, ptr, ptr, i32 } %140(ptr %132) #31
  %142 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 0
  store ptr %.fca.0.extract, ptr %142, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %142, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %142, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %141, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %142, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %142, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  %144 = load ptr, ptr %128, align 8
  store ptr %144, ptr %143, align 8
  %145 = getelementptr inbounds i8, ptr %143, i64 8
  %146 = load ptr, ptr %129, align 8
  store ptr %146, ptr %145, align 8
  %147 = getelementptr inbounds i8, ptr %143, i64 16
  %148 = load ptr, ptr %130, align 8
  store ptr %148, ptr %147, align 8
  %149 = getelementptr inbounds i8, ptr %143, i64 24
  %150 = load i32, ptr %131, align 8
  store i32 %150, ptr %149, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %143, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %151 = load ptr, ptr %143, align 8
  %152 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %151, 0
  %153 = load ptr, ptr %145, align 8
  %154 = insertvalue { ptr, ptr, ptr, i32 } %152, ptr %153, 1
  %155 = load ptr, ptr %147, align 8
  %156 = insertvalue { ptr, ptr, ptr, i32 } %154, ptr %155, 2
  %157 = load i32, ptr %149, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } %156, i32 %157, 3
  %159 = alloca { ptr, ptr, ptr, i32 }, align 8
  %160 = load ptr, ptr %142, align 8
  store ptr %160, ptr %159, align 8
  %161 = getelementptr inbounds i8, ptr %159, i64 8
  %162 = load ptr, ptr %.fca.1.gep, align 8
  store ptr %162, ptr %161, align 8
  %163 = getelementptr inbounds i8, ptr %159, i64 16
  %164 = load ptr, ptr %.fca.2.gep, align 8
  store ptr %164, ptr %163, align 8
  %165 = getelementptr inbounds i8, ptr %159, i64 24
  %166 = load i32, ptr %.fca.3.gep, align 8
  store i32 %166, ptr %165, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %159, ptr noundef nonnull align 8 dereferenceable(56) @Iterable)
  %167 = load ptr, ptr %159, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %167, 0
  %169 = load ptr, ptr %161, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %169, 1
  %171 = load ptr, ptr %163, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, ptr %171, 2
  %173 = load i32, ptr %165, align 8
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, i32 %173, 3
  %175 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %97, 1
  %176 = insertvalue { ptr, ptr, ptr, i32 } %175, ptr undef, 2
  %177 = insertvalue { ptr, ptr, ptr, i32 } %176, i32 10, 3
  %178 = load ptr, ptr %6, align 8
  %179 = load ptr, ptr %5, align 8
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %179)
  %181 = load i32, ptr %8, align 8
  %182 = sext i32 %181 to i64
  %183 = getelementptr ptr, ptr %179, i64 %182
  %184 = load ptr, ptr %183, align 8
  %185 = call ptr @typegetter_wrapper(ptr %184, ptr %178)
  %186 = call ptr @bump_malloc(i64 noundef 24)
  %187 = getelementptr i8, ptr %186, i64 8
  store ptr %185, ptr %187, align 8
  %188 = getelementptr i8, ptr %186, i64 16
  store ptr null, ptr %188, align 8
  %189 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %186)
  store ptr @Iterator, ptr %186, align 8
  %190 = load ptr, ptr %6, align 8
  %191 = load ptr, ptr %5, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %191)
  %193 = load i32, ptr %8, align 8
  %194 = sext i32 %193 to i64
  %195 = getelementptr ptr, ptr %191, i64 %194
  %196 = getelementptr i8, ptr %195, i64 8
  %197 = load ptr, ptr %196, align 8
  %198 = call ptr @typegetter_wrapper(ptr %197, ptr %190)
  %199 = call ptr @bump_malloc(i64 noundef 24)
  %200 = getelementptr i8, ptr %199, i64 8
  store ptr %198, ptr %200, align 8
  %201 = getelementptr i8, ptr %199, i64 16
  store ptr null, ptr %201, align 8
  %202 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %199)
  store ptr @Collection, ptr %199, align 8
  %203 = alloca [2 x ptr], align 8
  store ptr %186, ptr %203, align 8
  %204 = getelementptr inbounds i8, ptr %203, i64 8
  store ptr %199, ptr %204, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %203)
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 8 dereferenceable(168) @ProductIterator)
  %207 = load ptr, ptr getelementptr inbounds (i8, ptr @ProductIterator, i64 136), align 8
  %208 = alloca { ptr, ptr }, align 8
  store ptr %151, ptr %208, align 8
  %209 = getelementptr inbounds i8, ptr %208, i64 8
  store ptr %167, ptr %209, align 8
  %210 = call ptr @behavior_wrapper(ptr %207, { ptr, ptr, ptr, i32 } %177, ptr noundef nonnull align 8 dereferenceable(16) %208)
  call void %210({ ptr, ptr, ptr, i32 } %177, { ptr, ptr, ptr, i32 } %177, ptr nonnull %203, { ptr, ptr, ptr, i32 } %158, { ptr, ptr, ptr, i32 } %174) #39
  %211 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ProductIterator, ptr %211, align 8
  %212 = getelementptr inbounds i8, ptr %211, i64 8
  store ptr %97, ptr %212, align 8
  %213 = getelementptr inbounds i8, ptr %211, i64 16
  %214 = getelementptr inbounds i8, ptr %211, i64 24
  store i32 10, ptr %214, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %211, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %215 = load ptr, ptr %211, align 8
  %216 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %215, 0
  %217 = load ptr, ptr %212, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } %216, ptr %217, 1
  %219 = load ptr, ptr %213, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %219, 2
  %221 = load i32, ptr %214, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, i32 %221, 3
  ret { ptr, ptr, ptr, i32 } %222
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 152, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 152
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract51 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract45, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract47, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract49, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract51, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract39 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract33, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %.fca.1.extract35, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr %.fca.2.extract37, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %11, i64 24
  store i32 %.fca.3.extract39, ptr %14, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %11, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  %16 = load ptr, ptr %11, align 8
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds i8, ptr %15, i64 8
  %18 = load ptr, ptr %12, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds i8, ptr %15, i64 16
  %20 = load ptr, ptr %13, align 8
  store ptr %20, ptr %19, align 8
  %21 = getelementptr inbounds i8, ptr %15, i64 24
  %22 = load i32, ptr %14, align 8
  store i32 %22, ptr %21, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %15, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %23 = load ptr, ptr %8, align 8
  %24 = load ptr, ptr %7, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %24)
  %26 = load i32, ptr %10, align 8
  %27 = sext i32 %26 to i64
  %28 = getelementptr ptr, ptr %24, i64 %27
  %29 = getelementptr i8, ptr %28, i64 24
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %15, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %33, 0
  %35 = load ptr, ptr %17, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 1
  %37 = load ptr, ptr %19, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %37, 2
  %39 = load i32, ptr %21, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %39, 3
  call void %32(ptr %23, { ptr, ptr, ptr, i32 } %40) #30
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %41 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract21, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %41, i64 8
  store ptr %.fca.1.extract23, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %41, i64 16
  store ptr %.fca.2.extract25, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %41, i64 24
  store i32 %.fca.3.extract27, ptr %44, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %41, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %45 = alloca { ptr, ptr, ptr, i32 }, align 8
  %46 = load ptr, ptr %41, align 8
  store ptr %46, ptr %45, align 8
  %47 = getelementptr inbounds i8, ptr %45, i64 8
  %48 = load ptr, ptr %42, align 8
  store ptr %48, ptr %47, align 8
  %49 = getelementptr inbounds i8, ptr %45, i64 16
  %50 = load ptr, ptr %43, align 8
  store ptr %50, ptr %49, align 8
  %51 = getelementptr inbounds i8, ptr %45, i64 24
  %52 = load i32, ptr %44, align 8
  store i32 %52, ptr %51, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %45, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %53 = load ptr, ptr %8, align 8
  %54 = load ptr, ptr %7, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %54)
  %56 = load i32, ptr %10, align 8
  %57 = sext i32 %56 to i64
  %58 = getelementptr ptr, ptr %54, i64 %57
  %59 = getelementptr i8, ptr %58, i64 40
  %60 = load ptr, ptr %59, align 8
  %61 = getelementptr i8, ptr %60, i64 8
  %62 = load ptr, ptr %61, align 8
  %63 = load ptr, ptr %45, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %63, 0
  %65 = load ptr, ptr %47, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %65, 1
  %67 = load ptr, ptr %49, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 2
  %69 = load i32, ptr %51, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 %69, 3
  call void %62(ptr %53, { ptr, ptr, ptr, i32 } %70) #30
  %71 = load ptr, ptr %8, align 8
  %72 = load ptr, ptr %7, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %10, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = getelementptr i8, ptr %76, i64 40
  %78 = load ptr, ptr %77, align 8
  %79 = load ptr, ptr %78, align 8
  %80 = call { ptr, ptr, ptr, i32 } %79(ptr %71) #31
  %81 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %80, 0
  store ptr %.fca.0.extract13, ptr %81, align 8
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %80, 1
  %.fca.1.gep16 = getelementptr inbounds i8, ptr %81, i64 8
  store ptr %.fca.1.extract15, ptr %.fca.1.gep16, align 8
  %.fca.2.extract17 = extractvalue { ptr, ptr, ptr, i32 } %80, 2
  %.fca.2.gep18 = getelementptr inbounds i8, ptr %81, i64 16
  store ptr %.fca.2.extract17, ptr %.fca.2.gep18, align 8
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %80, 3
  %.fca.3.gep20 = getelementptr inbounds i8, ptr %81, i64 24
  store i32 %.fca.3.extract19, ptr %.fca.3.gep20, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %81, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %82 = load ptr, ptr %81, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %82, 0
  %84 = load ptr, ptr %.fca.1.gep16, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %84, 1
  %86 = load ptr, ptr %.fca.2.gep18, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %85, ptr %86, 2
  %88 = load i32, ptr %.fca.3.gep20, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, i32 %88, 3
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %82)
  %92 = sext i32 %88 to i64
  %93 = getelementptr ptr, ptr %82, i64 %92
  %94 = getelementptr i8, ptr %93, i64 8
  %95 = load ptr, ptr %94, align 8
  %96 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %89, ptr noundef nonnull align 8 %6)
  %97 = call { ptr, ptr, ptr, i32 } %96({ ptr, ptr, ptr, i32 } %89, { ptr, ptr, ptr, i32 } %89, ptr nonnull align 8 %6) #39
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %97, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %97, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %97, 2
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %97, 3
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %98, align 8
  %99 = getelementptr inbounds i8, ptr %98, i64 8
  store ptr %.fca.1.extract5, ptr %99, align 8
  %100 = getelementptr inbounds i8, ptr %98, i64 16
  store ptr %.fca.2.extract7, ptr %100, align 8
  %101 = getelementptr inbounds i8, ptr %98, i64 24
  store i32 %.fca.3.extract9, ptr %101, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %98, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %102 = alloca { ptr, ptr, ptr, i32 }, align 8
  %103 = load ptr, ptr %98, align 8
  store ptr %103, ptr %102, align 8
  %104 = getelementptr inbounds i8, ptr %102, i64 8
  %105 = load ptr, ptr %99, align 8
  store ptr %105, ptr %104, align 8
  %106 = getelementptr inbounds i8, ptr %102, i64 16
  %107 = load ptr, ptr %100, align 8
  store ptr %107, ptr %106, align 8
  %108 = getelementptr inbounds i8, ptr %102, i64 24
  %109 = load i32, ptr %101, align 8
  store i32 %109, ptr %108, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %102, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %110 = load ptr, ptr %8, align 8
  %111 = load ptr, ptr %7, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %111)
  %113 = load i32, ptr %10, align 8
  %114 = sext i32 %113 to i64
  %115 = getelementptr ptr, ptr %111, i64 %114
  %116 = getelementptr i8, ptr %115, i64 32
  %117 = load ptr, ptr %116, align 8
  %118 = getelementptr i8, ptr %117, i64 8
  %119 = load ptr, ptr %118, align 8
  %120 = load ptr, ptr %102, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %120, 0
  %122 = load ptr, ptr %104, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } %121, ptr %122, 1
  %124 = load ptr, ptr %106, align 8
  %125 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %124, 2
  %126 = load i32, ptr %108, align 8
  %127 = insertvalue { ptr, ptr, ptr, i32 } %125, i32 %126, 3
  call void %119(ptr %110, { ptr, ptr, ptr, i32 } %127) #30
  %128 = load ptr, ptr %8, align 8
  %129 = load ptr, ptr %7, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %129)
  %131 = load i32, ptr %10, align 8
  %132 = sext i32 %131 to i64
  %133 = getelementptr ptr, ptr %129, i64 %132
  %134 = getelementptr i8, ptr %133, i64 24
  %135 = load ptr, ptr %134, align 8
  %136 = load ptr, ptr %135, align 8
  %137 = call { ptr, ptr, ptr, i32 } %136(ptr %128) #31
  %138 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %137, 0
  store ptr %.fca.0.extract1, ptr %138, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %137, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %138, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %137, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %138, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %137, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %138, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %138, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %139 = load ptr, ptr %138, align 8
  %140 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %139, 0
  %141 = load ptr, ptr %.fca.1.gep, align 8
  %142 = insertvalue { ptr, ptr, ptr, i32 } %140, ptr %141, 1
  %143 = load ptr, ptr %.fca.2.gep, align 8
  %144 = insertvalue { ptr, ptr, ptr, i32 } %142, ptr %143, 2
  %145 = load i32, ptr %.fca.3.gep, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } %144, i32 %145, 3
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %139)
  %149 = sext i32 %145 to i64
  %150 = getelementptr ptr, ptr %139, i64 %149
  %151 = getelementptr i8, ptr %150, i64 8
  %152 = load ptr, ptr %151, align 8
  %153 = call ptr @behavior_wrapper(ptr %152, { ptr, ptr, ptr, i32 } %146, ptr noundef nonnull align 8 %6)
  %154 = call { ptr, i160 } %153({ ptr, ptr, ptr, i32 } %146, { ptr, ptr, ptr, i32 } %146, ptr nonnull %6) #39
  %155 = load ptr, ptr %8, align 8
  %156 = load ptr, ptr %7, align 8
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %156)
  %158 = load i32, ptr %10, align 8
  %159 = sext i32 %158 to i64
  %160 = getelementptr ptr, ptr %156, i64 %159
  %161 = getelementptr i8, ptr %160, i64 48
  %162 = load ptr, ptr %161, align 8
  %163 = getelementptr i8, ptr %162, i64 8
  %164 = load ptr, ptr %163, align 8
  call void %164(ptr %155, { ptr, i160 } %154) #30
  ret void
}

define { ptr, i160 } @ProductIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca [3 x ptr], align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  %12 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract7, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract8, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %16, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %17 = load ptr, ptr %14, align 8
  %18 = load ptr, ptr %13, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %18)
  %20 = load i32, ptr %16, align 8
  %21 = sext i32 %20 to i64
  %22 = getelementptr ptr, ptr %18, i64 %21
  %23 = getelementptr i8, ptr %22, i64 48
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr, i160 } %25(ptr %17) #31
  %.fca.0.extract = extractvalue { ptr, i160 } %26, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %26, 1
  %.fca.1.gep66 = getelementptr inbounds i8, ptr %5, i64 8
  %.fca.2.gep68 = getelementptr inbounds i8, ptr %5, i64 16
  %.fca.3.gep70 = getelementptr inbounds i8, ptr %5, i64 24
  %.fca.1.gep40 = getelementptr inbounds i8, ptr %9, i64 8
  %.fca.2.gep42 = getelementptr inbounds i8, ptr %9, i64 16
  %.fca.3.gep44 = getelementptr inbounds i8, ptr %9, i64 24
  %.fca.1.gep = getelementptr inbounds i8, ptr %10, i64 8
  %.fca.2.gep = getelementptr inbounds i8, ptr %10, i64 16
  %.fca.3.gep = getelementptr inbounds i8, ptr %10, i64 24
  %27 = getelementptr inbounds i8, ptr %11, i64 8
  %28 = getelementptr inbounds i8, ptr %11, i64 16
  %29 = getelementptr inbounds i8, ptr %11, i64 24
  %30 = getelementptr inbounds i8, ptr %12, i64 8
  %31 = getelementptr inbounds i8, ptr %12, i64 16
  %32 = getelementptr inbounds i8, ptr %12, i64 24
  br label %33

33:                                               ; preds = %177, %3
  %.sroa.060.0 = phi ptr [ undef, %3 ], [ %.sroa.060.1, %177 ]
  %.sroa.362.0 = phi i160 [ undef, %3 ], [ %.sroa.362.1, %177 ]
  %.079 = phi ptr [ undef, %3 ], [ %.180, %177 ]
  %.077 = phi i160 [ undef, %3 ], [ %.178, %177 ]
  %.074 = phi i160 [ %.fca.1.extract, %3 ], [ %.276, %177 ]
  %.0 = phi ptr [ %.fca.0.extract, %3 ], [ %.2, %177 ]
  %34 = load ptr, ptr %14, align 8
  %35 = load ptr, ptr %13, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %35)
  %37 = load i32, ptr %16, align 8
  %38 = sext i32 %37 to i64
  %39 = getelementptr ptr, ptr %35, i64 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %34)
  %42 = icmp ne ptr %.0, @nil_typ
  %43 = icmp ne ptr %.0, null
  %.not82 = and i1 %42, %43
  br i1 %.not82, label %44, label %177

44:                                               ; preds = %33
  %45 = load ptr, ptr %14, align 8
  %46 = load ptr, ptr %13, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %46)
  %48 = load i32, ptr %16, align 8
  %49 = sext i32 %48 to i64
  %50 = getelementptr ptr, ptr %46, i64 %49
  %51 = getelementptr i8, ptr %50, i64 32
  %52 = load ptr, ptr %51, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %45) #31
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  store ptr %.fca.0.extract63, ptr %5, align 8
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  store ptr %.fca.1.extract65, ptr %.fca.1.gep66, align 8
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  store ptr %.fca.2.extract67, ptr %.fca.2.gep68, align 8
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  store i32 %.fca.3.extract69, ptr %.fca.3.gep70, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %55 = load ptr, ptr %5, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %.fca.1.gep66, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %.fca.2.gep68, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %.fca.3.gep70, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %55)
  %65 = sext i32 %61 to i64
  %66 = getelementptr ptr, ptr %55, i64 %65
  %67 = getelementptr i8, ptr %66, i64 8
  %68 = load ptr, ptr %67, align 8
  %69 = call ptr @behavior_wrapper(ptr %68, { ptr, ptr, ptr, i32 } %62, ptr noundef nonnull align 8 %4)
  %70 = call { ptr, i160 } %69({ ptr, ptr, ptr, i32 } %62, { ptr, ptr, ptr, i32 } %62, ptr nonnull align 8 %4) #39
  %.fca.0.extract56 = extractvalue { ptr, i160 } %70, 0
  %.fca.1.extract58 = extractvalue { ptr, i160 } %70, 1
  %71 = load ptr, ptr %14, align 8
  %72 = load ptr, ptr %13, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %16, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = getelementptr i8, ptr %76, i64 8
  %78 = load ptr, ptr %77, align 8
  %79 = call ptr @typegetter_wrapper(ptr %78, ptr %71)
  %80 = icmp eq ptr %.fca.0.extract56, @nil_typ
  %81 = icmp eq ptr %.fca.0.extract56, null
  %.not84.not = or i1 %80, %81
  br i1 %.not84.not, label %82, label %177

82:                                               ; preds = %44
  %83 = load ptr, ptr %14, align 8
  %84 = load ptr, ptr %13, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %84)
  %86 = load i32, ptr %16, align 8
  %87 = sext i32 %86 to i64
  %88 = getelementptr ptr, ptr %84, i64 %87
  %89 = getelementptr i8, ptr %88, i64 24
  %90 = load ptr, ptr %89, align 8
  %91 = load ptr, ptr %90, align 8
  %92 = call { ptr, ptr, ptr, i32 } %91(ptr %83) #31
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %92, 0
  store ptr %.fca.0.extract37, ptr %9, align 8
  %.fca.1.extract39 = extractvalue { ptr, ptr, ptr, i32 } %92, 1
  store ptr %.fca.1.extract39, ptr %.fca.1.gep40, align 8
  %.fca.2.extract41 = extractvalue { ptr, ptr, ptr, i32 } %92, 2
  store ptr %.fca.2.extract41, ptr %.fca.2.gep42, align 8
  %.fca.3.extract43 = extractvalue { ptr, ptr, ptr, i32 } %92, 3
  store i32 %.fca.3.extract43, ptr %.fca.3.gep44, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %93 = load ptr, ptr %9, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %93, 0
  %95 = load ptr, ptr %.fca.1.gep40, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 1
  %97 = load ptr, ptr %.fca.2.gep42, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %97, 2
  %99 = load i32, ptr %.fca.3.gep44, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, i32 %99, 3
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %93)
  %103 = sext i32 %99 to i64
  %104 = getelementptr ptr, ptr %93, i64 %103
  %105 = getelementptr i8, ptr %104, i64 8
  %106 = load ptr, ptr %105, align 8
  %107 = call ptr @behavior_wrapper(ptr %106, { ptr, ptr, ptr, i32 } %100, ptr noundef nonnull align 8 %4)
  %108 = call { ptr, i160 } %107({ ptr, ptr, ptr, i32 } %100, { ptr, ptr, ptr, i32 } %100, ptr nonnull align 8 %4) #39
  %109 = load ptr, ptr %14, align 8
  %110 = load ptr, ptr %13, align 8
  %111 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %110)
  %112 = load i32, ptr %16, align 8
  %113 = sext i32 %112 to i64
  %114 = getelementptr ptr, ptr %110, i64 %113
  %115 = getelementptr i8, ptr %114, i64 48
  %116 = load ptr, ptr %115, align 8
  %117 = getelementptr i8, ptr %116, i64 8
  %118 = load ptr, ptr %117, align 8
  call void %118(ptr %109, { ptr, i160 } %108) #30
  %119 = load ptr, ptr %14, align 8
  %120 = load ptr, ptr %13, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %120)
  %122 = load i32, ptr %16, align 8
  %123 = sext i32 %122 to i64
  %124 = getelementptr ptr, ptr %120, i64 %123
  %125 = getelementptr i8, ptr %124, i64 40
  %126 = load ptr, ptr %125, align 8
  %127 = load ptr, ptr %126, align 8
  %128 = call { ptr, ptr, ptr, i32 } %127(ptr %119) #31
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %128, 0
  store ptr %.fca.0.extract27, ptr %10, align 8
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %128, 1
  store ptr %.fca.1.extract28, ptr %.fca.1.gep, align 8
  %.fca.2.extract29 = extractvalue { ptr, ptr, ptr, i32 } %128, 2
  store ptr %.fca.2.extract29, ptr %.fca.2.gep, align 8
  %.fca.3.extract30 = extractvalue { ptr, ptr, ptr, i32 } %128, 3
  store i32 %.fca.3.extract30, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %129 = load ptr, ptr %10, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %129, 0
  %131 = load ptr, ptr %.fca.1.gep, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 1
  %133 = load ptr, ptr %.fca.2.gep, align 8
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr %133, 2
  %135 = load i32, ptr %.fca.3.gep, align 8
  %136 = insertvalue { ptr, ptr, ptr, i32 } %134, i32 %135, 3
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %129)
  %139 = sext i32 %135 to i64
  %140 = getelementptr ptr, ptr %129, i64 %139
  %141 = getelementptr i8, ptr %140, i64 8
  %142 = load ptr, ptr %141, align 8
  %143 = call ptr @behavior_wrapper(ptr %142, { ptr, ptr, ptr, i32 } %136, ptr noundef nonnull align 8 %4)
  %144 = call { ptr, ptr, ptr, i32 } %143({ ptr, ptr, ptr, i32 } %136, { ptr, ptr, ptr, i32 } %136, ptr nonnull %4) #39
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %144, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %144, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %144, 2
  %.fca.3.extract22 = extractvalue { ptr, ptr, ptr, i32 } %144, 3
  store ptr %.fca.0.extract19, ptr %11, align 8
  store ptr %.fca.1.extract20, ptr %27, align 8
  store ptr %.fca.2.extract21, ptr %28, align 8
  store i32 %.fca.3.extract22, ptr %29, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %11, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %145 = load ptr, ptr %11, align 8
  store ptr %145, ptr %12, align 8
  %146 = load ptr, ptr %27, align 8
  store ptr %146, ptr %30, align 8
  %147 = load ptr, ptr %28, align 8
  store ptr %147, ptr %31, align 8
  %148 = load i32, ptr %29, align 8
  store i32 %148, ptr %32, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %12, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %149 = load ptr, ptr %14, align 8
  %150 = load ptr, ptr %13, align 8
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %150)
  %152 = load i32, ptr %16, align 8
  %153 = sext i32 %152 to i64
  %154 = getelementptr ptr, ptr %150, i64 %153
  %155 = getelementptr i8, ptr %154, i64 32
  %156 = load ptr, ptr %155, align 8
  %157 = getelementptr i8, ptr %156, i64 8
  %158 = load ptr, ptr %157, align 8
  %159 = load ptr, ptr %12, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %159, 0
  %161 = load ptr, ptr %30, align 8
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, ptr %161, 1
  %163 = load ptr, ptr %31, align 8
  %164 = insertvalue { ptr, ptr, ptr, i32 } %162, ptr %163, 2
  %165 = load i32, ptr %32, align 8
  %166 = insertvalue { ptr, ptr, ptr, i32 } %164, i32 %165, 3
  call void %158(ptr %149, { ptr, ptr, ptr, i32 } %166) #30
  %167 = load ptr, ptr %14, align 8
  %168 = load ptr, ptr %13, align 8
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %168)
  %170 = load i32, ptr %16, align 8
  %171 = sext i32 %170 to i64
  %172 = getelementptr ptr, ptr %168, i64 %171
  %173 = getelementptr i8, ptr %172, i64 48
  %174 = load ptr, ptr %173, align 8
  %175 = load ptr, ptr %174, align 8
  %176 = call { ptr, i160 } %175(ptr %167) #31
  %.fca.0.extract15 = extractvalue { ptr, i160 } %176, 0
  %.fca.1.extract16 = extractvalue { ptr, i160 } %176, 1
  br label %177

177:                                              ; preds = %82, %44, %33
  %.sroa.060.1 = phi ptr [ %.fca.0.extract56, %44 ], [ %.fca.0.extract56, %82 ], [ %.sroa.060.0, %33 ]
  %.sroa.362.1 = phi i160 [ %.fca.1.extract58, %44 ], [ %.fca.1.extract58, %82 ], [ %.sroa.362.0, %33 ]
  %.reg2mem44.0.off0 = phi i1 [ false, %44 ], [ true, %82 ], [ false, %33 ]
  %.reg2mem46.0 = phi i1 [ true, %44 ], [ false, %82 ], [ false, %33 ]
  %.180 = phi ptr [ %.0, %44 ], [ %.0, %82 ], [ %.079, %33 ]
  %.178 = phi i160 [ %.074, %44 ], [ %.074, %82 ], [ %.077, %33 ]
  %.276 = phi i160 [ %.074, %44 ], [ %.fca.1.extract16, %82 ], [ %.074, %33 ]
  %.2 = phi ptr [ %.0, %44 ], [ %.fca.0.extract15, %82 ], [ %.0, %33 ]
  br i1 %.reg2mem44.0.off0, label %33, label %178

178:                                              ; preds = %177
  br i1 %.reg2mem46.0, label %179, label %234

179:                                              ; preds = %178
  %180 = load ptr, ptr %14, align 8
  %181 = load ptr, ptr %13, align 8
  %182 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %181)
  %183 = load i32, ptr %16, align 8
  %184 = sext i32 %183 to i64
  %185 = getelementptr ptr, ptr %181, i64 %184
  %186 = load ptr, ptr %185, align 8
  %187 = call ptr @typegetter_wrapper(ptr %186, ptr %180)
  %188 = load ptr, ptr %14, align 8
  %189 = load ptr, ptr %13, align 8
  %190 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %189)
  %191 = load i32, ptr %16, align 8
  %192 = sext i32 %191 to i64
  %193 = getelementptr ptr, ptr %189, i64 %192
  %194 = getelementptr i8, ptr %193, i64 8
  %195 = load ptr, ptr %194, align 8
  %196 = call ptr @typegetter_wrapper(ptr %195, ptr %188)
  store ptr @Pair, ptr %6, align 8
  %197 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %187, ptr %197, align 8
  %198 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %196, ptr %198, align 8
  %199 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Pair, ptr noundef nonnull align 8 dereferenceable(24) %6)
  %200 = extractvalue { i64, i64 } %199, 0
  %201 = call ptr @bump_malloc(i64 %200)
  store ptr %187, ptr %201, align 8
  %202 = getelementptr i8, ptr %201, i64 8
  store ptr %196, ptr %202, align 8
  %203 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %201)
  %204 = insertvalue { ptr, i160 } undef, ptr %.180, 0
  %205 = insertvalue { ptr, i160 } %204, i160 %.178, 1
  %206 = insertvalue { ptr, i160 } undef, ptr %.sroa.060.1, 0
  %207 = insertvalue { ptr, i160 } %206, i160 %.sroa.362.1, 1
  %208 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %201, 1
  %209 = insertvalue { ptr, ptr, ptr, i32 } %208, ptr undef, 2
  %210 = insertvalue { ptr, ptr, ptr, i32 } %209, i32 10, 3
  %211 = load ptr, ptr %14, align 8
  %212 = load ptr, ptr %13, align 8
  %213 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %212)
  %214 = load i32, ptr %16, align 8
  %215 = sext i32 %214 to i64
  %216 = getelementptr ptr, ptr %212, i64 %215
  %217 = load ptr, ptr %216, align 8
  %218 = call ptr @typegetter_wrapper(ptr %217, ptr %211)
  %219 = load ptr, ptr %14, align 8
  %220 = load ptr, ptr %13, align 8
  %221 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %220)
  %222 = load i32, ptr %16, align 8
  %223 = sext i32 %222 to i64
  %224 = getelementptr ptr, ptr %220, i64 %223
  %225 = getelementptr i8, ptr %224, i64 8
  %226 = load ptr, ptr %225, align 8
  %227 = call ptr @typegetter_wrapper(ptr %226, ptr %219)
  store ptr %218, ptr %7, align 8
  %228 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %227, ptr %228, align 8
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair)
  store ptr %.180, ptr %8, align 8
  %231 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.sroa.060.1, ptr %231, align 8
  %232 = call ptr @behavior_wrapper(ptr noundef nonnull @Pair_B_init_firstT_secondU, { ptr, ptr, ptr, i32 } %210, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %232({ ptr, ptr, ptr, i32 } %210, { ptr, ptr, ptr, i32 } %210, ptr nonnull %7, { ptr, i160 } %205, { ptr, i160 } %207) #39
  %233 = ptrtoint ptr %201 to i64
  %.sroa.3.8.insert.ext = zext i64 %233 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %234

234:                                              ; preds = %179, %178
  %.reg2mem42.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %179 ], [ undef, %178 ]
  %.reg2mem42.sroa.0.0 = phi ptr [ @Pair, %179 ], [ @nil_typ, %178 ]
  %.reload43.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem42.sroa.0.0, 0
  %.reload43.fca.1.insert = insertvalue { ptr, i160 } %.reload43.fca.0.insert, i160 %.reg2mem42.sroa.3.0, 1
  ret { ptr, i160 } %.reload43.fca.1.insert
}

define { i64, i64 } @_data_size_Pair(ptr nocapture nofree readonly align 8 %0) #3 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 16, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 16
  %15 = add i64 %14, %13
  %16 = getelementptr i8, ptr %0, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = extractvalue { i64, i64 } %21, 1
  %24 = call i64 @llvm.umax.i64(i64 %9, i64 %23)
  %25 = call i64 @llvm.umax.i64(i64 %24, i64 noundef 8), !range !1
  %26 = urem i64 %15, %23
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %23, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %22, %15
  %31 = add i64 %30, %29
  %32 = urem i64 %31, %25
  %33 = icmp eq i64 %32, 0
  %34 = sub i64 %25, %32
  %35 = select i1 %33, i64 0, i64 %34
  %36 = add i64 %31, %35
  %37 = insertvalue { i64, i64 } undef, i64 %36, 0
  %38 = insertvalue { i64, i64 } %37, i64 %25, 1
  ret { i64, i64 } %38
}

define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 136
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nil_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

define { ptr, i160 } @_box_nil_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_nil_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @nil_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_nil_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_nil_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @ProductIterator_getter_current_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 8
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_current_first(ptr nocapture nofree writeonly align 8 %0, { ptr, i160 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterable(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_first_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_first_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_function_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

define { ptr, i160 } @_box_function_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_function_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_function_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_function_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract12, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(160) @Pair)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = getelementptr i8, ptr %15, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %10, { ptr, i160 } %3) #30
  %20 = load ptr, ptr %7, align 8
  %21 = load ptr, ptr %6, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %21)
  %23 = load i32, ptr %9, align 8
  %24 = sext i32 %23 to i64
  %25 = getelementptr ptr, ptr %21, i64 %24
  %26 = getelementptr i8, ptr %25, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %20, { ptr, i160 } %4) #30
  ret void
}

define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract4, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(160) @Pair)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } %16(ptr %8) #31
  ret { ptr, i160 } %17
}

define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract4, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(160) @Pair)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } %16(ptr %8) #31
  ret { ptr, i160 } %17
}

define { ptr, i160 } @Pair_getter_second(ptr noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = extractvalue { i64, i64 } %6, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %20 = call { i64, i64 } @size_wrapper(ptr %19, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %21 = extractvalue { i64, i64 } %20, 1
  %22 = urem i64 %14, %21
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 %21, %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = getelementptr i8, ptr %0, i64 %14
  %27 = getelementptr i8, ptr %26, i64 %25
  %28 = load ptr, ptr %15, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = call { ptr, i160 } @box_wrapper(ptr %31, ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %28)
  ret { ptr, i160 } %32
}

define void @Pair_setter_second(ptr noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #3 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 16, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 16
  %15 = add i64 %14, %13
  %16 = getelementptr inbounds i8, ptr %0, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %22 = extractvalue { i64, i64 } %21, 1
  %23 = urem i64 %15, %22
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %22, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = getelementptr i8, ptr %0, i64 %15
  %28 = getelementptr i8, ptr %27, i64 %26
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  call void @unbox_wrapper(ptr %32, { ptr, i160 } %1, ptr noundef nonnull align 8 dereferenceable(8) %29, ptr %28)
  ret void
}

define { ptr, i160 } @Pair_getter_first(ptr noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %7 = extractvalue { i64, i64 } %6, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = load ptr, ptr %0, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 56
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } @box_wrapper(ptr %16, ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %13)
  ret { ptr, i160 } %17
}

define void @Pair_setter_first(ptr noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #3 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %reass.sub = sub i64 %8, %9
  %11 = add i64 %reass.sub, 16
  %12 = select i1 %10, i64 16, i64 %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load ptr, ptr %0, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 64
  %17 = load ptr, ptr %16, align 8
  call void @unbox_wrapper(ptr %17, { ptr, i160 } %1, ptr noundef nonnull align 8 dereferenceable(8) %14, ptr %13)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Collection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ProductIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 224
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 9197944775169318296, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 248
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ProductIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ProductIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ProductIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 312
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ProductIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 320
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @ProductIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(528) @ProductIterable)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 32
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @ProductIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract51, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract53, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract55, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract57, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(528) @ProductIterable)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract43, ptr %19, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep46, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep48, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep50, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract33, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract35, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract37, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 32
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %40) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract23, ptr %50, align 8
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep26 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract25, ptr %.fca.1.gep26, align 8
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep28 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract27, ptr %.fca.2.gep28, align 8
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep30 = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract29, ptr %.fca.3.gep30, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %51 = load ptr, ptr %6, align 8
  %52 = load ptr, ptr %5, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %52)
  %54 = load i32, ptr %8, align 8
  %55 = sext i32 %54 to i64
  %56 = getelementptr ptr, ptr %52, i64 %55
  %57 = load ptr, ptr %56, align 8
  %58 = call ptr @typegetter_wrapper(ptr %57, ptr %51)
  %59 = load ptr, ptr %6, align 8
  %60 = load ptr, ptr %5, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %60)
  %62 = load i32, ptr %8, align 8
  %63 = sext i32 %62 to i64
  %64 = getelementptr ptr, ptr %60, i64 %63
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  %67 = call ptr @typegetter_wrapper(ptr %66, ptr %59)
  %68 = load ptr, ptr %6, align 8
  %69 = load ptr, ptr %5, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %69)
  %71 = load i32, ptr %8, align 8
  %72 = sext i32 %71 to i64
  %73 = getelementptr ptr, ptr %69, i64 %72
  %74 = load ptr, ptr %73, align 8
  %75 = call ptr @typegetter_wrapper(ptr %74, ptr %68)
  %76 = load ptr, ptr %6, align 8
  %77 = load ptr, ptr %5, align 8
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %77)
  %79 = load i32, ptr %8, align 8
  %80 = sext i32 %79 to i64
  %81 = getelementptr ptr, ptr %77, i64 %80
  %82 = getelementptr i8, ptr %81, i64 8
  %83 = load ptr, ptr %82, align 8
  %84 = call ptr @typegetter_wrapper(ptr %83, ptr %76)
  %85 = call ptr @bump_malloc(i64 noundef 32)
  %86 = getelementptr i8, ptr %85, i64 16
  store ptr %84, ptr %86, align 8
  %87 = getelementptr i8, ptr %85, i64 8
  store ptr %75, ptr %87, align 8
  %88 = getelementptr i8, ptr %85, i64 24
  store ptr null, ptr %88, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %85)
  store ptr @Pair, ptr %85, align 8
  %90 = alloca [4 x ptr], align 8
  store ptr @ProductIterator, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %90, i64 8
  store ptr %58, ptr %91, align 8
  %92 = getelementptr inbounds i8, ptr %90, i64 16
  store ptr %67, ptr %92, align 8
  %93 = getelementptr inbounds i8, ptr %90, i64 24
  store ptr %85, ptr %93, align 8
  %94 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ProductIterator, ptr noundef nonnull align 8 dereferenceable(32) %90)
  %95 = extractvalue { i64, i64 } %94, 0
  %96 = call ptr @bump_malloc(i64 %95)
  store ptr %58, ptr %96, align 8
  %97 = getelementptr i8, ptr %96, i64 8
  store ptr %67, ptr %97, align 8
  %98 = getelementptr i8, ptr %96, i64 16
  store ptr %85, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %96)
  %100 = load ptr, ptr %6, align 8
  %101 = load ptr, ptr %5, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %101)
  %103 = load i32, ptr %8, align 8
  %104 = sext i32 %103 to i64
  %105 = getelementptr ptr, ptr %101, i64 %104
  %106 = getelementptr i8, ptr %105, i64 24
  %107 = load ptr, ptr %106, align 8
  %108 = load ptr, ptr %107, align 8
  %109 = call { ptr, ptr, ptr, i32 } %108(ptr %100) #31
  %110 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %109, 0
  store ptr %.fca.0.extract9, ptr %110, align 8
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %109, 1
  %.fca.1.gep12 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr %.fca.1.extract11, ptr %.fca.1.gep12, align 8
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %109, 2
  %.fca.2.gep14 = getelementptr inbounds i8, ptr %110, i64 16
  store ptr %.fca.2.extract13, ptr %.fca.2.gep14, align 8
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %109, 3
  %.fca.3.gep16 = getelementptr inbounds i8, ptr %110, i64 24
  store i32 %.fca.3.extract15, ptr %.fca.3.gep16, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %110, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %111 = load ptr, ptr %110, align 8
  %112 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %111, 0
  %113 = load ptr, ptr %.fca.1.gep12, align 8
  %114 = insertvalue { ptr, ptr, ptr, i32 } %112, ptr %113, 1
  %115 = load ptr, ptr %.fca.2.gep14, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr %115, 2
  %117 = load i32, ptr %.fca.3.gep16, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } %116, i32 %117, 3
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %111)
  %121 = sext i32 %117 to i64
  %122 = getelementptr ptr, ptr %111, i64 %121
  %123 = getelementptr i8, ptr %122, i64 8
  %124 = load ptr, ptr %123, align 8
  %125 = call ptr @behavior_wrapper(ptr %124, { ptr, ptr, ptr, i32 } %118, ptr noundef nonnull align 8 %4)
  %126 = call { ptr, ptr, ptr, i32 } %125({ ptr, ptr, ptr, i32 } %118, { ptr, ptr, ptr, i32 } %118, ptr nonnull %4) #39
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %126, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %126, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %126, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %126, 3
  %127 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %127, align 8
  %128 = getelementptr inbounds i8, ptr %127, i64 8
  store ptr %.fca.1.extract3, ptr %128, align 8
  %129 = getelementptr inbounds i8, ptr %127, i64 16
  store ptr %.fca.2.extract5, ptr %129, align 8
  %130 = getelementptr inbounds i8, ptr %127, i64 24
  store i32 %.fca.3.extract7, ptr %130, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %127, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %131 = load ptr, ptr %6, align 8
  %132 = load ptr, ptr %5, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %132)
  %134 = load i32, ptr %8, align 8
  %135 = sext i32 %134 to i64
  %136 = getelementptr ptr, ptr %132, i64 %135
  %137 = getelementptr i8, ptr %136, i64 32
  %138 = load ptr, ptr %137, align 8
  %139 = load ptr, ptr %138, align 8
  %140 = call { ptr, ptr, ptr, i32 } %139(ptr %131) #31
  %141 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %140, 0
  store ptr %.fca.0.extract, ptr %141, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %140, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %141, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %140, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %141, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %140, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %141, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %141, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %142 = alloca { ptr, ptr, ptr, i32 }, align 8
  %143 = load ptr, ptr %127, align 8
  store ptr %143, ptr %142, align 8
  %144 = getelementptr inbounds i8, ptr %142, i64 8
  %145 = load ptr, ptr %128, align 8
  store ptr %145, ptr %144, align 8
  %146 = getelementptr inbounds i8, ptr %142, i64 16
  %147 = load ptr, ptr %129, align 8
  store ptr %147, ptr %146, align 8
  %148 = getelementptr inbounds i8, ptr %142, i64 24
  %149 = load i32, ptr %130, align 8
  store i32 %149, ptr %148, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %142, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %150 = load ptr, ptr %142, align 8
  %151 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %150, 0
  %152 = load ptr, ptr %144, align 8
  %153 = insertvalue { ptr, ptr, ptr, i32 } %151, ptr %152, 1
  %154 = load ptr, ptr %146, align 8
  %155 = insertvalue { ptr, ptr, ptr, i32 } %153, ptr %154, 2
  %156 = load i32, ptr %148, align 8
  %157 = insertvalue { ptr, ptr, ptr, i32 } %155, i32 %156, 3
  %158 = alloca { ptr, ptr, ptr, i32 }, align 8
  %159 = load ptr, ptr %141, align 8
  store ptr %159, ptr %158, align 8
  %160 = getelementptr inbounds i8, ptr %158, i64 8
  %161 = load ptr, ptr %.fca.1.gep, align 8
  store ptr %161, ptr %160, align 8
  %162 = getelementptr inbounds i8, ptr %158, i64 16
  %163 = load ptr, ptr %.fca.2.gep, align 8
  store ptr %163, ptr %162, align 8
  %164 = getelementptr inbounds i8, ptr %158, i64 24
  %165 = load i32, ptr %.fca.3.gep, align 8
  store i32 %165, ptr %164, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %158, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %166 = load ptr, ptr %158, align 8
  %167 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %166, 0
  %168 = load ptr, ptr %160, align 8
  %169 = insertvalue { ptr, ptr, ptr, i32 } %167, ptr %168, 1
  %170 = load ptr, ptr %162, align 8
  %171 = insertvalue { ptr, ptr, ptr, i32 } %169, ptr %170, 2
  %172 = load i32, ptr %164, align 8
  %173 = insertvalue { ptr, ptr, ptr, i32 } %171, i32 %172, 3
  %174 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %96, 1
  %175 = insertvalue { ptr, ptr, ptr, i32 } %174, ptr undef, 2
  %176 = insertvalue { ptr, ptr, ptr, i32 } %175, i32 10, 3
  %177 = load ptr, ptr %6, align 8
  %178 = load ptr, ptr %5, align 8
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %178)
  %180 = load i32, ptr %8, align 8
  %181 = sext i32 %180 to i64
  %182 = getelementptr ptr, ptr %178, i64 %181
  %183 = load ptr, ptr %182, align 8
  %184 = call ptr @typegetter_wrapper(ptr %183, ptr %177)
  %185 = call ptr @bump_malloc(i64 noundef 24)
  %186 = getelementptr i8, ptr %185, i64 8
  store ptr %184, ptr %186, align 8
  %187 = getelementptr i8, ptr %185, i64 16
  store ptr null, ptr %187, align 8
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %185)
  store ptr @Iterator, ptr %185, align 8
  %189 = load ptr, ptr %6, align 8
  %190 = load ptr, ptr %5, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %190)
  %192 = load i32, ptr %8, align 8
  %193 = sext i32 %192 to i64
  %194 = getelementptr ptr, ptr %190, i64 %193
  %195 = getelementptr i8, ptr %194, i64 8
  %196 = load ptr, ptr %195, align 8
  %197 = call ptr @typegetter_wrapper(ptr %196, ptr %189)
  %198 = call ptr @bump_malloc(i64 noundef 24)
  %199 = getelementptr i8, ptr %198, i64 8
  store ptr %197, ptr %199, align 8
  %200 = getelementptr i8, ptr %198, i64 16
  store ptr null, ptr %200, align 8
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %198)
  store ptr @Iterable, ptr %198, align 8
  %202 = alloca [2 x ptr], align 8
  store ptr %185, ptr %202, align 8
  %203 = getelementptr inbounds i8, ptr %202, i64 8
  store ptr %198, ptr %203, align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %202)
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @ProductIterator)
  %206 = alloca { ptr, ptr }, align 8
  store ptr %150, ptr %206, align 8
  %207 = getelementptr inbounds i8, ptr %206, i64 8
  store ptr %166, ptr %207, align 8
  %208 = call ptr @behavior_wrapper(ptr noundef nonnull @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU, { ptr, ptr, ptr, i32 } %176, ptr noundef nonnull align 8 dereferenceable(16) %206)
  call void %208({ ptr, ptr, ptr, i32 } %176, { ptr, ptr, ptr, i32 } %176, ptr nonnull %202, { ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %173) #39
  %209 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ProductIterator, ptr %209, align 8
  %210 = getelementptr inbounds i8, ptr %209, i64 8
  store ptr %96, ptr %210, align 8
  %211 = getelementptr inbounds i8, ptr %209, i64 16
  %212 = getelementptr inbounds i8, ptr %209, i64 24
  store i32 10, ptr %212, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %209, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %213 = load ptr, ptr %209, align 8
  %214 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %213, 0
  %215 = load ptr, ptr %210, align 8
  %216 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %215, 1
  %217 = load ptr, ptr %211, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } %216, ptr %217, 2
  %219 = load i32, ptr %212, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } %218, i32 %219, 3
  ret { ptr, ptr, ptr, i32 } %220
}

define { ptr, ptr, ptr, i32 } @Iterable_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = call ptr @typegetter_wrapper(ptr %14, ptr %8)
  %16 = load ptr, ptr %5, align 8
  %17 = load ptr, ptr %4, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %17)
  %19 = load i32, ptr %7, align 8
  %20 = sext i32 %19 to i64
  %21 = getelementptr ptr, ptr %17, i64 %20
  %22 = load ptr, ptr %21, align 8
  %23 = call ptr @typegetter_wrapper(ptr %22, ptr %16)
  %24 = call ptr @bump_malloc(i64 noundef 32)
  %25 = getelementptr i8, ptr %24, i64 16
  store ptr %23, ptr %25, align 8
  %26 = getelementptr i8, ptr %24, i64 8
  store ptr @_parameterization_i32, ptr %26, align 8
  %27 = getelementptr i8, ptr %24, i64 24
  store ptr null, ptr %27, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %24)
  store ptr @Pair, ptr %24, align 8
  %29 = alloca [3 x ptr], align 8
  store ptr @Enumeration, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %29, i64 8
  store ptr %15, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %29, i64 16
  store ptr %24, ptr %31, align 8
  %32 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Enumeration, ptr noundef nonnull align 8 dereferenceable(24) %29)
  %33 = extractvalue { i64, i64 } %32, 0
  %34 = call ptr @bump_malloc(i64 %33)
  store ptr %15, ptr %34, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr %24, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %34)
  %37 = alloca { ptr, ptr, ptr, i32 }, align 8
  %38 = load ptr, ptr %4, align 8
  store ptr %38, ptr %37, align 8
  %39 = getelementptr inbounds i8, ptr %37, i64 8
  %40 = load ptr, ptr %5, align 8
  store ptr %40, ptr %39, align 8
  %41 = getelementptr inbounds i8, ptr %37, i64 16
  %42 = load ptr, ptr %6, align 8
  store ptr %42, ptr %41, align 8
  %43 = getelementptr inbounds i8, ptr %37, i64 24
  %44 = load i32, ptr %7, align 8
  store i32 %44, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %37, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %45 = load ptr, ptr %37, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %45, 0
  %47 = load ptr, ptr %39, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %47, 1
  %49 = load ptr, ptr %41, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 2
  %51 = load i32, ptr %43, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %51, 3
  %53 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumeration, ptr undef, ptr undef, i32 undef }, ptr %34, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr undef, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 10, 3
  %56 = load ptr, ptr %5, align 8
  %57 = load ptr, ptr %4, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %57)
  %59 = load i32, ptr %7, align 8
  %60 = sext i32 %59 to i64
  %61 = getelementptr ptr, ptr %57, i64 %60
  %62 = load ptr, ptr %61, align 8
  %63 = call ptr @typegetter_wrapper(ptr %62, ptr %56)
  %64 = call ptr @bump_malloc(i64 noundef 24)
  %65 = getelementptr i8, ptr %64, i64 8
  store ptr %63, ptr %65, align 8
  %66 = getelementptr i8, ptr %64, i64 16
  store ptr null, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %64)
  store ptr @Iterable, ptr %64, align 8
  %68 = alloca [1 x ptr], align 8
  store ptr %64, ptr %68, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %68)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef nonnull align 16 dereferenceable(512) @Enumeration)
  %71 = alloca { ptr }, align 8
  store ptr %45, ptr %71, align 8
  %72 = call ptr @behavior_wrapper(ptr noundef nonnull @Enumeration_B_init_iterableIterableT, { ptr, ptr, ptr, i32 } %55, ptr noundef nonnull align 8 dereferenceable(8) %71)
  call void %72({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull %68, { ptr, ptr, ptr, i32 } %52) #39
  %73 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @Enumeration, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %73, i64 8
  store ptr %34, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %73, i64 16
  %76 = getelementptr inbounds i8, ptr %73, i64 24
  store i32 10, ptr %76, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %73, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %77 = load ptr, ptr %73, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %77, 0
  %79 = load ptr, ptr %74, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %79, 1
  %81 = load ptr, ptr %75, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %81, 2
  %83 = load i32, ptr %76, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, i32 %83, 3
  ret { ptr, ptr, ptr, i32 } %84
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumeration(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @Enumeration_B_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 208
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumeration_field_Enumeration_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumeration_field_Enumeration_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Enumeration_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 9197944775169318296, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 232
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumeration_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Enumeration_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 280
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @Enumeration_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @Enumeration_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @Enumeration_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @Enumeration_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract4, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(512) @Enumeration)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = load ptr, ptr %9, align 8
  store ptr %14, ptr %13, align 8
  %15 = getelementptr inbounds i8, ptr %13, i64 8
  %16 = load ptr, ptr %10, align 8
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds i8, ptr %13, i64 16
  %18 = load ptr, ptr %11, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds i8, ptr %13, i64 24
  %20 = load i32, ptr %12, align 8
  store i32 %20, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %5, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %8, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %13, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = load ptr, ptr %15, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 1
  %35 = load ptr, ptr %17, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 2
  %37 = load i32, ptr %19, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %37, 3
  call void %30(ptr %21, { ptr, ptr, ptr, i32 } %38) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @Enumeration_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract33, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract35, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract37, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(512) @Enumeration)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract23, ptr %19, align 8
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep26 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract25, ptr %.fca.1.gep26, align 8
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep28 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract27, ptr %.fca.2.gep28, align 8
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep30 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract29, ptr %.fca.3.gep30, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep26, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep28, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep30, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract13, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract15, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract17, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = load ptr, ptr %45, align 8
  %47 = call ptr @typegetter_wrapper(ptr %46, ptr %40)
  %48 = load ptr, ptr %6, align 8
  %49 = load ptr, ptr %5, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %49)
  %51 = load i32, ptr %8, align 8
  %52 = sext i32 %51 to i64
  %53 = getelementptr ptr, ptr %49, i64 %52
  %54 = load ptr, ptr %53, align 8
  %55 = call ptr @typegetter_wrapper(ptr %54, ptr %48)
  %56 = call ptr @bump_malloc(i64 noundef 32)
  %57 = getelementptr i8, ptr %56, i64 16
  store ptr %55, ptr %57, align 8
  %58 = getelementptr i8, ptr %56, i64 8
  store ptr @_parameterization_i32, ptr %58, align 8
  %59 = getelementptr i8, ptr %56, i64 24
  store ptr null, ptr %59, align 8
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %56)
  store ptr @Pair, ptr %56, align 8
  %61 = alloca [3 x ptr], align 8
  store ptr @Enumerator, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %61, i64 8
  store ptr %47, ptr %62, align 8
  %63 = getelementptr inbounds i8, ptr %61, i64 16
  store ptr %56, ptr %63, align 8
  %64 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Enumerator, ptr noundef nonnull align 8 dereferenceable(24) %61)
  %65 = extractvalue { i64, i64 } %64, 0
  %66 = call ptr @bump_malloc(i64 %65)
  store ptr %47, ptr %66, align 8
  %67 = getelementptr i8, ptr %66, i64 8
  store ptr %56, ptr %67, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %66)
  %69 = load ptr, ptr %6, align 8
  %70 = load ptr, ptr %5, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %70)
  %72 = load i32, ptr %8, align 8
  %73 = sext i32 %72 to i64
  %74 = getelementptr ptr, ptr %70, i64 %73
  %75 = getelementptr i8, ptr %74, i64 16
  %76 = load ptr, ptr %75, align 8
  %77 = load ptr, ptr %76, align 8
  %78 = call { ptr, ptr, ptr, i32 } %77(ptr %69) #31
  %79 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %78, 0
  store ptr %.fca.0.extract1, ptr %79, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %78, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %79, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %78, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %79, i64 16
  store ptr %.fca.2.extract3, ptr %.fca.2.gep, align 8
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %78, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %79, i64 24
  store i32 %.fca.3.extract4, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %79, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %80 = load ptr, ptr %79, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %80, 0
  %82 = load ptr, ptr %.fca.1.gep, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %82, 1
  %84 = load ptr, ptr %.fca.2.gep, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %84, 2
  %86 = load i32, ptr %.fca.3.gep, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %86, 3
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %80)
  %90 = sext i32 %86 to i64
  %91 = getelementptr ptr, ptr %80, i64 %90
  %92 = getelementptr i8, ptr %91, i64 8
  %93 = load ptr, ptr %92, align 8
  %94 = call ptr @behavior_wrapper(ptr %93, { ptr, ptr, ptr, i32 } %87, ptr noundef nonnull align 8 %4)
  %95 = call { ptr, ptr, ptr, i32 } %94({ ptr, ptr, ptr, i32 } %87, { ptr, ptr, ptr, i32 } %87, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %95, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %95, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %95, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %95, 3
  %96 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %96, align 8
  %97 = getelementptr inbounds i8, ptr %96, i64 8
  store ptr %.fca.1.extract, ptr %97, align 8
  %98 = getelementptr inbounds i8, ptr %96, i64 16
  store ptr %.fca.2.extract, ptr %98, align 8
  %99 = getelementptr inbounds i8, ptr %96, i64 24
  store i32 %.fca.3.extract, ptr %99, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %96, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %100 = alloca { ptr, ptr, ptr, i32 }, align 8
  %101 = load ptr, ptr %96, align 8
  store ptr %101, ptr %100, align 8
  %102 = getelementptr inbounds i8, ptr %100, i64 8
  %103 = load ptr, ptr %97, align 8
  store ptr %103, ptr %102, align 8
  %104 = getelementptr inbounds i8, ptr %100, i64 16
  %105 = load ptr, ptr %98, align 8
  store ptr %105, ptr %104, align 8
  %106 = getelementptr inbounds i8, ptr %100, i64 24
  %107 = load i32, ptr %99, align 8
  store i32 %107, ptr %106, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %100, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %108 = load ptr, ptr %100, align 8
  %109 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %108, 0
  %110 = load ptr, ptr %102, align 8
  %111 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %110, 1
  %112 = load ptr, ptr %104, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } %111, ptr %112, 2
  %114 = load i32, ptr %106, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %113, i32 %114, 3
  %116 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %66, 1
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr undef, 2
  %118 = insertvalue { ptr, ptr, ptr, i32 } %117, i32 10, 3
  %119 = load ptr, ptr %6, align 8
  %120 = load ptr, ptr %5, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %120)
  %122 = load i32, ptr %8, align 8
  %123 = sext i32 %122 to i64
  %124 = getelementptr ptr, ptr %120, i64 %123
  %125 = load ptr, ptr %124, align 8
  %126 = call ptr @typegetter_wrapper(ptr %125, ptr %119)
  %127 = call ptr @bump_malloc(i64 noundef 24)
  %128 = getelementptr i8, ptr %127, i64 8
  store ptr %126, ptr %128, align 8
  %129 = getelementptr i8, ptr %127, i64 16
  store ptr null, ptr %129, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %127)
  store ptr @Iterator, ptr %127, align 8
  %131 = alloca [1 x ptr], align 8
  store ptr %127, ptr %131, align 8
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %131)
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @Enumerator)
  %134 = alloca { ptr }, align 8
  store ptr %108, ptr %134, align 8
  %135 = call ptr @behavior_wrapper(ptr noundef nonnull @Enumerator_B_init_iteratorIteratorT, { ptr, ptr, ptr, i32 } %118, ptr noundef nonnull align 8 dereferenceable(8) %134)
  call void %135({ ptr, ptr, ptr, i32 } %118, { ptr, ptr, ptr, i32 } %118, ptr nonnull %131, { ptr, ptr, ptr, i32 } %115) #39
  %136 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @Enumerator, ptr %136, align 8
  %137 = getelementptr inbounds i8, ptr %136, i64 8
  store ptr %66, ptr %137, align 8
  %138 = getelementptr inbounds i8, ptr %136, i64 16
  %139 = getelementptr inbounds i8, ptr %136, i64 24
  store i32 10, ptr %139, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %136, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %140 = load ptr, ptr %136, align 8
  %141 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %140, 0
  %142 = load ptr, ptr %137, align 8
  %143 = insertvalue { ptr, ptr, ptr, i32 } %141, ptr %142, 1
  %144 = load ptr, ptr %138, align 8
  %145 = insertvalue { ptr, ptr, ptr, i32 } %143, ptr %144, 2
  %146 = load i32, ptr %139, align 8
  %147 = insertvalue { ptr, ptr, ptr, i32 } %145, i32 %146, 3
  ret { ptr, ptr, ptr, i32 } %147
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Enumerator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

define ptr @Enumerator_B_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 128
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Enumerator_field_Enumerator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Enumerator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Enumerator_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract4, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(168) @Enumerator)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = load ptr, ptr %9, align 8
  store ptr %14, ptr %13, align 8
  %15 = getelementptr inbounds i8, ptr %13, i64 8
  %16 = load ptr, ptr %10, align 8
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds i8, ptr %13, i64 16
  %18 = load ptr, ptr %11, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds i8, ptr %13, i64 24
  %20 = load i32, ptr %12, align 8
  store i32 %20, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %5, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %8, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %13, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = load ptr, ptr %15, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 1
  %35 = load ptr, ptr %17, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 2
  %37 = load i32, ptr %19, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %37, 3
  call void %30(ptr %21, { ptr, ptr, ptr, i32 } %38) #30
  %39 = load ptr, ptr %6, align 8
  %40 = load ptr, ptr %5, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %40)
  %42 = load i32, ptr %8, align 8
  %43 = sext i32 %42 to i64
  %44 = getelementptr ptr, ptr %40, i64 %43
  %45 = getelementptr i8, ptr %44, i64 24
  %46 = load ptr, ptr %45, align 8
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  call void %48(ptr %39, i32 0) #30
  ret void
}

define { ptr, i160 } @Enumerator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract14, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract16, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract18, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract20, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(168) @Enumerator)
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %8, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %13)
  %15 = load i32, ptr %11, align 8
  %16 = sext i32 %15 to i64
  %17 = getelementptr ptr, ptr %13, i64 %16
  %18 = getelementptr i8, ptr %17, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %12) #31
  %22 = add i32 %21, 1
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %13)
  %24 = getelementptr i8, ptr %19, i64 8
  %25 = load ptr, ptr %24, align 8
  call void %25(ptr %12, i32 %22) #30
  %26 = load ptr, ptr %9, align 8
  %27 = load ptr, ptr %8, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %27)
  %29 = load i32, ptr %11, align 8
  %30 = sext i32 %29 to i64
  %31 = getelementptr ptr, ptr %27, i64 %30
  %32 = getelementptr i8, ptr %31, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %26) #31
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  store ptr %.fca.0.extract2, ptr %36, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %39 = load ptr, ptr %.fca.1.gep, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 1
  %41 = load ptr, ptr %.fca.2.gep, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 2
  %43 = load i32, ptr %.fca.3.gep, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %37)
  %47 = sext i32 %43 to i64
  %48 = getelementptr ptr, ptr %37, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr noundef nonnull align 8 %4)
  %52 = call { ptr, i160 } %51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %52, 0
  %53 = load ptr, ptr %9, align 8
  %54 = load ptr, ptr %8, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %54)
  %56 = load i32, ptr %11, align 8
  %57 = sext i32 %56 to i64
  %58 = getelementptr ptr, ptr %54, i64 %57
  %59 = load ptr, ptr %58, align 8
  %60 = call ptr @typegetter_wrapper(ptr %59, ptr %53)
  %61 = icmp ne ptr %.fca.0.extract, @nil_typ
  %62 = icmp ne ptr %.fca.0.extract, null
  %.not43 = and i1 %61, %62
  br i1 %.not43, label %63, label %108

63:                                               ; preds = %3
  %64 = load ptr, ptr %9, align 8
  %65 = load ptr, ptr %8, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %65)
  %67 = load i32, ptr %11, align 8
  %68 = sext i32 %67 to i64
  %69 = getelementptr ptr, ptr %65, i64 %68
  %70 = getelementptr i8, ptr %69, i64 24
  %71 = load ptr, ptr %70, align 8
  %72 = load ptr, ptr %71, align 8
  %73 = call i32 %72(ptr %64) #31
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %65)
  %75 = load ptr, ptr %69, align 8
  %76 = call ptr @typegetter_wrapper(ptr %75, ptr %64)
  store ptr @Pair, ptr %5, align 8
  %77 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %76, ptr %78, align 8
  %79 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Pair, ptr noundef nonnull align 8 dereferenceable(24) %5)
  %80 = extractvalue { i64, i64 } %79, 0
  %81 = call ptr @bump_malloc(i64 %80)
  store ptr @_parameterization_i32, ptr %81, align 8
  %82 = getelementptr i8, ptr %81, i64 8
  store ptr %76, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %81)
  %84 = load ptr, ptr %9, align 8
  %85 = load ptr, ptr %8, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %85)
  %87 = load i32, ptr %11, align 8
  %88 = sext i32 %87 to i64
  %89 = getelementptr ptr, ptr %85, i64 %88
  %90 = getelementptr i8, ptr %89, i64 24
  %91 = load ptr, ptr %90, align 8
  %92 = load ptr, ptr %91, align 8
  %93 = call i32 %92(ptr %84) #31
  %94 = add i32 %93, -1
  %.sroa.028.0.insert.ext = zext i32 %94 to i160
  %95 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.028.0.insert.ext, 1
  %96 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %81, 1
  %97 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr undef, 2
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, i32 10, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %85)
  %100 = load ptr, ptr %89, align 8
  %101 = call ptr @typegetter_wrapper(ptr %100, ptr %84)
  store ptr @_parameterization_i32, ptr %6, align 8
  %102 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %101, ptr %102, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair)
  store ptr @i32_typ, ptr %7, align 8
  %105 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.0.extract, ptr %105, align 8
  %106 = call ptr @behavior_wrapper(ptr noundef nonnull @Pair_B_init_firstT_secondU, { ptr, ptr, ptr, i32 } %98, ptr noundef nonnull align 8 dereferenceable(16) %7)
  call void %106({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull %6, { ptr, i160 } %95, { ptr, i160 } %52) #39
  %107 = ptrtoint ptr %81 to i64
  %.sroa.335.8.insert.ext = zext i64 %107 to i160
  %.sroa.335.8.insert.insert = or disjoint i160 %.sroa.335.8.insert.ext, 3402823669209384634633746074317682114560
  br label %108

108:                                              ; preds = %63, %3
  %.reg2mem25.sroa.0.0 = phi ptr [ @Pair, %63 ], [ @nil_typ, %3 ]
  %.reg2mem25.sroa.3.0 = phi i160 [ %.sroa.335.8.insert.insert, %63 ], [ undef, %3 ]
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i32_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 4, i64 4 }
}

define { ptr, i160 } @_box_i32_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i32_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_i32_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i32_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Enumerator_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumerator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumerator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Enumeration_getter_iterable(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Enumeration_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZippedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 232
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZippedCollection_field_ZippedCollection_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Pair, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 264
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 28
  %8 = getelementptr [120 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZippedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ZippedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 30, %21 ], [ 30, %14 ], [ 31, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [120 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 32, %.critedge ], [ 33, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [120 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 34, %21 ], [ 34, %14 ], [ 35, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [120 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 37, %.critedge ], [ 36, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [120 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define void @ZippedCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1040) @ZippedCollection)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 32
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define i32 @ZippedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract13, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract15, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract17, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract19, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1040) @ZippedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract5, ptr %19, align 8
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep8 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract7, ptr %.fca.1.gep8, align 8
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep10 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract9, ptr %.fca.2.gep10, align 8
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep12 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract11, ptr %.fca.3.gep12, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep8, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep10, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep12, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %36 = load ptr, ptr %6, align 8
  %37 = load ptr, ptr %5, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %37)
  %39 = load i32, ptr %8, align 8
  %40 = sext i32 %39 to i64
  %41 = getelementptr ptr, ptr %37, i64 %40
  %42 = getelementptr i8, ptr %41, i64 32
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %36) #31
  %46 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  store ptr %.fca.0.extract, ptr %46, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %46, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %46, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %46, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %46, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %49 = load ptr, ptr %.fca.1.gep, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 1
  %51 = load ptr, ptr %.fca.2.gep, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %51, 2
  %53 = load i32, ptr %.fca.3.gep, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %53, 3
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %47)
  %57 = sext i32 %53 to i64
  %58 = getelementptr ptr, ptr %47, i64 %57
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = call ptr @behavior_wrapper(ptr %60, { ptr, ptr, ptr, i32 } %54, ptr noundef nonnull align 8 %4)
  %62 = call i32 %61({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull %4) #39
  %.sroa.speculated = call i32 @llvm.smin.i32(i32 %35, i32 %62)
  ret i32 %.sroa.speculated
}

define { ptr, ptr, ptr, i32 } @ZippedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract77 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract71, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract73, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract75, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract77, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1040) @ZippedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract63, ptr %19, align 8
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep66 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract65, ptr %.fca.1.gep66, align 8
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep68 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract67, ptr %.fca.2.gep68, align 8
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep70 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract69, ptr %.fca.3.gep70, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep66, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep68, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep70, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract51, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract53, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract55, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract57, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 32
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %40) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract43, ptr %50, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %.fca.1.gep46, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %.fca.2.gep48, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %.fca.3.gep50, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %51)
  %61 = sext i32 %57 to i64
  %62 = getelementptr ptr, ptr %51, i64 %61
  %63 = getelementptr i8, ptr %62, i64 16
  %64 = load ptr, ptr %63, align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %4) #39
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %66, 3
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %.fca.1.extract33, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr %.fca.2.extract35, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %67, i64 24
  store i32 %.fca.3.extract37, ptr %70, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %67, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %71 = load ptr, ptr %6, align 8
  %72 = load ptr, ptr %5, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %8, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = load ptr, ptr %76, align 8
  %78 = call ptr @typegetter_wrapper(ptr %77, ptr %71)
  %79 = load ptr, ptr %6, align 8
  %80 = load ptr, ptr %5, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %80)
  %82 = load i32, ptr %8, align 8
  %83 = sext i32 %82 to i64
  %84 = getelementptr ptr, ptr %80, i64 %83
  %85 = getelementptr i8, ptr %84, i64 8
  %86 = load ptr, ptr %85, align 8
  %87 = call ptr @typegetter_wrapper(ptr %86, ptr %79)
  %88 = load ptr, ptr %6, align 8
  %89 = load ptr, ptr %5, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %89)
  %91 = load i32, ptr %8, align 8
  %92 = sext i32 %91 to i64
  %93 = getelementptr ptr, ptr %89, i64 %92
  %94 = load ptr, ptr %93, align 8
  %95 = call ptr @typegetter_wrapper(ptr %94, ptr %88)
  %96 = load ptr, ptr %6, align 8
  %97 = load ptr, ptr %5, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %97)
  %99 = load i32, ptr %8, align 8
  %100 = sext i32 %99 to i64
  %101 = getelementptr ptr, ptr %97, i64 %100
  %102 = getelementptr i8, ptr %101, i64 8
  %103 = load ptr, ptr %102, align 8
  %104 = call ptr @typegetter_wrapper(ptr %103, ptr %96)
  %105 = call ptr @bump_malloc(i64 noundef 32)
  %106 = getelementptr i8, ptr %105, i64 16
  store ptr %104, ptr %106, align 8
  %107 = getelementptr i8, ptr %105, i64 8
  store ptr %95, ptr %107, align 8
  %108 = getelementptr i8, ptr %105, i64 24
  store ptr null, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %105)
  store ptr @Pair, ptr %105, align 8
  %110 = alloca [4 x ptr], align 8
  store ptr @ZipIterator, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr %78, ptr %111, align 8
  %112 = getelementptr inbounds i8, ptr %110, i64 16
  store ptr %87, ptr %112, align 8
  %113 = getelementptr inbounds i8, ptr %110, i64 24
  store ptr %105, ptr %113, align 8
  %114 = load ptr, ptr getelementptr inbounds (i8, ptr @ZipIterator, i64 48), align 8
  %115 = call { i64, i64 } @size_wrapper(ptr %114, ptr noundef nonnull align 8 dereferenceable(32) %110)
  %116 = extractvalue { i64, i64 } %115, 0
  %117 = call ptr @bump_malloc(i64 %116)
  store ptr %78, ptr %117, align 8
  %118 = getelementptr i8, ptr %117, i64 8
  store ptr %87, ptr %118, align 8
  %119 = getelementptr i8, ptr %117, i64 16
  store ptr %105, ptr %119, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %117)
  %121 = load ptr, ptr %6, align 8
  %122 = load ptr, ptr %5, align 8
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %122)
  %124 = load i32, ptr %8, align 8
  %125 = sext i32 %124 to i64
  %126 = getelementptr ptr, ptr %122, i64 %125
  %127 = getelementptr i8, ptr %126, i64 24
  %128 = load ptr, ptr %127, align 8
  %129 = load ptr, ptr %128, align 8
  %130 = call { ptr, ptr, ptr, i32 } %129(ptr %121) #31
  %131 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %130, 0
  store ptr %.fca.0.extract17, ptr %131, align 8
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %130, 1
  %.fca.1.gep20 = getelementptr inbounds i8, ptr %131, i64 8
  store ptr %.fca.1.extract19, ptr %.fca.1.gep20, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %130, 2
  %.fca.2.gep22 = getelementptr inbounds i8, ptr %131, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep22, align 8
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %130, 3
  %.fca.3.gep24 = getelementptr inbounds i8, ptr %131, i64 24
  store i32 %.fca.3.extract23, ptr %.fca.3.gep24, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %131, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %132 = load ptr, ptr %131, align 8
  %133 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %132, 0
  %134 = load ptr, ptr %.fca.1.gep20, align 8
  %135 = insertvalue { ptr, ptr, ptr, i32 } %133, ptr %134, 1
  %136 = load ptr, ptr %.fca.2.gep22, align 8
  %137 = insertvalue { ptr, ptr, ptr, i32 } %135, ptr %136, 2
  %138 = load i32, ptr %.fca.3.gep24, align 8
  %139 = insertvalue { ptr, ptr, ptr, i32 } %137, i32 %138, 3
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %132)
  %142 = sext i32 %138 to i64
  %143 = getelementptr ptr, ptr %132, i64 %142
  %144 = getelementptr i8, ptr %143, i64 16
  %145 = load ptr, ptr %144, align 8
  %146 = call ptr @behavior_wrapper(ptr %145, { ptr, ptr, ptr, i32 } %139, ptr noundef nonnull align 8 %4)
  %147 = call { ptr, ptr, ptr, i32 } %146({ ptr, ptr, ptr, i32 } %139, { ptr, ptr, ptr, i32 } %139, ptr nonnull align 8 %4) #39
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %147, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %147, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %147, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %147, 3
  %148 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %148, align 8
  %149 = getelementptr inbounds i8, ptr %148, i64 8
  store ptr %.fca.1.extract7, ptr %149, align 8
  %150 = getelementptr inbounds i8, ptr %148, i64 16
  store ptr %.fca.2.extract9, ptr %150, align 8
  %151 = getelementptr inbounds i8, ptr %148, i64 24
  store i32 %.fca.3.extract11, ptr %151, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %148, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %152 = load ptr, ptr %6, align 8
  %153 = load ptr, ptr %5, align 8
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %153)
  %155 = load i32, ptr %8, align 8
  %156 = sext i32 %155 to i64
  %157 = getelementptr ptr, ptr %153, i64 %156
  %158 = getelementptr i8, ptr %157, i64 32
  %159 = load ptr, ptr %158, align 8
  %160 = load ptr, ptr %159, align 8
  %161 = call { ptr, ptr, ptr, i32 } %160(ptr %152) #31
  %162 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %161, 0
  store ptr %.fca.0.extract1, ptr %162, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %161, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %162, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %161, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %162, i64 16
  store ptr %.fca.2.extract3, ptr %.fca.2.gep, align 8
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %161, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %162, i64 24
  store i32 %.fca.3.extract4, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %162, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %163 = load ptr, ptr %162, align 8
  %164 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %163, 0
  %165 = load ptr, ptr %.fca.1.gep, align 8
  %166 = insertvalue { ptr, ptr, ptr, i32 } %164, ptr %165, 1
  %167 = load ptr, ptr %.fca.2.gep, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } %166, ptr %167, 2
  %169 = load i32, ptr %.fca.3.gep, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, i32 %169, 3
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %163)
  %173 = sext i32 %169 to i64
  %174 = getelementptr ptr, ptr %163, i64 %173
  %175 = getelementptr i8, ptr %174, i64 16
  %176 = load ptr, ptr %175, align 8
  %177 = call ptr @behavior_wrapper(ptr %176, { ptr, ptr, ptr, i32 } %170, ptr noundef nonnull align 8 %4)
  %178 = call { ptr, ptr, ptr, i32 } %177({ ptr, ptr, ptr, i32 } %170, { ptr, ptr, ptr, i32 } %170, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %178, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %178, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %178, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %178, 3
  %179 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %179, align 8
  %180 = getelementptr inbounds i8, ptr %179, i64 8
  store ptr %.fca.1.extract, ptr %180, align 8
  %181 = getelementptr inbounds i8, ptr %179, i64 16
  store ptr %.fca.2.extract, ptr %181, align 8
  %182 = getelementptr inbounds i8, ptr %179, i64 24
  store i32 %.fca.3.extract, ptr %182, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %179, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %183 = alloca { ptr, ptr, ptr, i32 }, align 8
  %184 = load ptr, ptr %148, align 8
  store ptr %184, ptr %183, align 8
  %185 = getelementptr inbounds i8, ptr %183, i64 8
  %186 = load ptr, ptr %149, align 8
  store ptr %186, ptr %185, align 8
  %187 = getelementptr inbounds i8, ptr %183, i64 16
  %188 = load ptr, ptr %150, align 8
  store ptr %188, ptr %187, align 8
  %189 = getelementptr inbounds i8, ptr %183, i64 24
  %190 = load i32, ptr %151, align 8
  store i32 %190, ptr %189, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %183, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %191 = load ptr, ptr %183, align 8
  %192 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %191, 0
  %193 = load ptr, ptr %185, align 8
  %194 = insertvalue { ptr, ptr, ptr, i32 } %192, ptr %193, 1
  %195 = load ptr, ptr %187, align 8
  %196 = insertvalue { ptr, ptr, ptr, i32 } %194, ptr %195, 2
  %197 = load i32, ptr %189, align 8
  %198 = insertvalue { ptr, ptr, ptr, i32 } %196, i32 %197, 3
  %199 = alloca { ptr, ptr, ptr, i32 }, align 8
  %200 = load ptr, ptr %179, align 8
  store ptr %200, ptr %199, align 8
  %201 = getelementptr inbounds i8, ptr %199, i64 8
  %202 = load ptr, ptr %180, align 8
  store ptr %202, ptr %201, align 8
  %203 = getelementptr inbounds i8, ptr %199, i64 16
  %204 = load ptr, ptr %181, align 8
  store ptr %204, ptr %203, align 8
  %205 = getelementptr inbounds i8, ptr %199, i64 24
  %206 = load i32, ptr %182, align 8
  store i32 %206, ptr %205, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %199, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %207 = load ptr, ptr %199, align 8
  %208 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %207, 0
  %209 = load ptr, ptr %201, align 8
  %210 = insertvalue { ptr, ptr, ptr, i32 } %208, ptr %209, 1
  %211 = load ptr, ptr %203, align 8
  %212 = insertvalue { ptr, ptr, ptr, i32 } %210, ptr %211, 2
  %213 = load i32, ptr %205, align 8
  %214 = insertvalue { ptr, ptr, ptr, i32 } %212, i32 %213, 3
  %215 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %117, 1
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, ptr undef, 2
  %217 = insertvalue { ptr, ptr, ptr, i32 } %216, i32 10, 3
  %218 = load ptr, ptr %6, align 8
  %219 = load ptr, ptr %5, align 8
  %220 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %219)
  %221 = load i32, ptr %8, align 8
  %222 = sext i32 %221 to i64
  %223 = getelementptr ptr, ptr %219, i64 %222
  %224 = load ptr, ptr %223, align 8
  %225 = call ptr @typegetter_wrapper(ptr %224, ptr %218)
  %226 = call ptr @bump_malloc(i64 noundef 24)
  %227 = getelementptr i8, ptr %226, i64 8
  store ptr %225, ptr %227, align 8
  %228 = getelementptr i8, ptr %226, i64 16
  store ptr null, ptr %228, align 8
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %226)
  store ptr @Iterator, ptr %226, align 8
  %230 = load ptr, ptr %6, align 8
  %231 = load ptr, ptr %5, align 8
  %232 = call ptr @llvm.invariant.start.p0(i64 noundef 960, ptr nocapture nofree noundef %231)
  %233 = load i32, ptr %8, align 8
  %234 = sext i32 %233 to i64
  %235 = getelementptr ptr, ptr %231, i64 %234
  %236 = getelementptr i8, ptr %235, i64 8
  %237 = load ptr, ptr %236, align 8
  %238 = call ptr @typegetter_wrapper(ptr %237, ptr %230)
  %239 = call ptr @bump_malloc(i64 noundef 24)
  %240 = getelementptr i8, ptr %239, i64 8
  store ptr %238, ptr %240, align 8
  %241 = getelementptr i8, ptr %239, i64 16
  store ptr null, ptr %241, align 8
  %242 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %239)
  store ptr @Iterator, ptr %239, align 8
  %243 = alloca [2 x ptr], align 8
  store ptr %226, ptr %243, align 8
  %244 = getelementptr inbounds i8, ptr %243, i64 8
  store ptr %239, ptr %244, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %243)
  %246 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 8 dereferenceable(152) @ZipIterator)
  %247 = load ptr, ptr getelementptr inbounds (i8, ptr @ZipIterator, i64 120), align 8
  %248 = alloca { ptr, ptr }, align 8
  store ptr %191, ptr %248, align 8
  %249 = getelementptr inbounds i8, ptr %248, i64 8
  store ptr %207, ptr %249, align 8
  %250 = call ptr @behavior_wrapper(ptr %247, { ptr, ptr, ptr, i32 } %217, ptr noundef nonnull align 8 dereferenceable(16) %248)
  call void %250({ ptr, ptr, ptr, i32 } %217, { ptr, ptr, ptr, i32 } %217, ptr nonnull %243, { ptr, ptr, ptr, i32 } %198, { ptr, ptr, ptr, i32 } %214) #39
  %251 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ZipIterator, ptr %251, align 8
  %252 = getelementptr inbounds i8, ptr %251, i64 8
  store ptr %117, ptr %252, align 8
  %253 = getelementptr inbounds i8, ptr %251, i64 16
  %254 = getelementptr inbounds i8, ptr %251, i64 24
  store i32 10, ptr %254, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %251, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %255 = load ptr, ptr %251, align 8
  %256 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %255, 0
  %257 = load ptr, ptr %252, align 8
  %258 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %257, 1
  %259 = load ptr, ptr %253, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } %258, ptr %259, 2
  %261 = load i32, ptr %254, align 8
  %262 = insertvalue { ptr, ptr, ptr, i32 } %260, i32 %261, 3
  ret { ptr, ptr, ptr, i32 } %262
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 136
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ZipIterator_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(176) @ZipIterator)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 32
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define { ptr, i160 } @ZipIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract28, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract30, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract34, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(176) @ZipIterator)
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %8, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %13)
  %15 = load i32, ptr %11, align 8
  %16 = sext i32 %15 to i64
  %17 = getelementptr ptr, ptr %13, i64 %16
  %18 = getelementptr i8, ptr %17, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call { ptr, ptr, ptr, i32 } %20(ptr %12) #31
  %22 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %21, 0
  store ptr %.fca.0.extract8, ptr %22, align 8
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %21, 1
  %.fca.1.gep11 = getelementptr inbounds i8, ptr %22, i64 8
  store ptr %.fca.1.extract10, ptr %.fca.1.gep11, align 8
  %.fca.2.extract12 = extractvalue { ptr, ptr, ptr, i32 } %21, 2
  %.fca.2.gep13 = getelementptr inbounds i8, ptr %22, i64 16
  store ptr %.fca.2.extract12, ptr %.fca.2.gep13, align 8
  %.fca.3.extract14 = extractvalue { ptr, ptr, ptr, i32 } %21, 3
  %.fca.3.gep15 = getelementptr inbounds i8, ptr %22, i64 24
  store i32 %.fca.3.extract14, ptr %.fca.3.gep15, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %22, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %23 = load ptr, ptr %22, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %23, 0
  %25 = load ptr, ptr %.fca.1.gep11, align 8
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %25, 1
  %27 = load ptr, ptr %.fca.2.gep13, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %27, 2
  %29 = load i32, ptr %.fca.3.gep15, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %29, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %23)
  %33 = sext i32 %29 to i64
  %34 = getelementptr ptr, ptr %23, i64 %33
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = call ptr @behavior_wrapper(ptr %36, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 %4)
  %38 = call { ptr, i160 } %37({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 %4) #39
  %.fca.0.extract4 = extractvalue { ptr, i160 } %38, 0
  %39 = load ptr, ptr %9, align 8
  %40 = load ptr, ptr %8, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %40)
  %42 = load i32, ptr %11, align 8
  %43 = sext i32 %42 to i64
  %44 = getelementptr ptr, ptr %40, i64 %43
  %45 = getelementptr i8, ptr %44, i64 32
  %46 = load ptr, ptr %45, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr, ptr, ptr, i32 } %47(ptr %39) #31
  %49 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %48, 0
  store ptr %.fca.0.extract2, ptr %49, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %48, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %49, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %48, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %49, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %48, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %49, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %49, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %50 = load ptr, ptr %49, align 8
  %51 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %50, 0
  %52 = load ptr, ptr %.fca.1.gep, align 8
  %53 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %52, 1
  %54 = load ptr, ptr %.fca.2.gep, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %54, 2
  %56 = load i32, ptr %.fca.3.gep, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 %56, 3
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %50)
  %60 = sext i32 %56 to i64
  %61 = getelementptr ptr, ptr %50, i64 %60
  %62 = getelementptr i8, ptr %61, i64 8
  %63 = load ptr, ptr %62, align 8
  %64 = call ptr @behavior_wrapper(ptr %63, { ptr, ptr, ptr, i32 } %57, ptr noundef nonnull align 8 %4)
  %65 = call { ptr, i160 } %64({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %65, 0
  %66 = load ptr, ptr %9, align 8
  %67 = load ptr, ptr %8, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %67)
  %69 = load i32, ptr %11, align 8
  %70 = sext i32 %69 to i64
  %71 = getelementptr ptr, ptr %67, i64 %70
  %72 = load ptr, ptr %71, align 8
  %73 = call ptr @typegetter_wrapper(ptr %72, ptr %66)
  %74 = icmp ne ptr %.fca.0.extract4, @nil_typ
  %75 = icmp ne ptr %.fca.0.extract4, null
  %.not55 = and i1 %74, %75
  br i1 %.not55, label %76, label %139

76:                                               ; preds = %3
  %77 = load ptr, ptr %9, align 8
  %78 = load ptr, ptr %8, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %78)
  %80 = load i32, ptr %11, align 8
  %81 = sext i32 %80 to i64
  %82 = getelementptr ptr, ptr %78, i64 %81
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = load ptr, ptr %83, align 8
  %85 = call ptr @typegetter_wrapper(ptr %84, ptr %77)
  %86 = icmp ne ptr %.fca.0.extract, @nil_typ
  %87 = icmp ne ptr %.fca.0.extract, null
  %.not57.not.not = and i1 %86, %87
  br i1 %.not57.not.not, label %88, label %139

88:                                               ; preds = %76
  %89 = load ptr, ptr %9, align 8
  %90 = load ptr, ptr %8, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %90)
  %92 = load i32, ptr %11, align 8
  %93 = sext i32 %92 to i64
  %94 = getelementptr ptr, ptr %90, i64 %93
  %95 = load ptr, ptr %94, align 8
  %96 = call ptr @typegetter_wrapper(ptr %95, ptr %89)
  %97 = load ptr, ptr %9, align 8
  %98 = load ptr, ptr %8, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %98)
  %100 = load i32, ptr %11, align 8
  %101 = sext i32 %100 to i64
  %102 = getelementptr ptr, ptr %98, i64 %101
  %103 = getelementptr i8, ptr %102, i64 8
  %104 = load ptr, ptr %103, align 8
  %105 = call ptr @typegetter_wrapper(ptr %104, ptr %97)
  store ptr @Pair, ptr %5, align 8
  %106 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %96, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %105, ptr %107, align 8
  %108 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Pair, ptr noundef nonnull align 8 dereferenceable(24) %5)
  %109 = extractvalue { i64, i64 } %108, 0
  %110 = call ptr @bump_malloc(i64 %109)
  store ptr %96, ptr %110, align 8
  %111 = getelementptr i8, ptr %110, i64 8
  store ptr %105, ptr %111, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %110)
  %113 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %110, 1
  %114 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr undef, 2
  %115 = insertvalue { ptr, ptr, ptr, i32 } %114, i32 10, 3
  %116 = load ptr, ptr %9, align 8
  %117 = load ptr, ptr %8, align 8
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %117)
  %119 = load i32, ptr %11, align 8
  %120 = sext i32 %119 to i64
  %121 = getelementptr ptr, ptr %117, i64 %120
  %122 = load ptr, ptr %121, align 8
  %123 = call ptr @typegetter_wrapper(ptr %122, ptr %116)
  %124 = load ptr, ptr %9, align 8
  %125 = load ptr, ptr %8, align 8
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %125)
  %127 = load i32, ptr %11, align 8
  %128 = sext i32 %127 to i64
  %129 = getelementptr ptr, ptr %125, i64 %128
  %130 = getelementptr i8, ptr %129, i64 8
  %131 = load ptr, ptr %130, align 8
  %132 = call ptr @typegetter_wrapper(ptr %131, ptr %124)
  store ptr %123, ptr %6, align 8
  %133 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %132, ptr %133, align 8
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @Pair)
  store ptr %.fca.0.extract4, ptr %7, align 8
  %136 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.0.extract, ptr %136, align 8
  %137 = call ptr @behavior_wrapper(ptr noundef nonnull @Pair_B_init_firstT_secondU, { ptr, ptr, ptr, i32 } %115, ptr noundef nonnull align 8 dereferenceable(16) %7)
  call void %137({ ptr, ptr, ptr, i32 } %115, { ptr, ptr, ptr, i32 } %115, ptr nonnull %6, { ptr, i160 } %38, { ptr, i160 } %65) #39
  %138 = ptrtoint ptr %110 to i64
  %.sroa.344.8.insert.ext = zext i64 %138 to i160
  %.sroa.344.8.insert.insert = or disjoint i160 %.sroa.344.8.insert.ext, 3402823669209384634633746074317682114560
  br label %139

139:                                              ; preds = %88, %76, %3
  %.reg2mem41.sroa.3.0 = phi i160 [ %.sroa.344.8.insert.insert, %88 ], [ poison, %3 ], [ poison, %76 ]
  %.reg2mem39.0 = phi ptr [ @Pair, %88 ], [ @nil_typ, %3 ], [ @nil_typ, %76 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem39.0, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem41.sroa.3.0, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #5

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZippedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @ZipIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 224
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 9197944775169318296, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 248
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ZipIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ZipIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ZipIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 312
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ZipIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 320
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @ZipIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(528) @ZipIterable)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 32
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @ZipIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract77 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract71, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract73, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract75, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract77, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(528) @ZipIterable)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract63, ptr %19, align 8
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep66 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract65, ptr %.fca.1.gep66, align 8
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep68 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract67, ptr %.fca.2.gep68, align 8
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep70 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract69, ptr %.fca.3.gep70, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep66, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep68, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep70, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract51, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract53, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract55, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract57, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 32
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %40) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract43, ptr %50, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %.fca.1.gep46, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %.fca.2.gep48, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %.fca.3.gep50, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %51)
  %61 = sext i32 %57 to i64
  %62 = getelementptr ptr, ptr %51, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %4) #39
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %66, 3
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %.fca.1.extract33, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr %.fca.2.extract35, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %67, i64 24
  store i32 %.fca.3.extract37, ptr %70, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %67, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %71 = load ptr, ptr %6, align 8
  %72 = load ptr, ptr %5, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %8, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = load ptr, ptr %76, align 8
  %78 = call ptr @typegetter_wrapper(ptr %77, ptr %71)
  %79 = load ptr, ptr %6, align 8
  %80 = load ptr, ptr %5, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %80)
  %82 = load i32, ptr %8, align 8
  %83 = sext i32 %82 to i64
  %84 = getelementptr ptr, ptr %80, i64 %83
  %85 = getelementptr i8, ptr %84, i64 8
  %86 = load ptr, ptr %85, align 8
  %87 = call ptr @typegetter_wrapper(ptr %86, ptr %79)
  %88 = load ptr, ptr %6, align 8
  %89 = load ptr, ptr %5, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %89)
  %91 = load i32, ptr %8, align 8
  %92 = sext i32 %91 to i64
  %93 = getelementptr ptr, ptr %89, i64 %92
  %94 = load ptr, ptr %93, align 8
  %95 = call ptr @typegetter_wrapper(ptr %94, ptr %88)
  %96 = load ptr, ptr %6, align 8
  %97 = load ptr, ptr %5, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %97)
  %99 = load i32, ptr %8, align 8
  %100 = sext i32 %99 to i64
  %101 = getelementptr ptr, ptr %97, i64 %100
  %102 = getelementptr i8, ptr %101, i64 8
  %103 = load ptr, ptr %102, align 8
  %104 = call ptr @typegetter_wrapper(ptr %103, ptr %96)
  %105 = call ptr @bump_malloc(i64 noundef 32)
  %106 = getelementptr i8, ptr %105, i64 16
  store ptr %104, ptr %106, align 8
  %107 = getelementptr i8, ptr %105, i64 8
  store ptr %95, ptr %107, align 8
  %108 = getelementptr i8, ptr %105, i64 24
  store ptr null, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %105)
  store ptr @Pair, ptr %105, align 8
  %110 = alloca [4 x ptr], align 8
  store ptr @ZipIterator, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr %78, ptr %111, align 8
  %112 = getelementptr inbounds i8, ptr %110, i64 16
  store ptr %87, ptr %112, align 8
  %113 = getelementptr inbounds i8, ptr %110, i64 24
  store ptr %105, ptr %113, align 8
  %114 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_ZipIterator, ptr noundef nonnull align 8 dereferenceable(32) %110)
  %115 = extractvalue { i64, i64 } %114, 0
  %116 = call ptr @bump_malloc(i64 %115)
  store ptr %78, ptr %116, align 8
  %117 = getelementptr i8, ptr %116, i64 8
  store ptr %87, ptr %117, align 8
  %118 = getelementptr i8, ptr %116, i64 16
  store ptr %105, ptr %118, align 8
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %116)
  %120 = load ptr, ptr %6, align 8
  %121 = load ptr, ptr %5, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %121)
  %123 = load i32, ptr %8, align 8
  %124 = sext i32 %123 to i64
  %125 = getelementptr ptr, ptr %121, i64 %124
  %126 = getelementptr i8, ptr %125, i64 24
  %127 = load ptr, ptr %126, align 8
  %128 = load ptr, ptr %127, align 8
  %129 = call { ptr, ptr, ptr, i32 } %128(ptr %120) #31
  %130 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %129, 0
  store ptr %.fca.0.extract17, ptr %130, align 8
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %129, 1
  %.fca.1.gep20 = getelementptr inbounds i8, ptr %130, i64 8
  store ptr %.fca.1.extract19, ptr %.fca.1.gep20, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %129, 2
  %.fca.2.gep22 = getelementptr inbounds i8, ptr %130, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep22, align 8
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %129, 3
  %.fca.3.gep24 = getelementptr inbounds i8, ptr %130, i64 24
  store i32 %.fca.3.extract23, ptr %.fca.3.gep24, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %130, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %131 = load ptr, ptr %130, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %131, 0
  %133 = load ptr, ptr %.fca.1.gep20, align 8
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr %133, 1
  %135 = load ptr, ptr %.fca.2.gep22, align 8
  %136 = insertvalue { ptr, ptr, ptr, i32 } %134, ptr %135, 2
  %137 = load i32, ptr %.fca.3.gep24, align 8
  %138 = insertvalue { ptr, ptr, ptr, i32 } %136, i32 %137, 3
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %131)
  %141 = sext i32 %137 to i64
  %142 = getelementptr ptr, ptr %131, i64 %141
  %143 = getelementptr i8, ptr %142, i64 8
  %144 = load ptr, ptr %143, align 8
  %145 = call ptr @behavior_wrapper(ptr %144, { ptr, ptr, ptr, i32 } %138, ptr noundef nonnull align 8 %4)
  %146 = call { ptr, ptr, ptr, i32 } %145({ ptr, ptr, ptr, i32 } %138, { ptr, ptr, ptr, i32 } %138, ptr nonnull align 8 %4) #39
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %146, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %146, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %146, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %146, 3
  %147 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %147, align 8
  %148 = getelementptr inbounds i8, ptr %147, i64 8
  store ptr %.fca.1.extract7, ptr %148, align 8
  %149 = getelementptr inbounds i8, ptr %147, i64 16
  store ptr %.fca.2.extract9, ptr %149, align 8
  %150 = getelementptr inbounds i8, ptr %147, i64 24
  store i32 %.fca.3.extract11, ptr %150, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %147, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %151 = load ptr, ptr %6, align 8
  %152 = load ptr, ptr %5, align 8
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %152)
  %154 = load i32, ptr %8, align 8
  %155 = sext i32 %154 to i64
  %156 = getelementptr ptr, ptr %152, i64 %155
  %157 = getelementptr i8, ptr %156, i64 32
  %158 = load ptr, ptr %157, align 8
  %159 = load ptr, ptr %158, align 8
  %160 = call { ptr, ptr, ptr, i32 } %159(ptr %151) #31
  %161 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %160, 0
  store ptr %.fca.0.extract1, ptr %161, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %160, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %161, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %160, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %161, i64 16
  store ptr %.fca.2.extract3, ptr %.fca.2.gep, align 8
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %160, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %161, i64 24
  store i32 %.fca.3.extract4, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %161, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %162 = load ptr, ptr %161, align 8
  %163 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %162, 0
  %164 = load ptr, ptr %.fca.1.gep, align 8
  %165 = insertvalue { ptr, ptr, ptr, i32 } %163, ptr %164, 1
  %166 = load ptr, ptr %.fca.2.gep, align 8
  %167 = insertvalue { ptr, ptr, ptr, i32 } %165, ptr %166, 2
  %168 = load i32, ptr %.fca.3.gep, align 8
  %169 = insertvalue { ptr, ptr, ptr, i32 } %167, i32 %168, 3
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %162)
  %172 = sext i32 %168 to i64
  %173 = getelementptr ptr, ptr %162, i64 %172
  %174 = getelementptr i8, ptr %173, i64 8
  %175 = load ptr, ptr %174, align 8
  %176 = call ptr @behavior_wrapper(ptr %175, { ptr, ptr, ptr, i32 } %169, ptr noundef nonnull align 8 %4)
  %177 = call { ptr, ptr, ptr, i32 } %176({ ptr, ptr, ptr, i32 } %169, { ptr, ptr, ptr, i32 } %169, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %177, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %177, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %177, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %177, 3
  %178 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %178, align 8
  %179 = getelementptr inbounds i8, ptr %178, i64 8
  store ptr %.fca.1.extract, ptr %179, align 8
  %180 = getelementptr inbounds i8, ptr %178, i64 16
  store ptr %.fca.2.extract, ptr %180, align 8
  %181 = getelementptr inbounds i8, ptr %178, i64 24
  store i32 %.fca.3.extract, ptr %181, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %178, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %182 = alloca { ptr, ptr, ptr, i32 }, align 8
  %183 = load ptr, ptr %147, align 8
  store ptr %183, ptr %182, align 8
  %184 = getelementptr inbounds i8, ptr %182, i64 8
  %185 = load ptr, ptr %148, align 8
  store ptr %185, ptr %184, align 8
  %186 = getelementptr inbounds i8, ptr %182, i64 16
  %187 = load ptr, ptr %149, align 8
  store ptr %187, ptr %186, align 8
  %188 = getelementptr inbounds i8, ptr %182, i64 24
  %189 = load i32, ptr %150, align 8
  store i32 %189, ptr %188, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %182, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %190 = load ptr, ptr %182, align 8
  %191 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %190, 0
  %192 = load ptr, ptr %184, align 8
  %193 = insertvalue { ptr, ptr, ptr, i32 } %191, ptr %192, 1
  %194 = load ptr, ptr %186, align 8
  %195 = insertvalue { ptr, ptr, ptr, i32 } %193, ptr %194, 2
  %196 = load i32, ptr %188, align 8
  %197 = insertvalue { ptr, ptr, ptr, i32 } %195, i32 %196, 3
  %198 = alloca { ptr, ptr, ptr, i32 }, align 8
  %199 = load ptr, ptr %178, align 8
  store ptr %199, ptr %198, align 8
  %200 = getelementptr inbounds i8, ptr %198, i64 8
  %201 = load ptr, ptr %179, align 8
  store ptr %201, ptr %200, align 8
  %202 = getelementptr inbounds i8, ptr %198, i64 16
  %203 = load ptr, ptr %180, align 8
  store ptr %203, ptr %202, align 8
  %204 = getelementptr inbounds i8, ptr %198, i64 24
  %205 = load i32, ptr %181, align 8
  store i32 %205, ptr %204, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %198, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %206 = load ptr, ptr %198, align 8
  %207 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %206, 0
  %208 = load ptr, ptr %200, align 8
  %209 = insertvalue { ptr, ptr, ptr, i32 } %207, ptr %208, 1
  %210 = load ptr, ptr %202, align 8
  %211 = insertvalue { ptr, ptr, ptr, i32 } %209, ptr %210, 2
  %212 = load i32, ptr %204, align 8
  %213 = insertvalue { ptr, ptr, ptr, i32 } %211, i32 %212, 3
  %214 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %116, 1
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr undef, 2
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, i32 10, 3
  %217 = load ptr, ptr %6, align 8
  %218 = load ptr, ptr %5, align 8
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %218)
  %220 = load i32, ptr %8, align 8
  %221 = sext i32 %220 to i64
  %222 = getelementptr ptr, ptr %218, i64 %221
  %223 = load ptr, ptr %222, align 8
  %224 = call ptr @typegetter_wrapper(ptr %223, ptr %217)
  %225 = call ptr @bump_malloc(i64 noundef 24)
  %226 = getelementptr i8, ptr %225, i64 8
  store ptr %224, ptr %226, align 8
  %227 = getelementptr i8, ptr %225, i64 16
  store ptr null, ptr %227, align 8
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %225)
  store ptr @Iterator, ptr %225, align 8
  %229 = load ptr, ptr %6, align 8
  %230 = load ptr, ptr %5, align 8
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 448, ptr nocapture nofree noundef %230)
  %232 = load i32, ptr %8, align 8
  %233 = sext i32 %232 to i64
  %234 = getelementptr ptr, ptr %230, i64 %233
  %235 = getelementptr i8, ptr %234, i64 8
  %236 = load ptr, ptr %235, align 8
  %237 = call ptr @typegetter_wrapper(ptr %236, ptr %229)
  %238 = call ptr @bump_malloc(i64 noundef 24)
  %239 = getelementptr i8, ptr %238, i64 8
  store ptr %237, ptr %239, align 8
  %240 = getelementptr i8, ptr %238, i64 16
  store ptr null, ptr %240, align 8
  %241 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %238)
  store ptr @Iterator, ptr %238, align 8
  %242 = alloca [2 x ptr], align 8
  store ptr %225, ptr %242, align 8
  %243 = getelementptr inbounds i8, ptr %242, i64 8
  store ptr %238, ptr %243, align 8
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %242)
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull align 16 dereferenceable(176) @ZipIterator)
  %246 = alloca { ptr, ptr }, align 8
  store ptr %190, ptr %246, align 8
  %247 = getelementptr inbounds i8, ptr %246, i64 8
  store ptr %206, ptr %247, align 8
  %248 = call ptr @behavior_wrapper(ptr noundef nonnull @ZipIterator_B_init_firstIteratorT_secondIteratorU, { ptr, ptr, ptr, i32 } %216, ptr noundef nonnull align 8 dereferenceable(16) %246)
  call void %248({ ptr, ptr, ptr, i32 } %216, { ptr, ptr, ptr, i32 } %216, ptr nonnull %242, { ptr, ptr, ptr, i32 } %197, { ptr, ptr, ptr, i32 } %213) #39
  %249 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ZipIterator, ptr %249, align 8
  %250 = getelementptr inbounds i8, ptr %249, i64 8
  store ptr %116, ptr %250, align 8
  %251 = getelementptr inbounds i8, ptr %249, i64 16
  %252 = getelementptr inbounds i8, ptr %249, i64 24
  store i32 10, ptr %252, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %249, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %253 = load ptr, ptr %249, align 8
  %254 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %253, 0
  %255 = load ptr, ptr %250, align 8
  %256 = insertvalue { ptr, ptr, ptr, i32 } %254, ptr %255, 1
  %257 = load ptr, ptr %251, align 8
  %258 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %257, 2
  %259 = load i32, ptr %252, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } %258, i32 %259, 3
  ret { ptr, ptr, ptr, i32 } %260
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

define ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 208
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterable_field_InterleaveIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 232
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InterleaveIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 280
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @InterleaveIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @InterleaveIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @InterleaveIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @InterleaveIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(512) @InterleaveIterable)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 16
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @InterleaveIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract77 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract71, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract73, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract75, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract77, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(512) @InterleaveIterable)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract63, ptr %19, align 8
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep66 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract65, ptr %.fca.1.gep66, align 8
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep68 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract67, ptr %.fca.2.gep68, align 8
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep70 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract69, ptr %.fca.3.gep70, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep66, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep68, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep70, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract51, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract53, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract55, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract57, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 16
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %40) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract43, ptr %50, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %.fca.1.gep46, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %.fca.2.gep48, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %.fca.3.gep50, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %51)
  %61 = sext i32 %57 to i64
  %62 = getelementptr ptr, ptr %51, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %4) #39
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %66, 3
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %.fca.1.extract33, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr %.fca.2.extract35, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %67, i64 24
  store i32 %.fca.3.extract37, ptr %70, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %67, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %71 = load ptr, ptr %6, align 8
  %72 = load ptr, ptr %5, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %8, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = load ptr, ptr %76, align 8
  %78 = call ptr @typegetter_wrapper(ptr %77, ptr %71)
  %79 = alloca [2 x ptr], align 8
  store ptr @InterleaveIterator, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr %78, ptr %80, align 8
  %81 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_InterleaveIterator, ptr noundef nonnull align 8 dereferenceable(16) %79)
  %82 = extractvalue { i64, i64 } %81, 0
  %83 = call ptr @bump_malloc(i64 %82)
  store ptr %78, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %83)
  %85 = load ptr, ptr %6, align 8
  %86 = load ptr, ptr %5, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %86)
  %88 = load i32, ptr %8, align 8
  %89 = sext i32 %88 to i64
  %90 = getelementptr ptr, ptr %86, i64 %89
  %91 = getelementptr i8, ptr %90, i64 8
  %92 = load ptr, ptr %91, align 8
  %93 = load ptr, ptr %92, align 8
  %94 = call { ptr, ptr, ptr, i32 } %93(ptr %85) #31
  %95 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %94, 0
  store ptr %.fca.0.extract17, ptr %95, align 8
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %94, 1
  %.fca.1.gep20 = getelementptr inbounds i8, ptr %95, i64 8
  store ptr %.fca.1.extract19, ptr %.fca.1.gep20, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %94, 2
  %.fca.2.gep22 = getelementptr inbounds i8, ptr %95, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep22, align 8
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %94, 3
  %.fca.3.gep24 = getelementptr inbounds i8, ptr %95, i64 24
  store i32 %.fca.3.extract23, ptr %.fca.3.gep24, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %95, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %96 = load ptr, ptr %95, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %96, 0
  %98 = load ptr, ptr %.fca.1.gep20, align 8
  %99 = insertvalue { ptr, ptr, ptr, i32 } %97, ptr %98, 1
  %100 = load ptr, ptr %.fca.2.gep22, align 8
  %101 = insertvalue { ptr, ptr, ptr, i32 } %99, ptr %100, 2
  %102 = load i32, ptr %.fca.3.gep24, align 8
  %103 = insertvalue { ptr, ptr, ptr, i32 } %101, i32 %102, 3
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %96)
  %106 = sext i32 %102 to i64
  %107 = getelementptr ptr, ptr %96, i64 %106
  %108 = getelementptr i8, ptr %107, i64 8
  %109 = load ptr, ptr %108, align 8
  %110 = call ptr @behavior_wrapper(ptr %109, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 %4)
  %111 = call { ptr, ptr, ptr, i32 } %110({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull align 8 %4) #39
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %111, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %111, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %111, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %111, 3
  %112 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %112, align 8
  %113 = getelementptr inbounds i8, ptr %112, i64 8
  store ptr %.fca.1.extract7, ptr %113, align 8
  %114 = getelementptr inbounds i8, ptr %112, i64 16
  store ptr %.fca.2.extract9, ptr %114, align 8
  %115 = getelementptr inbounds i8, ptr %112, i64 24
  store i32 %.fca.3.extract11, ptr %115, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %112, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %116 = load ptr, ptr %6, align 8
  %117 = load ptr, ptr %5, align 8
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %117)
  %119 = load i32, ptr %8, align 8
  %120 = sext i32 %119 to i64
  %121 = getelementptr ptr, ptr %117, i64 %120
  %122 = getelementptr i8, ptr %121, i64 16
  %123 = load ptr, ptr %122, align 8
  %124 = load ptr, ptr %123, align 8
  %125 = call { ptr, ptr, ptr, i32 } %124(ptr %116) #31
  %126 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %125, 0
  store ptr %.fca.0.extract1, ptr %126, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %125, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %126, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %125, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %126, i64 16
  store ptr %.fca.2.extract3, ptr %.fca.2.gep, align 8
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %125, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %126, i64 24
  store i32 %.fca.3.extract4, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %126, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %127 = load ptr, ptr %126, align 8
  %128 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %127, 0
  %129 = load ptr, ptr %.fca.1.gep, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %129, 1
  %131 = load ptr, ptr %.fca.2.gep, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 2
  %133 = load i32, ptr %.fca.3.gep, align 8
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, i32 %133, 3
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %127)
  %137 = sext i32 %133 to i64
  %138 = getelementptr ptr, ptr %127, i64 %137
  %139 = getelementptr i8, ptr %138, i64 8
  %140 = load ptr, ptr %139, align 8
  %141 = call ptr @behavior_wrapper(ptr %140, { ptr, ptr, ptr, i32 } %134, ptr noundef nonnull align 8 %4)
  %142 = call { ptr, ptr, ptr, i32 } %141({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } %134, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %142, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %142, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %142, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %142, 3
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %143, align 8
  %144 = getelementptr inbounds i8, ptr %143, i64 8
  store ptr %.fca.1.extract, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %143, i64 16
  store ptr %.fca.2.extract, ptr %145, align 8
  %146 = getelementptr inbounds i8, ptr %143, i64 24
  store i32 %.fca.3.extract, ptr %146, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %143, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %147 = alloca { ptr, ptr, ptr, i32 }, align 8
  %148 = load ptr, ptr %112, align 8
  store ptr %148, ptr %147, align 8
  %149 = getelementptr inbounds i8, ptr %147, i64 8
  %150 = load ptr, ptr %113, align 8
  store ptr %150, ptr %149, align 8
  %151 = getelementptr inbounds i8, ptr %147, i64 16
  %152 = load ptr, ptr %114, align 8
  store ptr %152, ptr %151, align 8
  %153 = getelementptr inbounds i8, ptr %147, i64 24
  %154 = load i32, ptr %115, align 8
  store i32 %154, ptr %153, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %147, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %155 = load ptr, ptr %147, align 8
  %156 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %155, 0
  %157 = load ptr, ptr %149, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } %156, ptr %157, 1
  %159 = load ptr, ptr %151, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %159, 2
  %161 = load i32, ptr %153, align 8
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, i32 %161, 3
  %163 = alloca { ptr, ptr, ptr, i32 }, align 8
  %164 = load ptr, ptr %143, align 8
  store ptr %164, ptr %163, align 8
  %165 = getelementptr inbounds i8, ptr %163, i64 8
  %166 = load ptr, ptr %144, align 8
  store ptr %166, ptr %165, align 8
  %167 = getelementptr inbounds i8, ptr %163, i64 16
  %168 = load ptr, ptr %145, align 8
  store ptr %168, ptr %167, align 8
  %169 = getelementptr inbounds i8, ptr %163, i64 24
  %170 = load i32, ptr %146, align 8
  store i32 %170, ptr %169, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %163, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %171 = load ptr, ptr %163, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %171, 0
  %173 = load ptr, ptr %165, align 8
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, ptr %173, 1
  %175 = load ptr, ptr %167, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } %174, ptr %175, 2
  %177 = load i32, ptr %169, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, i32 %177, 3
  %179 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %83, 1
  %180 = insertvalue { ptr, ptr, ptr, i32 } %179, ptr undef, 2
  %181 = insertvalue { ptr, ptr, ptr, i32 } %180, i32 10, 3
  %182 = load ptr, ptr %6, align 8
  %183 = load ptr, ptr %5, align 8
  %184 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %183)
  %185 = load i32, ptr %8, align 8
  %186 = sext i32 %185 to i64
  %187 = getelementptr ptr, ptr %183, i64 %186
  %188 = load ptr, ptr %187, align 8
  %189 = call ptr @typegetter_wrapper(ptr %188, ptr %182)
  %190 = call ptr @bump_malloc(i64 noundef 24)
  %191 = getelementptr i8, ptr %190, i64 8
  store ptr %189, ptr %191, align 8
  %192 = getelementptr i8, ptr %190, i64 16
  store ptr null, ptr %192, align 8
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %190)
  store ptr @Iterator, ptr %190, align 8
  %194 = load ptr, ptr %6, align 8
  %195 = load ptr, ptr %5, align 8
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %195)
  %197 = load i32, ptr %8, align 8
  %198 = sext i32 %197 to i64
  %199 = getelementptr ptr, ptr %195, i64 %198
  %200 = load ptr, ptr %199, align 8
  %201 = call ptr @typegetter_wrapper(ptr %200, ptr %194)
  %202 = call ptr @bump_malloc(i64 noundef 24)
  %203 = getelementptr i8, ptr %202, i64 8
  store ptr %201, ptr %203, align 8
  %204 = getelementptr i8, ptr %202, i64 16
  store ptr null, ptr %204, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %202)
  store ptr @Iterator, ptr %202, align 8
  %206 = alloca [2 x ptr], align 8
  store ptr %190, ptr %206, align 8
  %207 = getelementptr inbounds i8, ptr %206, i64 8
  store ptr %202, ptr %207, align 8
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %206)
  %209 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @InterleaveIterator)
  %210 = alloca { ptr, ptr }, align 8
  store ptr %155, ptr %210, align 8
  %211 = getelementptr inbounds i8, ptr %210, i64 8
  store ptr %171, ptr %211, align 8
  %212 = call ptr @behavior_wrapper(ptr noundef nonnull @InterleaveIterator_B_init_firstIteratorT_secondIteratorT, { ptr, ptr, ptr, i32 } %181, ptr noundef nonnull align 8 dereferenceable(16) %210)
  call void %212({ ptr, ptr, ptr, i32 } %181, { ptr, ptr, ptr, i32 } %181, ptr nonnull %206, { ptr, ptr, ptr, i32 } %162, { ptr, ptr, ptr, i32 } %178) #39
  %213 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @InterleaveIterator, ptr %213, align 8
  %214 = getelementptr inbounds i8, ptr %213, i64 8
  store ptr %83, ptr %214, align 8
  %215 = getelementptr inbounds i8, ptr %213, i64 16
  %216 = getelementptr inbounds i8, ptr %213, i64 24
  store i32 10, ptr %216, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %213, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %217 = load ptr, ptr %213, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %217, 0
  %219 = load ptr, ptr %214, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %219, 1
  %221 = load ptr, ptr %215, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 2
  %223 = load i32, ptr %216, align 8
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, i32 %223, 3
  ret { ptr, ptr, ptr, i32 } %224
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

define ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 128
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterator_field_InterleaveIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @InterleaveIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(168) @InterleaveIterator)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 16
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  %70 = load ptr, ptr %7, align 8
  %71 = load ptr, ptr %6, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %71)
  %73 = load i32, ptr %9, align 8
  %74 = sext i32 %73 to i64
  %75 = getelementptr ptr, ptr %71, i64 %74
  %76 = getelementptr i8, ptr %75, i64 24
  %77 = load ptr, ptr %76, align 8
  %78 = getelementptr i8, ptr %77, i64 8
  %79 = load ptr, ptr %78, align 8
  call void %79(ptr %70, i1 true) #30
  ret void
}

define { ptr, i160 } @InterleaveIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract4, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(168) @InterleaveIterator)
  %11 = load ptr, ptr %8, align 8
  %12 = load ptr, ptr %7, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %12)
  %14 = load i32, ptr %10, align 8
  %15 = sext i32 %14 to i64
  %16 = getelementptr ptr, ptr %12, i64 %15
  %17 = getelementptr i8, ptr %16, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i1 %19(ptr %11) #31
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %12)
  %22 = getelementptr i8, ptr %18, i64 8
  %23 = load ptr, ptr %22, align 8
  %not. = xor i1 %20, true
  %.68 = select i1 %20, i64 8, i64 16
  %.69 = select i1 %20, ptr %5, ptr %6
  call void %23(ptr %11, i1 %not.) #30
  %24 = load ptr, ptr %8, align 8
  %25 = load ptr, ptr %7, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %25)
  %27 = load i32, ptr %10, align 8
  %28 = sext i32 %27 to i64
  %29 = getelementptr ptr, ptr %25, i64 %28
  %30 = getelementptr i8, ptr %29, i64 %.68
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr, ptr, ptr, i32 } %32(ptr %24) #31
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  store ptr %.fca.0.extract9, ptr %.69, align 8
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.69.sroa.sel.v = select i1 %20, ptr %5, ptr %6
  %.69.sroa.sel = getelementptr inbounds i8, ptr %.69.sroa.sel.v, i64 8
  store ptr %.fca.1.extract10, ptr %.69.sroa.sel, align 8
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %.69.sroa.sel73.v = select i1 %20, ptr %5, ptr %6
  %.69.sroa.sel73 = getelementptr inbounds i8, ptr %.69.sroa.sel73.v, i64 16
  store ptr %.fca.2.extract11, ptr %.69.sroa.sel73, align 8
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  %.69.sroa.sel76.v = select i1 %20, ptr %5, ptr %6
  %.69.sroa.sel76 = getelementptr inbounds i8, ptr %.69.sroa.sel76.v, i64 24
  store i32 %.fca.3.extract12, ptr %.69.sroa.sel76, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %.69, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %34 = load ptr, ptr %.69, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %34, 0
  %36 = load ptr, ptr %.69.sroa.sel, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 1
  %38 = load ptr, ptr %.69.sroa.sel73, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 2
  %40 = load i32, ptr %.69.sroa.sel76, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %40, 3
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %34)
  %44 = sext i32 %40 to i64
  %45 = getelementptr ptr, ptr %34, i64 %44
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  %48 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr noundef nonnull align 8 %4)
  %49 = call { ptr, i160 } %48({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull %4) #39
  ret { ptr, i160 } %49
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @InterleaveIterator_getter_on_first(ptr nocapture nofree readonly %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleavedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

define ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 216
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleavedCollection_field_InterleavedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 248
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 25, i64 26
  %8 = getelementptr [118 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @InterleavedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 29, %.critedge ], [ 28, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 30, %.critedge ], [ 31, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 32, %21 ], [ 32, %14 ], [ 33, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [118 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 35, %.critedge ], [ 34, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define void @InterleavedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1024) @InterleavedCollection)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 16
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define i32 @InterleavedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract13, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract15, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract17, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1024) @InterleavedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract3, ptr %19, align 8
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep6 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract5, ptr %.fca.1.gep6, align 8
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep8 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract7, ptr %.fca.2.gep8, align 8
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep10 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract9, ptr %.fca.3.gep10, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep6, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep8, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep10, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %36 = load ptr, ptr %6, align 8
  %37 = load ptr, ptr %5, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %37)
  %39 = load i32, ptr %8, align 8
  %40 = sext i32 %39 to i64
  %41 = getelementptr ptr, ptr %37, i64 %40
  %42 = getelementptr i8, ptr %41, i64 16
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %36) #31
  %46 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  store ptr %.fca.0.extract, ptr %46, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %46, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %46, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %46, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %46, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %49 = load ptr, ptr %.fca.1.gep, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 1
  %51 = load ptr, ptr %.fca.2.gep, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %51, 2
  %53 = load i32, ptr %.fca.3.gep, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %53, 3
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %47)
  %57 = sext i32 %53 to i64
  %58 = getelementptr ptr, ptr %47, i64 %57
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = call ptr @behavior_wrapper(ptr %60, { ptr, ptr, ptr, i32 } %54, ptr noundef nonnull align 8 %4)
  %62 = call i32 %61({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull %4) #39
  %63 = add i32 %62, %35
  ret i32 %63
}

define { ptr, ptr, ptr, i32 } @InterleavedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract77 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract71, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract73, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract75, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract77, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1024) @InterleavedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract63, ptr %19, align 8
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep66 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract65, ptr %.fca.1.gep66, align 8
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep68 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract67, ptr %.fca.2.gep68, align 8
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep70 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract69, ptr %.fca.3.gep70, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep66, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep68, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep70, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract51, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract53, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract55, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract57, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 16
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %40) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract43, ptr %50, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %.fca.1.gep46, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %.fca.2.gep48, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %.fca.3.gep50, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %51)
  %61 = sext i32 %57 to i64
  %62 = getelementptr ptr, ptr %51, i64 %61
  %63 = getelementptr i8, ptr %62, i64 16
  %64 = load ptr, ptr %63, align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %4) #39
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %66, 3
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %.fca.1.extract33, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr %.fca.2.extract35, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %67, i64 24
  store i32 %.fca.3.extract37, ptr %70, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %67, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %71 = load ptr, ptr %6, align 8
  %72 = load ptr, ptr %5, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %8, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = load ptr, ptr %76, align 8
  %78 = call ptr @typegetter_wrapper(ptr %77, ptr %71)
  %79 = alloca [2 x ptr], align 8
  store ptr @InterleaveIterator, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr %78, ptr %80, align 8
  %81 = load ptr, ptr getelementptr inbounds (i8, ptr @InterleaveIterator, i64 48), align 8
  %82 = call { i64, i64 } @size_wrapper(ptr %81, ptr noundef nonnull align 8 dereferenceable(16) %79)
  %83 = extractvalue { i64, i64 } %82, 0
  %84 = call ptr @bump_malloc(i64 %83)
  store ptr %78, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %84)
  %86 = load ptr, ptr %6, align 8
  %87 = load ptr, ptr %5, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %87)
  %89 = load i32, ptr %8, align 8
  %90 = sext i32 %89 to i64
  %91 = getelementptr ptr, ptr %87, i64 %90
  %92 = getelementptr i8, ptr %91, i64 8
  %93 = load ptr, ptr %92, align 8
  %94 = load ptr, ptr %93, align 8
  %95 = call { ptr, ptr, ptr, i32 } %94(ptr %86) #31
  %96 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %95, 0
  store ptr %.fca.0.extract17, ptr %96, align 8
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %95, 1
  %.fca.1.gep20 = getelementptr inbounds i8, ptr %96, i64 8
  store ptr %.fca.1.extract19, ptr %.fca.1.gep20, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %95, 2
  %.fca.2.gep22 = getelementptr inbounds i8, ptr %96, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep22, align 8
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %95, 3
  %.fca.3.gep24 = getelementptr inbounds i8, ptr %96, i64 24
  store i32 %.fca.3.extract23, ptr %.fca.3.gep24, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %96, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %97 = load ptr, ptr %96, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %.fca.1.gep20, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %.fca.2.gep22, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %.fca.3.gep24, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %97)
  %107 = sext i32 %103 to i64
  %108 = getelementptr ptr, ptr %97, i64 %107
  %109 = getelementptr i8, ptr %108, i64 16
  %110 = load ptr, ptr %109, align 8
  %111 = call ptr @behavior_wrapper(ptr %110, { ptr, ptr, ptr, i32 } %104, ptr noundef nonnull align 8 %4)
  %112 = call { ptr, ptr, ptr, i32 } %111({ ptr, ptr, ptr, i32 } %104, { ptr, ptr, ptr, i32 } %104, ptr nonnull align 8 %4) #39
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %112, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %112, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %112, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %112, 3
  %113 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %113, align 8
  %114 = getelementptr inbounds i8, ptr %113, i64 8
  store ptr %.fca.1.extract7, ptr %114, align 8
  %115 = getelementptr inbounds i8, ptr %113, i64 16
  store ptr %.fca.2.extract9, ptr %115, align 8
  %116 = getelementptr inbounds i8, ptr %113, i64 24
  store i32 %.fca.3.extract11, ptr %116, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %113, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %117 = load ptr, ptr %6, align 8
  %118 = load ptr, ptr %5, align 8
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %118)
  %120 = load i32, ptr %8, align 8
  %121 = sext i32 %120 to i64
  %122 = getelementptr ptr, ptr %118, i64 %121
  %123 = getelementptr i8, ptr %122, i64 16
  %124 = load ptr, ptr %123, align 8
  %125 = load ptr, ptr %124, align 8
  %126 = call { ptr, ptr, ptr, i32 } %125(ptr %117) #31
  %127 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %126, 0
  store ptr %.fca.0.extract1, ptr %127, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %126, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %127, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %126, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %127, i64 16
  store ptr %.fca.2.extract3, ptr %.fca.2.gep, align 8
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %126, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %127, i64 24
  store i32 %.fca.3.extract4, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %127, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %128 = load ptr, ptr %127, align 8
  %129 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %128, 0
  %130 = load ptr, ptr %.fca.1.gep, align 8
  %131 = insertvalue { ptr, ptr, ptr, i32 } %129, ptr %130, 1
  %132 = load ptr, ptr %.fca.2.gep, align 8
  %133 = insertvalue { ptr, ptr, ptr, i32 } %131, ptr %132, 2
  %134 = load i32, ptr %.fca.3.gep, align 8
  %135 = insertvalue { ptr, ptr, ptr, i32 } %133, i32 %134, 3
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %128)
  %138 = sext i32 %134 to i64
  %139 = getelementptr ptr, ptr %128, i64 %138
  %140 = getelementptr i8, ptr %139, i64 16
  %141 = load ptr, ptr %140, align 8
  %142 = call ptr @behavior_wrapper(ptr %141, { ptr, ptr, ptr, i32 } %135, ptr noundef nonnull align 8 %4)
  %143 = call { ptr, ptr, ptr, i32 } %142({ ptr, ptr, ptr, i32 } %135, { ptr, ptr, ptr, i32 } %135, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %143, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %143, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %143, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %143, 3
  %144 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %144, i64 8
  store ptr %.fca.1.extract, ptr %145, align 8
  %146 = getelementptr inbounds i8, ptr %144, i64 16
  store ptr %.fca.2.extract, ptr %146, align 8
  %147 = getelementptr inbounds i8, ptr %144, i64 24
  store i32 %.fca.3.extract, ptr %147, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %144, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %148 = alloca { ptr, ptr, ptr, i32 }, align 8
  %149 = load ptr, ptr %113, align 8
  store ptr %149, ptr %148, align 8
  %150 = getelementptr inbounds i8, ptr %148, i64 8
  %151 = load ptr, ptr %114, align 8
  store ptr %151, ptr %150, align 8
  %152 = getelementptr inbounds i8, ptr %148, i64 16
  %153 = load ptr, ptr %115, align 8
  store ptr %153, ptr %152, align 8
  %154 = getelementptr inbounds i8, ptr %148, i64 24
  %155 = load i32, ptr %116, align 8
  store i32 %155, ptr %154, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %148, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %156 = load ptr, ptr %148, align 8
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %156, 0
  %158 = load ptr, ptr %150, align 8
  %159 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %158, 1
  %160 = load ptr, ptr %152, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %160, 2
  %162 = load i32, ptr %154, align 8
  %163 = insertvalue { ptr, ptr, ptr, i32 } %161, i32 %162, 3
  %164 = alloca { ptr, ptr, ptr, i32 }, align 8
  %165 = load ptr, ptr %144, align 8
  store ptr %165, ptr %164, align 8
  %166 = getelementptr inbounds i8, ptr %164, i64 8
  %167 = load ptr, ptr %145, align 8
  store ptr %167, ptr %166, align 8
  %168 = getelementptr inbounds i8, ptr %164, i64 16
  %169 = load ptr, ptr %146, align 8
  store ptr %169, ptr %168, align 8
  %170 = getelementptr inbounds i8, ptr %164, i64 24
  %171 = load i32, ptr %147, align 8
  store i32 %171, ptr %170, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %164, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %172 = load ptr, ptr %164, align 8
  %173 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %172, 0
  %174 = load ptr, ptr %166, align 8
  %175 = insertvalue { ptr, ptr, ptr, i32 } %173, ptr %174, 1
  %176 = load ptr, ptr %168, align 8
  %177 = insertvalue { ptr, ptr, ptr, i32 } %175, ptr %176, 2
  %178 = load i32, ptr %170, align 8
  %179 = insertvalue { ptr, ptr, ptr, i32 } %177, i32 %178, 3
  %180 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %84, 1
  %181 = insertvalue { ptr, ptr, ptr, i32 } %180, ptr undef, 2
  %182 = insertvalue { ptr, ptr, ptr, i32 } %181, i32 10, 3
  %183 = load ptr, ptr %6, align 8
  %184 = load ptr, ptr %5, align 8
  %185 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %184)
  %186 = load i32, ptr %8, align 8
  %187 = sext i32 %186 to i64
  %188 = getelementptr ptr, ptr %184, i64 %187
  %189 = load ptr, ptr %188, align 8
  %190 = call ptr @typegetter_wrapper(ptr %189, ptr %183)
  %191 = call ptr @bump_malloc(i64 noundef 24)
  %192 = getelementptr i8, ptr %191, i64 8
  store ptr %190, ptr %192, align 8
  %193 = getelementptr i8, ptr %191, i64 16
  store ptr null, ptr %193, align 8
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %191)
  store ptr @Iterator, ptr %191, align 8
  %195 = load ptr, ptr %6, align 8
  %196 = load ptr, ptr %5, align 8
  %197 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %196)
  %198 = load i32, ptr %8, align 8
  %199 = sext i32 %198 to i64
  %200 = getelementptr ptr, ptr %196, i64 %199
  %201 = load ptr, ptr %200, align 8
  %202 = call ptr @typegetter_wrapper(ptr %201, ptr %195)
  %203 = call ptr @bump_malloc(i64 noundef 24)
  %204 = getelementptr i8, ptr %203, i64 8
  store ptr %202, ptr %204, align 8
  %205 = getelementptr i8, ptr %203, i64 16
  store ptr null, ptr %205, align 8
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %203)
  store ptr @Iterator, ptr %203, align 8
  %207 = alloca [2 x ptr], align 8
  store ptr %191, ptr %207, align 8
  %208 = getelementptr inbounds i8, ptr %207, i64 8
  store ptr %203, ptr %208, align 8
  %209 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %207)
  %210 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(144) @InterleaveIterator)
  %211 = load ptr, ptr getelementptr inbounds (i8, ptr @InterleaveIterator, i64 112), align 8
  %212 = alloca { ptr, ptr }, align 8
  store ptr %156, ptr %212, align 8
  %213 = getelementptr inbounds i8, ptr %212, i64 8
  store ptr %172, ptr %213, align 8
  %214 = call ptr @behavior_wrapper(ptr %211, { ptr, ptr, ptr, i32 } %182, ptr noundef nonnull align 8 dereferenceable(16) %212)
  call void %214({ ptr, ptr, ptr, i32 } %182, { ptr, ptr, ptr, i32 } %182, ptr nonnull %207, { ptr, ptr, ptr, i32 } %163, { ptr, ptr, ptr, i32 } %179) #39
  %215 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @InterleaveIterator, ptr %215, align 8
  %216 = getelementptr inbounds i8, ptr %215, i64 8
  store ptr %84, ptr %216, align 8
  %217 = getelementptr inbounds i8, ptr %215, i64 16
  %218 = getelementptr inbounds i8, ptr %215, i64 24
  store i32 10, ptr %218, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %215, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %219 = load ptr, ptr %215, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %219, 0
  %221 = load ptr, ptr %216, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 1
  %223 = load ptr, ptr %217, align 8
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, ptr %223, 2
  %225 = load i32, ptr %218, align 8
  %226 = insertvalue { ptr, ptr, ptr, i32 } %224, i32 %225, 3
  ret { ptr, ptr, ptr, i32 } %226
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleavedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

define ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 216
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainedCollection_field_ChainedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 248
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 25, i64 26
  %8 = getelementptr [118 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ChainedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 29, %.critedge ], [ 28, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 30, %.critedge ], [ 31, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 32, %21 ], [ 32, %14 ], [ 33, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [118 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 35, %.critedge ], [ 34, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define void @ChainedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1024) @ChainedCollection)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 16
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define i32 @ChainedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract13, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract15, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract17, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1024) @ChainedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract3, ptr %19, align 8
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep6 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract5, ptr %.fca.1.gep6, align 8
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep8 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract7, ptr %.fca.2.gep8, align 8
  %.fca.3.extract9 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep10 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract9, ptr %.fca.3.gep10, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep6, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep8, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep10, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %36 = load ptr, ptr %6, align 8
  %37 = load ptr, ptr %5, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %37)
  %39 = load i32, ptr %8, align 8
  %40 = sext i32 %39 to i64
  %41 = getelementptr ptr, ptr %37, i64 %40
  %42 = getelementptr i8, ptr %41, i64 16
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %36) #31
  %46 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  store ptr %.fca.0.extract, ptr %46, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %46, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %46, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %46, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %46, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %49 = load ptr, ptr %.fca.1.gep, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 1
  %51 = load ptr, ptr %.fca.2.gep, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %51, 2
  %53 = load i32, ptr %.fca.3.gep, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %53, 3
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %47)
  %57 = sext i32 %53 to i64
  %58 = getelementptr ptr, ptr %47, i64 %57
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = call ptr @behavior_wrapper(ptr %60, { ptr, ptr, ptr, i32 } %54, ptr noundef nonnull align 8 %4)
  %62 = call i32 %61({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull %4) #39
  %63 = add i32 %62, %35
  ret i32 %63
}

define { ptr, ptr, ptr, i32 } @ChainedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract77 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract71, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract73, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract75, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract77, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1024) @ChainedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract63, ptr %19, align 8
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep66 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract65, ptr %.fca.1.gep66, align 8
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep68 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract67, ptr %.fca.2.gep68, align 8
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep70 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract69, ptr %.fca.3.gep70, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep66, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep68, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep70, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract51, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract53, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract55, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract57, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 16
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %40) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract43, ptr %50, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %.fca.1.gep46, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %.fca.2.gep48, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %.fca.3.gep50, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %51)
  %61 = sext i32 %57 to i64
  %62 = getelementptr ptr, ptr %51, i64 %61
  %63 = getelementptr i8, ptr %62, i64 16
  %64 = load ptr, ptr %63, align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %4) #39
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %66, 3
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %.fca.1.extract33, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr %.fca.2.extract35, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %67, i64 24
  store i32 %.fca.3.extract37, ptr %70, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %67, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %71 = load ptr, ptr %6, align 8
  %72 = load ptr, ptr %5, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %8, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = load ptr, ptr %76, align 8
  %78 = call ptr @typegetter_wrapper(ptr %77, ptr %71)
  %79 = alloca [2 x ptr], align 8
  store ptr @ChainIterator, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr %78, ptr %80, align 8
  %81 = load ptr, ptr getelementptr inbounds (i8, ptr @ChainIterator, i64 48), align 8
  %82 = call { i64, i64 } @size_wrapper(ptr %81, ptr noundef nonnull align 8 dereferenceable(16) %79)
  %83 = extractvalue { i64, i64 } %82, 0
  %84 = call ptr @bump_malloc(i64 %83)
  store ptr %78, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %84)
  %86 = load ptr, ptr %6, align 8
  %87 = load ptr, ptr %5, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %87)
  %89 = load i32, ptr %8, align 8
  %90 = sext i32 %89 to i64
  %91 = getelementptr ptr, ptr %87, i64 %90
  %92 = getelementptr i8, ptr %91, i64 8
  %93 = load ptr, ptr %92, align 8
  %94 = load ptr, ptr %93, align 8
  %95 = call { ptr, ptr, ptr, i32 } %94(ptr %86) #31
  %96 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %95, 0
  store ptr %.fca.0.extract17, ptr %96, align 8
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %95, 1
  %.fca.1.gep20 = getelementptr inbounds i8, ptr %96, i64 8
  store ptr %.fca.1.extract19, ptr %.fca.1.gep20, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %95, 2
  %.fca.2.gep22 = getelementptr inbounds i8, ptr %96, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep22, align 8
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %95, 3
  %.fca.3.gep24 = getelementptr inbounds i8, ptr %96, i64 24
  store i32 %.fca.3.extract23, ptr %.fca.3.gep24, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %96, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %97 = load ptr, ptr %96, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %.fca.1.gep20, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %.fca.2.gep22, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %.fca.3.gep24, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %97)
  %107 = sext i32 %103 to i64
  %108 = getelementptr ptr, ptr %97, i64 %107
  %109 = getelementptr i8, ptr %108, i64 16
  %110 = load ptr, ptr %109, align 8
  %111 = call ptr @behavior_wrapper(ptr %110, { ptr, ptr, ptr, i32 } %104, ptr noundef nonnull align 8 %4)
  %112 = call { ptr, ptr, ptr, i32 } %111({ ptr, ptr, ptr, i32 } %104, { ptr, ptr, ptr, i32 } %104, ptr nonnull align 8 %4) #39
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %112, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %112, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %112, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %112, 3
  %113 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %113, align 8
  %114 = getelementptr inbounds i8, ptr %113, i64 8
  store ptr %.fca.1.extract7, ptr %114, align 8
  %115 = getelementptr inbounds i8, ptr %113, i64 16
  store ptr %.fca.2.extract9, ptr %115, align 8
  %116 = getelementptr inbounds i8, ptr %113, i64 24
  store i32 %.fca.3.extract11, ptr %116, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %113, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %117 = load ptr, ptr %6, align 8
  %118 = load ptr, ptr %5, align 8
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %118)
  %120 = load i32, ptr %8, align 8
  %121 = sext i32 %120 to i64
  %122 = getelementptr ptr, ptr %118, i64 %121
  %123 = getelementptr i8, ptr %122, i64 16
  %124 = load ptr, ptr %123, align 8
  %125 = load ptr, ptr %124, align 8
  %126 = call { ptr, ptr, ptr, i32 } %125(ptr %117) #31
  %127 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %126, 0
  store ptr %.fca.0.extract1, ptr %127, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %126, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %127, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %126, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %127, i64 16
  store ptr %.fca.2.extract3, ptr %.fca.2.gep, align 8
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %126, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %127, i64 24
  store i32 %.fca.3.extract4, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %127, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %128 = load ptr, ptr %127, align 8
  %129 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %128, 0
  %130 = load ptr, ptr %.fca.1.gep, align 8
  %131 = insertvalue { ptr, ptr, ptr, i32 } %129, ptr %130, 1
  %132 = load ptr, ptr %.fca.2.gep, align 8
  %133 = insertvalue { ptr, ptr, ptr, i32 } %131, ptr %132, 2
  %134 = load i32, ptr %.fca.3.gep, align 8
  %135 = insertvalue { ptr, ptr, ptr, i32 } %133, i32 %134, 3
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %128)
  %138 = sext i32 %134 to i64
  %139 = getelementptr ptr, ptr %128, i64 %138
  %140 = getelementptr i8, ptr %139, i64 16
  %141 = load ptr, ptr %140, align 8
  %142 = call ptr @behavior_wrapper(ptr %141, { ptr, ptr, ptr, i32 } %135, ptr noundef nonnull align 8 %4)
  %143 = call { ptr, ptr, ptr, i32 } %142({ ptr, ptr, ptr, i32 } %135, { ptr, ptr, ptr, i32 } %135, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %143, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %143, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %143, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %143, 3
  %144 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %144, i64 8
  store ptr %.fca.1.extract, ptr %145, align 8
  %146 = getelementptr inbounds i8, ptr %144, i64 16
  store ptr %.fca.2.extract, ptr %146, align 8
  %147 = getelementptr inbounds i8, ptr %144, i64 24
  store i32 %.fca.3.extract, ptr %147, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %144, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %148 = alloca { ptr, ptr, ptr, i32 }, align 8
  %149 = load ptr, ptr %113, align 8
  store ptr %149, ptr %148, align 8
  %150 = getelementptr inbounds i8, ptr %148, i64 8
  %151 = load ptr, ptr %114, align 8
  store ptr %151, ptr %150, align 8
  %152 = getelementptr inbounds i8, ptr %148, i64 16
  %153 = load ptr, ptr %115, align 8
  store ptr %153, ptr %152, align 8
  %154 = getelementptr inbounds i8, ptr %148, i64 24
  %155 = load i32, ptr %116, align 8
  store i32 %155, ptr %154, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %148, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %156 = load ptr, ptr %148, align 8
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %156, 0
  %158 = load ptr, ptr %150, align 8
  %159 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %158, 1
  %160 = load ptr, ptr %152, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %160, 2
  %162 = load i32, ptr %154, align 8
  %163 = insertvalue { ptr, ptr, ptr, i32 } %161, i32 %162, 3
  %164 = alloca { ptr, ptr, ptr, i32 }, align 8
  %165 = load ptr, ptr %144, align 8
  store ptr %165, ptr %164, align 8
  %166 = getelementptr inbounds i8, ptr %164, i64 8
  %167 = load ptr, ptr %145, align 8
  store ptr %167, ptr %166, align 8
  %168 = getelementptr inbounds i8, ptr %164, i64 16
  %169 = load ptr, ptr %146, align 8
  store ptr %169, ptr %168, align 8
  %170 = getelementptr inbounds i8, ptr %164, i64 24
  %171 = load i32, ptr %147, align 8
  store i32 %171, ptr %170, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %164, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %172 = load ptr, ptr %164, align 8
  %173 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %172, 0
  %174 = load ptr, ptr %166, align 8
  %175 = insertvalue { ptr, ptr, ptr, i32 } %173, ptr %174, 1
  %176 = load ptr, ptr %168, align 8
  %177 = insertvalue { ptr, ptr, ptr, i32 } %175, ptr %176, 2
  %178 = load i32, ptr %170, align 8
  %179 = insertvalue { ptr, ptr, ptr, i32 } %177, i32 %178, 3
  %180 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %84, 1
  %181 = insertvalue { ptr, ptr, ptr, i32 } %180, ptr undef, 2
  %182 = insertvalue { ptr, ptr, ptr, i32 } %181, i32 10, 3
  %183 = load ptr, ptr %6, align 8
  %184 = load ptr, ptr %5, align 8
  %185 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %184)
  %186 = load i32, ptr %8, align 8
  %187 = sext i32 %186 to i64
  %188 = getelementptr ptr, ptr %184, i64 %187
  %189 = load ptr, ptr %188, align 8
  %190 = call ptr @typegetter_wrapper(ptr %189, ptr %183)
  %191 = call ptr @bump_malloc(i64 noundef 24)
  %192 = getelementptr i8, ptr %191, i64 8
  store ptr %190, ptr %192, align 8
  %193 = getelementptr i8, ptr %191, i64 16
  store ptr null, ptr %193, align 8
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %191)
  store ptr @Iterator, ptr %191, align 8
  %195 = load ptr, ptr %6, align 8
  %196 = load ptr, ptr %5, align 8
  %197 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %196)
  %198 = load i32, ptr %8, align 8
  %199 = sext i32 %198 to i64
  %200 = getelementptr ptr, ptr %196, i64 %199
  %201 = load ptr, ptr %200, align 8
  %202 = call ptr @typegetter_wrapper(ptr %201, ptr %195)
  %203 = call ptr @bump_malloc(i64 noundef 24)
  %204 = getelementptr i8, ptr %203, i64 8
  store ptr %202, ptr %204, align 8
  %205 = getelementptr i8, ptr %203, i64 16
  store ptr null, ptr %205, align 8
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %203)
  store ptr @Iterator, ptr %203, align 8
  %207 = alloca [2 x ptr], align 8
  store ptr %191, ptr %207, align 8
  %208 = getelementptr inbounds i8, ptr %207, i64 8
  store ptr %203, ptr %208, align 8
  %209 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %207)
  %210 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(144) @ChainIterator)
  %211 = load ptr, ptr getelementptr inbounds (i8, ptr @ChainIterator, i64 112), align 8
  %212 = alloca { ptr, ptr }, align 8
  store ptr %156, ptr %212, align 8
  %213 = getelementptr inbounds i8, ptr %212, i64 8
  store ptr %172, ptr %213, align 8
  %214 = call ptr @behavior_wrapper(ptr %211, { ptr, ptr, ptr, i32 } %182, ptr noundef nonnull align 8 dereferenceable(16) %212)
  call void %214({ ptr, ptr, ptr, i32 } %182, { ptr, ptr, ptr, i32 } %182, ptr nonnull %207, { ptr, ptr, ptr, i32 } %163, { ptr, ptr, ptr, i32 } %179) #39
  %215 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ChainIterator, ptr %215, align 8
  %216 = getelementptr inbounds i8, ptr %215, i64 8
  store ptr %84, ptr %216, align 8
  %217 = getelementptr inbounds i8, ptr %215, i64 16
  %218 = getelementptr inbounds i8, ptr %215, i64 24
  store i32 10, ptr %218, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %215, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %219 = load ptr, ptr %215, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %219, 0
  %221 = load ptr, ptr %216, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 1
  %223 = load ptr, ptr %217, align 8
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, ptr %223, 2
  %225 = load i32, ptr %218, align 8
  %226 = insertvalue { ptr, ptr, ptr, i32 } %224, i32 %225, 3
  ret { ptr, ptr, ptr, i32 } %226
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterator_field_ChainIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 128
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ChainIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(168) @ChainIterator)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 16
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  %70 = load ptr, ptr %7, align 8
  %71 = load ptr, ptr %6, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %71)
  %73 = load i32, ptr %9, align 8
  %74 = sext i32 %73 to i64
  %75 = getelementptr ptr, ptr %71, i64 %74
  %76 = getelementptr i8, ptr %75, i64 24
  %77 = load ptr, ptr %76, align 8
  %78 = getelementptr i8, ptr %77, i64 8
  %79 = load ptr, ptr %78, align 8
  call void %79(ptr %70, i1 true) #30
  ret void
}

define { ptr, i160 } @ChainIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract4, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(168) @ChainIterator)
  %11 = load ptr, ptr %8, align 8
  %12 = load ptr, ptr %7, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %12)
  %14 = load i32, ptr %10, align 8
  %15 = sext i32 %14 to i64
  %16 = getelementptr ptr, ptr %12, i64 %15
  %17 = getelementptr i8, ptr %16, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call i1 %19(ptr %11) #31
  br i1 %20, label %21, label %64

21:                                               ; preds = %3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %12)
  %23 = getelementptr i8, ptr %16, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr, ptr, ptr, i32 } %25(ptr %11) #31
  %.fca.0.extract22 = extractvalue { ptr, ptr, ptr, i32 } %26, 0
  store ptr %.fca.0.extract22, ptr %5, align 8
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %26, 1
  %.fca.1.gep25 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract24, ptr %.fca.1.gep25, align 8
  %.fca.2.extract26 = extractvalue { ptr, ptr, ptr, i32 } %26, 2
  %.fca.2.gep27 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract26, ptr %.fca.2.gep27, align 8
  %.fca.3.extract28 = extractvalue { ptr, ptr, ptr, i32 } %26, 3
  %.fca.3.gep29 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract28, ptr %.fca.3.gep29, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %27 = load ptr, ptr %5, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = load ptr, ptr %.fca.1.gep25, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %29, 1
  %31 = load ptr, ptr %.fca.2.gep27, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %31, 2
  %33 = load i32, ptr %.fca.3.gep29, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %33, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %27)
  %37 = sext i32 %33 to i64
  %38 = getelementptr ptr, ptr %27, i64 %37
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @behavior_wrapper(ptr %40, { ptr, ptr, ptr, i32 } %34, ptr noundef nonnull align 8 %4)
  %42 = call { ptr, i160 } %41({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %4) #39
  %.fca.0.extract16 = extractvalue { ptr, i160 } %42, 0
  %.fca.1.extract18 = extractvalue { ptr, i160 } %42, 1
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %7, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %44)
  %46 = load i32, ptr %10, align 8
  %47 = sext i32 %46 to i64
  %48 = getelementptr ptr, ptr %44, i64 %47
  %49 = load ptr, ptr %48, align 8
  %50 = call ptr @typegetter_wrapper(ptr %49, ptr %43)
  %51 = icmp ne ptr %.fca.0.extract16, @nil_typ
  %52 = icmp ne ptr %.fca.0.extract16, null
  %.not31.not.not = and i1 %51, %52
  br i1 %.not31.not.not, label %64, label %53

53:                                               ; preds = %21
  %54 = load ptr, ptr %8, align 8
  %55 = load ptr, ptr %7, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %55)
  %57 = load i32, ptr %10, align 8
  %58 = sext i32 %57 to i64
  %59 = getelementptr ptr, ptr %55, i64 %58
  %60 = getelementptr i8, ptr %59, i64 24
  %61 = load ptr, ptr %60, align 8
  %62 = getelementptr i8, ptr %61, i64 8
  %63 = load ptr, ptr %62, align 8
  call void %63(ptr %54, i1 false) #30
  br label %64

64:                                               ; preds = %53, %21, %3
  %.reg2mem27.0 = phi i1 [ true, %21 ], [ false, %53 ], [ false, %3 ]
  %.reg2mem29.sroa.3.0 = phi i160 [ %.fca.1.extract18, %21 ], [ %.fca.1.extract18, %53 ], [ poison, %3 ]
  %.reg2mem29.sroa.0.0 = phi ptr [ %.fca.0.extract16, %21 ], [ %.fca.0.extract16, %53 ], [ poison, %3 ]
  br i1 %.reg2mem27.0, label %92, label %65

65:                                               ; preds = %64
  %66 = load ptr, ptr %8, align 8
  %67 = load ptr, ptr %7, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %67)
  %69 = load i32, ptr %10, align 8
  %70 = sext i32 %69 to i64
  %71 = getelementptr ptr, ptr %67, i64 %70
  %72 = getelementptr i8, ptr %71, i64 16
  %73 = load ptr, ptr %72, align 8
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #31
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %75, 0
  store ptr %.fca.0.extract9, ptr %6, align 8
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %75, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %.fca.1.gep, align 8
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %75, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %.fca.2.gep, align 8
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %75, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %76 = load ptr, ptr %6, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %76, 0
  %78 = load ptr, ptr %.fca.1.gep, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %78, 1
  %80 = load ptr, ptr %.fca.2.gep, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 2
  %82 = load i32, ptr %.fca.3.gep, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 %82, 3
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %76)
  %86 = sext i32 %82 to i64
  %87 = getelementptr ptr, ptr %76, i64 %86
  %88 = getelementptr i8, ptr %87, i64 8
  %89 = load ptr, ptr %88, align 8
  %90 = call ptr @behavior_wrapper(ptr %89, { ptr, ptr, ptr, i32 } %83, ptr noundef nonnull align 8 %4)
  %91 = call { ptr, i160 } %90({ ptr, ptr, ptr, i32 } %83, { ptr, ptr, ptr, i32 } %83, ptr nonnull %4) #39
  %.fca.0.extract5 = extractvalue { ptr, i160 } %91, 0
  %.fca.1.extract6 = extractvalue { ptr, i160 } %91, 1
  br label %92

92:                                               ; preds = %65, %64
  %.reg2mem25.sroa.0.0 = phi ptr [ %.fca.0.extract5, %65 ], [ %.reg2mem29.sroa.0.0, %64 ]
  %.reg2mem25.sroa.3.0 = phi i160 [ %.fca.1.extract6, %65 ], [ %.reg2mem29.sroa.3.0, %64 ]
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @ChainIterator_getter_on_first(ptr nocapture nofree readonly %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainedCollection_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 72, i64 8 }
}

define ptr @ChainIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = getelementptr inbounds i8, ptr %1, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = getelementptr i8, ptr %15, i64 16
  %18 = getelementptr i8, ptr %15, i64 24
  %19 = getelementptr i8, ptr %15, i64 32
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %23)
  %25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %26 = getelementptr i8, ptr %25, i64 208
  %27 = load ptr, ptr %26, align 8
  ret ptr %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterable_field_ChainIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 232
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @ChainIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 280
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ChainIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ChainIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @ChainIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @ChainIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract9, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract10, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract12, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(512) @ChainIterable)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract2, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract3, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract4, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %40 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr %.fca.1.extract, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr %.fca.2.extract, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %40, i64 24
  store i32 %.fca.3.extract, ptr %43, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %40, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = load ptr, ptr %40, align 8
  store ptr %45, ptr %44, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 8
  %47 = load ptr, ptr %41, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds i8, ptr %44, i64 16
  %49 = load ptr, ptr %42, align 8
  store ptr %49, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %44, i64 24
  %51 = load i32, ptr %43, align 8
  store i32 %51, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %44, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %9, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 16
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 8
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %44, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %46, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %48, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %50, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  call void %61(ptr %52, { ptr, ptr, ptr, i32 } %69) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @ChainIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract75 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract77 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract71, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract73, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract75, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract77, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(512) @ChainIterable)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract63, ptr %19, align 8
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep66 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract65, ptr %.fca.1.gep66, align 8
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep68 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract67, ptr %.fca.2.gep68, align 8
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep70 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract69, ptr %.fca.3.gep70, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep66, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep68, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep70, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract51, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract53, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract55, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract57, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 16
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %40) #31
  %50 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  store ptr %.fca.0.extract43, ptr %50, align 8
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.1.gep46 = getelementptr inbounds i8, ptr %50, i64 8
  store ptr %.fca.1.extract45, ptr %.fca.1.gep46, align 8
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.2.gep48 = getelementptr inbounds i8, ptr %50, i64 16
  store ptr %.fca.2.extract47, ptr %.fca.2.gep48, align 8
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %.fca.3.gep50 = getelementptr inbounds i8, ptr %50, i64 24
  store i32 %.fca.3.extract49, ptr %.fca.3.gep50, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %50, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %.fca.1.gep46, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %.fca.2.gep48, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %.fca.3.gep50, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %51)
  %61 = sext i32 %57 to i64
  %62 = getelementptr ptr, ptr %51, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %65 = call ptr @behavior_wrapper(ptr %64, { ptr, ptr, ptr, i32 } %58, ptr noundef nonnull align 8 %4)
  %66 = call { ptr, ptr, ptr, i32 } %65({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %4) #39
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %66, 3
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %.fca.1.extract33, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr %.fca.2.extract35, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %67, i64 24
  store i32 %.fca.3.extract37, ptr %70, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %67, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %71 = load ptr, ptr %6, align 8
  %72 = load ptr, ptr %5, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %8, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = load ptr, ptr %76, align 8
  %78 = call ptr @typegetter_wrapper(ptr %77, ptr %71)
  %79 = alloca [2 x ptr], align 8
  store ptr @ChainIterator, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr %78, ptr %80, align 8
  %81 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_ChainIterator, ptr noundef nonnull align 8 dereferenceable(16) %79)
  %82 = extractvalue { i64, i64 } %81, 0
  %83 = call ptr @bump_malloc(i64 %82)
  store ptr %78, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %83)
  %85 = load ptr, ptr %6, align 8
  %86 = load ptr, ptr %5, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %86)
  %88 = load i32, ptr %8, align 8
  %89 = sext i32 %88 to i64
  %90 = getelementptr ptr, ptr %86, i64 %89
  %91 = getelementptr i8, ptr %90, i64 8
  %92 = load ptr, ptr %91, align 8
  %93 = load ptr, ptr %92, align 8
  %94 = call { ptr, ptr, ptr, i32 } %93(ptr %85) #31
  %95 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %94, 0
  store ptr %.fca.0.extract17, ptr %95, align 8
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %94, 1
  %.fca.1.gep20 = getelementptr inbounds i8, ptr %95, i64 8
  store ptr %.fca.1.extract19, ptr %.fca.1.gep20, align 8
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %94, 2
  %.fca.2.gep22 = getelementptr inbounds i8, ptr %95, i64 16
  store ptr %.fca.2.extract21, ptr %.fca.2.gep22, align 8
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %94, 3
  %.fca.3.gep24 = getelementptr inbounds i8, ptr %95, i64 24
  store i32 %.fca.3.extract23, ptr %.fca.3.gep24, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %95, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %96 = load ptr, ptr %95, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %96, 0
  %98 = load ptr, ptr %.fca.1.gep20, align 8
  %99 = insertvalue { ptr, ptr, ptr, i32 } %97, ptr %98, 1
  %100 = load ptr, ptr %.fca.2.gep22, align 8
  %101 = insertvalue { ptr, ptr, ptr, i32 } %99, ptr %100, 2
  %102 = load i32, ptr %.fca.3.gep24, align 8
  %103 = insertvalue { ptr, ptr, ptr, i32 } %101, i32 %102, 3
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %96)
  %106 = sext i32 %102 to i64
  %107 = getelementptr ptr, ptr %96, i64 %106
  %108 = getelementptr i8, ptr %107, i64 8
  %109 = load ptr, ptr %108, align 8
  %110 = call ptr @behavior_wrapper(ptr %109, { ptr, ptr, ptr, i32 } %103, ptr noundef nonnull align 8 %4)
  %111 = call { ptr, ptr, ptr, i32 } %110({ ptr, ptr, ptr, i32 } %103, { ptr, ptr, ptr, i32 } %103, ptr nonnull align 8 %4) #39
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %111, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %111, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %111, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %111, 3
  %112 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %112, align 8
  %113 = getelementptr inbounds i8, ptr %112, i64 8
  store ptr %.fca.1.extract7, ptr %113, align 8
  %114 = getelementptr inbounds i8, ptr %112, i64 16
  store ptr %.fca.2.extract9, ptr %114, align 8
  %115 = getelementptr inbounds i8, ptr %112, i64 24
  store i32 %.fca.3.extract11, ptr %115, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %112, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %116 = load ptr, ptr %6, align 8
  %117 = load ptr, ptr %5, align 8
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %117)
  %119 = load i32, ptr %8, align 8
  %120 = sext i32 %119 to i64
  %121 = getelementptr ptr, ptr %117, i64 %120
  %122 = getelementptr i8, ptr %121, i64 16
  %123 = load ptr, ptr %122, align 8
  %124 = load ptr, ptr %123, align 8
  %125 = call { ptr, ptr, ptr, i32 } %124(ptr %116) #31
  %126 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %125, 0
  store ptr %.fca.0.extract1, ptr %126, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %125, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %126, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %125, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %126, i64 16
  store ptr %.fca.2.extract3, ptr %.fca.2.gep, align 8
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %125, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %126, i64 24
  store i32 %.fca.3.extract4, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %126, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %127 = load ptr, ptr %126, align 8
  %128 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %127, 0
  %129 = load ptr, ptr %.fca.1.gep, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %129, 1
  %131 = load ptr, ptr %.fca.2.gep, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 2
  %133 = load i32, ptr %.fca.3.gep, align 8
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, i32 %133, 3
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %136 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %127)
  %137 = sext i32 %133 to i64
  %138 = getelementptr ptr, ptr %127, i64 %137
  %139 = getelementptr i8, ptr %138, i64 8
  %140 = load ptr, ptr %139, align 8
  %141 = call ptr @behavior_wrapper(ptr %140, { ptr, ptr, ptr, i32 } %134, ptr noundef nonnull align 8 %4)
  %142 = call { ptr, ptr, ptr, i32 } %141({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } %134, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %142, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %142, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %142, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %142, 3
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %143, align 8
  %144 = getelementptr inbounds i8, ptr %143, i64 8
  store ptr %.fca.1.extract, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %143, i64 16
  store ptr %.fca.2.extract, ptr %145, align 8
  %146 = getelementptr inbounds i8, ptr %143, i64 24
  store i32 %.fca.3.extract, ptr %146, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %143, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %147 = alloca { ptr, ptr, ptr, i32 }, align 8
  %148 = load ptr, ptr %112, align 8
  store ptr %148, ptr %147, align 8
  %149 = getelementptr inbounds i8, ptr %147, i64 8
  %150 = load ptr, ptr %113, align 8
  store ptr %150, ptr %149, align 8
  %151 = getelementptr inbounds i8, ptr %147, i64 16
  %152 = load ptr, ptr %114, align 8
  store ptr %152, ptr %151, align 8
  %153 = getelementptr inbounds i8, ptr %147, i64 24
  %154 = load i32, ptr %115, align 8
  store i32 %154, ptr %153, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %147, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %155 = load ptr, ptr %147, align 8
  %156 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %155, 0
  %157 = load ptr, ptr %149, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } %156, ptr %157, 1
  %159 = load ptr, ptr %151, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %159, 2
  %161 = load i32, ptr %153, align 8
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, i32 %161, 3
  %163 = alloca { ptr, ptr, ptr, i32 }, align 8
  %164 = load ptr, ptr %143, align 8
  store ptr %164, ptr %163, align 8
  %165 = getelementptr inbounds i8, ptr %163, i64 8
  %166 = load ptr, ptr %144, align 8
  store ptr %166, ptr %165, align 8
  %167 = getelementptr inbounds i8, ptr %163, i64 16
  %168 = load ptr, ptr %145, align 8
  store ptr %168, ptr %167, align 8
  %169 = getelementptr inbounds i8, ptr %163, i64 24
  %170 = load i32, ptr %146, align 8
  store i32 %170, ptr %169, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %163, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %171 = load ptr, ptr %163, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %171, 0
  %173 = load ptr, ptr %165, align 8
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, ptr %173, 1
  %175 = load ptr, ptr %167, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } %174, ptr %175, 2
  %177 = load i32, ptr %169, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, i32 %177, 3
  %179 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %83, 1
  %180 = insertvalue { ptr, ptr, ptr, i32 } %179, ptr undef, 2
  %181 = insertvalue { ptr, ptr, ptr, i32 } %180, i32 10, 3
  %182 = load ptr, ptr %6, align 8
  %183 = load ptr, ptr %5, align 8
  %184 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %183)
  %185 = load i32, ptr %8, align 8
  %186 = sext i32 %185 to i64
  %187 = getelementptr ptr, ptr %183, i64 %186
  %188 = load ptr, ptr %187, align 8
  %189 = call ptr @typegetter_wrapper(ptr %188, ptr %182)
  %190 = call ptr @bump_malloc(i64 noundef 24)
  %191 = getelementptr i8, ptr %190, i64 8
  store ptr %189, ptr %191, align 8
  %192 = getelementptr i8, ptr %190, i64 16
  store ptr null, ptr %192, align 8
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %190)
  store ptr @Iterator, ptr %190, align 8
  %194 = load ptr, ptr %6, align 8
  %195 = load ptr, ptr %5, align 8
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %195)
  %197 = load i32, ptr %8, align 8
  %198 = sext i32 %197 to i64
  %199 = getelementptr ptr, ptr %195, i64 %198
  %200 = load ptr, ptr %199, align 8
  %201 = call ptr @typegetter_wrapper(ptr %200, ptr %194)
  %202 = call ptr @bump_malloc(i64 noundef 24)
  %203 = getelementptr i8, ptr %202, i64 8
  store ptr %201, ptr %203, align 8
  %204 = getelementptr i8, ptr %202, i64 16
  store ptr null, ptr %204, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %202)
  store ptr @Iterator, ptr %202, align 8
  %206 = alloca [2 x ptr], align 8
  store ptr %190, ptr %206, align 8
  %207 = getelementptr inbounds i8, ptr %206, i64 8
  store ptr %202, ptr %207, align 8
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %206)
  %209 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @ChainIterator)
  %210 = alloca { ptr, ptr }, align 8
  store ptr %155, ptr %210, align 8
  %211 = getelementptr inbounds i8, ptr %210, i64 8
  store ptr %171, ptr %211, align 8
  %212 = call ptr @behavior_wrapper(ptr noundef nonnull @ChainIterator_B_init_firstIteratorT_secondIteratorT, { ptr, ptr, ptr, i32 } %181, ptr noundef nonnull align 8 dereferenceable(16) %210)
  call void %212({ ptr, ptr, ptr, i32 } %181, { ptr, ptr, ptr, i32 } %181, ptr nonnull %206, { ptr, ptr, ptr, i32 } %162, { ptr, ptr, ptr, i32 } %178) #39
  %213 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ChainIterator, ptr %213, align 8
  %214 = getelementptr inbounds i8, ptr %213, i64 8
  store ptr %83, ptr %214, align 8
  %215 = getelementptr inbounds i8, ptr %213, i64 16
  %216 = getelementptr inbounds i8, ptr %213, i64 24
  store i32 10, ptr %216, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %213, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %217 = load ptr, ptr %213, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %217, 0
  %219 = load ptr, ptr %214, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %219, 1
  %221 = load ptr, ptr %215, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 2
  %223 = load i32, ptr %216, align 8
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, i32 %223, 3
  ret { ptr, ptr, ptr, i32 } %224
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_second(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_second(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_first(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_first(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 208
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterable_field_FilterIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 232
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @FilterIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 280
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @FilterIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @FilterIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @FilterIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @FilterIterable_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract4, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract5, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(512) @FilterIterable)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %40 = load ptr, ptr %7, align 8
  %41 = load ptr, ptr %6, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %9, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 16
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  call void %49(ptr %40, { ptr } %4) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @FilterIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract35, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract37, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract39, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract41, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(512) @FilterIterable)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract27, ptr %19, align 8
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep30 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract29, ptr %.fca.1.gep30, align 8
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep32 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract31, ptr %.fca.2.gep32, align 8
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep34 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract33, ptr %.fca.3.gep34, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep30, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep32, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep34, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract19 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract21 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract15, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract17, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract19, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract21, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 16
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %40) #31
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %41)
  %51 = load ptr, ptr %45, align 8
  %52 = call ptr @typegetter_wrapper(ptr %51, ptr %40)
  %53 = alloca [2 x ptr], align 8
  store ptr @FilterIterator, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %53, i64 8
  store ptr %52, ptr %54, align 8
  %55 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_FilterIterator, ptr noundef nonnull align 8 dereferenceable(16) %53)
  %56 = extractvalue { i64, i64 } %55, 0
  %57 = call ptr @bump_malloc(i64 %56)
  store ptr %52, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %57)
  %59 = load ptr, ptr %6, align 8
  %60 = load ptr, ptr %5, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %60)
  %62 = load i32, ptr %8, align 8
  %63 = sext i32 %62 to i64
  %64 = getelementptr ptr, ptr %60, i64 %63
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr, ptr, ptr, i32 } %67(ptr %59) #31
  %69 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %68, 0
  store ptr %.fca.0.extract2, ptr %69, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %68, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %69, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %68, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %69, i64 16
  store ptr %.fca.2.extract4, ptr %.fca.2.gep, align 8
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %68, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %69, i64 24
  store i32 %.fca.3.extract5, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %69, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %70 = load ptr, ptr %69, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %70, 0
  %72 = load ptr, ptr %.fca.1.gep, align 8
  %73 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr %72, 1
  %74 = load ptr, ptr %.fca.2.gep, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %74, 2
  %76 = load i32, ptr %.fca.3.gep, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } %75, i32 %76, 3
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %70)
  %80 = sext i32 %76 to i64
  %81 = getelementptr ptr, ptr %70, i64 %80
  %82 = getelementptr i8, ptr %81, i64 8
  %83 = load ptr, ptr %82, align 8
  %84 = call ptr @behavior_wrapper(ptr %83, { ptr, ptr, ptr, i32 } %77, ptr noundef nonnull align 8 %4)
  %85 = call { ptr, ptr, ptr, i32 } %84({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull %4) #39
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %85, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %85, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %85, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %85, 3
  %86 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %86, i64 8
  store ptr %.fca.1.extract, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %86, i64 16
  store ptr %.fca.2.extract, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %86, i64 24
  store i32 %.fca.3.extract, ptr %89, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %86, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %90 = load ptr, ptr %6, align 8
  %91 = load ptr, ptr %5, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %91)
  %93 = load i32, ptr %8, align 8
  %94 = sext i32 %93 to i64
  %95 = getelementptr ptr, ptr %91, i64 %94
  %96 = getelementptr i8, ptr %95, i64 16
  %97 = load ptr, ptr %96, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = call { ptr } %98(ptr %90) #31
  %100 = alloca { ptr, ptr, ptr, i32 }, align 8
  %101 = load ptr, ptr %86, align 8
  store ptr %101, ptr %100, align 8
  %102 = getelementptr inbounds i8, ptr %100, i64 8
  %103 = load ptr, ptr %87, align 8
  store ptr %103, ptr %102, align 8
  %104 = getelementptr inbounds i8, ptr %100, i64 16
  %105 = load ptr, ptr %88, align 8
  store ptr %105, ptr %104, align 8
  %106 = getelementptr inbounds i8, ptr %100, i64 24
  %107 = load i32, ptr %89, align 8
  store i32 %107, ptr %106, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %100, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %108 = load ptr, ptr %100, align 8
  %109 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %108, 0
  %110 = load ptr, ptr %102, align 8
  %111 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %110, 1
  %112 = load ptr, ptr %104, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } %111, ptr %112, 2
  %114 = load i32, ptr %106, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %113, i32 %114, 3
  %116 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterator, ptr undef, ptr undef, i32 undef }, ptr %57, 1
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr undef, 2
  %118 = insertvalue { ptr, ptr, ptr, i32 } %117, i32 10, 3
  %119 = load ptr, ptr %6, align 8
  %120 = load ptr, ptr %5, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %120)
  %122 = load i32, ptr %8, align 8
  %123 = sext i32 %122 to i64
  %124 = getelementptr ptr, ptr %120, i64 %123
  %125 = load ptr, ptr %124, align 8
  %126 = call ptr @typegetter_wrapper(ptr %125, ptr %119)
  %127 = call ptr @bump_malloc(i64 noundef 24)
  %128 = getelementptr i8, ptr %127, i64 8
  store ptr %126, ptr %128, align 8
  %129 = getelementptr i8, ptr %127, i64 16
  store ptr null, ptr %129, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %127)
  store ptr @Iterator, ptr %127, align 8
  %131 = load ptr, ptr %6, align 8
  %132 = load ptr, ptr %5, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 432, ptr nocapture nofree noundef %132)
  %134 = load i32, ptr %8, align 8
  %135 = sext i32 %134 to i64
  %136 = getelementptr ptr, ptr %132, i64 %135
  %137 = load ptr, ptr %136, align 8
  %138 = call ptr @typegetter_wrapper(ptr %137, ptr %131)
  %139 = call ptr @bump_malloc(i64 noundef 32)
  %140 = getelementptr i8, ptr %139, i64 16
  store ptr %138, ptr %140, align 8
  %141 = getelementptr i8, ptr %139, i64 8
  store ptr @_parameterization_Bool, ptr %141, align 8
  %142 = getelementptr i8, ptr %139, i64 24
  store ptr null, ptr %142, align 8
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %139)
  store ptr @function_typ, ptr %139, align 8
  %144 = alloca [2 x ptr], align 8
  store ptr %127, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %144, i64 8
  store ptr %139, ptr %145, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %144)
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @FilterIterator)
  %148 = alloca { ptr, ptr }, align 8
  store ptr %108, ptr %148, align 8
  %149 = getelementptr inbounds i8, ptr %148, i64 8
  store ptr @function_typ, ptr %149, align 8
  %150 = call ptr @behavior_wrapper(ptr noundef nonnull @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool, { ptr, ptr, ptr, i32 } %118, ptr noundef nonnull align 8 dereferenceable(16) %148)
  call void %150({ ptr, ptr, ptr, i32 } %118, { ptr, ptr, ptr, i32 } %118, ptr nonnull %144, { ptr, ptr, ptr, i32 } %115, { ptr } %99) #39
  %151 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @FilterIterator, ptr %151, align 8
  %152 = getelementptr inbounds i8, ptr %151, i64 8
  store ptr %57, ptr %152, align 8
  %153 = getelementptr inbounds i8, ptr %151, i64 16
  %154 = getelementptr inbounds i8, ptr %151, i64 24
  store i32 10, ptr %154, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %151, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %155 = load ptr, ptr %151, align 8
  %156 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %155, 0
  %157 = load ptr, ptr %152, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } %156, ptr %157, 1
  %159 = load ptr, ptr %153, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %159, 2
  %161 = load i32, ptr %154, align 8
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, i32 %161, 3
  ret { ptr, ptr, ptr, i32 } %162
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 120
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterator_field_FilterIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract4, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract5, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(160) @FilterIterator)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %40 = load ptr, ptr %7, align 8
  %41 = load ptr, ptr %6, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %9, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 16
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  call void %49(ptr %40, { ptr } %4) #30
  ret void
}

define { ptr, i160 } @FilterIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract14, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract16, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract18, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract20, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(160) @FilterIterator)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr, ptr, ptr, i32 } %18(ptr %10) #31
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  store ptr %.fca.0.extract1, ptr %20, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.1.gep4 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep4, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %20, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %20, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %20, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = load ptr, ptr %.fca.1.gep4, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %23, 1
  %25 = load ptr, ptr %.fca.2.gep, align 8
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %25, 2
  %27 = load i32, ptr %.fca.3.gep, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %27, 3
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %21)
  %31 = sext i32 %27 to i64
  %32 = getelementptr ptr, ptr %21, i64 %31
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = call ptr @behavior_wrapper(ptr %34, { ptr, ptr, ptr, i32 } %28, ptr noundef nonnull align 8 %4)
  %36 = call { ptr, i160 } %35({ ptr, ptr, ptr, i32 } %28, { ptr, ptr, ptr, i32 } %28, ptr nonnull align 8 %4) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %36, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %36, 1
  %.fca.1.gep31 = getelementptr inbounds i8, ptr %5, i64 8
  %.fca.2.gep33 = getelementptr inbounds i8, ptr %5, i64 16
  %.fca.3.gep35 = getelementptr inbounds i8, ptr %5, i64 24
  br label %37

37:                                               ; preds = %90, %3
  %.sroa.3.0 = phi i160 [ %.fca.1.extract, %3 ], [ %.sroa.3.1, %90 ]
  %.sroa.0.0 = phi ptr [ %.fca.0.extract, %3 ], [ %.sroa.0.1, %90 ]
  %.0 = phi i160 [ undef, %3 ], [ %.1, %90 ]
  %38 = load ptr, ptr %7, align 8
  %39 = load ptr, ptr %6, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %39)
  %41 = load i32, ptr %9, align 8
  %42 = sext i32 %41 to i64
  %43 = getelementptr ptr, ptr %39, i64 %42
  %44 = load ptr, ptr %43, align 8
  %45 = call ptr @typegetter_wrapper(ptr %44, ptr %38)
  %46 = icmp ne ptr %.sroa.0.0, @nil_typ
  %47 = icmp ne ptr %.sroa.0.0, null
  %.not50 = and i1 %46, %47
  br i1 %.not50, label %48, label %90

48:                                               ; preds = %37
  %49 = insertvalue { ptr, i160 } undef, ptr %.sroa.0.0, 0
  %50 = insertvalue { ptr, i160 } %49, i160 %.sroa.3.0, 1
  %51 = load ptr, ptr %7, align 8
  %52 = load ptr, ptr %6, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %52)
  %54 = load i32, ptr %9, align 8
  %55 = sext i32 %54 to i64
  %56 = getelementptr ptr, ptr %52, i64 %55
  %57 = getelementptr i8, ptr %56, i64 16
  %58 = load ptr, ptr %57, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr } %59(ptr %51) #31
  %.fca.0.extract37 = extractvalue { ptr } %60, 0
  %61 = call i1 %.fca.0.extract37({ ptr, i160 } %50)
  %62 = xor i1 %61, true
  br i1 %61, label %90, label %63

63:                                               ; preds = %48
  %64 = load ptr, ptr %7, align 8
  %65 = load ptr, ptr %6, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %65)
  %67 = load i32, ptr %9, align 8
  %68 = sext i32 %67 to i64
  %69 = getelementptr ptr, ptr %65, i64 %68
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = load ptr, ptr %70, align 8
  %72 = load ptr, ptr %71, align 8
  %73 = call { ptr, ptr, ptr, i32 } %72(ptr %64) #31
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %73, 0
  store ptr %.fca.0.extract28, ptr %5, align 8
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %73, 1
  store ptr %.fca.1.extract30, ptr %.fca.1.gep31, align 8
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %73, 2
  store ptr %.fca.2.extract32, ptr %.fca.2.gep33, align 8
  %.fca.3.extract34 = extractvalue { ptr, ptr, ptr, i32 } %73, 3
  store i32 %.fca.3.extract34, ptr %.fca.3.gep35, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %74 = load ptr, ptr %5, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %74, 0
  %76 = load ptr, ptr %.fca.1.gep31, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %76, 1
  %78 = load ptr, ptr %.fca.2.gep33, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %78, 2
  %80 = load i32, ptr %.fca.3.gep35, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, i32 %80, 3
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %74)
  %84 = sext i32 %80 to i64
  %85 = getelementptr ptr, ptr %74, i64 %84
  %86 = getelementptr i8, ptr %85, i64 8
  %87 = load ptr, ptr %86, align 8
  %88 = call ptr @behavior_wrapper(ptr %87, { ptr, ptr, ptr, i32 } %81, ptr noundef nonnull align 8 %4)
  %89 = call { ptr, i160 } %88({ ptr, ptr, ptr, i32 } %81, { ptr, ptr, ptr, i32 } %81, ptr nonnull %4) #39
  %.fca.0.extract22 = extractvalue { ptr, i160 } %89, 0
  %.fca.1.extract24 = extractvalue { ptr, i160 } %89, 1
  br label %90

90:                                               ; preds = %63, %48, %37
  %.sroa.3.1 = phi i160 [ %.sroa.3.0, %48 ], [ %.fca.1.extract24, %63 ], [ %.sroa.3.0, %37 ]
  %.sroa.0.1 = phi ptr [ %.sroa.0.0, %48 ], [ %.fca.0.extract22, %63 ], [ %.sroa.0.0, %37 ]
  %.1 = phi i160 [ %.sroa.3.0, %48 ], [ %.sroa.3.0, %63 ], [ %.0, %37 ]
  %.reg2mem32.0.off0 = phi i1 [ %62, %48 ], [ %62, %63 ], [ false, %37 ]
  %.reg2mem34.0 = phi ptr [ %.sroa.0.0, %48 ], [ @nil_typ, %63 ], [ @nil_typ, %37 ]
  br i1 %.reg2mem32.0.off0, label %37, label %91

91:                                               ; preds = %90
  %.reload31.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem34.0, 0
  %.reload31.fca.1.insert = insertvalue { ptr, i160 } %.reload31.fca.0.insert, i160 %.1, 1
  ret { ptr, i160 } %.reload31.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterator_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterable_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterable_getter_iterable(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

define ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 216
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 240
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MapIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 288
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @MapIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 296
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @MapIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 304
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define ptr @MapIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 3037712219555723519, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 312
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

define void @MapIterable_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract4, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract5, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(520) @MapIterable)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %40 = load ptr, ptr %7, align 8
  %41 = load ptr, ptr %6, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %9, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 24
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  call void %49(ptr %40, { ptr } %4) #30
  ret void
}

define { ptr, ptr, ptr, i32 } @MapIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract35, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract37, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract39, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract41, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(520) @MapIterable)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract27, ptr %19, align 8
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep30 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract29, ptr %.fca.1.gep30, align 8
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep32 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract31, ptr %.fca.2.gep32, align 8
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep34 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract33, ptr %.fca.3.gep34, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep30, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep32, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep34, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract19 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract21 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract15, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract17, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract19, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract21, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 24
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %40) #31
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %41)
  %51 = load ptr, ptr %45, align 8
  %52 = call ptr @typegetter_wrapper(ptr %51, ptr %40)
  %53 = load ptr, ptr %6, align 8
  %54 = load ptr, ptr %5, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %54)
  %56 = load i32, ptr %8, align 8
  %57 = sext i32 %56 to i64
  %58 = getelementptr ptr, ptr %54, i64 %57
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = call ptr @typegetter_wrapper(ptr %60, ptr %53)
  %62 = alloca [3 x ptr], align 8
  store ptr @MapIterator, ptr %62, align 8
  %63 = getelementptr inbounds i8, ptr %62, i64 8
  store ptr %52, ptr %63, align 8
  %64 = getelementptr inbounds i8, ptr %62, i64 16
  store ptr %61, ptr %64, align 8
  %65 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_MapIterator, ptr noundef nonnull align 8 dereferenceable(24) %62)
  %66 = extractvalue { i64, i64 } %65, 0
  %67 = call ptr @bump_malloc(i64 %66)
  store ptr %52, ptr %67, align 8
  %68 = getelementptr i8, ptr %67, i64 8
  store ptr %61, ptr %68, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %67)
  %70 = load ptr, ptr %6, align 8
  %71 = load ptr, ptr %5, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %71)
  %73 = load i32, ptr %8, align 8
  %74 = sext i32 %73 to i64
  %75 = getelementptr ptr, ptr %71, i64 %74
  %76 = getelementptr i8, ptr %75, i64 16
  %77 = load ptr, ptr %76, align 8
  %78 = load ptr, ptr %77, align 8
  %79 = call { ptr, ptr, ptr, i32 } %78(ptr %70) #31
  %80 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %79, 0
  store ptr %.fca.0.extract2, ptr %80, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %79, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %80, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %79, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %80, i64 16
  store ptr %.fca.2.extract4, ptr %.fca.2.gep, align 8
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %79, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %80, i64 24
  store i32 %.fca.3.extract5, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %80, ptr noundef nonnull align 16 dereferenceable(80) @Iterable)
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %81, 0
  %83 = load ptr, ptr %.fca.1.gep, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %83, 1
  %85 = load ptr, ptr %.fca.2.gep, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 2
  %87 = load i32, ptr %.fca.3.gep, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, i32 %87, 3
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %81)
  %91 = sext i32 %87 to i64
  %92 = getelementptr ptr, ptr %81, i64 %91
  %93 = getelementptr i8, ptr %92, i64 8
  %94 = load ptr, ptr %93, align 8
  %95 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %88, ptr noundef nonnull align 8 %4)
  %96 = call { ptr, ptr, ptr, i32 } %95({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr nonnull %4) #39
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %96, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %96, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %96, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %96, 3
  %97 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %97, align 8
  %98 = getelementptr inbounds i8, ptr %97, i64 8
  store ptr %.fca.1.extract, ptr %98, align 8
  %99 = getelementptr inbounds i8, ptr %97, i64 16
  store ptr %.fca.2.extract, ptr %99, align 8
  %100 = getelementptr inbounds i8, ptr %97, i64 24
  store i32 %.fca.3.extract, ptr %100, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %97, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %101 = load ptr, ptr %6, align 8
  %102 = load ptr, ptr %5, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %102)
  %104 = load i32, ptr %8, align 8
  %105 = sext i32 %104 to i64
  %106 = getelementptr ptr, ptr %102, i64 %105
  %107 = getelementptr i8, ptr %106, i64 24
  %108 = load ptr, ptr %107, align 8
  %109 = load ptr, ptr %108, align 8
  %110 = call { ptr } %109(ptr %101) #31
  %111 = alloca { ptr, ptr, ptr, i32 }, align 8
  %112 = load ptr, ptr %97, align 8
  store ptr %112, ptr %111, align 8
  %113 = getelementptr inbounds i8, ptr %111, i64 8
  %114 = load ptr, ptr %98, align 8
  store ptr %114, ptr %113, align 8
  %115 = getelementptr inbounds i8, ptr %111, i64 16
  %116 = load ptr, ptr %99, align 8
  store ptr %116, ptr %115, align 8
  %117 = getelementptr inbounds i8, ptr %111, i64 24
  %118 = load i32, ptr %100, align 8
  store i32 %118, ptr %117, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %111, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %119 = load ptr, ptr %111, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = load ptr, ptr %113, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 1
  %123 = load ptr, ptr %115, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %123, 2
  %125 = load i32, ptr %117, align 8
  %126 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %125, 3
  %127 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %67, 1
  %128 = insertvalue { ptr, ptr, ptr, i32 } %127, ptr undef, 2
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, i32 10, 3
  %130 = load ptr, ptr %6, align 8
  %131 = load ptr, ptr %5, align 8
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %131)
  %133 = load i32, ptr %8, align 8
  %134 = sext i32 %133 to i64
  %135 = getelementptr ptr, ptr %131, i64 %134
  %136 = load ptr, ptr %135, align 8
  %137 = call ptr @typegetter_wrapper(ptr %136, ptr %130)
  %138 = call ptr @bump_malloc(i64 noundef 24)
  %139 = getelementptr i8, ptr %138, i64 8
  store ptr %137, ptr %139, align 8
  %140 = getelementptr i8, ptr %138, i64 16
  store ptr null, ptr %140, align 8
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %138)
  store ptr @Iterator, ptr %138, align 8
  %142 = load ptr, ptr %6, align 8
  %143 = load ptr, ptr %5, align 8
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %143)
  %145 = load i32, ptr %8, align 8
  %146 = sext i32 %145 to i64
  %147 = getelementptr ptr, ptr %143, i64 %146
  %148 = getelementptr i8, ptr %147, i64 8
  %149 = load ptr, ptr %148, align 8
  %150 = call ptr @typegetter_wrapper(ptr %149, ptr %142)
  %151 = load ptr, ptr %6, align 8
  %152 = load ptr, ptr %5, align 8
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %152)
  %154 = load i32, ptr %8, align 8
  %155 = sext i32 %154 to i64
  %156 = getelementptr ptr, ptr %152, i64 %155
  %157 = load ptr, ptr %156, align 8
  %158 = call ptr @typegetter_wrapper(ptr %157, ptr %151)
  %159 = call ptr @bump_malloc(i64 noundef 32)
  %160 = getelementptr i8, ptr %159, i64 16
  store ptr %158, ptr %160, align 8
  %161 = getelementptr i8, ptr %159, i64 8
  store ptr %150, ptr %161, align 8
  %162 = getelementptr i8, ptr %159, i64 24
  store ptr null, ptr %162, align 8
  %163 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %159)
  store ptr @function_typ, ptr %159, align 8
  %164 = alloca [2 x ptr], align 8
  store ptr %138, ptr %164, align 8
  %165 = getelementptr inbounds i8, ptr %164, i64 8
  store ptr %159, ptr %165, align 8
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %164)
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 16 dereferenceable(168) @MapIterator)
  %168 = alloca { ptr, ptr }, align 8
  store ptr %119, ptr %168, align 8
  %169 = getelementptr inbounds i8, ptr %168, i64 8
  store ptr @function_typ, ptr %169, align 8
  %170 = call ptr @behavior_wrapper(ptr noundef nonnull @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U, { ptr, ptr, ptr, i32 } %129, ptr noundef nonnull align 8 dereferenceable(16) %168)
  call void %170({ ptr, ptr, ptr, i32 } %129, { ptr, ptr, ptr, i32 } %129, ptr nonnull %164, { ptr, ptr, ptr, i32 } %126, { ptr } %110) #39
  %171 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @MapIterator, ptr %171, align 8
  %172 = getelementptr inbounds i8, ptr %171, i64 8
  store ptr %67, ptr %172, align 8
  %173 = getelementptr inbounds i8, ptr %171, i64 16
  %174 = getelementptr inbounds i8, ptr %171, i64 24
  store i32 10, ptr %174, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %171, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %175 = load ptr, ptr %171, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %175, 0
  %177 = load ptr, ptr %172, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, ptr %177, 1
  %179 = load ptr, ptr %173, align 8
  %180 = insertvalue { ptr, ptr, ptr, i32 } %178, ptr %179, 2
  %181 = load i32, ptr %174, align 8
  %182 = insertvalue { ptr, ptr, ptr, i32 } %180, i32 %181, 3
  ret { ptr, ptr, ptr, i32 } %182
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

define ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 8673632051301757104, i64 noundef ptrtoint (ptr @Iterator to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 128
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @MapIterator_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract4, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract5, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(168) @MapIterator)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %40 = load ptr, ptr %7, align 8
  %41 = load ptr, ptr %6, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %9, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 24
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  call void %49(ptr %40, { ptr } %4) #30
  ret void
}

define { ptr, i160 } @MapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract12, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract14, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract16, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract18, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(168) @MapIterator)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract2, ptr %19, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Iterator)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, i160 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %35, 0
  %36 = load ptr, ptr %6, align 8
  %37 = load ptr, ptr %5, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %37)
  %39 = load i32, ptr %8, align 8
  %40 = sext i32 %39 to i64
  %41 = getelementptr ptr, ptr %37, i64 %40
  %42 = load ptr, ptr %41, align 8
  %43 = call ptr @typegetter_wrapper(ptr %42, ptr %36)
  %44 = icmp ne ptr %.fca.0.extract, @nil_typ
  %45 = icmp ne ptr %.fca.0.extract, null
  %.not36 = and i1 %44, %45
  br i1 %.not36, label %46, label %58

46:                                               ; preds = %3
  %47 = load ptr, ptr %6, align 8
  %48 = load ptr, ptr %5, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %48)
  %50 = load i32, ptr %8, align 8
  %51 = sext i32 %50 to i64
  %52 = getelementptr ptr, ptr %48, i64 %51
  %53 = getelementptr i8, ptr %52, i64 24
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr } %55(ptr %47) #31
  %.fca.0.extract28 = extractvalue { ptr } %56, 0
  %57 = call { ptr, i160 } %.fca.0.extract28({ ptr, i160 } %35)
  %.fca.0.extract22 = extractvalue { ptr, i160 } %57, 0
  %.fca.1.extract24 = extractvalue { ptr, i160 } %57, 1
  br label %58

58:                                               ; preds = %46, %3
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract22, %46 ], [ @nil_typ, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract24, %46 ], [ undef, %3 ]
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem15.sroa.0.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.reg2mem15.sroa.3.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterator_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterator_getter_iterator(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_iterator(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterable_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterable_getter_iterable(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_iterable(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MappedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

define ptr @MappedCollection_B_init_collectionCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 224
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MappedCollection_field_MappedCollection_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 256
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 27, i64 26
  %8 = getelementptr [119 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MappedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @MappedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 29, %21 ], [ 29, %14 ], [ 30, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [119 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 31, %.critedge ], [ 32, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [119 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 33, %21 ], [ 33, %14 ], [ 34, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [119 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 36, %.critedge ], [ 35, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [119 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define void @MappedCollection_init_collectionCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #3 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract4, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract5, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1032) @MappedCollection)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = load ptr, ptr %10, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 8
  %17 = load ptr, ptr %11, align 8
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds i8, ptr %14, i64 16
  %19 = load ptr, ptr %12, align 8
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds i8, ptr %14, i64 24
  %21 = load i32, ptr %13, align 8
  store i32 %21, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %22 = load ptr, ptr %7, align 8
  %23 = load ptr, ptr %6, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %9, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %14, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %16, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %18, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  call void %31(ptr %22, { ptr, ptr, ptr, i32 } %39) #30
  %40 = load ptr, ptr %7, align 8
  %41 = load ptr, ptr %6, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %9, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 24
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  call void %49(ptr %40, { ptr } %4) #30
  ret void
}

define i32 @MappedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract3, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract5, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract7, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1032) @MappedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract, ptr %19, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull %4) #39
  ret i32 %35
}

define { ptr, ptr, ptr, i32 } @MappedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract35, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract37, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract39, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract41, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1032) @MappedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract27, ptr %19, align 8
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep30 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract29, ptr %.fca.1.gep30, align 8
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep32 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract31, ptr %.fca.2.gep32, align 8
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep34 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract33, ptr %.fca.3.gep34, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep30, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep32, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep34, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract19 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract21 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract15, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract17, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract19, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract21, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 24
  %47 = load ptr, ptr %46, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %40) #31
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %41)
  %51 = load ptr, ptr %45, align 8
  %52 = call ptr @typegetter_wrapper(ptr %51, ptr %40)
  %53 = load ptr, ptr %6, align 8
  %54 = load ptr, ptr %5, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %54)
  %56 = load i32, ptr %8, align 8
  %57 = sext i32 %56 to i64
  %58 = getelementptr ptr, ptr %54, i64 %57
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = call ptr @typegetter_wrapper(ptr %60, ptr %53)
  %62 = alloca [3 x ptr], align 8
  store ptr @MapIterator, ptr %62, align 8
  %63 = getelementptr inbounds i8, ptr %62, i64 8
  store ptr %52, ptr %63, align 8
  %64 = getelementptr inbounds i8, ptr %62, i64 16
  store ptr %61, ptr %64, align 8
  %65 = load ptr, ptr getelementptr inbounds (i8, ptr @MapIterator, i64 48), align 8
  %66 = call { i64, i64 } @size_wrapper(ptr %65, ptr noundef nonnull align 8 dereferenceable(24) %62)
  %67 = extractvalue { i64, i64 } %66, 0
  %68 = call ptr @bump_malloc(i64 %67)
  store ptr %52, ptr %68, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  store ptr %61, ptr %69, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %68)
  %71 = load ptr, ptr %6, align 8
  %72 = load ptr, ptr %5, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %72)
  %74 = load i32, ptr %8, align 8
  %75 = sext i32 %74 to i64
  %76 = getelementptr ptr, ptr %72, i64 %75
  %77 = getelementptr i8, ptr %76, i64 16
  %78 = load ptr, ptr %77, align 8
  %79 = load ptr, ptr %78, align 8
  %80 = call { ptr, ptr, ptr, i32 } %79(ptr %71) #31
  %81 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %80, 0
  store ptr %.fca.0.extract2, ptr %81, align 8
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %80, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %81, i64 8
  store ptr %.fca.1.extract3, ptr %.fca.1.gep, align 8
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %80, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %81, i64 16
  store ptr %.fca.2.extract4, ptr %.fca.2.gep, align 8
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %80, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %81, i64 24
  store i32 %.fca.3.extract5, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %81, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %82 = load ptr, ptr %81, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %82, 0
  %84 = load ptr, ptr %.fca.1.gep, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %84, 1
  %86 = load ptr, ptr %.fca.2.gep, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %85, ptr %86, 2
  %88 = load i32, ptr %.fca.3.gep, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, i32 %88, 3
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %82)
  %92 = sext i32 %88 to i64
  %93 = getelementptr ptr, ptr %82, i64 %92
  %94 = getelementptr i8, ptr %93, i64 16
  %95 = load ptr, ptr %94, align 8
  %96 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %89, ptr noundef nonnull align 8 %4)
  %97 = call { ptr, ptr, ptr, i32 } %96({ ptr, ptr, ptr, i32 } %89, { ptr, ptr, ptr, i32 } %89, ptr nonnull %4) #39
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %97, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %97, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %97, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %97, 3
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %98, align 8
  %99 = getelementptr inbounds i8, ptr %98, i64 8
  store ptr %.fca.1.extract, ptr %99, align 8
  %100 = getelementptr inbounds i8, ptr %98, i64 16
  store ptr %.fca.2.extract, ptr %100, align 8
  %101 = getelementptr inbounds i8, ptr %98, i64 24
  store i32 %.fca.3.extract, ptr %101, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %98, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %102 = load ptr, ptr %6, align 8
  %103 = load ptr, ptr %5, align 8
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %103)
  %105 = load i32, ptr %8, align 8
  %106 = sext i32 %105 to i64
  %107 = getelementptr ptr, ptr %103, i64 %106
  %108 = getelementptr i8, ptr %107, i64 24
  %109 = load ptr, ptr %108, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = call { ptr } %110(ptr %102) #31
  %112 = alloca { ptr, ptr, ptr, i32 }, align 8
  %113 = load ptr, ptr %98, align 8
  store ptr %113, ptr %112, align 8
  %114 = getelementptr inbounds i8, ptr %112, i64 8
  %115 = load ptr, ptr %99, align 8
  store ptr %115, ptr %114, align 8
  %116 = getelementptr inbounds i8, ptr %112, i64 16
  %117 = load ptr, ptr %100, align 8
  store ptr %117, ptr %116, align 8
  %118 = getelementptr inbounds i8, ptr %112, i64 24
  %119 = load i32, ptr %101, align 8
  store i32 %119, ptr %118, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %112, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %120 = load ptr, ptr %112, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %120, 0
  %122 = load ptr, ptr %114, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } %121, ptr %122, 1
  %124 = load ptr, ptr %116, align 8
  %125 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %124, 2
  %126 = load i32, ptr %118, align 8
  %127 = insertvalue { ptr, ptr, ptr, i32 } %125, i32 %126, 3
  %128 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %68, 1
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr undef, 2
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, i32 10, 3
  %131 = load ptr, ptr %6, align 8
  %132 = load ptr, ptr %5, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %132)
  %134 = load i32, ptr %8, align 8
  %135 = sext i32 %134 to i64
  %136 = getelementptr ptr, ptr %132, i64 %135
  %137 = load ptr, ptr %136, align 8
  %138 = call ptr @typegetter_wrapper(ptr %137, ptr %131)
  %139 = call ptr @bump_malloc(i64 noundef 24)
  %140 = getelementptr i8, ptr %139, i64 8
  store ptr %138, ptr %140, align 8
  %141 = getelementptr i8, ptr %139, i64 16
  store ptr null, ptr %141, align 8
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %139)
  store ptr @Iterator, ptr %139, align 8
  %143 = load ptr, ptr %6, align 8
  %144 = load ptr, ptr %5, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %144)
  %146 = load i32, ptr %8, align 8
  %147 = sext i32 %146 to i64
  %148 = getelementptr ptr, ptr %144, i64 %147
  %149 = getelementptr i8, ptr %148, i64 8
  %150 = load ptr, ptr %149, align 8
  %151 = call ptr @typegetter_wrapper(ptr %150, ptr %143)
  %152 = load ptr, ptr %6, align 8
  %153 = load ptr, ptr %5, align 8
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 952, ptr nocapture nofree noundef %153)
  %155 = load i32, ptr %8, align 8
  %156 = sext i32 %155 to i64
  %157 = getelementptr ptr, ptr %153, i64 %156
  %158 = load ptr, ptr %157, align 8
  %159 = call ptr @typegetter_wrapper(ptr %158, ptr %152)
  %160 = call ptr @bump_malloc(i64 noundef 32)
  %161 = getelementptr i8, ptr %160, i64 16
  store ptr %159, ptr %161, align 8
  %162 = getelementptr i8, ptr %160, i64 8
  store ptr %151, ptr %162, align 8
  %163 = getelementptr i8, ptr %160, i64 24
  store ptr null, ptr %163, align 8
  %164 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %160)
  store ptr @function_typ, ptr %160, align 8
  %165 = alloca [2 x ptr], align 8
  store ptr %139, ptr %165, align 8
  %166 = getelementptr inbounds i8, ptr %165, i64 8
  store ptr %160, ptr %166, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %165)
  %168 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(144) @MapIterator)
  %169 = load ptr, ptr getelementptr inbounds (i8, ptr @MapIterator, i64 112), align 8
  %170 = alloca { ptr, ptr }, align 8
  store ptr %120, ptr %170, align 8
  %171 = getelementptr inbounds i8, ptr %170, i64 8
  store ptr @function_typ, ptr %171, align 8
  %172 = call ptr @behavior_wrapper(ptr %169, { ptr, ptr, ptr, i32 } %130, ptr noundef nonnull align 8 dereferenceable(16) %170)
  call void %172({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull %165, { ptr, ptr, ptr, i32 } %127, { ptr } %111) #39
  %173 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @MapIterator, ptr %173, align 8
  %174 = getelementptr inbounds i8, ptr %173, i64 8
  store ptr %68, ptr %174, align 8
  %175 = getelementptr inbounds i8, ptr %173, i64 16
  %176 = getelementptr inbounds i8, ptr %173, i64 24
  store i32 10, ptr %176, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %173, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %177 = load ptr, ptr %173, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %177, 0
  %179 = load ptr, ptr %174, align 8
  %180 = insertvalue { ptr, ptr, ptr, i32 } %178, ptr %179, 1
  %181 = load ptr, ptr %175, align 8
  %182 = insertvalue { ptr, ptr, ptr, i32 } %180, ptr %181, 2
  %183 = load i32, ptr %176, align 8
  %184 = insertvalue { ptr, ptr, ptr, i32 } %182, i32 %183, 3
  ret { ptr, ptr, ptr, i32 } %184
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MappedCollection_getter_f(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_f(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MappedCollection_getter_collection(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MappedCollection_setter_collection(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_EnumeratedCollection(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @EnumeratedCollection_B_init_collectionCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 216
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @EnumeratedCollection_field_EnumeratedCollection_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Pair, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 248
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 25, i64 26
  %8 = getelementptr [118 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @EnumeratedCollection_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 29, %.critedge ], [ 28, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 30, %.critedge ], [ 31, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %13, label %._crit_edge, label %14

14:                                               ; preds = %2
  %15 = load i64, ptr %5, align 4
  %16 = load i64, ptr %6, align 4
  %17 = load ptr, ptr %7, align 8
  %18 = load ptr, ptr %8, align 8
  %19 = load i64, ptr @Iterable, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %18)
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %14
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %._crit_edge

._crit_edge:                                      ; preds = %21, %14, %2
  %27 = phi i32 [ 32, %21 ], [ 32, %14 ], [ 33, %2 ]
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = zext nneg i32 %27 to i64
  %30 = getelementptr [118 x ptr], ptr %28, i64 0, i64 %29
  %31 = getelementptr i8, ptr %30, i64 80
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %20, label %.critedge, label %26

.critedge:                                        ; preds = %15, %2
  %21 = load i64, ptr %5, align 4
  %22 = load i64, ptr %6, align 4
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 noundef 1375598993350293883, i64 noundef ptrtoint (ptr @Collection to i64), ptr %24)
  br label %26

26:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 35, %.critedge ], [ 34, %15 ]
  %27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %28 = zext nneg i32 %.reg2mem3.0 to i64
  %29 = getelementptr [118 x ptr], ptr %27, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

define void @EnumeratedCollection_init_collectionCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract4, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1024) @EnumeratedCollection)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = load ptr, ptr %9, align 8
  store ptr %14, ptr %13, align 8
  %15 = getelementptr inbounds i8, ptr %13, i64 8
  %16 = load ptr, ptr %10, align 8
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds i8, ptr %13, i64 16
  %18 = load ptr, ptr %11, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds i8, ptr %13, i64 24
  %20 = load i32, ptr %12, align 8
  store i32 %20, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %5, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %8, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %13, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = load ptr, ptr %15, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 1
  %35 = load ptr, ptr %17, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 2
  %37 = load i32, ptr %19, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %37, 3
  call void %30(ptr %21, { ptr, ptr, ptr, i32 } %38) #30
  ret void
}

define i32 @EnumeratedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract3, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract5, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract7, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1024) @EnumeratedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract, ptr %19, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull %4) #39
  ret i32 %35
}

define { ptr, ptr, ptr, i32 } @EnumeratedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract33, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract35, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract37, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1024) @EnumeratedCollection)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract23, ptr %19, align 8
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep26 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract25, ptr %.fca.1.gep26, align 8
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep28 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract27, ptr %.fca.2.gep28, align 8
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep30 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract29, ptr %.fca.3.gep30, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep26, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep28, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep30, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr, ptr, ptr, i32 } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 %4) #39
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr %.fca.1.extract13, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr %.fca.2.extract15, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store i32 %.fca.3.extract17, ptr %39, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %36, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = load ptr, ptr %45, align 8
  %47 = call ptr @typegetter_wrapper(ptr %46, ptr %40)
  %48 = load ptr, ptr %6, align 8
  %49 = load ptr, ptr %5, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %49)
  %51 = load i32, ptr %8, align 8
  %52 = sext i32 %51 to i64
  %53 = getelementptr ptr, ptr %49, i64 %52
  %54 = load ptr, ptr %53, align 8
  %55 = call ptr @typegetter_wrapper(ptr %54, ptr %48)
  %56 = call ptr @bump_malloc(i64 noundef 32)
  %57 = getelementptr i8, ptr %56, i64 16
  store ptr %55, ptr %57, align 8
  %58 = getelementptr i8, ptr %56, i64 8
  store ptr @_parameterization_i32, ptr %58, align 8
  %59 = getelementptr i8, ptr %56, i64 24
  store ptr null, ptr %59, align 8
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %56)
  store ptr @Pair, ptr %56, align 8
  %61 = alloca [3 x ptr], align 8
  store ptr @Enumerator, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %61, i64 8
  store ptr %47, ptr %62, align 8
  %63 = getelementptr inbounds i8, ptr %61, i64 16
  store ptr %56, ptr %63, align 8
  %64 = load ptr, ptr getelementptr inbounds (i8, ptr @Enumerator, i64 48), align 8
  %65 = call { i64, i64 } @size_wrapper(ptr %64, ptr noundef nonnull align 8 dereferenceable(24) %61)
  %66 = extractvalue { i64, i64 } %65, 0
  %67 = call ptr @bump_malloc(i64 %66)
  store ptr %47, ptr %67, align 8
  %68 = getelementptr i8, ptr %67, i64 8
  store ptr %56, ptr %68, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %67)
  %70 = load ptr, ptr %6, align 8
  %71 = load ptr, ptr %5, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %71)
  %73 = load i32, ptr %8, align 8
  %74 = sext i32 %73 to i64
  %75 = getelementptr ptr, ptr %71, i64 %74
  %76 = getelementptr i8, ptr %75, i64 16
  %77 = load ptr, ptr %76, align 8
  %78 = load ptr, ptr %77, align 8
  %79 = call { ptr, ptr, ptr, i32 } %78(ptr %70) #31
  %80 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %79, 0
  store ptr %.fca.0.extract1, ptr %80, align 8
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %79, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %80, i64 8
  store ptr %.fca.1.extract2, ptr %.fca.1.gep, align 8
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %79, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %80, i64 16
  store ptr %.fca.2.extract3, ptr %.fca.2.gep, align 8
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %79, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %80, i64 24
  store i32 %.fca.3.extract4, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %80, ptr noundef nonnull align 16 dereferenceable(80) @Collection)
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %81, 0
  %83 = load ptr, ptr %.fca.1.gep, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %83, 1
  %85 = load ptr, ptr %.fca.2.gep, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 2
  %87 = load i32, ptr %.fca.3.gep, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, i32 %87, 3
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 456, ptr nocapture nofree noundef %81)
  %91 = sext i32 %87 to i64
  %92 = getelementptr ptr, ptr %81, i64 %91
  %93 = getelementptr i8, ptr %92, i64 16
  %94 = load ptr, ptr %93, align 8
  %95 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %88, ptr noundef nonnull align 8 %4)
  %96 = call { ptr, ptr, ptr, i32 } %95({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %96, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %96, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %96, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %96, 3
  %97 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %97, align 8
  %98 = getelementptr inbounds i8, ptr %97, i64 8
  store ptr %.fca.1.extract, ptr %98, align 8
  %99 = getelementptr inbounds i8, ptr %97, i64 16
  store ptr %.fca.2.extract, ptr %99, align 8
  %100 = getelementptr inbounds i8, ptr %97, i64 24
  store i32 %.fca.3.extract, ptr %100, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %97, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %101 = alloca { ptr, ptr, ptr, i32 }, align 8
  %102 = load ptr, ptr %97, align 8
  store ptr %102, ptr %101, align 8
  %103 = getelementptr inbounds i8, ptr %101, i64 8
  %104 = load ptr, ptr %98, align 8
  store ptr %104, ptr %103, align 8
  %105 = getelementptr inbounds i8, ptr %101, i64 16
  %106 = load ptr, ptr %99, align 8
  store ptr %106, ptr %105, align 8
  %107 = getelementptr inbounds i8, ptr %101, i64 24
  %108 = load i32, ptr %100, align 8
  store i32 %108, ptr %107, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %101, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %109 = load ptr, ptr %101, align 8
  %110 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %109, 0
  %111 = load ptr, ptr %103, align 8
  %112 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %111, 1
  %113 = load ptr, ptr %105, align 8
  %114 = insertvalue { ptr, ptr, ptr, i32 } %112, ptr %113, 2
  %115 = load i32, ptr %107, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %114, i32 %115, 3
  %117 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Enumerator, ptr undef, ptr undef, i32 undef }, ptr %67, 1
  %118 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr undef, 2
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, i32 10, 3
  %120 = load ptr, ptr %6, align 8
  %121 = load ptr, ptr %5, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 944, ptr nocapture nofree noundef %121)
  %123 = load i32, ptr %8, align 8
  %124 = sext i32 %123 to i64
  %125 = getelementptr ptr, ptr %121, i64 %124
  %126 = load ptr, ptr %125, align 8
  %127 = call ptr @typegetter_wrapper(ptr %126, ptr %120)
  %128 = call ptr @bump_malloc(i64 noundef 24)
  %129 = getelementptr i8, ptr %128, i64 8
  store ptr %127, ptr %129, align 8
  %130 = getelementptr i8, ptr %128, i64 16
  store ptr null, ptr %130, align 8
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %128)
  store ptr @Iterator, ptr %128, align 8
  %132 = alloca [1 x ptr], align 8
  store ptr %128, ptr %132, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %132)
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(144) @Enumerator)
  %135 = load ptr, ptr getelementptr inbounds (i8, ptr @Enumerator, i64 112), align 8
  %136 = alloca { ptr }, align 8
  store ptr %109, ptr %136, align 8
  %137 = call ptr @behavior_wrapper(ptr %135, { ptr, ptr, ptr, i32 } %119, ptr noundef nonnull align 8 dereferenceable(8) %136)
  call void %137({ ptr, ptr, ptr, i32 } %119, { ptr, ptr, ptr, i32 } %119, ptr nonnull %132, { ptr, ptr, ptr, i32 } %116) #39
  %138 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @Enumerator, ptr %138, align 8
  %139 = getelementptr inbounds i8, ptr %138, i64 8
  store ptr %67, ptr %139, align 8
  %140 = getelementptr inbounds i8, ptr %138, i64 16
  %141 = getelementptr inbounds i8, ptr %138, i64 24
  store i32 10, ptr %141, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %138, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %142 = load ptr, ptr %138, align 8
  %143 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %142, 0
  %144 = load ptr, ptr %139, align 8
  %145 = insertvalue { ptr, ptr, ptr, i32 } %143, ptr %144, 1
  %146 = load ptr, ptr %140, align 8
  %147 = insertvalue { ptr, ptr, ptr, i32 } %145, ptr %146, 2
  %148 = load i32, ptr %141, align 8
  %149 = insertvalue { ptr, ptr, ptr, i32 } %147, i32 %148, 3
  ret { ptr, ptr, ptr, i32 } %149
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @EnumeratedCollection_getter_collection(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @EnumeratedCollection_setter_collection(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_StringIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 40, i64 8 }
}

define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 120
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @StringIterator_field_StringIterator_0(ptr nocapture nofree readnone %0) #1 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract4, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(160) @StringIterator)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = load ptr, ptr %9, align 8
  store ptr %14, ptr %13, align 8
  %15 = getelementptr inbounds i8, ptr %13, i64 8
  %16 = load ptr, ptr %10, align 8
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds i8, ptr %13, i64 16
  %18 = load ptr, ptr %11, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds i8, ptr %13, i64 24
  %20 = load i32, ptr %12, align 8
  store i32 %20, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %5, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %8, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %13, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %30, 0
  %32 = load ptr, ptr %15, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %32, 1
  %34 = load ptr, ptr %17, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 2
  %36 = load i32, ptr %19, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, i32 %36, 3
  call void %29(ptr %21, { ptr, ptr, ptr, i32 } %37) #30
  %38 = load ptr, ptr %6, align 8
  %39 = load ptr, ptr %5, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %39)
  %41 = load i32, ptr %8, align 8
  %42 = sext i32 %41 to i64
  %43 = getelementptr ptr, ptr %39, i64 %42
  %44 = getelementptr i8, ptr %43, i64 8
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  call void %47(ptr %38, i32 0) #30
  ret void
}

define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract10, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr %.fca.1.extract12, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr %.fca.2.extract14, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %14, i64 24
  store i32 %.fca.3.extract16, ptr %17, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(160) @StringIterator)
  %18 = load ptr, ptr %15, align 8
  %19 = load ptr, ptr %14, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %19)
  %21 = load i32, ptr %17, align 8
  %22 = sext i32 %21 to i64
  %23 = getelementptr ptr, ptr %19, i64 %22
  %24 = getelementptr i8, ptr %23, i64 8
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %18) #31
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %19)
  %29 = load ptr, ptr %23, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr, ptr, ptr, i32 } %30(ptr %18) #31
  %32 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %31, 0
  store ptr %.fca.0.extract, ptr %32, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %31, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %32, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %31, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %32, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %31, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %32, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %32, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %33, 0
  %35 = load ptr, ptr %.fca.1.gep, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 1
  %37 = load ptr, ptr %.fca.2.gep, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %37, 2
  %39 = load i32, ptr %.fca.3.gep, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %39, 3
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %33)
  %43 = sext i32 %39 to i64
  %44 = getelementptr ptr, ptr %33, i64 %43
  %45 = getelementptr i8, ptr %44, i64 64
  %46 = load ptr, ptr %45, align 8
  %47 = call ptr @behavior_wrapper(ptr %46, { ptr, ptr, ptr, i32 } %40, ptr noundef nonnull align 8 %4)
  %48 = call i32 %47({ ptr, ptr, ptr, i32 } %40, { ptr, ptr, ptr, i32 } %40, ptr nonnull %4) #39
  %.not = icmp slt i32 %27, %48
  br i1 %.not, label %49, label %136

49:                                               ; preds = %3
  %50 = load ptr, ptr %15, align 8
  %51 = load ptr, ptr %14, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %51)
  %53 = load i32, ptr %17, align 8
  %54 = sext i32 %53 to i64
  %55 = getelementptr ptr, ptr %51, i64 %54
  %56 = getelementptr i8, ptr %55, i64 8
  %57 = load ptr, ptr %56, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call i32 %58(ptr %50) #31
  %60 = add i32 %59, 1
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %51)
  %62 = getelementptr i8, ptr %57, i64 8
  %63 = load ptr, ptr %62, align 8
  call void %63(ptr %50, i32 %60) #30
  %64 = load ptr, ptr %15, align 8
  %65 = load ptr, ptr %14, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %65)
  %67 = load i32, ptr %17, align 8
  %68 = sext i32 %67 to i64
  %69 = getelementptr ptr, ptr %65, i64 %68
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = load ptr, ptr %70, align 8
  %72 = load ptr, ptr %71, align 8
  %73 = call i32 %72(ptr %64) #31
  %74 = add i32 %73, -1
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %65)
  %76 = load ptr, ptr %69, align 8
  %77 = load ptr, ptr %76, align 8
  %78 = call { ptr, ptr, ptr, i32 } %77(ptr %64) #31
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %78, 0
  store ptr %.fca.0.extract34, ptr %5, align 8
  %.fca.1.extract36 = extractvalue { ptr, ptr, ptr, i32 } %78, 1
  %.fca.1.gep37 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract36, ptr %.fca.1.gep37, align 8
  %.fca.2.extract38 = extractvalue { ptr, ptr, ptr, i32 } %78, 2
  %.fca.2.gep39 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract38, ptr %.fca.2.gep39, align 8
  %.fca.3.extract40 = extractvalue { ptr, ptr, ptr, i32 } %78, 3
  %.fca.3.gep41 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract40, ptr %.fca.3.gep41, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %79 = load ptr, ptr %5, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %79, 0
  %81 = load ptr, ptr %.fca.1.gep37, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %81, 1
  %83 = load ptr, ptr %.fca.2.gep39, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %83, 2
  %85 = load i32, ptr %.fca.3.gep41, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 %85, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %79)
  %89 = sext i32 %85 to i64
  %90 = getelementptr ptr, ptr %79, i64 %89
  %91 = getelementptr i8, ptr %90, i64 120
  %92 = load ptr, ptr %91, align 8
  store ptr @i32_typ, ptr %7, align 8
  %93 = call ptr @behavior_wrapper(ptr %92, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %94 = call i8 %93({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %6, i32 %74) #39
  store ptr @Character, ptr %8, align 8
  %95 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Character, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %96 = extractvalue { i64, i64 } %95, 0
  %97 = call ptr @bump_malloc(i64 %96)
  %98 = load ptr, ptr %15, align 8
  %99 = load ptr, ptr %14, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %99)
  %101 = load i32, ptr %17, align 8
  %102 = sext i32 %101 to i64
  %103 = getelementptr ptr, ptr %99, i64 %102
  %104 = getelementptr i8, ptr %103, i64 8
  %105 = load ptr, ptr %104, align 8
  %106 = load ptr, ptr %105, align 8
  %107 = call i32 %106(ptr %98) #31
  %108 = add i32 %107, -1
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %99)
  %110 = load ptr, ptr %103, align 8
  %111 = load ptr, ptr %110, align 8
  %112 = call { ptr, ptr, ptr, i32 } %111(ptr %98) #31
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %112, 0
  store ptr %.fca.0.extract19, ptr %9, align 8
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %112, 1
  %.fca.1.gep22 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract21, ptr %.fca.1.gep22, align 8
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %112, 2
  %.fca.2.gep24 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract23, ptr %.fca.2.gep24, align 8
  %.fca.3.extract25 = extractvalue { ptr, ptr, ptr, i32 } %112, 3
  %.fca.3.gep26 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract25, ptr %.fca.3.gep26, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %113 = load ptr, ptr %9, align 8
  %114 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %113, 0
  %115 = load ptr, ptr %.fca.1.gep22, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr %115, 1
  %117 = load ptr, ptr %.fca.2.gep24, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr %117, 2
  %119 = load i32, ptr %.fca.3.gep26, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } %118, i32 %119, 3
  store ptr @_parameterization_i32, ptr %10, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %10)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %113)
  %123 = sext i32 %119 to i64
  %124 = getelementptr ptr, ptr %113, i64 %123
  %125 = getelementptr i8, ptr %124, i64 120
  %126 = load ptr, ptr %125, align 8
  store ptr @i32_typ, ptr %11, align 8
  %127 = call ptr @behavior_wrapper(ptr %126, { ptr, ptr, ptr, i32 } %120, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %128 = call i8 %127({ ptr, ptr, ptr, i32 } %120, { ptr, ptr, ptr, i32 } %120, ptr nonnull %10, i32 %108) #39
  %129 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Character, ptr undef, ptr undef, i32 undef }, ptr %97, 1
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, ptr undef, 2
  %131 = insertvalue { ptr, ptr, ptr, i32 } %130, i32 10, 3
  store ptr @_parameterization_i8, ptr %12, align 8
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %12)
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 16 dereferenceable(120) @Character)
  store ptr @i8_typ, ptr %13, align 8
  %134 = call ptr @behavior_wrapper(ptr noundef nonnull @Character_B_init_bytei8, { ptr, ptr, ptr, i32 } %131, ptr noundef nonnull align 8 dereferenceable(8) %13)
  call void %134({ ptr, ptr, ptr, i32 } %131, { ptr, ptr, ptr, i32 } %131, ptr nonnull %12, i8 %128) #39
  %135 = ptrtoint ptr %97 to i64
  %.sroa.3.8.insert.ext = zext i64 %135 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %136

136:                                              ; preds = %49, %3
  %.reg2mem25.sroa.0.0 = phi ptr [ @Character, %49 ], [ @nil_typ, %3 ]
  %.reg2mem25.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %49 ], [ undef, %3 ]
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Character(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_bytei8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i8_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

define { ptr, i160 } @_box_i8_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i8_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_i8_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i8_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_byte_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Character_init_bytei8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(120) @Character)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %9, i8 %3) #30
  ret void
}

define i8 @Character_byte_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(120) @Character)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = call i8 %15(ptr %8) #31
  ret i8 %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i8 @Character_getter_byte(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0) #6 {
  %2 = load i8, ptr %0, align 1
  ret i8 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_byte(ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %0, i8 %1) #7 {
  store i8 %1, ptr %0, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_buffer_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

define { ptr, i160 } @_box_buffer_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_buffer_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @buffer_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_buffer_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_length(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #7 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Representable(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(96) @Representable)
  %8 = call ptr @bump_malloc(i64 noundef 7)
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %8, align 1
  %9 = alloca [1 x ptr], align 8
  store ptr @String, ptr %9, align 8
  %10 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %9)
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = call ptr @bump_malloc(i64 %11)
  %13 = insertvalue { ptr } undef, ptr %8, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %12, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 10, 3
  %17 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr @_parameterization_i32, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %17)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %22 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %22, i64 8
  store ptr @i32_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %22, i64 16
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %16, ptr noundef nonnull align 8 dereferenceable(24) %22)
  call void %25({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %17, { ptr } %13, i32 6, i32 7) #39
  %26 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @String, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr %12, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %26, i64 16
  %29 = getelementptr inbounds i8, ptr %26, i64 24
  store i32 10, ptr %29, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %26, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %30 = load ptr, ptr %26, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %30, 0
  %32 = load ptr, ptr %27, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %32, 1
  %34 = load ptr, ptr %28, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 2
  %36 = load i32, ptr %29, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

define { ptr, i160 } @_box_i64_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i64_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_i64_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_i64_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_f64_typ(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 8 }
}

define { ptr, i160 } @_box_f64_typ(ptr nocapture nofree readonly %0, ptr %1) #3 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_f64_typ, ptr %1)
  %4 = extractvalue { i64, i64 } %3, 0
  %5 = icmp slt i64 %4, 17
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = call ptr @bump_malloc(i64 %4)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %7, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  store ptr %7, ptr %.sroa.2, align 8
  br label %9

8:                                                ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %4, i1 noundef false)
  br label %9

9:                                                ; preds = %8, %6
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %10 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %10
}

define void @_unbox_f64_typ({ ptr, i160 } %0, ptr %1, ptr nocapture nofree writeonly %2) #3 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = load ptr, ptr %.fca.1.gep, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_f64_typ, ptr %1)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = icmp slt i64 %7, 17
  %9 = select i1 %8, ptr %.fca.1.gep, ptr %5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %9, i64 %7, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Array(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterableT(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #29
  %3 = load ptr, ptr %0, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %12 = load i64, ptr @Iterable, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %10, i64 %9, i64 %8, i64 %12, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %11)
  ret ptr @Array__Self_from_iterable_iterableIterableT
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 392
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @Array_B_extend_otherArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef -5261542750394134544, i64 noundef ptrtoint (ptr @Array to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 400
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B__set_index_xi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = load i64, ptr @any_typ, align 8
  %15 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 %14, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %13)
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = getelementptr i8, ptr %16, i64 424
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_unchecked_insert_xi32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = load i64, ptr @any_typ, align 8
  %15 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 %14, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %13)
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = getelementptr i8, ptr %16, i64 440
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 472
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %7 = select i1 %5, i64 54, i64 53
  %8 = getelementptr [149 x ptr], ptr %6, i64 0, i64 %7
  %9 = getelementptr i8, ptr %8, i64 80
  %10 = load ptr, ptr %9, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Array_B_chain_otherIterableT_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Collection, align 8
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %21, label %.critedge, label %28

.critedge:                                        ; preds = %15, %2
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = load i64, ptr @Collection, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 %26, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %28

28:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 57, %.critedge ], [ 56, %15 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %.reg2mem3.0 to i64
  %31 = getelementptr [149 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Array_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 8
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 59, %22 ], [ 59, %15 ], [ 58, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [149 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Array_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  br i1 %14, label %15, label %.critedge

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Collection, align 8
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Collection to i64), ptr %19)
  br i1 %21, label %.critedge, label %28

.critedge:                                        ; preds = %15, %2
  %22 = load i64, ptr %5, align 4
  %23 = load i64, ptr %6, align 4
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %8, align 8
  %26 = load i64, ptr @Collection, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %24, i64 %23, i64 %22, i64 %26, i64 noundef ptrtoint (ptr @Collection to i64), ptr %25)
  br label %28

28:                                               ; preds = %.critedge, %15
  %.reg2mem3.0 = phi i32 [ 61, %.critedge ], [ 60, %15 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %.reg2mem3.0 to i64
  %31 = getelementptr [149 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

define ptr @Array_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Collection, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %12)
  br i1 %14, label %._crit_edge, label %15

15:                                               ; preds = %2
  %16 = load i64, ptr %5, align 4
  %17 = load i64, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %8, align 8
  %20 = load i64, ptr @Iterable, align 8
  %21 = call i1 @subtype_test_wrapper(ptr %18, i64 %17, i64 %16, i64 %20, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %19)
  br i1 %21, label %22, label %._crit_edge

22:                                               ; preds = %15
  %23 = load i64, ptr %5, align 4
  %24 = load i64, ptr %6, align 4
  %25 = load ptr, ptr %7, align 8
  %26 = load ptr, ptr %8, align 8
  %27 = call i1 @subtype_test_wrapper(ptr %25, i64 %24, i64 %23, i64 %13, i64 noundef ptrtoint (ptr @Collection to i64), ptr %26)
  br label %._crit_edge

._crit_edge:                                      ; preds = %22, %15, %2
  %28 = phi i32 [ 62, %22 ], [ 62, %15 ], [ 63, %2 ]
  %29 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %30 = zext nneg i32 %28 to i64
  %31 = getelementptr [149 x ptr], ptr %29, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  ret ptr %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterableT(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #3 {
  %3 = alloca [0 x ptr], align 8
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract26, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract27, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract28, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract29, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 8 dereferenceable(56) @Iterable)
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract26)
  %13 = sext i32 %.fca.3.extract29 to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract26, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr @typegetter_wrapper(ptr %15, ptr %.fca.1.extract27)
  %17 = alloca [2 x ptr], align 8
  store ptr @Array, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %16, ptr %18, align 8
  %19 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Array, ptr noundef nonnull align 8 dereferenceable(16) %17)
  %20 = extractvalue { i64, i64 } %19, 0
  %21 = call ptr @bump_malloc(i64 %20)
  store ptr %16, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21)
  %23 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %21, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr undef, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 10, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array)
  %28 = call ptr @behavior_wrapper(ptr noundef nonnull @Array_B_init_, { ptr, ptr, ptr, i32 } %25, ptr noundef nonnull align 8 %3)
  call void %28({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %3) #39
  %29 = load ptr, ptr %8, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %29, 0
  %31 = load ptr, ptr %9, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %31, 1
  %33 = load ptr, ptr %10, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 2
  %35 = load i32, ptr %11, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %35, 3
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 200, ptr nocapture nofree noundef %29)
  %39 = sext i32 %35 to i64
  %40 = getelementptr ptr, ptr %29, i64 %39
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  %43 = call ptr @behavior_wrapper(ptr %42, { ptr, ptr, ptr, i32 } %36, ptr noundef nonnull align 8 %3)
  %44 = call { ptr, ptr, ptr, i32 } %43({ ptr, ptr, ptr, i32 } %36, { ptr, ptr, ptr, i32 } %36, ptr nonnull align 8 %3) #39
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %44, 3
  %45 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr %.fca.1.extract, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %45, i64 16
  store ptr %.fca.2.extract, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %45, i64 24
  store i32 %.fca.3.extract, ptr %48, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %45, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %49 = load ptr, ptr %45, align 8
  %50 = load ptr, ptr %46, align 8
  %51 = load ptr, ptr %47, align 8
  %52 = load i32, ptr %48, align 8
  %53 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %49, 0
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %50, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %51, 2
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 %52, 3
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %49)
  %59 = sext i32 %52 to i64
  %60 = getelementptr ptr, ptr %49, i64 %59
  %61 = getelementptr i8, ptr %60, i64 8
  %62 = getelementptr inbounds i8, ptr %6, i64 8
  %63 = getelementptr inbounds i8, ptr %6, i64 16
  %64 = getelementptr inbounds i8, ptr %6, i64 24
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %2
  %65 = load ptr, ptr %61, align 8
  %66 = call ptr @behavior_wrapper(ptr %65, { ptr, ptr, ptr, i32 } %56, ptr noundef nonnull align 8 %3)
  %67 = call { ptr, i160 } %66({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull %3) #39
  %.fca.0.extract63 = extractvalue { ptr, i160 } %67, 0
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract26)
  %69 = load ptr, ptr %14, align 8
  %70 = call ptr @typegetter_wrapper(ptr %69, ptr %.fca.1.extract27)
  %71 = icmp ne ptr %.fca.0.extract63, @nil_typ
  %72 = icmp ne ptr %.fca.0.extract63, null
  %.not71 = and i1 %71, %72
  br i1 %.not71, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %.fca.0.extract26)
  %74 = load ptr, ptr %14, align 8
  %75 = call ptr @typegetter_wrapper(ptr %74, ptr %.fca.1.extract27)
  store ptr %75, ptr %4, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @Array)
  store ptr %.fca.0.extract63, ptr %5, align 8
  %78 = call ptr @behavior_wrapper(ptr noundef nonnull @Array_B_append_xT, { ptr, ptr, ptr, i32 } %25, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %79 = call { ptr, ptr, ptr, i32 } %78({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %4, { ptr, i160 } %67) #39
  %.fca.0.extract36 = extractvalue { ptr, ptr, ptr, i32 } %79, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %79, 1
  %.fca.2.extract38 = extractvalue { ptr, ptr, ptr, i32 } %79, 2
  %.fca.3.extract39 = extractvalue { ptr, ptr, ptr, i32 } %79, 3
  store ptr %.fca.0.extract36, ptr %6, align 8
  store ptr %.fca.1.extract37, ptr %62, align 8
  store ptr %.fca.2.extract38, ptr %63, align 8
  store i32 %.fca.3.extract39, ptr %64, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1
  store ptr @Array, ptr %7, align 8
  %80 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %21, ptr %80, align 8
  %81 = getelementptr inbounds i8, ptr %7, i64 16
  %82 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 10, ptr %82, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %83 = load ptr, ptr %7, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %85 = load ptr, ptr %80, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 1
  %87 = load ptr, ptr %81, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %87, 2
  %89 = load i32, ptr %82, align 8
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %89, 3
  ret { ptr, ptr, ptr, i32 } %90
}

define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = call ptr @typegetter_wrapper(ptr %14, ptr %8)
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %19 = call { i64, i64 } @size_wrapper(ptr %18, ptr noundef nonnull align 8 dereferenceable(8) %15)
  %20 = extractvalue { i64, i64 } %19, 0
  %21 = call ptr @bump_malloc(i64 %20)
  %22 = load ptr, ptr %5, align 8
  %23 = load ptr, ptr %4, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %23)
  %25 = load i32, ptr %7, align 8
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr } undef, ptr %21, 0
  call void %31(ptr %22, { ptr } %32) #30
  %33 = load ptr, ptr %5, align 8
  %34 = load ptr, ptr %4, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %34)
  %36 = load i32, ptr %7, align 8
  %37 = sext i32 %36 to i64
  %38 = getelementptr ptr, ptr %34, i64 %37
  %39 = getelementptr i8, ptr %38, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  call void %42(ptr %33, i32 0) #30
  %43 = load ptr, ptr %5, align 8
  %44 = load ptr, ptr %4, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %44)
  %46 = load i32, ptr %7, align 8
  %47 = sext i32 %46 to i64
  %48 = getelementptr ptr, ptr %44, i64 %47
  %49 = getelementptr i8, ptr %48, i64 24
  %50 = load ptr, ptr %49, align 8
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  call void %52(ptr %43, i32 1) #30
  ret void
}

define void @Array_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %9, i32 %3) #30
  %19 = load ptr, ptr %6, align 8
  %20 = load ptr, ptr %5, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %20)
  %22 = load i32, ptr %8, align 8
  %23 = sext i32 %22 to i64
  %24 = getelementptr ptr, ptr %20, i64 %23
  %25 = getelementptr i8, ptr %24, i64 24
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %19) #31
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %20)
  %30 = load ptr, ptr %24, align 8
  %31 = call ptr @typegetter_wrapper(ptr %30, ptr %19)
  %32 = sext i32 %28 to i64
  %33 = load ptr, ptr %31, align 8
  %34 = getelementptr i8, ptr %33, i64 72
  %35 = load ptr, ptr %34, align 8
  %36 = call { i64, i64 } @size_wrapper(ptr %35, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %37 = extractvalue { i64, i64 } %36, 0
  %38 = mul i64 %37, %32
  %39 = call ptr @bump_malloc(i64 %38)
  %40 = load ptr, ptr %6, align 8
  %41 = load ptr, ptr %5, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %8, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr i8, ptr %47, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = insertvalue { ptr } undef, ptr %39, 0
  call void %49(ptr %40, { ptr } %50) #30
  %51 = load ptr, ptr %6, align 8
  %52 = load ptr, ptr %5, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %52)
  %54 = load i32, ptr %8, align 8
  %55 = sext i32 %54 to i64
  %56 = getelementptr ptr, ptr %52, i64 %55
  %57 = getelementptr i8, ptr %56, i64 16
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  call void %60(ptr %51, i32 0) #30
  ret void
}

define void @Array_init_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = getelementptr i8, ptr %15, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %10, i32 %3) #30
  %20 = load ptr, ptr %7, align 8
  %21 = load ptr, ptr %6, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %21)
  %23 = load i32, ptr %9, align 8
  %24 = sext i32 %23 to i64
  %25 = getelementptr ptr, ptr %21, i64 %24
  %26 = getelementptr i8, ptr %25, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %20, i32 %4) #30
  %30 = load ptr, ptr %7, align 8
  %31 = load ptr, ptr %6, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %31)
  %33 = load i32, ptr %9, align 8
  %34 = sext i32 %33 to i64
  %35 = getelementptr ptr, ptr %31, i64 %34
  %36 = getelementptr i8, ptr %35, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call i32 %38(ptr %30) #31
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %31)
  %41 = load ptr, ptr %35, align 8
  %42 = call ptr @typegetter_wrapper(ptr %41, ptr %30)
  %43 = sext i32 %39 to i64
  %44 = load ptr, ptr %42, align 8
  %45 = getelementptr i8, ptr %44, i64 72
  %46 = load ptr, ptr %45, align 8
  %47 = call { i64, i64 } @size_wrapper(ptr %46, ptr noundef nonnull align 8 dereferenceable(8) %42)
  %48 = extractvalue { i64, i64 } %47, 0
  %49 = mul i64 %48, %43
  %50 = call ptr @bump_malloc(i64 %49)
  %51 = load ptr, ptr %7, align 8
  %52 = load ptr, ptr %6, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %52)
  %54 = load i32, ptr %9, align 8
  %55 = sext i32 %54 to i64
  %56 = getelementptr ptr, ptr %52, i64 %55
  %57 = getelementptr i8, ptr %56, i64 8
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = insertvalue { ptr } undef, ptr %50, 0
  call void %60(ptr %51, { ptr } %61) #30
  ret void
}

define void @Array_init_bufferBufferT_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #3 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %11 = load ptr, ptr %8, align 8
  %12 = load ptr, ptr %7, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %12)
  %14 = load i32, ptr %10, align 8
  %15 = sext i32 %14 to i64
  %16 = getelementptr ptr, ptr %12, i64 %15
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %11, { ptr } %3) #30
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %10, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %21, i32 %4) #30
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %7, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %32)
  %34 = load i32, ptr %10, align 8
  %35 = sext i32 %34 to i64
  %36 = getelementptr ptr, ptr %32, i64 %35
  %37 = getelementptr i8, ptr %36, i64 24
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  call void %40(ptr %31, i32 %5) #30
  ret void
}

define i32 @Array_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  ret i32 %17
}

define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  ret i32 %17
}

define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract4, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract5, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %8, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %15 = load i32, ptr %11, align 8
  %16 = sext i32 %15 to i64
  %17 = getelementptr ptr, ptr %13, i64 %16
  %18 = getelementptr i8, ptr %17, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %12) #31
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %23 = getelementptr i8, ptr %17, i64 24
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call i32 %25(ptr %12) #31
  %.not = icmp slt i32 %21, %26
  br i1 %.not, label %._crit_edge, label %27

27:                                               ; preds = %4
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %29 = call i32 %25(ptr %12) #31
  %30 = shl i32 %29, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %12, 1
  %33 = load ptr, ptr %10, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %15, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %13)
  %38 = getelementptr i8, ptr %17, i64 104
  %39 = load ptr, ptr %38, align 8
  store ptr @i32_typ, ptr %6, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %35, ptr noundef nonnull align 8 dereferenceable(8) %6)
  call void %40({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull %5, i32 %30) #39
  br label %._crit_edge

._crit_edge:                                      ; preds = %27, %4
  %41 = load ptr, ptr %9, align 8
  %42 = load ptr, ptr %8, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %42)
  %44 = load i32, ptr %11, align 8
  %45 = sext i32 %44 to i64
  %46 = getelementptr ptr, ptr %42, i64 %45
  %47 = getelementptr i8, ptr %46, i64 16
  %48 = load ptr, ptr %47, align 8
  %49 = load ptr, ptr %48, align 8
  %50 = call i32 %49(ptr %41) #31
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %42)
  %52 = getelementptr i8, ptr %46, i64 8
  %53 = load ptr, ptr %52, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr } %54(ptr %41) #31
  %.fca.0.extract14 = extractvalue { ptr } %55, 0
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %42)
  %57 = load ptr, ptr %46, align 8
  %58 = call ptr @typegetter_wrapper(ptr %57, ptr %41)
  %59 = sext i32 %50 to i64
  %60 = load ptr, ptr %58, align 8
  %61 = getelementptr i8, ptr %60, i64 72
  %62 = load ptr, ptr %61, align 8
  %63 = call { i64, i64 } @size_wrapper(ptr %62, ptr noundef nonnull align 8 dereferenceable(8) %58)
  %64 = extractvalue { i64, i64 } %63, 0
  %65 = mul i64 %64, %59
  %66 = getelementptr i8, ptr %.fca.0.extract14, i64 %65
  %67 = load ptr, ptr %58, align 8
  %68 = getelementptr i8, ptr %67, i64 64
  %69 = load ptr, ptr %68, align 8
  call void @unbox_wrapper(ptr %69, { ptr, i160 } %3, ptr noundef nonnull align 8 dereferenceable(8) %58, ptr %66)
  %70 = load ptr, ptr %9, align 8
  %71 = load ptr, ptr %8, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %71)
  %73 = load i32, ptr %11, align 8
  %74 = sext i32 %73 to i64
  %75 = getelementptr ptr, ptr %71, i64 %74
  %76 = getelementptr i8, ptr %75, i64 16
  %77 = load ptr, ptr %76, align 8
  %78 = load ptr, ptr %77, align 8
  %79 = call i32 %78(ptr %70) #31
  %80 = add i32 %79, 1
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %71)
  %82 = getelementptr i8, ptr %77, i64 8
  %83 = load ptr, ptr %82, align 8
  call void %83(ptr %70, i32 %80) #30
  %84 = load ptr, ptr %8, align 8
  store ptr %84, ptr %7, align 8
  %85 = getelementptr inbounds i8, ptr %7, i64 8
  %86 = load ptr, ptr %9, align 8
  store ptr %86, ptr %85, align 8
  %87 = getelementptr inbounds i8, ptr %7, i64 16
  %88 = load ptr, ptr %10, align 8
  store ptr %88, ptr %87, align 8
  %89 = getelementptr inbounds i8, ptr %7, i64 24
  %90 = load i32, ptr %11, align 8
  store i32 %90, ptr %89, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %91 = load ptr, ptr %7, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %85, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %87, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %89, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  ret { ptr, ptr, ptr, i32 } %98
}

define { ptr, ptr, ptr, i32 } @Array_extend_otherArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %.fca.1.extract12, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr %.fca.2.extract13, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %11, i64 24
  store i32 %.fca.3.extract14, ptr %14, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %11, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr %.fca.1.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr %.fca.2.extract, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %15, i64 24
  store i32 %.fca.3.extract, ptr %18, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %15, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %19 = load ptr, ptr %15, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %19, 0
  %21 = load ptr, ptr %16, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 1
  %23 = load ptr, ptr %17, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %23, 2
  %25 = load i32, ptr %18, align 8
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %25, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %19)
  %29 = sext i32 %25 to i64
  %30 = getelementptr ptr, ptr %19, i64 %29
  %31 = getelementptr i8, ptr %30, i64 72
  %32 = load ptr, ptr %31, align 8
  %33 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %26, ptr noundef nonnull align 8 %5)
  %34 = call i32 %33({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull %5) #39
  %35 = load ptr, ptr %12, align 8
  %36 = load ptr, ptr %11, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %36)
  %38 = load i32, ptr %14, align 8
  %39 = sext i32 %38 to i64
  %40 = getelementptr ptr, ptr %36, i64 %39
  %41 = getelementptr i8, ptr %40, i64 16
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call i32 %43(ptr %35) #31
  %45 = add i32 %44, %34
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %35, 1
  %48 = load ptr, ptr %13, align 8
  %49 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %48, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %38, 3
  %51 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %51)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %36)
  %54 = getelementptr i8, ptr %40, i64 104
  %55 = load ptr, ptr %54, align 8
  %56 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %56, align 8
  %57 = call ptr @behavior_wrapper(ptr %55, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(8) %56)
  call void %57({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %51, i32 %45) #39
  %58 = getelementptr inbounds i8, ptr %8, i64 8
  %59 = getelementptr inbounds i8, ptr %9, i64 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %.0 = phi i32 [ 0, %4 ], [ %.1, %._crit_edge ]
  %60 = icmp slt i32 %.0, %34
  br i1 %60, label %61, label %._crit_edge

61:                                               ; preds = %._crit_edge1
  %62 = add i32 %.0, %44
  %63 = load ptr, ptr %15, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %63, 0
  %65 = load ptr, ptr %16, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %65, 1
  %67 = load ptr, ptr %17, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 2
  %69 = load i32, ptr %18, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 %69, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %63)
  %73 = sext i32 %69 to i64
  %74 = getelementptr ptr, ptr %63, i64 %73
  %75 = getelementptr i8, ptr %74, i64 128
  %76 = load ptr, ptr %75, align 8
  store ptr @i32_typ, ptr %7, align 8
  %77 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %70, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %78 = call { ptr, i160 } %77({ ptr, ptr, ptr, i32 } %70, { ptr, ptr, ptr, i32 } %70, ptr nonnull %6, i32 %.0) #39
  %.fca.0.extract24 = extractvalue { ptr, i160 } %78, 0
  %79 = load ptr, ptr %11, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %79, 0
  %81 = load ptr, ptr %12, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %81, 1
  %83 = load ptr, ptr %13, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %83, 2
  %85 = load i32, ptr %14, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 %85, 3
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %79)
  %88 = sext i32 %85 to i64
  %89 = getelementptr ptr, ptr %79, i64 %88
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr @typegetter_wrapper(ptr %90, ptr %81)
  store ptr @_parameterization_i32, ptr %8, align 8
  store ptr %91, ptr %58, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %79)
  %94 = getelementptr i8, ptr %89, i64 136
  %95 = load ptr, ptr %94, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr %.fca.0.extract24, ptr %59, align 8
  %96 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(16) %9)
  call void %96({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %8, i32 %62, { ptr, i160 } %78) #39
  %97 = add nsw i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %61, %._crit_edge1
  %.1 = phi i32 [ %97, %61 ], [ %.0, %._crit_edge1 ]
  br i1 %60, label %._crit_edge1, label %98

98:                                               ; preds = %._crit_edge
  %99 = load ptr, ptr %12, align 8
  %100 = load ptr, ptr %11, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %100)
  %102 = load i32, ptr %14, align 8
  %103 = sext i32 %102 to i64
  %104 = getelementptr ptr, ptr %100, i64 %103
  %105 = getelementptr i8, ptr %104, i64 16
  %106 = load ptr, ptr %105, align 8
  %107 = getelementptr i8, ptr %106, i64 8
  %108 = load ptr, ptr %107, align 8
  call void %108(ptr %99, i32 %45) #30
  %109 = load ptr, ptr %11, align 8
  store ptr %109, ptr %10, align 8
  %110 = getelementptr inbounds i8, ptr %10, i64 8
  %111 = load ptr, ptr %12, align 8
  store ptr %111, ptr %110, align 8
  %112 = getelementptr inbounds i8, ptr %10, i64 16
  %113 = load ptr, ptr %13, align 8
  store ptr %113, ptr %112, align 8
  %114 = getelementptr inbounds i8, ptr %10, i64 24
  %115 = load i32, ptr %14, align 8
  store i32 %115, ptr %114, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %116 = load ptr, ptr %10, align 8
  %117 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %116, 0
  %118 = load ptr, ptr %110, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr %118, 1
  %120 = load ptr, ptr %112, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr %120, 2
  %122 = load i32, ptr %114, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } %121, i32 %122, 3
  ret { ptr, ptr, ptr, i32 } %123
}

define void @Array_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %9) #31
  %.not = icmp sgt i32 %3, %18
  br i1 %.not, label %19, label %.loopexit

19:                                               ; preds = %4
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %21 = getelementptr i8, ptr %16, i64 8
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %9, i32 %3) #30
  %23 = load ptr, ptr %6, align 8
  %24 = load ptr, ptr %5, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %24)
  %26 = load i32, ptr %8, align 8
  %27 = sext i32 %26 to i64
  %28 = getelementptr ptr, ptr %24, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = call { ptr } %31(ptr %23) #31
  %.fca.0.extract25 = extractvalue { ptr } %32, 0
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %24)
  %34 = getelementptr i8, ptr %28, i64 24
  %35 = load ptr, ptr %34, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call i32 %36(ptr %23) #31
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %24)
  %39 = load ptr, ptr %28, align 8
  %40 = call ptr @typegetter_wrapper(ptr %39, ptr %23)
  %41 = sext i32 %37 to i64
  %42 = load ptr, ptr %40, align 8
  %43 = getelementptr i8, ptr %42, i64 72
  %44 = load ptr, ptr %43, align 8
  %45 = call { i64, i64 } @size_wrapper(ptr %44, ptr noundef nonnull align 8 dereferenceable(8) %40)
  %46 = extractvalue { i64, i64 } %45, 0
  %47 = mul i64 %46, %41
  %48 = call ptr @bump_malloc(i64 %47)
  %49 = load ptr, ptr %6, align 8
  %50 = load ptr, ptr %5, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %50)
  %52 = load i32, ptr %8, align 8
  %53 = sext i32 %52 to i64
  %54 = getelementptr ptr, ptr %50, i64 %53
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  %57 = getelementptr i8, ptr %56, i64 8
  %58 = load ptr, ptr %57, align 8
  %59 = insertvalue { ptr } undef, ptr %48, 0
  call void %58(ptr %49, { ptr } %59) #30
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %19
  %.0 = phi i32 [ 0, %19 ], [ %.1, %._crit_edge ]
  %60 = load ptr, ptr %6, align 8
  %61 = load ptr, ptr %5, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %61)
  %63 = load i32, ptr %8, align 8
  %64 = sext i32 %63 to i64
  %65 = getelementptr ptr, ptr %61, i64 %64
  %66 = getelementptr i8, ptr %65, i64 16
  %67 = load ptr, ptr %66, align 8
  %68 = load ptr, ptr %67, align 8
  %69 = call i32 %68(ptr %60) #31
  %70 = icmp slt i32 %.0, %69
  br i1 %70, label %71, label %._crit_edge

71:                                               ; preds = %._crit_edge1
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %61)
  %73 = load ptr, ptr %65, align 8
  %74 = call ptr @typegetter_wrapper(ptr %73, ptr %60)
  %75 = sext i32 %.0 to i64
  %76 = load ptr, ptr %74, align 8
  %77 = getelementptr i8, ptr %76, i64 72
  %78 = load ptr, ptr %77, align 8
  %79 = call { i64, i64 } @size_wrapper(ptr %78, ptr noundef nonnull align 8 dereferenceable(8) %74)
  %80 = extractvalue { i64, i64 } %79, 0
  %81 = mul i64 %80, %75
  %82 = getelementptr i8, ptr %.fca.0.extract25, i64 %81
  %83 = load ptr, ptr %74, align 8
  %84 = getelementptr i8, ptr %83, i64 56
  %85 = load ptr, ptr %84, align 8
  %86 = call { ptr, i160 } @box_wrapper(ptr %85, ptr %82, ptr noundef nonnull align 8 dereferenceable(8) %74)
  %87 = load ptr, ptr %6, align 8
  %88 = load ptr, ptr %5, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %88)
  %90 = load i32, ptr %8, align 8
  %91 = sext i32 %90 to i64
  %92 = getelementptr ptr, ptr %88, i64 %91
  %93 = getelementptr i8, ptr %92, i64 8
  %94 = load ptr, ptr %93, align 8
  %95 = load ptr, ptr %94, align 8
  %96 = call { ptr } %95(ptr %87) #31
  %.fca.0.extract8 = extractvalue { ptr } %96, 0
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %88)
  %98 = load ptr, ptr %92, align 8
  %99 = call ptr @typegetter_wrapper(ptr %98, ptr %87)
  %100 = load ptr, ptr %99, align 8
  %101 = getelementptr i8, ptr %100, i64 72
  %102 = load ptr, ptr %101, align 8
  %103 = call { i64, i64 } @size_wrapper(ptr %102, ptr noundef nonnull align 8 dereferenceable(8) %99)
  %104 = extractvalue { i64, i64 } %103, 0
  %105 = mul i64 %104, %75
  %106 = getelementptr i8, ptr %.fca.0.extract8, i64 %105
  %107 = load ptr, ptr %99, align 8
  %108 = getelementptr i8, ptr %107, i64 64
  %109 = load ptr, ptr %108, align 8
  call void @unbox_wrapper(ptr %109, { ptr, i160 } %86, ptr noundef nonnull align 8 dereferenceable(8) %99, ptr %106)
  %110 = add nsw i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %71, %._crit_edge1
  %.1 = phi i32 [ %110, %71 ], [ %.0, %._crit_edge1 ]
  br i1 %70, label %._crit_edge1, label %.loopexit

.loopexit:                                        ; preds = %._crit_edge, %4
  ret void
}

define { ptr, i160 } @Array__index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca [3 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr }, align 8
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  %12 = alloca [2 x ptr], align 8
  %13 = alloca { ptr, ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %16 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %16, i64 8
  store ptr %.fca.1.extract, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %16, i64 16
  store ptr %.fca.2.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %16, i64 24
  store i32 %.fca.3.extract, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %16, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %20 = load ptr, ptr %17, align 8
  %21 = load ptr, ptr %16, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %21)
  %23 = load i32, ptr %19, align 8
  %24 = sext i32 %23 to i64
  %25 = getelementptr ptr, ptr %21, i64 %24
  %26 = getelementptr i8, ptr %25, i64 16
  %27 = load ptr, ptr %26, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = call i32 %28(ptr %20) #31
  %30 = add i32 %29, -1
  %31 = icmp sgt i32 %3, %30
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %21)
  %33 = call i32 %28(ptr %20) #31
  %34 = add i32 %33, %3
  %35 = icmp slt i32 %34, 0
  %.0 = select i1 %31, i1 true, i1 %35
  br i1 %.0, label %36, label %._crit_edge

36:                                               ; preds = %4
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %21)
  %38 = call i32 %28(ptr %20) #31
  store ptr @OutOfBounds, ptr %5, align 8
  %39 = load ptr, ptr getelementptr inbounds (i8, ptr @OutOfBounds, i64 48), align 8
  %40 = call { i64, i64 } @size_wrapper(ptr %39, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %41 = extractvalue { i64, i64 } %40, 0
  %42 = call ptr @bump_malloc(i64 %41)
  %43 = load ptr, ptr %17, align 8
  %44 = load ptr, ptr %16, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %44)
  %46 = load i32, ptr %19, align 8
  %47 = sext i32 %46 to i64
  %48 = getelementptr ptr, ptr %44, i64 %47
  %49 = getelementptr i8, ptr %48, i64 16
  %50 = load ptr, ptr %49, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = call i32 %51(ptr %43) #31
  %53 = insertvalue { ptr, ptr, ptr, i32 } { ptr @OutOfBounds, ptr undef, ptr undef, i32 undef }, ptr %42, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr undef, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 10, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %56 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @_parameterization_i32, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef nonnull align 8 dereferenceable(352) @OutOfBounds)
  %59 = load ptr, ptr getelementptr inbounds (i8, ptr @OutOfBounds, i64 128), align 8
  store ptr @i32_typ, ptr %7, align 8
  %60 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @i32_typ, ptr %60, align 8
  %61 = call ptr @behavior_wrapper(ptr %59, { ptr, ptr, ptr, i32 } %55, ptr noundef nonnull align 8 dereferenceable(16) %7)
  call void %61({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull %6, i32 %52, i32 %3) #39
  %62 = call ptr @bump_malloc(i64 noundef 57)
  %63 = load <56 x i8>, ptr @uagtt_CUsersPaulKOneDriveDocumentsPLPyPLlibarraymini, align 64
  store <56 x i8> %63, ptr %62, align 1
  store ptr @String, ptr %8, align 8
  %64 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %65 = call { i64, i64 } @size_wrapper(ptr %64, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %66 = extractvalue { i64, i64 } %65, 0
  %67 = call ptr @bump_malloc(i64 %66)
  %68 = insertvalue { ptr } undef, ptr %62, 0
  %69 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %67, 1
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr undef, 2
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %9, align 8
  %72 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @_parameterization_i32, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @_parameterization_i32, ptr %73, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %9)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %76 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %10, align 8
  %77 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr @i32_typ, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @i32_typ, ptr %78, align 8
  %79 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %71, ptr noundef nonnull align 8 dereferenceable(24) %10)
  call void %79({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull %9, { ptr } %68, i32 56, i32 57) #39
  store ptr @String, ptr %11, align 8
  %80 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %67, ptr %80, align 8
  %81 = getelementptr inbounds i8, ptr %11, i64 16
  %82 = getelementptr inbounds i8, ptr %11, i64 24
  store i32 10, ptr %82, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %11, ptr noundef nonnull align 8 dereferenceable(1248) @String)
  %83 = load ptr, ptr %11, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %85 = load ptr, ptr %80, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 1
  %87 = load ptr, ptr %81, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %87, 2
  %89 = load i32, ptr %82, align 8
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %89, 3
  store ptr @_parameterization_i32, ptr %12, align 8
  %91 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr @_parameterization_String, ptr %91, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %12)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef nonnull align 8 dereferenceable(352) @OutOfBounds)
  %94 = load ptr, ptr getelementptr inbounds (i8, ptr @OutOfBounds, i64 152), align 8
  store ptr @i32_typ, ptr %13, align 8
  %95 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %83, ptr %95, align 8
  %96 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %55, ptr noundef nonnull align 8 dereferenceable(16) %13)
  call void %96({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull %12, i32 86, { ptr, ptr, ptr, i32 } %90) #39
  %97 = ptrtoint ptr %42 to i64
  %.sroa.454.8.insert.ext = zext i64 %97 to i160
  %.sroa.454.8.insert.insert = or disjoint i160 %.sroa.454.8.insert.ext, 3402823669209384634633746074317682114560
  %98 = call ptr @get_current_coroutine()
  %99 = getelementptr i8, ptr %98, i64 48
  store ptr @OutOfBounds, ptr %99, align 8
  %100 = getelementptr i8, ptr %98, i64 56
  store i160 %.sroa.454.8.insert.insert, ptr %100, align 4
  call void @coroutine_yield_cold(ptr noundef align 8 %98)
  br label %._crit_edge

._crit_edge:                                      ; preds = %36, %4
  %101 = icmp slt i32 %3, 0
  br i1 %101, label %102, label %._crit_edge1

102:                                              ; preds = %._crit_edge
  %103 = load ptr, ptr %17, align 8
  %104 = load ptr, ptr %16, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %104)
  %106 = load i32, ptr %19, align 8
  %107 = sext i32 %106 to i64
  %108 = getelementptr ptr, ptr %104, i64 %107
  %109 = getelementptr i8, ptr %108, i64 16
  %110 = load ptr, ptr %109, align 8
  %111 = load ptr, ptr %110, align 8
  %112 = call i32 %111(ptr %103) #31
  %113 = add i32 %112, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %102, %._crit_edge
  %.060 = phi i32 [ %113, %102 ], [ %3, %._crit_edge ]
  %114 = load ptr, ptr %16, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %114, 0
  %116 = load ptr, ptr %17, align 8
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %116, 1
  %118 = load ptr, ptr %18, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr %118, 2
  %120 = load i32, ptr %19, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 %120, 3
  store ptr @_parameterization_i32, ptr %14, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %14)
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %114)
  %124 = sext i32 %120 to i64
  %125 = getelementptr ptr, ptr %114, i64 %124
  %126 = getelementptr i8, ptr %125, i64 128
  %127 = load ptr, ptr %126, align 8
  store ptr @i32_typ, ptr %15, align 8
  %128 = call ptr @behavior_wrapper(ptr %127, { ptr, ptr, ptr, i32 } %121, ptr noundef nonnull align 8 dereferenceable(8) %15)
  %129 = call { ptr, i160 } %128({ ptr, ptr, ptr, i32 } %121, { ptr, ptr, ptr, i32 } %121, ptr nonnull %14, i32 %.060) #39
  ret { ptr, i160 } %129
}

define void @Array__set_index_xi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #3 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [2 x ptr], align 8
  %8 = alloca { ptr, ptr }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca [3 x ptr], align 8
  %11 = alloca { ptr, ptr, ptr }, align 8
  %12 = alloca { ptr, ptr, ptr, i32 }, align 8
  %13 = alloca [2 x ptr], align 8
  %14 = alloca { ptr, ptr }, align 8
  %15 = alloca [2 x ptr], align 8
  %16 = alloca { ptr, ptr }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %17 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract16, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %.fca.1.extract17, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %17, i64 16
  store ptr %.fca.2.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %17, i64 24
  store i32 %.fca.3.extract, ptr %20, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %17, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %21 = load ptr, ptr %18, align 8
  %22 = load ptr, ptr %17, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %20, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call i32 %29(ptr %21) #31
  %31 = add i32 %30, -1
  %32 = icmp sgt i32 %3, %31
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %22)
  %34 = call i32 %29(ptr %21) #31
  %35 = add i32 %34, %3
  %36 = icmp slt i32 %35, 0
  %.0 = select i1 %32, i1 true, i1 %36
  br i1 %.0, label %37, label %._crit_edge

37:                                               ; preds = %5
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %22)
  %39 = call i32 %29(ptr %21) #31
  store ptr @OutOfBounds, ptr %6, align 8
  %40 = load ptr, ptr getelementptr inbounds (i8, ptr @OutOfBounds, i64 48), align 8
  %41 = call { i64, i64 } @size_wrapper(ptr %40, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %42 = extractvalue { i64, i64 } %41, 0
  %43 = call ptr @bump_malloc(i64 %42)
  %44 = load ptr, ptr %18, align 8
  %45 = load ptr, ptr %17, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %45)
  %47 = load i32, ptr %20, align 8
  %48 = sext i32 %47 to i64
  %49 = getelementptr ptr, ptr %45, i64 %48
  %50 = getelementptr i8, ptr %49, i64 16
  %51 = load ptr, ptr %50, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr %44) #31
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @OutOfBounds, ptr undef, ptr undef, i32 undef }, ptr %43, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 10, 3
  store ptr @_parameterization_i32, ptr %7, align 8
  %57 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %7)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef nonnull align 8 dereferenceable(352) @OutOfBounds)
  %60 = load ptr, ptr getelementptr inbounds (i8, ptr @OutOfBounds, i64 128), align 8
  store ptr @i32_typ, ptr %8, align 8
  %61 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %61, align 8
  %62 = call ptr @behavior_wrapper(ptr %60, { ptr, ptr, ptr, i32 } %56, ptr noundef nonnull align 8 dereferenceable(16) %8)
  call void %62({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull %7, i32 %53, i32 %3) #39
  %63 = call ptr @bump_malloc(i64 noundef 57)
  %64 = load <56 x i8>, ptr @uagtt_CUsersPaulKOneDriveDocumentsPLPyPLlibarraymini, align 64
  store <56 x i8> %64, ptr %63, align 1
  store ptr @String, ptr %9, align 8
  %65 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %66 = call { i64, i64 } @size_wrapper(ptr %65, ptr noundef nonnull align 8 dereferenceable(8) %9)
  %67 = extractvalue { i64, i64 } %66, 0
  %68 = call ptr @bump_malloc(i64 %67)
  %69 = insertvalue { ptr } undef, ptr %63, 0
  %70 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %68, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr undef, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %10, align 8
  %73 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr @_parameterization_i32, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @_parameterization_i32, ptr %74, align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %10)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %77 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %11, align 8
  %78 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @i32_typ, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr @i32_typ, ptr %79, align 8
  %80 = call ptr @behavior_wrapper(ptr %77, { ptr, ptr, ptr, i32 } %72, ptr noundef nonnull align 8 dereferenceable(24) %11)
  call void %80({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull %10, { ptr } %69, i32 56, i32 57) #39
  store ptr @String, ptr %12, align 8
  %81 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %68, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %12, i64 16
  %83 = getelementptr inbounds i8, ptr %12, i64 24
  store i32 10, ptr %83, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %12, ptr noundef nonnull align 8 dereferenceable(1248) @String)
  %84 = load ptr, ptr %12, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %84, 0
  %86 = load ptr, ptr %81, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %85, ptr %86, 1
  %88 = load ptr, ptr %82, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %88, 2
  %90 = load i32, ptr %83, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } %89, i32 %90, 3
  store ptr @_parameterization_i32, ptr %13, align 8
  %92 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr @_parameterization_String, ptr %92, align 8
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %13)
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef nonnull align 8 dereferenceable(352) @OutOfBounds)
  %95 = load ptr, ptr getelementptr inbounds (i8, ptr @OutOfBounds, i64 152), align 8
  store ptr @i32_typ, ptr %14, align 8
  %96 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr %84, ptr %96, align 8
  %97 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %56, ptr noundef nonnull align 8 dereferenceable(16) %14)
  call void %97({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull %13, i32 94, { ptr, ptr, ptr, i32 } %91) #39
  %98 = ptrtoint ptr %43 to i64
  %.sroa.454.8.insert.ext = zext i64 %98 to i160
  %.sroa.454.8.insert.insert = or disjoint i160 %.sroa.454.8.insert.ext, 3402823669209384634633746074317682114560
  %99 = call ptr @get_current_coroutine()
  %100 = getelementptr i8, ptr %99, i64 48
  store ptr @OutOfBounds, ptr %100, align 8
  %101 = getelementptr i8, ptr %99, i64 56
  store i160 %.sroa.454.8.insert.insert, ptr %101, align 4
  call void @coroutine_yield_cold(ptr noundef align 8 %99)
  br label %._crit_edge

._crit_edge:                                      ; preds = %37, %5
  %102 = icmp slt i32 %3, 0
  br i1 %102, label %103, label %._crit_edge1

103:                                              ; preds = %._crit_edge
  %104 = load ptr, ptr %18, align 8
  %105 = load ptr, ptr %17, align 8
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %105)
  %107 = load i32, ptr %20, align 8
  %108 = sext i32 %107 to i64
  %109 = getelementptr ptr, ptr %105, i64 %108
  %110 = getelementptr i8, ptr %109, i64 16
  %111 = load ptr, ptr %110, align 8
  %112 = load ptr, ptr %111, align 8
  %113 = call i32 %112(ptr %104) #31
  %114 = add i32 %113, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %103, %._crit_edge
  %.060 = phi i32 [ %114, %103 ], [ %3, %._crit_edge ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %115 = load ptr, ptr %17, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %115, 0
  %117 = load ptr, ptr %18, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr %117, 1
  %119 = load ptr, ptr %19, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr %119, 2
  %121 = load i32, ptr %20, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, i32 %121, 3
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %115)
  %124 = sext i32 %121 to i64
  %125 = getelementptr ptr, ptr %115, i64 %124
  %126 = load ptr, ptr %125, align 8
  %127 = call ptr @typegetter_wrapper(ptr %126, ptr %117)
  store ptr @_parameterization_i32, ptr %15, align 8
  %128 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr %127, ptr %128, align 8
  %129 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %15)
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %115)
  %131 = getelementptr i8, ptr %125, i64 136
  %132 = load ptr, ptr %131, align 8
  store ptr @i32_typ, ptr %16, align 8
  %133 = getelementptr inbounds i8, ptr %16, i64 8
  store ptr %.fca.0.extract, ptr %133, align 8
  %134 = call ptr @behavior_wrapper(ptr %132, { ptr, ptr, ptr, i32 } %122, ptr noundef nonnull align 8 dereferenceable(16) %16)
  call void %134({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr nonnull %15, i32 %.060, { ptr, i160 } %4) #39
  ret void
}

define { ptr, i160 } @Array_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract6, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr } %17(ptr %9) #31
  %.fca.0.extract2 = extractvalue { ptr } %18, 0
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %10)
  %20 = load ptr, ptr %14, align 8
  %21 = call ptr @typegetter_wrapper(ptr %20, ptr %9)
  %22 = sext i32 %3 to i64
  %23 = load ptr, ptr %21, align 8
  %24 = getelementptr i8, ptr %23, i64 72
  %25 = load ptr, ptr %24, align 8
  %26 = call { i64, i64 } @size_wrapper(ptr %25, ptr noundef nonnull align 8 dereferenceable(8) %21)
  %27 = extractvalue { i64, i64 } %26, 0
  %28 = mul i64 %27, %22
  %29 = getelementptr i8, ptr %.fca.0.extract2, i64 %28
  %30 = load ptr, ptr %21, align 8
  %31 = getelementptr i8, ptr %30, i64 56
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr, i160 } @box_wrapper(ptr %32, ptr %29, ptr noundef nonnull align 8 dereferenceable(8) %21)
  ret { ptr, i160 } %33
}

define void @Array_unchecked_insert_xi32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract7, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract8, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr } %18(ptr %10) #31
  %.fca.0.extract = extractvalue { ptr } %19, 0
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %11)
  %21 = load ptr, ptr %15, align 8
  %22 = call ptr @typegetter_wrapper(ptr %21, ptr %10)
  %23 = sext i32 %3 to i64
  %24 = load ptr, ptr %22, align 8
  %25 = getelementptr i8, ptr %24, i64 72
  %26 = load ptr, ptr %25, align 8
  %27 = call { i64, i64 } @size_wrapper(ptr %26, ptr noundef nonnull align 8 dereferenceable(8) %22)
  %28 = extractvalue { i64, i64 } %27, 0
  %29 = mul i64 %28, %23
  %30 = getelementptr i8, ptr %.fca.0.extract, i64 %29
  %31 = load ptr, ptr %22, align 8
  %32 = getelementptr i8, ptr %31, i64 64
  %33 = load ptr, ptr %32, align 8
  call void @unbox_wrapper(ptr %33, { ptr, i160 } %4, ptr noundef nonnull align 8 dereferenceable(8) %22, ptr %30)
  ret void
}

define i32 @Array_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  ret i32 %17
}

define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = call ptr @typegetter_wrapper(ptr %14, ptr %8)
  %16 = alloca [2 x ptr], align 8
  store ptr @ArrayIterator, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %16, i64 8
  store ptr %15, ptr %17, align 8
  %18 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_ArrayIterator, ptr noundef nonnull align 8 dereferenceable(16) %16)
  %19 = extractvalue { i64, i64 } %18, 0
  %20 = call ptr @bump_malloc(i64 %19)
  store ptr %15, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %20)
  %22 = alloca { ptr, ptr, ptr, i32 }, align 8
  %23 = load ptr, ptr %4, align 8
  store ptr %23, ptr %22, align 8
  %24 = getelementptr inbounds i8, ptr %22, i64 8
  %25 = load ptr, ptr %5, align 8
  store ptr %25, ptr %24, align 8
  %26 = getelementptr inbounds i8, ptr %22, i64 16
  %27 = load ptr, ptr %6, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr inbounds i8, ptr %22, i64 24
  %29 = load i32, ptr %7, align 8
  store i32 %29, ptr %28, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %22, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %30 = load ptr, ptr %22, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %30, 0
  %32 = load ptr, ptr %24, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %32, 1
  %34 = load ptr, ptr %26, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 2
  %36 = load i32, ptr %28, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, i32 %36, 3
  %38 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %20, 1
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr undef, 2
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 10, 3
  %41 = load ptr, ptr %5, align 8
  %42 = load ptr, ptr %4, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %42)
  %44 = load i32, ptr %7, align 8
  %45 = sext i32 %44 to i64
  %46 = getelementptr ptr, ptr %42, i64 %45
  %47 = load ptr, ptr %46, align 8
  %48 = call ptr @typegetter_wrapper(ptr %47, ptr %41)
  %49 = call ptr @bump_malloc(i64 noundef 24)
  %50 = getelementptr i8, ptr %49, i64 8
  store ptr %48, ptr %50, align 8
  %51 = getelementptr i8, ptr %49, i64 16
  store ptr null, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %49)
  store ptr @Array, ptr %49, align 8
  %53 = alloca [1 x ptr], align 8
  store ptr %49, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %53)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @ArrayIterator)
  %56 = alloca { ptr }, align 8
  store ptr %30, ptr %56, align 8
  %57 = call ptr @behavior_wrapper(ptr noundef nonnull @ArrayIterator_B_init_arrayArrayT, { ptr, ptr, ptr, i32 } %40, ptr noundef nonnull align 8 dereferenceable(8) %56)
  call void %57({ ptr, ptr, ptr, i32 } %40, { ptr, ptr, ptr, i32 } %40, ptr nonnull %53, { ptr, ptr, ptr, i32 } %37) #39
  %58 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @ArrayIterator, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %58, i64 8
  store ptr %20, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %58, i64 16
  %61 = getelementptr inbounds i8, ptr %58, i64 24
  store i32 10, ptr %61, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %58, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %62 = load ptr, ptr %58, align 8
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %62, 0
  %64 = load ptr, ptr %59, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 1
  %66 = load ptr, ptr %60, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 2
  %68 = load i32, ptr %61, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %68, 3
  ret { ptr, ptr, ptr, i32 } %69
}

define { ptr, ptr, ptr, i32 } @Array_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %8 = call ptr @bump_malloc(i64 noundef 6)
  store <5 x i8> <i8 65, i8 114, i8 114, i8 97, i8 121>, ptr %8, align 1
  %9 = alloca [1 x ptr], align 8
  store ptr @String, ptr %9, align 8
  %10 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %11 = call { i64, i64 } @size_wrapper(ptr %10, ptr noundef nonnull align 8 dereferenceable(8) %9)
  %12 = extractvalue { i64, i64 } %11, 0
  %13 = call ptr @bump_malloc(i64 %12)
  %14 = insertvalue { ptr } undef, ptr %8, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %13, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 10, 3
  %18 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @_parameterization_i32, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %18)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %23 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  %24 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %24, i64 8
  store ptr @i32_typ, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %24, i64 16
  store ptr @i32_typ, ptr %26, align 8
  %27 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(24) %24)
  call void %27({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %18, { ptr } %14, i32 5, i32 6) #39
  %28 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @String, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %28, i64 8
  store ptr %13, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 16
  %31 = getelementptr inbounds i8, ptr %28, i64 24
  store i32 10, ptr %31, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %28, ptr noundef nonnull align 8 dereferenceable(1248) @String)
  %32 = load ptr, ptr %28, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = load ptr, ptr %29, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 1
  %36 = load ptr, ptr %30, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 2
  %38 = load i32, ptr %31, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %38, 3
  ret { ptr, ptr, ptr, i32 } %39
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ArrayIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 48, i64 8 }
}

define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef -5261542750394134544, i64 noundef ptrtoint (ptr @Array to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 120
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract2, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract3, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract4, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(160) @ArrayIterator)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = load ptr, ptr %9, align 8
  store ptr %14, ptr %13, align 8
  %15 = getelementptr inbounds i8, ptr %13, i64 8
  %16 = load ptr, ptr %10, align 8
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds i8, ptr %13, i64 16
  %18 = load ptr, ptr %11, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds i8, ptr %13, i64 24
  %20 = load i32, ptr %12, align 8
  store i32 %20, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %5, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %8, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %13, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = load ptr, ptr %15, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 1
  %35 = load ptr, ptr %17, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 2
  %37 = load i32, ptr %19, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %37, 3
  call void %30(ptr %21, { ptr, ptr, ptr, i32 } %38) #30
  %39 = load ptr, ptr %6, align 8
  %40 = load ptr, ptr %5, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %40)
  %42 = load i32, ptr %8, align 8
  %43 = sext i32 %42 to i64
  %44 = getelementptr ptr, ptr %40, i64 %43
  %45 = getelementptr i8, ptr %44, i64 16
  %46 = load ptr, ptr %45, align 8
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  call void %48(ptr %39, i32 0) #30
  ret void
}

define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract10, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract12, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract14, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract16, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(160) @ArrayIterator)
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %8, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %13)
  %15 = load i32, ptr %11, align 8
  %16 = sext i32 %15 to i64
  %17 = getelementptr ptr, ptr %13, i64 %16
  %18 = getelementptr i8, ptr %17, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = call i32 %20(ptr %12) #31
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %13)
  %23 = getelementptr i8, ptr %17, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr, ptr, ptr, i32 } %25(ptr %12) #31
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %26, 0
  store ptr %.fca.0.extract, ptr %27, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %26, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %27, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %26, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %27, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %26, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %27, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %27, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %28, 0
  %30 = load ptr, ptr %.fca.1.gep, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %30, 1
  %32 = load ptr, ptr %.fca.2.gep, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %32, 2
  %34 = load i32, ptr %.fca.3.gep, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %34, 3
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %28)
  %38 = sext i32 %34 to i64
  %39 = getelementptr ptr, ptr %28, i64 %38
  %40 = getelementptr i8, ptr %39, i64 72
  %41 = load ptr, ptr %40, align 8
  %42 = call ptr @behavior_wrapper(ptr %41, { ptr, ptr, ptr, i32 } %35, ptr noundef nonnull align 8 %4)
  %43 = call i32 %42({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull %4) #39
  %.not = icmp slt i32 %21, %43
  br i1 %.not, label %44, label %91

44:                                               ; preds = %3
  %45 = load ptr, ptr %9, align 8
  %46 = load ptr, ptr %8, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %46)
  %48 = load i32, ptr %11, align 8
  %49 = sext i32 %48 to i64
  %50 = getelementptr ptr, ptr %46, i64 %49
  %51 = getelementptr i8, ptr %50, i64 16
  %52 = load ptr, ptr %51, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call i32 %53(ptr %45) #31
  %55 = add i32 %54, 1
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %46)
  %57 = getelementptr i8, ptr %52, i64 8
  %58 = load ptr, ptr %57, align 8
  call void %58(ptr %45, i32 %55) #30
  %59 = load ptr, ptr %9, align 8
  %60 = load ptr, ptr %8, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %60)
  %62 = load i32, ptr %11, align 8
  %63 = sext i32 %62 to i64
  %64 = getelementptr ptr, ptr %60, i64 %63
  %65 = getelementptr i8, ptr %64, i64 16
  %66 = load ptr, ptr %65, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call i32 %67(ptr %59) #31
  %69 = add i32 %68, -1
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %60)
  %71 = getelementptr i8, ptr %64, i64 8
  %72 = load ptr, ptr %71, align 8
  %73 = load ptr, ptr %72, align 8
  %74 = call { ptr, ptr, ptr, i32 } %73(ptr %59) #31
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %74, 0
  store ptr %.fca.0.extract26, ptr %5, align 8
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %74, 1
  %.fca.1.gep29 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract28, ptr %.fca.1.gep29, align 8
  %.fca.2.extract30 = extractvalue { ptr, ptr, ptr, i32 } %74, 2
  %.fca.2.gep31 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract30, ptr %.fca.2.gep31, align 8
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %74, 3
  %.fca.3.gep33 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract32, ptr %.fca.3.gep33, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(1272) @Array)
  %75 = load ptr, ptr %5, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %75, 0
  %77 = load ptr, ptr %.fca.1.gep29, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %77, 1
  %79 = load ptr, ptr %.fca.2.gep31, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %79, 2
  %81 = load i32, ptr %.fca.3.gep33, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, i32 %81, 3
  store ptr @_parameterization_i32, ptr %6, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %75)
  %85 = sext i32 %81 to i64
  %86 = getelementptr ptr, ptr %75, i64 %85
  %87 = getelementptr i8, ptr %86, i64 128
  %88 = load ptr, ptr %87, align 8
  store ptr @i32_typ, ptr %7, align 8
  %89 = call ptr @behavior_wrapper(ptr %88, { ptr, ptr, ptr, i32 } %82, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %90 = call { ptr, i160 } %89({ ptr, ptr, ptr, i32 } %82, { ptr, ptr, ptr, i32 } %82, ptr nonnull %6, i32 %69) #39
  %.fca.0.extract20 = extractvalue { ptr, i160 } %90, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %90, 1
  br label %91

91:                                               ; preds = %44, %3
  %.reg2mem21.sroa.0.0 = phi ptr [ %.fca.0.extract20, %44 ], [ @nil_typ, %3 ]
  %.reg2mem21.sroa.3.0 = phi i160 [ %.fca.1.extract22, %44 ], [ undef, %3 ]
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem21.sroa.0.0, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %.reg2mem21.sroa.3.0, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBounds(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 120, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @OutOfBounds_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 192
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %13)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 208
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_print_stacktrace_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBounds_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @OutOfBounds_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract40, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(376) @OutOfBounds)
  %10 = alloca [1 x ptr], align 8
  store ptr @OutOfBoundsDetails, ptr %10, align 8
  %11 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_OutOfBoundsDetails, ptr noundef nonnull align 8 dereferenceable(8) %10)
  %12 = extractvalue { i64, i64 } %11, 0
  %13 = call ptr @bump_malloc(i64 %12)
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @OutOfBoundsDetails, ptr undef, ptr undef, i32 undef }, ptr %13, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 10, 3
  %17 = alloca [2 x ptr], align 8
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr @_parameterization_i32, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %17)
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails)
  %21 = alloca { ptr, ptr }, align 8
  store ptr @i32_typ, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr @i32_typ, ptr %22, align 8
  %23 = call ptr @behavior_wrapper(ptr noundef nonnull @OutOfBoundsDetails_B_init_boundsi32_indexi32, { ptr, ptr, ptr, i32 } %16, ptr noundef nonnull align 8 dereferenceable(16) %21)
  call void %23({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %17, i32 %3, i32 %4) #39
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %6, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %25)
  %27 = load i32, ptr %9, align 8
  %28 = sext i32 %27 to i64
  %29 = getelementptr ptr, ptr %25, i64 %28
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = ptrtoint ptr %13 to i64
  %.sroa.3.8.insert.ext = zext i64 %33 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %34 = insertvalue { ptr, i160 } { ptr @OutOfBoundsDetails, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  call void %32(ptr %24, { ptr, i160 } %34) #30
  %35 = load ptr, ptr %7, align 8
  %36 = load ptr, ptr %6, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %36)
  %38 = load i32, ptr %9, align 8
  %39 = sext i32 %38 to i64
  %40 = getelementptr ptr, ptr %36, i64 %39
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %35, i32 0) #30
  %45 = call ptr @bump_malloc(i64 noundef 1)
  %46 = alloca [1 x ptr], align 8
  store ptr @String, ptr %46, align 8
  %47 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %46)
  %48 = extractvalue { i64, i64 } %47, 0
  %49 = call ptr @bump_malloc(i64 %48)
  %50 = insertvalue { ptr } undef, ptr %45, 0
  %51 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %49, 1
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr undef, 2
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 10, 3
  %54 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %54, i64 8
  store ptr @_parameterization_i32, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %54, i64 16
  store ptr @_parameterization_i32, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %54)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %59 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %59, i64 8
  store ptr @i32_typ, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %59, i64 16
  store ptr @i32_typ, ptr %61, align 8
  %62 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %53, ptr noundef nonnull align 8 dereferenceable(24) %59)
  call void %62({ ptr, ptr, ptr, i32 } %53, { ptr, ptr, ptr, i32 } %53, ptr nonnull %54, { ptr } %50, i32 0, i32 1) #39
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @String, ptr %63, align 8
  %64 = getelementptr inbounds i8, ptr %63, i64 8
  store ptr %49, ptr %64, align 8
  %65 = getelementptr inbounds i8, ptr %63, i64 16
  %66 = getelementptr inbounds i8, ptr %63, i64 24
  store i32 10, ptr %66, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %63, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %67 = load ptr, ptr %7, align 8
  %68 = load ptr, ptr %6, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %68)
  %70 = load i32, ptr %9, align 8
  %71 = sext i32 %70 to i64
  %72 = getelementptr ptr, ptr %68, i64 %71
  %73 = getelementptr i8, ptr %72, i64 16
  %74 = load ptr, ptr %73, align 8
  %75 = getelementptr i8, ptr %74, i64 8
  %76 = load ptr, ptr %75, align 8
  %77 = load ptr, ptr %63, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %77, 0
  %79 = load ptr, ptr %64, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %79, 1
  %81 = load ptr, ptr %65, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %81, 2
  %83 = load i32, ptr %66, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, i32 %83, 3
  call void %76(ptr %67, { ptr, ptr, ptr, i32 } %84) #30
  %85 = call ptr @bump_malloc(i64 noundef 66)
  %86 = load <65 x i8>, ptr @wapia_An_outofbounds_error_occurred_while_indexing_into_a_collection, align 128
  store <65 x i8> %86, ptr %85, align 1
  %87 = alloca [1 x ptr], align 8
  store ptr @String, ptr %87, align 8
  %88 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %87)
  %89 = extractvalue { i64, i64 } %88, 0
  %90 = call ptr @bump_malloc(i64 %89)
  %91 = insertvalue { ptr } undef, ptr %85, 0
  %92 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %90, 1
  %93 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr undef, 2
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 10, 3
  %95 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %95, i64 8
  store ptr @_parameterization_i32, ptr %96, align 8
  %97 = getelementptr inbounds i8, ptr %95, i64 16
  store ptr @_parameterization_i32, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %95)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %100 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %100, align 8
  %101 = getelementptr inbounds i8, ptr %100, i64 8
  store ptr @i32_typ, ptr %101, align 8
  %102 = getelementptr inbounds i8, ptr %100, i64 16
  store ptr @i32_typ, ptr %102, align 8
  %103 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 dereferenceable(24) %100)
  call void %103({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull %95, { ptr } %91, i32 65, i32 66) #39
  %104 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @String, ptr %104, align 8
  %105 = getelementptr inbounds i8, ptr %104, i64 8
  store ptr %90, ptr %105, align 8
  %106 = getelementptr inbounds i8, ptr %104, i64 16
  %107 = getelementptr inbounds i8, ptr %104, i64 24
  store i32 10, ptr %107, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %104, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %108 = load ptr, ptr %7, align 8
  %109 = load ptr, ptr %6, align 8
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %109)
  %111 = load i32, ptr %9, align 8
  %112 = sext i32 %111 to i64
  %113 = getelementptr ptr, ptr %109, i64 %112
  %114 = getelementptr i8, ptr %113, i64 24
  %115 = load ptr, ptr %114, align 8
  %116 = getelementptr i8, ptr %115, i64 8
  %117 = load ptr, ptr %116, align 8
  %118 = load ptr, ptr %104, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %118, 0
  %120 = load ptr, ptr %105, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr %120, 1
  %122 = load ptr, ptr %106, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } %121, ptr %122, 2
  %124 = load i32, ptr %107, align 8
  %125 = insertvalue { ptr, ptr, ptr, i32 } %123, i32 %124, 3
  call void %117(ptr %108, { ptr, ptr, ptr, i32 } %125) #30
  %126 = call ptr @bump_malloc(i64 noundef 800)
  %127 = load ptr, ptr %7, align 8
  %128 = load ptr, ptr %6, align 8
  %129 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %128)
  %130 = load i32, ptr %9, align 8
  %131 = sext i32 %130 to i64
  %132 = getelementptr ptr, ptr %128, i64 %131
  %133 = getelementptr i8, ptr %132, i64 32
  %134 = load ptr, ptr %133, align 8
  %135 = getelementptr i8, ptr %134, i64 8
  %136 = load ptr, ptr %135, align 8
  %137 = insertvalue { ptr } undef, ptr %126, 0
  call void %136(ptr %127, { ptr } %137) #30
  %138 = load ptr, ptr %7, align 8
  %139 = load ptr, ptr %6, align 8
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %139)
  %141 = load i32, ptr %9, align 8
  %142 = sext i32 %141 to i64
  %143 = getelementptr ptr, ptr %139, i64 %142
  %144 = getelementptr i8, ptr %143, i64 32
  %145 = load ptr, ptr %144, align 8
  %146 = load ptr, ptr %145, align 8
  %147 = call { ptr } %146(ptr %138) #31
  %148 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %147)
  %149 = load ptr, ptr %7, align 8
  %150 = load ptr, ptr %6, align 8
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %150)
  %152 = load i32, ptr %9, align 8
  %153 = sext i32 %152 to i64
  %154 = getelementptr ptr, ptr %150, i64 %153
  %155 = getelementptr i8, ptr %154, i64 40
  %156 = load ptr, ptr %155, align 8
  %157 = getelementptr i8, ptr %156, i64 8
  %158 = load ptr, ptr %157, align 8
  call void %158(ptr %149, i64 %148) #30
  ret void
}

define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract24 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract21, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract22, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract23, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract24, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(216) @Exception)
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract20, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = load ptr, ptr %9, align 8
  store ptr %14, ptr %13, align 8
  %15 = getelementptr inbounds i8, ptr %13, i64 8
  %16 = load ptr, ptr %10, align 8
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds i8, ptr %13, i64 16
  %18 = load ptr, ptr %11, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds i8, ptr %13, i64 24
  %20 = load i32, ptr %12, align 8
  store i32 %20, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %5, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %8, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %13, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = load ptr, ptr %15, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 1
  %35 = load ptr, ptr %17, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 2
  %37 = load i32, ptr %19, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %37, 3
  call void %30(ptr %21, { ptr, ptr, ptr, i32 } %38) #30
  %39 = load ptr, ptr %6, align 8
  %40 = load ptr, ptr %5, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %40)
  %42 = load i32, ptr %8, align 8
  %43 = sext i32 %42 to i64
  %44 = getelementptr ptr, ptr %40, i64 %43
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  call void %47(ptr %39, i32 0) #30
  %48 = call ptr @bump_malloc(i64 noundef 1)
  %49 = alloca [1 x ptr], align 8
  store ptr @String, ptr %49, align 8
  %50 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %49)
  %51 = extractvalue { i64, i64 } %50, 0
  %52 = call ptr @bump_malloc(i64 %51)
  %53 = insertvalue { ptr } undef, ptr %48, 0
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %52, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 10, 3
  %57 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %57, i64 8
  store ptr @_parameterization_i32, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %57, i64 16
  store ptr @_parameterization_i32, ptr %59, align 8
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %57)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %62 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %62, align 8
  %63 = getelementptr inbounds i8, ptr %62, i64 8
  store ptr @i32_typ, ptr %63, align 8
  %64 = getelementptr inbounds i8, ptr %62, i64 16
  store ptr @i32_typ, ptr %64, align 8
  %65 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %56, ptr noundef nonnull align 8 dereferenceable(24) %62)
  call void %65({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull %57, { ptr } %53, i32 0, i32 1) #39
  %66 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @String, ptr %66, align 8
  %67 = getelementptr inbounds i8, ptr %66, i64 8
  store ptr %52, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %66, i64 16
  %69 = getelementptr inbounds i8, ptr %66, i64 24
  store i32 10, ptr %69, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %66, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %70 = load ptr, ptr %6, align 8
  %71 = load ptr, ptr %5, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %71)
  %73 = load i32, ptr %8, align 8
  %74 = sext i32 %73 to i64
  %75 = getelementptr ptr, ptr %71, i64 %74
  %76 = getelementptr i8, ptr %75, i64 8
  %77 = load ptr, ptr %76, align 8
  %78 = getelementptr i8, ptr %77, i64 8
  %79 = load ptr, ptr %78, align 8
  %80 = load ptr, ptr %66, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %80, 0
  %82 = load ptr, ptr %67, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %82, 1
  %84 = load ptr, ptr %68, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %84, 2
  %86 = load i32, ptr %69, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %86, 3
  call void %79(ptr %70, { ptr, ptr, ptr, i32 } %87) #30
  %88 = call ptr @bump_malloc(i64 noundef 800)
  %89 = load ptr, ptr %6, align 8
  %90 = load ptr, ptr %5, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %90)
  %92 = load i32, ptr %8, align 8
  %93 = sext i32 %92 to i64
  %94 = getelementptr ptr, ptr %90, i64 %93
  %95 = getelementptr i8, ptr %94, i64 24
  %96 = load ptr, ptr %95, align 8
  %97 = getelementptr i8, ptr %96, i64 8
  %98 = load ptr, ptr %97, align 8
  %99 = insertvalue { ptr } undef, ptr %88, 0
  call void %98(ptr %89, { ptr } %99) #30
  %100 = load ptr, ptr %6, align 8
  %101 = load ptr, ptr %5, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %101)
  %103 = load i32, ptr %8, align 8
  %104 = sext i32 %103 to i64
  %105 = getelementptr ptr, ptr %101, i64 %104
  %106 = getelementptr i8, ptr %105, i64 24
  %107 = load ptr, ptr %106, align 8
  %108 = load ptr, ptr %107, align 8
  %109 = call { ptr } %108(ptr %100) #31
  %110 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %109)
  %111 = load ptr, ptr %6, align 8
  %112 = load ptr, ptr %5, align 8
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %112)
  %114 = load i32, ptr %8, align 8
  %115 = sext i32 %114 to i64
  %116 = getelementptr ptr, ptr %112, i64 %115
  %117 = getelementptr i8, ptr %116, i64 32
  %118 = load ptr, ptr %117, align 8
  %119 = getelementptr i8, ptr %118, i64 8
  %120 = load ptr, ptr %119, align 8
  call void %120(ptr %111, i64 %110) #30
  ret void
}

define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract36 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract36, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(216) @Exception)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %8, i32 0) #30
  %17 = call ptr @bump_malloc(i64 noundef 7)
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %17, align 1
  %18 = alloca [1 x ptr], align 8
  store ptr @String, ptr %18, align 8
  %19 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %18)
  %20 = extractvalue { i64, i64 } %19, 0
  %21 = call ptr @bump_malloc(i64 %20)
  %22 = insertvalue { ptr } undef, ptr %17, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %21, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr undef, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 10, 3
  %26 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr @_parameterization_i32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %26, i64 16
  store ptr @_parameterization_i32, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %26)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %31 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %31, i64 8
  store ptr @i32_typ, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %31, i64 16
  store ptr @i32_typ, ptr %33, align 8
  %34 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %25, ptr noundef nonnull align 8 dereferenceable(24) %31)
  call void %34({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %26, { ptr } %22, i32 6, i32 7) #39
  %35 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @String, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %35, i64 8
  store ptr %21, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %35, i64 16
  %38 = getelementptr inbounds i8, ptr %35, i64 24
  store i32 10, ptr %38, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %35, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %39 = load ptr, ptr %5, align 8
  %40 = load ptr, ptr %4, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %40)
  %42 = load i32, ptr %7, align 8
  %43 = sext i32 %42 to i64
  %44 = getelementptr ptr, ptr %40, i64 %43
  %45 = getelementptr i8, ptr %44, i64 16
  %46 = load ptr, ptr %45, align 8
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %49 = load ptr, ptr %35, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %49, 0
  %51 = load ptr, ptr %36, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %51, 1
  %53 = load ptr, ptr %37, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 2
  %55 = load i32, ptr %38, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %55, 3
  call void %48(ptr %39, { ptr, ptr, ptr, i32 } %56) #30
  %57 = call ptr @bump_malloc(i64 noundef 1)
  %58 = alloca [1 x ptr], align 8
  store ptr @String, ptr %58, align 8
  %59 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %58)
  %60 = extractvalue { i64, i64 } %59, 0
  %61 = call ptr @bump_malloc(i64 %60)
  %62 = insertvalue { ptr } undef, ptr %57, 0
  %63 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %61, 1
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr undef, 2
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 10, 3
  %66 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %66, align 8
  %67 = getelementptr inbounds i8, ptr %66, i64 8
  store ptr @_parameterization_i32, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %66, i64 16
  store ptr @_parameterization_i32, ptr %68, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %66)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %71 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %71, i64 8
  store ptr @i32_typ, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %71, i64 16
  store ptr @i32_typ, ptr %73, align 8
  %74 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %65, ptr noundef nonnull align 8 dereferenceable(24) %71)
  call void %74({ ptr, ptr, ptr, i32 } %65, { ptr, ptr, ptr, i32 } %65, ptr nonnull %66, { ptr } %62, i32 0, i32 1) #39
  %75 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @String, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %75, i64 8
  store ptr %61, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %75, i64 16
  %78 = getelementptr inbounds i8, ptr %75, i64 24
  store i32 10, ptr %78, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %75, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %79 = load ptr, ptr %5, align 8
  %80 = load ptr, ptr %4, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %80)
  %82 = load i32, ptr %7, align 8
  %83 = sext i32 %82 to i64
  %84 = getelementptr ptr, ptr %80, i64 %83
  %85 = getelementptr i8, ptr %84, i64 8
  %86 = load ptr, ptr %85, align 8
  %87 = getelementptr i8, ptr %86, i64 8
  %88 = load ptr, ptr %87, align 8
  %89 = load ptr, ptr %75, align 8
  %90 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %89, 0
  %91 = load ptr, ptr %76, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } %90, ptr %91, 1
  %93 = load ptr, ptr %77, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 2
  %95 = load i32, ptr %78, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, i32 %95, 3
  call void %88(ptr %79, { ptr, ptr, ptr, i32 } %96) #30
  %97 = call ptr @bump_malloc(i64 noundef 800)
  %98 = load ptr, ptr %5, align 8
  %99 = load ptr, ptr %4, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %99)
  %101 = load i32, ptr %7, align 8
  %102 = sext i32 %101 to i64
  %103 = getelementptr ptr, ptr %99, i64 %102
  %104 = getelementptr i8, ptr %103, i64 24
  %105 = load ptr, ptr %104, align 8
  %106 = getelementptr i8, ptr %105, i64 8
  %107 = load ptr, ptr %106, align 8
  %108 = insertvalue { ptr } undef, ptr %97, 0
  call void %107(ptr %98, { ptr } %108) #30
  %109 = load ptr, ptr %5, align 8
  %110 = load ptr, ptr %4, align 8
  %111 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %110)
  %112 = load i32, ptr %7, align 8
  %113 = sext i32 %112 to i64
  %114 = getelementptr ptr, ptr %110, i64 %113
  %115 = getelementptr i8, ptr %114, i64 24
  %116 = load ptr, ptr %115, align 8
  %117 = load ptr, ptr %116, align 8
  %118 = call { ptr } %117(ptr %109) #31
  %119 = call i64 @capture_backtrace(i64 noundef 100, { ptr } %118)
  %120 = load ptr, ptr %5, align 8
  %121 = load ptr, ptr %4, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %121)
  %123 = load i32, ptr %7, align 8
  %124 = sext i32 %123 to i64
  %125 = getelementptr ptr, ptr %121, i64 %124
  %126 = getelementptr i8, ptr %125, i64 32
  %127 = load ptr, ptr %126, align 8
  %128 = getelementptr i8, ptr %127, i64 8
  %129 = load ptr, ptr %128, align 8
  call void %129(ptr %120, i64 %119) #30
  ret void
}

define void @Exception_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract2, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract3, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract4, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(216) @Exception)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %10, i32 %3) #30
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 3
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract, ptr %22, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %23 = alloca { ptr, ptr, ptr, i32 }, align 8
  %24 = load ptr, ptr %19, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr inbounds i8, ptr %23, i64 8
  %26 = load ptr, ptr %20, align 8
  store ptr %26, ptr %25, align 8
  %27 = getelementptr inbounds i8, ptr %23, i64 16
  %28 = load ptr, ptr %21, align 8
  store ptr %28, ptr %27, align 8
  %29 = getelementptr inbounds i8, ptr %23, i64 24
  %30 = load i32, ptr %22, align 8
  store i32 %30, ptr %29, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %23, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %31 = load ptr, ptr %7, align 8
  %32 = load ptr, ptr %6, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %32)
  %34 = load i32, ptr %9, align 8
  %35 = sext i32 %34 to i64
  %36 = getelementptr ptr, ptr %32, i64 %35
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %23, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %41, 0
  %43 = load ptr, ptr %25, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %43, 1
  %45 = load ptr, ptr %27, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %45, 2
  %47 = load i32, ptr %29, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %47, 3
  call void %40(ptr %31, { ptr, ptr, ptr, i32 } %48) #30
  ret void
}

define void @Exception_print_stacktrace_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(216) @Exception)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr } %16(ptr %8) #31
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %9)
  %19 = getelementptr i8, ptr %13, i64 32
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i64 %21(ptr %8) #31
  call void @print_backtrace({ ptr } %17, i64 %22)
  ret void
}

define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract117 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract119 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract121 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract123 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract117, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract119, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract121, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract123, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(216) @Exception)
  %9 = call ptr @bump_malloc(i64 noundef 10)
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %9, align 1
  %10 = alloca [1 x ptr], align 8
  store ptr @String, ptr %10, align 8
  %11 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %10)
  %12 = extractvalue { i64, i64 } %11, 0
  %13 = call ptr @bump_malloc(i64 %12)
  %14 = insertvalue { ptr } undef, ptr %9, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %13, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 10, 3
  %18 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr @_parameterization_i32, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %18, i64 16
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %18)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %23 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %23, i64 8
  store ptr @i32_typ, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %23, i64 16
  store ptr @i32_typ, ptr %25, align 8
  %26 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(24) %23)
  call void %26({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %18, { ptr } %14, i32 9, i32 10) #39
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %29 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 %4)
  %30 = call { ptr } %29({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %4) #39
  %.fca.0.extract97 = extractvalue { ptr } %30, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract97) #39
  %31 = call ptr @bump_malloc(i64 noundef 27)
  store <26 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110, i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105, i8 108, i8 101>, ptr %31, align 1
  %32 = alloca [1 x ptr], align 8
  store ptr @String, ptr %32, align 8
  %33 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %32)
  %34 = extractvalue { i64, i64 } %33, 0
  %35 = call ptr @bump_malloc(i64 %34)
  %36 = insertvalue { ptr } undef, ptr %31, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %35, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr undef, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 10, 3
  %40 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %40, i64 8
  store ptr @_parameterization_i32, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %40, i64 16
  store ptr @_parameterization_i32, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %40)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %45 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr @i32_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %45, i64 16
  store ptr @i32_typ, ptr %47, align 8
  %48 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %39, ptr noundef nonnull align 8 dereferenceable(24) %45)
  call void %48({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull %40, { ptr } %36, i32 26, i32 27) #39
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %51 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %39, ptr noundef nonnull align 8 %4)
  %52 = call { ptr } %51({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %4) #39
  %.fca.0.extract77 = extractvalue { ptr } %52, 0
  %puts125 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract77) #39
  %53 = load ptr, ptr %6, align 8
  %54 = load ptr, ptr %5, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %54)
  %56 = load i32, ptr %8, align 8
  %57 = sext i32 %56 to i64
  %58 = getelementptr ptr, ptr %54, i64 %57
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  %61 = load ptr, ptr %60, align 8
  %62 = call { ptr, ptr, ptr, i32 } %61(ptr %53) #31
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract76 = extractvalue { ptr, ptr, ptr, i32 } %62, 0
  store ptr %.fca.0.extract76, ptr %63, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %62, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %63, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %62, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %63, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %62, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %63, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %63, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %64, 0
  %66 = load ptr, ptr %.fca.1.gep, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 1
  %68 = load ptr, ptr %.fca.2.gep, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, ptr %68, 2
  %70 = load i32, ptr %.fca.3.gep, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %69, i32 %70, 3
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %64)
  %74 = sext i32 %70 to i64
  %75 = getelementptr ptr, ptr %64, i64 %74
  %76 = getelementptr i8, ptr %75, i64 80
  %77 = load ptr, ptr %76, align 8
  %78 = call ptr @behavior_wrapper(ptr %77, { ptr, ptr, ptr, i32 } %71, ptr noundef nonnull align 8 %4)
  %79 = call { ptr } %78({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull align 8 %4) #39
  %.fca.0.extract74 = extractvalue { ptr } %79, 0
  %puts126 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract74) #39
  %80 = call ptr @bump_malloc(i64 noundef 8)
  store <7 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101>, ptr %80, align 1
  %81 = alloca [1 x ptr], align 8
  store ptr @String, ptr %81, align 8
  %82 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %81)
  %83 = extractvalue { i64, i64 } %82, 0
  %84 = call ptr @bump_malloc(i64 %83)
  %85 = insertvalue { ptr } undef, ptr %80, 0
  %86 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %84, 1
  %87 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr undef, 2
  %88 = insertvalue { ptr, ptr, ptr, i32 } %87, i32 10, 3
  %89 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %89, i64 8
  store ptr @_parameterization_i32, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %89, i64 16
  store ptr @_parameterization_i32, ptr %91, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %89)
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %94 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %94, i64 8
  store ptr @i32_typ, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %94, i64 16
  store ptr @i32_typ, ptr %96, align 8
  %97 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %88, ptr noundef nonnull align 8 dereferenceable(24) %94)
  call void %97({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr nonnull %89, { ptr } %85, i32 7, i32 8) #39
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %100 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %88, ptr noundef nonnull align 8 %4)
  %101 = call { ptr } %100({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr nonnull align 8 %4) #39
  %.fca.0.extract55 = extractvalue { ptr } %101, 0
  %puts127 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract55) #39
  %102 = load ptr, ptr %6, align 8
  %103 = load ptr, ptr %5, align 8
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %103)
  %105 = load i32, ptr %8, align 8
  %106 = sext i32 %105 to i64
  %107 = getelementptr ptr, ptr %103, i64 %106
  %108 = load ptr, ptr %107, align 8
  %109 = load ptr, ptr %108, align 8
  %110 = call i32 %109(ptr %102) #31
  %111 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %110) #39
  %112 = call ptr @bump_malloc(i64 noundef 13)
  store <12 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115, i8 115, i8 97, i8 103, i8 101>, ptr %112, align 1
  %113 = alloca [1 x ptr], align 8
  store ptr @String, ptr %113, align 8
  %114 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %113)
  %115 = extractvalue { i64, i64 } %114, 0
  %116 = call ptr @bump_malloc(i64 %115)
  %117 = insertvalue { ptr } undef, ptr %112, 0
  %118 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %116, 1
  %119 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr undef, 2
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 10, 3
  %121 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %121, align 8
  %122 = getelementptr inbounds i8, ptr %121, i64 8
  store ptr @_parameterization_i32, ptr %122, align 8
  %123 = getelementptr inbounds i8, ptr %121, i64 16
  store ptr @_parameterization_i32, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %121)
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %126 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %126, align 8
  %127 = getelementptr inbounds i8, ptr %126, i64 8
  store ptr @i32_typ, ptr %127, align 8
  %128 = getelementptr inbounds i8, ptr %126, i64 16
  store ptr @i32_typ, ptr %128, align 8
  %129 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %120, ptr noundef nonnull align 8 dereferenceable(24) %126)
  call void %129({ ptr, ptr, ptr, i32 } %120, { ptr, ptr, ptr, i32 } %120, ptr nonnull %121, { ptr } %117, i32 12, i32 13) #39
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %132 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %120, ptr noundef nonnull align 8 %4)
  %133 = call { ptr } %132({ ptr, ptr, ptr, i32 } %120, { ptr, ptr, ptr, i32 } %120, ptr nonnull align 8 %4) #39
  %.fca.0.extract35 = extractvalue { ptr } %133, 0
  %puts128 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract35) #39
  %134 = load ptr, ptr %5, align 8
  %135 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %134, 0
  %136 = load ptr, ptr %6, align 8
  %137 = insertvalue { ptr, ptr, ptr, i32 } %135, ptr %136, 1
  %138 = load ptr, ptr %7, align 8
  %139 = insertvalue { ptr, ptr, ptr, i32 } %137, ptr %138, 2
  %140 = load i32, ptr %8, align 8
  %141 = insertvalue { ptr, ptr, ptr, i32 } %139, i32 %140, 3
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %143 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %134)
  %144 = sext i32 %140 to i64
  %145 = getelementptr ptr, ptr %134, i64 %144
  %146 = getelementptr i8, ptr %145, i64 80
  %147 = load ptr, ptr %146, align 8
  %148 = call ptr @behavior_wrapper(ptr %147, { ptr, ptr, ptr, i32 } %141, ptr noundef nonnull align 8 %4)
  call void %148({ ptr, ptr, ptr, i32 } %141, { ptr, ptr, ptr, i32 } %141, ptr nonnull align 8 %4) #39
  %149 = call ptr @bump_malloc(i64 noundef 13)
  store <12 x i8> <i8 83, i8 116, i8 97, i8 99, i8 107, i8 32, i8 116, i8 114, i8 97, i8 99, i8 101, i8 58>, ptr %149, align 1
  %150 = alloca [1 x ptr], align 8
  store ptr @String, ptr %150, align 8
  %151 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %150)
  %152 = extractvalue { i64, i64 } %151, 0
  %153 = call ptr @bump_malloc(i64 %152)
  %154 = insertvalue { ptr } undef, ptr %149, 0
  %155 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %153, 1
  %156 = insertvalue { ptr, ptr, ptr, i32 } %155, ptr undef, 2
  %157 = insertvalue { ptr, ptr, ptr, i32 } %156, i32 10, 3
  %158 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %158, align 8
  %159 = getelementptr inbounds i8, ptr %158, i64 8
  store ptr @_parameterization_i32, ptr %159, align 8
  %160 = getelementptr inbounds i8, ptr %158, i64 16
  store ptr @_parameterization_i32, ptr %160, align 8
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %158)
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %163 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %163, align 8
  %164 = getelementptr inbounds i8, ptr %163, i64 8
  store ptr @i32_typ, ptr %164, align 8
  %165 = getelementptr inbounds i8, ptr %163, i64 16
  store ptr @i32_typ, ptr %165, align 8
  %166 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %157, ptr noundef nonnull align 8 dereferenceable(24) %163)
  call void %166({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr nonnull %158, { ptr } %154, i32 12, i32 13) #39
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %168 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %169 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %157, ptr noundef nonnull align 8 %4)
  %170 = call { ptr } %169({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr nonnull align 8 %4) #39
  %.fca.0.extract16 = extractvalue { ptr } %170, 0
  %puts129 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract16) #39
  %171 = load ptr, ptr %5, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %171, 0
  %173 = load ptr, ptr %6, align 8
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, ptr %173, 1
  %175 = load ptr, ptr %7, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } %174, ptr %175, 2
  %177 = load i32, ptr %8, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, i32 %177, 3
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %171)
  %181 = sext i32 %177 to i64
  %182 = getelementptr ptr, ptr %171, i64 %181
  %183 = getelementptr i8, ptr %182, i64 64
  %184 = load ptr, ptr %183, align 8
  %185 = call ptr @behavior_wrapper(ptr %184, { ptr, ptr, ptr, i32 } %178, ptr noundef nonnull align 8 %4)
  call void %185({ ptr, ptr, ptr, i32 } %178, { ptr, ptr, ptr, i32 } %178, ptr nonnull align 8 %4) #39
  %186 = call ptr @bump_malloc(i64 noundef 10)
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %186, align 1
  %187 = alloca [1 x ptr], align 8
  store ptr @String, ptr %187, align 8
  %188 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %187)
  %189 = extractvalue { i64, i64 } %188, 0
  %190 = call ptr @bump_malloc(i64 %189)
  %191 = insertvalue { ptr } undef, ptr %186, 0
  %192 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %190, 1
  %193 = insertvalue { ptr, ptr, ptr, i32 } %192, ptr undef, 2
  %194 = insertvalue { ptr, ptr, ptr, i32 } %193, i32 10, 3
  %195 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %195, align 8
  %196 = getelementptr inbounds i8, ptr %195, i64 8
  store ptr @_parameterization_i32, ptr %196, align 8
  %197 = getelementptr inbounds i8, ptr %195, i64 16
  store ptr @_parameterization_i32, ptr %197, align 8
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %195)
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %200 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %200, align 8
  %201 = getelementptr inbounds i8, ptr %200, i64 8
  store ptr @i32_typ, ptr %201, align 8
  %202 = getelementptr inbounds i8, ptr %200, i64 16
  store ptr @i32_typ, ptr %202, align 8
  %203 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %194, ptr noundef nonnull align 8 dereferenceable(24) %200)
  call void %203({ ptr, ptr, ptr, i32 } %194, { ptr, ptr, ptr, i32 } %194, ptr nonnull %195, { ptr } %191, i32 9, i32 10) #39
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %206 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %194, ptr noundef nonnull align 8 %4)
  %207 = call { ptr } %206({ ptr, ptr, ptr, i32 } %194, { ptr, ptr, ptr, i32 } %194, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr } %207, 0
  %puts130 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #39
  ret void
}

define void @OutOfBounds_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract7, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract9, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract11, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract13, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(376) @OutOfBounds)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = getelementptr i8, ptr %15, i64 24
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = call { ptr, ptr, ptr, i32 } %18(ptr %10) #31
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  store ptr %.fca.0.extract5, ptr %20, align 8
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %20, i64 8
  store ptr %.fca.1.extract6, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %20, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %20, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %20, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = load ptr, ptr %.fca.1.gep, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %23, 1
  %25 = load ptr, ptr %.fca.2.gep, align 8
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %25, 2
  %27 = load i32, ptr %.fca.3.gep, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %27, 3
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %21)
  %31 = sext i32 %27 to i64
  %32 = getelementptr ptr, ptr %21, i64 %31
  %33 = getelementptr i8, ptr %32, i64 80
  %34 = load ptr, ptr %33, align 8
  %35 = call ptr @behavior_wrapper(ptr %34, { ptr, ptr, ptr, i32 } %28, ptr noundef nonnull align 8 %4)
  %36 = call { ptr } %35({ ptr, ptr, ptr, i32 } %28, { ptr, ptr, ptr, i32 } %28, ptr nonnull align 8 %4) #39
  %.fca.0.extract3 = extractvalue { ptr } %36, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract3) #39
  %37 = load ptr, ptr %7, align 8
  %38 = load ptr, ptr %6, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 296, ptr nocapture nofree noundef %38)
  %40 = load i32, ptr %9, align 8
  %41 = sext i32 %40 to i64
  %42 = getelementptr ptr, ptr %38, i64 %41
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, i160 } %44(ptr %37) #31
  %.fca.0.extract = extractvalue { ptr, i160 } %45, 0
  %46 = icmp ne ptr %.fca.0.extract, @nil_typ
  %47 = icmp ne ptr %.fca.0.extract, null
  %.not18 = and i1 %46, %47
  br i1 %.not18, label %48, label %._crit_edge

48:                                               ; preds = %3
  %.fca.1.extract = extractvalue { ptr, i160 } %45, 1
  store ptr %.fca.0.extract, ptr %5, align 8
  %49 = getelementptr inbounds i8, ptr %5, i64 8
  store i160 %.fca.1.extract, ptr %49, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails)
  %50 = load ptr, ptr %5, align 8
  %51 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %50, 0
  %52 = load ptr, ptr %49, align 8
  %53 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %52, 1
  %54 = getelementptr inbounds i8, ptr %5, i64 16
  %55 = load ptr, ptr %54, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %55, 2
  %57 = getelementptr inbounds i8, ptr %5, i64 24
  %58 = load i32, ptr %57, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %58, 3
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %50)
  %62 = sext i32 %58 to i64
  %63 = getelementptr ptr, ptr %50, i64 %62
  %64 = getelementptr i8, ptr %63, i64 24
  %65 = load ptr, ptr %64, align 8
  %66 = call ptr @behavior_wrapper(ptr %65, { ptr, ptr, ptr, i32 } %59, ptr noundef nonnull align 8 %4)
  call void %66({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull %4) #39
  br label %._crit_edge

._crit_edge:                                      ; preds = %48, %3
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_OutOfBoundsDetails(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @OutOfBoundsDetails_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @OutOfBoundsDetails_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  call void %18(ptr %10, i32 %3) #30
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %20)
  %22 = load i32, ptr %9, align 8
  %23 = sext i32 %22 to i64
  %24 = getelementptr ptr, ptr %20, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  call void %28(ptr %19, i32 %4) #30
  ret void
}

define void @OutOfBoundsDetails_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract37, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(128) @OutOfBoundsDetails)
  %9 = call ptr @bump_malloc(i64 noundef 45)
  %10 = load <44 x i8>, ptr @modls_The_size_of_the_collection_being_indexed_was, align 64
  store <44 x i8> %10, ptr %9, align 1
  %11 = alloca [1 x ptr], align 8
  store ptr @String, ptr %11, align 8
  %12 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %11)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = call ptr @bump_malloc(i64 %13)
  %15 = insertvalue { ptr } undef, ptr %9, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %14, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr undef, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 10, 3
  %19 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr @_parameterization_i32, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr @_parameterization_i32, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %19)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %24 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %24, i64 8
  store ptr @i32_typ, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %24, i64 16
  store ptr @i32_typ, ptr %26, align 8
  %27 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %18, ptr noundef nonnull align 8 dereferenceable(24) %24)
  call void %27({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull %19, { ptr } %15, i32 44, i32 45) #39
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %30 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %18, ptr noundef nonnull align 8 %4)
  %31 = call { ptr } %30({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 %4) #39
  %.fca.0.extract18 = extractvalue { ptr } %31, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract18) #39
  %32 = load ptr, ptr %6, align 8
  %33 = load ptr, ptr %5, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %33)
  %35 = load i32, ptr %8, align 8
  %36 = sext i32 %35 to i64
  %37 = getelementptr ptr, ptr %33, i64 %36
  %38 = load ptr, ptr %37, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call i32 %39(ptr %32) #31
  %41 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %40) #39
  %42 = call ptr @bump_malloc(i64 noundef 26)
  store <25 x i8> <i8 84, i8 104, i8 101, i8 32, i8 105, i8 110, i8 100, i8 101, i8 120, i8 105, i8 110, i8 103, i8 32, i8 97, i8 114, i8 103, i8 117, i8 109, i8 101, i8 110, i8 116, i8 32, i8 119, i8 97, i8 115>, ptr %42, align 1
  %43 = alloca [1 x ptr], align 8
  store ptr @String, ptr %43, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_String, ptr noundef nonnull align 8 dereferenceable(8) %43)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  %47 = insertvalue { ptr } undef, ptr %42, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %46, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr undef, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 10, 3
  %51 = alloca [3 x ptr], align 8
  store ptr @_parameterization_Bufferi8, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %51, i64 8
  store ptr @_parameterization_i32, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %51, i64 16
  store ptr @_parameterization_i32, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %51)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %56 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %56, i64 8
  store ptr @i32_typ, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %56, i64 16
  store ptr @i32_typ, ptr %58, align 8
  %59 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_init_bytesBufferi8_lengthi32_capacityi32, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(24) %56)
  call void %59({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %51, { ptr } %47, i32 25, i32 26) #39
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 16 dereferenceable(1272) @String)
  %62 = call ptr @behavior_wrapper(ptr noundef nonnull @String_B_c_string_, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 %4)
  %63 = call { ptr } %62({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr } %63, 0
  %puts38 = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #39
  %64 = load ptr, ptr %6, align 8
  %65 = load ptr, ptr %5, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %65)
  %67 = load i32, ptr %8, align 8
  %68 = sext i32 %67 to i64
  %69 = getelementptr ptr, ptr %65, i64 %68
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = load ptr, ptr %70, align 8
  %72 = load ptr, ptr %71, align 8
  %73 = call i32 %72(ptr %64) #31
  %74 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %73) #39
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBoundsDetails_getter_bounds(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBoundsDetails_setter_bounds(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Exception(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 168
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @Exception_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 noundef 6499063144389013426, i64 noundef ptrtoint (ptr @String to i64), ptr %13)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 184
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_stacktrace_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract2, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract4, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract6, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract8, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(216) @Exception)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %9) #31
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  store ptr %.fca.0.extract1, ptr %19, align 8
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract, ptr %.fca.1.gep, align 8
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.2.gep = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract, ptr %.fca.2.gep, align 8
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %.fca.3.gep = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract, ptr %.fca.3.gep, align 8
  call void @assume_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(1272) @String)
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %20, 0
  %22 = load ptr, ptr %.fca.1.gep, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %22, 1
  %24 = load ptr, ptr %.fca.2.gep, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %24, 2
  %26 = load i32, ptr %.fca.3.gep, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %26, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef %20)
  %30 = sext i32 %26 to i64
  %31 = getelementptr ptr, ptr %20, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @behavior_wrapper(ptr %33, { ptr, ptr, ptr, i32 } %27, ptr noundef nonnull align 8 %4)
  %35 = call { ptr } %34({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull %4) #39
  %.fca.0.extract = extractvalue { ptr } %35, 0
  %puts = call i32 @puts(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %.fca.0.extract) #39
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @Exception_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 80
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 80
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Exception_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @OutOfBounds_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 112
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 112
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @OutOfBounds_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 104
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 104
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_message(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 80
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 88
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 96
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 80
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 88
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 96
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_file_name(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @OutOfBounds_getter_line_number(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_line_number(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @OutOfBounds_getter_details(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, i160 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load i160, ptr %4, align 8
  %6 = insertvalue { ptr, i160 } %3, i160 %5, 1
  ret { ptr, i160 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @OutOfBounds_setter_details(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, i160 } %1) #7 {
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store i160 %.fca.1.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 64, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_6(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @CuckooMap_B__Self_max_displacements_(ptr nocapture nofree %0) #28 {
  %2 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #29
  ret ptr @CuckooMap__Self_max_displacements_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_hash1_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 416
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_hash2_from_primary_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index1_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index2_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 noundef 4015701072841558310, i64 noundef ptrtoint (ptr @Entry to i64), ptr %12)
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = getelementptr i8, ptr %14, i64 448
  %16 = load ptr, ptr %15, align 8
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_resize_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 472
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @CuckooMap_B_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 480
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 488
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 496
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 512
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 520
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @CuckooMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 528
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B__index_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 544
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Pair, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Pair to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 568
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 576
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @CuckooMap_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 616
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 624
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 632
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

define ptr @CuckooMap_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @Iterable, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @Iterable to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 640
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @CuckooMap__Self_max_displacements_(ptr nocapture nofree readnone %0) #1 {
  ret i32 100
}

define void @CuckooMap_init_hasherFunctionK_to_i32_eqFunctionK._K_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4) #3 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract10, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %10 = load ptr, ptr %7, align 8
  %11 = load ptr, ptr %6, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %11)
  %13 = load i32, ptr %9, align 8
  %14 = sext i32 %13 to i64
  %15 = getelementptr ptr, ptr %11, i64 %14
  %16 = getelementptr i8, ptr %15, i64 56
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  call void %19(ptr %10, { ptr } %3) #30
  %20 = load ptr, ptr %7, align 8
  %21 = load ptr, ptr %6, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %21)
  %23 = load i32, ptr %9, align 8
  %24 = sext i32 %23 to i64
  %25 = getelementptr ptr, ptr %21, i64 %24
  %26 = getelementptr i8, ptr %25, i64 64
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  call void %29(ptr %20, { ptr } %4) #30
  %30 = load ptr, ptr %7, align 8
  %31 = load ptr, ptr %6, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %31)
  %33 = load i32, ptr %9, align 8
  %34 = sext i32 %33 to i64
  %35 = getelementptr ptr, ptr %31, i64 %34
  %36 = getelementptr i8, ptr %35, i64 40
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  call void %39(ptr %30, i32 8) #30
  %40 = call ptr @bump_malloc(i64 noundef 256)
  %41 = load ptr, ptr %7, align 8
  %42 = load ptr, ptr %6, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %42)
  %44 = load i32, ptr %9, align 8
  %45 = sext i32 %44 to i64
  %46 = getelementptr ptr, ptr %42, i64 %45
  %47 = getelementptr i8, ptr %46, i64 24
  %48 = load ptr, ptr %47, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = insertvalue { ptr } undef, ptr %40, 0
  call void %50(ptr %41, { ptr } %51) #30
  %52 = call ptr @bump_malloc(i64 noundef 256)
  %53 = load ptr, ptr %7, align 8
  %54 = load ptr, ptr %6, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %54)
  %56 = load i32, ptr %9, align 8
  %57 = sext i32 %56 to i64
  %58 = getelementptr ptr, ptr %54, i64 %57
  %59 = getelementptr i8, ptr %58, i64 32
  %60 = load ptr, ptr %59, align 8
  %61 = getelementptr i8, ptr %60, i64 8
  %62 = load ptr, ptr %61, align 8
  %63 = insertvalue { ptr } undef, ptr %52, 0
  call void %62(ptr %53, { ptr } %63) #30
  %64 = load ptr, ptr %7, align 8
  %65 = load ptr, ptr %6, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %65)
  %67 = load i32, ptr %9, align 8
  %68 = sext i32 %67 to i64
  %69 = getelementptr ptr, ptr %65, i64 %68
  %70 = getelementptr i8, ptr %69, i64 48
  %71 = load ptr, ptr %70, align 8
  %72 = getelementptr i8, ptr %71, i64 8
  %73 = load ptr, ptr %72, align 8
  call void %73(ptr %64, i32 0) #30
  ret void
}

define i32 @CuckooMap_hash1_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract6, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract7, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 56
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr } %17(ptr %9) #31
  %.fca.0.extract = extractvalue { ptr } %18, 0
  %19 = call i32 %.fca.0.extract({ ptr, i160 } %3)
  ret i32 %19
}

define i32 @CuckooMap_hash2_from_primary_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %9 = call i32 @i32_hasher(i32 %3)
  ret i32 %9
}

define i32 @CuckooMap_index1_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %9 = load ptr, ptr %6, align 8
  %10 = load ptr, ptr %5, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %10)
  %12 = load i32, ptr %8, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr ptr, ptr %10, i64 %13
  %15 = getelementptr i8, ptr %14, i64 40
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 %17(ptr %9) #31
  %19 = add i32 %18, -1
  %20 = and i32 %19, %3
  ret i32 %20
}

define i32 @CuckooMap_index2_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %5, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %5, i64 24
  store i32 %.fca.3.extract, ptr %8, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %9 = load ptr, ptr %5, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = load ptr, ptr %6, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %11, 1
  %13 = load ptr, ptr %7, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %13, 2
  %15 = load i32, ptr %8, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %15, 3
  %17 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %9)
  %20 = sext i32 %15 to i64
  %21 = getelementptr ptr, ptr %9, i64 %20
  %22 = getelementptr i8, ptr %21, i64 96
  %23 = load ptr, ptr %22, align 8
  %24 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %24, align 8
  %25 = call ptr @behavior_wrapper(ptr %23, { ptr, ptr, ptr, i32 } %16, ptr noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call i32 %25({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %17, i32 %3) #39
  %27 = load ptr, ptr %6, align 8
  %28 = load ptr, ptr %5, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %28)
  %30 = load i32, ptr %8, align 8
  %31 = sext i32 %30 to i64
  %32 = getelementptr ptr, ptr %28, i64 %31
  %33 = getelementptr i8, ptr %32, i64 40
  %34 = load ptr, ptr %33, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %27) #31
  %37 = add i32 %36, -1
  %38 = and i32 %37, %26
  ret i32 %38
}

define { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #3 {
  %5 = alloca {}, align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr %.fca.1.extract9, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %15, i64 16
  store ptr %.fca.2.extract10, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %15, i64 24
  store i32 %.fca.3.extract11, ptr %18, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %15, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract, ptr %22, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = load ptr, ptr %21, align 8
  %26 = load i32, ptr %22, align 8
  %27 = getelementptr inbounds i8, ptr %6, i64 8
  br label %28

28:                                               ; preds = %117, %4
  %.sroa.17.0 = phi i32 [ %26, %4 ], [ %.sroa.17.2, %117 ]
  %.sroa.12.0 = phi ptr [ %25, %4 ], [ %.sroa.12.2, %117 ]
  %.sroa.6.0 = phi ptr [ %24, %4 ], [ %.sroa.6.2, %117 ]
  %.sroa.0.0 = phi ptr [ %23, %4 ], [ %.sroa.0.2, %117 ]
  %.074 = phi i1 [ true, %4 ], [ %.3, %117 ]
  %.0 = phi i32 [ 0, %4 ], [ %.1, %117 ]
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %15, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %30)
  %32 = load i32, ptr %18, align 8
  %33 = sext i32 %32 to i64
  %34 = getelementptr ptr, ptr %30, i64 %33
  %35 = load ptr, ptr %34, align 8
  %36 = call ptr @typegetter_wrapper(ptr %35, ptr %29)
  %37 = load ptr, ptr %16, align 8
  %38 = load ptr, ptr %15, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %38)
  %40 = load i32, ptr %18, align 8
  %41 = sext i32 %40 to i64
  %42 = getelementptr ptr, ptr %38, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %45 = call ptr @typegetter_wrapper(ptr %44, ptr %37)
  store ptr %36, ptr %6, align 8
  store ptr %45, ptr %27, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %6)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %48 = call ptr @class_behavior_wrapper(ptr noundef nonnull @CuckooMap_B__Self_max_displacements_, ptr noundef nonnull align 8 %5)
  %49 = call i32 %48(ptr nonnull %6) #39
  %50 = icmp slt i32 %.0, %49
  br i1 %50, label %51, label %117

51:                                               ; preds = %28
  %52 = add nsw i32 %.0, 1
  %53 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0, 0
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %.sroa.6.0, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %.sroa.12.0, 2
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 %.sroa.17.0, 3
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0)
  %59 = sext i32 %.sroa.17.0 to i64
  %60 = getelementptr ptr, ptr %.sroa.0.0, i64 %59
  %61 = getelementptr i8, ptr %60, i64 64
  %62 = load ptr, ptr %61, align 8
  %63 = call ptr @behavior_wrapper(ptr %62, { ptr, ptr, ptr, i32 } %56, ptr noundef nonnull align 8 %5)
  %64 = call i32 %63({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull %5) #39
  %65 = load ptr, ptr %15, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %65, 0
  %67 = load ptr, ptr %16, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 1
  %69 = load ptr, ptr %17, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %69, 2
  %71 = load i32, ptr %18, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %71, 3
  %73 = sext i32 %71 to i64
  %74 = getelementptr ptr, ptr %65, i64 %73
  %. = select i1 %.074, ptr %7, ptr %11
  %.188 = select i1 %.074, i64 104, i64 112
  %.189 = select i1 %.074, ptr %8, ptr %12
  %.190 = select i1 %.074, i64 24, i64 32
  store ptr @_parameterization_i32, ptr %., align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %.)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %65)
  %77 = getelementptr i8, ptr %74, i64 %.188
  %78 = load ptr, ptr %77, align 8
  store ptr @i32_typ, ptr %.189, align 8
  %79 = call ptr @behavior_wrapper(ptr %78, { ptr, ptr, ptr, i32 } %72, ptr noundef nonnull align 8 dereferenceable(8) %.189)
  %80 = call i32 %79({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull %., i32 %64) #39
  %81 = load ptr, ptr %16, align 8
  %82 = load ptr, ptr %15, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %82)
  %84 = load i32, ptr %18, align 8
  %85 = sext i32 %84 to i64
  %86 = getelementptr ptr, ptr %82, i64 %85
  %87 = getelementptr i8, ptr %86, i64 %.190
  %88 = load ptr, ptr %87, align 8
  %89 = load ptr, ptr %88, align 8
  %90 = call { ptr } %89(ptr %81) #31
  %.fca.0.extract55 = extractvalue { ptr } %90, 0
  %91 = sext i32 %80 to i64
  %92 = shl nsw i64 %91, 5
  %93 = getelementptr i8, ptr %.fca.0.extract55, i64 %92
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr i8, ptr %93, i64 8
  %96 = load i160, ptr %95, align 4
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %82)
  %98 = call { ptr } %89(ptr %81) #31
  %.fca.0.extract52 = extractvalue { ptr } %98, 0
  %99 = getelementptr i8, ptr %.fca.0.extract52, i64 %92
  store ptr %.sroa.0.0, ptr %99, align 8
  %100 = getelementptr i8, ptr %99, i64 8
  %101 = ptrtoint ptr %.sroa.6.0 to i64
  %102 = ptrtoint ptr %.sroa.12.0 to i64
  store i64 %101, ptr %100, align 4
  %.sroa_idx104 = getelementptr i8, ptr %99, i64 16
  store i64 %102, ptr %.sroa_idx104, align 4
  %.sroa_idx105 = getelementptr i8, ptr %99, i64 24
  store i32 %.sroa.17.0, ptr %.sroa_idx105, align 4
  %103 = icmp ne ptr %94, @nil_typ
  %104 = icmp ne ptr %94, null
  %.not94 = and i1 %103, %104
  br i1 %.not94, label %.cont, label %._crit_edge

.cont:                                            ; preds = %51
  %105 = select i1 %.074, ptr %9, ptr %13
  %106 = select i1 %.074, ptr %10, ptr %14
  %107 = xor i1 %.074, true
  store ptr %94, ptr %105, align 8
  %.sroa.sel31.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.074, ptr %9, ptr %13
  %.sroa.sel31.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.sroa.sel31.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  store i160 %96, ptr %.sroa.sel31.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %105, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %108 = load ptr, ptr %105, align 8
  store ptr %108, ptr %106, align 8
  %.sroa.sel19.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.074, ptr %10, ptr %14
  %.sroa.sel19.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.sroa.sel19.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  %109 = load ptr, ptr %.sroa.sel31.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store ptr %109, ptr %.sroa.sel19.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.sroa.sel40.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.074, ptr %9, ptr %13
  %.sroa.sel40.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.sroa.sel40.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  %.sroa.sel22.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.074, ptr %10, ptr %14
  %.sroa.sel22.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.sroa.sel22.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 16
  %110 = load ptr, ptr %.sroa.sel40.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store ptr %110, ptr %.sroa.sel22.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %.sroa.sel43.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.074, ptr %9, ptr %13
  %.sroa.sel43.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.sroa.sel43.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 24
  %.sroa.sel25.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.074, ptr %10, ptr %14
  %.sroa.sel25.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.sroa.sel25.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 24
  %111 = load i32, ptr %.sroa.sel43.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store i32 %111, ptr %.sroa.sel25.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %106, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %112 = load ptr, ptr %106, align 8
  %113 = load ptr, ptr %.sroa.sel19.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %114 = load ptr, ptr %.sroa.sel22.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %115 = load i32, ptr %.sroa.sel25.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %.cont, %51
  %.sroa.17.1 = phi i32 [ %115, %.cont ], [ %.sroa.17.0, %51 ]
  %.sroa.12.1 = phi ptr [ %114, %.cont ], [ %.sroa.12.0, %51 ]
  %.sroa.6.1 = phi ptr [ %113, %.cont ], [ %.sroa.6.0, %51 ]
  %.sroa.0.1 = phi ptr [ %112, %.cont ], [ %.sroa.0.0, %51 ]
  %.2 = phi i1 [ %107, %.cont ], [ %.074, %51 ]
  %116 = xor i1 %.not94, true
  br label %117

117:                                              ; preds = %._crit_edge, %28
  %.sroa.17.2 = phi i32 [ %.sroa.17.1, %._crit_edge ], [ %.sroa.17.0, %28 ]
  %.sroa.12.2 = phi ptr [ %.sroa.12.1, %._crit_edge ], [ %.sroa.12.0, %28 ]
  %.sroa.6.2 = phi ptr [ %.sroa.6.1, %._crit_edge ], [ %.sroa.6.0, %28 ]
  %.sroa.0.2 = phi ptr [ %.sroa.0.1, %._crit_edge ], [ %.sroa.0.0, %28 ]
  %.reg2mem143.0.off0 = phi i1 [ %.not94, %._crit_edge ], [ false, %28 ]
  %.reg2mem145.0 = phi i1 [ %116, %._crit_edge ], [ false, %28 ]
  %.3 = phi i1 [ %.2, %._crit_edge ], [ %.074, %28 ]
  %.1 = phi i32 [ %52, %._crit_edge ], [ %.0, %28 ]
  br i1 %.reg2mem143.0.off0, label %28, label %118

118:                                              ; preds = %117
  br i1 %.reg2mem145.0, label %119, label %134

119:                                              ; preds = %118
  %120 = load ptr, ptr %16, align 8
  %121 = load ptr, ptr %15, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %121)
  %123 = load i32, ptr %18, align 8
  %124 = sext i32 %123 to i64
  %125 = getelementptr ptr, ptr %121, i64 %124
  %126 = getelementptr i8, ptr %125, i64 48
  %127 = load ptr, ptr %126, align 8
  %128 = load ptr, ptr %127, align 8
  %129 = call i32 %128(ptr %120) #31
  %130 = add i32 %129, 1
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %121)
  %132 = getelementptr i8, ptr %127, i64 8
  %133 = load ptr, ptr %132, align 8
  call void %133(ptr %120, i32 %130) #30
  br label %137

134:                                              ; preds = %118
  %135 = ptrtoint ptr %.sroa.6.2 to i64
  %136 = ptrtoint ptr %.sroa.12.2 to i64
  %.sroa.17.8.insert.ext = zext i32 %.sroa.17.2 to i160
  %.sroa.17.8.insert.shift = shl nuw i160 %.sroa.17.8.insert.ext, 128
  %.sroa.12.8.insert.ext = zext i64 %136 to i160
  %.sroa.12.8.insert.shift = shl nuw nsw i160 %.sroa.12.8.insert.ext, 64
  %.sroa.12.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.shift, %.sroa.17.8.insert.shift
  %.sroa.6.8.insert.ext = zext i64 %135 to i160
  %.sroa.6.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.insert, %.sroa.6.8.insert.ext
  br label %137

137:                                              ; preds = %134, %119
  %.reg2mem141.sroa.3.0 = phi i160 [ undef, %119 ], [ %.sroa.6.8.insert.insert, %134 ]
  %.reg2mem141.sroa.0.0 = phi ptr [ @nil_typ, %119 ], [ %.sroa.0.2, %134 ]
  %.reload142.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem141.sroa.0.0, 0
  %.reload142.fca.1.insert = insertvalue { ptr, i160 } %.reload142.fca.0.insert, i160 %.reg2mem141.sroa.3.0, 1
  ret { ptr, i160 } %.reload142.fca.1.insert
}

define void @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablei32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4) #3 {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract4, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %14 = getelementptr inbounds i8, ptr %6, i64 8
  %15 = getelementptr inbounds i8, ptr %7, i64 8
  %16 = getelementptr inbounds i8, ptr %6, i64 16
  %17 = getelementptr inbounds i8, ptr %7, i64 16
  %18 = getelementptr inbounds i8, ptr %6, i64 24
  %19 = getelementptr inbounds i8, ptr %7, i64 24
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %._crit_edge, %5
  %.0 = phi i32 [ 0, %5 ], [ %.1, %._crit_edge ]
  %20 = icmp slt i32 %.0, %4
  br i1 %20, label %21, label %._crit_edge

21:                                               ; preds = %._crit_edge2
  %22 = sext i32 %.0 to i64
  %23 = shl nsw i64 %22, 5
  %24 = getelementptr i8, ptr %.fca.0.extract, i64 %23
  %25 = load ptr, ptr %24, align 8
  %26 = icmp ne ptr %25, @nil_typ
  %27 = icmp ne ptr %25, null
  %.not17 = and i1 %26, %27
  br i1 %.not17, label %28, label %._crit_edge1

28:                                               ; preds = %21
  %29 = getelementptr i8, ptr %24, i64 8
  %30 = load i160, ptr %29, align 4
  store ptr %25, ptr %6, align 8
  store i160 %30, ptr %14, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %31 = load ptr, ptr %6, align 8
  store ptr %31, ptr %7, align 8
  %32 = load ptr, ptr %14, align 8
  store ptr %32, ptr %15, align 8
  %33 = load ptr, ptr %16, align 8
  store ptr %33, ptr %17, align 8
  %34 = load i32, ptr %18, align 8
  store i32 %34, ptr %19, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %35 = load ptr, ptr %7, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %35, 0
  %37 = load ptr, ptr %15, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %37, 1
  %39 = load ptr, ptr %17, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %39, 2
  %41 = load i32, ptr %19, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %41, 3
  %43 = load ptr, ptr %10, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %43, 0
  %45 = load ptr, ptr %11, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %45, 1
  %47 = load ptr, ptr %12, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %47, 2
  %49 = load i32, ptr %13, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %49, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %43)
  %52 = sext i32 %49 to i64
  %53 = getelementptr ptr, ptr %43, i64 %52
  %54 = load ptr, ptr %53, align 8
  %55 = call ptr @typegetter_wrapper(ptr %54, ptr %45)
  %56 = load ptr, ptr %11, align 8
  %57 = load ptr, ptr %10, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %57)
  %59 = load i32, ptr %13, align 8
  %60 = sext i32 %59 to i64
  %61 = getelementptr ptr, ptr %57, i64 %60
  %62 = getelementptr i8, ptr %61, i64 8
  %63 = load ptr, ptr %62, align 8
  %64 = call ptr @typegetter_wrapper(ptr %63, ptr %56)
  %65 = call ptr @bump_malloc(i64 noundef 32)
  %66 = getelementptr i8, ptr %65, i64 16
  store ptr %64, ptr %66, align 8
  %67 = getelementptr i8, ptr %65, i64 8
  store ptr %55, ptr %67, align 8
  %68 = getelementptr i8, ptr %65, i64 24
  store ptr null, ptr %68, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %65)
  store ptr @Entry, ptr %65, align 8
  store ptr %65, ptr %8, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %43)
  %72 = getelementptr i8, ptr %53, i64 120
  %73 = load ptr, ptr %72, align 8
  store ptr %35, ptr %9, align 8
  %74 = call ptr @behavior_wrapper(ptr %73, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 dereferenceable(8) %9)
  %75 = call { ptr, i160 } %74({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %8, { ptr, ptr, ptr, i32 } %42) #39
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %28, %21
  %76 = add i32 %.0, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge1, %._crit_edge2
  %.1 = phi i32 [ %76, %._crit_edge1 ], [ %.0, %._crit_edge2 ]
  br i1 %20, label %._crit_edge2, label %77

77:                                               ; preds = %._crit_edge
  ret void
}

define void @CuckooMap_resize_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
._crit_edge:
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract15, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %11 = load ptr, ptr %8, align 8
  %12 = load ptr, ptr %7, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %12)
  %14 = load i32, ptr %10, align 8
  %15 = sext i32 %14 to i64
  %16 = getelementptr ptr, ptr %12, i64 %15
  %17 = getelementptr i8, ptr %16, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = call { ptr } %19(ptr %11) #31
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %12)
  %22 = getelementptr i8, ptr %16, i64 32
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = call { ptr } %24(ptr %11) #31
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %12)
  %27 = getelementptr i8, ptr %16, i64 40
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call i32 %29(ptr %11) #31
  %31 = shl i32 %30, 1
  %spec.select = call i32 @llvm.smax.i32(i32 %31, i32 16)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %12)
  %33 = getelementptr i8, ptr %28, i64 8
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %11, i32 %spec.select) #30
  %35 = zext nneg i32 %spec.select to i64
  %36 = shl nuw nsw i64 %35, 5
  %37 = call ptr @bump_malloc(i64 %36)
  %38 = load ptr, ptr %8, align 8
  %39 = load ptr, ptr %7, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %39)
  %41 = load i32, ptr %10, align 8
  %42 = sext i32 %41 to i64
  %43 = getelementptr ptr, ptr %39, i64 %42
  %44 = getelementptr i8, ptr %43, i64 24
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr } undef, ptr %37, 0
  call void %47(ptr %38, { ptr } %48) #30
  %49 = call ptr @bump_malloc(i64 %36)
  %50 = load ptr, ptr %8, align 8
  %51 = load ptr, ptr %7, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %51)
  %53 = load i32, ptr %10, align 8
  %54 = sext i32 %53 to i64
  %55 = getelementptr ptr, ptr %51, i64 %54
  %56 = getelementptr i8, ptr %55, i64 32
  %57 = load ptr, ptr %56, align 8
  %58 = getelementptr i8, ptr %57, i64 8
  %59 = load ptr, ptr %58, align 8
  %60 = insertvalue { ptr } undef, ptr %49, 0
  call void %59(ptr %50, { ptr } %60) #30
  %61 = load ptr, ptr %8, align 8
  %62 = load ptr, ptr %7, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %62)
  %64 = load i32, ptr %10, align 8
  %65 = sext i32 %64 to i64
  %66 = getelementptr ptr, ptr %62, i64 %65
  %67 = getelementptr i8, ptr %66, i64 48
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  call void %70(ptr %61, i32 0) #30
  %71 = load ptr, ptr %7, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %71, 0
  %73 = load ptr, ptr %8, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 1
  %75 = load ptr, ptr %9, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %75, 2
  %77 = load i32, ptr %10, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %77, 3
  %79 = call ptr @bump_malloc(i64 noundef 16)
  %80 = getelementptr i8, ptr %79, i64 8
  store ptr null, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %79)
  store ptr @buffer_typ, ptr %79, align 8
  store ptr %79, ptr %3, align 8
  %82 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_i32, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %71)
  %85 = sext i32 %77 to i64
  %86 = getelementptr ptr, ptr %71, i64 %85
  %87 = getelementptr i8, ptr %86, i64 128
  %88 = load ptr, ptr %87, align 8
  store ptr @buffer_typ, ptr %4, align 8
  %89 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %89, align 8
  %90 = call ptr @behavior_wrapper(ptr %88, { ptr, ptr, ptr, i32 } %78, ptr noundef nonnull align 8 dereferenceable(16) %4)
  call void %90({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull %3, { ptr } %20, i32 %30) #39
  %91 = load ptr, ptr %7, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %8, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %9, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %10, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = call ptr @bump_malloc(i64 noundef 16)
  %100 = getelementptr i8, ptr %99, i64 8
  store ptr null, ptr %100, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %99)
  store ptr @buffer_typ, ptr %99, align 8
  store ptr %99, ptr %5, align 8
  %102 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_i32, ptr %102, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5)
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %91)
  %105 = sext i32 %97 to i64
  %106 = getelementptr ptr, ptr %91, i64 %105
  %107 = getelementptr i8, ptr %106, i64 128
  %108 = load ptr, ptr %107, align 8
  store ptr @buffer_typ, ptr %6, align 8
  %109 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %109, align 8
  %110 = call ptr @behavior_wrapper(ptr %108, { ptr, ptr, ptr, i32 } %98, ptr noundef nonnull align 8 dereferenceable(16) %6)
  call void %110({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull %5, { ptr } %25, i32 %30) #39
  ret void
}

define noundef i1 @CuckooMap_replace_in_table_keyK_valueV_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5, i32 %6, { ptr } %7) #3 {
  %9 = alloca [0 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %11 = alloca [3 x ptr], align 8
  %12 = alloca [3 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr }, align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract21, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr %.fca.1.extract22, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %14, i64 16
  store ptr %.fca.2.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %14, i64 24
  store i32 %.fca.3.extract, ptr %17, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract17 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract12 = extractvalue { ptr, i160 } %4, 0
  %.fca.0.extract = extractvalue { ptr } %7, 0
  %18 = sext i32 %6 to i64
  %19 = shl nsw i64 %18, 5
  %20 = getelementptr i8, ptr %.fca.0.extract, i64 %19
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %20, i64 8
  %23 = icmp ne ptr %21, @nil_typ
  %24 = icmp ne ptr %21, null
  %.not66 = and i1 %23, %24
  br i1 %.not66, label %25, label %.critedge

25:                                               ; preds = %8
  %26 = load i160, ptr %22, align 4
  store ptr %21, ptr %10, align 8
  %27 = getelementptr inbounds i8, ptr %10, i64 8
  store i160 %26, ptr %27, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %28 = load ptr, ptr %10, align 8
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %28, 0
  %30 = load ptr, ptr %27, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %30, 1
  %32 = getelementptr inbounds i8, ptr %10, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %33, 2
  %35 = getelementptr inbounds i8, ptr %10, i64 24
  %36 = load i32, ptr %35, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %36, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %28)
  %40 = sext i32 %36 to i64
  %41 = getelementptr ptr, ptr %28, i64 %40
  %42 = getelementptr i8, ptr %41, i64 64
  %43 = load ptr, ptr %42, align 8
  %44 = call ptr @behavior_wrapper(ptr %43, { ptr, ptr, ptr, i32 } %37, ptr noundef nonnull align 8 %9)
  %45 = call i32 %44({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %9) #39
  %46 = icmp eq i32 %45, %5
  br i1 %46, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %25
  %47 = load ptr, ptr %10, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %49 = load ptr, ptr %27, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 1
  %51 = load ptr, ptr %32, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %51, 2
  %53 = load i32, ptr %35, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %53, 3
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %47)
  %57 = sext i32 %53 to i64
  %58 = getelementptr ptr, ptr %47, i64 %57
  %59 = getelementptr i8, ptr %58, i64 48
  %60 = load ptr, ptr %59, align 8
  %61 = call ptr @behavior_wrapper(ptr %60, { ptr, ptr, ptr, i32 } %54, ptr noundef nonnull align 8 %9)
  %62 = call { ptr, i160 } %61({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr nonnull %9) #39
  %63 = load ptr, ptr %15, align 8
  %64 = load ptr, ptr %14, align 8
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %64)
  %66 = load i32, ptr %17, align 8
  %67 = sext i32 %66 to i64
  %68 = getelementptr ptr, ptr %64, i64 %67
  %69 = getelementptr i8, ptr %68, i64 64
  %70 = load ptr, ptr %69, align 8
  %71 = load ptr, ptr %70, align 8
  %72 = call { ptr } %71(ptr %63) #31
  %.fca.0.extract49 = extractvalue { ptr } %72, 0
  %73 = call i1 %.fca.0.extract49({ ptr, i160 } %62, { ptr, i160 } %3)
  br i1 %73, label %74, label %.critedge

74:                                               ; preds = %._crit_edge
  %75 = load ptr, ptr %15, align 8
  %76 = load ptr, ptr %14, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %76)
  %78 = load i32, ptr %17, align 8
  %79 = sext i32 %78 to i64
  %80 = getelementptr ptr, ptr %76, i64 %79
  %81 = load ptr, ptr %80, align 8
  %82 = call ptr @typegetter_wrapper(ptr %81, ptr %75)
  %83 = load ptr, ptr %15, align 8
  %84 = load ptr, ptr %14, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %84)
  %86 = load i32, ptr %17, align 8
  %87 = sext i32 %86 to i64
  %88 = getelementptr ptr, ptr %84, i64 %87
  %89 = getelementptr i8, ptr %88, i64 8
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr @typegetter_wrapper(ptr %90, ptr %83)
  store ptr @Entry, ptr %11, align 8
  %92 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %82, ptr %92, align 8
  %93 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr %91, ptr %93, align 8
  %94 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Entry, ptr noundef nonnull align 8 dereferenceable(24) %11)
  %95 = extractvalue { i64, i64 } %94, 0
  %96 = call ptr @bump_malloc(i64 %95)
  store ptr %82, ptr %96, align 8
  %97 = getelementptr i8, ptr %96, i64 8
  store ptr %91, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %96)
  %99 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %96, 1
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, ptr undef, 2
  %101 = insertvalue { ptr, ptr, ptr, i32 } %100, i32 10, 3
  %102 = load ptr, ptr %15, align 8
  %103 = load ptr, ptr %14, align 8
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %103)
  %105 = load i32, ptr %17, align 8
  %106 = sext i32 %105 to i64
  %107 = getelementptr ptr, ptr %103, i64 %106
  %108 = load ptr, ptr %107, align 8
  %109 = call ptr @typegetter_wrapper(ptr %108, ptr %102)
  %110 = load ptr, ptr %15, align 8
  %111 = load ptr, ptr %14, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %111)
  %113 = load i32, ptr %17, align 8
  %114 = sext i32 %113 to i64
  %115 = getelementptr ptr, ptr %111, i64 %114
  %116 = getelementptr i8, ptr %115, i64 8
  %117 = load ptr, ptr %116, align 8
  %118 = call ptr @typegetter_wrapper(ptr %117, ptr %110)
  store ptr %109, ptr %12, align 8
  %119 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %118, ptr %119, align 8
  %120 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %12)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry)
  store ptr %.fca.0.extract17, ptr %13, align 8
  %123 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.0.extract12, ptr %123, align 8
  %124 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %124, align 8
  %125 = call ptr @behavior_wrapper(ptr noundef nonnull @Entry_B_init_keyK_valueV_primary_hashi32, { ptr, ptr, ptr, i32 } %101, ptr noundef nonnull align 8 dereferenceable(24) %13)
  call void %125({ ptr, ptr, ptr, i32 } %101, { ptr, ptr, ptr, i32 } %101, ptr nonnull %12, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #39
  store ptr @Entry, ptr %20, align 8
  %126 = ptrtoint ptr %96 to i64
  store i64 %126, ptr %22, align 4
  %.sroa_idx30 = getelementptr i8, ptr %20, i64 24
  store i32 10, ptr %.sroa_idx30, align 4
  br label %.critedge

.critedge:                                        ; preds = %74, %._crit_edge, %25, %8
  %.reg2mem45.0 = phi i1 [ false, %._crit_edge ], [ true, %74 ], [ false, %8 ], [ false, %25 ]
  ret i1 %.reg2mem45.0
}

define { ptr, i160 } @CuckooMap_get_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) #3 {
  %8 = alloca [0 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract14, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract15, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %14 = sext i32 %5 to i64
  %15 = shl nsw i64 %14, 5
  %16 = getelementptr i8, ptr %.fca.0.extract, i64 %15
  %17 = load ptr, ptr %16, align 8
  %18 = icmp ne ptr %17, @nil_typ
  %19 = icmp ne ptr %17, null
  %.not45 = and i1 %18, %19
  br i1 %.not45, label %20, label %.critedge

20:                                               ; preds = %7
  %21 = getelementptr i8, ptr %16, i64 8
  %22 = load i160, ptr %21, align 4
  store ptr %17, ptr %9, align 8
  %23 = getelementptr inbounds i8, ptr %9, i64 8
  store i160 %22, ptr %23, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %24 = load ptr, ptr %9, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %24, 0
  %26 = load ptr, ptr %23, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %26, 1
  %28 = getelementptr inbounds i8, ptr %9, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %29, 2
  %31 = getelementptr inbounds i8, ptr %9, i64 24
  %32 = load i32, ptr %31, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %32, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %24)
  %36 = sext i32 %32 to i64
  %37 = getelementptr ptr, ptr %24, i64 %36
  %38 = getelementptr i8, ptr %37, i64 64
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 %8)
  %41 = call i32 %40({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull align 8 %8) #39
  %42 = icmp eq i32 %41, %4
  br i1 %42, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %20
  %43 = load ptr, ptr %9, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %43, 0
  %45 = load ptr, ptr %23, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %45, 1
  %47 = load ptr, ptr %28, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %47, 2
  %49 = load i32, ptr %31, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %49, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %43)
  %53 = sext i32 %49 to i64
  %54 = getelementptr ptr, ptr %43, i64 %53
  %55 = getelementptr i8, ptr %54, i64 48
  %56 = load ptr, ptr %55, align 8
  %57 = call ptr @behavior_wrapper(ptr %56, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 %8)
  %58 = call { ptr, i160 } %57({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %8) #39
  %59 = load ptr, ptr %11, align 8
  %60 = load ptr, ptr %10, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %60)
  %62 = load i32, ptr %13, align 8
  %63 = sext i32 %62 to i64
  %64 = getelementptr ptr, ptr %60, i64 %63
  %65 = getelementptr i8, ptr %64, i64 64
  %66 = load ptr, ptr %65, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr } %67(ptr %59) #31
  %.fca.0.extract28 = extractvalue { ptr } %68, 0
  %69 = call i1 %.fca.0.extract28({ ptr, i160 } %58, { ptr, i160 } %3)
  br i1 %69, label %70, label %.critedge

70:                                               ; preds = %._crit_edge
  %71 = load ptr, ptr %9, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %71, 0
  %73 = load ptr, ptr %23, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 1
  %75 = load ptr, ptr %28, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %75, 2
  %77 = load i32, ptr %31, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %77, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %71)
  %81 = sext i32 %77 to i64
  %82 = getelementptr ptr, ptr %71, i64 %81
  %83 = getelementptr i8, ptr %82, i64 56
  %84 = load ptr, ptr %83, align 8
  %85 = call ptr @behavior_wrapper(ptr %84, { ptr, ptr, ptr, i32 } %78, ptr noundef nonnull align 8 %8)
  %86 = call { ptr, i160 } %85({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull %8) #39
  %.fca.0.extract22 = extractvalue { ptr, i160 } %86, 0
  %.fca.1.extract23 = extractvalue { ptr, i160 } %86, 1
  br label %.critedge

.critedge:                                        ; preds = %70, %._crit_edge, %20, %7
  %.reg2mem43.sroa.3.0 = phi i160 [ %.fca.1.extract23, %70 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %20 ]
  %.reg2mem41.0 = phi ptr [ %.fca.0.extract22, %70 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %20 ]
  %.reload40.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem41.0, 0
  %.reload40.fca.1.insert = insertvalue { ptr, i160 } %.reload40.fca.0.insert, i160 %.reg2mem43.sroa.3.0, 1
  ret { ptr, i160 } %.reload40.fca.1.insert
}

define { ptr, i160 } @CuckooMap_remove_from_table_keyK_h1i32_idxi32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) #3 {
  %8 = alloca [0 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract16, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.1.extract17, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr %.fca.2.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 %.fca.3.extract, ptr %13, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %14 = sext i32 %5 to i64
  %15 = shl nsw i64 %14, 5
  %16 = getelementptr i8, ptr %.fca.0.extract, i64 %15
  %17 = load ptr, ptr %16, align 8
  %18 = icmp ne ptr %17, @nil_typ
  %19 = icmp ne ptr %17, null
  %.not53 = and i1 %18, %19
  br i1 %.not53, label %20, label %.critedge

20:                                               ; preds = %7
  %21 = getelementptr i8, ptr %16, i64 8
  %22 = load i160, ptr %21, align 4
  store ptr %17, ptr %9, align 8
  %23 = getelementptr inbounds i8, ptr %9, i64 8
  store i160 %22, ptr %23, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %24 = load ptr, ptr %9, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %24, 0
  %26 = load ptr, ptr %23, align 8
  %27 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %26, 1
  %28 = getelementptr inbounds i8, ptr %9, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %29, 2
  %31 = getelementptr inbounds i8, ptr %9, i64 24
  %32 = load i32, ptr %31, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %32, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %24)
  %36 = sext i32 %32 to i64
  %37 = getelementptr ptr, ptr %24, i64 %36
  %38 = getelementptr i8, ptr %37, i64 64
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr @behavior_wrapper(ptr %39, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 %8)
  %41 = call i32 %40({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull align 8 %8) #39
  %42 = icmp eq i32 %41, %4
  br i1 %42, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %20
  %43 = load ptr, ptr %9, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %43, 0
  %45 = load ptr, ptr %23, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %45, 1
  %47 = load ptr, ptr %28, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %47, 2
  %49 = load i32, ptr %31, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %49, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %43)
  %53 = sext i32 %49 to i64
  %54 = getelementptr ptr, ptr %43, i64 %53
  %55 = getelementptr i8, ptr %54, i64 48
  %56 = load ptr, ptr %55, align 8
  %57 = call ptr @behavior_wrapper(ptr %56, { ptr, ptr, ptr, i32 } %50, ptr noundef nonnull align 8 %8)
  %58 = call { ptr, i160 } %57({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %8) #39
  %59 = load ptr, ptr %11, align 8
  %60 = load ptr, ptr %10, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %60)
  %62 = load i32, ptr %13, align 8
  %63 = sext i32 %62 to i64
  %64 = getelementptr ptr, ptr %60, i64 %63
  %65 = getelementptr i8, ptr %64, i64 64
  %66 = load ptr, ptr %65, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr } %67(ptr %59) #31
  %.fca.0.extract36 = extractvalue { ptr } %68, 0
  %69 = call i1 %.fca.0.extract36({ ptr, i160 } %58, { ptr, i160 } %3)
  br i1 %69, label %70, label %.critedge

70:                                               ; preds = %._crit_edge
  %71 = load ptr, ptr %9, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %71, 0
  %73 = load ptr, ptr %23, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 1
  %75 = load ptr, ptr %28, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %75, 2
  %77 = load i32, ptr %31, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %77, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %71)
  %81 = sext i32 %77 to i64
  %82 = getelementptr ptr, ptr %71, i64 %81
  %83 = getelementptr i8, ptr %82, i64 56
  %84 = load ptr, ptr %83, align 8
  %85 = call ptr @behavior_wrapper(ptr %84, { ptr, ptr, ptr, i32 } %78, ptr noundef nonnull align 8 %8)
  %86 = call { ptr, i160 } %85({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull %8) #39
  %.fca.0.extract30 = extractvalue { ptr, i160 } %86, 0
  %.fca.1.extract31 = extractvalue { ptr, i160 } %86, 1
  store ptr @nil_typ, ptr %16, align 8
  %87 = load ptr, ptr %11, align 8
  %88 = load ptr, ptr %10, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %88)
  %90 = load i32, ptr %13, align 8
  %91 = sext i32 %90 to i64
  %92 = getelementptr ptr, ptr %88, i64 %91
  %93 = getelementptr i8, ptr %92, i64 48
  %94 = load ptr, ptr %93, align 8
  %95 = load ptr, ptr %94, align 8
  %96 = call i32 %95(ptr %87) #31
  %97 = add i32 %96, -1
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %88)
  %99 = getelementptr i8, ptr %94, i64 8
  %100 = load ptr, ptr %99, align 8
  call void %100(ptr %87, i32 %97) #30
  br label %.critedge

.critedge:                                        ; preds = %70, %._crit_edge, %20, %7
  %.reg2mem47.sroa.3.0 = phi i160 [ %.fca.1.extract31, %70 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %20 ]
  %.reg2mem45.0 = phi ptr [ %.fca.0.extract30, %70 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %20 ]
  %.reload44.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem45.0, 0
  %.reload44.fca.1.insert = insertvalue { ptr, i160 } %.reload44.fca.0.insert, i160 %.reg2mem47.sroa.3.0, 1
  ret { ptr, i160 } %.reload44.fca.1.insert
}

define void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #3 {
  %6 = alloca [0 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [5 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [3 x ptr], align 8
  %12 = alloca [3 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr }, align 8
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  %15 = alloca [1 x ptr], align 8
  %16 = alloca { ptr }, align 8
  %17 = alloca { ptr, ptr, ptr, i32 }, align 8
  %18 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract34, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %19, i64 8
  store ptr %.fca.1.extract35, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %19, i64 16
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %19, i64 24
  store i32 %.fca.3.extract, ptr %22, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %19, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract29 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract20 = extractvalue { ptr, i160 } %4, 0
  %23 = load ptr, ptr %19, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %23, 0
  %25 = load ptr, ptr %20, align 8
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %25, 1
  %27 = load ptr, ptr %21, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %27, 2
  %29 = load i32, ptr %22, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %29, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %23)
  %32 = sext i32 %29 to i64
  %33 = getelementptr ptr, ptr %23, i64 %32
  %34 = load ptr, ptr %33, align 8
  %35 = call ptr @typegetter_wrapper(ptr %34, ptr %25)
  %36 = alloca [1 x ptr], align 8
  store ptr %35, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %36)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %23)
  %39 = getelementptr i8, ptr %33, i64 88
  %40 = load ptr, ptr %39, align 8
  %41 = alloca { ptr }, align 8
  store ptr %.fca.0.extract29, ptr %41, align 8
  %42 = call ptr @behavior_wrapper(ptr %40, { ptr, ptr, ptr, i32 } %30, ptr noundef nonnull align 8 dereferenceable(8) %41)
  %43 = call i32 %42({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %36, { ptr, i160 } %3) #39
  %44 = load ptr, ptr %19, align 8
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %44, 0
  %46 = load ptr, ptr %20, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %46, 1
  %48 = load ptr, ptr %21, align 8
  %49 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %48, 2
  %50 = load i32, ptr %22, align 8
  %51 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %50, 3
  %52 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %52)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %44)
  %55 = sext i32 %50 to i64
  %56 = getelementptr ptr, ptr %44, i64 %55
  %57 = getelementptr i8, ptr %56, i64 104
  %58 = load ptr, ptr %57, align 8
  %59 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %59, align 8
  %60 = call ptr @behavior_wrapper(ptr %58, { ptr, ptr, ptr, i32 } %51, ptr noundef nonnull align 8 dereferenceable(8) %59)
  %61 = call i32 %60({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull %52, i32 %43) #39
  %62 = load ptr, ptr %20, align 8
  %63 = load ptr, ptr %19, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %63)
  %65 = load i32, ptr %22, align 8
  %66 = sext i32 %65 to i64
  %67 = getelementptr ptr, ptr %63, i64 %66
  %68 = getelementptr i8, ptr %67, i64 24
  %69 = load ptr, ptr %68, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call { ptr } %70(ptr %62) #31
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %63, 0
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %62, 1
  %74 = load ptr, ptr %21, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %74, 2
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, i32 %65, 3
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %63)
  %78 = load ptr, ptr %67, align 8
  %79 = call ptr @typegetter_wrapper(ptr %78, ptr %62)
  %80 = load ptr, ptr %20, align 8
  %81 = load ptr, ptr %19, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %81)
  %83 = load i32, ptr %22, align 8
  %84 = sext i32 %83 to i64
  %85 = getelementptr ptr, ptr %81, i64 %84
  %86 = getelementptr i8, ptr %85, i64 8
  %87 = load ptr, ptr %86, align 8
  %88 = call ptr @typegetter_wrapper(ptr %87, ptr %80)
  %89 = call ptr @bump_malloc(i64 noundef 16)
  %90 = getelementptr i8, ptr %89, i64 8
  store ptr null, ptr %90, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %89)
  store ptr @buffer_typ, ptr %89, align 8
  %92 = alloca [5 x ptr], align 8
  store ptr %79, ptr %92, align 8
  %93 = getelementptr inbounds i8, ptr %92, i64 8
  store ptr %88, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %92, i64 16
  store ptr @_parameterization_i32, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %92, i64 24
  store ptr @_parameterization_i32, ptr %95, align 8
  %96 = getelementptr inbounds i8, ptr %92, i64 32
  store ptr %89, ptr %96, align 8
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %92)
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %63)
  %99 = getelementptr i8, ptr %67, i64 144
  %100 = load ptr, ptr %99, align 8
  %101 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract29, ptr %101, align 8
  %102 = getelementptr inbounds i8, ptr %101, i64 8
  store ptr %.fca.0.extract20, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %101, i64 16
  store ptr @i32_typ, ptr %103, align 8
  %104 = getelementptr inbounds i8, ptr %101, i64 24
  store ptr @i32_typ, ptr %104, align 8
  %105 = getelementptr inbounds i8, ptr %101, i64 32
  store ptr @buffer_typ, ptr %105, align 8
  %106 = call ptr @behavior_wrapper(ptr %100, { ptr, ptr, ptr, i32 } %76, ptr noundef nonnull align 8 dereferenceable(40) %101)
  %107 = call i1 %106({ ptr, ptr, ptr, i32 } %76, { ptr, ptr, ptr, i32 } %76, ptr nonnull %92, { ptr, i160 } %3, { ptr, i160 } %4, i32 %43, i32 %61, { ptr } %71) #39
  br i1 %107, label %.loopexit, label %108

108:                                              ; preds = %5
  %109 = load ptr, ptr %19, align 8
  %110 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %109, 0
  %111 = load ptr, ptr %20, align 8
  %112 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %111, 1
  %113 = load ptr, ptr %21, align 8
  %114 = insertvalue { ptr, ptr, ptr, i32 } %112, ptr %113, 2
  %115 = load i32, ptr %22, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %114, i32 %115, 3
  store ptr @_parameterization_i32, ptr %7, align 8
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %109)
  %119 = sext i32 %115 to i64
  %120 = getelementptr ptr, ptr %109, i64 %119
  %121 = getelementptr i8, ptr %120, i64 112
  %122 = load ptr, ptr %121, align 8
  store ptr @i32_typ, ptr %8, align 8
  %123 = call ptr @behavior_wrapper(ptr %122, { ptr, ptr, ptr, i32 } %116, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %124 = call i32 %123({ ptr, ptr, ptr, i32 } %116, { ptr, ptr, ptr, i32 } %116, ptr nonnull %7, i32 %43) #39
  %125 = load ptr, ptr %20, align 8
  %126 = load ptr, ptr %19, align 8
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %126)
  %128 = load i32, ptr %22, align 8
  %129 = sext i32 %128 to i64
  %130 = getelementptr ptr, ptr %126, i64 %129
  %131 = getelementptr i8, ptr %130, i64 32
  %132 = load ptr, ptr %131, align 8
  %133 = load ptr, ptr %132, align 8
  %134 = call { ptr } %133(ptr %125) #31
  %135 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %126, 0
  %136 = insertvalue { ptr, ptr, ptr, i32 } %135, ptr %125, 1
  %137 = load ptr, ptr %21, align 8
  %138 = insertvalue { ptr, ptr, ptr, i32 } %136, ptr %137, 2
  %139 = insertvalue { ptr, ptr, ptr, i32 } %138, i32 %128, 3
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %126)
  %141 = load ptr, ptr %130, align 8
  %142 = call ptr @typegetter_wrapper(ptr %141, ptr %125)
  %143 = load ptr, ptr %20, align 8
  %144 = load ptr, ptr %19, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %144)
  %146 = load i32, ptr %22, align 8
  %147 = sext i32 %146 to i64
  %148 = getelementptr ptr, ptr %144, i64 %147
  %149 = getelementptr i8, ptr %148, i64 8
  %150 = load ptr, ptr %149, align 8
  %151 = call ptr @typegetter_wrapper(ptr %150, ptr %143)
  %152 = call ptr @bump_malloc(i64 noundef 16)
  %153 = getelementptr i8, ptr %152, i64 8
  store ptr null, ptr %153, align 8
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %152)
  store ptr @buffer_typ, ptr %152, align 8
  store ptr %142, ptr %9, align 8
  %155 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %151, ptr %155, align 8
  %156 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @_parameterization_i32, ptr %156, align 8
  %157 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @_parameterization_i32, ptr %157, align 8
  %158 = getelementptr inbounds i8, ptr %9, i64 32
  store ptr %152, ptr %158, align 8
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %9)
  %160 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %126)
  %161 = getelementptr i8, ptr %130, i64 144
  %162 = load ptr, ptr %161, align 8
  store ptr %.fca.0.extract29, ptr %10, align 8
  %163 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.0.extract20, ptr %163, align 8
  %164 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @i32_typ, ptr %164, align 8
  %165 = getelementptr inbounds i8, ptr %10, i64 24
  store ptr @i32_typ, ptr %165, align 8
  %166 = getelementptr inbounds i8, ptr %10, i64 32
  store ptr @buffer_typ, ptr %166, align 8
  %167 = call ptr @behavior_wrapper(ptr %162, { ptr, ptr, ptr, i32 } %139, ptr noundef nonnull align 8 dereferenceable(40) %10)
  %168 = call i1 %167({ ptr, ptr, ptr, i32 } %139, { ptr, ptr, ptr, i32 } %139, ptr nonnull %9, { ptr, i160 } %3, { ptr, i160 } %4, i32 %43, i32 %124, { ptr } %134) #39
  br i1 %168, label %.loopexit, label %169

169:                                              ; preds = %108
  %170 = load ptr, ptr %20, align 8
  %171 = load ptr, ptr %19, align 8
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %171)
  %173 = load i32, ptr %22, align 8
  %174 = sext i32 %173 to i64
  %175 = getelementptr ptr, ptr %171, i64 %174
  %176 = getelementptr i8, ptr %175, i64 48
  %177 = load ptr, ptr %176, align 8
  %178 = load ptr, ptr %177, align 8
  %179 = call i32 %178(ptr %170) #31
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %171)
  %181 = getelementptr i8, ptr %175, i64 40
  %182 = load ptr, ptr %181, align 8
  %183 = load ptr, ptr %182, align 8
  %184 = call i32 %183(ptr %170) #31
  %.not = icmp slt i32 %179, %184
  br i1 %.not, label %._crit_edge, label %185

185:                                              ; preds = %169
  %186 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %171, 0
  %187 = insertvalue { ptr, ptr, ptr, i32 } %186, ptr %170, 1
  %188 = load ptr, ptr %21, align 8
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, ptr %188, 2
  %190 = insertvalue { ptr, ptr, ptr, i32 } %189, i32 %173, 3
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %171)
  %193 = getelementptr i8, ptr %175, i64 136
  %194 = load ptr, ptr %193, align 8
  %195 = call ptr @behavior_wrapper(ptr %194, { ptr, ptr, ptr, i32 } %190, ptr noundef nonnull align 8 %6)
  call void %195({ ptr, ptr, ptr, i32 } %190, { ptr, ptr, ptr, i32 } %190, ptr nonnull %6) #39
  br label %._crit_edge

._crit_edge:                                      ; preds = %185, %169
  %196 = load ptr, ptr %20, align 8
  %197 = load ptr, ptr %19, align 8
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %197)
  %199 = load i32, ptr %22, align 8
  %200 = sext i32 %199 to i64
  %201 = getelementptr ptr, ptr %197, i64 %200
  %202 = load ptr, ptr %201, align 8
  %203 = call ptr @typegetter_wrapper(ptr %202, ptr %196)
  %204 = load ptr, ptr %20, align 8
  %205 = load ptr, ptr %19, align 8
  %206 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %205)
  %207 = load i32, ptr %22, align 8
  %208 = sext i32 %207 to i64
  %209 = getelementptr ptr, ptr %205, i64 %208
  %210 = getelementptr i8, ptr %209, i64 8
  %211 = load ptr, ptr %210, align 8
  %212 = call ptr @typegetter_wrapper(ptr %211, ptr %204)
  store ptr @Entry, ptr %11, align 8
  %213 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr %203, ptr %213, align 8
  %214 = getelementptr inbounds i8, ptr %11, i64 16
  store ptr %212, ptr %214, align 8
  %215 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_Entry, ptr noundef nonnull align 8 dereferenceable(24) %11)
  %216 = extractvalue { i64, i64 } %215, 0
  %217 = call ptr @bump_malloc(i64 %216)
  store ptr %203, ptr %217, align 8
  %218 = getelementptr i8, ptr %217, i64 8
  store ptr %212, ptr %218, align 8
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %217)
  %220 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %217, 1
  %221 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr undef, 2
  %222 = insertvalue { ptr, ptr, ptr, i32 } %221, i32 10, 3
  %223 = load ptr, ptr %20, align 8
  %224 = load ptr, ptr %19, align 8
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %224)
  %226 = load i32, ptr %22, align 8
  %227 = sext i32 %226 to i64
  %228 = getelementptr ptr, ptr %224, i64 %227
  %229 = load ptr, ptr %228, align 8
  %230 = call ptr @typegetter_wrapper(ptr %229, ptr %223)
  %231 = load ptr, ptr %20, align 8
  %232 = load ptr, ptr %19, align 8
  %233 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %232)
  %234 = load i32, ptr %22, align 8
  %235 = sext i32 %234 to i64
  %236 = getelementptr ptr, ptr %232, i64 %235
  %237 = getelementptr i8, ptr %236, i64 8
  %238 = load ptr, ptr %237, align 8
  %239 = call ptr @typegetter_wrapper(ptr %238, ptr %231)
  store ptr %230, ptr %12, align 8
  %240 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %239, ptr %240, align 8
  %241 = getelementptr inbounds i8, ptr %12, i64 16
  store ptr @_parameterization_i32, ptr %241, align 8
  %242 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %12)
  %243 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull align 16 dereferenceable(200) @Entry)
  store ptr %.fca.0.extract29, ptr %13, align 8
  %244 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.0.extract20, ptr %244, align 8
  %245 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr @i32_typ, ptr %245, align 8
  %246 = call ptr @behavior_wrapper(ptr noundef nonnull @Entry_B_init_keyK_valueV_primary_hashi32, { ptr, ptr, ptr, i32 } %222, ptr noundef nonnull align 8 dereferenceable(24) %13)
  call void %246({ ptr, ptr, ptr, i32 } %222, { ptr, ptr, ptr, i32 } %222, ptr nonnull %12, { ptr, i160 } %3, { ptr, i160 } %4, i32 %43) #39
  %247 = getelementptr inbounds i8, ptr %14, i64 8
  %248 = getelementptr inbounds i8, ptr %14, i64 16
  %249 = getelementptr inbounds i8, ptr %14, i64 24
  %250 = getelementptr inbounds i8, ptr %17, i64 8
  %251 = getelementptr inbounds i8, ptr %18, i64 8
  %252 = getelementptr inbounds i8, ptr %17, i64 16
  %253 = getelementptr inbounds i8, ptr %18, i64 16
  %254 = getelementptr inbounds i8, ptr %17, i64 24
  %255 = getelementptr inbounds i8, ptr %18, i64 24
  br label %256

256:                                              ; preds = %326, %._crit_edge
  %.093 = phi i32 [ 0, %._crit_edge ], [ %.295, %326 ]
  %.089 = phi ptr [ @Entry, %._crit_edge ], [ %.392, %326 ]
  %.085 = phi ptr [ %217, %._crit_edge ], [ %.388, %326 ]
  %.081 = phi ptr [ undef, %._crit_edge ], [ %.384, %326 ]
  %.0 = phi i32 [ 10, %._crit_edge ], [ %.3, %326 ]
  %257 = icmp slt i32 %.093, 2
  br i1 %257, label %258, label %326

258:                                              ; preds = %256
  store ptr %.089, ptr %14, align 8
  store ptr %.085, ptr %247, align 8
  store ptr %.081, ptr %248, align 8
  store i32 %.0, ptr %249, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %14, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %259 = load ptr, ptr %14, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %259, 0
  %261 = load ptr, ptr %247, align 8
  %262 = insertvalue { ptr, ptr, ptr, i32 } %260, ptr %261, 1
  %263 = load ptr, ptr %248, align 8
  %264 = insertvalue { ptr, ptr, ptr, i32 } %262, ptr %263, 2
  %265 = load i32, ptr %249, align 8
  %266 = insertvalue { ptr, ptr, ptr, i32 } %264, i32 %265, 3
  %267 = load ptr, ptr %19, align 8
  %268 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %267, 0
  %269 = load ptr, ptr %20, align 8
  %270 = insertvalue { ptr, ptr, ptr, i32 } %268, ptr %269, 1
  %271 = load ptr, ptr %21, align 8
  %272 = insertvalue { ptr, ptr, ptr, i32 } %270, ptr %271, 2
  %273 = load i32, ptr %22, align 8
  %274 = insertvalue { ptr, ptr, ptr, i32 } %272, i32 %273, 3
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %267)
  %276 = sext i32 %273 to i64
  %277 = getelementptr ptr, ptr %267, i64 %276
  %278 = load ptr, ptr %277, align 8
  %279 = call ptr @typegetter_wrapper(ptr %278, ptr %269)
  %280 = load ptr, ptr %20, align 8
  %281 = load ptr, ptr %19, align 8
  %282 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %281)
  %283 = load i32, ptr %22, align 8
  %284 = sext i32 %283 to i64
  %285 = getelementptr ptr, ptr %281, i64 %284
  %286 = getelementptr i8, ptr %285, i64 8
  %287 = load ptr, ptr %286, align 8
  %288 = call ptr @typegetter_wrapper(ptr %287, ptr %280)
  %289 = call ptr @bump_malloc(i64 noundef 32)
  %290 = getelementptr i8, ptr %289, i64 16
  store ptr %288, ptr %290, align 8
  %291 = getelementptr i8, ptr %289, i64 8
  store ptr %279, ptr %291, align 8
  %292 = getelementptr i8, ptr %289, i64 24
  store ptr null, ptr %292, align 8
  %293 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %289)
  store ptr @Entry, ptr %289, align 8
  store ptr %289, ptr %15, align 8
  %294 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %15)
  %295 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %267)
  %296 = getelementptr i8, ptr %277, i64 120
  %297 = load ptr, ptr %296, align 8
  store ptr %259, ptr %16, align 8
  %298 = call ptr @behavior_wrapper(ptr %297, { ptr, ptr, ptr, i32 } %274, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %299 = call { ptr, i160 } %298({ ptr, ptr, ptr, i32 } %274, { ptr, ptr, ptr, i32 } %274, ptr nonnull %15, { ptr, ptr, ptr, i32 } %266) #39
  %.fca.0.extract42 = extractvalue { ptr, i160 } %299, 0
  %300 = icmp ne ptr %.fca.0.extract42, @nil_typ
  %301 = icmp ne ptr %.fca.0.extract42, null
  %.not98 = and i1 %300, %301
  br i1 %.not98, label %._crit_edge1, label %326

._crit_edge1:                                     ; preds = %258
  %.fca.1.extract43 = extractvalue { ptr, i160 } %299, 1
  %302 = load ptr, ptr %19, align 8
  %303 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %302, 0
  %304 = load ptr, ptr %20, align 8
  %305 = insertvalue { ptr, ptr, ptr, i32 } %303, ptr %304, 1
  %306 = load ptr, ptr %21, align 8
  %307 = insertvalue { ptr, ptr, ptr, i32 } %305, ptr %306, 2
  %308 = load i32, ptr %22, align 8
  %309 = insertvalue { ptr, ptr, ptr, i32 } %307, i32 %308, 3
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %311 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %302)
  %312 = sext i32 %308 to i64
  %313 = getelementptr ptr, ptr %302, i64 %312
  %314 = getelementptr i8, ptr %313, i64 136
  %315 = load ptr, ptr %314, align 8
  %316 = call ptr @behavior_wrapper(ptr %315, { ptr, ptr, ptr, i32 } %309, ptr noundef nonnull align 8 %6)
  call void %316({ ptr, ptr, ptr, i32 } %309, { ptr, ptr, ptr, i32 } %309, ptr nonnull %6) #39
  store ptr %.fca.0.extract42, ptr %17, align 8
  store i160 %.fca.1.extract43, ptr %250, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %17, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %317 = load ptr, ptr %17, align 8
  store ptr %317, ptr %18, align 8
  %318 = load ptr, ptr %250, align 8
  store ptr %318, ptr %251, align 8
  %319 = load ptr, ptr %252, align 8
  store ptr %319, ptr %253, align 8
  %320 = load i32, ptr %254, align 8
  store i32 %320, ptr %255, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %18, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %321 = load i32, ptr %255, align 8
  %322 = load ptr, ptr %253, align 8
  %323 = load ptr, ptr %251, align 8
  %324 = load ptr, ptr %18, align 8
  %325 = add nsw i32 %.093, 1
  br label %326

326:                                              ; preds = %._crit_edge1, %258, %256
  %.reg2mem75.0.off0 = phi i1 [ false, %258 ], [ true, %._crit_edge1 ], [ false, %256 ]
  %.295 = phi i32 [ %.093, %258 ], [ %325, %._crit_edge1 ], [ %.093, %256 ]
  %.392 = phi ptr [ %.089, %258 ], [ %324, %._crit_edge1 ], [ %.089, %256 ]
  %.388 = phi ptr [ %.085, %258 ], [ %323, %._crit_edge1 ], [ %.085, %256 ]
  %.384 = phi ptr [ %.081, %258 ], [ %322, %._crit_edge1 ], [ %.081, %256 ]
  %.3 = phi i32 [ %.0, %258 ], [ %321, %._crit_edge1 ], [ %.0, %256 ]
  br i1 %.reg2mem75.0.off0, label %256, label %.loopexit

.loopexit:                                        ; preds = %326, %108, %5
  ret void
}

define i32 @CuckooMap_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 48
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  ret i32 %17
}

define { ptr, i160 } @CuckooMap_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %13 = load ptr, ptr %9, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %15 = load ptr, ptr %10, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %15, 1
  %17 = load ptr, ptr %11, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %17, 2
  %19 = load i32, ptr %12, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %19, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %13)
  %22 = sext i32 %19 to i64
  %23 = getelementptr ptr, ptr %13, i64 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %15)
  %26 = alloca [1 x ptr], align 8
  store ptr %25, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %13)
  %29 = getelementptr i8, ptr %23, i64 88
  %30 = load ptr, ptr %29, align 8
  %31 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %31, align 8
  %32 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %33 = call i32 %32({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %26, { ptr, i160 } %3) #39
  %34 = load ptr, ptr %9, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %34, 0
  %36 = load ptr, ptr %10, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 1
  %38 = load ptr, ptr %11, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 2
  %40 = load i32, ptr %12, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %40, 3
  %42 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %34)
  %45 = sext i32 %40 to i64
  %46 = getelementptr ptr, ptr %34, i64 %45
  %47 = getelementptr i8, ptr %46, i64 104
  %48 = load ptr, ptr %47, align 8
  %49 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %49, align 8
  %50 = call ptr @behavior_wrapper(ptr %48, { ptr, ptr, ptr, i32 } %41, ptr noundef nonnull align 8 dereferenceable(8) %49)
  %51 = call i32 %50({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull %42, i32 %33) #39
  %52 = load ptr, ptr %10, align 8
  %53 = load ptr, ptr %9, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %12, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 24
  %59 = load ptr, ptr %58, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr } %60(ptr %52) #31
  %62 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %53, 0
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %52, 1
  %64 = load ptr, ptr %11, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 2
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %55, 3
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %53)
  %68 = load ptr, ptr %57, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %52)
  %70 = call ptr @bump_malloc(i64 noundef 16)
  %71 = getelementptr i8, ptr %70, i64 8
  store ptr null, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %70)
  store ptr @buffer_typ, ptr %70, align 8
  %73 = alloca [4 x ptr], align 8
  store ptr %69, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %73, i64 8
  store ptr @_parameterization_i32, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %73, i64 16
  store ptr @_parameterization_i32, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %73, i64 24
  store ptr %70, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %73)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %53)
  %79 = getelementptr i8, ptr %57, i64 152
  %80 = load ptr, ptr %79, align 8
  %81 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %81, i64 8
  store ptr @i32_typ, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %81, i64 16
  store ptr @i32_typ, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %81, i64 24
  store ptr @buffer_typ, ptr %84, align 8
  %85 = call ptr @behavior_wrapper(ptr %80, { ptr, ptr, ptr, i32 } %66, ptr noundef nonnull align 8 dereferenceable(32) %81)
  %86 = call { ptr, i160 } %85({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr nonnull %73, { ptr, i160 } %3, i32 %33, i32 %51, { ptr } %61) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %86, 0
  %87 = load ptr, ptr %10, align 8
  %88 = load ptr, ptr %9, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %88)
  %90 = load i32, ptr %12, align 8
  %91 = sext i32 %90 to i64
  %92 = getelementptr ptr, ptr %88, i64 %91
  %93 = getelementptr i8, ptr %92, i64 8
  %94 = load ptr, ptr %93, align 8
  %95 = call ptr @typegetter_wrapper(ptr %94, ptr %87)
  %96 = icmp ne ptr %.fca.0.extract, @nil_typ
  %97 = icmp ne ptr %.fca.0.extract, null
  %.not63 = and i1 %96, %97
  br i1 %.not63, label %158, label %98

98:                                               ; preds = %4
  %99 = load ptr, ptr %9, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %99, 0
  %101 = load ptr, ptr %10, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 1
  %103 = load ptr, ptr %11, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 2
  %105 = load i32, ptr %12, align 8
  %106 = insertvalue { ptr, ptr, ptr, i32 } %104, i32 %105, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %99)
  %109 = sext i32 %105 to i64
  %110 = getelementptr ptr, ptr %99, i64 %109
  %111 = getelementptr i8, ptr %110, i64 112
  %112 = load ptr, ptr %111, align 8
  store ptr @i32_typ, ptr %6, align 8
  %113 = call ptr @behavior_wrapper(ptr %112, { ptr, ptr, ptr, i32 } %106, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %114 = call i32 %113({ ptr, ptr, ptr, i32 } %106, { ptr, ptr, ptr, i32 } %106, ptr nonnull %5, i32 %33) #39
  %115 = load ptr, ptr %10, align 8
  %116 = load ptr, ptr %9, align 8
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %116)
  %118 = load i32, ptr %12, align 8
  %119 = sext i32 %118 to i64
  %120 = getelementptr ptr, ptr %116, i64 %119
  %121 = getelementptr i8, ptr %120, i64 32
  %122 = load ptr, ptr %121, align 8
  %123 = load ptr, ptr %122, align 8
  %124 = call { ptr } %123(ptr %115) #31
  %125 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %116, 0
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, ptr %115, 1
  %127 = load ptr, ptr %11, align 8
  %128 = insertvalue { ptr, ptr, ptr, i32 } %126, ptr %127, 2
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, i32 %118, 3
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %116)
  %131 = load ptr, ptr %120, align 8
  %132 = call ptr @typegetter_wrapper(ptr %131, ptr %115)
  %133 = call ptr @bump_malloc(i64 noundef 16)
  %134 = getelementptr i8, ptr %133, i64 8
  store ptr null, ptr %134, align 8
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %133)
  store ptr @buffer_typ, ptr %133, align 8
  store ptr %132, ptr %7, align 8
  %136 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %136, align 8
  %137 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %137, align 8
  %138 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %133, ptr %138, align 8
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %116)
  %141 = getelementptr i8, ptr %120, i64 152
  %142 = load ptr, ptr %141, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %143 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %143, align 8
  %144 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %145, align 8
  %146 = call ptr @behavior_wrapper(ptr %142, { ptr, ptr, ptr, i32 } %129, ptr noundef nonnull align 8 dereferenceable(32) %8)
  %147 = call { ptr, i160 } %146({ ptr, ptr, ptr, i32 } %129, { ptr, ptr, ptr, i32 } %129, ptr nonnull %7, { ptr, i160 } %3, i32 %33, i32 %114, { ptr } %124) #39
  %.fca.0.extract51 = extractvalue { ptr, i160 } %147, 0
  %.fca.1.extract52 = extractvalue { ptr, i160 } %147, 1
  %148 = load ptr, ptr %10, align 8
  %149 = load ptr, ptr %9, align 8
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %149)
  %151 = load i32, ptr %12, align 8
  %152 = sext i32 %151 to i64
  %153 = getelementptr ptr, ptr %149, i64 %152
  %154 = getelementptr i8, ptr %153, i64 8
  %155 = load ptr, ptr %154, align 8
  %156 = call ptr @typegetter_wrapper(ptr %155, ptr %148)
  %.not = icmp eq ptr %.fca.0.extract51, null
  %157 = select i1 %.not, ptr @nil_typ, ptr %.fca.0.extract51
  br label %158

158:                                              ; preds = %98, %4
  %.reg2mem56.0 = phi ptr [ %157, %98 ], [ %.fca.0.extract, %4 ]
  %.sroa.354.0 = phi i160 [ %.fca.1.extract52, %98 ], [ undef, %4 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %86, 1
  %.fca.1.extract..sroa.354.0 = select i1 %.not63, i160 %.fca.1.extract, i160 %.sroa.354.0
  %.reload55.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem56.0, 0
  %.reload55.fca.1.insert = insertvalue { ptr, i160 } %.reload55.fca.0.insert, i160 %.fca.1.extract..sroa.354.0, 1
  ret { ptr, i160 } %.reload55.fca.1.insert
}

define void @CuckooMap__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %.fca.1.extract12, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %.fca.3.extract, ptr %9, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract7 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %10 = load ptr, ptr %6, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %10, 0
  %12 = load ptr, ptr %7, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %12, 1
  %14 = load ptr, ptr %8, align 8
  %15 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %14, 2
  %16 = load i32, ptr %9, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %16, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %10)
  %19 = sext i32 %16 to i64
  %20 = getelementptr ptr, ptr %10, i64 %19
  %21 = load ptr, ptr %20, align 8
  %22 = call ptr @typegetter_wrapper(ptr %21, ptr %12)
  %23 = load ptr, ptr %7, align 8
  %24 = load ptr, ptr %6, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %24)
  %26 = load i32, ptr %9, align 8
  %27 = sext i32 %26 to i64
  %28 = getelementptr ptr, ptr %24, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = call ptr @typegetter_wrapper(ptr %30, ptr %23)
  %32 = alloca [2 x ptr], align 8
  store ptr %22, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %32, i64 8
  store ptr %31, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %32)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %10)
  %36 = getelementptr i8, ptr %20, i64 168
  %37 = load ptr, ptr %36, align 8
  %38 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract7, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr %.fca.0.extract, ptr %39, align 8
  %40 = call ptr @behavior_wrapper(ptr %37, { ptr, ptr, ptr, i32 } %17, ptr noundef nonnull align 8 dereferenceable(16) %38)
  call void %40({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull %32, { ptr, i160 } %3, { ptr, i160 } %4) #39
  ret void
}

define { ptr, i160 } @CuckooMap_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract31, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %13 = load ptr, ptr %9, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %15 = load ptr, ptr %10, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %15, 1
  %17 = load ptr, ptr %11, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %17, 2
  %19 = load i32, ptr %12, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %19, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %13)
  %22 = sext i32 %19 to i64
  %23 = getelementptr ptr, ptr %13, i64 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %15)
  %26 = alloca [1 x ptr], align 8
  store ptr %25, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %26)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %13)
  %29 = getelementptr i8, ptr %23, i64 88
  %30 = load ptr, ptr %29, align 8
  %31 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %31, align 8
  %32 = call ptr @behavior_wrapper(ptr %30, { ptr, ptr, ptr, i32 } %20, ptr noundef nonnull align 8 dereferenceable(8) %31)
  %33 = call i32 %32({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %26, { ptr, i160 } %3) #39
  %34 = load ptr, ptr %9, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %34, 0
  %36 = load ptr, ptr %10, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 1
  %38 = load ptr, ptr %11, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 2
  %40 = load i32, ptr %12, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %40, 3
  %42 = alloca [1 x ptr], align 8
  store ptr @_parameterization_i32, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %34)
  %45 = sext i32 %40 to i64
  %46 = getelementptr ptr, ptr %34, i64 %45
  %47 = getelementptr i8, ptr %46, i64 104
  %48 = load ptr, ptr %47, align 8
  %49 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %49, align 8
  %50 = call ptr @behavior_wrapper(ptr %48, { ptr, ptr, ptr, i32 } %41, ptr noundef nonnull align 8 dereferenceable(8) %49)
  %51 = call i32 %50({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull %42, i32 %33) #39
  %52 = load ptr, ptr %10, align 8
  %53 = load ptr, ptr %9, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %53)
  %55 = load i32, ptr %12, align 8
  %56 = sext i32 %55 to i64
  %57 = getelementptr ptr, ptr %53, i64 %56
  %58 = getelementptr i8, ptr %57, i64 24
  %59 = load ptr, ptr %58, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr } %60(ptr %52) #31
  %62 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %53, 0
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %52, 1
  %64 = load ptr, ptr %11, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %64, 2
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %55, 3
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %53)
  %68 = load ptr, ptr %57, align 8
  %69 = call ptr @typegetter_wrapper(ptr %68, ptr %52)
  %70 = call ptr @bump_malloc(i64 noundef 16)
  %71 = getelementptr i8, ptr %70, i64 8
  store ptr null, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %70)
  store ptr @buffer_typ, ptr %70, align 8
  %73 = alloca [4 x ptr], align 8
  store ptr %69, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %73, i64 8
  store ptr @_parameterization_i32, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %73, i64 16
  store ptr @_parameterization_i32, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %73, i64 24
  store ptr %70, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %73)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %53)
  %79 = getelementptr i8, ptr %57, i64 160
  %80 = load ptr, ptr %79, align 8
  %81 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %81, i64 8
  store ptr @i32_typ, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %81, i64 16
  store ptr @i32_typ, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %81, i64 24
  store ptr @buffer_typ, ptr %84, align 8
  %85 = call ptr @behavior_wrapper(ptr %80, { ptr, ptr, ptr, i32 } %66, ptr noundef nonnull align 8 dereferenceable(32) %81)
  %86 = call { ptr, i160 } %85({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr nonnull %73, { ptr, i160 } %3, i32 %33, i32 %51, { ptr } %61) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %86, 0
  %87 = load ptr, ptr %10, align 8
  %88 = load ptr, ptr %9, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %88)
  %90 = load i32, ptr %12, align 8
  %91 = sext i32 %90 to i64
  %92 = getelementptr ptr, ptr %88, i64 %91
  %93 = getelementptr i8, ptr %92, i64 8
  %94 = load ptr, ptr %93, align 8
  %95 = call ptr @typegetter_wrapper(ptr %94, ptr %87)
  %96 = icmp ne ptr %.fca.0.extract, @nil_typ
  %97 = icmp ne ptr %.fca.0.extract, null
  %.not63 = and i1 %96, %97
  br i1 %.not63, label %158, label %98

98:                                               ; preds = %4
  %99 = load ptr, ptr %9, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %99, 0
  %101 = load ptr, ptr %10, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 1
  %103 = load ptr, ptr %11, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 2
  %105 = load i32, ptr %12, align 8
  %106 = insertvalue { ptr, ptr, ptr, i32 } %104, i32 %105, 3
  store ptr @_parameterization_i32, ptr %5, align 8
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %99)
  %109 = sext i32 %105 to i64
  %110 = getelementptr ptr, ptr %99, i64 %109
  %111 = getelementptr i8, ptr %110, i64 112
  %112 = load ptr, ptr %111, align 8
  store ptr @i32_typ, ptr %6, align 8
  %113 = call ptr @behavior_wrapper(ptr %112, { ptr, ptr, ptr, i32 } %106, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %114 = call i32 %113({ ptr, ptr, ptr, i32 } %106, { ptr, ptr, ptr, i32 } %106, ptr nonnull %5, i32 %33) #39
  %115 = load ptr, ptr %10, align 8
  %116 = load ptr, ptr %9, align 8
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %116)
  %118 = load i32, ptr %12, align 8
  %119 = sext i32 %118 to i64
  %120 = getelementptr ptr, ptr %116, i64 %119
  %121 = getelementptr i8, ptr %120, i64 32
  %122 = load ptr, ptr %121, align 8
  %123 = load ptr, ptr %122, align 8
  %124 = call { ptr } %123(ptr %115) #31
  %125 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %116, 0
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, ptr %115, 1
  %127 = load ptr, ptr %11, align 8
  %128 = insertvalue { ptr, ptr, ptr, i32 } %126, ptr %127, 2
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, i32 %118, 3
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %116)
  %131 = load ptr, ptr %120, align 8
  %132 = call ptr @typegetter_wrapper(ptr %131, ptr %115)
  %133 = call ptr @bump_malloc(i64 noundef 16)
  %134 = getelementptr i8, ptr %133, i64 8
  store ptr null, ptr %134, align 8
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %133)
  store ptr @buffer_typ, ptr %133, align 8
  store ptr %132, ptr %7, align 8
  %136 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_i32, ptr %136, align 8
  %137 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_i32, ptr %137, align 8
  %138 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %133, ptr %138, align 8
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %116)
  %141 = getelementptr i8, ptr %120, i64 160
  %142 = load ptr, ptr %141, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %143 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %143, align 8
  %144 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %145, align 8
  %146 = call ptr @behavior_wrapper(ptr %142, { ptr, ptr, ptr, i32 } %129, ptr noundef nonnull align 8 dereferenceable(32) %8)
  %147 = call { ptr, i160 } %146({ ptr, ptr, ptr, i32 } %129, { ptr, ptr, ptr, i32 } %129, ptr nonnull %7, { ptr, i160 } %3, i32 %33, i32 %114, { ptr } %124) #39
  %.fca.0.extract51 = extractvalue { ptr, i160 } %147, 0
  %.fca.1.extract52 = extractvalue { ptr, i160 } %147, 1
  %148 = load ptr, ptr %10, align 8
  %149 = load ptr, ptr %9, align 8
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %149)
  %151 = load i32, ptr %12, align 8
  %152 = sext i32 %151 to i64
  %153 = getelementptr ptr, ptr %149, i64 %152
  %154 = getelementptr i8, ptr %153, i64 8
  %155 = load ptr, ptr %154, align 8
  %156 = call ptr @typegetter_wrapper(ptr %155, ptr %148)
  %.not = icmp eq ptr %.fca.0.extract51, null
  %157 = select i1 %.not, ptr @nil_typ, ptr %.fca.0.extract51
  br label %158

158:                                              ; preds = %98, %4
  %.reg2mem56.0 = phi ptr [ %157, %98 ], [ %.fca.0.extract, %4 ]
  %.sroa.354.0 = phi i160 [ %.fca.1.extract52, %98 ], [ undef, %4 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %86, 1
  %.fca.1.extract..sroa.354.0 = select i1 %.not63, i160 %.fca.1.extract, i160 %.sroa.354.0
  %.reload55.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem56.0, 0
  %.reload55.fca.1.insert = insertvalue { ptr, i160 } %.reload55.fca.0.insert, i160 %.fca.1.extract..sroa.354.0, 1
  ret { ptr, i160 } %.reload55.fca.1.insert
}

define void @CuckooMap_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 40
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  call void %17(ptr %8, i32 8) #30
  %18 = call ptr @bump_malloc(i64 noundef 256)
  %19 = load ptr, ptr %5, align 8
  %20 = load ptr, ptr %4, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %20)
  %22 = load i32, ptr %7, align 8
  %23 = sext i32 %22 to i64
  %24 = getelementptr ptr, ptr %20, i64 %23
  %25 = getelementptr i8, ptr %24, i64 24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %18, 0
  call void %28(ptr %19, { ptr } %29) #30
  %30 = call ptr @bump_malloc(i64 noundef 256)
  %31 = load ptr, ptr %5, align 8
  %32 = load ptr, ptr %4, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %32)
  %34 = load i32, ptr %7, align 8
  %35 = sext i32 %34 to i64
  %36 = getelementptr ptr, ptr %32, i64 %35
  %37 = getelementptr i8, ptr %36, i64 32
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %41 = insertvalue { ptr } undef, ptr %30, 0
  call void %40(ptr %31, { ptr } %41) #30
  %42 = load ptr, ptr %5, align 8
  %43 = load ptr, ptr %4, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %43)
  %45 = load i32, ptr %7, align 8
  %46 = sext i32 %45 to i64
  %47 = getelementptr ptr, ptr %43, i64 %46
  %48 = getelementptr i8, ptr %47, i64 48
  %49 = load ptr, ptr %48, align 8
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  call void %51(ptr %42, i32 0) #30
  ret void
}

define { ptr, i160 } @Map__index_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca [3 x ptr], align 8
  %9 = alloca { ptr, ptr, ptr }, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract11, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %13, i64 8
  store ptr %.fca.1.extract12, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %13, i64 16
  store ptr %.fca.2.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %13, i64 24
  store i32 %.fca.3.extract, ptr %16, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %13, ptr noundef nonnull align 16 dereferenceable(80) @Map)
  %.fca.0.extract6 = extractvalue { ptr, i160 } %3, 0
  %17 = load ptr, ptr %13, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %17, 0
  %19 = load ptr, ptr %14, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %19, 1
  %21 = load ptr, ptr %15, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 2
  %23 = load i32, ptr %16, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %23, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 512, ptr nocapture nofree noundef %17)
  %26 = sext i32 %23 to i64
  %27 = getelementptr ptr, ptr %17, i64 %26
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr @typegetter_wrapper(ptr %28, ptr %19)
  %30 = alloca [1 x ptr], align 8
  store ptr %29, ptr %30, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %30)
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 512, ptr nocapture nofree noundef %17)
  %33 = getelementptr i8, ptr %27, i64 32
  %34 = load ptr, ptr %33, align 8
  %35 = alloca { ptr }, align 8
  store ptr %.fca.0.extract6, ptr %35, align 8
  %36 = call ptr @behavior_wrapper(ptr %34, { ptr, ptr, ptr, i32 } %24, ptr noundef nonnull align 8 dereferenceable(8) %35)
  %37 = call { ptr, i160 } %36({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull %30, { ptr, i160 } %3) #39
  %.fca.0.extract = extractvalue { ptr, i160 } %37, 0
  %38 = icmp eq ptr %.fca.0.extract, @nil_typ
  %39 = icmp eq ptr %.fca.0.extract, null
  %40 = or i1 %38, %39
  br i1 %40, label %41, label %._crit_edge

41:                                               ; preds = %4
  store ptr @KeyNotFound, ptr %6, align 8
  %42 = call { i64, i64 } @size_wrapper(ptr noundef nonnull @_data_size_KeyNotFound, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %43 = extractvalue { i64, i64 } %42, 0
  %44 = call ptr @bump_malloc(i64 %43)
  %45 = insertvalue { ptr, ptr, ptr, i32 } { ptr @KeyNotFound, ptr undef, ptr undef, i32 undef }, ptr %44, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr undef, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 10, 3
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 272, ptr nocapture nofree noundef nonnull align 16 dereferenceable(352) @KeyNotFound)
  %50 = call ptr @behavior_wrapper(ptr noundef nonnull @KeyNotFound_B_init_, { ptr, ptr, ptr, i32 } %47, ptr noundef nonnull align 8 %5)
  call void %50({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull %5) #39
  %51 = call ptr @bump_malloc(i64 noundef 55)
  %52 = load <54 x i8>, ptr @fsifx_CUsersPaulKOneDriveDocumentsPLPyPLlibmapmini, align 64
  store <54 x i8> %52, ptr %51, align 1
  store ptr @String, ptr %7, align 8
  %53 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 48), align 8
  %54 = call { i64, i64 } @size_wrapper(ptr %53, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %55 = extractvalue { i64, i64 } %54, 0
  %56 = call ptr @bump_malloc(i64 %55)
  %57 = insertvalue { ptr } undef, ptr %51, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %56, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr undef, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 10, 3
  store ptr @_parameterization_Bufferi8, ptr %8, align 8
  %61 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @_parameterization_i32, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @_parameterization_i32, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %8)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 1192, ptr nocapture nofree noundef nonnull align 8 dereferenceable(1248) @String)
  %65 = load ptr, ptr getelementptr inbounds (i8, ptr @String, i64 136), align 8
  store ptr @buffer_typ, ptr %9, align 8
  %66 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr @i32_typ, ptr %66, align 8
  %67 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @i32_typ, ptr %67, align 8
  %68 = call ptr @behavior_wrapper(ptr %65, { ptr, ptr, ptr, i32 } %60, ptr noundef nonnull align 8 dereferenceable(24) %9)
  call void %68({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull %8, { ptr } %57, i32 54, i32 55) #39
  store ptr @String, ptr %10, align 8
  %69 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %56, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %10, i64 16
  %71 = getelementptr inbounds i8, ptr %10, i64 24
  store i32 10, ptr %71, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %10, ptr noundef nonnull align 8 dereferenceable(1248) @String)
  %72 = load ptr, ptr %10, align 8
  %73 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %72, 0
  %74 = load ptr, ptr %69, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %74, 1
  %76 = load ptr, ptr %70, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %76, 2
  %78 = load i32, ptr %71, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, i32 %78, 3
  store ptr @_parameterization_i32, ptr %11, align 8
  %80 = getelementptr inbounds i8, ptr %11, i64 8
  store ptr @_parameterization_String, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %11)
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 272, ptr nocapture nofree noundef nonnull align 16 dereferenceable(352) @KeyNotFound)
  store ptr @i32_typ, ptr %12, align 8
  %83 = getelementptr inbounds i8, ptr %12, i64 8
  store ptr %72, ptr %83, align 8
  %84 = call ptr @behavior_wrapper(ptr noundef nonnull @KeyNotFound_B_set_info_line_numberi32_file_nameString, { ptr, ptr, ptr, i32 } %47, ptr noundef nonnull align 8 dereferenceable(16) %12)
  call void %84({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull %11, i32 14, { ptr, ptr, ptr, i32 } %79) #39
  %85 = ptrtoint ptr %44 to i64
  %.sroa.449.8.insert.ext = zext i64 %85 to i160
  %.sroa.449.8.insert.insert = or disjoint i160 %.sroa.449.8.insert.ext, 3402823669209384634633746074317682114560
  %86 = call ptr @get_current_coroutine()
  %87 = getelementptr i8, ptr %86, i64 48
  store ptr @KeyNotFound, ptr %87, align 8
  %88 = getelementptr i8, ptr %86, i64 56
  store i160 %.sroa.449.8.insert.insert, ptr %88, align 4
  call void @coroutine_yield_cold(ptr noundef align 8 %86)
  br label %._crit_edge

._crit_edge:                                      ; preds = %41, %4
  %.sroa.0.0 = phi ptr [ @nil_typ, %41 ], [ %.fca.0.extract, %4 ]
  %89 = load ptr, ptr %14, align 8
  %90 = load ptr, ptr %13, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 512, ptr nocapture nofree noundef %90)
  %92 = load i32, ptr %16, align 8
  %93 = sext i32 %92 to i64
  %94 = getelementptr ptr, ptr %90, i64 %93
  %95 = getelementptr i8, ptr %94, i64 8
  %96 = load ptr, ptr %95, align 8
  %97 = call ptr @typegetter_wrapper(ptr %96, ptr %89)
  %.fca.1.extract = extractvalue { ptr, i160 } %37, 1
  %.reload13.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.sroa.0.0, 0
  %.reload13.fca.1.insert = insertvalue { ptr, i160 } %.reload13.fca.0.insert, i160 %.fca.1.extract, 1
  ret { ptr, i160 } %.reload13.fca.1.insert
}

define { ptr, ptr, ptr, i32 } @CuckooMap_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract13, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(2384) @CuckooMap)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr } %16(ptr %8) #31
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %9)
  %19 = getelementptr i8, ptr %13, i64 32
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call { ptr } %21(ptr %8) #31
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %9)
  %24 = getelementptr i8, ptr %13, i64 40
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %8) #31
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %9)
  %29 = load ptr, ptr %13, align 8
  %30 = call ptr @typegetter_wrapper(ptr %29, ptr %8)
  %31 = load ptr, ptr %5, align 8
  %32 = load ptr, ptr %4, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %32)
  %34 = load i32, ptr %7, align 8
  %35 = sext i32 %34 to i64
  %36 = getelementptr ptr, ptr %32, i64 %35
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %39 = call ptr @typegetter_wrapper(ptr %38, ptr %31)
  %40 = load ptr, ptr %5, align 8
  %41 = load ptr, ptr %4, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %41)
  %43 = load i32, ptr %7, align 8
  %44 = sext i32 %43 to i64
  %45 = getelementptr ptr, ptr %41, i64 %44
  %46 = load ptr, ptr %45, align 8
  %47 = call ptr @typegetter_wrapper(ptr %46, ptr %40)
  %48 = load ptr, ptr %5, align 8
  %49 = load ptr, ptr %4, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %49)
  %51 = load i32, ptr %7, align 8
  %52 = sext i32 %51 to i64
  %53 = getelementptr ptr, ptr %49, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %56 = call ptr @typegetter_wrapper(ptr %55, ptr %48)
  %57 = call ptr @bump_malloc(i64 noundef 32)
  %58 = getelementptr i8, ptr %57, i64 16
  store ptr %56, ptr %58, align 8
  %59 = getelementptr i8, ptr %57, i64 8
  store ptr %47, ptr %59, align 8
  %60 = getelementptr i8, ptr %57, i64 24
  store ptr null, ptr %60, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %57)
  store ptr @Pair, ptr %57, align 8
  %62 = alloca [4 x ptr], align 8
  store ptr @CuckooMapIterator, ptr %62, align 8
  %63 = getelementptr inbounds i8, ptr %62, i64 8
  store ptr %30, ptr %63, align 8
  %64 = getelementptr inbounds i8, ptr %62, i64 16
  store ptr %39, ptr %64, align 8
  %65 = getelementptr inbounds i8, ptr %62, i64 24
  store ptr %57, ptr %65, align 8
  %66 = call { i64, i64 } @size_wrapper(ptr nonnull @_data_size_CuckooMapIterator, ptr noundef nonnull align 8 dereferenceable(32) %62)
  %67 = extractvalue { i64, i64 } %66, 0
  %68 = call ptr @bump_malloc(i64 %67)
  store ptr %30, ptr %68, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  store ptr %39, ptr %69, align 8
  %70 = getelementptr i8, ptr %68, i64 16
  store ptr %57, ptr %70, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %68)
  %72 = load ptr, ptr %5, align 8
  %73 = load ptr, ptr %4, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %73)
  %75 = load i32, ptr %7, align 8
  %76 = sext i32 %75 to i64
  %77 = getelementptr ptr, ptr %73, i64 %76
  %78 = getelementptr i8, ptr %77, i64 24
  %79 = load ptr, ptr %78, align 8
  %80 = load ptr, ptr %79, align 8
  %81 = call { ptr } %80(ptr %72) #31
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %73)
  %83 = getelementptr i8, ptr %77, i64 32
  %84 = load ptr, ptr %83, align 8
  %85 = load ptr, ptr %84, align 8
  %86 = call { ptr } %85(ptr %72) #31
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 2304, ptr nocapture nofree noundef %73)
  %88 = getelementptr i8, ptr %77, i64 40
  %89 = load ptr, ptr %88, align 8
  %90 = load ptr, ptr %89, align 8
  %91 = call i32 %90(ptr %72) #31
  %92 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMapIterator, ptr undef, ptr undef, i32 undef }, ptr %68, 1
  %93 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr undef, 2
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 10, 3
  %95 = call ptr @bump_malloc(i64 noundef 16)
  %96 = getelementptr i8, ptr %95, i64 8
  store ptr null, ptr %96, align 8
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %95)
  store ptr @buffer_typ, ptr %95, align 8
  %98 = call ptr @bump_malloc(i64 noundef 16)
  %99 = getelementptr i8, ptr %98, i64 8
  store ptr null, ptr %99, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %98)
  store ptr @buffer_typ, ptr %98, align 8
  %101 = alloca [3 x ptr], align 8
  store ptr %95, ptr %101, align 8
  %102 = getelementptr inbounds i8, ptr %101, i64 8
  store ptr %98, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %101, i64 16
  store ptr @_parameterization_i32, ptr %103, align 8
  %104 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %101)
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator)
  %106 = alloca { ptr, ptr, ptr }, align 8
  store ptr @buffer_typ, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %106, i64 8
  store ptr @buffer_typ, ptr %107, align 8
  %108 = getelementptr inbounds i8, ptr %106, i64 16
  store ptr @i32_typ, ptr %108, align 8
  %109 = call ptr @behavior_wrapper(ptr noundef nonnull @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32, { ptr, ptr, ptr, i32 } %94, ptr noundef nonnull align 8 dereferenceable(24) %106)
  call void %109({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr nonnull %101, { ptr } %81, { ptr } %86, i32 %91) #39
  %110 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @CuckooMapIterator, ptr %110, align 8
  %111 = getelementptr inbounds i8, ptr %110, i64 8
  store ptr %68, ptr %111, align 8
  %112 = getelementptr inbounds i8, ptr %110, i64 16
  %113 = getelementptr inbounds i8, ptr %110, i64 24
  store i32 10, ptr %113, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %110, ptr noundef nonnull align 8 dereferenceable(56) @Iterator)
  %114 = load ptr, ptr %110, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %114, 0
  %116 = load ptr, ptr %111, align 8
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %116, 1
  %118 = load ptr, ptr %112, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr %118, 2
  %120 = load i32, ptr %113, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 %120, 3
  ret { ptr, ptr, ptr, i32 } %121
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMapIterator(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_leni32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4, i32 %5) #3 {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator)
  %11 = load ptr, ptr %8, align 8
  %12 = load ptr, ptr %7, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %12)
  %14 = load i32, ptr %10, align 8
  %15 = sext i32 %14 to i64
  %16 = getelementptr ptr, ptr %12, i64 %15
  %17 = getelementptr i8, ptr %16, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %11, { ptr } %3) #30
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %10, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 32
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %21, { ptr } %4) #30
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %7, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %32)
  %34 = load i32, ptr %10, align 8
  %35 = sext i32 %34 to i64
  %36 = getelementptr ptr, ptr %32, i64 %35
  %37 = getelementptr i8, ptr %36, i64 40
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  call void %40(ptr %31, i32 %5) #30
  %41 = load ptr, ptr %8, align 8
  %42 = load ptr, ptr %7, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %42)
  %44 = load i32, ptr %10, align 8
  %45 = sext i32 %44 to i64
  %46 = getelementptr ptr, ptr %42, i64 %45
  %47 = getelementptr i8, ptr %46, i64 48
  %48 = load ptr, ptr %47, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  call void %50(ptr %41, i32 0) #30
  %51 = load ptr, ptr %8, align 8
  %52 = load ptr, ptr %7, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %52)
  %54 = load i32, ptr %10, align 8
  %55 = sext i32 %54 to i64
  %56 = getelementptr ptr, ptr %52, i64 %55
  %57 = getelementptr i8, ptr %56, i64 56
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  call void %60(ptr %51, i1 false) #30
  ret void
}

define { ptr, i160 } @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #3 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %.fca.1.extract6, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr %.fca.2.extract, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %8, i64 24
  store i32 %.fca.3.extract, ptr %11, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %8, ptr noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator)
  %.fca.0.extract = extractvalue { ptr } %3, 0
  br label %12

12:                                               ; preds = %47, %4
  %.028 = phi ptr [ undef, %4 ], [ %.129, %47 ]
  %.0 = phi i160 [ undef, %4 ], [ %.1, %47 ]
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %8, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %11, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = getelementptr i8, ptr %18, i64 48
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i32 %21(ptr %13) #31
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %14)
  %24 = getelementptr i8, ptr %18, i64 40
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %13) #31
  %28 = icmp slt i32 %22, %27
  br i1 %28, label %29, label %47

29:                                               ; preds = %12
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %14)
  %31 = call i32 %21(ptr %13) #31
  %32 = sext i32 %31 to i64
  %33 = shl nsw i64 %32, 5
  %34 = getelementptr i8, ptr %.fca.0.extract, i64 %33
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr i8, ptr %34, i64 8
  %37 = load i160, ptr %36, align 4
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %14)
  %39 = call i32 %21(ptr %13) #31
  %40 = add i32 %39, 1
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %14)
  %42 = getelementptr i8, ptr %20, i64 8
  %43 = load ptr, ptr %42, align 8
  call void %43(ptr %13, i32 %40) #30
  %44 = icmp ne ptr %35, @nil_typ
  %45 = icmp ne ptr %35, null
  %.not31 = and i1 %44, %45
  %46 = xor i1 %.not31, true
  br label %47

47:                                               ; preds = %29, %12
  %.129 = phi ptr [ %35, %29 ], [ %.028, %12 ]
  %.reg2mem28.0.off0 = phi i1 [ %46, %29 ], [ false, %12 ]
  %.reg2mem30.0 = phi i1 [ %.not31, %29 ], [ false, %12 ]
  %.1 = phi i160 [ %37, %29 ], [ %.0, %12 ]
  br i1 %.reg2mem28.0.off0, label %12, label %48

48:                                               ; preds = %47
  br i1 %.reg2mem30.0, label %49, label %74

49:                                               ; preds = %48
  store ptr %.129, ptr %6, align 8
  %50 = getelementptr inbounds i8, ptr %6, i64 8
  store i160 %.1, ptr %50, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %51 = load ptr, ptr %6, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %50, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = getelementptr inbounds i8, ptr %6, i64 16
  %56 = load ptr, ptr %55, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %56, 2
  %58 = getelementptr inbounds i8, ptr %6, i64 24
  %59 = load i32, ptr %58, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %59, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %51)
  %63 = sext i32 %59 to i64
  %64 = getelementptr ptr, ptr %51, i64 %63
  %65 = getelementptr i8, ptr %64, i64 72
  %66 = load ptr, ptr %65, align 8
  %67 = call ptr @behavior_wrapper(ptr %66, { ptr, ptr, ptr, i32 } %60, ptr noundef nonnull align 8 %5)
  %68 = call { ptr, ptr, ptr, i32 } %67({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull %5) #39
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %68, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %68, 1
  %.fca.2.extract10 = extractvalue { ptr, ptr, ptr, i32 } %68, 2
  %.fca.3.extract11 = extractvalue { ptr, ptr, ptr, i32 } %68, 3
  store ptr %.fca.0.extract8, ptr %7, align 8
  %69 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract9, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract10, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract11, ptr %71, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 8 dereferenceable(136) @Pair)
  %72 = load ptr, ptr %7, align 8
  %73 = load i160, ptr %69, align 8
  br label %74

74:                                               ; preds = %49, %48
  %.reg2mem26.sroa.3.0 = phi i160 [ %73, %49 ], [ undef, %48 ]
  %.reg2mem26.sroa.0.0 = phi ptr [ %72, %49 ], [ @nil_typ, %48 ]
  %.reload27.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem26.sroa.0.0, 0
  %.reload27.fca.1.insert = insertvalue { ptr, i160 } %.reload27.fca.0.insert, i160 %.reg2mem26.sroa.3.0, 1
  ret { ptr, i160 } %.reload27.fca.1.insert
}

define { ptr, i160 } @CuckooMapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract5, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.1.extract6, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %9, i64 24
  store i32 %.fca.3.extract, ptr %12, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %9, ptr noundef nonnull align 16 dereferenceable(216) @CuckooMapIterator)
  %13 = load ptr, ptr %10, align 8
  %14 = load ptr, ptr %9, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %14)
  %16 = load i32, ptr %12, align 8
  %17 = sext i32 %16 to i64
  %18 = getelementptr ptr, ptr %14, i64 %17
  %19 = getelementptr i8, ptr %18, i64 56
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i1 %21(ptr %13) #31
  br i1 %22, label %70, label %23

23:                                               ; preds = %3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %14)
  %25 = getelementptr i8, ptr %18, i64 24
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr } %27(ptr %13) #31
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %14, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %13, 1
  %31 = load ptr, ptr %11, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %31, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %16, 3
  %34 = call ptr @bump_malloc(i64 noundef 16)
  %35 = getelementptr i8, ptr %34, i64 8
  store ptr null, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %34)
  store ptr @buffer_typ, ptr %34, align 8
  store ptr %34, ptr %4, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %14)
  %39 = getelementptr i8, ptr %18, i64 72
  %40 = load ptr, ptr %39, align 8
  store ptr @buffer_typ, ptr %5, align 8
  %41 = call ptr @behavior_wrapper(ptr %40, { ptr, ptr, ptr, i32 } %33, ptr noundef nonnull align 8 dereferenceable(8) %5)
  %42 = call { ptr, i160 } %41({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull %4, { ptr } %28) #39
  %.fca.0.extract15 = extractvalue { ptr, i160 } %42, 0
  %43 = icmp ne ptr %.fca.0.extract15, @nil_typ
  %44 = icmp ne ptr %.fca.0.extract15, null
  %.not22.not.not = and i1 %43, %44
  br i1 %.not22.not.not, label %45, label %49

45:                                               ; preds = %23
  %.fca.1.extract16 = extractvalue { ptr, i160 } %42, 1
  store ptr %.fca.0.extract15, ptr %6, align 8
  %46 = getelementptr inbounds i8, ptr %6, i64 8
  store i160 %.fca.1.extract16, ptr %46, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %6, ptr noundef nonnull align 8 dereferenceable(136) @Pair)
  %47 = load ptr, ptr %6, align 8
  %48 = load i160, ptr %46, align 8
  br label %70

49:                                               ; preds = %23
  %50 = load ptr, ptr %10, align 8
  %51 = load ptr, ptr %9, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %51)
  %53 = load i32, ptr %12, align 8
  %54 = sext i32 %53 to i64
  %55 = getelementptr ptr, ptr %51, i64 %54
  %56 = getelementptr i8, ptr %55, i64 48
  %57 = load ptr, ptr %56, align 8
  %58 = getelementptr i8, ptr %57, i64 8
  %59 = load ptr, ptr %58, align 8
  call void %59(ptr %50, i32 0) #30
  %60 = load ptr, ptr %10, align 8
  %61 = load ptr, ptr %9, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %61)
  %63 = load i32, ptr %12, align 8
  %64 = sext i32 %63 to i64
  %65 = getelementptr ptr, ptr %61, i64 %64
  %66 = getelementptr i8, ptr %65, i64 56
  %67 = load ptr, ptr %66, align 8
  %68 = getelementptr i8, ptr %67, i64 8
  %69 = load ptr, ptr %68, align 8
  call void %69(ptr %60, i1 true) #30
  br label %70

70:                                               ; preds = %49, %45, %3
  %.reg2mem41.sroa.3.0 = phi i160 [ %48, %45 ], [ poison, %49 ], [ poison, %3 ]
  %.reg2mem41.sroa.0.0 = phi ptr [ %47, %45 ], [ poison, %49 ], [ poison, %3 ]
  %.reg2mem39.0 = phi i1 [ true, %45 ], [ false, %49 ], [ false, %3 ]
  br i1 %.reg2mem39.0, label %96, label %71

71:                                               ; preds = %70
  %72 = load ptr, ptr %10, align 8
  %73 = load ptr, ptr %9, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %73)
  %75 = load i32, ptr %12, align 8
  %76 = sext i32 %75 to i64
  %77 = getelementptr ptr, ptr %73, i64 %76
  %78 = getelementptr i8, ptr %77, i64 32
  %79 = load ptr, ptr %78, align 8
  %80 = load ptr, ptr %79, align 8
  %81 = call { ptr } %80(ptr %72) #31
  %82 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %73, 0
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %72, 1
  %84 = load ptr, ptr %11, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %84, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %75, 3
  %87 = call ptr @bump_malloc(i64 noundef 16)
  %88 = getelementptr i8, ptr %87, i64 8
  store ptr null, ptr %88, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %87)
  store ptr @buffer_typ, ptr %87, align 8
  store ptr %87, ptr %7, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %73)
  %92 = getelementptr i8, ptr %77, i64 72
  %93 = load ptr, ptr %92, align 8
  store ptr @buffer_typ, ptr %8, align 8
  %94 = call ptr @behavior_wrapper(ptr %93, { ptr, ptr, ptr, i32 } %86, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %95 = call { ptr, i160 } %94({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %7, { ptr } %81) #39
  %.fca.0.extract7 = extractvalue { ptr, i160 } %95, 0
  %.fca.1.extract8 = extractvalue { ptr, i160 } %95, 1
  br label %96

96:                                               ; preds = %71, %70
  %.reg2mem37.sroa.0.0 = phi ptr [ %.fca.0.extract7, %71 ], [ %.reg2mem41.sroa.0.0, %70 ]
  %.reg2mem37.sroa.3.0 = phi i160 [ %.fca.1.extract8, %71 ], [ %.reg2mem41.sroa.3.0, %70 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem37.sroa.0.0, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem37.sroa.3.0, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

define { i64, i64 } @_data_size_Entry(ptr nocapture nofree readonly align 8 %0) #3 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 20, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 20
  %15 = add i64 %14, %13
  %16 = getelementptr i8, ptr %0, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = extractvalue { i64, i64 } %21, 1
  %24 = call i64 @llvm.umax.i64(i64 %9, i64 %23)
  %25 = call i64 @llvm.umax.i64(i64 %24, i64 noundef 8), !range !1
  %26 = urem i64 %15, %23
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %23, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %22, %15
  %31 = add i64 %30, %29
  %32 = urem i64 %31, %25
  %33 = icmp eq i64 %32, 0
  %34 = sub i64 %25, %32
  %35 = select i1 %33, i64 0, i64 %34
  %36 = add i64 %31, %35
  %37 = insertvalue { i64, i64 } undef, i64 %36, 0
  %38 = insertvalue { i64, i64 } %37, i64 %25, 1
  ret { i64, i64 } %38
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #6 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @Entry_B_init_keyK_valueV_primary_hashi32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @any_typ, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %12)
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = getelementptr i8, ptr %16, i64 16
  %19 = getelementptr i8, ptr %16, i64 24
  %20 = getelementptr i8, ptr %16, i64 32
  %21 = load i64, ptr %17, align 4
  %22 = load i64, ptr %18, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %25 = call i1 @subtype_test_wrapper(ptr %23, i64 %22, i64 %21, i64 %13, i64 noundef ptrtoint (ptr @any_typ to i64), ptr %24)
  %26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %27 = getelementptr i8, ptr %26, i64 160
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_primary_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_to_pair_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Entry_init_keyK_valueV_primary_hashi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #3 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract12, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr %.fca.1.extract13, ptr %8, align 8
  %9 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr %.fca.2.extract, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %7, i64 24
  store i32 %.fca.3.extract, ptr %10, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %7, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %11 = load ptr, ptr %8, align 8
  %12 = load ptr, ptr %7, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %12)
  %14 = load i32, ptr %10, align 8
  %15 = sext i32 %14 to i64
  %16 = getelementptr ptr, ptr %12, i64 %15
  %17 = getelementptr i8, ptr %16, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  call void %20(ptr %11, { ptr, i160 } %3) #30
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %22)
  %24 = load i32, ptr %10, align 8
  %25 = sext i32 %24 to i64
  %26 = getelementptr ptr, ptr %22, i64 %25
  %27 = getelementptr i8, ptr %26, i64 32
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  call void %30(ptr %21, { ptr, i160 } %4) #30
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %7, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %32)
  %34 = load i32, ptr %10, align 8
  %35 = sext i32 %34 to i64
  %36 = getelementptr ptr, ptr %32, i64 %35
  %37 = getelementptr i8, ptr %36, i64 16
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  call void %40(ptr %31, i32 %5) #30
  ret void
}

define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract4, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } %16(ptr %8) #31
  ret { ptr, i160 } %17
}

define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract3, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract4, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 32
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } %16(ptr %8) #31
  ret { ptr, i160 } %17
}

define i32 @Entry_primary_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call i32 %16(ptr %8) #31
  ret i32 %17
}

define { ptr, ptr, ptr, i32 } @Entry_to_pair_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract27, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %.fca.1.extract28, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %4, i64 16
  store ptr %.fca.2.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %4, i64 24
  store i32 %.fca.3.extract, ptr %7, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %4, ptr noundef nonnull align 16 dereferenceable(200) @Entry)
  %8 = load ptr, ptr %5, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %9)
  %11 = load i32, ptr %7, align 8
  %12 = sext i32 %11 to i64
  %13 = getelementptr ptr, ptr %9, i64 %12
  %14 = getelementptr i8, ptr %13, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } %16(ptr %8) #31
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %9)
  %19 = getelementptr i8, ptr %13, i64 32
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call { ptr, i160 } %21(ptr %8) #31
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %9)
  %24 = load ptr, ptr %13, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %8)
  %26 = load ptr, ptr %5, align 8
  %27 = load ptr, ptr %4, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %27)
  %29 = load i32, ptr %7, align 8
  %30 = sext i32 %29 to i64
  %31 = getelementptr ptr, ptr %27, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr @typegetter_wrapper(ptr %33, ptr %26)
  %35 = alloca [3 x ptr], align 8
  store ptr @Pair, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %35, i64 8
  store ptr %25, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %35, i64 16
  store ptr %34, ptr %37, align 8
  %38 = load ptr, ptr getelementptr inbounds (i8, ptr @Pair, i64 48), align 8
  %39 = call { i64, i64 } @size_wrapper(ptr %38, ptr noundef nonnull align 8 dereferenceable(24) %35)
  %40 = extractvalue { i64, i64 } %39, 0
  %41 = call ptr @bump_malloc(i64 %40)
  store ptr %25, ptr %41, align 8
  %42 = getelementptr i8, ptr %41, i64 8
  store ptr %34, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %41)
  %44 = load ptr, ptr %5, align 8
  %45 = load ptr, ptr %4, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %45)
  %47 = load i32, ptr %7, align 8
  %48 = sext i32 %47 to i64
  %49 = getelementptr ptr, ptr %45, i64 %48
  %50 = getelementptr i8, ptr %49, i64 24
  %51 = load ptr, ptr %50, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr, i160 } %52(ptr %44) #31
  %.fca.0.extract7 = extractvalue { ptr, i160 } %53, 0
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %45)
  %55 = getelementptr i8, ptr %49, i64 32
  %56 = load ptr, ptr %55, align 8
  %57 = load ptr, ptr %56, align 8
  %58 = call { ptr, i160 } %57(ptr %44) #31
  %.fca.0.extract = extractvalue { ptr, i160 } %58, 0
  %59 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %41, 1
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr undef, 2
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 10, 3
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %45)
  %63 = load ptr, ptr %49, align 8
  %64 = call ptr @typegetter_wrapper(ptr %63, ptr %44)
  %65 = load ptr, ptr %5, align 8
  %66 = load ptr, ptr %4, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %66)
  %68 = load i32, ptr %7, align 8
  %69 = sext i32 %68 to i64
  %70 = getelementptr ptr, ptr %66, i64 %69
  %71 = getelementptr i8, ptr %70, i64 8
  %72 = load ptr, ptr %71, align 8
  %73 = call ptr @typegetter_wrapper(ptr %72, ptr %65)
  %74 = alloca [2 x ptr], align 8
  store ptr %64, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %74, i64 8
  store ptr %73, ptr %75, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %74)
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(136) @Pair)
  %78 = load ptr, ptr getelementptr inbounds (i8, ptr @Pair, i64 112), align 8
  %79 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract7, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %79, i64 8
  store ptr %.fca.0.extract, ptr %80, align 8
  %81 = call ptr @behavior_wrapper(ptr %78, { ptr, ptr, ptr, i32 } %61, ptr noundef nonnull align 8 dereferenceable(16) %79)
  call void %81({ ptr, ptr, ptr, i32 } %61, { ptr, ptr, ptr, i32 } %61, ptr nonnull %74, { ptr, i160 } %53, { ptr, i160 } %58) #39
  %82 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr @Pair, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %82, i64 8
  store ptr %41, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %82, i64 16
  %85 = getelementptr inbounds i8, ptr %82, i64 24
  store i32 10, ptr %85, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %82, ptr noundef nonnull align 8 dereferenceable(136) @Pair)
  %86 = load ptr, ptr %82, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %86, 0
  %88 = load ptr, ptr %83, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %88, 1
  %90 = load ptr, ptr %84, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } %89, ptr %90, 2
  %92 = load i32, ptr %85, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, i32 %92, 3
  ret { ptr, ptr, ptr, i32 } %93
}

define { ptr, i160 } @Entry_getter_value(ptr noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = extractvalue { i64, i64 } %6, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %20 = call { i64, i64 } @size_wrapper(ptr %19, ptr noundef nonnull align 8 dereferenceable(8) %16)
  %21 = extractvalue { i64, i64 } %20, 1
  %22 = urem i64 %14, %21
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 %21, %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = getelementptr i8, ptr %0, i64 %14
  %27 = getelementptr i8, ptr %26, i64 %25
  %28 = load ptr, ptr %15, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = call { ptr, i160 } @box_wrapper(ptr %31, ptr %27, ptr noundef nonnull align 8 dereferenceable(8) %28)
  ret { ptr, i160 } %32
}

define void @Entry_setter_value(ptr noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #3 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 20, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 20
  %15 = add i64 %14, %13
  %16 = getelementptr inbounds i8, ptr %0, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %21 = call { i64, i64 } @size_wrapper(ptr %20, ptr noundef nonnull align 8 dereferenceable(8) %17)
  %22 = extractvalue { i64, i64 } %21, 1
  %23 = urem i64 %15, %22
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %22, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = getelementptr i8, ptr %0, i64 %15
  %28 = getelementptr i8, ptr %27, i64 %26
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  call void @unbox_wrapper(ptr %32, { ptr, i160 } %1, ptr noundef nonnull align 8 dereferenceable(8) %29, ptr %28)
  ret void
}

define { ptr, i160 } @Entry_getter_key(ptr noundef nonnull align 8 dereferenceable(8) %0) #3 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr noundef nonnull align 8 dereferenceable(8) %2)
  %7 = extractvalue { i64, i64 } %6, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = load ptr, ptr %0, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 56
  %16 = load ptr, ptr %15, align 8
  %17 = call { ptr, i160 } @box_wrapper(ptr %16, ptr %12, ptr noundef nonnull align 8 dereferenceable(8) %13)
  ret { ptr, i160 } %17
}

define void @Entry_setter_key(ptr noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #3 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr %6, ptr noundef nonnull align 8 dereferenceable(8) %3)
  %8 = extractvalue { i64, i64 } %7, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %reass.sub = sub i64 %8, %9
  %11 = add i64 %reass.sub, 20
  %12 = select i1 %10, i64 20, i64 %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load ptr, ptr %0, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 64
  %17 = load ptr, ptr %16, align 8
  call void @unbox_wrapper(ptr %17, { ptr, i160 } %1, ptr noundef nonnull align 8 dereferenceable(8) %14, ptr %13)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_primary_hash(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_primary_hash(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @CuckooMapIterator_getter_on_second(ptr nocapture nofree readonly %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_on_second(ptr nocapture nofree writeonly %0, i1 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_index(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_index(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_table_len(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_table_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table2(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table1(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_KeyNotFound(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define ptr @KeyNotFound_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #29
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = load i64, ptr @String, align 8
  %15 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 %14, i64 noundef ptrtoint (ptr @String to i64), ptr %13)
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = getelementptr i8, ptr %16, i64 184
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

define ptr @KeyNotFound_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #3 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #29
  %4 = load ptr, ptr %1, align 8
  %5 = getelementptr i8, ptr %4, i64 8
  %6 = getelementptr i8, ptr %4, i64 16
  %7 = getelementptr i8, ptr %4, i64 24
  %8 = getelementptr i8, ptr %4, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %13 = load i64, ptr @String, align 8
  %14 = call i1 @subtype_test_wrapper(ptr %11, i64 %10, i64 %9, i64 %13, i64 noundef ptrtoint (ptr @String to i64), ptr %12)
  %15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %16 = getelementptr i8, ptr %15, i64 168
  %17 = load ptr, ptr %16, align 8
  ret ptr %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_print_stacktrace_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #2 {
  %3 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #29
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i64 @KeyNotFound_getter_n_frames(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 80
  %3 = load i64, ptr %2, align 4
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_n_frames(ptr nocapture nofree writeonly align 4 %0, i64 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 80
  store i64 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @KeyNotFound_getter_stacktrace(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_stacktrace(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 72
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_message(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_message(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_file_name(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_file_name(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @KeyNotFound_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #6 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #7 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Map(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #1 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_eq(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_eq(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_hasher(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_hasher(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_size(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_size(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_table_len(ptr nocapture nofree readonly align 4 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table_len(ptr nocapture nofree writeonly align 4 %0, i32 %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table2(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table2(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table1(ptr nocapture nofree readonly align 8 %0) #6 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table1(ptr nocapture nofree writeonly align 8 %0, { ptr } %1) #7 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMap(ptr nocapture nofree readnone %0) #1 {
  ret { i64, i64 } { i64 24, i64 8 }
}

define void @report_exception({ ptr } %0) #3 {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %4 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %.fca.0.extract2, i64 56
  %7 = load i160, ptr %6, align 4
  %8 = getelementptr i8, ptr %5, i64 8
  %9 = getelementptr i8, ptr %5, i64 16
  %10 = getelementptr i8, ptr %5, i64 24
  %11 = getelementptr i8, ptr %5, i64 32
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 noundef 9027164862567808692, i64 noundef ptrtoint (ptr @Exception to i64), ptr %15)
  br i1 %16, label %17, label %._crit_edge

17:                                               ; preds = %1
  store ptr %5, ptr %3, align 8
  %18 = getelementptr inbounds i8, ptr %3, i64 8
  store i160 %7, ptr %18, align 8
  call void @set_offset(ptr noundef nonnull align 8 dereferenceable(32) %3, ptr noundef nonnull align 16 dereferenceable(216) @Exception)
  %19 = load ptr, ptr %3, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %19, 0
  %21 = load ptr, ptr %18, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 1
  %23 = getelementptr inbounds i8, ptr %3, i64 16
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 2
  %26 = getelementptr inbounds i8, ptr %3, i64 24
  %27 = load i32, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %27, 3
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %19)
  %31 = sext i32 %27 to i64
  %32 = getelementptr ptr, ptr %19, i64 %31
  %33 = getelementptr i8, ptr %32, i64 72
  %34 = load ptr, ptr %33, align 8
  %35 = call ptr @behavior_wrapper(ptr %34, { ptr, ptr, ptr, i32 } %28, ptr noundef nonnull align 8 %2)
  call void %35({ ptr, ptr, ptr, i32 } %28, { ptr, ptr, ptr, i32 } %28, ptr nonnull %2) #39
  br label %._crit_edge

._crit_edge:                                      ; preds = %17, %1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #1 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "disable-tail-calls"="true" }
attributes #2 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) "disable-tail-calls"="true" }
attributes #3 = { "disable-tail-calls"="true" }
attributes #4 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "disable-tail-calls"="true" }
attributes #7 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "disable-tail-calls"="true" }
attributes #8 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) }
attributes #9 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #10 = { alwaysinline mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none) }
attributes #11 = { alwaysinline }
attributes #12 = { nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #13 = { alwaysinline mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #14 = { mustprogress nofree noinline nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #15 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #16 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #17 = { noinline }
attributes #18 = { noreturn nounwind }
attributes #19 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #20 = { nocallback nofree nosync nounwind willreturn }
attributes #21 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #22 = { noinline nounwind memory(readwrite) }
attributes #23 = { cold noinline }
attributes #24 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #25 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #26 = { nofree nounwind "disable-tail-calls"="true" }
attributes #27 = { nofree nounwind }
attributes #28 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) "disable-tail-calls"="true" }
attributes #29 = { nofree willreturn }
attributes #30 = { nounwind willreturn memory(argmem: readwrite) }
attributes #31 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #32 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #33 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #34 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #35 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #36 = { mustprogress nofree nosync nounwind willreturn }
attributes #37 = { mustprogress nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #38 = { nounwind memory(readwrite) }
attributes #39 = { nounwind }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i64 8, i64 0}
