# Plan for the full implementation of generics

A full implementation of generics will involve objects (fat pointers) carrying references their type parameters at runtime. This is so that:

1. We can do runtime type-checks of arbitrarily nested parameterzed types

	Example: "if x is Iterable[Pair[i32, f64]] {...}"

2. We can multi-dispatch on different parameterizations of a type

3. We can construct new parameterized instances from the type parameters of the current instance

	Example: Pair[T, U].reversed() constructs a Pair[U, T] from its own stored type parameters

4. We can use attributes of a type (like size-in-bytes) in containers

	Example: to index into an Array[T] in constant time, we can query the stored type parameter T for its size

# Implementation Strategies

There are several candidate approaches to storing type parameters at runtime:

1. Storing them as fields of the instance alongside its data fields, accessed via the vtable

This has the rather significant downside that whenever we convert an i32 to an Addable[i32, i32] for use in a generic method, we should have to allocate space on the heap and put it behind a pointer, because storing those two type parameters takes more space than is available inside the fat pointer. Gets even worse when you consider that it is also Addable[f64, f64], and Comparable[i32], and so on.

2. Making a separate allocation for type parameters at object creation time

This means that even if many instances share exactly the same type parameters, they all get their own allocation. Consider placing i32's into an Array[Addable[i32, i32]]. Every i32 converted into an Addable will have to allocate its own version of exactly the same type parameter list.

3. (Current best idea) Creating a (thread local) global for each unique type parameter list

We would then use the third word of the fat pointer to store a pointer to this list at object creation time. This would mean that in the previous example, all the elements of the array would have a pointer to the very same parameter list. These parameter lists would be globally visible and invariant, so the optimizer can reason about them quite well.

They would still be accessed via the vtable, so that casting works as expected, but for type parameters which are 'baked in' to the type, such as the i32 in "Range extends Iterable[i32]," the vtable method could just directly return the vptr of i32.

For nested type parameters, the indirection would work as follows:

Suppose we have an instance of type Mapping[i32, f64], which we are viewing as an Iterable[f64]. This is an instantiation of Mapping[T, U] which extends Iterable[U]. There are two global variables assocated with this instance. One is the type list [i32, f64], which contains vptrs. Another is a list containing just the pointer to the second element of that list, which creates the indirection necessary to map the formal type parameter Iterable.T to Mapping.U, so that when we query the vtable for Iterable.T (because we are viewing it as an Iterable), we follow the indirection to end up at the f64, which is Mapping.U. The pointer to this second global is stored in the third word of the fat pointer at the point of object creation.

That layer of indirection also means that type parameter nesting can be arbitrarily deep, because each formal type parameter maps to the start of a range of (flattened) concrete type parameters. So for instance Pair[Pair[i32, i32], f64] would have a concrete type list of [Pair, i32, i32, f64], and the mapping from formal type parameters would be a two element array [T, U] with pointers to elements 0 and 3.

The downside is the space overhead of having a global for each unique parameter list and each mapping of formal types to concrete types, but this does not seem so bad.

# Required changes

We will need to move function pointers from being represented merely as a raw pointer to being represented by a fat pointer, so that we can store its type parameters and the @function_type vptr. The small struct optimization applies for the function ptr itself, which will be stored in the second word. Reabstraction switches out the second word fptr.

Buffer creation and indexation will need to use the locally available type parameters so that buffers can remain just a single raw pointer. So for instance operations on the Buffer[T] field of Array[T] will use the T from the Array instance.

Because the third word of the fat ptr is now used, we can only use the second word for small struct optimization, so only values 64 bits or smaller can be stored without an extra heap allocation. Perhaps we can have more complicated rules around small struct optimization if it has no type parameters, or defer boxing until cast to a parent which has type parameters, or something like that.

We will have to create a way to cast builtin types to generic parents, for example i32 to Addable[i32, i32]. The approach here might be to write a class "Int32 extends Addable[Int32, Int32] etc." with magic methods for operators etc, and add it to the ancestor list of i32.

# What this design allows

First, generic fields and generic buffers can actually be the size of the concrete types they are instantiated with. An Array of i32 can actually be hold a contiguous buffer of i32's that can be iterated over with great cache locality. A Pair[i32, i32] can be stored inline inside a fat ptr.

Second, certain kinds of casts not available in other langauges will be possible. For example, when we add variance, it will be possible to upcast a covariant container (of value types) with essentially no runtime cost. Only at the point of taking an element out of the container will the element itself have to be casted.

Third, we retain separate compilation and avoid code duplication and keep all the good parts of non-monomorphized generics.