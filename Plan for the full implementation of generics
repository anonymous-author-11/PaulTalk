# Plan for the full implementation of generics

A full implementation of generics will involve objects (fat pointers) carrying references their type parameters at runtime. This is so that:

1. We can do runtime type-checks of arbitrarily nested parameterzed types

	Example: "if x is Iterable[Pair[i32, f64]] {...}"

2. We can multi-dispatch on different parameterizations of a type

3. We can construct new parameterized instances from the type parameters of the current instance

	Example: Pair[T, U].reversed() constructs a Pair[U, T] from its own stored type parameters

4. We can use attributes of a type (like size-in-bytes) in containers

	Example: to index into an Array[T] in constant time, we can query the stored type parameter T for its size

# Implementation Strategies

There are several candidate approaches to storing type parameters at runtime:

1. Storing them as fields of the instance alongside its data fields, accessed via the vtable

This has the rather significant downside that whenever we convert an i32 to an Addable[i32, i32] for use in a generic method, we should have to allocate space on the heap and put it behind a pointer, because storing those two type parameters takes more space than is available inside the fat pointer. Gets even worse when you consider that it is also Addable[f64, f64], and Comparable[i32], and so on.

2. Making a separate allocation for type parameters at object creation time

This means that even if many instances share exactly the same type parameters, they all get their own allocation. Consider placing i32's into an Array[Addable[i32, i32]]. Every i32 converted into an Addable will have to allocate its own version of exactly the same type parameter list.

3. (Current best idea) Creating a (thread local) global for each unique type parameter list

For "Range extends Iterable[i32]", we will call the i32 a "fixed" type parameter. It has been "fixed" by inheritance and cannot vary between instantiations. Whereas for "Array[T] extends Iterable[T]", T is not fixed. We only need to store unfixed type parameters as instance fields. For fixed type parameters, the vtable getter can immediately return the fixed type. This means that an i32 converted to an Addable[i32, i32] needs no extra fields because all of its type parameters are fixed and can be immediately returned by its vtable getters.

Each of the unfixed formal parameters will be associated with a field in the instance. That field is populated at instance creation with a pointer to a global representing the concrete type at that type parameter position. This global may be an array of types representing a nested type. So, a Pair[Pair[i32, f64], i32] would have two type fields for its two formal parameters. These fields would contain pointers to globals. These globals would be [Pair, i32, f64] for the first formal parameter and [i32] for the second.

The globals would have names that are a function of the types they contain, so that globals with identical types will have identical names and can be merged at link time.

It seems like unions can be easily incorporated into this scheme by being an array of all the types in the union. The only twist would be also storing the size of the union since unions can have a variable number of types in them.

# Required changes

We will need to move function pointers from being represented merely as a raw pointer to being represented by a fat pointer, so that we can store the @function_type vptr and its type parameters. We should figure out a special optimization for these, so that we can store a pointer to type information in the third word of the fat ptr. Probably that pointer will be to a global array with an element for every formal type parameter, storing pointers to global arrays for each formal parameter's concrete types. Then the @function_type's vtable getter should know to retrieve type parameters from there.

Buffer creation and indexation will need to use the locally available type parameters so that buffers can remain just a single raw pointer. So for instance operations on the Buffer[T] field of Array[T] will use the T from the Array instance.

We will have to create a way to cast builtin types to generic parents, for example i32 to Addable[i32, i32]. The approach here might be to write a class "Int32 extends Addable[Int32, Int32] etc." with magic methods for operators etc, and add it to the ancestor list of i32.

# What this design allows

First, generic fields and generic buffers can actually be the size of the concrete types they are instantiated with. An Array of i32 can actually be hold a contiguous buffer of i32's that can be iterated over with great cache locality. A Pair[i32, i32] could be stored inline inside a fat ptr.

Second, certain kinds of casts not available in other langauges will be possible. For example, when we add variance, it will be possible to upcast a covariant container (of value types) with essentially no runtime cost. Only at the point of taking an element out of the container will the element itself have to be casted.

Third, we retain separate compilation and avoid code duplication and keep all the good parts of non-monomorphized generics.