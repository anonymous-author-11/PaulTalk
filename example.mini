// pc == protection counter
// reg == memory region

// allocation -- know exactly where data value is allocated
data = Object.new();
// data reg pc incremented

// allocation -- know exactly where buf value is allocated
buf = Buffer[Object].new(1);
// buf reg pc incremented

// data must outlive buf
buf.[0] = data;

// buf must outlive ary
ary = Array.new(buf, 1, 1);
// ary reg pc incremented

// don't know where iter is allocated. must increment iter reg pc internally.
// ary must outlive iter
iter = ary.iterator();

// don't know where x is allocated. must increment x reg pc internally.
// last use of iter imminent-- decrease protection count of ary reg, iter reg, buf reg, data reg [problematic! iter not allocated in this scope!]
// iter reg, ary reg, buf reg freed internally
// data reg atempted free internally; still protected (because aliased by x)
// x must outlive iter
x = iter.next();

// last use of x imminent; x (and data) reg pc decremented [problematic! x not allocated in this scope!]
// x (and data) reg attempted free internally (succeeded)
IO.print(x);

/// ----------

class Iterator2[T] {
    #[ret > iterable_reg]
	abstract def next() -> T | Nil {}
}

class Iterable2[T] {
    #[ret < self]
	abstract def iterator() -> Iterator2[T] {}
	def each(f : (T)) {
        for x in self { f.call(x); }
    }
    #[ret == accumulator]
    def reduce(accumulator : T, f : (T, T) -> T) -> T {
        for x in self { accumulator = f.call(accumulator, x); }
        return accumulator;
    }
    def all(f : (T) -> Bool) -> Bool {
        for x in self {
            if f.call(x) { continue; }
            return false;
        }
        return true;
    }
    def any(f : (T) -> Bool) -> Bool {
        for x in self { if f.call(x) { return true; } }
        return false;
    }
    #[ret < self, ret < f]
    def map[U](f : (T) -> U) -> MapIterable2[T, U] {
        return MapIterable2[T, U].new(self, f);
    }
    #[ret < self, ret < f]
    def filter(f : (T) -> Bool) -> FilterIterable2[T] {
        return FilterIterable2[T].new(self, f);
    }
    #[ret < self, ret < other]
    def chain(other : Iterable2[T]) -> ChainIterable2[T] {
        return ChainIterable2[T].new(self, other);
    }
    #[ret < self, ret < other]
    def interleave(other : Iterable2[T]) -> InterleaveIterable2[T] {
        return InterleaveIterable2[T].new(self, other);
    }
    #[ret < self, ret < other]
    def zip[U](other : Iterable2[U]) -> ZipIterable2[T, U] {
        return ZipIterable2[T, U].new(self, other);
    }
    #[ret < self, ret < other]
    def product[U](other : Iterable2[U]) -> ProductIterable2[T, U] {
        return ProductIterable2[T, U].new(self, other);
    }
}

class Array[T] extends ScopedIterable2[T] {
	@buffer : Buffer[T]
	@length : i32
	@capacity : i32

    #[ret < iterable]
	def Self.from_iterable(iterable : Iterable2[T]) -> Array[T] {
    	result = Array[T].new();
    	for elem in iterable { result.append(elem); }
    	return result;
    }
	def init() {
		@buffer = Buffer[T].new(1);
		@length = 0;
		@capacity = 1;
	}
    def init(@capacity : i32) {
        @buffer = Buffer[T].new(@capacity);
        @length = 0;
    }
    #[ret == self]
	def length() -> i32 {
		return @length;
	}
    #[ret == self]
    def capacity() -> i32 {
    	return @capacity;
    }
    #[ret == self, self < x]
    def append(x : T) -> Array[T] {
        if @length >= @capacity { self.grow(); }
        @buffer.[@length] = x;
        @length = @length + 1;
        return self;
    }
    def grow() {
    	@capacity = @capacity * 2;
        old_buffer = @buffer;
        @buffer = Buffer[T].new(@capacity);
        i = 0;
        while i < @length {
            @buffer.[i] = old_buffer.[i];
            i = i + 1;
        }
    }
    #[ret > self]
    def [](x : i32) -> T yields OutOfBounds | Nil {
    	past_end = x > (@length - 1);
    	before_start = (@length + x) < 0;
        if past_end or before_start { self.throw_oob(x); }
        if x < 0 { x = @length + x; }
        return self.unsafe_index(x);
    }
    def throw_oob(x : i32) yields OutOfBounds {
    	yield(Exception.new());
    }
    #[ret > self]
    def unsafe_index(x : i32) -> T {
    	return @buffer.[x];
    }
    def iterator() -> ArrayIterator[T] {
    	return ArrayIterator[T].new(self);
    }
}

class ArrayIterator[T] extends ScopedIterator2[T] {
	@array : Array[T]
	@index : i32

	#[iterable_reg == @array]
	def init(@array : Array[T]) { @index = 0; }
	def next() -> T | Nil {
		if @index >= @array.length() { return nil; }
		@index = @index + 1;
		return @array.unsafe_index(@index - 1);
	}
}
