; ModuleID = 'out_reg2mem.ll'
source_filename = "llvm-link"

@ndpsw_Warning_Remove_returned_Nil_for_key_ = internal unnamed_addr constant [37 x i8] c"Warning: Remove returned Nil for key "
@rroys_Warning_Remove_returned_wrong_value_for_key_ = internal unnamed_addr constant [45 x i8] c"Warning: Remove returned wrong value for key "
@euodo_Error_Nil_returned_during_random_hit_test_for_key_ = internal unnamed_addr constant [51 x i8] c"Error: Nil returned during random hit test for key "
@qyaaw__unique_keys_for_random_hit_test = internal unnamed_addr constant [33 x i8] c" unique keys for random hit test."
@tvsrx_Error_Nil_returned_during_sequential_hit_test_for_key_ = internal unnamed_addr constant [55 x i8] c"Error: Nil returned during sequential hit test for key "
@_parameterization_PairPtri32._Ptri1 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_Ptri32, ptr @_parameterization_Ptri1, ptr null]
@_parameterization_PairPtri32._Ptri32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_Ptri32, ptr @_parameterization_Ptri32, ptr null]
@PRNG_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = constant [4 x i32] [i32 15, i32 10, i32 10, i32 0]
@PRNG = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_data_size_PRNG, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedPtri32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedPtri32, ptr @PRNG_next_] }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i32_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i128_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @i128_typ, ptr @any_typ, ptr null]
@i128_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@f64_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@nothing_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @nothing_typ]
@nothing_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@coroutine_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @coroutine_typ]
@coroutine_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@function_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @buffer_typ, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@tuple_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @tuple_typ]
@tuple_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@union_typ_hashtbl = constant [4 x ptr] [ptr @union_typ, ptr null, ptr @any_typ, ptr @Object]
@union_typ_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@Object_hashtbl = constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@_parameterization_Nil = linkonce_odr constant [2 x ptr] [ptr @nil_typ, ptr null]
@_parameterization_BufferEntryK._V_or_Nil = linkonce_odr constant [2 x ptr] [ptr @buffer_typ, ptr null]
@Entry_hashtbl = constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = constant [4 x i32] [i32 10, i32 25, i32 10, i32 0]
@Entry = constant { [3 x i64], [7 x ptr], [15 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_data_size_Entry, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [15 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_primary_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_init_keyK_valueV_primary_hashPtri32, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_primary_hash_, ptr @Entry_B_to_pair_, ptr @Entry_init_keyK_valueV_primary_hashPtri32, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_primary_hash_, ptr @Entry_to_pair_] }
@HashMap_hashtbl = constant [8 x ptr] [ptr null, ptr @HashMap, ptr @Container, ptr null, ptr @Object, ptr null, ptr @any_typ, ptr @Iterable2]
@HashMap_offset_tbl = constant [8 x i32] [i32 0, i32 10, i32 98, i32 0, i32 98, i32 0, i32 10, i32 75]
@HashMap = constant { [3 x i64], [7 x ptr], [88 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_data_size_HashMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [88 x ptr] [ptr @HashMap_field_HashMap_0, ptr @HashMap_field_HashMap_1, ptr @HashMap_field_HashMap_2, ptr @HashMap_field_table1, ptr @HashMap_field_table2, ptr @HashMap_field_table_len, ptr @HashMap_field_size, ptr @HashMap_field_hasher, ptr @HashMap_field_eq, ptr @HashMap_B__Self_max_displacements_, ptr @HashMap_B_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1, ptr @HashMap_B_hash1_keyK, ptr @HashMap_B_hash2_from_primary_primary_hashPtri32, ptr @HashMap_B_index1_primary_hashPtri32, ptr @HashMap_B_index2_primary_hashPtri32, ptr @HashMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @HashMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32, ptr @HashMap_B_resize_, ptr @HashMap_B_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @HashMap_B_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @HashMap_B_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @HashMap_B_insert_keyK_valueV, ptr @HashMap_B_get_keyK, ptr @HashMap_B_remove_keyK, ptr @HashMap_B_clear_, ptr @HashMap_B_size_, ptr @HashMap_B_iterator_, ptr @HashMap_B_each_fFunctionT_to_Nothing, ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @HashMap_B_all_fFunctionT_to_Ptri1, ptr @HashMap_B_any_fFunctionT_to_Ptri1, ptr @HashMap_B_map_fFunctionT_to_U, ptr @HashMap_B_filter_fFunctionT_to_Ptri1, ptr @HashMap_B_chain_otherIterable2T, ptr @HashMap_B_interleave_otherIterable2T, ptr @HashMap_B_zip_otherIterable2U, ptr @HashMap_B_product_otherIterable2U, ptr @HashMap__Self_max_displacements_, ptr @HashMap_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1, ptr @HashMap_hash1_keyK, ptr @HashMap_hash2_from_primary_primary_hashPtri32, ptr @HashMap_index1_primary_hashPtri32, ptr @HashMap_index2_primary_hashPtri32, ptr @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32, ptr @HashMap_resize_, ptr @HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @HashMap_insert_keyK_valueV, ptr @HashMap_get_keyK, ptr @HashMap_remove_keyK, ptr @HashMap_clear_, ptr @HashMap_size_, ptr @HashMap_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @HashMap_field_HashMap_2, ptr @HashMap_B_iterator_, ptr @HashMap_B_each_fFunctionT_to_Nothing, ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @HashMap_B_all_fFunctionT_to_Ptri1, ptr @HashMap_B_any_fFunctionT_to_Ptri1, ptr @HashMap_B_map_fFunctionT_to_U, ptr @HashMap_B_filter_fFunctionT_to_Ptri1, ptr @HashMap_B_chain_otherIterable2T, ptr @HashMap_B_interleave_otherIterable2T, ptr @HashMap_B_zip_otherIterable2U, ptr @HashMap_B_product_otherIterable2U, ptr @HashMap_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@HashMapIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @HashMapIterator, ptr null, ptr @Iterator2, ptr null]
@HashMapIterator_offset_tbl = constant [8 x i32] [i32 27, i32 10, i32 0, i32 27, i32 10, i32 0, i32 24, i32 0]
@HashMapIterator = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 -704669437586349537, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @HashMapIterator_hashtbl, ptr @HashMapIterator_offset_tbl, ptr @_data_size_HashMapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @HashMapIterator_field_HashMapIterator_0, ptr @HashMapIterator_field_HashMapIterator_1, ptr @HashMapIterator_field_HashMapIterator_2, ptr @HashMapIterator_field_map_table1, ptr @HashMapIterator_field_map_table2, ptr @HashMapIterator_field_table_len, ptr @HashMapIterator_field_index, ptr @HashMapIterator_field_on_second, ptr @HashMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_lenPtri32, ptr @HashMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil, ptr @HashMapIterator_B_next_, ptr @HashMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_lenPtri32, ptr @HashMapIterator_next_from_table_tableBufferEntryK._V_or_Nil, ptr @HashMapIterator_next_, ptr @HashMapIterator_field_HashMapIterator_2, ptr @HashMapIterator_B_next_, ptr @HashMapIterator_next_] }
@Entry_field_primary_hash = internal constant { ptr, ptr } { ptr @Entry_getter_primary_hash, ptr @Entry_setter_primary_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@HashMap_field_table1 = internal constant { ptr, ptr } { ptr @HashMap_getter_table1, ptr @HashMap_setter_table1 }
@HashMap_field_table2 = internal constant { ptr, ptr } { ptr @HashMap_getter_table2, ptr @HashMap_setter_table2 }
@HashMap_field_table_len = internal constant { ptr, ptr } { ptr @HashMap_getter_table_len, ptr @HashMap_setter_table_len }
@HashMap_field_size = internal constant { ptr, ptr } { ptr @HashMap_getter_size, ptr @HashMap_setter_size }
@HashMap_field_hasher = internal constant { ptr, ptr } { ptr @HashMap_getter_hasher, ptr @HashMap_setter_hasher }
@HashMap_field_eq = internal constant { ptr, ptr } { ptr @HashMap_getter_eq, ptr @HashMap_setter_eq }
@HashMapIterator_field_map_table1 = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_map_table1, ptr @HashMapIterator_setter_map_table1 }
@HashMapIterator_field_map_table2 = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_map_table2, ptr @HashMapIterator_setter_map_table2 }
@HashMapIterator_field_table_len = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_table_len, ptr @HashMapIterator_setter_table_len }
@HashMapIterator_field_index = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_index, ptr @HashMapIterator_setter_index }
@HashMapIterator_field_on_second = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_on_second, ptr @HashMapIterator_setter_on_second }
@_parameterization_Ptri1 = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 10, i32 0]
@Pair = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_init_firstT_secondU, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_] }
@Container_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container]
@Container_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Container = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 9056556090793359372, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Container_hashtbl, ptr @Container_offset_tbl, ptr @_data_size_Container, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator2_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Iterator2, ptr @Container]
@Iterator2_offset_tbl = constant [4 x i32] [i32 13, i32 10, i32 10, i32 13]
@Iterator2 = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 4189192806087951739, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator2_hashtbl, ptr @Iterator2_offset_tbl, ptr @_data_size_Iterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable2_hashtbl = constant [4 x ptr] [ptr @Iterable2, ptr @any_typ, ptr @Container, ptr @Object]
@Iterable2_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 33, i32 33]
@Iterable2 = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5693646204635713916, i64 4611686018427388349, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable2_hashtbl, ptr @Iterable2_offset_tbl, ptr @_data_size_Iterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Array_hashtbl = constant [8 x ptr] [ptr @Container, ptr null, ptr @Iterable2, ptr @Object, ptr @any_typ, ptr null, ptr null, ptr @Array]
@Array_offset_tbl = constant [8 x i32] [i32 85, i32 0, i32 62, i32 85, i32 10, i32 0, i32 0, i32 10]
@Array = constant { [3 x i64], [7 x ptr], [75 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427388289, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_data_size_Array, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [75 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_B__Self_from_iterable_iterableIterable2T, ptr @Array_B_init_, ptr @Array_B_init_capacityPtri32, ptr @Array_B_init_lengthPtri32_capacityPtri32, ptr @Array_B_length_, ptr @Array_B_capacity_, ptr @Array_B_append_xT, ptr @Array_B_reserve_new_capacityPtri32, ptr @Array_B__index_xPtri32, ptr @Array_B__set_index_xPtri32_valueT, ptr @Array_B_throw_oob_xPtri32, ptr @Array_B_unchecked_index_xPtri32, ptr @Array_B_unchecked_insert_xPtri32_valueT, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Ptri1, ptr @Array_B_any_fFunctionT_to_Ptri1, ptr @Array_B_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Ptri1, ptr @Array_B_chain_otherIterable2T, ptr @Array_B_interleave_otherIterable2T, ptr @Array_B_zip_otherIterable2U, ptr @Array_B_product_otherIterable2U, ptr @Array__Self_from_iterable_iterableIterable2T, ptr @Array_init_, ptr @Array_init_capacityPtri32, ptr @Array_init_lengthPtri32_capacityPtri32, ptr @Array_length_, ptr @Array_capacity_, ptr @Array_append_xT, ptr @Array_reserve_new_capacityPtri32, ptr @Array__index_xPtri32, ptr @Array__set_index_xPtri32_valueT, ptr @Array_throw_oob_xPtri32, ptr @Array_unchecked_index_xPtri32, ptr @Array_unchecked_insert_xPtri32_valueT, ptr @Array_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Ptri1, ptr @Array_B_any_fFunctionT_to_Ptri1, ptr @Array_B_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Ptri1, ptr @Array_B_chain_otherIterable2T, ptr @Array_B_interleave_otherIterable2T, ptr @Array_B_zip_otherIterable2U, ptr @Array_B_product_otherIterable2U, ptr @Array_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ArrayIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @ArrayIterator, ptr null, ptr @Iterator2, ptr null]
@ArrayIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 10, i32 0, i32 17, i32 0]
@ArrayIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_data_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@MapIterable2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @MapIterable2, ptr @Container, ptr null, ptr @Iterable2, ptr null, ptr null]
@MapIterable2_offset_tbl = constant [8 x i32] [i32 61, i32 10, i32 10, i32 61, i32 0, i32 38, i32 0, i32 0]
@MapIterable2 = constant { [3 x i64], [7 x ptr], [51 x ptr] } { [3 x i64] [i64 -1724859134596891929, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterable2_hashtbl, ptr @MapIterable2_offset_tbl, ptr @_data_size_MapIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [51 x ptr] [ptr @MapIterable2_field_MapIterable2_0, ptr @MapIterable2_field_MapIterable2_1, ptr @MapIterable2_field_iterable, ptr @MapIterable2_field_f, ptr @MapIterable2_B_init_iterableIterable2T_fFunctionT_to_U, ptr @MapIterable2_B_iterator_, ptr @MapIterable2_B_each_fFunctionT_to_Nothing, ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable2_B_all_fFunctionT_to_Ptri1, ptr @MapIterable2_B_any_fFunctionT_to_Ptri1, ptr @MapIterable2_B_map_fFunctionT_to_U, ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1, ptr @MapIterable2_B_chain_otherIterable2T, ptr @MapIterable2_B_interleave_otherIterable2T, ptr @MapIterable2_B_zip_otherIterable2U, ptr @MapIterable2_B_product_otherIterable2U, ptr @MapIterable2_init_iterableIterable2T_fFunctionT_to_U, ptr @MapIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @MapIterable2_field_MapIterable2_1, ptr @MapIterable2_B_iterator_, ptr @MapIterable2_B_each_fFunctionT_to_Nothing, ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable2_B_all_fFunctionT_to_Ptri1, ptr @MapIterable2_B_any_fFunctionT_to_Ptri1, ptr @MapIterable2_B_map_fFunctionT_to_U, ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1, ptr @MapIterable2_B_chain_otherIterable2T, ptr @MapIterable2_B_interleave_otherIterable2T, ptr @MapIterable2_B_zip_otherIterable2U, ptr @MapIterable2_B_product_otherIterable2U, ptr @MapIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@MapIterator2_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @MapIterator2, ptr null, ptr @Object, ptr @Iterator2, ptr null, ptr @any_typ]
@MapIterator2_offset_tbl = constant [8 x i32] [i32 0, i32 21, i32 10, i32 0, i32 21, i32 18, i32 0, i32 10]
@MapIterator2 = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -10255947709272500, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterator2_hashtbl, ptr @MapIterator2_offset_tbl, ptr @_data_size_MapIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @MapIterator2_field_MapIterator2_0, ptr @MapIterator2_field_MapIterator2_1, ptr @MapIterator2_field_iterator, ptr @MapIterator2_field_f, ptr @MapIterator2_B_init_iteratorIterator2T_fFunctionT_to_U, ptr @MapIterator2_B_next_, ptr @MapIterator2_init_iteratorIterator2T_fFunctionT_to_U, ptr @MapIterator2_next_, ptr @MapIterator2_field_MapIterator2_1, ptr @MapIterator2_B_next_, ptr @MapIterator2_next_] }
@FilterIterable2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable2, ptr @FilterIterable2, ptr null]
@FilterIterable2_offset_tbl = constant [8 x i32] [i32 60, i32 10, i32 0, i32 60, i32 0, i32 37, i32 10, i32 0]
@FilterIterable2 = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 1178467452958968374, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterable2_hashtbl, ptr @FilterIterable2_offset_tbl, ptr @_data_size_FilterIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @FilterIterable2_field_FilterIterable2_0, ptr @FilterIterable2_field_iterable, ptr @FilterIterable2_field_f, ptr @FilterIterable2_B_init_iterableIterable2T_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_iterator_, ptr @FilterIterable2_B_each_fFunctionT_to_Nothing, ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_map_fFunctionT_to_U, ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_chain_otherIterable2T, ptr @FilterIterable2_B_interleave_otherIterable2T, ptr @FilterIterable2_B_zip_otherIterable2U, ptr @FilterIterable2_B_product_otherIterable2U, ptr @FilterIterable2_init_iterableIterable2T_fFunctionT_to_Ptri1, ptr @FilterIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @FilterIterable2_field_FilterIterable2_0, ptr @FilterIterable2_B_iterator_, ptr @FilterIterable2_B_each_fFunctionT_to_Nothing, ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_map_fFunctionT_to_U, ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_chain_otherIterable2T, ptr @FilterIterable2_B_interleave_otherIterable2T, ptr @FilterIterable2_B_zip_otherIterable2U, ptr @FilterIterable2_B_product_otherIterable2U, ptr @FilterIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@FilterIterator2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @FilterIterator2, ptr @Container, ptr null, ptr null, ptr @Iterator2, ptr null]
@FilterIterator2_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 10, i32 20, i32 0, i32 0, i32 17, i32 0]
@FilterIterator2 = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 8213847504843366470, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterator2_hashtbl, ptr @FilterIterator2_offset_tbl, ptr @_data_size_FilterIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @FilterIterator2_field_FilterIterator2_0, ptr @FilterIterator2_field_iterator, ptr @FilterIterator2_field_f, ptr @FilterIterator2_B_init_iteratorIterator2T_fFunctionT_to_Ptri1, ptr @FilterIterator2_B_next_, ptr @FilterIterator2_init_iteratorIterator2T_fFunctionT_to_Ptri1, ptr @FilterIterator2_next_, ptr @FilterIterator2_field_FilterIterator2_0, ptr @FilterIterator2_B_next_, ptr @FilterIterator2_next_] }
@ChainIterable2_hashtbl = constant [8 x ptr] [ptr @ChainIterable2, ptr @Object, ptr @any_typ, ptr null, ptr null, ptr @Container, ptr null, ptr @Iterable2]
@ChainIterable2_offset_tbl = constant [8 x i32] [i32 10, i32 60, i32 10, i32 0, i32 0, i32 60, i32 0, i32 37]
@ChainIterable2 = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 -5233298072945030060, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterable2_hashtbl, ptr @ChainIterable2_offset_tbl, ptr @_data_size_ChainIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @ChainIterable2_field_ChainIterable2_0, ptr @ChainIterable2_field_first, ptr @ChainIterable2_field_second, ptr @ChainIterable2_B_init_firstIterable2T_secondIterable2T, ptr @ChainIterable2_B_iterator_, ptr @ChainIterable2_B_each_fFunctionT_to_Nothing, ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_map_fFunctionT_to_U, ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_chain_otherIterable2T, ptr @ChainIterable2_B_interleave_otherIterable2T, ptr @ChainIterable2_B_zip_otherIterable2U, ptr @ChainIterable2_B_product_otherIterable2U, ptr @ChainIterable2_init_firstIterable2T_secondIterable2T, ptr @ChainIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ChainIterable2_field_ChainIterable2_0, ptr @ChainIterable2_B_iterator_, ptr @ChainIterable2_B_each_fFunctionT_to_Nothing, ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_map_fFunctionT_to_U, ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_chain_otherIterable2T, ptr @ChainIterable2_B_interleave_otherIterable2T, ptr @ChainIterable2_B_zip_otherIterable2U, ptr @ChainIterable2_B_product_otherIterable2U, ptr @ChainIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ChainIterator2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr null, ptr @Iterator2, ptr @ChainIterator2]
@ChainIterator2_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 0, i32 21, i32 0, i32 0, i32 18, i32 10]
@ChainIterator2 = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -228267985060461774, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterator2_hashtbl, ptr @ChainIterator2_offset_tbl, ptr @_data_size_ChainIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @ChainIterator2_field_ChainIterator2_0, ptr @ChainIterator2_field_first, ptr @ChainIterator2_field_second, ptr @ChainIterator2_field_on_first, ptr @ChainIterator2_B_init_firstIterator2T_secondIterator2T, ptr @ChainIterator2_B_next_, ptr @ChainIterator2_init_firstIterator2T_secondIterator2T, ptr @ChainIterator2_next_, ptr @ChainIterator2_field_ChainIterator2_0, ptr @ChainIterator2_B_next_, ptr @ChainIterator2_next_] }
@InterleaveIterable2_hashtbl = constant [8 x ptr] [ptr @Iterable2, ptr null, ptr null, ptr @InterleaveIterable2, ptr @any_typ, ptr @Object, ptr null, ptr @Container]
@InterleaveIterable2_offset_tbl = constant [8 x i32] [i32 37, i32 0, i32 0, i32 10, i32 10, i32 60, i32 0, i32 60]
@InterleaveIterable2 = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 -6258231685215461775, i64 4611686018427388207, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterable2_hashtbl, ptr @InterleaveIterable2_offset_tbl, ptr @_data_size_InterleaveIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @InterleaveIterable2_field_InterleaveIterable2_0, ptr @InterleaveIterable2_field_first, ptr @InterleaveIterable2_field_second, ptr @InterleaveIterable2_B_init_firstIterable2T_secondIterable2T, ptr @InterleaveIterable2_B_iterator_, ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_map_fFunctionT_to_U, ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_chain_otherIterable2T, ptr @InterleaveIterable2_B_interleave_otherIterable2T, ptr @InterleaveIterable2_B_zip_otherIterable2U, ptr @InterleaveIterable2_B_product_otherIterable2U, ptr @InterleaveIterable2_init_firstIterable2T_secondIterable2T, ptr @InterleaveIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @InterleaveIterable2_field_InterleaveIterable2_0, ptr @InterleaveIterable2_B_iterator_, ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_map_fFunctionT_to_U, ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_chain_otherIterable2T, ptr @InterleaveIterable2_B_interleave_otherIterable2T, ptr @InterleaveIterable2_B_zip_otherIterable2U, ptr @InterleaveIterable2_B_product_otherIterable2U, ptr @InterleaveIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@InterleaveIterator2_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr null, ptr @InterleaveIterator2, ptr @Container, ptr null, ptr @Iterator2, ptr @Object]
@InterleaveIterator2_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 0, i32 10, i32 21, i32 0, i32 18, i32 21]
@InterleaveIterator2 = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6709847746581360093, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterator2_hashtbl, ptr @InterleaveIterator2_offset_tbl, ptr @_data_size_InterleaveIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @InterleaveIterator2_field_InterleaveIterator2_0, ptr @InterleaveIterator2_field_first, ptr @InterleaveIterator2_field_second, ptr @InterleaveIterator2_field_on_first, ptr @InterleaveIterator2_B_init_firstIterator2T_secondIterator2T, ptr @InterleaveIterator2_B_next_, ptr @InterleaveIterator2_init_firstIterator2T_secondIterator2T, ptr @InterleaveIterator2_next_, ptr @InterleaveIterator2_field_InterleaveIterator2_0, ptr @InterleaveIterator2_B_next_, ptr @InterleaveIterator2_next_] }
@ZipIterable2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @ZipIterable2, ptr @Container, ptr null, ptr @Iterable2, ptr null, ptr null]
@ZipIterable2_offset_tbl = constant [8 x i32] [i32 62, i32 10, i32 10, i32 62, i32 0, i32 39, i32 0, i32 0]
@ZipIterable2 = constant { [3 x i64], [7 x ptr], [52 x ptr] } { [3 x i64] [i64 -3218950579047519815, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterable2_hashtbl, ptr @ZipIterable2_offset_tbl, ptr @_data_size_ZipIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [52 x ptr] [ptr @ZipIterable2_field_ZipIterable2_0, ptr @ZipIterable2_field_ZipIterable2_1, ptr @ZipIterable2_field_ZipIterable2_2, ptr @ZipIterable2_field_first, ptr @ZipIterable2_field_second, ptr @ZipIterable2_B_init_firstIterable2T_secondIterable2U, ptr @ZipIterable2_B_iterator_, ptr @ZipIterable2_B_each_fFunctionT_to_Nothing, ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_map_fFunctionT_to_U, ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_chain_otherIterable2T, ptr @ZipIterable2_B_interleave_otherIterable2T, ptr @ZipIterable2_B_zip_otherIterable2U, ptr @ZipIterable2_B_product_otherIterable2U, ptr @ZipIterable2_init_firstIterable2T_secondIterable2U, ptr @ZipIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ZipIterable2_field_ZipIterable2_2, ptr @ZipIterable2_B_iterator_, ptr @ZipIterable2_B_each_fFunctionT_to_Nothing, ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_map_fFunctionT_to_U, ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_chain_otherIterable2T, ptr @ZipIterable2_B_interleave_otherIterable2T, ptr @ZipIterable2_B_zip_otherIterable2U, ptr @ZipIterable2_B_product_otherIterable2U, ptr @ZipIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ZipIterator2_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr null, ptr @ZipIterator2, ptr @Container, ptr null, ptr @Iterator2, ptr @Object]
@ZipIterator2_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 0, i32 10, i32 22, i32 0, i32 19, i32 22]
@ZipIterator2 = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 5502728639611621286, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterator2_hashtbl, ptr @ZipIterator2_offset_tbl, ptr @_data_size_ZipIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @ZipIterator2_field_ZipIterator2_0, ptr @ZipIterator2_field_ZipIterator2_1, ptr @ZipIterator2_field_ZipIterator2_2, ptr @ZipIterator2_field_first, ptr @ZipIterator2_field_second, ptr @ZipIterator2_B_init_firstIterator2T_secondIterator2U, ptr @ZipIterator2_B_next_, ptr @ZipIterator2_init_firstIterator2T_secondIterator2U, ptr @ZipIterator2_next_, ptr @ZipIterator2_field_ZipIterator2_2, ptr @ZipIterator2_B_next_, ptr @ZipIterator2_next_] }
@ProductIterable2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable2, ptr @ProductIterable2, ptr null]
@ProductIterable2_offset_tbl = constant [8 x i32] [i32 62, i32 10, i32 0, i32 62, i32 0, i32 39, i32 10, i32 0]
@ProductIterable2 = constant { [3 x i64], [7 x ptr], [52 x ptr] } { [3 x i64] [i64 7827074759551300494, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterable2_hashtbl, ptr @ProductIterable2_offset_tbl, ptr @_data_size_ProductIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [52 x ptr] [ptr @ProductIterable2_field_ProductIterable2_0, ptr @ProductIterable2_field_ProductIterable2_1, ptr @ProductIterable2_field_ProductIterable2_2, ptr @ProductIterable2_field_first, ptr @ProductIterable2_field_second, ptr @ProductIterable2_B_init_firstIterable2T_secondIterable2U, ptr @ProductIterable2_B_iterator_, ptr @ProductIterable2_B_each_fFunctionT_to_Nothing, ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_map_fFunctionT_to_U, ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_chain_otherIterable2T, ptr @ProductIterable2_B_interleave_otherIterable2T, ptr @ProductIterable2_B_zip_otherIterable2U, ptr @ProductIterable2_B_product_otherIterable2U, ptr @ProductIterable2_init_firstIterable2T_secondIterable2U, ptr @ProductIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ProductIterable2_field_ProductIterable2_2, ptr @ProductIterable2_B_iterator_, ptr @ProductIterable2_B_each_fFunctionT_to_Nothing, ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_map_fFunctionT_to_U, ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_chain_otherIterable2T, ptr @ProductIterable2_B_interleave_otherIterable2T, ptr @ProductIterable2_B_zip_otherIterable2U, ptr @ProductIterable2_B_product_otherIterable2U, ptr @ProductIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ProductIterator2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @ProductIterator2, ptr @Iterator2, ptr null]
@ProductIterator2_offset_tbl = constant [8 x i32] [i32 24, i32 10, i32 0, i32 24, i32 0, i32 10, i32 21, i32 0]
@ProductIterator2 = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 4440657219728359865, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterator2_hashtbl, ptr @ProductIterator2_offset_tbl, ptr @_data_size_ProductIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @ProductIterator2_field_ProductIterator2_0, ptr @ProductIterator2_field_ProductIterator2_1, ptr @ProductIterator2_field_ProductIterator2_2, ptr @ProductIterator2_field_first_iterator, ptr @ProductIterator2_field_second_iterator, ptr @ProductIterator2_field_second_iterable, ptr @ProductIterator2_field_current_first, ptr @ProductIterator2_B_init_first_iteratorIterator2T_second_iterableIterable2U, ptr @ProductIterator2_B_next_, ptr @ProductIterator2_init_first_iteratorIterator2T_second_iterableIterable2U, ptr @ProductIterator2_next_, ptr @ProductIterator2_field_ProductIterator2_2, ptr @ProductIterator2_B_next_, ptr @ProductIterator2_next_] }
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@MapIterable2_field_iterable = internal constant { ptr, ptr } { ptr @MapIterable2_getter_iterable, ptr @MapIterable2_setter_iterable }
@MapIterable2_field_f = internal constant { ptr, ptr } { ptr @MapIterable2_getter_f, ptr @MapIterable2_setter_f }
@MapIterator2_field_iterator = internal constant { ptr, ptr } { ptr @MapIterator2_getter_iterator, ptr @MapIterator2_setter_iterator }
@MapIterator2_field_f = internal constant { ptr, ptr } { ptr @MapIterator2_getter_f, ptr @MapIterator2_setter_f }
@FilterIterable2_field_iterable = internal constant { ptr, ptr } { ptr @FilterIterable2_getter_iterable, ptr @FilterIterable2_setter_iterable }
@FilterIterable2_field_f = internal constant { ptr, ptr } { ptr @FilterIterable2_getter_f, ptr @FilterIterable2_setter_f }
@FilterIterator2_field_iterator = internal constant { ptr, ptr } { ptr @FilterIterator2_getter_iterator, ptr @FilterIterator2_setter_iterator }
@FilterIterator2_field_f = internal constant { ptr, ptr } { ptr @FilterIterator2_getter_f, ptr @FilterIterator2_setter_f }
@ChainIterable2_field_first = internal constant { ptr, ptr } { ptr @ChainIterable2_getter_first, ptr @ChainIterable2_setter_first }
@ChainIterable2_field_second = internal constant { ptr, ptr } { ptr @ChainIterable2_getter_second, ptr @ChainIterable2_setter_second }
@ChainIterator2_field_first = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_first, ptr @ChainIterator2_setter_first }
@ChainIterator2_field_second = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_second, ptr @ChainIterator2_setter_second }
@ChainIterator2_field_on_first = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_on_first, ptr @ChainIterator2_setter_on_first }
@InterleaveIterable2_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterable2_getter_first, ptr @InterleaveIterable2_setter_first }
@InterleaveIterable2_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterable2_getter_second, ptr @InterleaveIterable2_setter_second }
@InterleaveIterator2_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_first, ptr @InterleaveIterator2_setter_first }
@InterleaveIterator2_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_second, ptr @InterleaveIterator2_setter_second }
@InterleaveIterator2_field_on_first = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_on_first, ptr @InterleaveIterator2_setter_on_first }
@ZipIterable2_field_first = internal constant { ptr, ptr } { ptr @ZipIterable2_getter_first, ptr @ZipIterable2_setter_first }
@ZipIterable2_field_second = internal constant { ptr, ptr } { ptr @ZipIterable2_getter_second, ptr @ZipIterable2_setter_second }
@ZipIterator2_field_first = internal constant { ptr, ptr } { ptr @ZipIterator2_getter_first, ptr @ZipIterator2_setter_first }
@ZipIterator2_field_second = internal constant { ptr, ptr } { ptr @ZipIterator2_getter_second, ptr @ZipIterator2_setter_second }
@ProductIterable2_field_first = internal constant { ptr, ptr } { ptr @ProductIterable2_getter_first, ptr @ProductIterable2_setter_first }
@ProductIterable2_field_second = internal constant { ptr, ptr } { ptr @ProductIterable2_getter_second, ptr @ProductIterable2_setter_second }
@ProductIterator2_field_first_iterator = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_first_iterator, ptr @ProductIterator2_setter_first_iterator }
@ProductIterator2_field_second_iterator = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_second_iterator, ptr @ProductIterator2_setter_second_iterator }
@ProductIterator2_field_second_iterable = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_second_iterable, ptr @ProductIterator2_setter_second_iterable }
@ProductIterator2_field_current_first = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_current_first, ptr @ProductIterator2_setter_current_first }
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@Iterator_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Iterator]
@Iterator_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@Iterable_hashtbl = constant [4 x ptr] [ptr null, ptr @Iterable, ptr @any_typ, ptr @Object]
@Iterable_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 12]
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 12]
@String_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @String, ptr @Representable, ptr @Object, ptr null, ptr null, ptr @Iterable]
@String_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 10, i32 43, i32 43, i32 0, i32 0, i32 41]
@Character_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = constant [4 x i32] [i32 15, i32 0, i32 10, i32 10]
@StringIterator_hashtbl = constant [4 x ptr] [ptr @StringIterator, ptr @Object, ptr @any_typ, ptr @Iterator]
@StringIterator_offset_tbl = constant [4 x i32] [i32 10, i32 16, i32 10, i32 16]
@Exception_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = constant [4 x i32] [i32 23, i32 0, i32 10, i32 10]
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_length = internal constant { ptr, ptr } { ptr @String_getter_length, ptr @String_setter_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_byte = internal constant { ptr, ptr } { ptr @Character_getter_byte, ptr @Character_setter_byte }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_index, ptr @StringIterator_setter_index }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@_parameterization_Ptri32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@i128_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -8755878215469463641, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i128_typ_hashtbl, ptr @i128_typ_offset_tbl, ptr @_data_size_i128_typ, ptr @_box_i128_typ, ptr @_unbox_i128_typ, ptr @_data_size_i128_typ], [0 x ptr] undef }
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@nothing_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -3334456163433371378, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @nothing_typ_hashtbl, ptr @nothing_typ_offset_tbl, ptr @_data_size_nothing_typ, ptr @_box_nothing_typ, ptr @_unbox_nothing_typ, ptr @_data_size_nothing_typ], [0 x ptr] undef }
@coroutine_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7194361020959218064, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @coroutine_typ_hashtbl, ptr @coroutine_typ_offset_tbl, ptr @_data_size_coroutine_typ, ptr @_box_coroutine_typ, ptr @_unbox_coroutine_typ, ptr @_data_size_coroutine_typ], [0 x ptr] undef }
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@tuple_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3422634369532007740, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @tuple_typ_hashtbl, ptr @tuple_typ_offset_tbl, ptr @_data_size_tuple_typ, ptr @_box_tuple_typ, ptr @_unbox_tuple_typ, ptr @_data_size_tuple_typ], [0 x ptr] undef }
@union_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7543233778997666740, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @union_typ_hashtbl, ptr @union_typ_offset_tbl, ptr @_data_size_union_typ, ptr @_box_union_typ, ptr @_unbox_union_typ, ptr @_data_size_union_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@String = constant { [3 x i64], [7 x ptr], [35 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427388073, i64 7], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [35 x ptr] [ptr @String_field_bytes, ptr @String_field_length, ptr @String_field_capacity, ptr @String_B_init_, ptr @String_B_init_bytesBufferPtri8_lengthPtri32_capacityPtri32, ptr @String_B_length_, ptr @String_B_capacity_, ptr @String_B_bytes_, ptr @String_B_append_xPtri8, ptr @String_B_extend_strString, ptr @String_B__index_xPtri32, ptr @String_B__EQ_otherString, ptr @String_B_pop_, ptr @String_B_copy_, ptr @String_B_c_string_, ptr @String_B_iterator_, ptr @String_B_repr_, ptr @String_init_, ptr @String_init_bytesBufferPtri8_lengthPtri32_capacityPtri32, ptr @String_length_, ptr @String_capacity_, ptr @String_bytes_, ptr @String_append_xPtri8, ptr @String_extend_strString, ptr @String__index_xPtri32, ptr @String__EQ_otherString, ptr @String_pop_, ptr @String_copy_, ptr @String_c_string_, ptr @String_iterator_, ptr @String_repr_, ptr @String_B_iterator_, ptr @String_iterator_, ptr @String_B_repr_, ptr @String_repr_] }
@Character = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @Character_field_byte, ptr @Character_B_byte_, ptr @Character_B_init_bytePtri8, ptr @Character_byte_, ptr @Character_init_bytePtri8] }
@StringIterator = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_index, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_] }
@Exception = constant { [3 x i64], [7 x ptr], [13 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [13 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberPtri32_file_nameString, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberPtri32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@IO_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 20]
@IO = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_data_size_IO, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @IO_B__Self_print_xNil__Self_print_xPtrf64__Self_print_xRepresentable__Self_print_xString__Self_print_xPtri32__Self_print_xPtri1__Self_print_xPtri64__Self_print_xCharacter__Self_print_xPtri8, ptr @IO__Self_print_xNil, ptr @IO__Self_print_xPtrf64, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xString, ptr @IO__Self_print_xPtri32, ptr @IO__Self_print_xPtri1, ptr @IO__Self_print_xPtri64, ptr @IO__Self_print_xCharacter, ptr @IO__Self_print_xPtri8] }
@string_string.95 = internal constant [4 x i8] c"%s\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local local_unnamed_addr global ptr null
@always_one = linkonce thread_local local_unnamed_addr global i1 true
@current_ptr = internal thread_local global ptr null

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_PRNG(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @PRNG_init_initial_seedPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %. = tail call i32 @llvm.smax.i32(i32 %3, i32 1)
  tail call void %10(ptr %.fca.1.extract, i32 %.) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !4
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i32 %8(ptr %.fca.1.extract) #36
  %10 = mul i32 %9, 1103515245
  %11 = add i32 %10, 12345
  %12 = and i32 %11, 2147483647
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 %12) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %17 = load ptr, ptr %6, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call i32 %18(ptr %.fca.1.extract) #36
  ret i32 %19
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

define i1 @jtsshqxerx(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @sshndfvtsv(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @vdgbvvguid(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @zbeuwobpin(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ublvkccrts(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @hcbtagnexk(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @axlszbyysq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @zatzdtouuc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @nzoueoxdzd(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @wvqrefvxqs(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @jflfzrlbri(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @fxudcdkewt(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ozgljpgafu(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @mcvhackynz(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ujjpaegnhk(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @mopmykeazj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @fsgroehfsq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @bnhzmayidc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @kbsaabmajz(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @newiwemfnz(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

; Function Attrs: nounwind
define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !7
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !7
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !7
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !7
  %4 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %5 = ptrtoint ptr %.fca.1.extract to i64
  %6 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i.i to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %6 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext237 = zext i64 %5 to i160
  %.sroa.3.8.insert.insert238 = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext237
  %7 = insertvalue { ptr, i160 } %4, i160 %.sroa.3.8.insert.insert238, 1
  %8 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8) #34
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %13 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %14 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %result.i.i = tail call i1 %15(i64 %14, i64 %13, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %16) #5
  %result.i14.i = tail call i1 %15(i64 %14, i64 %13, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %16) #5
  %not.result.i.i = xor i1 %result.i.i, true
  %.reg2mem47.0.i = select i1 %not.result.i.i, i1 true, i1 %result.i14.i
  br i1 %.reg2mem47.0.i, label %17, label %._crit_edge.lr.ph.i

17:                                               ; preds = %3
  %18 = icmp eq ptr %.fca.0.extract, @i64_typ
  br i1 %18, label %._crit_edge.lr.ph.i, label %19

19:                                               ; preds = %17
  %20 = icmp eq ptr %.fca.0.extract, @i8_typ
  br i1 %20, label %._crit_edge.lr.ph.i, label %21

21:                                               ; preds = %19
  %22 = icmp eq ptr %.fca.0.extract, @nil_typ
  %23 = icmp eq ptr %.fca.0.extract, null
  %24 = or i1 %22, %23
  br i1 %24, label %._crit_edge.lr.ph.i, label %25

25:                                               ; preds = %21
  %result.i15.i = tail call i1 %15(i64 %14, i64 %13, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %16) #5
  %result.i15.not.i = xor i1 %result.i15.i, true
  %.reg2mem45.0.i = or i1 %result.i.i, %result.i14.i
  %or.cond.i = select i1 %result.i15.not.i, i1 true, i1 %.reg2mem45.0.i
  br i1 %or.cond.i, label %.critedge.i, label %._crit_edge.lr.ph.i

.critedge.i:                                      ; preds = %25
  %26 = icmp eq ptr %.fca.0.extract, @bool_typ
  br i1 %26, label %._crit_edge.lr.ph.i, label %27

27:                                               ; preds = %.critedge.i
  %not.result.i14.i = xor i1 %result.i14.i, true
  %.reg2mem41.0.i = or i1 %result.i.i, %not.result.i14.i
  %28 = icmp eq ptr %.fca.0.extract, @i32_typ
  %29 = select i1 %28, i32 5, i32 2
  %.reg2mem39.0.i = select i1 %.reg2mem41.0.i, i32 %29, i32 4
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %27, %.critedge.i, %25, %21, %19, %17, %3
  %.reg2mem27.0.i = phi i32 [ 7, %17 ], [ 9, %19 ], [ 1, %21 ], [ %.reg2mem39.0.i, %27 ], [ 6, %.critedge.i ], [ 8, %3 ], [ 3, %25 ]
  %30 = zext nneg i32 %.reg2mem27.0.i to i64
  %31 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %30
  %32 = getelementptr i8, ptr %31, i64 80
  %33 = load ptr, ptr %32, align 8
  call void %33(ptr nonnull align 8 dereferenceable(8) %8, { ptr, i160 } %7) #7
  %result.i97 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97, align 16
  %result.i.i376 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376, ptr noundef nonnull align 16 dereferenceable(14) %result.i97, i64 14, i1 false)
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376)
  %34 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1) #16
  %result.i103 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103, align 16
  %result.i.i390 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390, ptr noundef nonnull align 16 dereferenceable(14) %result.i103, i64 14, i1 false)
  %puts.i314 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390)
  %35 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2) #16
  %result.i109 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109, align 4
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i409 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409, ptr noundef nonnull align 4 dereferenceable(3) %result.i109, i64 3, i1 false)
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i334 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409)
  %38 = icmp sgt i32 %1, 0
  br i1 %38, label %._crit_edge1, label %._crit_edge

._crit_edge1:                                     ; preds = %._crit_edge.lr.ph.i
  %39 = icmp sgt i64 %2, 0
  br i1 %39, label %40, label %._crit_edge.lr.ph.i429

40:                                               ; preds = %._crit_edge1
  %41 = zext nneg i32 %1 to i64
  %42 = mul i64 %2, 1000000
  %43 = sdiv i64 %42, %41
  br label %._crit_edge.lr.ph.i429

._crit_edge.lr.ph.i429:                           ; preds = %40, %._crit_edge1
  %.0 = phi i64 [ %43, %40 ], [ 0, %._crit_edge1 ]
  %result.i114 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114, align 16
  %result.i.i428 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428, ptr noundef nonnull align 16 dereferenceable(15) %result.i114, i64 15, i1 false)
  %puts.i354 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428)
  %44 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0) #16
  %result.i120 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120, align 4
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i447 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447, ptr noundef nonnull align 4 dereferenceable(3) %result.i120, i64 3, i1 false)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i374 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i429
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %oldProtect.i154 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %result.i150 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i150, align 8
  %15 = getelementptr inbounds i8, ptr %result.i150, i64 8
  store ptr @_parameterization_Ptri32, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i150, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i150) #38
  %result.i151 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i152 = call i32 @VirtualProtect(ptr nofree %result.i151, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i151, ptr noalias nofree noundef nonnull readnone @newiwemfnz, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i151) #39
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i151) #38
  %result.i153 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i154)
  %result.i155 = call i32 @VirtualProtect(ptr nofree %result.i153, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i154) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i154)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i153, ptr noalias nofree noundef nonnull readnone @kbsaabmajz, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i156 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i153) #39
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i153) #38
  %20 = getelementptr inbounds i8, ptr %result.i150, i64 48
  store ptr %ret.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i150, i64 56
  store ptr %ret.i156, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i150, i64 40
  store i32 8, ptr %22, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %23 = getelementptr inbounds i8, ptr %result.i150, i64 24
  store ptr %result.i.i, ptr %23, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %24 = getelementptr inbounds i8, ptr %result.i150, i64 32
  store ptr %result.i9.i, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %26 = call i64 @clock()
  %27 = icmp sgt i32 %0, 0
  br i1 %27, label %._crit_edge.preheader, label %1064

._crit_edge.preheader:                            ; preds = %1
  %28 = getelementptr inbounds i8, ptr %result.i150, i64 44
  %29 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i150, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr undef, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 10, 3
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %HashMap_insert_keyK_valueV.exit
  %.0216 = phi i32 [ %32, %HashMap_insert_keyK_valueV.exit ], [ 0, %._crit_edge.preheader ]
  %32 = add nuw nsw i32 %.0216, 1
  %.sroa.0131.0.insert.ext = zext nneg i32 %.0216 to i160
  %33 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0131.0.insert.ext, 1
  %.sroa.0128.0.insert.ext = zext nneg i32 %32 to i160
  %34 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0128.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %35 = load ptr, ptr %result.i150, align 8
  %36 = load ptr, ptr %20, align 8
  %37 = call i32 %36({ ptr, i160 } %33) #7
  %38 = load i32, ptr %22, align 8
  %39 = add i32 %38, -1
  %40 = and i32 %39, %37
  %41 = load ptr, ptr %23, align 8
  %42 = load ptr, ptr %15, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %44 = sext i32 %40 to i64
  %45 = shl nsw i64 %44, 5
  %46 = getelementptr i8, ptr %41, i64 %45
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr i8, ptr %46, i64 8
  %49 = icmp ne ptr %47, @nil_typ
  %50 = icmp ne ptr %47, null
  %.not64.i = and i1 %49, %50
  br i1 %.not64.i, label %51, label %148

51:                                               ; preds = %._crit_edge
  %52 = load i64, ptr %48, align 4
  %.sroa_idx.i = getelementptr i8, ptr %46, i64 16
  %53 = load i64, ptr %.sroa_idx.i, align 4
  %54 = inttoptr i64 %52 to ptr
  %55 = inttoptr i64 %53 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %47, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %47, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %47, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !10
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !10
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !10
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !10
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %54, 1
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %55, 2
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %offset.i.i77.i, 3
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %47) #34
  %62 = sext i32 %offset.i.i77.i to i64
  %63 = getelementptr ptr, ptr %47, i64 %62
  %64 = getelementptr i8, ptr %63, i64 64
  %65 = load ptr, ptr %64, align 8
  %result.i.i399 = call ptr %65({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly %2) #15
  %66 = call i32 %result.i.i399({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 %2) #7
  %67 = icmp eq i32 %66, %37
  br i1 %67, label %._crit_edge.i400, label %148

._crit_edge.i400:                                 ; preds = %51
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %47)
  %70 = getelementptr i8, ptr %63, i64 48
  %71 = load ptr, ptr %70, align 8
  %result.i79.i = call ptr %71({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly %2) #15
  %72 = call { ptr, i160 } %result.i79.i({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 %2) #7
  %73 = load ptr, ptr %21, align 8
  %74 = call i1 %73({ ptr, i160 } %72, { ptr, i160 } %33) #7
  br i1 %74, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %148

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i400
  %75 = load ptr, ptr %result.i150, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %77 = load ptr, ptr %15, align 8
  %78 = load ptr, ptr %75, align 8, !alias.scope !13
  %79 = getelementptr i8, ptr %78, i64 72
  %80 = load ptr, ptr %79, align 8, !alias.scope !13
  %result.i.i.i401 = call { i64, i64 } %80(ptr nocapture nofree nonnull readonly %75) #5, !alias.scope !13
  %81 = extractvalue { i64, i64 } %result.i.i.i401, 0
  %82 = extractvalue { i64, i64 } %result.i.i.i401, 1
  %83 = urem i64 20, %82
  %84 = icmp eq i64 %83, 0
  %85 = sub i64 %82, %83
  %86 = select i1 %84, i64 0, i64 %85
  %87 = add i64 %81, 20
  %88 = add i64 %87, %86
  %89 = load ptr, ptr %77, align 8, !alias.scope !13
  %90 = getelementptr i8, ptr %89, i64 72
  %91 = load ptr, ptr %90, align 8, !alias.scope !13
  %result.i1.i.i402 = call { i64, i64 } %91(ptr nocapture nofree nonnull readonly %77) #5, !alias.scope !13
  %92 = extractvalue { i64, i64 } %result.i1.i.i402, 0
  %93 = extractvalue { i64, i64 } %result.i1.i.i402, 1
  %94 = call i64 @llvm.umax.i64(i64 %82, i64 %93)
  %95 = call i64 @llvm.umax.i64(i64 %94, i64 8)
  %96 = urem i64 %88, %93
  %97 = icmp eq i64 %96, 0
  %98 = sub i64 %93, %96
  %99 = select i1 %97, i64 0, i64 %98
  %100 = add i64 %92, %88
  %101 = add i64 %100, %99
  %102 = urem i64 %101, %95
  %103 = icmp eq i64 %102, 0
  %104 = sub i64 %95, %102
  %105 = select i1 %103, i64 0, i64 %104
  %106 = add i64 %105, %101
  %result.i83.i403 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %106, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %75, ptr %result.i83.i403, align 8
  %107 = getelementptr inbounds i8, ptr %result.i83.i403, i64 8
  store ptr %77, ptr %107, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i403)
  %109 = load ptr, ptr %75, align 8
  %110 = getelementptr i8, ptr %109, i64 72
  %111 = load ptr, ptr %110, align 8
  %result.i.i114.i = call { i64, i64 } %111(ptr nocapture nofree nonnull readonly %75) #5
  %112 = extractvalue { i64, i64 } %result.i.i114.i, 1
  %113 = urem i64 20, %112
  %114 = icmp eq i64 %113, 0
  %reass.sub1446 = sub i64 %112, %113
  %115 = add i64 %reass.sub1446, 20
  %116 = select i1 %114, i64 20, i64 %115
  %117 = getelementptr i8, ptr %result.i83.i403, i64 %116
  %118 = getelementptr i8, ptr %109, i64 64
  %119 = load ptr, ptr %118, align 8
  call void %119({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %75, ptr nocapture nofree writeonly %117) #12
  %120 = load ptr, ptr %result.i83.i403, align 8
  %121 = load ptr, ptr %120, align 8
  %122 = getelementptr i8, ptr %121, i64 72
  %123 = load ptr, ptr %122, align 8
  %result.i.i115.i = call { i64, i64 } %123(ptr nocapture nofree nonnull readonly %120) #5
  %124 = extractvalue { i64, i64 } %result.i.i115.i, 0
  %125 = extractvalue { i64, i64 } %result.i.i115.i, 1
  %126 = urem i64 20, %125
  %127 = icmp eq i64 %126, 0
  %128 = sub i64 %125, %126
  %129 = select i1 %127, i64 0, i64 %128
  %130 = add i64 %124, 20
  %131 = add i64 %130, %129
  %132 = load ptr, ptr %107, align 8
  %133 = load ptr, ptr %132, align 8
  %134 = getelementptr i8, ptr %133, i64 72
  %135 = load ptr, ptr %134, align 8
  %result.i1.i116.i = call { i64, i64 } %135(ptr nocapture nofree nonnull readonly %132) #5
  %136 = extractvalue { i64, i64 } %result.i1.i116.i, 1
  %137 = urem i64 %131, %136
  %138 = icmp eq i64 %137, 0
  %139 = sub i64 %136, %137
  %140 = select i1 %138, i64 0, i64 %139
  %141 = getelementptr i8, ptr %result.i83.i403, i64 %131
  %142 = getelementptr i8, ptr %141, i64 %140
  %143 = getelementptr i8, ptr %133, i64 64
  %144 = load ptr, ptr %143, align 8
  call void %144({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %132, ptr nocapture nofree writeonly %142) #12
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %146 = getelementptr inbounds i8, ptr %result.i83.i403, i64 16
  store i32 %37, ptr %146, align 8
  store ptr @Entry, ptr %46, align 8
  %147 = ptrtoint ptr %result.i83.i403 to i64
  store i64 %147, ptr %48, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %46, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

148:                                              ; preds = %._crit_edge.i400, %._crit_edge, %51
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %149 = add i32 %37, 2127912214
  %150 = shl i32 %37, 12
  %151 = add i32 %149, %150
  %152 = ashr i32 %151, 19
  %153 = xor i32 %151, %152
  %154 = xor i32 %153, -949894596
  %155 = add i32 %154, 374761393
  %156 = shl i32 %154, 5
  %157 = add i32 %155, %156
  %158 = add i32 %157, -744332180
  %159 = shl i32 %157, 9
  %160 = xor i32 %158, %159
  %161 = add i32 %160, -42973499
  %162 = shl i32 %160, 3
  %163 = add i32 %161, %162
  %164 = ashr i32 %163, 16
  %165 = xor i32 %163, %164
  %166 = xor i32 %165, -1252372727
  %167 = load i32, ptr %22, align 8
  %168 = add i32 %167, -1
  %169 = and i32 %168, %166
  %170 = load ptr, ptr %24, align 8
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %172 = sext i32 %169 to i64
  %173 = shl nsw i64 %172, 5
  %174 = getelementptr i8, ptr %170, i64 %173
  %175 = load ptr, ptr %174, align 8
  %176 = getelementptr i8, ptr %174, i64 8
  %177 = icmp ne ptr %175, @nil_typ
  %178 = icmp ne ptr %175, null
  %.not64.i432 = and i1 %177, %178
  br i1 %.not64.i432, label %179, label %276

179:                                              ; preds = %148
  %180 = load i64, ptr %176, align 4
  %.sroa_idx.i434 = getelementptr i8, ptr %174, i64 16
  %181 = load i64, ptr %.sroa_idx.i434, align 4
  %182 = inttoptr i64 %180 to ptr
  %183 = inttoptr i64 %181 to ptr
  %hash_coef_ptr.i.i66.i435 = getelementptr i8, ptr %175, i64 8
  %tbl_size_ptr.i.i67.i436 = getelementptr i8, ptr %175, i64 16
  %offset_tbl_ptr.i.i68.i437 = getelementptr i8, ptr %175, i64 40
  %hash_coef.i.i69.i438 = load i64, ptr %hash_coef_ptr.i.i66.i435, align 4, !noalias !16
  %tbl_size.i.i70.i439 = load i64, ptr %tbl_size_ptr.i.i67.i436, align 4, !noalias !16
  %offset_tbl.i.i71.i440 = load ptr, ptr %offset_tbl_ptr.i.i68.i437, align 8, !noalias !16
  %product.i.i.i72.i441 = mul i64 %hash_coef.i.i69.i438, 4015701072841558310
  %shifted.i.i.i73.i442 = lshr i64 %product.i.i.i72.i441, 32
  %xored.i.i.i74.i443 = xor i64 %shifted.i.i.i73.i442, %product.i.i.i72.i441
  %hash.i.i.i75.i444 = and i64 %xored.i.i.i74.i443, %tbl_size.i.i70.i439
  %offset_ptr.i.i76.i445 = getelementptr i32, ptr %offset_tbl.i.i71.i440, i64 %hash.i.i.i75.i444
  %offset.i.i77.i446 = load i32, ptr %offset_ptr.i.i76.i445, align 4, !noalias !16
  %184 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %175, 0
  %185 = insertvalue { ptr, ptr, ptr, i32 } %184, ptr %182, 1
  %186 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %183, 2
  %187 = insertvalue { ptr, ptr, ptr, i32 } %186, i32 %offset.i.i77.i446, 3
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %189 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %175) #34
  %190 = sext i32 %offset.i.i77.i446 to i64
  %191 = getelementptr ptr, ptr %175, i64 %190
  %192 = getelementptr i8, ptr %191, i64 64
  %193 = load ptr, ptr %192, align 8
  %result.i.i447 = call ptr %193({ ptr, ptr, ptr, i32 } %187, ptr nocapture nofree noundef nonnull readonly %2) #15
  %194 = call i32 %result.i.i447({ ptr, ptr, ptr, i32 } %187, { ptr, ptr, ptr, i32 } %187, ptr nonnull align 8 %2) #7
  %195 = icmp eq i32 %194, %37
  br i1 %195, label %._crit_edge.i448, label %276

._crit_edge.i448:                                 ; preds = %179
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %197 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %175)
  %198 = getelementptr i8, ptr %191, i64 48
  %199 = load ptr, ptr %198, align 8
  %result.i79.i449 = call ptr %199({ ptr, ptr, ptr, i32 } %187, ptr nocapture nofree noundef nonnull readonly %2) #15
  %200 = call { ptr, i160 } %result.i79.i449({ ptr, ptr, ptr, i32 } %187, { ptr, ptr, ptr, i32 } %187, ptr nonnull align 8 %2) #7
  %201 = load ptr, ptr %21, align 8
  %202 = call i1 %201({ ptr, i160 } %200, { ptr, i160 } %33) #7
  br i1 %202, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit461, label %276

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit461: ; preds = %._crit_edge.i448
  %203 = load ptr, ptr %result.i150, align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %205 = load ptr, ptr %15, align 8
  %206 = load ptr, ptr %203, align 8, !alias.scope !19
  %207 = getelementptr i8, ptr %206, i64 72
  %208 = load ptr, ptr %207, align 8, !alias.scope !19
  %result.i.i.i453 = call { i64, i64 } %208(ptr nocapture nofree nonnull readonly %203) #5, !alias.scope !19
  %209 = extractvalue { i64, i64 } %result.i.i.i453, 0
  %210 = extractvalue { i64, i64 } %result.i.i.i453, 1
  %211 = urem i64 20, %210
  %212 = icmp eq i64 %211, 0
  %213 = sub i64 %210, %211
  %214 = select i1 %212, i64 0, i64 %213
  %215 = add i64 %209, 20
  %216 = add i64 %215, %214
  %217 = load ptr, ptr %205, align 8, !alias.scope !19
  %218 = getelementptr i8, ptr %217, i64 72
  %219 = load ptr, ptr %218, align 8, !alias.scope !19
  %result.i1.i.i454 = call { i64, i64 } %219(ptr nocapture nofree nonnull readonly %205) #5, !alias.scope !19
  %220 = extractvalue { i64, i64 } %result.i1.i.i454, 0
  %221 = extractvalue { i64, i64 } %result.i1.i.i454, 1
  %222 = call i64 @llvm.umax.i64(i64 %210, i64 %221)
  %223 = call i64 @llvm.umax.i64(i64 %222, i64 8)
  %224 = urem i64 %216, %221
  %225 = icmp eq i64 %224, 0
  %226 = sub i64 %221, %224
  %227 = select i1 %225, i64 0, i64 %226
  %228 = add i64 %220, %216
  %229 = add i64 %228, %227
  %230 = urem i64 %229, %223
  %231 = icmp eq i64 %230, 0
  %232 = sub i64 %223, %230
  %233 = select i1 %231, i64 0, i64 %232
  %234 = add i64 %233, %229
  %result.i83.i455 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %234, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %203, ptr %result.i83.i455, align 8
  %235 = getelementptr inbounds i8, ptr %result.i83.i455, i64 8
  store ptr %205, ptr %235, align 8
  %236 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i455)
  %237 = load ptr, ptr %203, align 8
  %238 = getelementptr i8, ptr %237, i64 72
  %239 = load ptr, ptr %238, align 8
  %result.i.i114.i456 = call { i64, i64 } %239(ptr nocapture nofree nonnull readonly %203) #5
  %240 = extractvalue { i64, i64 } %result.i.i114.i456, 1
  %241 = urem i64 20, %240
  %242 = icmp eq i64 %241, 0
  %reass.sub1445 = sub i64 %240, %241
  %243 = add i64 %reass.sub1445, 20
  %244 = select i1 %242, i64 20, i64 %243
  %245 = getelementptr i8, ptr %result.i83.i455, i64 %244
  %246 = getelementptr i8, ptr %237, i64 64
  %247 = load ptr, ptr %246, align 8
  call void %247({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %203, ptr nocapture nofree writeonly %245) #12
  %248 = load ptr, ptr %result.i83.i455, align 8
  %249 = load ptr, ptr %248, align 8
  %250 = getelementptr i8, ptr %249, i64 72
  %251 = load ptr, ptr %250, align 8
  %result.i.i115.i458 = call { i64, i64 } %251(ptr nocapture nofree nonnull readonly %248) #5
  %252 = extractvalue { i64, i64 } %result.i.i115.i458, 0
  %253 = extractvalue { i64, i64 } %result.i.i115.i458, 1
  %254 = urem i64 20, %253
  %255 = icmp eq i64 %254, 0
  %256 = sub i64 %253, %254
  %257 = select i1 %255, i64 0, i64 %256
  %258 = add i64 %252, 20
  %259 = add i64 %258, %257
  %260 = load ptr, ptr %235, align 8
  %261 = load ptr, ptr %260, align 8
  %262 = getelementptr i8, ptr %261, i64 72
  %263 = load ptr, ptr %262, align 8
  %result.i1.i116.i459 = call { i64, i64 } %263(ptr nocapture nofree nonnull readonly %260) #5
  %264 = extractvalue { i64, i64 } %result.i1.i116.i459, 1
  %265 = urem i64 %259, %264
  %266 = icmp eq i64 %265, 0
  %267 = sub i64 %264, %265
  %268 = select i1 %266, i64 0, i64 %267
  %269 = getelementptr i8, ptr %result.i83.i455, i64 %259
  %270 = getelementptr i8, ptr %269, i64 %268
  %271 = getelementptr i8, ptr %261, i64 64
  %272 = load ptr, ptr %271, align 8
  call void %272({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %260, ptr nocapture nofree writeonly %270) #12
  %273 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %274 = getelementptr inbounds i8, ptr %result.i83.i455, i64 16
  store i32 %37, ptr %274, align 8
  store ptr @Entry, ptr %174, align 8
  %275 = ptrtoint ptr %result.i83.i455 to i64
  store i64 %275, ptr %176, align 4
  %.sroa_idx28.i460 = getelementptr i8, ptr %174, i64 24
  store i32 10, ptr %.sroa_idx28.i460, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

276:                                              ; preds = %._crit_edge.i448, %148, %179
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %277 = load i32, ptr %28, align 4
  %278 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %279 = load i32, ptr %22, align 8
  %.not.i = icmp slt i32 %277, %279
  br i1 %.not.i, label %._crit_edge.i, label %280

280:                                              ; preds = %276
  %281 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %282 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %283 = load ptr, ptr %23, align 8
  %284 = load ptr, ptr %24, align 8
  %285 = shl i32 %279, 1
  %spec.select.i476 = call i32 @llvm.smax.i32(i32 %285, i32 16)
  store i32 %spec.select.i476, ptr %22, align 8
  %286 = zext nneg i32 %spec.select.i476 to i64
  %287 = shl nuw nsw i64 %286, 5
  %result.i.i477 = call noalias ptr @bump_malloc_inner(i64 noundef %287, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i477, ptr %23, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %287, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i, ptr %24, align 8
  store i32 0, ptr %28, align 4
  %288 = icmp sgt i32 %279, 0
  br i1 %288, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread: ; preds = %280
  %289 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i

.lr.ph.i:                                         ; preds = %280, %._crit_edge.i793
  %.060.i = phi i32 [ %308, %._crit_edge.i793 ], [ 0, %280 ]
  %290 = zext nneg i32 %.060.i to i64
  %291 = shl nuw nsw i64 %290, 5
  %292 = getelementptr i8, ptr %283, i64 %291
  %293 = load ptr, ptr %292, align 8
  %294 = icmp ne ptr %293, @nil_typ
  %295 = icmp ne ptr %293, null
  %.not16.i = and i1 %294, %295
  br i1 %.not16.i, label %296, label %._crit_edge.i793

296:                                              ; preds = %.lr.ph.i
  %297 = getelementptr i8, ptr %292, i64 8
  %298 = load i64, ptr %297, align 4
  %.sroa_idx.i794 = getelementptr i8, ptr %292, i64 16
  %299 = load i64, ptr %.sroa_idx.i794, align 4
  %300 = inttoptr i64 %298 to ptr
  %301 = inttoptr i64 %299 to ptr
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %293, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %293, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %293, i64 40
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i43.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !23
  %302 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %293, 0
  %303 = insertvalue { ptr, ptr, ptr, i32 } %302, ptr %300, 1
  %304 = insertvalue { ptr, ptr, ptr, i32 } %303, ptr %301, 2
  %305 = insertvalue { ptr, ptr, ptr, i32 } %304, i32 %offset.i.i43.i, 3
  %306 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %307 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %305) #7
  br label %._crit_edge.i793

._crit_edge.i793:                                 ; preds = %296, %.lr.ph.i
  %308 = add nuw nsw i32 %.060.i, 1
  %309 = icmp slt i32 %308, %279
  br i1 %309, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i793
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %311

311:                                              ; preds = %._crit_edge.i812, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %.060.i810 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit ], [ %330, %._crit_edge.i812 ]
  %312 = zext nneg i32 %.060.i810 to i64
  %313 = shl nuw nsw i64 %312, 5
  %314 = getelementptr i8, ptr %284, i64 %313
  %315 = load ptr, ptr %314, align 8
  %316 = icmp ne ptr %315, @nil_typ
  %317 = icmp ne ptr %315, null
  %.not16.i811 = and i1 %316, %317
  br i1 %.not16.i811, label %318, label %._crit_edge.i812

318:                                              ; preds = %311
  %319 = getelementptr i8, ptr %314, i64 8
  %320 = load i64, ptr %319, align 4
  %.sroa_idx.i813 = getelementptr i8, ptr %314, i64 16
  %321 = load i64, ptr %.sroa_idx.i813, align 4
  %322 = inttoptr i64 %320 to ptr
  %323 = inttoptr i64 %321 to ptr
  %hash_coef_ptr.i.i18.i814 = getelementptr i8, ptr %315, i64 8
  %tbl_size_ptr.i.i19.i815 = getelementptr i8, ptr %315, i64 16
  %offset_tbl_ptr.i.i20.i816 = getelementptr i8, ptr %315, i64 40
  %hash_coef.i.i21.i817 = load i64, ptr %hash_coef_ptr.i.i18.i814, align 4, !noalias !22
  %tbl_size.i.i22.i818 = load i64, ptr %tbl_size_ptr.i.i19.i815, align 4, !noalias !22
  %offset_tbl.i.i23.i819 = load ptr, ptr %offset_tbl_ptr.i.i20.i816, align 8, !noalias !22
  %product.i.i.i24.i820 = mul i64 %hash_coef.i.i21.i817, 4015701072841558310
  %shifted.i.i.i25.i821 = lshr i64 %product.i.i.i24.i820, 32
  %xored.i.i.i26.i822 = xor i64 %shifted.i.i.i25.i821, %product.i.i.i24.i820
  %hash.i.i.i27.i823 = and i64 %xored.i.i.i26.i822, %tbl_size.i.i22.i818
  %offset_ptr.i.i28.i824 = getelementptr i32, ptr %offset_tbl.i.i23.i819, i64 %hash.i.i.i27.i823
  %offset.i.i43.i825 = load i32, ptr %offset_ptr.i.i28.i824, align 4, !noalias !26
  %324 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %315, 0
  %325 = insertvalue { ptr, ptr, ptr, i32 } %324, ptr %322, 1
  %326 = insertvalue { ptr, ptr, ptr, i32 } %325, ptr %323, 2
  %327 = insertvalue { ptr, ptr, ptr, i32 } %326, i32 %offset.i.i43.i825, 3
  %328 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %329 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %327) #7
  br label %._crit_edge.i812

._crit_edge.i812:                                 ; preds = %318, %311
  %330 = add nuw nsw i32 %.060.i810, 1
  %331 = icmp slt i32 %330, %279
  br i1 %331, label %311, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i812, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread, %276
  %332 = load ptr, ptr %35, align 8
  %333 = getelementptr i8, ptr %332, i64 72
  %334 = load ptr, ptr %333, align 8
  %result.i.i.i = call { i64, i64 } %334(ptr nocapture nofree nonnull readonly %35) #5
  %335 = extractvalue { i64, i64 } %result.i.i.i, 0
  %336 = extractvalue { i64, i64 } %result.i.i.i, 1
  %337 = urem i64 20, %336
  %338 = icmp eq i64 %337, 0
  %339 = sub i64 %336, %337
  %340 = select i1 %338, i64 0, i64 %339
  %341 = add i64 %335, 20
  %342 = add i64 %341, %340
  %343 = load ptr, ptr %42, align 8
  %344 = getelementptr i8, ptr %343, i64 72
  %345 = load ptr, ptr %344, align 8
  %result.i1.i.i = call { i64, i64 } %345(ptr nocapture nofree nonnull readonly %42) #5
  %346 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %347 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %348 = call i64 @llvm.umax.i64(i64 %336, i64 %347)
  %349 = call i64 @llvm.umax.i64(i64 %348, i64 8)
  %350 = urem i64 %342, %347
  %351 = icmp eq i64 %350, 0
  %352 = sub i64 %347, %350
  %353 = select i1 %351, i64 0, i64 %352
  %354 = add i64 %346, %342
  %355 = add i64 %354, %353
  %356 = urem i64 %355, %349
  %357 = icmp eq i64 %356, 0
  %358 = sub i64 %349, %356
  %359 = select i1 %357, i64 0, i64 %358
  %360 = add i64 %359, %355
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %360, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %35, ptr %result.i83.i, align 8
  %361 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %42, ptr %361, align 8
  %362 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %363 = load ptr, ptr %35, align 8
  %364 = getelementptr i8, ptr %363, i64 72
  %365 = load ptr, ptr %364, align 8
  %result.i.i179.i = call { i64, i64 } %365(ptr nocapture nofree nonnull readonly %35) #5
  %366 = extractvalue { i64, i64 } %result.i.i179.i, 1
  %367 = urem i64 20, %366
  %368 = icmp eq i64 %367, 0
  %reass.sub = sub i64 %366, %367
  %369 = add i64 %reass.sub, 20
  %370 = select i1 %368, i64 20, i64 %369
  %371 = getelementptr i8, ptr %result.i83.i, i64 %370
  %372 = getelementptr i8, ptr %363, i64 64
  %373 = load ptr, ptr %372, align 8
  call void %373({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %35, ptr nocapture nofree writeonly %371) #12
  %374 = load ptr, ptr %result.i83.i, align 8
  %375 = load ptr, ptr %374, align 8
  %376 = getelementptr i8, ptr %375, i64 72
  %377 = load ptr, ptr %376, align 8
  %result.i.i180.i = call { i64, i64 } %377(ptr nocapture nofree nonnull readonly %374) #5
  %378 = extractvalue { i64, i64 } %result.i.i180.i, 0
  %379 = extractvalue { i64, i64 } %result.i.i180.i, 1
  %380 = urem i64 20, %379
  %381 = icmp eq i64 %380, 0
  %382 = sub i64 %379, %380
  %383 = select i1 %381, i64 0, i64 %382
  %384 = add i64 %378, 20
  %385 = add i64 %384, %383
  %386 = load ptr, ptr %361, align 8
  %387 = load ptr, ptr %386, align 8
  %388 = getelementptr i8, ptr %387, i64 72
  %389 = load ptr, ptr %388, align 8
  %result.i1.i181.i = call { i64, i64 } %389(ptr nocapture nofree nonnull readonly %386) #5
  %390 = extractvalue { i64, i64 } %result.i1.i181.i, 1
  %391 = urem i64 %385, %390
  %392 = icmp eq i64 %391, 0
  %393 = sub i64 %390, %391
  %394 = select i1 %392, i64 0, i64 %393
  %395 = getelementptr i8, ptr %result.i83.i, i64 %385
  %396 = getelementptr i8, ptr %395, i64 %394
  %397 = getelementptr i8, ptr %387, i64 64
  %398 = load ptr, ptr %397, align 8
  call void %398({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %386, ptr nocapture nofree writeonly %396) #12
  %399 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %400 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %37, ptr %400, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %404

404:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %405, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %471, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i83.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i493, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %405 = add nuw nsw i32 %.0566.i, 1
  %406 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %407 = insertvalue { ptr, ptr, ptr, i32 } %406, ptr %.sroa.6.0563.i, 1
  %408 = insertvalue { ptr, ptr, ptr, i32 } %407, ptr %.sroa.12.0562.i, 2
  %409 = insertvalue { ptr, ptr, ptr, i32 } %408, i32 %.sroa.17.0561.i, 3
  %410 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %411 = sext i32 %.sroa.17.0561.i to i64
  %412 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %411
  %413 = getelementptr i8, ptr %412, i64 64
  %414 = load ptr, ptr %413, align 8
  %result.i125.i = call ptr %414({ ptr, ptr, ptr, i32 } %409, ptr nocapture nofree noundef nonnull readonly %2) #15
  %415 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %409, { ptr, ptr, ptr, i32 } %409, ptr nonnull align 8 %2) #7
  %416 = ptrtoint ptr %.sroa.6.0563.i to i64
  %417 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %418, label %434

418:                                              ; preds = %404
  %419 = load i32, ptr %22, align 8
  %420 = add i32 %419, -1
  %421 = and i32 %420, %415
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %423 = load ptr, ptr %23, align 8
  %424 = sext i32 %421 to i64
  %425 = shl nsw i64 %424, 5
  %426 = getelementptr i8, ptr %423, i64 %425
  %427 = load ptr, ptr %426, align 8
  %428 = getelementptr i8, ptr %426, i64 8
  %429 = load i160, ptr %428, align 4
  store ptr %.sroa.0.0564.i, ptr %426, align 8
  store i64 %416, ptr %428, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %426, i64 16
  store i64 %417, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %426, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %430 = icmp ne ptr %427, @nil_typ
  %431 = icmp ne ptr %427, null
  %.not92.i = and i1 %430, %431
  %extract.i = lshr i160 %429, 64
  %432 = insertelement <2 x i160> poison, i160 %429, i64 0
  %433 = insertelement <2 x i160> %432, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

434:                                              ; preds = %404
  %435 = add i32 %415, 2127912214
  %436 = shl i32 %415, 12
  %437 = add i32 %435, %436
  %438 = ashr i32 %437, 19
  %439 = xor i32 %437, %438
  %440 = xor i32 %439, -949894596
  %441 = add i32 %440, 374761393
  %442 = shl i32 %440, 5
  %443 = add i32 %441, %442
  %444 = add i32 %443, -744332180
  %445 = shl i32 %443, 9
  %446 = xor i32 %444, %445
  %447 = add i32 %446, -42973499
  %448 = shl i32 %446, 3
  %449 = add i32 %447, %448
  %450 = ashr i32 %449, 16
  %451 = xor i32 %449, %450
  %452 = xor i32 %451, -1252372727
  %453 = load i32, ptr %22, align 8
  %454 = add i32 %453, -1
  %455 = and i32 %454, %452
  %456 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %457 = load ptr, ptr %24, align 8
  %458 = sext i32 %455 to i64
  %459 = shl nsw i64 %458, 5
  %460 = getelementptr i8, ptr %457, i64 %459
  %461 = load ptr, ptr %460, align 8
  %462 = getelementptr i8, ptr %460, i64 8
  %463 = load i160, ptr %462, align 4
  store ptr %.sroa.0.0564.i, ptr %460, align 8
  store i64 %416, ptr %462, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %460, i64 16
  store i64 %417, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %460, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %464 = icmp ne ptr %461, @nil_typ
  %465 = icmp ne ptr %461, null
  %.not90.i = and i1 %464, %465
  %extract607.i = lshr i160 %463, 64
  %466 = insertelement <2 x i160> poison, i160 %463, i64 0
  %467 = insertelement <2 x i160> %466, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %434, %418
  %vptr.i142.sroa.speculated.i = phi ptr [ %427, %418 ], [ %461, %434 ]
  %.in = phi <2 x i160> [ %433, %418 ], [ %467, %434 ]
  %468 = trunc <2 x i160> %.in to <2 x i64>
  %469 = extractelement <2 x i64> %468, i64 1
  %spec.select.i493 = inttoptr i64 %469 to ptr
  %470 = extractelement <2 x i64> %468, i64 0
  %spec.select539.i = inttoptr i64 %470 to ptr
  %471 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %472 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %473 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %474 = icmp ult i32 %.0566.i, 99
  br i1 %474, label %404, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %418, %434
  %475 = phi ptr [ %14, %434 ], [ %13, %418 ]
  %476 = load i32, ptr %28, align 4
  store i32 %476, ptr %475, align 4
  %477 = add i32 %476, 1
  %478 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %477, ptr %28, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  %479 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %479, label %HashMap_insert_keyK_valueV.exit, label %480

480:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %481 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %482 = load ptr, ptr %23, align 8
  %483 = load ptr, ptr %24, align 8
  %484 = load i32, ptr %22, align 8
  %485 = shl i32 %484, 1
  %spec.select.i510 = call i32 @llvm.smax.i32(i32 %485, i32 16)
  store i32 %spec.select.i510, ptr %22, align 8
  %486 = zext nneg i32 %spec.select.i510 to i64
  %487 = shl nuw nsw i64 %486, 5
  %result.i.i511 = call noalias ptr @bump_malloc_inner(i64 noundef %487, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i511, ptr %23, align 8
  %result.i20.i512 = call noalias ptr @bump_malloc_inner(i64 noundef %487, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i512, ptr %24, align 8
  store i32 0, ptr %28, align 4
  %488 = icmp sgt i32 %484, 0
  br i1 %488, label %.lr.ph.i859, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928

.lr.ph.i859:                                      ; preds = %480, %._crit_edge.i874
  %.060.i872 = phi i32 [ %577, %._crit_edge.i874 ], [ 0, %480 ]
  %489 = zext nneg i32 %.060.i872 to i64
  %490 = shl nuw nsw i64 %489, 5
  %491 = getelementptr i8, ptr %482, i64 %490
  %492 = load ptr, ptr %491, align 8
  %493 = icmp ne ptr %492, @nil_typ
  %494 = icmp ne ptr %492, null
  %.not16.i873 = and i1 %493, %494
  br i1 %.not16.i873, label %495, label %._crit_edge.i874

495:                                              ; preds = %.lr.ph.i859
  %496 = getelementptr i8, ptr %491, i64 8
  %497 = load <2 x i64>, ptr %496, align 4
  %hash_coef_ptr.i.i18.i876 = getelementptr i8, ptr %492, i64 8
  %tbl_size_ptr.i.i19.i877 = getelementptr i8, ptr %492, i64 16
  %offset_tbl_ptr.i.i20.i878 = getelementptr i8, ptr %492, i64 40
  %498 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i876, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i877, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i878, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !29
  %499 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %500 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %502

502:                                              ; preds = %.cont.cont.i1052, %495
  %.0566.i1039 = phi i32 [ 0, %495 ], [ %506, %.cont.cont.i1052 ]
  %.070565.i1040 = phi i1 [ true, %495 ], [ %568, %.cont.cont.i1052 ]
  %.sroa.0.0564.i1041 = phi ptr [ %492, %495 ], [ %vptr.i142.sroa.speculated.i1055, %.cont.cont.i1052 ]
  %.sroa.17.0561.i1044 = phi i32 [ %offset.i.i121.i, %495 ], [ %offset.i.i154.i1069, %.cont.cont.i1052 ]
  %503 = phi <2 x i64> [ %497, %495 ], [ %567, %.cont.cont.i1052 ]
  %504 = extractelement <2 x i64> %503, i64 1
  %.sroa.12.0562.i1043 = inttoptr i64 %504 to ptr
  %505 = extractelement <2 x i64> %503, i64 0
  %.sroa.6.0563.i1042 = inttoptr i64 %505 to ptr
  %506 = add nuw nsw i32 %.0566.i1039, 1
  %507 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1041, 0
  %508 = insertvalue { ptr, ptr, ptr, i32 } %507, ptr %.sroa.6.0563.i1042, 1
  %509 = insertvalue { ptr, ptr, ptr, i32 } %508, ptr %.sroa.12.0562.i1043, 2
  %510 = insertvalue { ptr, ptr, ptr, i32 } %509, i32 %.sroa.17.0561.i1044, 3
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1041)
  %512 = sext i32 %.sroa.17.0561.i1044 to i64
  %513 = getelementptr ptr, ptr %.sroa.0.0564.i1041, i64 %512
  %514 = getelementptr i8, ptr %513, i64 64
  %515 = load ptr, ptr %514, align 8
  %result.i125.i1045 = call ptr %515({ ptr, ptr, ptr, i32 } %510, ptr nocapture nofree noundef nonnull readonly %2) #15
  %516 = call i32 %result.i125.i1045({ ptr, ptr, ptr, i32 } %510, { ptr, ptr, ptr, i32 } %510, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1040, label %517, label %533

517:                                              ; preds = %502
  %518 = load i32, ptr %22, align 8
  %519 = add i32 %518, -1
  %520 = and i32 %519, %516
  %521 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %522 = load ptr, ptr %23, align 8
  %523 = sext i32 %520 to i64
  %524 = shl nsw i64 %523, 5
  %525 = getelementptr i8, ptr %522, i64 %524
  %526 = load ptr, ptr %525, align 8
  %527 = getelementptr i8, ptr %525, i64 8
  %528 = load i160, ptr %527, align 4
  store ptr %.sroa.0.0564.i1041, ptr %525, align 8
  store i64 %505, ptr %527, align 4
  %.sroa_idx157.i1071 = getelementptr i8, ptr %525, i64 16
  store i64 %504, ptr %.sroa_idx157.i1071, align 4
  %.sroa_idx158.i1072 = getelementptr i8, ptr %525, i64 24
  store i32 %.sroa.17.0561.i1044, ptr %.sroa_idx158.i1072, align 4
  %529 = icmp ne ptr %526, @nil_typ
  %530 = icmp ne ptr %526, null
  %.not92.i1073 = and i1 %529, %530
  %extract.i1075 = lshr i160 %528, 64
  %531 = insertelement <2 x i160> poison, i160 %528, i64 0
  %532 = insertelement <2 x i160> %531, i160 %extract.i1075, i64 1
  br i1 %.not92.i1073, label %.cont.cont.i1052, label %572

533:                                              ; preds = %502
  %534 = add i32 %516, 2127912214
  %535 = shl i32 %516, 12
  %536 = add i32 %534, %535
  %537 = ashr i32 %536, 19
  %538 = xor i32 %536, %537
  %539 = xor i32 %538, -949894596
  %540 = add i32 %539, 374761393
  %541 = shl i32 %539, 5
  %542 = add i32 %540, %541
  %543 = add i32 %542, -744332180
  %544 = shl i32 %542, 9
  %545 = xor i32 %543, %544
  %546 = add i32 %545, -42973499
  %547 = shl i32 %545, 3
  %548 = add i32 %546, %547
  %549 = ashr i32 %548, 16
  %550 = xor i32 %548, %549
  %551 = xor i32 %550, -1252372727
  %552 = load i32, ptr %22, align 8
  %553 = add i32 %552, -1
  %554 = and i32 %553, %551
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %556 = load ptr, ptr %24, align 8
  %557 = sext i32 %554 to i64
  %558 = shl nsw i64 %557, 5
  %559 = getelementptr i8, ptr %556, i64 %558
  %560 = load ptr, ptr %559, align 8
  %561 = getelementptr i8, ptr %559, i64 8
  %562 = load i160, ptr %561, align 4
  store ptr %.sroa.0.0564.i1041, ptr %559, align 8
  store i64 %505, ptr %561, align 4
  %.sroa_idx161.i1046 = getelementptr i8, ptr %559, i64 16
  store i64 %504, ptr %.sroa_idx161.i1046, align 4
  %.sroa_idx162.i1047 = getelementptr i8, ptr %559, i64 24
  store i32 %.sroa.17.0561.i1044, ptr %.sroa_idx162.i1047, align 4
  %563 = icmp ne ptr %560, @nil_typ
  %564 = icmp ne ptr %560, null
  %.not90.i1048 = and i1 %563, %564
  %extract607.i1050 = lshr i160 %562, 64
  %565 = insertelement <2 x i160> poison, i160 %562, i64 0
  %566 = insertelement <2 x i160> %565, i160 %extract607.i1050, i64 1
  br i1 %.not90.i1048, label %.cont.cont.i1052, label %572

.cont.cont.i1052:                                 ; preds = %533, %517
  %vptr.i142.sroa.speculated.i1055 = phi ptr [ %526, %517 ], [ %560, %533 ]
  %.in1447 = phi <2 x i160> [ %532, %517 ], [ %566, %533 ]
  %567 = trunc <2 x i160> %.in1447 to <2 x i64>
  %568 = xor i1 %.070565.i1040, true
  %hash_coef_ptr.i.i143.i1058 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1055, i64 8
  %tbl_size_ptr.i.i144.i1059 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1055, i64 16
  %offset_tbl_ptr.i.i145.i1060 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1055, i64 40
  %hash_coef.i.i146.i1061 = load i64, ptr %hash_coef_ptr.i.i143.i1058, align 4
  %tbl_size.i.i147.i1062 = load i64, ptr %tbl_size_ptr.i.i144.i1059, align 4
  %offset_tbl.i.i148.i1063 = load ptr, ptr %offset_tbl_ptr.i.i145.i1060, align 8
  %product.i.i.i149.i1064 = mul i64 %hash_coef.i.i146.i1061, 4015701072841558310
  %shifted.i.i.i150.i1065 = lshr i64 %product.i.i.i149.i1064, 32
  %xored.i.i.i151.i1066 = xor i64 %shifted.i.i.i150.i1065, %product.i.i.i149.i1064
  %hash.i.i.i152.i1067 = and i64 %xored.i.i.i151.i1066, %tbl_size.i.i147.i1062
  %offset_ptr.i.i153.i1068 = getelementptr i32, ptr %offset_tbl.i.i148.i1063, i64 %hash.i.i.i152.i1067
  %offset.i.i154.i1069 = load i32, ptr %offset_ptr.i.i153.i1068, align 4
  %569 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %570 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %571 = icmp ult i32 %.0566.i1039, 99
  br i1 %571, label %502, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1077

572:                                              ; preds = %533, %517
  %573 = phi ptr [ %10, %533 ], [ %9, %517 ]
  %574 = load i32, ptr %28, align 4
  store i32 %574, ptr %573, align 4
  %575 = add i32 %574, 1
  %576 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %575, ptr %28, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1077

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1077: ; preds = %.cont.cont.i1052, %572
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i874

._crit_edge.i874:                                 ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1077, %.lr.ph.i859
  %577 = add nuw nsw i32 %.060.i872, 1
  %578 = icmp slt i32 %577, %484
  br i1 %578, label %.lr.ph.i859, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892: ; preds = %._crit_edge.i874, %._crit_edge.i910
  %.060.i908 = phi i32 [ %667, %._crit_edge.i910 ], [ 0, %._crit_edge.i874 ]
  %579 = zext nneg i32 %.060.i908 to i64
  %580 = shl nuw nsw i64 %579, 5
  %581 = getelementptr i8, ptr %483, i64 %580
  %582 = load ptr, ptr %581, align 8
  %583 = icmp ne ptr %582, @nil_typ
  %584 = icmp ne ptr %582, null
  %.not16.i909 = and i1 %583, %584
  br i1 %.not16.i909, label %585, label %._crit_edge.i910

585:                                              ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892
  %586 = getelementptr i8, ptr %581, i64 8
  %587 = load <2 x i64>, ptr %586, align 4
  %hash_coef_ptr.i.i18.i912 = getelementptr i8, ptr %582, i64 8
  %tbl_size_ptr.i.i19.i913 = getelementptr i8, ptr %582, i64 16
  %offset_tbl_ptr.i.i20.i914 = getelementptr i8, ptr %582, i64 40
  %588 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i1095 = load i64, ptr %hash_coef_ptr.i.i18.i912, align 4, !noalias !22
  %tbl_size.i.i100.i1096 = load i64, ptr %tbl_size_ptr.i.i19.i913, align 4, !noalias !22
  %offset_tbl.i.i101.i1097 = load ptr, ptr %offset_tbl_ptr.i.i20.i914, align 8, !noalias !22
  %product.i.i.i102.i1098 = mul i64 %hash_coef.i.i99.i1095, 4015701072841558310
  %shifted.i.i.i103.i1099 = lshr i64 %product.i.i.i102.i1098, 32
  %xored.i.i.i104.i1100 = xor i64 %shifted.i.i.i103.i1099, %product.i.i.i102.i1098
  %hash.i.i.i105.i1101 = and i64 %xored.i.i.i104.i1100, %tbl_size.i.i100.i1096
  %offset_ptr.i.i106.i1102 = getelementptr i32, ptr %offset_tbl.i.i101.i1097, i64 %hash.i.i.i105.i1101
  %offset.i.i121.i1103 = load i32, ptr %offset_ptr.i.i106.i1102, align 4, !noalias !32
  %589 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %590 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %591 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %592

592:                                              ; preds = %.cont.cont.i1124, %585
  %.0566.i1104 = phi i32 [ 0, %585 ], [ %596, %.cont.cont.i1124 ]
  %.070565.i1105 = phi i1 [ true, %585 ], [ %658, %.cont.cont.i1124 ]
  %.sroa.0.0564.i1106 = phi ptr [ %582, %585 ], [ %vptr.i142.sroa.speculated.i1127, %.cont.cont.i1124 ]
  %.sroa.17.0561.i1109 = phi i32 [ %offset.i.i121.i1103, %585 ], [ %offset.i.i154.i1141, %.cont.cont.i1124 ]
  %593 = phi <2 x i64> [ %587, %585 ], [ %657, %.cont.cont.i1124 ]
  %594 = extractelement <2 x i64> %593, i64 1
  %.sroa.12.0562.i1108 = inttoptr i64 %594 to ptr
  %595 = extractelement <2 x i64> %593, i64 0
  %.sroa.6.0563.i1107 = inttoptr i64 %595 to ptr
  %596 = add nuw nsw i32 %.0566.i1104, 1
  %597 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1106, 0
  %598 = insertvalue { ptr, ptr, ptr, i32 } %597, ptr %.sroa.6.0563.i1107, 1
  %599 = insertvalue { ptr, ptr, ptr, i32 } %598, ptr %.sroa.12.0562.i1108, 2
  %600 = insertvalue { ptr, ptr, ptr, i32 } %599, i32 %.sroa.17.0561.i1109, 3
  %601 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1106)
  %602 = sext i32 %.sroa.17.0561.i1109 to i64
  %603 = getelementptr ptr, ptr %.sroa.0.0564.i1106, i64 %602
  %604 = getelementptr i8, ptr %603, i64 64
  %605 = load ptr, ptr %604, align 8
  %result.i125.i1110 = call ptr %605({ ptr, ptr, ptr, i32 } %600, ptr nocapture nofree noundef nonnull readonly %2) #15
  %606 = call i32 %result.i125.i1110({ ptr, ptr, ptr, i32 } %600, { ptr, ptr, ptr, i32 } %600, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1105, label %607, label %623

607:                                              ; preds = %592
  %608 = load i32, ptr %22, align 8
  %609 = add i32 %608, -1
  %610 = and i32 %609, %606
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %612 = load ptr, ptr %23, align 8
  %613 = sext i32 %610 to i64
  %614 = shl nsw i64 %613, 5
  %615 = getelementptr i8, ptr %612, i64 %614
  %616 = load ptr, ptr %615, align 8
  %617 = getelementptr i8, ptr %615, i64 8
  %618 = load i160, ptr %617, align 4
  store ptr %.sroa.0.0564.i1106, ptr %615, align 8
  store i64 %595, ptr %617, align 4
  %.sroa_idx157.i1153 = getelementptr i8, ptr %615, i64 16
  store i64 %594, ptr %.sroa_idx157.i1153, align 4
  %.sroa_idx158.i1154 = getelementptr i8, ptr %615, i64 24
  store i32 %.sroa.17.0561.i1109, ptr %.sroa_idx158.i1154, align 4
  %619 = icmp ne ptr %616, @nil_typ
  %620 = icmp ne ptr %616, null
  %.not92.i1155 = and i1 %619, %620
  %extract.i1157 = lshr i160 %618, 64
  %621 = insertelement <2 x i160> poison, i160 %618, i64 0
  %622 = insertelement <2 x i160> %621, i160 %extract.i1157, i64 1
  br i1 %.not92.i1155, label %.cont.cont.i1124, label %662

623:                                              ; preds = %592
  %624 = add i32 %606, 2127912214
  %625 = shl i32 %606, 12
  %626 = add i32 %624, %625
  %627 = ashr i32 %626, 19
  %628 = xor i32 %626, %627
  %629 = xor i32 %628, -949894596
  %630 = add i32 %629, 374761393
  %631 = shl i32 %629, 5
  %632 = add i32 %630, %631
  %633 = add i32 %632, -744332180
  %634 = shl i32 %632, 9
  %635 = xor i32 %633, %634
  %636 = add i32 %635, -42973499
  %637 = shl i32 %635, 3
  %638 = add i32 %636, %637
  %639 = ashr i32 %638, 16
  %640 = xor i32 %638, %639
  %641 = xor i32 %640, -1252372727
  %642 = load i32, ptr %22, align 8
  %643 = add i32 %642, -1
  %644 = and i32 %643, %641
  %645 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %646 = load ptr, ptr %24, align 8
  %647 = sext i32 %644 to i64
  %648 = shl nsw i64 %647, 5
  %649 = getelementptr i8, ptr %646, i64 %648
  %650 = load ptr, ptr %649, align 8
  %651 = getelementptr i8, ptr %649, i64 8
  %652 = load i160, ptr %651, align 4
  store ptr %.sroa.0.0564.i1106, ptr %649, align 8
  store i64 %595, ptr %651, align 4
  %.sroa_idx161.i1114 = getelementptr i8, ptr %649, i64 16
  store i64 %594, ptr %.sroa_idx161.i1114, align 4
  %.sroa_idx162.i1115 = getelementptr i8, ptr %649, i64 24
  store i32 %.sroa.17.0561.i1109, ptr %.sroa_idx162.i1115, align 4
  %653 = icmp ne ptr %650, @nil_typ
  %654 = icmp ne ptr %650, null
  %.not90.i1116 = and i1 %653, %654
  %extract607.i1118 = lshr i160 %652, 64
  %655 = insertelement <2 x i160> poison, i160 %652, i64 0
  %656 = insertelement <2 x i160> %655, i160 %extract607.i1118, i64 1
  br i1 %.not90.i1116, label %.cont.cont.i1124, label %662

.cont.cont.i1124:                                 ; preds = %623, %607
  %vptr.i142.sroa.speculated.i1127 = phi ptr [ %616, %607 ], [ %650, %623 ]
  %.in1448 = phi <2 x i160> [ %622, %607 ], [ %656, %623 ]
  %657 = trunc <2 x i160> %.in1448 to <2 x i64>
  %658 = xor i1 %.070565.i1105, true
  %hash_coef_ptr.i.i143.i1130 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1127, i64 8
  %tbl_size_ptr.i.i144.i1131 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1127, i64 16
  %offset_tbl_ptr.i.i145.i1132 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1127, i64 40
  %hash_coef.i.i146.i1133 = load i64, ptr %hash_coef_ptr.i.i143.i1130, align 4
  %tbl_size.i.i147.i1134 = load i64, ptr %tbl_size_ptr.i.i144.i1131, align 4
  %offset_tbl.i.i148.i1135 = load ptr, ptr %offset_tbl_ptr.i.i145.i1132, align 8
  %product.i.i.i149.i1136 = mul i64 %hash_coef.i.i146.i1133, 4015701072841558310
  %shifted.i.i.i150.i1137 = lshr i64 %product.i.i.i149.i1136, 32
  %xored.i.i.i151.i1138 = xor i64 %shifted.i.i.i150.i1137, %product.i.i.i149.i1136
  %hash.i.i.i152.i1139 = and i64 %xored.i.i.i151.i1138, %tbl_size.i.i147.i1134
  %offset_ptr.i.i153.i1140 = getelementptr i32, ptr %offset_tbl.i.i148.i1135, i64 %hash.i.i.i152.i1139
  %offset.i.i154.i1141 = load i32, ptr %offset_ptr.i.i153.i1140, align 4
  %659 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %660 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %661 = icmp ult i32 %.0566.i1104, 99
  br i1 %661, label %592, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1159

662:                                              ; preds = %623, %607
  %663 = phi ptr [ %8, %623 ], [ %7, %607 ]
  %664 = load i32, ptr %28, align 4
  store i32 %664, ptr %663, align 4
  %665 = add i32 %664, 1
  %666 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %665, ptr %28, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1159

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1159: ; preds = %.cont.cont.i1124, %662
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i910

._crit_edge.i910:                                 ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1159, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892
  %667 = add nuw nsw i32 %.060.i908, 1
  %668 = icmp slt i32 %667, %484
  br i1 %668, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928: ; preds = %._crit_edge.i910, %480
  %669 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i533 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i534 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i535 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i536 = mul i64 %hash_coef.i.i99.i533, 4015701072841558310
  %shifted.i.i.i103.i537 = lshr i64 %product.i.i.i102.i536, 32
  %xored.i.i.i104.i538 = xor i64 %shifted.i.i.i103.i537, %product.i.i.i102.i536
  %hash.i.i.i105.i539 = and i64 %xored.i.i.i104.i538, %tbl_size.i.i100.i534
  %offset_ptr.i.i106.i540 = getelementptr i32, ptr %offset_tbl.i.i101.i535, i64 %hash.i.i.i105.i539
  %offset.i.i121.i541 = load i32, ptr %offset_ptr.i.i106.i540, align 4, !noalias !35
  %670 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %673

673:                                              ; preds = %.cont.cont.i563, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928
  %.0566.i543 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928 ], [ %677, %.cont.cont.i563 ]
  %.070565.i544 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928 ], [ %739, %.cont.cont.i563 ]
  %.sroa.0.0564.i545 = phi ptr [ %vptr.i142.sroa.speculated.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928 ], [ %vptr.i142.sroa.speculated.i566, %.cont.cont.i563 ]
  %.sroa.17.0561.i548 = phi i32 [ %offset.i.i121.i541, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928 ], [ %offset.i.i154.i580, %.cont.cont.i563 ]
  %674 = phi <2 x i64> [ %468, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928 ], [ %738, %.cont.cont.i563 ]
  %675 = extractelement <2 x i64> %674, i64 1
  %.sroa.12.0562.i547 = inttoptr i64 %675 to ptr
  %676 = extractelement <2 x i64> %674, i64 0
  %.sroa.6.0563.i546 = inttoptr i64 %676 to ptr
  %677 = add nuw nsw i32 %.0566.i543, 1
  %678 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i545, 0
  %679 = insertvalue { ptr, ptr, ptr, i32 } %678, ptr %.sroa.6.0563.i546, 1
  %680 = insertvalue { ptr, ptr, ptr, i32 } %679, ptr %.sroa.12.0562.i547, 2
  %681 = insertvalue { ptr, ptr, ptr, i32 } %680, i32 %.sroa.17.0561.i548, 3
  %682 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i545)
  %683 = sext i32 %.sroa.17.0561.i548 to i64
  %684 = getelementptr ptr, ptr %.sroa.0.0564.i545, i64 %683
  %685 = getelementptr i8, ptr %684, i64 64
  %686 = load ptr, ptr %685, align 8
  %result.i125.i549 = call ptr %686({ ptr, ptr, ptr, i32 } %681, ptr nocapture nofree noundef nonnull readonly %2) #15
  %687 = call i32 %result.i125.i549({ ptr, ptr, ptr, i32 } %681, { ptr, ptr, ptr, i32 } %681, ptr nonnull align 8 %2) #7
  br i1 %.070565.i544, label %688, label %704

688:                                              ; preds = %673
  %689 = load i32, ptr %22, align 8
  %690 = add i32 %689, -1
  %691 = and i32 %690, %687
  %692 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %693 = load ptr, ptr %23, align 8
  %694 = sext i32 %691 to i64
  %695 = shl nsw i64 %694, 5
  %696 = getelementptr i8, ptr %693, i64 %695
  %697 = load ptr, ptr %696, align 8
  %698 = getelementptr i8, ptr %696, i64 8
  %699 = load i160, ptr %698, align 4
  store ptr %.sroa.0.0564.i545, ptr %696, align 8
  store i64 %676, ptr %698, align 4
  %.sroa_idx157.i592 = getelementptr i8, ptr %696, i64 16
  store i64 %675, ptr %.sroa_idx157.i592, align 4
  %.sroa_idx158.i593 = getelementptr i8, ptr %696, i64 24
  store i32 %.sroa.17.0561.i548, ptr %.sroa_idx158.i593, align 4
  %700 = icmp ne ptr %697, @nil_typ
  %701 = icmp ne ptr %697, null
  %.not92.i594 = and i1 %700, %701
  %extract.i596 = lshr i160 %699, 64
  %702 = insertelement <2 x i160> poison, i160 %699, i64 0
  %703 = insertelement <2 x i160> %702, i160 %extract.i596, i64 1
  br i1 %.not92.i594, label %.cont.cont.i563, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.thread

704:                                              ; preds = %673
  %705 = add i32 %687, 2127912214
  %706 = shl i32 %687, 12
  %707 = add i32 %705, %706
  %708 = ashr i32 %707, 19
  %709 = xor i32 %707, %708
  %710 = xor i32 %709, -949894596
  %711 = add i32 %710, 374761393
  %712 = shl i32 %710, 5
  %713 = add i32 %711, %712
  %714 = add i32 %713, -744332180
  %715 = shl i32 %713, 9
  %716 = xor i32 %714, %715
  %717 = add i32 %716, -42973499
  %718 = shl i32 %716, 3
  %719 = add i32 %717, %718
  %720 = ashr i32 %719, 16
  %721 = xor i32 %719, %720
  %722 = xor i32 %721, -1252372727
  %723 = load i32, ptr %22, align 8
  %724 = add i32 %723, -1
  %725 = and i32 %724, %722
  %726 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %727 = load ptr, ptr %24, align 8
  %728 = sext i32 %725 to i64
  %729 = shl nsw i64 %728, 5
  %730 = getelementptr i8, ptr %727, i64 %729
  %731 = load ptr, ptr %730, align 8
  %732 = getelementptr i8, ptr %730, i64 8
  %733 = load i160, ptr %732, align 4
  store ptr %.sroa.0.0564.i545, ptr %730, align 8
  store i64 %676, ptr %732, align 4
  %.sroa_idx161.i553 = getelementptr i8, ptr %730, i64 16
  store i64 %675, ptr %.sroa_idx161.i553, align 4
  %.sroa_idx162.i554 = getelementptr i8, ptr %730, i64 24
  store i32 %.sroa.17.0561.i548, ptr %.sroa_idx162.i554, align 4
  %734 = icmp ne ptr %731, @nil_typ
  %735 = icmp ne ptr %731, null
  %.not90.i555 = and i1 %734, %735
  %extract607.i557 = lshr i160 %733, 64
  %736 = insertelement <2 x i160> poison, i160 %733, i64 0
  %737 = insertelement <2 x i160> %736, i160 %extract607.i557, i64 1
  br i1 %.not90.i555, label %.cont.cont.i563, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.thread

.cont.cont.i563:                                  ; preds = %704, %688
  %vptr.i142.sroa.speculated.i566 = phi ptr [ %697, %688 ], [ %731, %704 ]
  %.in1449 = phi <2 x i160> [ %703, %688 ], [ %737, %704 ]
  %738 = trunc <2 x i160> %.in1449 to <2 x i64>
  %739 = xor i1 %.070565.i544, true
  %hash_coef_ptr.i.i143.i569 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i566, i64 8
  %tbl_size_ptr.i.i144.i570 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i566, i64 16
  %offset_tbl_ptr.i.i145.i571 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i566, i64 40
  %hash_coef.i.i146.i572 = load i64, ptr %hash_coef_ptr.i.i143.i569, align 4
  %tbl_size.i.i147.i573 = load i64, ptr %tbl_size_ptr.i.i144.i570, align 4
  %offset_tbl.i.i148.i574 = load ptr, ptr %offset_tbl_ptr.i.i145.i571, align 8
  %product.i.i.i149.i575 = mul i64 %hash_coef.i.i146.i572, 4015701072841558310
  %shifted.i.i.i150.i576 = lshr i64 %product.i.i.i149.i575, 32
  %xored.i.i.i151.i577 = xor i64 %shifted.i.i.i150.i576, %product.i.i.i149.i575
  %hash.i.i.i152.i578 = and i64 %xored.i.i.i151.i577, %tbl_size.i.i147.i573
  %offset_ptr.i.i153.i579 = getelementptr i32, ptr %offset_tbl.i.i148.i574, i64 %hash.i.i.i152.i578
  %offset.i.i154.i580 = load i32, ptr %offset_ptr.i.i153.i579, align 4
  %740 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %741 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %742 = icmp ult i32 %.0566.i543, 99
  br i1 %742, label %673, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.thread: ; preds = %688, %704
  %743 = phi ptr [ %12, %704 ], [ %11, %688 ]
  %744 = load i32, ptr %28, align 4
  store i32 %744, ptr %743, align 4
  %745 = add i32 %744, 1
  %746 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %745, ptr %28, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598: ; preds = %.cont.cont.i563
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  %747 = icmp eq ptr %vptr.i142.sroa.speculated.i566, null
  br i1 %747, label %HashMap_insert_keyK_valueV.exit, label %748

748:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598
  %749 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %750 = load ptr, ptr %23, align 8
  %751 = load ptr, ptr %24, align 8
  %752 = load i32, ptr %22, align 8
  %753 = shl i32 %752, 1
  %spec.select.i614 = call i32 @llvm.smax.i32(i32 %753, i32 16)
  store i32 %spec.select.i614, ptr %22, align 8
  %754 = zext nneg i32 %spec.select.i614 to i64
  %755 = shl nuw nsw i64 %754, 5
  %result.i.i615 = call noalias ptr @bump_malloc_inner(i64 noundef %755, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i615, ptr %23, align 8
  %result.i20.i616 = call noalias ptr @bump_malloc_inner(i64 noundef %755, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i616, ptr %24, align 8
  store i32 0, ptr %28, align 4
  %756 = icmp sgt i32 %752, 0
  br i1 %756, label %.lr.ph.i958, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.thread: ; preds = %748
  %757 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit

.lr.ph.i958:                                      ; preds = %748, %._crit_edge.i973
  %.060.i971 = phi i32 [ %846, %._crit_edge.i973 ], [ 0, %748 ]
  %758 = zext nneg i32 %.060.i971 to i64
  %759 = shl nuw nsw i64 %758, 5
  %760 = getelementptr i8, ptr %750, i64 %759
  %761 = load ptr, ptr %760, align 8
  %762 = icmp ne ptr %761, @nil_typ
  %763 = icmp ne ptr %761, null
  %.not16.i972 = and i1 %762, %763
  br i1 %.not16.i972, label %764, label %._crit_edge.i973

764:                                              ; preds = %.lr.ph.i958
  %765 = getelementptr i8, ptr %760, i64 8
  %766 = load <2 x i64>, ptr %765, align 4
  %hash_coef_ptr.i.i18.i975 = getelementptr i8, ptr %761, i64 8
  %tbl_size_ptr.i.i19.i976 = getelementptr i8, ptr %761, i64 16
  %offset_tbl_ptr.i.i20.i977 = getelementptr i8, ptr %761, i64 40
  %767 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i1177 = load i64, ptr %hash_coef_ptr.i.i18.i975, align 4, !noalias !22
  %tbl_size.i.i100.i1178 = load i64, ptr %tbl_size_ptr.i.i19.i976, align 4, !noalias !22
  %offset_tbl.i.i101.i1179 = load ptr, ptr %offset_tbl_ptr.i.i20.i977, align 8, !noalias !22
  %product.i.i.i102.i1180 = mul i64 %hash_coef.i.i99.i1177, 4015701072841558310
  %shifted.i.i.i103.i1181 = lshr i64 %product.i.i.i102.i1180, 32
  %xored.i.i.i104.i1182 = xor i64 %shifted.i.i.i103.i1181, %product.i.i.i102.i1180
  %hash.i.i.i105.i1183 = and i64 %xored.i.i.i104.i1182, %tbl_size.i.i100.i1178
  %offset_ptr.i.i106.i1184 = getelementptr i32, ptr %offset_tbl.i.i101.i1179, i64 %hash.i.i.i105.i1183
  %offset.i.i121.i1185 = load i32, ptr %offset_ptr.i.i106.i1184, align 4, !noalias !38
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %770 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %771

771:                                              ; preds = %.cont.cont.i1206, %764
  %.0566.i1186 = phi i32 [ 0, %764 ], [ %775, %.cont.cont.i1206 ]
  %.070565.i1187 = phi i1 [ true, %764 ], [ %837, %.cont.cont.i1206 ]
  %.sroa.0.0564.i1188 = phi ptr [ %761, %764 ], [ %vptr.i142.sroa.speculated.i1209, %.cont.cont.i1206 ]
  %.sroa.17.0561.i1191 = phi i32 [ %offset.i.i121.i1185, %764 ], [ %offset.i.i154.i1223, %.cont.cont.i1206 ]
  %772 = phi <2 x i64> [ %766, %764 ], [ %836, %.cont.cont.i1206 ]
  %773 = extractelement <2 x i64> %772, i64 1
  %.sroa.12.0562.i1190 = inttoptr i64 %773 to ptr
  %774 = extractelement <2 x i64> %772, i64 0
  %.sroa.6.0563.i1189 = inttoptr i64 %774 to ptr
  %775 = add nuw nsw i32 %.0566.i1186, 1
  %776 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1188, 0
  %777 = insertvalue { ptr, ptr, ptr, i32 } %776, ptr %.sroa.6.0563.i1189, 1
  %778 = insertvalue { ptr, ptr, ptr, i32 } %777, ptr %.sroa.12.0562.i1190, 2
  %779 = insertvalue { ptr, ptr, ptr, i32 } %778, i32 %.sroa.17.0561.i1191, 3
  %780 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1188)
  %781 = sext i32 %.sroa.17.0561.i1191 to i64
  %782 = getelementptr ptr, ptr %.sroa.0.0564.i1188, i64 %781
  %783 = getelementptr i8, ptr %782, i64 64
  %784 = load ptr, ptr %783, align 8
  %result.i125.i1192 = call ptr %784({ ptr, ptr, ptr, i32 } %779, ptr nocapture nofree noundef nonnull readonly %2) #15
  %785 = call i32 %result.i125.i1192({ ptr, ptr, ptr, i32 } %779, { ptr, ptr, ptr, i32 } %779, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1187, label %786, label %802

786:                                              ; preds = %771
  %787 = load i32, ptr %22, align 8
  %788 = add i32 %787, -1
  %789 = and i32 %788, %785
  %790 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %791 = load ptr, ptr %23, align 8
  %792 = sext i32 %789 to i64
  %793 = shl nsw i64 %792, 5
  %794 = getelementptr i8, ptr %791, i64 %793
  %795 = load ptr, ptr %794, align 8
  %796 = getelementptr i8, ptr %794, i64 8
  %797 = load i160, ptr %796, align 4
  store ptr %.sroa.0.0564.i1188, ptr %794, align 8
  store i64 %774, ptr %796, align 4
  %.sroa_idx157.i1235 = getelementptr i8, ptr %794, i64 16
  store i64 %773, ptr %.sroa_idx157.i1235, align 4
  %.sroa_idx158.i1236 = getelementptr i8, ptr %794, i64 24
  store i32 %.sroa.17.0561.i1191, ptr %.sroa_idx158.i1236, align 4
  %798 = icmp ne ptr %795, @nil_typ
  %799 = icmp ne ptr %795, null
  %.not92.i1237 = and i1 %798, %799
  %extract.i1239 = lshr i160 %797, 64
  %800 = insertelement <2 x i160> poison, i160 %797, i64 0
  %801 = insertelement <2 x i160> %800, i160 %extract.i1239, i64 1
  br i1 %.not92.i1237, label %.cont.cont.i1206, label %841

802:                                              ; preds = %771
  %803 = add i32 %785, 2127912214
  %804 = shl i32 %785, 12
  %805 = add i32 %803, %804
  %806 = ashr i32 %805, 19
  %807 = xor i32 %805, %806
  %808 = xor i32 %807, -949894596
  %809 = add i32 %808, 374761393
  %810 = shl i32 %808, 5
  %811 = add i32 %809, %810
  %812 = add i32 %811, -744332180
  %813 = shl i32 %811, 9
  %814 = xor i32 %812, %813
  %815 = add i32 %814, -42973499
  %816 = shl i32 %814, 3
  %817 = add i32 %815, %816
  %818 = ashr i32 %817, 16
  %819 = xor i32 %817, %818
  %820 = xor i32 %819, -1252372727
  %821 = load i32, ptr %22, align 8
  %822 = add i32 %821, -1
  %823 = and i32 %822, %820
  %824 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %825 = load ptr, ptr %24, align 8
  %826 = sext i32 %823 to i64
  %827 = shl nsw i64 %826, 5
  %828 = getelementptr i8, ptr %825, i64 %827
  %829 = load ptr, ptr %828, align 8
  %830 = getelementptr i8, ptr %828, i64 8
  %831 = load i160, ptr %830, align 4
  store ptr %.sroa.0.0564.i1188, ptr %828, align 8
  store i64 %774, ptr %830, align 4
  %.sroa_idx161.i1196 = getelementptr i8, ptr %828, i64 16
  store i64 %773, ptr %.sroa_idx161.i1196, align 4
  %.sroa_idx162.i1197 = getelementptr i8, ptr %828, i64 24
  store i32 %.sroa.17.0561.i1191, ptr %.sroa_idx162.i1197, align 4
  %832 = icmp ne ptr %829, @nil_typ
  %833 = icmp ne ptr %829, null
  %.not90.i1198 = and i1 %832, %833
  %extract607.i1200 = lshr i160 %831, 64
  %834 = insertelement <2 x i160> poison, i160 %831, i64 0
  %835 = insertelement <2 x i160> %834, i160 %extract607.i1200, i64 1
  br i1 %.not90.i1198, label %.cont.cont.i1206, label %841

.cont.cont.i1206:                                 ; preds = %802, %786
  %vptr.i142.sroa.speculated.i1209 = phi ptr [ %795, %786 ], [ %829, %802 ]
  %.in1450 = phi <2 x i160> [ %801, %786 ], [ %835, %802 ]
  %836 = trunc <2 x i160> %.in1450 to <2 x i64>
  %837 = xor i1 %.070565.i1187, true
  %hash_coef_ptr.i.i143.i1212 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1209, i64 8
  %tbl_size_ptr.i.i144.i1213 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1209, i64 16
  %offset_tbl_ptr.i.i145.i1214 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1209, i64 40
  %hash_coef.i.i146.i1215 = load i64, ptr %hash_coef_ptr.i.i143.i1212, align 4
  %tbl_size.i.i147.i1216 = load i64, ptr %tbl_size_ptr.i.i144.i1213, align 4
  %offset_tbl.i.i148.i1217 = load ptr, ptr %offset_tbl_ptr.i.i145.i1214, align 8
  %product.i.i.i149.i1218 = mul i64 %hash_coef.i.i146.i1215, 4015701072841558310
  %shifted.i.i.i150.i1219 = lshr i64 %product.i.i.i149.i1218, 32
  %xored.i.i.i151.i1220 = xor i64 %shifted.i.i.i150.i1219, %product.i.i.i149.i1218
  %hash.i.i.i152.i1221 = and i64 %xored.i.i.i151.i1220, %tbl_size.i.i147.i1216
  %offset_ptr.i.i153.i1222 = getelementptr i32, ptr %offset_tbl.i.i148.i1217, i64 %hash.i.i.i152.i1221
  %offset.i.i154.i1223 = load i32, ptr %offset_ptr.i.i153.i1222, align 4
  %838 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %839 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %840 = icmp ult i32 %.0566.i1186, 99
  br i1 %840, label %771, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1241

841:                                              ; preds = %802, %786
  %842 = phi ptr [ %6, %802 ], [ %5, %786 ]
  %843 = load i32, ptr %28, align 4
  store i32 %843, ptr %842, align 4
  %844 = add i32 %843, 1
  %845 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %844, ptr %28, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1241

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1241: ; preds = %.cont.cont.i1206, %841
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i973

._crit_edge.i973:                                 ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1241, %.lr.ph.i958
  %846 = add nuw nsw i32 %.060.i971, 1
  %847 = icmp slt i32 %846, %752
  br i1 %847, label %.lr.ph.i958, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991: ; preds = %._crit_edge.i973
  %848 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %849

849:                                              ; preds = %._crit_edge.i1009, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991
  %.060.i1007 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991 ], [ %938, %._crit_edge.i1009 ]
  %850 = zext nneg i32 %.060.i1007 to i64
  %851 = shl nuw nsw i64 %850, 5
  %852 = getelementptr i8, ptr %751, i64 %851
  %853 = load ptr, ptr %852, align 8
  %854 = icmp ne ptr %853, @nil_typ
  %855 = icmp ne ptr %853, null
  %.not16.i1008 = and i1 %854, %855
  br i1 %.not16.i1008, label %856, label %._crit_edge.i1009

856:                                              ; preds = %849
  %857 = getelementptr i8, ptr %852, i64 8
  %858 = load <2 x i64>, ptr %857, align 4
  %hash_coef_ptr.i.i18.i1011 = getelementptr i8, ptr %853, i64 8
  %tbl_size_ptr.i.i19.i1012 = getelementptr i8, ptr %853, i64 16
  %offset_tbl_ptr.i.i20.i1013 = getelementptr i8, ptr %853, i64 40
  %859 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i1259 = load i64, ptr %hash_coef_ptr.i.i18.i1011, align 4, !noalias !22
  %tbl_size.i.i100.i1260 = load i64, ptr %tbl_size_ptr.i.i19.i1012, align 4, !noalias !22
  %offset_tbl.i.i101.i1261 = load ptr, ptr %offset_tbl_ptr.i.i20.i1013, align 8, !noalias !22
  %product.i.i.i102.i1262 = mul i64 %hash_coef.i.i99.i1259, 4015701072841558310
  %shifted.i.i.i103.i1263 = lshr i64 %product.i.i.i102.i1262, 32
  %xored.i.i.i104.i1264 = xor i64 %shifted.i.i.i103.i1263, %product.i.i.i102.i1262
  %hash.i.i.i105.i1265 = and i64 %xored.i.i.i104.i1264, %tbl_size.i.i100.i1260
  %offset_ptr.i.i106.i1266 = getelementptr i32, ptr %offset_tbl.i.i101.i1261, i64 %hash.i.i.i105.i1265
  %offset.i.i121.i1267 = load i32, ptr %offset_ptr.i.i106.i1266, align 4, !noalias !41
  %860 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %861 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %862 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %863

863:                                              ; preds = %.cont.cont.i1288, %856
  %.0566.i1268 = phi i32 [ 0, %856 ], [ %867, %.cont.cont.i1288 ]
  %.070565.i1269 = phi i1 [ true, %856 ], [ %929, %.cont.cont.i1288 ]
  %.sroa.0.0564.i1270 = phi ptr [ %853, %856 ], [ %vptr.i142.sroa.speculated.i1291, %.cont.cont.i1288 ]
  %.sroa.17.0561.i1273 = phi i32 [ %offset.i.i121.i1267, %856 ], [ %offset.i.i154.i1305, %.cont.cont.i1288 ]
  %864 = phi <2 x i64> [ %858, %856 ], [ %928, %.cont.cont.i1288 ]
  %865 = extractelement <2 x i64> %864, i64 1
  %.sroa.12.0562.i1272 = inttoptr i64 %865 to ptr
  %866 = extractelement <2 x i64> %864, i64 0
  %.sroa.6.0563.i1271 = inttoptr i64 %866 to ptr
  %867 = add nuw nsw i32 %.0566.i1268, 1
  %868 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1270, 0
  %869 = insertvalue { ptr, ptr, ptr, i32 } %868, ptr %.sroa.6.0563.i1271, 1
  %870 = insertvalue { ptr, ptr, ptr, i32 } %869, ptr %.sroa.12.0562.i1272, 2
  %871 = insertvalue { ptr, ptr, ptr, i32 } %870, i32 %.sroa.17.0561.i1273, 3
  %872 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1270)
  %873 = sext i32 %.sroa.17.0561.i1273 to i64
  %874 = getelementptr ptr, ptr %.sroa.0.0564.i1270, i64 %873
  %875 = getelementptr i8, ptr %874, i64 64
  %876 = load ptr, ptr %875, align 8
  %result.i125.i1274 = call ptr %876({ ptr, ptr, ptr, i32 } %871, ptr nocapture nofree noundef nonnull readonly %2) #15
  %877 = call i32 %result.i125.i1274({ ptr, ptr, ptr, i32 } %871, { ptr, ptr, ptr, i32 } %871, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1269, label %878, label %894

878:                                              ; preds = %863
  %879 = load i32, ptr %22, align 8
  %880 = add i32 %879, -1
  %881 = and i32 %880, %877
  %882 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %883 = load ptr, ptr %23, align 8
  %884 = sext i32 %881 to i64
  %885 = shl nsw i64 %884, 5
  %886 = getelementptr i8, ptr %883, i64 %885
  %887 = load ptr, ptr %886, align 8
  %888 = getelementptr i8, ptr %886, i64 8
  %889 = load i160, ptr %888, align 4
  store ptr %.sroa.0.0564.i1270, ptr %886, align 8
  store i64 %866, ptr %888, align 4
  %.sroa_idx157.i1317 = getelementptr i8, ptr %886, i64 16
  store i64 %865, ptr %.sroa_idx157.i1317, align 4
  %.sroa_idx158.i1318 = getelementptr i8, ptr %886, i64 24
  store i32 %.sroa.17.0561.i1273, ptr %.sroa_idx158.i1318, align 4
  %890 = icmp ne ptr %887, @nil_typ
  %891 = icmp ne ptr %887, null
  %.not92.i1319 = and i1 %890, %891
  %extract.i1321 = lshr i160 %889, 64
  %892 = insertelement <2 x i160> poison, i160 %889, i64 0
  %893 = insertelement <2 x i160> %892, i160 %extract.i1321, i64 1
  br i1 %.not92.i1319, label %.cont.cont.i1288, label %933

894:                                              ; preds = %863
  %895 = add i32 %877, 2127912214
  %896 = shl i32 %877, 12
  %897 = add i32 %895, %896
  %898 = ashr i32 %897, 19
  %899 = xor i32 %897, %898
  %900 = xor i32 %899, -949894596
  %901 = add i32 %900, 374761393
  %902 = shl i32 %900, 5
  %903 = add i32 %901, %902
  %904 = add i32 %903, -744332180
  %905 = shl i32 %903, 9
  %906 = xor i32 %904, %905
  %907 = add i32 %906, -42973499
  %908 = shl i32 %906, 3
  %909 = add i32 %907, %908
  %910 = ashr i32 %909, 16
  %911 = xor i32 %909, %910
  %912 = xor i32 %911, -1252372727
  %913 = load i32, ptr %22, align 8
  %914 = add i32 %913, -1
  %915 = and i32 %914, %912
  %916 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %917 = load ptr, ptr %24, align 8
  %918 = sext i32 %915 to i64
  %919 = shl nsw i64 %918, 5
  %920 = getelementptr i8, ptr %917, i64 %919
  %921 = load ptr, ptr %920, align 8
  %922 = getelementptr i8, ptr %920, i64 8
  %923 = load i160, ptr %922, align 4
  store ptr %.sroa.0.0564.i1270, ptr %920, align 8
  store i64 %866, ptr %922, align 4
  %.sroa_idx161.i1278 = getelementptr i8, ptr %920, i64 16
  store i64 %865, ptr %.sroa_idx161.i1278, align 4
  %.sroa_idx162.i1279 = getelementptr i8, ptr %920, i64 24
  store i32 %.sroa.17.0561.i1273, ptr %.sroa_idx162.i1279, align 4
  %924 = icmp ne ptr %921, @nil_typ
  %925 = icmp ne ptr %921, null
  %.not90.i1280 = and i1 %924, %925
  %extract607.i1282 = lshr i160 %923, 64
  %926 = insertelement <2 x i160> poison, i160 %923, i64 0
  %927 = insertelement <2 x i160> %926, i160 %extract607.i1282, i64 1
  br i1 %.not90.i1280, label %.cont.cont.i1288, label %933

.cont.cont.i1288:                                 ; preds = %894, %878
  %vptr.i142.sroa.speculated.i1291 = phi ptr [ %887, %878 ], [ %921, %894 ]
  %.in1451 = phi <2 x i160> [ %893, %878 ], [ %927, %894 ]
  %928 = trunc <2 x i160> %.in1451 to <2 x i64>
  %929 = xor i1 %.070565.i1269, true
  %hash_coef_ptr.i.i143.i1294 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1291, i64 8
  %tbl_size_ptr.i.i144.i1295 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1291, i64 16
  %offset_tbl_ptr.i.i145.i1296 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1291, i64 40
  %hash_coef.i.i146.i1297 = load i64, ptr %hash_coef_ptr.i.i143.i1294, align 4
  %tbl_size.i.i147.i1298 = load i64, ptr %tbl_size_ptr.i.i144.i1295, align 4
  %offset_tbl.i.i148.i1299 = load ptr, ptr %offset_tbl_ptr.i.i145.i1296, align 8
  %product.i.i.i149.i1300 = mul i64 %hash_coef.i.i146.i1297, 4015701072841558310
  %shifted.i.i.i150.i1301 = lshr i64 %product.i.i.i149.i1300, 32
  %xored.i.i.i151.i1302 = xor i64 %shifted.i.i.i150.i1301, %product.i.i.i149.i1300
  %hash.i.i.i152.i1303 = and i64 %xored.i.i.i151.i1302, %tbl_size.i.i147.i1298
  %offset_ptr.i.i153.i1304 = getelementptr i32, ptr %offset_tbl.i.i148.i1299, i64 %hash.i.i.i152.i1303
  %offset.i.i154.i1305 = load i32, ptr %offset_ptr.i.i153.i1304, align 4
  %930 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %931 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %932 = icmp ult i32 %.0566.i1268, 99
  br i1 %932, label %863, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1323

933:                                              ; preds = %894, %878
  %934 = phi ptr [ %4, %894 ], [ %3, %878 ]
  %935 = load i32, ptr %28, align 4
  store i32 %935, ptr %934, align 4
  %936 = add i32 %935, 1
  %937 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %936, ptr %28, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1323

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1323: ; preds = %.cont.cont.i1288, %933
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i1009

._crit_edge.i1009:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1323, %849
  %938 = add nuw nsw i32 %.060.i1007, 1
  %939 = icmp slt i32 %938, %752
  br i1 %939, label %849, label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %._crit_edge.i1009, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit461, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %940 = icmp slt i32 %32, %0
  br i1 %940, label %._crit_edge, label %._crit_edge2

._crit_edge2:                                     ; preds = %HashMap_insert_keyK_valueV.exit
  %941 = call i64 @clock()
  %942 = add nsw i32 %0, -1
  %.sroa.0117.0.insert.ext = zext nneg i32 %942 to i160
  %943 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext, 1
  %944 = load ptr, ptr %20, align 8
  %945 = call i32 %944({ ptr, i160 } %943) #7
  %946 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %947 = load i32, ptr %22, align 8
  %948 = add i32 %947, -1
  %949 = and i32 %948, %945
  %950 = load ptr, ptr %23, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %951 = sext i32 %949 to i64
  %952 = shl nsw i64 %951, 5
  %953 = getelementptr i8, ptr %950, i64 %952
  %954 = load ptr, ptr %953, align 8
  %955 = icmp ne ptr %954, @nil_typ
  %956 = icmp ne ptr %954, null
  %.not44.i = and i1 %955, %956
  br i1 %.not44.i, label %957, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

957:                                              ; preds = %._crit_edge2
  %958 = getelementptr i8, ptr %953, i64 8
  %959 = load i64, ptr %958, align 4
  %.sroa_idx.i659 = getelementptr i8, ptr %953, i64 16
  %960 = load i64, ptr %.sroa_idx.i659, align 4
  %961 = inttoptr i64 %959 to ptr
  %962 = inttoptr i64 %960 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %954, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %954, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %954, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !44
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !44
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !44
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !44
  %963 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %954, 0
  %964 = insertvalue { ptr, ptr, ptr, i32 } %963, ptr %961, 1
  %965 = insertvalue { ptr, ptr, ptr, i32 } %964, ptr %962, 2
  %966 = insertvalue { ptr, ptr, ptr, i32 } %965, i32 %offset.i.i57.i, 3
  %967 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %968 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %954) #34
  %969 = sext i32 %offset.i.i57.i to i64
  %970 = getelementptr ptr, ptr %954, i64 %969
  %971 = getelementptr i8, ptr %970, i64 64
  %972 = load ptr, ptr %971, align 8
  %result.i.i660 = call ptr %972({ ptr, ptr, ptr, i32 } %966, ptr nocapture nofree noundef nonnull readonly %2) #15
  %973 = call i32 %result.i.i660({ ptr, ptr, ptr, i32 } %966, { ptr, ptr, ptr, i32 } %966, ptr nonnull align 8 %2) #7
  %974 = icmp eq i32 %973, %945
  br i1 %974, label %._crit_edge.i661, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i661:                                 ; preds = %957
  %975 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %976 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %954)
  %977 = getelementptr i8, ptr %970, i64 48
  %978 = load ptr, ptr %977, align 8
  %result.i59.i = call ptr %978({ ptr, ptr, ptr, i32 } %966, ptr nocapture nofree noundef nonnull readonly %2) #15
  %979 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %966, { ptr, ptr, ptr, i32 } %966, ptr nonnull align 8 %2) #7
  %980 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %981 = load ptr, ptr %21, align 8
  %982 = call i1 %981({ ptr, i160 } %979, { ptr, i160 } %943) #7
  br i1 %982, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i661, %._crit_edge2, %957
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %990

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i661
  %983 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %954)
  %985 = getelementptr i8, ptr %970, i64 56
  %986 = load ptr, ptr %985, align 8
  %result.i60.i = call ptr %986({ ptr, ptr, ptr, i32 } %966, ptr nocapture nofree noundef nonnull readonly %2) #15
  %987 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %966, { ptr, ptr, ptr, i32 } %966, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %987, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %988 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %989 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %988, %989
  br i1 %.not63.i, label %HashMap_get_keyK.exit, label %990

990:                                              ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %991 = add i32 %945, 2127912214
  %992 = shl i32 %945, 12
  %993 = add i32 %991, %992
  %994 = ashr i32 %993, 19
  %995 = xor i32 %993, %994
  %996 = xor i32 %995, -949894596
  %997 = add i32 %996, 374761393
  %998 = shl i32 %996, 5
  %999 = add i32 %997, %998
  %1000 = add i32 %999, -744332180
  %1001 = shl i32 %999, 9
  %1002 = xor i32 %1000, %1001
  %1003 = add i32 %1002, -42973499
  %1004 = shl i32 %1002, 3
  %1005 = add i32 %1003, %1004
  %1006 = ashr i32 %1005, 16
  %1007 = xor i32 %1005, %1006
  %1008 = xor i32 %1007, -1252372727
  %1009 = load i32, ptr %22, align 8
  %1010 = add i32 %1009, -1
  %1011 = and i32 %1010, %1008
  %1012 = load ptr, ptr %24, align 8
  %1013 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1014 = sext i32 %1011 to i64
  %1015 = shl nsw i64 %1014, 5
  %1016 = getelementptr i8, ptr %1012, i64 %1015
  %1017 = load ptr, ptr %1016, align 8
  %1018 = icmp ne ptr %1017, @nil_typ
  %1019 = icmp ne ptr %1017, null
  %.not44.i691 = and i1 %1018, %1019
  br i1 %.not44.i691, label %1020, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715

1020:                                             ; preds = %990
  %1021 = getelementptr i8, ptr %1016, i64 8
  %1022 = load i64, ptr %1021, align 4
  %.sroa_idx.i695 = getelementptr i8, ptr %1016, i64 16
  %1023 = load i64, ptr %.sroa_idx.i695, align 4
  %1024 = inttoptr i64 %1022 to ptr
  %1025 = inttoptr i64 %1023 to ptr
  %hash_coef_ptr.i.i46.i696 = getelementptr i8, ptr %1017, i64 8
  %tbl_size_ptr.i.i47.i697 = getelementptr i8, ptr %1017, i64 16
  %offset_tbl_ptr.i.i48.i698 = getelementptr i8, ptr %1017, i64 40
  %hash_coef.i.i49.i699 = load i64, ptr %hash_coef_ptr.i.i46.i696, align 4, !noalias !47
  %tbl_size.i.i50.i700 = load i64, ptr %tbl_size_ptr.i.i47.i697, align 4, !noalias !47
  %offset_tbl.i.i51.i701 = load ptr, ptr %offset_tbl_ptr.i.i48.i698, align 8, !noalias !47
  %product.i.i.i52.i702 = mul i64 %hash_coef.i.i49.i699, 4015701072841558310
  %shifted.i.i.i53.i703 = lshr i64 %product.i.i.i52.i702, 32
  %xored.i.i.i54.i704 = xor i64 %shifted.i.i.i53.i703, %product.i.i.i52.i702
  %hash.i.i.i55.i705 = and i64 %xored.i.i.i54.i704, %tbl_size.i.i50.i700
  %offset_ptr.i.i56.i706 = getelementptr i32, ptr %offset_tbl.i.i51.i701, i64 %hash.i.i.i55.i705
  %offset.i.i57.i707 = load i32, ptr %offset_ptr.i.i56.i706, align 4, !noalias !47
  %1026 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1017, 0
  %1027 = insertvalue { ptr, ptr, ptr, i32 } %1026, ptr %1024, 1
  %1028 = insertvalue { ptr, ptr, ptr, i32 } %1027, ptr %1025, 2
  %1029 = insertvalue { ptr, ptr, ptr, i32 } %1028, i32 %offset.i.i57.i707, 3
  %1030 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1031 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1017) #34
  %1032 = sext i32 %offset.i.i57.i707 to i64
  %1033 = getelementptr ptr, ptr %1017, i64 %1032
  %1034 = getelementptr i8, ptr %1033, i64 64
  %1035 = load ptr, ptr %1034, align 8
  %result.i.i708 = call ptr %1035({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1036 = call i32 %result.i.i708({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 %2) #7
  %1037 = icmp eq i32 %1036, %945
  br i1 %1037, label %._crit_edge.i709, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715

._crit_edge.i709:                                 ; preds = %1020
  %1038 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1039 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1017)
  %1040 = getelementptr i8, ptr %1033, i64 48
  %1041 = load ptr, ptr %1040, align 8
  %result.i59.i710 = call ptr %1041({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1042 = call { ptr, i160 } %result.i59.i710({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 %2) #7
  %1043 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1044 = load ptr, ptr %21, align 8
  %1045 = call i1 %1044({ ptr, i160 } %1042, { ptr, i160 } %943) #7
  br i1 %1045, label %1046, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715

1046:                                             ; preds = %._crit_edge.i709
  %1047 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1048 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1017)
  %1049 = getelementptr i8, ptr %1033, i64 56
  %1050 = load ptr, ptr %1049, align 8
  %result.i60.i712 = call ptr %1050({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1051 = call { ptr, i160 } %result.i60.i712({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i713 = extractvalue { ptr, i160 } %1051, 0
  %.fca.1.extract22.i714 = extractvalue { ptr, i160 } %1051, 1
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715: ; preds = %990, %1020, %._crit_edge.i709, %1046
  %.reg2mem43.sroa.3.077.i692 = phi i160 [ %.fca.1.extract22.i714, %1046 ], [ poison, %._crit_edge.i709 ], [ poison, %990 ], [ poison, %1020 ]
  %1052 = phi ptr [ %.fca.0.extract21.i713, %1046 ], [ @nil_typ, %._crit_edge.i709 ], [ @nil_typ, %990 ], [ @nil_typ, %1020 ]
  %.reload40.fca.0.insert.i693 = insertvalue { ptr, i160 } poison, ptr %1052, 0
  %.reload40.fca.1.insert.i694 = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i693, i160 %.reg2mem43.sroa.3.077.i692, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1053 = icmp ne ptr %1052, @nil_typ
  %1054 = icmp ne ptr %1052, null
  %.not65.not.not.i = and i1 %1053, %1054
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %1052, ptr @nil_typ
  br label %HashMap_get_keyK.exit

HashMap_get_keyK.exit:                            ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715
  %.pn.i = phi { ptr, i160 } [ %987, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %.reload40.fca.1.insert.i694, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715 ]
  %1055 = phi ptr [ %.fca.0.extract21.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715 ]
  %1056 = icmp ne ptr %1055, @nil_typ
  %1057 = icmp ne ptr %1055, null
  %.not143 = and i1 %1056, %1057
  br i1 %.not143, label %._crit_edge3, label %._crit_edge4

._crit_edge3:                                     ; preds = %HashMap_get_keyK.exit
  %.fca.1.extract..sroa.354.0101.i = extractvalue { ptr, i160 } %.pn.i, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0101.i to i32
  %.not147 = icmp eq i32 %0, %.sroa.2.8.extract.trunc
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %HashMap_get_keyK.exit, %._crit_edge3
  %.2 = phi i1 [ %.not147, %._crit_edge3 ], [ false, %HashMap_get_keyK.exit ]
  %1058 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1059 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %1060 = load i32, ptr %28, align 4
  %.not148 = icmp eq i32 %1060, %0
  %1061 = select i1 %.not148, i1 %.2, i1 false
  %1062 = select i1 %1061, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %1063 = bitcast <4 x i8> %1062 to i32
  br label %._crit_edge.lr.ph.i

1064:                                             ; preds = %1
  %1065 = call i64 @clock()
  %1066 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %1064, %._crit_edge4
  %1068 = phi i64 [ %941, %._crit_edge4 ], [ %1065, %1064 ]
  %.reg2mem15.0.in = phi i32 [ %1063, %._crit_edge4 ], [ 1397965136, %1064 ]
  %result.i162 = call noalias align 32 dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i162, align 32
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1071 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i729 = call noalias dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(17) %result.i.i729, ptr noundef nonnull align 32 dereferenceable(17) %result.i162, i64 17, i1 false)
  %1072 = sub i64 %1068, %26
  %1073 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1074 = getelementptr i8, ptr %result.i.i729, i64 17
  store i8 0, ptr %1074, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i729)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i376.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376.i)
  %1075 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #16
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i390.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390.i)
  %1076 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1072) #16
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i409.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409.i)
  br i1 %27, label %._crit_edge1.i, label %._crit_edge.lr.ph.i745

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i
  %1077 = icmp sgt i64 %1072, 0
  br i1 %1077, label %1078, label %._crit_edge.lr.ph.i429.i

1078:                                             ; preds = %._crit_edge1.i
  %1079 = zext nneg i32 %0 to i64
  %1080 = mul i64 %1072, 1000000
  %1081 = sdiv i64 %1080, %1079
  br label %._crit_edge.lr.ph.i429.i

._crit_edge.lr.ph.i429.i:                         ; preds = %1078, %._crit_edge1.i
  %.0.i = phi i64 [ %1081, %1078 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i428.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i)
  %1082 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #16
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %1083 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i447.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %1084 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i374.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447.i)
  br label %._crit_edge.lr.ph.i745

._crit_edge.lr.ph.i745:                           ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i429.i
  %result.i166 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i166, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1085 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1086 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i744 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i744, ptr noundef nonnull align 32 dereferenceable(18) %result.i166, i64 18, i1 false)
  %1087 = getelementptr i8, ptr %result.i.i744, i64 18
  store i8 0, ptr %1087, align 1
  %puts.i350 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i744)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1088 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1089 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i763 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i32 %.reg2mem15.0.in, ptr %result.i.i763, align 1
  %1091 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1092 = getelementptr i8, ptr %result.i.i763, i64 4
  store i8 0, ptr %1092, align 1
  %puts.i370 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i763)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #4

declare i64 @clock() local_unnamed_addr

define void @benchmark_insert_random(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %oldProtect.i317 = alloca i32, align 4
  %oldProtect.i313 = alloca i32, align 4
  %oldProtect.i272 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0231.sroa.0 = alloca i8, align 8
  %result.i268 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i268, align 8
  %27 = getelementptr inbounds i8, ptr %result.i268, i64 8
  store ptr @_parameterization_Ptri32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i268, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %28, align 8
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i268) #38
  %result.i269 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i270 = call i32 @VirtualProtect(ptr nofree %result.i269, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i269, ptr noalias nofree noundef nonnull readnone @bnhzmayidc, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i269) #39
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i269) #38
  %result.i271 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i272)
  %result.i273 = call i32 @VirtualProtect(ptr nofree %result.i271, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i272) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i272)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i271, ptr noalias nofree noundef nonnull readnone @fsgroehfsq, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i274 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i271) #39
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i271) #38
  %32 = getelementptr inbounds i8, ptr %result.i268, i64 48
  store ptr %ret.i, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i268, i64 56
  store ptr %ret.i274, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i268, i64 40
  store i32 8, ptr %34, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %35 = getelementptr inbounds i8, ptr %result.i268, i64 24
  store ptr %result.i.i, ptr %35, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %36 = getelementptr inbounds i8, ptr %result.i268, i64 32
  store ptr %result.i9.i, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %38 = sext i32 %0 to i64
  %39 = shl nsw i64 %38, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %39, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %result.i311 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i311, align 8
  %41 = getelementptr inbounds i8, ptr %result.i311, i64 8
  store ptr @_parameterization_Ptri1, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i311, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i311)
  %result.i312 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i313)
  %result.i314 = call i32 @VirtualProtect(ptr nofree %result.i312, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i313) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i313)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i312, ptr noalias nofree noundef nonnull readnone @mopmykeazj, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i315 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i312) #39
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i312)
  %result.i316 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i317)
  %result.i318 = call i32 @VirtualProtect(ptr nofree %result.i316, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i317) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i317)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i316, ptr noalias nofree noundef nonnull readnone @ujjpaegnhk, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i319 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i316) #39
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i316)
  %46 = getelementptr inbounds i8, ptr %result.i311, i64 48
  store ptr %ret.i315, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i311, i64 56
  store ptr %ret.i319, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i311, i64 40
  store i32 8, ptr %48, align 8
  %result.i.i514 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %49 = getelementptr inbounds i8, ptr %result.i311, i64 24
  store ptr %result.i.i514, ptr %49, align 8
  %result.i9.i515 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %50 = getelementptr inbounds i8, ptr %result.i311, i64 32
  store ptr %result.i9.i515, ptr %50, align 8
  %51 = icmp sgt i32 %0, 0
  br i1 %51, label %._crit_edge.lr.ph, label %._crit_edge2._crit_edge.thread

._crit_edge2._crit_edge.thread:                   ; preds = %1
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %54 = call i64 @clock()
  %55 = call i64 @clock()
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph:                                ; preds = %1
  %58 = add nsw i32 %0, -1
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %62 = getelementptr inbounds i8, ptr %result.i311, i64 44
  %63 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i311, 1
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr undef, 2
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 10, 3
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %HashMap_insert_keyK_valueV.exit
  %66 = phi i32 [ 123, %._crit_edge.lr.ph ], [ %69, %HashMap_insert_keyK_valueV.exit ]
  %.0473 = phi i32 [ -1, %._crit_edge.lr.ph ], [ %spec.select, %HashMap_insert_keyK_valueV.exit ]
  %.0247472 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %981, %HashMap_insert_keyK_valueV.exit ]
  %67 = mul i32 %66, 1103515245
  %68 = add i32 %67, 12345
  %69 = and i32 %68, 2147483647
  %.sroa.0241.0.insert.ext = zext nneg i32 %69 to i160
  %70 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0241.0.insert.ext, 1
  %71 = zext nneg i32 %.0247472 to i64
  %72 = shl nuw nsw i64 %71, 2
  %73 = getelementptr i8, ptr %result.i4.i, i64 %72
  store i32 %69, ptr %73, align 1
  %74 = icmp eq i32 %.0247472, %58
  %spec.select = select i1 %74, i32 %69, i32 %.0473
  store i1 true, ptr %.sroa.0231.sroa.0, align 8
  %.sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.0. = load i8, ptr %.sroa.0231.sroa.0, align 8
  %.sroa.0231.0.insert.ext = zext i8 %.sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.0. to i160
  %75 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0231.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %76 = load ptr, ptr %result.i311, align 8
  %77 = load ptr, ptr %46, align 8
  %78 = call i32 %77({ ptr, i160 } %70) #7
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %80 = load i32, ptr %48, align 8
  %81 = add i32 %80, -1
  %82 = and i32 %81, %78
  %83 = load ptr, ptr %49, align 8
  %84 = load ptr, ptr %41, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %85 = sext i32 %82 to i64
  %86 = shl nsw i64 %85, 5
  %87 = getelementptr i8, ptr %83, i64 %86
  %88 = load ptr, ptr %87, align 8
  %89 = getelementptr i8, ptr %87, i64 8
  %90 = icmp ne ptr %88, @nil_typ
  %91 = icmp ne ptr %88, null
  %.not64.i = and i1 %90, %91
  br i1 %.not64.i, label %92, label %189

92:                                               ; preds = %._crit_edge
  %93 = load i64, ptr %89, align 4
  %.sroa_idx.i = getelementptr i8, ptr %87, i64 16
  %94 = load i64, ptr %.sroa_idx.i, align 4
  %95 = inttoptr i64 %93 to ptr
  %96 = inttoptr i64 %94 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %88, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %88, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %88, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !50
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !50
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !50
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !50
  %97 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %88, 0
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, ptr %95, 1
  %99 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %96, 2
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, i32 %offset.i.i77.i, 3
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %88) #34
  %103 = sext i32 %offset.i.i77.i to i64
  %104 = getelementptr ptr, ptr %88, i64 %103
  %105 = getelementptr i8, ptr %104, i64 64
  %106 = load ptr, ptr %105, align 8
  %result.i.i881 = call ptr %106({ ptr, ptr, ptr, i32 } %100, ptr nocapture nofree noundef nonnull readonly %2) #15
  %107 = call i32 %result.i.i881({ ptr, ptr, ptr, i32 } %100, { ptr, ptr, ptr, i32 } %100, ptr nonnull align 8 %2) #7
  %108 = icmp eq i32 %107, %78
  br i1 %108, label %._crit_edge.i882, label %189

._crit_edge.i882:                                 ; preds = %92
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %88)
  %111 = getelementptr i8, ptr %104, i64 48
  %112 = load ptr, ptr %111, align 8
  %result.i79.i = call ptr %112({ ptr, ptr, ptr, i32 } %100, ptr nocapture nofree noundef nonnull readonly %2) #15
  %113 = call { ptr, i160 } %result.i79.i({ ptr, ptr, ptr, i32 } %100, { ptr, ptr, ptr, i32 } %100, ptr nonnull align 8 %2) #7
  %114 = load ptr, ptr %47, align 8
  %115 = call i1 %114({ ptr, i160 } %113, { ptr, i160 } %70) #7
  br i1 %115, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %189

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i882
  %116 = load ptr, ptr %result.i311, align 8
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %118 = load ptr, ptr %41, align 8
  %119 = load ptr, ptr %116, align 8, !alias.scope !53
  %120 = getelementptr i8, ptr %119, i64 72
  %121 = load ptr, ptr %120, align 8, !alias.scope !53
  %result.i.i.i883 = call { i64, i64 } %121(ptr nocapture nofree nonnull readonly %116) #5, !alias.scope !53
  %122 = extractvalue { i64, i64 } %result.i.i.i883, 0
  %123 = extractvalue { i64, i64 } %result.i.i.i883, 1
  %124 = urem i64 20, %123
  %125 = icmp eq i64 %124, 0
  %126 = sub i64 %123, %124
  %127 = select i1 %125, i64 0, i64 %126
  %128 = add i64 %122, 20
  %129 = add i64 %128, %127
  %130 = load ptr, ptr %118, align 8, !alias.scope !53
  %131 = getelementptr i8, ptr %130, i64 72
  %132 = load ptr, ptr %131, align 8, !alias.scope !53
  %result.i1.i.i884 = call { i64, i64 } %132(ptr nocapture nofree nonnull readonly %118) #5, !alias.scope !53
  %133 = extractvalue { i64, i64 } %result.i1.i.i884, 0
  %134 = extractvalue { i64, i64 } %result.i1.i.i884, 1
  %135 = call i64 @llvm.umax.i64(i64 %123, i64 %134)
  %136 = call i64 @llvm.umax.i64(i64 %135, i64 8)
  %137 = urem i64 %129, %134
  %138 = icmp eq i64 %137, 0
  %139 = sub i64 %134, %137
  %140 = select i1 %138, i64 0, i64 %139
  %141 = add i64 %133, %129
  %142 = add i64 %141, %140
  %143 = urem i64 %142, %136
  %144 = icmp eq i64 %143, 0
  %145 = sub i64 %136, %143
  %146 = select i1 %144, i64 0, i64 %145
  %147 = add i64 %146, %142
  %result.i83.i885 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %147, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %116, ptr %result.i83.i885, align 8
  %148 = getelementptr inbounds i8, ptr %result.i83.i885, i64 8
  store ptr %118, ptr %148, align 8
  %149 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i885)
  %150 = load ptr, ptr %116, align 8
  %151 = getelementptr i8, ptr %150, i64 72
  %152 = load ptr, ptr %151, align 8
  %result.i.i114.i = call { i64, i64 } %152(ptr nocapture nofree nonnull readonly %116) #5
  %153 = extractvalue { i64, i64 } %result.i.i114.i, 1
  %154 = urem i64 20, %153
  %155 = icmp eq i64 %154, 0
  %reass.sub3114 = sub i64 %153, %154
  %156 = add i64 %reass.sub3114, 20
  %157 = select i1 %155, i64 20, i64 %156
  %158 = getelementptr i8, ptr %result.i83.i885, i64 %157
  %159 = getelementptr i8, ptr %150, i64 64
  %160 = load ptr, ptr %159, align 8
  call void %160({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %116, ptr nocapture nofree writeonly %158) #12
  %161 = load ptr, ptr %result.i83.i885, align 8
  %162 = load ptr, ptr %161, align 8
  %163 = getelementptr i8, ptr %162, i64 72
  %164 = load ptr, ptr %163, align 8
  %result.i.i115.i = call { i64, i64 } %164(ptr nocapture nofree nonnull readonly %161) #5
  %165 = extractvalue { i64, i64 } %result.i.i115.i, 0
  %166 = extractvalue { i64, i64 } %result.i.i115.i, 1
  %167 = urem i64 20, %166
  %168 = icmp eq i64 %167, 0
  %169 = sub i64 %166, %167
  %170 = select i1 %168, i64 0, i64 %169
  %171 = add i64 %165, 20
  %172 = add i64 %171, %170
  %173 = load ptr, ptr %148, align 8
  %174 = load ptr, ptr %173, align 8
  %175 = getelementptr i8, ptr %174, i64 72
  %176 = load ptr, ptr %175, align 8
  %result.i1.i116.i = call { i64, i64 } %176(ptr nocapture nofree nonnull readonly %173) #5
  %177 = extractvalue { i64, i64 } %result.i1.i116.i, 1
  %178 = urem i64 %172, %177
  %179 = icmp eq i64 %178, 0
  %180 = sub i64 %177, %178
  %181 = select i1 %179, i64 0, i64 %180
  %182 = getelementptr i8, ptr %result.i83.i885, i64 %172
  %183 = getelementptr i8, ptr %182, i64 %181
  %184 = getelementptr i8, ptr %174, i64 64
  %185 = load ptr, ptr %184, align 8
  call void %185({ ptr, i160 } %75, ptr nocapture nofree nonnull readonly %173, ptr nocapture nofree writeonly %183) #12
  %186 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %187 = getelementptr inbounds i8, ptr %result.i83.i885, i64 16
  store i32 %78, ptr %187, align 8
  store ptr @Entry, ptr %87, align 8
  %188 = ptrtoint ptr %result.i83.i885 to i64
  store i64 %188, ptr %89, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %87, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

189:                                              ; preds = %._crit_edge.i882, %._crit_edge, %92
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %190 = add i32 %78, 2127912214
  %191 = shl i32 %78, 12
  %192 = add i32 %190, %191
  %193 = ashr i32 %192, 19
  %194 = xor i32 %192, %193
  %195 = xor i32 %194, -949894596
  %196 = add i32 %195, 374761393
  %197 = shl i32 %195, 5
  %198 = add i32 %196, %197
  %199 = add i32 %198, -744332180
  %200 = shl i32 %198, 9
  %201 = xor i32 %199, %200
  %202 = add i32 %201, -42973499
  %203 = shl i32 %201, 3
  %204 = add i32 %202, %203
  %205 = ashr i32 %204, 16
  %206 = xor i32 %204, %205
  %207 = xor i32 %206, -1252372727
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %209 = load i32, ptr %48, align 8
  %210 = add i32 %209, -1
  %211 = and i32 %210, %207
  %212 = load ptr, ptr %50, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %213 = sext i32 %211 to i64
  %214 = shl nsw i64 %213, 5
  %215 = getelementptr i8, ptr %212, i64 %214
  %216 = load ptr, ptr %215, align 8
  %217 = getelementptr i8, ptr %215, i64 8
  %218 = icmp ne ptr %216, @nil_typ
  %219 = icmp ne ptr %216, null
  %.not64.i914 = and i1 %218, %219
  br i1 %.not64.i914, label %220, label %317

220:                                              ; preds = %189
  %221 = load i64, ptr %217, align 4
  %.sroa_idx.i916 = getelementptr i8, ptr %215, i64 16
  %222 = load i64, ptr %.sroa_idx.i916, align 4
  %223 = inttoptr i64 %221 to ptr
  %224 = inttoptr i64 %222 to ptr
  %hash_coef_ptr.i.i66.i917 = getelementptr i8, ptr %216, i64 8
  %tbl_size_ptr.i.i67.i918 = getelementptr i8, ptr %216, i64 16
  %offset_tbl_ptr.i.i68.i919 = getelementptr i8, ptr %216, i64 40
  %hash_coef.i.i69.i920 = load i64, ptr %hash_coef_ptr.i.i66.i917, align 4, !noalias !56
  %tbl_size.i.i70.i921 = load i64, ptr %tbl_size_ptr.i.i67.i918, align 4, !noalias !56
  %offset_tbl.i.i71.i922 = load ptr, ptr %offset_tbl_ptr.i.i68.i919, align 8, !noalias !56
  %product.i.i.i72.i923 = mul i64 %hash_coef.i.i69.i920, 4015701072841558310
  %shifted.i.i.i73.i924 = lshr i64 %product.i.i.i72.i923, 32
  %xored.i.i.i74.i925 = xor i64 %shifted.i.i.i73.i924, %product.i.i.i72.i923
  %hash.i.i.i75.i926 = and i64 %xored.i.i.i74.i925, %tbl_size.i.i70.i921
  %offset_ptr.i.i76.i927 = getelementptr i32, ptr %offset_tbl.i.i71.i922, i64 %hash.i.i.i75.i926
  %offset.i.i77.i928 = load i32, ptr %offset_ptr.i.i76.i927, align 4, !noalias !56
  %225 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %216, 0
  %226 = insertvalue { ptr, ptr, ptr, i32 } %225, ptr %223, 1
  %227 = insertvalue { ptr, ptr, ptr, i32 } %226, ptr %224, 2
  %228 = insertvalue { ptr, ptr, ptr, i32 } %227, i32 %offset.i.i77.i928, 3
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %216) #34
  %231 = sext i32 %offset.i.i77.i928 to i64
  %232 = getelementptr ptr, ptr %216, i64 %231
  %233 = getelementptr i8, ptr %232, i64 64
  %234 = load ptr, ptr %233, align 8
  %result.i.i929 = call ptr %234({ ptr, ptr, ptr, i32 } %228, ptr nocapture nofree noundef nonnull readonly %2) #15
  %235 = call i32 %result.i.i929({ ptr, ptr, ptr, i32 } %228, { ptr, ptr, ptr, i32 } %228, ptr nonnull align 8 %2) #7
  %236 = icmp eq i32 %235, %78
  br i1 %236, label %._crit_edge.i930, label %317

._crit_edge.i930:                                 ; preds = %220
  %237 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %238 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %216)
  %239 = getelementptr i8, ptr %232, i64 48
  %240 = load ptr, ptr %239, align 8
  %result.i79.i931 = call ptr %240({ ptr, ptr, ptr, i32 } %228, ptr nocapture nofree noundef nonnull readonly %2) #15
  %241 = call { ptr, i160 } %result.i79.i931({ ptr, ptr, ptr, i32 } %228, { ptr, ptr, ptr, i32 } %228, ptr nonnull align 8 %2) #7
  %242 = load ptr, ptr %47, align 8
  %243 = call i1 %242({ ptr, i160 } %241, { ptr, i160 } %70) #7
  br i1 %243, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit943, label %317

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit943: ; preds = %._crit_edge.i930
  %244 = load ptr, ptr %result.i311, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %246 = load ptr, ptr %41, align 8
  %247 = load ptr, ptr %244, align 8, !alias.scope !59
  %248 = getelementptr i8, ptr %247, i64 72
  %249 = load ptr, ptr %248, align 8, !alias.scope !59
  %result.i.i.i935 = call { i64, i64 } %249(ptr nocapture nofree nonnull readonly %244) #5, !alias.scope !59
  %250 = extractvalue { i64, i64 } %result.i.i.i935, 0
  %251 = extractvalue { i64, i64 } %result.i.i.i935, 1
  %252 = urem i64 20, %251
  %253 = icmp eq i64 %252, 0
  %254 = sub i64 %251, %252
  %255 = select i1 %253, i64 0, i64 %254
  %256 = add i64 %250, 20
  %257 = add i64 %256, %255
  %258 = load ptr, ptr %246, align 8, !alias.scope !59
  %259 = getelementptr i8, ptr %258, i64 72
  %260 = load ptr, ptr %259, align 8, !alias.scope !59
  %result.i1.i.i936 = call { i64, i64 } %260(ptr nocapture nofree nonnull readonly %246) #5, !alias.scope !59
  %261 = extractvalue { i64, i64 } %result.i1.i.i936, 0
  %262 = extractvalue { i64, i64 } %result.i1.i.i936, 1
  %263 = call i64 @llvm.umax.i64(i64 %251, i64 %262)
  %264 = call i64 @llvm.umax.i64(i64 %263, i64 8)
  %265 = urem i64 %257, %262
  %266 = icmp eq i64 %265, 0
  %267 = sub i64 %262, %265
  %268 = select i1 %266, i64 0, i64 %267
  %269 = add i64 %261, %257
  %270 = add i64 %269, %268
  %271 = urem i64 %270, %264
  %272 = icmp eq i64 %271, 0
  %273 = sub i64 %264, %271
  %274 = select i1 %272, i64 0, i64 %273
  %275 = add i64 %274, %270
  %result.i83.i937 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %275, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %244, ptr %result.i83.i937, align 8
  %276 = getelementptr inbounds i8, ptr %result.i83.i937, i64 8
  store ptr %246, ptr %276, align 8
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i937)
  %278 = load ptr, ptr %244, align 8
  %279 = getelementptr i8, ptr %278, i64 72
  %280 = load ptr, ptr %279, align 8
  %result.i.i114.i938 = call { i64, i64 } %280(ptr nocapture nofree nonnull readonly %244) #5
  %281 = extractvalue { i64, i64 } %result.i.i114.i938, 1
  %282 = urem i64 20, %281
  %283 = icmp eq i64 %282, 0
  %reass.sub3113 = sub i64 %281, %282
  %284 = add i64 %reass.sub3113, 20
  %285 = select i1 %283, i64 20, i64 %284
  %286 = getelementptr i8, ptr %result.i83.i937, i64 %285
  %287 = getelementptr i8, ptr %278, i64 64
  %288 = load ptr, ptr %287, align 8
  call void %288({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %244, ptr nocapture nofree writeonly %286) #12
  %289 = load ptr, ptr %result.i83.i937, align 8
  %290 = load ptr, ptr %289, align 8
  %291 = getelementptr i8, ptr %290, i64 72
  %292 = load ptr, ptr %291, align 8
  %result.i.i115.i940 = call { i64, i64 } %292(ptr nocapture nofree nonnull readonly %289) #5
  %293 = extractvalue { i64, i64 } %result.i.i115.i940, 0
  %294 = extractvalue { i64, i64 } %result.i.i115.i940, 1
  %295 = urem i64 20, %294
  %296 = icmp eq i64 %295, 0
  %297 = sub i64 %294, %295
  %298 = select i1 %296, i64 0, i64 %297
  %299 = add i64 %293, 20
  %300 = add i64 %299, %298
  %301 = load ptr, ptr %276, align 8
  %302 = load ptr, ptr %301, align 8
  %303 = getelementptr i8, ptr %302, i64 72
  %304 = load ptr, ptr %303, align 8
  %result.i1.i116.i941 = call { i64, i64 } %304(ptr nocapture nofree nonnull readonly %301) #5
  %305 = extractvalue { i64, i64 } %result.i1.i116.i941, 1
  %306 = urem i64 %300, %305
  %307 = icmp eq i64 %306, 0
  %308 = sub i64 %305, %306
  %309 = select i1 %307, i64 0, i64 %308
  %310 = getelementptr i8, ptr %result.i83.i937, i64 %300
  %311 = getelementptr i8, ptr %310, i64 %309
  %312 = getelementptr i8, ptr %302, i64 64
  %313 = load ptr, ptr %312, align 8
  call void %313({ ptr, i160 } %75, ptr nocapture nofree nonnull readonly %301, ptr nocapture nofree writeonly %311) #12
  %314 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %315 = getelementptr inbounds i8, ptr %result.i83.i937, i64 16
  store i32 %78, ptr %315, align 8
  store ptr @Entry, ptr %215, align 8
  %316 = ptrtoint ptr %result.i83.i937 to i64
  store i64 %316, ptr %217, align 4
  %.sroa_idx28.i942 = getelementptr i8, ptr %215, i64 24
  store i32 10, ptr %.sroa_idx28.i942, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

317:                                              ; preds = %._crit_edge.i930, %189, %220
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %318 = load i32, ptr %62, align 4
  %319 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %320 = load i32, ptr %48, align 8
  %.not.i = icmp slt i32 %318, %320
  br i1 %.not.i, label %._crit_edge.i, label %321

321:                                              ; preds = %317
  %322 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %323 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %324 = load ptr, ptr %49, align 8
  %325 = load ptr, ptr %50, align 8
  %326 = shl i32 %320, 1
  %spec.select.i958 = call i32 @llvm.smax.i32(i32 %326, i32 16)
  store i32 %spec.select.i958, ptr %48, align 8
  %327 = zext nneg i32 %spec.select.i958 to i64
  %328 = shl nuw nsw i64 %327, 5
  %result.i.i959 = call noalias ptr @bump_malloc_inner(i64 noundef %328, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i959, ptr %49, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %328, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i, ptr %50, align 8
  store i32 0, ptr %62, align 4
  %329 = icmp sgt i32 %320, 0
  br i1 %329, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread: ; preds = %321
  %330 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i

.lr.ph.i:                                         ; preds = %321, %._crit_edge.i1705
  %.060.i = phi i32 [ %349, %._crit_edge.i1705 ], [ 0, %321 ]
  %331 = zext nneg i32 %.060.i to i64
  %332 = shl nuw nsw i64 %331, 5
  %333 = getelementptr i8, ptr %324, i64 %332
  %334 = load ptr, ptr %333, align 8
  %335 = icmp ne ptr %334, @nil_typ
  %336 = icmp ne ptr %334, null
  %.not16.i = and i1 %335, %336
  br i1 %.not16.i, label %337, label %._crit_edge.i1705

337:                                              ; preds = %.lr.ph.i
  %338 = getelementptr i8, ptr %333, i64 8
  %339 = load i64, ptr %338, align 4
  %.sroa_idx.i1706 = getelementptr i8, ptr %333, i64 16
  %340 = load i64, ptr %.sroa_idx.i1706, align 4
  %341 = inttoptr i64 %339 to ptr
  %342 = inttoptr i64 %340 to ptr
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %334, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %334, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %334, i64 40
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i43.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !62
  %343 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %334, 0
  %344 = insertvalue { ptr, ptr, ptr, i32 } %343, ptr %341, 1
  %345 = insertvalue { ptr, ptr, ptr, i32 } %344, ptr %342, 2
  %346 = insertvalue { ptr, ptr, ptr, i32 } %345, i32 %offset.i.i43.i, 3
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %348 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %65, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %346) #7
  br label %._crit_edge.i1705

._crit_edge.i1705:                                ; preds = %337, %.lr.ph.i
  %349 = add nuw nsw i32 %.060.i, 1
  %350 = icmp slt i32 %349, %320
  br i1 %350, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i1705
  %351 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %352

352:                                              ; preds = %._crit_edge.i1724, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %.060.i1722 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit ], [ %371, %._crit_edge.i1724 ]
  %353 = zext nneg i32 %.060.i1722 to i64
  %354 = shl nuw nsw i64 %353, 5
  %355 = getelementptr i8, ptr %325, i64 %354
  %356 = load ptr, ptr %355, align 8
  %357 = icmp ne ptr %356, @nil_typ
  %358 = icmp ne ptr %356, null
  %.not16.i1723 = and i1 %357, %358
  br i1 %.not16.i1723, label %359, label %._crit_edge.i1724

359:                                              ; preds = %352
  %360 = getelementptr i8, ptr %355, i64 8
  %361 = load i64, ptr %360, align 4
  %.sroa_idx.i1725 = getelementptr i8, ptr %355, i64 16
  %362 = load i64, ptr %.sroa_idx.i1725, align 4
  %363 = inttoptr i64 %361 to ptr
  %364 = inttoptr i64 %362 to ptr
  %hash_coef_ptr.i.i18.i1726 = getelementptr i8, ptr %356, i64 8
  %tbl_size_ptr.i.i19.i1727 = getelementptr i8, ptr %356, i64 16
  %offset_tbl_ptr.i.i20.i1728 = getelementptr i8, ptr %356, i64 40
  %hash_coef.i.i21.i1729 = load i64, ptr %hash_coef_ptr.i.i18.i1726, align 4, !noalias !22
  %tbl_size.i.i22.i1730 = load i64, ptr %tbl_size_ptr.i.i19.i1727, align 4, !noalias !22
  %offset_tbl.i.i23.i1731 = load ptr, ptr %offset_tbl_ptr.i.i20.i1728, align 8, !noalias !22
  %product.i.i.i24.i1732 = mul i64 %hash_coef.i.i21.i1729, 4015701072841558310
  %shifted.i.i.i25.i1733 = lshr i64 %product.i.i.i24.i1732, 32
  %xored.i.i.i26.i1734 = xor i64 %shifted.i.i.i25.i1733, %product.i.i.i24.i1732
  %hash.i.i.i27.i1735 = and i64 %xored.i.i.i26.i1734, %tbl_size.i.i22.i1730
  %offset_ptr.i.i28.i1736 = getelementptr i32, ptr %offset_tbl.i.i23.i1731, i64 %hash.i.i.i27.i1735
  %offset.i.i43.i1737 = load i32, ptr %offset_ptr.i.i28.i1736, align 4, !noalias !65
  %365 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %356, 0
  %366 = insertvalue { ptr, ptr, ptr, i32 } %365, ptr %363, 1
  %367 = insertvalue { ptr, ptr, ptr, i32 } %366, ptr %364, 2
  %368 = insertvalue { ptr, ptr, ptr, i32 } %367, i32 %offset.i.i43.i1737, 3
  %369 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %370 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %65, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %368) #7
  br label %._crit_edge.i1724

._crit_edge.i1724:                                ; preds = %359, %352
  %371 = add nuw nsw i32 %.060.i1722, 1
  %372 = icmp slt i32 %371, %320
  br i1 %372, label %352, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i1724, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread, %317
  %373 = load ptr, ptr %76, align 8
  %374 = getelementptr i8, ptr %373, i64 72
  %375 = load ptr, ptr %374, align 8
  %result.i.i.i = call { i64, i64 } %375(ptr nocapture nofree nonnull readonly %76) #5
  %376 = extractvalue { i64, i64 } %result.i.i.i, 0
  %377 = extractvalue { i64, i64 } %result.i.i.i, 1
  %378 = urem i64 20, %377
  %379 = icmp eq i64 %378, 0
  %380 = sub i64 %377, %378
  %381 = select i1 %379, i64 0, i64 %380
  %382 = add i64 %376, 20
  %383 = add i64 %382, %381
  %384 = load ptr, ptr %84, align 8
  %385 = getelementptr i8, ptr %384, i64 72
  %386 = load ptr, ptr %385, align 8
  %result.i1.i.i = call { i64, i64 } %386(ptr nocapture nofree nonnull readonly %84) #5
  %387 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %388 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %389 = call i64 @llvm.umax.i64(i64 %377, i64 %388)
  %390 = call i64 @llvm.umax.i64(i64 %389, i64 8)
  %391 = urem i64 %383, %388
  %392 = icmp eq i64 %391, 0
  %393 = sub i64 %388, %391
  %394 = select i1 %392, i64 0, i64 %393
  %395 = add i64 %387, %383
  %396 = add i64 %395, %394
  %397 = urem i64 %396, %390
  %398 = icmp eq i64 %397, 0
  %399 = sub i64 %390, %397
  %400 = select i1 %398, i64 0, i64 %399
  %401 = add i64 %400, %396
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %401, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %76, ptr %result.i83.i, align 8
  %402 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %84, ptr %402, align 8
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %404 = load ptr, ptr %76, align 8
  %405 = getelementptr i8, ptr %404, i64 72
  %406 = load ptr, ptr %405, align 8
  %result.i.i179.i = call { i64, i64 } %406(ptr nocapture nofree nonnull readonly %76) #5
  %407 = extractvalue { i64, i64 } %result.i.i179.i, 1
  %408 = urem i64 20, %407
  %409 = icmp eq i64 %408, 0
  %reass.sub3112 = sub i64 %407, %408
  %410 = add i64 %reass.sub3112, 20
  %411 = select i1 %409, i64 20, i64 %410
  %412 = getelementptr i8, ptr %result.i83.i, i64 %411
  %413 = getelementptr i8, ptr %404, i64 64
  %414 = load ptr, ptr %413, align 8
  call void %414({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %76, ptr nocapture nofree writeonly %412) #12
  %415 = load ptr, ptr %result.i83.i, align 8
  %416 = load ptr, ptr %415, align 8
  %417 = getelementptr i8, ptr %416, i64 72
  %418 = load ptr, ptr %417, align 8
  %result.i.i180.i = call { i64, i64 } %418(ptr nocapture nofree nonnull readonly %415) #5
  %419 = extractvalue { i64, i64 } %result.i.i180.i, 0
  %420 = extractvalue { i64, i64 } %result.i.i180.i, 1
  %421 = urem i64 20, %420
  %422 = icmp eq i64 %421, 0
  %423 = sub i64 %420, %421
  %424 = select i1 %422, i64 0, i64 %423
  %425 = add i64 %419, 20
  %426 = add i64 %425, %424
  %427 = load ptr, ptr %402, align 8
  %428 = load ptr, ptr %427, align 8
  %429 = getelementptr i8, ptr %428, i64 72
  %430 = load ptr, ptr %429, align 8
  %result.i1.i181.i = call { i64, i64 } %430(ptr nocapture nofree nonnull readonly %427) #5
  %431 = extractvalue { i64, i64 } %result.i1.i181.i, 1
  %432 = urem i64 %426, %431
  %433 = icmp eq i64 %432, 0
  %434 = sub i64 %431, %432
  %435 = select i1 %433, i64 0, i64 %434
  %436 = getelementptr i8, ptr %result.i83.i, i64 %426
  %437 = getelementptr i8, ptr %436, i64 %435
  %438 = getelementptr i8, ptr %428, i64 64
  %439 = load ptr, ptr %438, align 8
  call void %439({ ptr, i160 } %75, ptr nocapture nofree nonnull readonly %427, ptr nocapture nofree writeonly %437) #12
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %441 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %78, ptr %441, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %26)
  %442 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %443 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %444 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %445

445:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %446, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %512, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i83.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i975, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %446 = add nuw nsw i32 %.0566.i, 1
  %447 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %448 = insertvalue { ptr, ptr, ptr, i32 } %447, ptr %.sroa.6.0563.i, 1
  %449 = insertvalue { ptr, ptr, ptr, i32 } %448, ptr %.sroa.12.0562.i, 2
  %450 = insertvalue { ptr, ptr, ptr, i32 } %449, i32 %.sroa.17.0561.i, 3
  %451 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %452 = sext i32 %.sroa.17.0561.i to i64
  %453 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %452
  %454 = getelementptr i8, ptr %453, i64 64
  %455 = load ptr, ptr %454, align 8
  %result.i125.i = call ptr %455({ ptr, ptr, ptr, i32 } %450, ptr nocapture nofree noundef nonnull readonly %2) #15
  %456 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %450, { ptr, ptr, ptr, i32 } %450, ptr nonnull align 8 %2) #7
  %457 = ptrtoint ptr %.sroa.6.0563.i to i64
  %458 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %459, label %475

459:                                              ; preds = %445
  %460 = load i32, ptr %48, align 8
  %461 = add i32 %460, -1
  %462 = and i32 %461, %456
  %463 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %464 = load ptr, ptr %49, align 8
  %465 = sext i32 %462 to i64
  %466 = shl nsw i64 %465, 5
  %467 = getelementptr i8, ptr %464, i64 %466
  %468 = load ptr, ptr %467, align 8
  %469 = getelementptr i8, ptr %467, i64 8
  %470 = load i160, ptr %469, align 4
  store ptr %.sroa.0.0564.i, ptr %467, align 8
  store i64 %457, ptr %469, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %467, i64 16
  store i64 %458, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %467, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %471 = icmp ne ptr %468, @nil_typ
  %472 = icmp ne ptr %468, null
  %.not92.i = and i1 %471, %472
  %extract.i = lshr i160 %470, 64
  %473 = insertelement <2 x i160> poison, i160 %470, i64 0
  %474 = insertelement <2 x i160> %473, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

475:                                              ; preds = %445
  %476 = add i32 %456, 2127912214
  %477 = shl i32 %456, 12
  %478 = add i32 %476, %477
  %479 = ashr i32 %478, 19
  %480 = xor i32 %478, %479
  %481 = xor i32 %480, -949894596
  %482 = add i32 %481, 374761393
  %483 = shl i32 %481, 5
  %484 = add i32 %482, %483
  %485 = add i32 %484, -744332180
  %486 = shl i32 %484, 9
  %487 = xor i32 %485, %486
  %488 = add i32 %487, -42973499
  %489 = shl i32 %487, 3
  %490 = add i32 %488, %489
  %491 = ashr i32 %490, 16
  %492 = xor i32 %490, %491
  %493 = xor i32 %492, -1252372727
  %494 = load i32, ptr %48, align 8
  %495 = add i32 %494, -1
  %496 = and i32 %495, %493
  %497 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %498 = load ptr, ptr %50, align 8
  %499 = sext i32 %496 to i64
  %500 = shl nsw i64 %499, 5
  %501 = getelementptr i8, ptr %498, i64 %500
  %502 = load ptr, ptr %501, align 8
  %503 = getelementptr i8, ptr %501, i64 8
  %504 = load i160, ptr %503, align 4
  store ptr %.sroa.0.0564.i, ptr %501, align 8
  store i64 %457, ptr %503, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %501, i64 16
  store i64 %458, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %501, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %505 = icmp ne ptr %502, @nil_typ
  %506 = icmp ne ptr %502, null
  %.not90.i = and i1 %505, %506
  %extract607.i = lshr i160 %504, 64
  %507 = insertelement <2 x i160> poison, i160 %504, i64 0
  %508 = insertelement <2 x i160> %507, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %475, %459
  %vptr.i142.sroa.speculated.i = phi ptr [ %468, %459 ], [ %502, %475 ]
  %.in = phi <2 x i160> [ %474, %459 ], [ %508, %475 ]
  %509 = trunc <2 x i160> %.in to <2 x i64>
  %510 = extractelement <2 x i64> %509, i64 1
  %spec.select.i975 = inttoptr i64 %510 to ptr
  %511 = extractelement <2 x i64> %509, i64 0
  %spec.select539.i = inttoptr i64 %511 to ptr
  %512 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %513 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %515 = icmp ult i32 %.0566.i, 99
  br i1 %515, label %445, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %459, %475
  %516 = phi ptr [ %26, %475 ], [ %25, %459 ]
  %517 = load i32, ptr %62, align 4
  store i32 %517, ptr %516, align 4
  %518 = add i32 %517, 1
  %519 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %518, ptr %62, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  %520 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %520, label %HashMap_insert_keyK_valueV.exit, label %521

521:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %522 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %523 = load ptr, ptr %49, align 8
  %524 = load ptr, ptr %50, align 8
  %525 = load i32, ptr %48, align 8
  %526 = shl i32 %525, 1
  %spec.select.i992 = call i32 @llvm.smax.i32(i32 %526, i32 16)
  store i32 %spec.select.i992, ptr %48, align 8
  %527 = zext nneg i32 %spec.select.i992 to i64
  %528 = shl nuw nsw i64 %527, 5
  %result.i.i993 = call noalias ptr @bump_malloc_inner(i64 noundef %528, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i993, ptr %49, align 8
  %result.i20.i994 = call noalias ptr @bump_malloc_inner(i64 noundef %528, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i994, ptr %50, align 8
  store i32 0, ptr %62, align 4
  %529 = icmp sgt i32 %525, 0
  br i1 %529, label %.lr.ph.i1771, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840

.lr.ph.i1771:                                     ; preds = %521, %._crit_edge.i1786
  %.060.i1784 = phi i32 [ %618, %._crit_edge.i1786 ], [ 0, %521 ]
  %530 = zext nneg i32 %.060.i1784 to i64
  %531 = shl nuw nsw i64 %530, 5
  %532 = getelementptr i8, ptr %523, i64 %531
  %533 = load ptr, ptr %532, align 8
  %534 = icmp ne ptr %533, @nil_typ
  %535 = icmp ne ptr %533, null
  %.not16.i1785 = and i1 %534, %535
  br i1 %.not16.i1785, label %536, label %._crit_edge.i1786

536:                                              ; preds = %.lr.ph.i1771
  %537 = getelementptr i8, ptr %532, i64 8
  %538 = load <2 x i64>, ptr %537, align 4
  %hash_coef_ptr.i.i18.i1788 = getelementptr i8, ptr %533, i64 8
  %tbl_size_ptr.i.i19.i1789 = getelementptr i8, ptr %533, i64 16
  %offset_tbl_ptr.i.i20.i1790 = getelementptr i8, ptr %533, i64 40
  %539 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i1788, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i1789, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i1790, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !68
  %540 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %541 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %542 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %543

543:                                              ; preds = %.cont.cont.i2247, %536
  %.0566.i2234 = phi i32 [ 0, %536 ], [ %547, %.cont.cont.i2247 ]
  %.070565.i2235 = phi i1 [ true, %536 ], [ %609, %.cont.cont.i2247 ]
  %.sroa.0.0564.i2236 = phi ptr [ %533, %536 ], [ %vptr.i142.sroa.speculated.i2250, %.cont.cont.i2247 ]
  %.sroa.17.0561.i2239 = phi i32 [ %offset.i.i121.i, %536 ], [ %offset.i.i154.i2264, %.cont.cont.i2247 ]
  %544 = phi <2 x i64> [ %538, %536 ], [ %608, %.cont.cont.i2247 ]
  %545 = extractelement <2 x i64> %544, i64 1
  %.sroa.12.0562.i2238 = inttoptr i64 %545 to ptr
  %546 = extractelement <2 x i64> %544, i64 0
  %.sroa.6.0563.i2237 = inttoptr i64 %546 to ptr
  %547 = add nuw nsw i32 %.0566.i2234, 1
  %548 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2236, 0
  %549 = insertvalue { ptr, ptr, ptr, i32 } %548, ptr %.sroa.6.0563.i2237, 1
  %550 = insertvalue { ptr, ptr, ptr, i32 } %549, ptr %.sroa.12.0562.i2238, 2
  %551 = insertvalue { ptr, ptr, ptr, i32 } %550, i32 %.sroa.17.0561.i2239, 3
  %552 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2236)
  %553 = sext i32 %.sroa.17.0561.i2239 to i64
  %554 = getelementptr ptr, ptr %.sroa.0.0564.i2236, i64 %553
  %555 = getelementptr i8, ptr %554, i64 64
  %556 = load ptr, ptr %555, align 8
  %result.i125.i2240 = call ptr %556({ ptr, ptr, ptr, i32 } %551, ptr nocapture nofree noundef nonnull readonly %2) #15
  %557 = call i32 %result.i125.i2240({ ptr, ptr, ptr, i32 } %551, { ptr, ptr, ptr, i32 } %551, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2235, label %558, label %574

558:                                              ; preds = %543
  %559 = load i32, ptr %48, align 8
  %560 = add i32 %559, -1
  %561 = and i32 %560, %557
  %562 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %563 = load ptr, ptr %49, align 8
  %564 = sext i32 %561 to i64
  %565 = shl nsw i64 %564, 5
  %566 = getelementptr i8, ptr %563, i64 %565
  %567 = load ptr, ptr %566, align 8
  %568 = getelementptr i8, ptr %566, i64 8
  %569 = load i160, ptr %568, align 4
  store ptr %.sroa.0.0564.i2236, ptr %566, align 8
  store i64 %546, ptr %568, align 4
  %.sroa_idx157.i2266 = getelementptr i8, ptr %566, i64 16
  store i64 %545, ptr %.sroa_idx157.i2266, align 4
  %.sroa_idx158.i2267 = getelementptr i8, ptr %566, i64 24
  store i32 %.sroa.17.0561.i2239, ptr %.sroa_idx158.i2267, align 4
  %570 = icmp ne ptr %567, @nil_typ
  %571 = icmp ne ptr %567, null
  %.not92.i2268 = and i1 %570, %571
  %extract.i2270 = lshr i160 %569, 64
  %572 = insertelement <2 x i160> poison, i160 %569, i64 0
  %573 = insertelement <2 x i160> %572, i160 %extract.i2270, i64 1
  br i1 %.not92.i2268, label %.cont.cont.i2247, label %613

574:                                              ; preds = %543
  %575 = add i32 %557, 2127912214
  %576 = shl i32 %557, 12
  %577 = add i32 %575, %576
  %578 = ashr i32 %577, 19
  %579 = xor i32 %577, %578
  %580 = xor i32 %579, -949894596
  %581 = add i32 %580, 374761393
  %582 = shl i32 %580, 5
  %583 = add i32 %581, %582
  %584 = add i32 %583, -744332180
  %585 = shl i32 %583, 9
  %586 = xor i32 %584, %585
  %587 = add i32 %586, -42973499
  %588 = shl i32 %586, 3
  %589 = add i32 %587, %588
  %590 = ashr i32 %589, 16
  %591 = xor i32 %589, %590
  %592 = xor i32 %591, -1252372727
  %593 = load i32, ptr %48, align 8
  %594 = add i32 %593, -1
  %595 = and i32 %594, %592
  %596 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %597 = load ptr, ptr %50, align 8
  %598 = sext i32 %595 to i64
  %599 = shl nsw i64 %598, 5
  %600 = getelementptr i8, ptr %597, i64 %599
  %601 = load ptr, ptr %600, align 8
  %602 = getelementptr i8, ptr %600, i64 8
  %603 = load i160, ptr %602, align 4
  store ptr %.sroa.0.0564.i2236, ptr %600, align 8
  store i64 %546, ptr %602, align 4
  %.sroa_idx161.i2241 = getelementptr i8, ptr %600, i64 16
  store i64 %545, ptr %.sroa_idx161.i2241, align 4
  %.sroa_idx162.i2242 = getelementptr i8, ptr %600, i64 24
  store i32 %.sroa.17.0561.i2239, ptr %.sroa_idx162.i2242, align 4
  %604 = icmp ne ptr %601, @nil_typ
  %605 = icmp ne ptr %601, null
  %.not90.i2243 = and i1 %604, %605
  %extract607.i2245 = lshr i160 %603, 64
  %606 = insertelement <2 x i160> poison, i160 %603, i64 0
  %607 = insertelement <2 x i160> %606, i160 %extract607.i2245, i64 1
  br i1 %.not90.i2243, label %.cont.cont.i2247, label %613

.cont.cont.i2247:                                 ; preds = %574, %558
  %vptr.i142.sroa.speculated.i2250 = phi ptr [ %567, %558 ], [ %601, %574 ]
  %.in3117 = phi <2 x i160> [ %573, %558 ], [ %607, %574 ]
  %608 = trunc <2 x i160> %.in3117 to <2 x i64>
  %609 = xor i1 %.070565.i2235, true
  %hash_coef_ptr.i.i143.i2253 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2250, i64 8
  %tbl_size_ptr.i.i144.i2254 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2250, i64 16
  %offset_tbl_ptr.i.i145.i2255 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2250, i64 40
  %hash_coef.i.i146.i2256 = load i64, ptr %hash_coef_ptr.i.i143.i2253, align 4
  %tbl_size.i.i147.i2257 = load i64, ptr %tbl_size_ptr.i.i144.i2254, align 4
  %offset_tbl.i.i148.i2258 = load ptr, ptr %offset_tbl_ptr.i.i145.i2255, align 8
  %product.i.i.i149.i2259 = mul i64 %hash_coef.i.i146.i2256, 4015701072841558310
  %shifted.i.i.i150.i2260 = lshr i64 %product.i.i.i149.i2259, 32
  %xored.i.i.i151.i2261 = xor i64 %shifted.i.i.i150.i2260, %product.i.i.i149.i2259
  %hash.i.i.i152.i2262 = and i64 %xored.i.i.i151.i2261, %tbl_size.i.i147.i2257
  %offset_ptr.i.i153.i2263 = getelementptr i32, ptr %offset_tbl.i.i148.i2258, i64 %hash.i.i.i152.i2262
  %offset.i.i154.i2264 = load i32, ptr %offset_ptr.i.i153.i2263, align 4
  %610 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %612 = icmp ult i32 %.0566.i2234, 99
  br i1 %612, label %543, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2272

613:                                              ; preds = %574, %558
  %614 = phi ptr [ %18, %574 ], [ %17, %558 ]
  %615 = load i32, ptr %62, align 4
  store i32 %615, ptr %614, align 4
  %616 = add i32 %615, 1
  %617 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %616, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2272

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2272: ; preds = %.cont.cont.i2247, %613
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i1786

._crit_edge.i1786:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2272, %.lr.ph.i1771
  %618 = add nuw nsw i32 %.060.i1784, 1
  %619 = icmp slt i32 %618, %525
  br i1 %619, label %.lr.ph.i1771, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1804

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1804: ; preds = %._crit_edge.i1786, %._crit_edge.i1822
  %.060.i1820 = phi i32 [ %708, %._crit_edge.i1822 ], [ 0, %._crit_edge.i1786 ]
  %620 = zext nneg i32 %.060.i1820 to i64
  %621 = shl nuw nsw i64 %620, 5
  %622 = getelementptr i8, ptr %524, i64 %621
  %623 = load ptr, ptr %622, align 8
  %624 = icmp ne ptr %623, @nil_typ
  %625 = icmp ne ptr %623, null
  %.not16.i1821 = and i1 %624, %625
  br i1 %.not16.i1821, label %626, label %._crit_edge.i1822

626:                                              ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1804
  %627 = getelementptr i8, ptr %622, i64 8
  %628 = load <2 x i64>, ptr %627, align 4
  %hash_coef_ptr.i.i18.i1824 = getelementptr i8, ptr %623, i64 8
  %tbl_size_ptr.i.i19.i1825 = getelementptr i8, ptr %623, i64 16
  %offset_tbl_ptr.i.i20.i1826 = getelementptr i8, ptr %623, i64 40
  %629 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i2290 = load i64, ptr %hash_coef_ptr.i.i18.i1824, align 4, !noalias !22
  %tbl_size.i.i100.i2291 = load i64, ptr %tbl_size_ptr.i.i19.i1825, align 4, !noalias !22
  %offset_tbl.i.i101.i2292 = load ptr, ptr %offset_tbl_ptr.i.i20.i1826, align 8, !noalias !22
  %product.i.i.i102.i2293 = mul i64 %hash_coef.i.i99.i2290, 4015701072841558310
  %shifted.i.i.i103.i2294 = lshr i64 %product.i.i.i102.i2293, 32
  %xored.i.i.i104.i2295 = xor i64 %shifted.i.i.i103.i2294, %product.i.i.i102.i2293
  %hash.i.i.i105.i2296 = and i64 %xored.i.i.i104.i2295, %tbl_size.i.i100.i2291
  %offset_ptr.i.i106.i2297 = getelementptr i32, ptr %offset_tbl.i.i101.i2292, i64 %hash.i.i.i105.i2296
  %offset.i.i121.i2298 = load i32, ptr %offset_ptr.i.i106.i2297, align 4, !noalias !71
  %630 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %631 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %632 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %633

633:                                              ; preds = %.cont.cont.i2319, %626
  %.0566.i2299 = phi i32 [ 0, %626 ], [ %637, %.cont.cont.i2319 ]
  %.070565.i2300 = phi i1 [ true, %626 ], [ %699, %.cont.cont.i2319 ]
  %.sroa.0.0564.i2301 = phi ptr [ %623, %626 ], [ %vptr.i142.sroa.speculated.i2322, %.cont.cont.i2319 ]
  %.sroa.17.0561.i2304 = phi i32 [ %offset.i.i121.i2298, %626 ], [ %offset.i.i154.i2336, %.cont.cont.i2319 ]
  %634 = phi <2 x i64> [ %628, %626 ], [ %698, %.cont.cont.i2319 ]
  %635 = extractelement <2 x i64> %634, i64 1
  %.sroa.12.0562.i2303 = inttoptr i64 %635 to ptr
  %636 = extractelement <2 x i64> %634, i64 0
  %.sroa.6.0563.i2302 = inttoptr i64 %636 to ptr
  %637 = add nuw nsw i32 %.0566.i2299, 1
  %638 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2301, 0
  %639 = insertvalue { ptr, ptr, ptr, i32 } %638, ptr %.sroa.6.0563.i2302, 1
  %640 = insertvalue { ptr, ptr, ptr, i32 } %639, ptr %.sroa.12.0562.i2303, 2
  %641 = insertvalue { ptr, ptr, ptr, i32 } %640, i32 %.sroa.17.0561.i2304, 3
  %642 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2301)
  %643 = sext i32 %.sroa.17.0561.i2304 to i64
  %644 = getelementptr ptr, ptr %.sroa.0.0564.i2301, i64 %643
  %645 = getelementptr i8, ptr %644, i64 64
  %646 = load ptr, ptr %645, align 8
  %result.i125.i2305 = call ptr %646({ ptr, ptr, ptr, i32 } %641, ptr nocapture nofree noundef nonnull readonly %2) #15
  %647 = call i32 %result.i125.i2305({ ptr, ptr, ptr, i32 } %641, { ptr, ptr, ptr, i32 } %641, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2300, label %648, label %664

648:                                              ; preds = %633
  %649 = load i32, ptr %48, align 8
  %650 = add i32 %649, -1
  %651 = and i32 %650, %647
  %652 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %653 = load ptr, ptr %49, align 8
  %654 = sext i32 %651 to i64
  %655 = shl nsw i64 %654, 5
  %656 = getelementptr i8, ptr %653, i64 %655
  %657 = load ptr, ptr %656, align 8
  %658 = getelementptr i8, ptr %656, i64 8
  %659 = load i160, ptr %658, align 4
  store ptr %.sroa.0.0564.i2301, ptr %656, align 8
  store i64 %636, ptr %658, align 4
  %.sroa_idx157.i2348 = getelementptr i8, ptr %656, i64 16
  store i64 %635, ptr %.sroa_idx157.i2348, align 4
  %.sroa_idx158.i2349 = getelementptr i8, ptr %656, i64 24
  store i32 %.sroa.17.0561.i2304, ptr %.sroa_idx158.i2349, align 4
  %660 = icmp ne ptr %657, @nil_typ
  %661 = icmp ne ptr %657, null
  %.not92.i2350 = and i1 %660, %661
  %extract.i2352 = lshr i160 %659, 64
  %662 = insertelement <2 x i160> poison, i160 %659, i64 0
  %663 = insertelement <2 x i160> %662, i160 %extract.i2352, i64 1
  br i1 %.not92.i2350, label %.cont.cont.i2319, label %703

664:                                              ; preds = %633
  %665 = add i32 %647, 2127912214
  %666 = shl i32 %647, 12
  %667 = add i32 %665, %666
  %668 = ashr i32 %667, 19
  %669 = xor i32 %667, %668
  %670 = xor i32 %669, -949894596
  %671 = add i32 %670, 374761393
  %672 = shl i32 %670, 5
  %673 = add i32 %671, %672
  %674 = add i32 %673, -744332180
  %675 = shl i32 %673, 9
  %676 = xor i32 %674, %675
  %677 = add i32 %676, -42973499
  %678 = shl i32 %676, 3
  %679 = add i32 %677, %678
  %680 = ashr i32 %679, 16
  %681 = xor i32 %679, %680
  %682 = xor i32 %681, -1252372727
  %683 = load i32, ptr %48, align 8
  %684 = add i32 %683, -1
  %685 = and i32 %684, %682
  %686 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %687 = load ptr, ptr %50, align 8
  %688 = sext i32 %685 to i64
  %689 = shl nsw i64 %688, 5
  %690 = getelementptr i8, ptr %687, i64 %689
  %691 = load ptr, ptr %690, align 8
  %692 = getelementptr i8, ptr %690, i64 8
  %693 = load i160, ptr %692, align 4
  store ptr %.sroa.0.0564.i2301, ptr %690, align 8
  store i64 %636, ptr %692, align 4
  %.sroa_idx161.i2309 = getelementptr i8, ptr %690, i64 16
  store i64 %635, ptr %.sroa_idx161.i2309, align 4
  %.sroa_idx162.i2310 = getelementptr i8, ptr %690, i64 24
  store i32 %.sroa.17.0561.i2304, ptr %.sroa_idx162.i2310, align 4
  %694 = icmp ne ptr %691, @nil_typ
  %695 = icmp ne ptr %691, null
  %.not90.i2311 = and i1 %694, %695
  %extract607.i2313 = lshr i160 %693, 64
  %696 = insertelement <2 x i160> poison, i160 %693, i64 0
  %697 = insertelement <2 x i160> %696, i160 %extract607.i2313, i64 1
  br i1 %.not90.i2311, label %.cont.cont.i2319, label %703

.cont.cont.i2319:                                 ; preds = %664, %648
  %vptr.i142.sroa.speculated.i2322 = phi ptr [ %657, %648 ], [ %691, %664 ]
  %.in3118 = phi <2 x i160> [ %663, %648 ], [ %697, %664 ]
  %698 = trunc <2 x i160> %.in3118 to <2 x i64>
  %699 = xor i1 %.070565.i2300, true
  %hash_coef_ptr.i.i143.i2325 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2322, i64 8
  %tbl_size_ptr.i.i144.i2326 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2322, i64 16
  %offset_tbl_ptr.i.i145.i2327 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2322, i64 40
  %hash_coef.i.i146.i2328 = load i64, ptr %hash_coef_ptr.i.i143.i2325, align 4
  %tbl_size.i.i147.i2329 = load i64, ptr %tbl_size_ptr.i.i144.i2326, align 4
  %offset_tbl.i.i148.i2330 = load ptr, ptr %offset_tbl_ptr.i.i145.i2327, align 8
  %product.i.i.i149.i2331 = mul i64 %hash_coef.i.i146.i2328, 4015701072841558310
  %shifted.i.i.i150.i2332 = lshr i64 %product.i.i.i149.i2331, 32
  %xored.i.i.i151.i2333 = xor i64 %shifted.i.i.i150.i2332, %product.i.i.i149.i2331
  %hash.i.i.i152.i2334 = and i64 %xored.i.i.i151.i2333, %tbl_size.i.i147.i2329
  %offset_ptr.i.i153.i2335 = getelementptr i32, ptr %offset_tbl.i.i148.i2330, i64 %hash.i.i.i152.i2334
  %offset.i.i154.i2336 = load i32, ptr %offset_ptr.i.i153.i2335, align 4
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %702 = icmp ult i32 %.0566.i2299, 99
  br i1 %702, label %633, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2354

703:                                              ; preds = %664, %648
  %704 = phi ptr [ %16, %664 ], [ %15, %648 ]
  %705 = load i32, ptr %62, align 4
  store i32 %705, ptr %704, align 4
  %706 = add i32 %705, 1
  %707 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %706, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2354

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2354: ; preds = %.cont.cont.i2319, %703
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i1822

._crit_edge.i1822:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2354, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1804
  %708 = add nuw nsw i32 %.060.i1820, 1
  %709 = icmp slt i32 %708, %525
  br i1 %709, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1804, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840: ; preds = %._crit_edge.i1822, %521
  %710 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %hash_coef.i.i99.i1015 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i1016 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1017 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i1018 = mul i64 %hash_coef.i.i99.i1015, 4015701072841558310
  %shifted.i.i.i103.i1019 = lshr i64 %product.i.i.i102.i1018, 32
  %xored.i.i.i104.i1020 = xor i64 %shifted.i.i.i103.i1019, %product.i.i.i102.i1018
  %hash.i.i.i105.i1021 = and i64 %xored.i.i.i104.i1020, %tbl_size.i.i100.i1016
  %offset_ptr.i.i106.i1022 = getelementptr i32, ptr %offset_tbl.i.i101.i1017, i64 %hash.i.i.i105.i1021
  %offset.i.i121.i1023 = load i32, ptr %offset_ptr.i.i106.i1022, align 4, !noalias !74
  %711 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %712 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %713 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %714

714:                                              ; preds = %.cont.cont.i1045, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840
  %.0566.i1025 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840 ], [ %718, %.cont.cont.i1045 ]
  %.070565.i1026 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840 ], [ %780, %.cont.cont.i1045 ]
  %.sroa.0.0564.i1027 = phi ptr [ %vptr.i142.sroa.speculated.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840 ], [ %vptr.i142.sroa.speculated.i1048, %.cont.cont.i1045 ]
  %.sroa.17.0561.i1030 = phi i32 [ %offset.i.i121.i1023, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840 ], [ %offset.i.i154.i1062, %.cont.cont.i1045 ]
  %715 = phi <2 x i64> [ %509, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1840 ], [ %779, %.cont.cont.i1045 ]
  %716 = extractelement <2 x i64> %715, i64 1
  %.sroa.12.0562.i1029 = inttoptr i64 %716 to ptr
  %717 = extractelement <2 x i64> %715, i64 0
  %.sroa.6.0563.i1028 = inttoptr i64 %717 to ptr
  %718 = add nuw nsw i32 %.0566.i1025, 1
  %719 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1027, 0
  %720 = insertvalue { ptr, ptr, ptr, i32 } %719, ptr %.sroa.6.0563.i1028, 1
  %721 = insertvalue { ptr, ptr, ptr, i32 } %720, ptr %.sroa.12.0562.i1029, 2
  %722 = insertvalue { ptr, ptr, ptr, i32 } %721, i32 %.sroa.17.0561.i1030, 3
  %723 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1027)
  %724 = sext i32 %.sroa.17.0561.i1030 to i64
  %725 = getelementptr ptr, ptr %.sroa.0.0564.i1027, i64 %724
  %726 = getelementptr i8, ptr %725, i64 64
  %727 = load ptr, ptr %726, align 8
  %result.i125.i1031 = call ptr %727({ ptr, ptr, ptr, i32 } %722, ptr nocapture nofree noundef nonnull readonly %2) #15
  %728 = call i32 %result.i125.i1031({ ptr, ptr, ptr, i32 } %722, { ptr, ptr, ptr, i32 } %722, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1026, label %729, label %745

729:                                              ; preds = %714
  %730 = load i32, ptr %48, align 8
  %731 = add i32 %730, -1
  %732 = and i32 %731, %728
  %733 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %734 = load ptr, ptr %49, align 8
  %735 = sext i32 %732 to i64
  %736 = shl nsw i64 %735, 5
  %737 = getelementptr i8, ptr %734, i64 %736
  %738 = load ptr, ptr %737, align 8
  %739 = getelementptr i8, ptr %737, i64 8
  %740 = load i160, ptr %739, align 4
  store ptr %.sroa.0.0564.i1027, ptr %737, align 8
  store i64 %717, ptr %739, align 4
  %.sroa_idx157.i1074 = getelementptr i8, ptr %737, i64 16
  store i64 %716, ptr %.sroa_idx157.i1074, align 4
  %.sroa_idx158.i1075 = getelementptr i8, ptr %737, i64 24
  store i32 %.sroa.17.0561.i1030, ptr %.sroa_idx158.i1075, align 4
  %741 = icmp ne ptr %738, @nil_typ
  %742 = icmp ne ptr %738, null
  %.not92.i1076 = and i1 %741, %742
  %extract.i1078 = lshr i160 %740, 64
  %743 = insertelement <2 x i160> poison, i160 %740, i64 0
  %744 = insertelement <2 x i160> %743, i160 %extract.i1078, i64 1
  br i1 %.not92.i1076, label %.cont.cont.i1045, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1080.thread

745:                                              ; preds = %714
  %746 = add i32 %728, 2127912214
  %747 = shl i32 %728, 12
  %748 = add i32 %746, %747
  %749 = ashr i32 %748, 19
  %750 = xor i32 %748, %749
  %751 = xor i32 %750, -949894596
  %752 = add i32 %751, 374761393
  %753 = shl i32 %751, 5
  %754 = add i32 %752, %753
  %755 = add i32 %754, -744332180
  %756 = shl i32 %754, 9
  %757 = xor i32 %755, %756
  %758 = add i32 %757, -42973499
  %759 = shl i32 %757, 3
  %760 = add i32 %758, %759
  %761 = ashr i32 %760, 16
  %762 = xor i32 %760, %761
  %763 = xor i32 %762, -1252372727
  %764 = load i32, ptr %48, align 8
  %765 = add i32 %764, -1
  %766 = and i32 %765, %763
  %767 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %768 = load ptr, ptr %50, align 8
  %769 = sext i32 %766 to i64
  %770 = shl nsw i64 %769, 5
  %771 = getelementptr i8, ptr %768, i64 %770
  %772 = load ptr, ptr %771, align 8
  %773 = getelementptr i8, ptr %771, i64 8
  %774 = load i160, ptr %773, align 4
  store ptr %.sroa.0.0564.i1027, ptr %771, align 8
  store i64 %717, ptr %773, align 4
  %.sroa_idx161.i1035 = getelementptr i8, ptr %771, i64 16
  store i64 %716, ptr %.sroa_idx161.i1035, align 4
  %.sroa_idx162.i1036 = getelementptr i8, ptr %771, i64 24
  store i32 %.sroa.17.0561.i1030, ptr %.sroa_idx162.i1036, align 4
  %775 = icmp ne ptr %772, @nil_typ
  %776 = icmp ne ptr %772, null
  %.not90.i1037 = and i1 %775, %776
  %extract607.i1039 = lshr i160 %774, 64
  %777 = insertelement <2 x i160> poison, i160 %774, i64 0
  %778 = insertelement <2 x i160> %777, i160 %extract607.i1039, i64 1
  br i1 %.not90.i1037, label %.cont.cont.i1045, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1080.thread

.cont.cont.i1045:                                 ; preds = %745, %729
  %vptr.i142.sroa.speculated.i1048 = phi ptr [ %738, %729 ], [ %772, %745 ]
  %.in3119 = phi <2 x i160> [ %744, %729 ], [ %778, %745 ]
  %779 = trunc <2 x i160> %.in3119 to <2 x i64>
  %780 = xor i1 %.070565.i1026, true
  %hash_coef_ptr.i.i143.i1051 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1048, i64 8
  %tbl_size_ptr.i.i144.i1052 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1048, i64 16
  %offset_tbl_ptr.i.i145.i1053 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1048, i64 40
  %hash_coef.i.i146.i1054 = load i64, ptr %hash_coef_ptr.i.i143.i1051, align 4
  %tbl_size.i.i147.i1055 = load i64, ptr %tbl_size_ptr.i.i144.i1052, align 4
  %offset_tbl.i.i148.i1056 = load ptr, ptr %offset_tbl_ptr.i.i145.i1053, align 8
  %product.i.i.i149.i1057 = mul i64 %hash_coef.i.i146.i1054, 4015701072841558310
  %shifted.i.i.i150.i1058 = lshr i64 %product.i.i.i149.i1057, 32
  %xored.i.i.i151.i1059 = xor i64 %shifted.i.i.i150.i1058, %product.i.i.i149.i1057
  %hash.i.i.i152.i1060 = and i64 %xored.i.i.i151.i1059, %tbl_size.i.i147.i1055
  %offset_ptr.i.i153.i1061 = getelementptr i32, ptr %offset_tbl.i.i148.i1056, i64 %hash.i.i.i152.i1060
  %offset.i.i154.i1062 = load i32, ptr %offset_ptr.i.i153.i1061, align 4
  %781 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %782 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %783 = icmp ult i32 %.0566.i1025, 99
  br i1 %783, label %714, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1080

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1080.thread: ; preds = %729, %745
  %784 = phi ptr [ %24, %745 ], [ %23, %729 ]
  %785 = load i32, ptr %62, align 4
  store i32 %785, ptr %784, align 4
  %786 = add i32 %785, 1
  %787 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %786, ptr %62, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1080: ; preds = %.cont.cont.i1045
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  %788 = icmp eq ptr %vptr.i142.sroa.speculated.i1048, null
  br i1 %788, label %HashMap_insert_keyK_valueV.exit, label %789

789:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1080
  %790 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %791 = load ptr, ptr %49, align 8
  %792 = load ptr, ptr %50, align 8
  %793 = load i32, ptr %48, align 8
  %794 = shl i32 %793, 1
  %spec.select.i1096 = call i32 @llvm.smax.i32(i32 %794, i32 16)
  store i32 %spec.select.i1096, ptr %48, align 8
  %795 = zext nneg i32 %spec.select.i1096 to i64
  %796 = shl nuw nsw i64 %795, 5
  %result.i.i1097 = call noalias ptr @bump_malloc_inner(i64 noundef %796, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1097, ptr %49, align 8
  %result.i20.i1098 = call noalias ptr @bump_malloc_inner(i64 noundef %796, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1098, ptr %50, align 8
  store i32 0, ptr %62, align 4
  %797 = icmp sgt i32 %793, 0
  br i1 %797, label %.lr.ph.i1870, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1903.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1903.thread: ; preds = %789
  %798 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit

.lr.ph.i1870:                                     ; preds = %789, %._crit_edge.i1885
  %.060.i1883 = phi i32 [ %887, %._crit_edge.i1885 ], [ 0, %789 ]
  %799 = zext nneg i32 %.060.i1883 to i64
  %800 = shl nuw nsw i64 %799, 5
  %801 = getelementptr i8, ptr %791, i64 %800
  %802 = load ptr, ptr %801, align 8
  %803 = icmp ne ptr %802, @nil_typ
  %804 = icmp ne ptr %802, null
  %.not16.i1884 = and i1 %803, %804
  br i1 %.not16.i1884, label %805, label %._crit_edge.i1885

805:                                              ; preds = %.lr.ph.i1870
  %806 = getelementptr i8, ptr %801, i64 8
  %807 = load <2 x i64>, ptr %806, align 4
  %hash_coef_ptr.i.i18.i1887 = getelementptr i8, ptr %802, i64 8
  %tbl_size_ptr.i.i19.i1888 = getelementptr i8, ptr %802, i64 16
  %offset_tbl_ptr.i.i20.i1889 = getelementptr i8, ptr %802, i64 40
  %808 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i2372 = load i64, ptr %hash_coef_ptr.i.i18.i1887, align 4, !noalias !22
  %tbl_size.i.i100.i2373 = load i64, ptr %tbl_size_ptr.i.i19.i1888, align 4, !noalias !22
  %offset_tbl.i.i101.i2374 = load ptr, ptr %offset_tbl_ptr.i.i20.i1889, align 8, !noalias !22
  %product.i.i.i102.i2375 = mul i64 %hash_coef.i.i99.i2372, 4015701072841558310
  %shifted.i.i.i103.i2376 = lshr i64 %product.i.i.i102.i2375, 32
  %xored.i.i.i104.i2377 = xor i64 %shifted.i.i.i103.i2376, %product.i.i.i102.i2375
  %hash.i.i.i105.i2378 = and i64 %xored.i.i.i104.i2377, %tbl_size.i.i100.i2373
  %offset_ptr.i.i106.i2379 = getelementptr i32, ptr %offset_tbl.i.i101.i2374, i64 %hash.i.i.i105.i2378
  %offset.i.i121.i2380 = load i32, ptr %offset_ptr.i.i106.i2379, align 4, !noalias !77
  %809 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %810 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %811 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %812

812:                                              ; preds = %.cont.cont.i2401, %805
  %.0566.i2381 = phi i32 [ 0, %805 ], [ %816, %.cont.cont.i2401 ]
  %.070565.i2382 = phi i1 [ true, %805 ], [ %878, %.cont.cont.i2401 ]
  %.sroa.0.0564.i2383 = phi ptr [ %802, %805 ], [ %vptr.i142.sroa.speculated.i2404, %.cont.cont.i2401 ]
  %.sroa.17.0561.i2386 = phi i32 [ %offset.i.i121.i2380, %805 ], [ %offset.i.i154.i2418, %.cont.cont.i2401 ]
  %813 = phi <2 x i64> [ %807, %805 ], [ %877, %.cont.cont.i2401 ]
  %814 = extractelement <2 x i64> %813, i64 1
  %.sroa.12.0562.i2385 = inttoptr i64 %814 to ptr
  %815 = extractelement <2 x i64> %813, i64 0
  %.sroa.6.0563.i2384 = inttoptr i64 %815 to ptr
  %816 = add nuw nsw i32 %.0566.i2381, 1
  %817 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2383, 0
  %818 = insertvalue { ptr, ptr, ptr, i32 } %817, ptr %.sroa.6.0563.i2384, 1
  %819 = insertvalue { ptr, ptr, ptr, i32 } %818, ptr %.sroa.12.0562.i2385, 2
  %820 = insertvalue { ptr, ptr, ptr, i32 } %819, i32 %.sroa.17.0561.i2386, 3
  %821 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2383)
  %822 = sext i32 %.sroa.17.0561.i2386 to i64
  %823 = getelementptr ptr, ptr %.sroa.0.0564.i2383, i64 %822
  %824 = getelementptr i8, ptr %823, i64 64
  %825 = load ptr, ptr %824, align 8
  %result.i125.i2387 = call ptr %825({ ptr, ptr, ptr, i32 } %820, ptr nocapture nofree noundef nonnull readonly %2) #15
  %826 = call i32 %result.i125.i2387({ ptr, ptr, ptr, i32 } %820, { ptr, ptr, ptr, i32 } %820, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2382, label %827, label %843

827:                                              ; preds = %812
  %828 = load i32, ptr %48, align 8
  %829 = add i32 %828, -1
  %830 = and i32 %829, %826
  %831 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %832 = load ptr, ptr %49, align 8
  %833 = sext i32 %830 to i64
  %834 = shl nsw i64 %833, 5
  %835 = getelementptr i8, ptr %832, i64 %834
  %836 = load ptr, ptr %835, align 8
  %837 = getelementptr i8, ptr %835, i64 8
  %838 = load i160, ptr %837, align 4
  store ptr %.sroa.0.0564.i2383, ptr %835, align 8
  store i64 %815, ptr %837, align 4
  %.sroa_idx157.i2430 = getelementptr i8, ptr %835, i64 16
  store i64 %814, ptr %.sroa_idx157.i2430, align 4
  %.sroa_idx158.i2431 = getelementptr i8, ptr %835, i64 24
  store i32 %.sroa.17.0561.i2386, ptr %.sroa_idx158.i2431, align 4
  %839 = icmp ne ptr %836, @nil_typ
  %840 = icmp ne ptr %836, null
  %.not92.i2432 = and i1 %839, %840
  %extract.i2434 = lshr i160 %838, 64
  %841 = insertelement <2 x i160> poison, i160 %838, i64 0
  %842 = insertelement <2 x i160> %841, i160 %extract.i2434, i64 1
  br i1 %.not92.i2432, label %.cont.cont.i2401, label %882

843:                                              ; preds = %812
  %844 = add i32 %826, 2127912214
  %845 = shl i32 %826, 12
  %846 = add i32 %844, %845
  %847 = ashr i32 %846, 19
  %848 = xor i32 %846, %847
  %849 = xor i32 %848, -949894596
  %850 = add i32 %849, 374761393
  %851 = shl i32 %849, 5
  %852 = add i32 %850, %851
  %853 = add i32 %852, -744332180
  %854 = shl i32 %852, 9
  %855 = xor i32 %853, %854
  %856 = add i32 %855, -42973499
  %857 = shl i32 %855, 3
  %858 = add i32 %856, %857
  %859 = ashr i32 %858, 16
  %860 = xor i32 %858, %859
  %861 = xor i32 %860, -1252372727
  %862 = load i32, ptr %48, align 8
  %863 = add i32 %862, -1
  %864 = and i32 %863, %861
  %865 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %866 = load ptr, ptr %50, align 8
  %867 = sext i32 %864 to i64
  %868 = shl nsw i64 %867, 5
  %869 = getelementptr i8, ptr %866, i64 %868
  %870 = load ptr, ptr %869, align 8
  %871 = getelementptr i8, ptr %869, i64 8
  %872 = load i160, ptr %871, align 4
  store ptr %.sroa.0.0564.i2383, ptr %869, align 8
  store i64 %815, ptr %871, align 4
  %.sroa_idx161.i2391 = getelementptr i8, ptr %869, i64 16
  store i64 %814, ptr %.sroa_idx161.i2391, align 4
  %.sroa_idx162.i2392 = getelementptr i8, ptr %869, i64 24
  store i32 %.sroa.17.0561.i2386, ptr %.sroa_idx162.i2392, align 4
  %873 = icmp ne ptr %870, @nil_typ
  %874 = icmp ne ptr %870, null
  %.not90.i2393 = and i1 %873, %874
  %extract607.i2395 = lshr i160 %872, 64
  %875 = insertelement <2 x i160> poison, i160 %872, i64 0
  %876 = insertelement <2 x i160> %875, i160 %extract607.i2395, i64 1
  br i1 %.not90.i2393, label %.cont.cont.i2401, label %882

.cont.cont.i2401:                                 ; preds = %843, %827
  %vptr.i142.sroa.speculated.i2404 = phi ptr [ %836, %827 ], [ %870, %843 ]
  %.in3120 = phi <2 x i160> [ %842, %827 ], [ %876, %843 ]
  %877 = trunc <2 x i160> %.in3120 to <2 x i64>
  %878 = xor i1 %.070565.i2382, true
  %hash_coef_ptr.i.i143.i2407 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2404, i64 8
  %tbl_size_ptr.i.i144.i2408 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2404, i64 16
  %offset_tbl_ptr.i.i145.i2409 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2404, i64 40
  %hash_coef.i.i146.i2410 = load i64, ptr %hash_coef_ptr.i.i143.i2407, align 4
  %tbl_size.i.i147.i2411 = load i64, ptr %tbl_size_ptr.i.i144.i2408, align 4
  %offset_tbl.i.i148.i2412 = load ptr, ptr %offset_tbl_ptr.i.i145.i2409, align 8
  %product.i.i.i149.i2413 = mul i64 %hash_coef.i.i146.i2410, 4015701072841558310
  %shifted.i.i.i150.i2414 = lshr i64 %product.i.i.i149.i2413, 32
  %xored.i.i.i151.i2415 = xor i64 %shifted.i.i.i150.i2414, %product.i.i.i149.i2413
  %hash.i.i.i152.i2416 = and i64 %xored.i.i.i151.i2415, %tbl_size.i.i147.i2411
  %offset_ptr.i.i153.i2417 = getelementptr i32, ptr %offset_tbl.i.i148.i2412, i64 %hash.i.i.i152.i2416
  %offset.i.i154.i2418 = load i32, ptr %offset_ptr.i.i153.i2417, align 4
  %879 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %880 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %881 = icmp ult i32 %.0566.i2381, 99
  br i1 %881, label %812, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2436

882:                                              ; preds = %843, %827
  %883 = phi ptr [ %14, %843 ], [ %13, %827 ]
  %884 = load i32, ptr %62, align 4
  store i32 %884, ptr %883, align 4
  %885 = add i32 %884, 1
  %886 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %885, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2436

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2436: ; preds = %.cont.cont.i2401, %882
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i1885

._crit_edge.i1885:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2436, %.lr.ph.i1870
  %887 = add nuw nsw i32 %.060.i1883, 1
  %888 = icmp slt i32 %887, %793
  br i1 %888, label %.lr.ph.i1870, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1903

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1903: ; preds = %._crit_edge.i1885
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %890

890:                                              ; preds = %._crit_edge.i1921, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1903
  %.060.i1919 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1903 ], [ %979, %._crit_edge.i1921 ]
  %891 = zext nneg i32 %.060.i1919 to i64
  %892 = shl nuw nsw i64 %891, 5
  %893 = getelementptr i8, ptr %792, i64 %892
  %894 = load ptr, ptr %893, align 8
  %895 = icmp ne ptr %894, @nil_typ
  %896 = icmp ne ptr %894, null
  %.not16.i1920 = and i1 %895, %896
  br i1 %.not16.i1920, label %897, label %._crit_edge.i1921

897:                                              ; preds = %890
  %898 = getelementptr i8, ptr %893, i64 8
  %899 = load <2 x i64>, ptr %898, align 4
  %hash_coef_ptr.i.i18.i1923 = getelementptr i8, ptr %894, i64 8
  %tbl_size_ptr.i.i19.i1924 = getelementptr i8, ptr %894, i64 16
  %offset_tbl_ptr.i.i20.i1925 = getelementptr i8, ptr %894, i64 40
  %900 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i2454 = load i64, ptr %hash_coef_ptr.i.i18.i1923, align 4, !noalias !22
  %tbl_size.i.i100.i2455 = load i64, ptr %tbl_size_ptr.i.i19.i1924, align 4, !noalias !22
  %offset_tbl.i.i101.i2456 = load ptr, ptr %offset_tbl_ptr.i.i20.i1925, align 8, !noalias !22
  %product.i.i.i102.i2457 = mul i64 %hash_coef.i.i99.i2454, 4015701072841558310
  %shifted.i.i.i103.i2458 = lshr i64 %product.i.i.i102.i2457, 32
  %xored.i.i.i104.i2459 = xor i64 %shifted.i.i.i103.i2458, %product.i.i.i102.i2457
  %hash.i.i.i105.i2460 = and i64 %xored.i.i.i104.i2459, %tbl_size.i.i100.i2455
  %offset_ptr.i.i106.i2461 = getelementptr i32, ptr %offset_tbl.i.i101.i2456, i64 %hash.i.i.i105.i2460
  %offset.i.i121.i2462 = load i32, ptr %offset_ptr.i.i106.i2461, align 4, !noalias !80
  %901 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %902 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %903 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %904

904:                                              ; preds = %.cont.cont.i2483, %897
  %.0566.i2463 = phi i32 [ 0, %897 ], [ %908, %.cont.cont.i2483 ]
  %.070565.i2464 = phi i1 [ true, %897 ], [ %970, %.cont.cont.i2483 ]
  %.sroa.0.0564.i2465 = phi ptr [ %894, %897 ], [ %vptr.i142.sroa.speculated.i2486, %.cont.cont.i2483 ]
  %.sroa.17.0561.i2468 = phi i32 [ %offset.i.i121.i2462, %897 ], [ %offset.i.i154.i2500, %.cont.cont.i2483 ]
  %905 = phi <2 x i64> [ %899, %897 ], [ %969, %.cont.cont.i2483 ]
  %906 = extractelement <2 x i64> %905, i64 1
  %.sroa.12.0562.i2467 = inttoptr i64 %906 to ptr
  %907 = extractelement <2 x i64> %905, i64 0
  %.sroa.6.0563.i2466 = inttoptr i64 %907 to ptr
  %908 = add nuw nsw i32 %.0566.i2463, 1
  %909 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2465, 0
  %910 = insertvalue { ptr, ptr, ptr, i32 } %909, ptr %.sroa.6.0563.i2466, 1
  %911 = insertvalue { ptr, ptr, ptr, i32 } %910, ptr %.sroa.12.0562.i2467, 2
  %912 = insertvalue { ptr, ptr, ptr, i32 } %911, i32 %.sroa.17.0561.i2468, 3
  %913 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2465)
  %914 = sext i32 %.sroa.17.0561.i2468 to i64
  %915 = getelementptr ptr, ptr %.sroa.0.0564.i2465, i64 %914
  %916 = getelementptr i8, ptr %915, i64 64
  %917 = load ptr, ptr %916, align 8
  %result.i125.i2469 = call ptr %917({ ptr, ptr, ptr, i32 } %912, ptr nocapture nofree noundef nonnull readonly %2) #15
  %918 = call i32 %result.i125.i2469({ ptr, ptr, ptr, i32 } %912, { ptr, ptr, ptr, i32 } %912, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2464, label %919, label %935

919:                                              ; preds = %904
  %920 = load i32, ptr %48, align 8
  %921 = add i32 %920, -1
  %922 = and i32 %921, %918
  %923 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %924 = load ptr, ptr %49, align 8
  %925 = sext i32 %922 to i64
  %926 = shl nsw i64 %925, 5
  %927 = getelementptr i8, ptr %924, i64 %926
  %928 = load ptr, ptr %927, align 8
  %929 = getelementptr i8, ptr %927, i64 8
  %930 = load i160, ptr %929, align 4
  store ptr %.sroa.0.0564.i2465, ptr %927, align 8
  store i64 %907, ptr %929, align 4
  %.sroa_idx157.i2512 = getelementptr i8, ptr %927, i64 16
  store i64 %906, ptr %.sroa_idx157.i2512, align 4
  %.sroa_idx158.i2513 = getelementptr i8, ptr %927, i64 24
  store i32 %.sroa.17.0561.i2468, ptr %.sroa_idx158.i2513, align 4
  %931 = icmp ne ptr %928, @nil_typ
  %932 = icmp ne ptr %928, null
  %.not92.i2514 = and i1 %931, %932
  %extract.i2516 = lshr i160 %930, 64
  %933 = insertelement <2 x i160> poison, i160 %930, i64 0
  %934 = insertelement <2 x i160> %933, i160 %extract.i2516, i64 1
  br i1 %.not92.i2514, label %.cont.cont.i2483, label %974

935:                                              ; preds = %904
  %936 = add i32 %918, 2127912214
  %937 = shl i32 %918, 12
  %938 = add i32 %936, %937
  %939 = ashr i32 %938, 19
  %940 = xor i32 %938, %939
  %941 = xor i32 %940, -949894596
  %942 = add i32 %941, 374761393
  %943 = shl i32 %941, 5
  %944 = add i32 %942, %943
  %945 = add i32 %944, -744332180
  %946 = shl i32 %944, 9
  %947 = xor i32 %945, %946
  %948 = add i32 %947, -42973499
  %949 = shl i32 %947, 3
  %950 = add i32 %948, %949
  %951 = ashr i32 %950, 16
  %952 = xor i32 %950, %951
  %953 = xor i32 %952, -1252372727
  %954 = load i32, ptr %48, align 8
  %955 = add i32 %954, -1
  %956 = and i32 %955, %953
  %957 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %958 = load ptr, ptr %50, align 8
  %959 = sext i32 %956 to i64
  %960 = shl nsw i64 %959, 5
  %961 = getelementptr i8, ptr %958, i64 %960
  %962 = load ptr, ptr %961, align 8
  %963 = getelementptr i8, ptr %961, i64 8
  %964 = load i160, ptr %963, align 4
  store ptr %.sroa.0.0564.i2465, ptr %961, align 8
  store i64 %907, ptr %963, align 4
  %.sroa_idx161.i2473 = getelementptr i8, ptr %961, i64 16
  store i64 %906, ptr %.sroa_idx161.i2473, align 4
  %.sroa_idx162.i2474 = getelementptr i8, ptr %961, i64 24
  store i32 %.sroa.17.0561.i2468, ptr %.sroa_idx162.i2474, align 4
  %965 = icmp ne ptr %962, @nil_typ
  %966 = icmp ne ptr %962, null
  %.not90.i2475 = and i1 %965, %966
  %extract607.i2477 = lshr i160 %964, 64
  %967 = insertelement <2 x i160> poison, i160 %964, i64 0
  %968 = insertelement <2 x i160> %967, i160 %extract607.i2477, i64 1
  br i1 %.not90.i2475, label %.cont.cont.i2483, label %974

.cont.cont.i2483:                                 ; preds = %935, %919
  %vptr.i142.sroa.speculated.i2486 = phi ptr [ %928, %919 ], [ %962, %935 ]
  %.in3121 = phi <2 x i160> [ %934, %919 ], [ %968, %935 ]
  %969 = trunc <2 x i160> %.in3121 to <2 x i64>
  %970 = xor i1 %.070565.i2464, true
  %hash_coef_ptr.i.i143.i2489 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2486, i64 8
  %tbl_size_ptr.i.i144.i2490 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2486, i64 16
  %offset_tbl_ptr.i.i145.i2491 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2486, i64 40
  %hash_coef.i.i146.i2492 = load i64, ptr %hash_coef_ptr.i.i143.i2489, align 4
  %tbl_size.i.i147.i2493 = load i64, ptr %tbl_size_ptr.i.i144.i2490, align 4
  %offset_tbl.i.i148.i2494 = load ptr, ptr %offset_tbl_ptr.i.i145.i2491, align 8
  %product.i.i.i149.i2495 = mul i64 %hash_coef.i.i146.i2492, 4015701072841558310
  %shifted.i.i.i150.i2496 = lshr i64 %product.i.i.i149.i2495, 32
  %xored.i.i.i151.i2497 = xor i64 %shifted.i.i.i150.i2496, %product.i.i.i149.i2495
  %hash.i.i.i152.i2498 = and i64 %xored.i.i.i151.i2497, %tbl_size.i.i147.i2493
  %offset_ptr.i.i153.i2499 = getelementptr i32, ptr %offset_tbl.i.i148.i2494, i64 %hash.i.i.i152.i2498
  %offset.i.i154.i2500 = load i32, ptr %offset_ptr.i.i153.i2499, align 4
  %971 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %973 = icmp ult i32 %.0566.i2463, 99
  br i1 %973, label %904, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2518

974:                                              ; preds = %935, %919
  %975 = phi ptr [ %12, %935 ], [ %11, %919 ]
  %976 = load i32, ptr %62, align 4
  store i32 %976, ptr %975, align 4
  %977 = add i32 %976, 1
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %977, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2518

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2518: ; preds = %.cont.cont.i2483, %974
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %._crit_edge.i1921

._crit_edge.i1921:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2518, %890
  %979 = add nuw nsw i32 %.060.i1919, 1
  %980 = icmp slt i32 %979, %793
  br i1 %980, label %890, label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %._crit_edge.i1921, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1903.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1080.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit943, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1080
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %981 = add nuw nsw i32 %.0247472, 1
  %982 = icmp slt i32 %981, %0
  br i1 %982, label %._crit_edge, label %._crit_edge2._crit_edge

._crit_edge2._crit_edge:                          ; preds = %HashMap_insert_keyK_valueV.exit
  %983 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %985 = load i32, ptr %62, align 4
  %986 = call i64 @clock()
  %987 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %988 = getelementptr inbounds i8, ptr %result.i268, i64 44
  %989 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i268, 1
  %990 = insertvalue { ptr, ptr, ptr, i32 } %989, ptr undef, 2
  %991 = insertvalue { ptr, ptr, ptr, i32 } %990, i32 10, 3
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge2._crit_edge, %HashMap_insert_keyK_valueV.exit713
  %.2249474 = phi i32 [ %1905, %HashMap_insert_keyK_valueV.exit713 ], [ 0, %._crit_edge2._crit_edge ]
  %992 = zext nneg i32 %.2249474 to i64
  %993 = shl nuw nsw i64 %992, 2
  %994 = getelementptr i8, ptr %result.i4.i, i64 %993
  %995 = load i32, ptr %994, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %995 to i160
  %996 = add i32 %995, 1
  %997 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %.sroa.0211.0.insert.ext = zext i32 %996 to i160
  %998 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0211.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %999 = load ptr, ptr %result.i268, align 8
  %1000 = load ptr, ptr %32, align 8
  %1001 = call i32 %1000({ ptr, i160 } %997) #7
  %1002 = load i32, ptr %34, align 8
  %1003 = add i32 %1002, -1
  %1004 = and i32 %1003, %1001
  %1005 = load ptr, ptr %35, align 8
  %1006 = load ptr, ptr %27, align 8
  %1007 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1008 = sext i32 %1004 to i64
  %1009 = shl nsw i64 %1008, 5
  %1010 = getelementptr i8, ptr %1005, i64 %1009
  %1011 = load ptr, ptr %1010, align 8
  %1012 = getelementptr i8, ptr %1010, i64 8
  %1013 = icmp ne ptr %1011, @nil_typ
  %1014 = icmp ne ptr %1011, null
  %.not64.i1142 = and i1 %1013, %1014
  br i1 %.not64.i1142, label %1015, label %1112

1015:                                             ; preds = %._crit_edge3
  %1016 = load i64, ptr %1012, align 4
  %.sroa_idx.i1144 = getelementptr i8, ptr %1010, i64 16
  %1017 = load i64, ptr %.sroa_idx.i1144, align 4
  %1018 = inttoptr i64 %1016 to ptr
  %1019 = inttoptr i64 %1017 to ptr
  %hash_coef_ptr.i.i66.i1145 = getelementptr i8, ptr %1011, i64 8
  %tbl_size_ptr.i.i67.i1146 = getelementptr i8, ptr %1011, i64 16
  %offset_tbl_ptr.i.i68.i1147 = getelementptr i8, ptr %1011, i64 40
  %hash_coef.i.i69.i1148 = load i64, ptr %hash_coef_ptr.i.i66.i1145, align 4, !noalias !83
  %tbl_size.i.i70.i1149 = load i64, ptr %tbl_size_ptr.i.i67.i1146, align 4, !noalias !83
  %offset_tbl.i.i71.i1150 = load ptr, ptr %offset_tbl_ptr.i.i68.i1147, align 8, !noalias !83
  %product.i.i.i72.i1151 = mul i64 %hash_coef.i.i69.i1148, 4015701072841558310
  %shifted.i.i.i73.i1152 = lshr i64 %product.i.i.i72.i1151, 32
  %xored.i.i.i74.i1153 = xor i64 %shifted.i.i.i73.i1152, %product.i.i.i72.i1151
  %hash.i.i.i75.i1154 = and i64 %xored.i.i.i74.i1153, %tbl_size.i.i70.i1149
  %offset_ptr.i.i76.i1155 = getelementptr i32, ptr %offset_tbl.i.i71.i1150, i64 %hash.i.i.i75.i1154
  %offset.i.i77.i1156 = load i32, ptr %offset_ptr.i.i76.i1155, align 4, !noalias !83
  %1020 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1011, 0
  %1021 = insertvalue { ptr, ptr, ptr, i32 } %1020, ptr %1018, 1
  %1022 = insertvalue { ptr, ptr, ptr, i32 } %1021, ptr %1019, 2
  %1023 = insertvalue { ptr, ptr, ptr, i32 } %1022, i32 %offset.i.i77.i1156, 3
  %1024 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1025 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1011) #34
  %1026 = sext i32 %offset.i.i77.i1156 to i64
  %1027 = getelementptr ptr, ptr %1011, i64 %1026
  %1028 = getelementptr i8, ptr %1027, i64 64
  %1029 = load ptr, ptr %1028, align 8
  %result.i.i1157 = call ptr %1029({ ptr, ptr, ptr, i32 } %1023, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1030 = call i32 %result.i.i1157({ ptr, ptr, ptr, i32 } %1023, { ptr, ptr, ptr, i32 } %1023, ptr nonnull align 8 %2) #7
  %1031 = icmp eq i32 %1030, %1001
  br i1 %1031, label %._crit_edge.i1158, label %1112

._crit_edge.i1158:                                ; preds = %1015
  %1032 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1033 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1011)
  %1034 = getelementptr i8, ptr %1027, i64 48
  %1035 = load ptr, ptr %1034, align 8
  %result.i79.i1159 = call ptr %1035({ ptr, ptr, ptr, i32 } %1023, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1036 = call { ptr, i160 } %result.i79.i1159({ ptr, ptr, ptr, i32 } %1023, { ptr, ptr, ptr, i32 } %1023, ptr nonnull align 8 %2) #7
  %1037 = load ptr, ptr %33, align 8
  %1038 = call i1 %1037({ ptr, i160 } %1036, { ptr, i160 } %997) #7
  br i1 %1038, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1171, label %1112

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1171: ; preds = %._crit_edge.i1158
  %1039 = load ptr, ptr %result.i268, align 8
  %1040 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1041 = load ptr, ptr %27, align 8
  %1042 = load ptr, ptr %1039, align 8, !alias.scope !86
  %1043 = getelementptr i8, ptr %1042, i64 72
  %1044 = load ptr, ptr %1043, align 8, !alias.scope !86
  %result.i.i.i1163 = call { i64, i64 } %1044(ptr nocapture nofree nonnull readonly %1039) #5, !alias.scope !86
  %1045 = extractvalue { i64, i64 } %result.i.i.i1163, 0
  %1046 = extractvalue { i64, i64 } %result.i.i.i1163, 1
  %1047 = urem i64 20, %1046
  %1048 = icmp eq i64 %1047, 0
  %1049 = sub i64 %1046, %1047
  %1050 = select i1 %1048, i64 0, i64 %1049
  %1051 = add i64 %1045, 20
  %1052 = add i64 %1051, %1050
  %1053 = load ptr, ptr %1041, align 8, !alias.scope !86
  %1054 = getelementptr i8, ptr %1053, i64 72
  %1055 = load ptr, ptr %1054, align 8, !alias.scope !86
  %result.i1.i.i1164 = call { i64, i64 } %1055(ptr nocapture nofree nonnull readonly %1041) #5, !alias.scope !86
  %1056 = extractvalue { i64, i64 } %result.i1.i.i1164, 0
  %1057 = extractvalue { i64, i64 } %result.i1.i.i1164, 1
  %1058 = call i64 @llvm.umax.i64(i64 %1046, i64 %1057)
  %1059 = call i64 @llvm.umax.i64(i64 %1058, i64 8)
  %1060 = urem i64 %1052, %1057
  %1061 = icmp eq i64 %1060, 0
  %1062 = sub i64 %1057, %1060
  %1063 = select i1 %1061, i64 0, i64 %1062
  %1064 = add i64 %1056, %1052
  %1065 = add i64 %1064, %1063
  %1066 = urem i64 %1065, %1059
  %1067 = icmp eq i64 %1066, 0
  %1068 = sub i64 %1059, %1066
  %1069 = select i1 %1067, i64 0, i64 %1068
  %1070 = add i64 %1069, %1065
  %result.i83.i1165 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1070, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1039, ptr %result.i83.i1165, align 8
  %1071 = getelementptr inbounds i8, ptr %result.i83.i1165, i64 8
  store ptr %1041, ptr %1071, align 8
  %1072 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1165)
  %1073 = load ptr, ptr %1039, align 8
  %1074 = getelementptr i8, ptr %1073, i64 72
  %1075 = load ptr, ptr %1074, align 8
  %result.i.i114.i1166 = call { i64, i64 } %1075(ptr nocapture nofree nonnull readonly %1039) #5
  %1076 = extractvalue { i64, i64 } %result.i.i114.i1166, 1
  %1077 = urem i64 20, %1076
  %1078 = icmp eq i64 %1077, 0
  %reass.sub = sub i64 %1076, %1077
  %1079 = add i64 %reass.sub, 20
  %1080 = select i1 %1078, i64 20, i64 %1079
  %1081 = getelementptr i8, ptr %result.i83.i1165, i64 %1080
  %1082 = getelementptr i8, ptr %1073, i64 64
  %1083 = load ptr, ptr %1082, align 8
  call void %1083({ ptr, i160 } %997, ptr nocapture nofree nonnull readonly %1039, ptr nocapture nofree writeonly %1081) #12
  %1084 = load ptr, ptr %result.i83.i1165, align 8
  %1085 = load ptr, ptr %1084, align 8
  %1086 = getelementptr i8, ptr %1085, i64 72
  %1087 = load ptr, ptr %1086, align 8
  %result.i.i115.i1168 = call { i64, i64 } %1087(ptr nocapture nofree nonnull readonly %1084) #5
  %1088 = extractvalue { i64, i64 } %result.i.i115.i1168, 0
  %1089 = extractvalue { i64, i64 } %result.i.i115.i1168, 1
  %1090 = urem i64 20, %1089
  %1091 = icmp eq i64 %1090, 0
  %1092 = sub i64 %1089, %1090
  %1093 = select i1 %1091, i64 0, i64 %1092
  %1094 = add i64 %1088, 20
  %1095 = add i64 %1094, %1093
  %1096 = load ptr, ptr %1071, align 8
  %1097 = load ptr, ptr %1096, align 8
  %1098 = getelementptr i8, ptr %1097, i64 72
  %1099 = load ptr, ptr %1098, align 8
  %result.i1.i116.i1169 = call { i64, i64 } %1099(ptr nocapture nofree nonnull readonly %1096) #5
  %1100 = extractvalue { i64, i64 } %result.i1.i116.i1169, 1
  %1101 = urem i64 %1095, %1100
  %1102 = icmp eq i64 %1101, 0
  %1103 = sub i64 %1100, %1101
  %1104 = select i1 %1102, i64 0, i64 %1103
  %1105 = getelementptr i8, ptr %result.i83.i1165, i64 %1095
  %1106 = getelementptr i8, ptr %1105, i64 %1104
  %1107 = getelementptr i8, ptr %1097, i64 64
  %1108 = load ptr, ptr %1107, align 8
  call void %1108({ ptr, i160 } %998, ptr nocapture nofree nonnull readonly %1096, ptr nocapture nofree writeonly %1106) #12
  %1109 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1110 = getelementptr inbounds i8, ptr %result.i83.i1165, i64 16
  store i32 %1001, ptr %1110, align 8
  store ptr @Entry, ptr %1010, align 8
  %1111 = ptrtoint ptr %result.i83.i1165 to i64
  store i64 %1111, ptr %1012, align 4
  %.sroa_idx28.i1170 = getelementptr i8, ptr %1010, i64 24
  store i32 10, ptr %.sroa_idx28.i1170, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit713

1112:                                             ; preds = %._crit_edge.i1158, %._crit_edge3, %1015
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1113 = add i32 %1001, 2127912214
  %1114 = shl i32 %1001, 12
  %1115 = add i32 %1113, %1114
  %1116 = ashr i32 %1115, 19
  %1117 = xor i32 %1115, %1116
  %1118 = xor i32 %1117, -949894596
  %1119 = add i32 %1118, 374761393
  %1120 = shl i32 %1118, 5
  %1121 = add i32 %1119, %1120
  %1122 = add i32 %1121, -744332180
  %1123 = shl i32 %1121, 9
  %1124 = xor i32 %1122, %1123
  %1125 = add i32 %1124, -42973499
  %1126 = shl i32 %1124, 3
  %1127 = add i32 %1125, %1126
  %1128 = ashr i32 %1127, 16
  %1129 = xor i32 %1127, %1128
  %1130 = xor i32 %1129, -1252372727
  %1131 = load i32, ptr %34, align 8
  %1132 = add i32 %1131, -1
  %1133 = and i32 %1132, %1130
  %1134 = load ptr, ptr %36, align 8
  %1135 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1136 = sext i32 %1133 to i64
  %1137 = shl nsw i64 %1136, 5
  %1138 = getelementptr i8, ptr %1134, i64 %1137
  %1139 = load ptr, ptr %1138, align 8
  %1140 = getelementptr i8, ptr %1138, i64 8
  %1141 = icmp ne ptr %1139, @nil_typ
  %1142 = icmp ne ptr %1139, null
  %.not64.i1201 = and i1 %1141, %1142
  br i1 %.not64.i1201, label %1143, label %1241

1143:                                             ; preds = %1112
  %1144 = load i64, ptr %1140, align 4
  %.sroa_idx.i1203 = getelementptr i8, ptr %1138, i64 16
  %1145 = load i64, ptr %.sroa_idx.i1203, align 4
  %1146 = inttoptr i64 %1144 to ptr
  %1147 = inttoptr i64 %1145 to ptr
  %hash_coef_ptr.i.i66.i1204 = getelementptr i8, ptr %1139, i64 8
  %tbl_size_ptr.i.i67.i1205 = getelementptr i8, ptr %1139, i64 16
  %offset_tbl_ptr.i.i68.i1206 = getelementptr i8, ptr %1139, i64 40
  %hash_coef.i.i69.i1207 = load i64, ptr %hash_coef_ptr.i.i66.i1204, align 4, !noalias !89
  %tbl_size.i.i70.i1208 = load i64, ptr %tbl_size_ptr.i.i67.i1205, align 4, !noalias !89
  %offset_tbl.i.i71.i1209 = load ptr, ptr %offset_tbl_ptr.i.i68.i1206, align 8, !noalias !89
  %product.i.i.i72.i1210 = mul i64 %hash_coef.i.i69.i1207, 4015701072841558310
  %shifted.i.i.i73.i1211 = lshr i64 %product.i.i.i72.i1210, 32
  %xored.i.i.i74.i1212 = xor i64 %shifted.i.i.i73.i1211, %product.i.i.i72.i1210
  %hash.i.i.i75.i1213 = and i64 %xored.i.i.i74.i1212, %tbl_size.i.i70.i1208
  %offset_ptr.i.i76.i1214 = getelementptr i32, ptr %offset_tbl.i.i71.i1209, i64 %hash.i.i.i75.i1213
  %offset.i.i77.i1215 = load i32, ptr %offset_ptr.i.i76.i1214, align 4, !noalias !89
  %1148 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1139, 0
  %1149 = insertvalue { ptr, ptr, ptr, i32 } %1148, ptr %1146, 1
  %1150 = insertvalue { ptr, ptr, ptr, i32 } %1149, ptr %1147, 2
  %1151 = insertvalue { ptr, ptr, ptr, i32 } %1150, i32 %offset.i.i77.i1215, 3
  %1152 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1153 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1139) #34
  %1154 = sext i32 %offset.i.i77.i1215 to i64
  %1155 = getelementptr ptr, ptr %1139, i64 %1154
  %1156 = getelementptr i8, ptr %1155, i64 64
  %1157 = load ptr, ptr %1156, align 8
  %result.i.i1216 = call ptr %1157({ ptr, ptr, ptr, i32 } %1151, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1158 = call i32 %result.i.i1216({ ptr, ptr, ptr, i32 } %1151, { ptr, ptr, ptr, i32 } %1151, ptr nonnull align 8 %2) #7
  %1159 = icmp eq i32 %1158, %1001
  br i1 %1159, label %._crit_edge.i1217, label %1241

._crit_edge.i1217:                                ; preds = %1143
  %1160 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1161 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1139)
  %1162 = getelementptr i8, ptr %1155, i64 48
  %1163 = load ptr, ptr %1162, align 8
  %result.i79.i1218 = call ptr %1163({ ptr, ptr, ptr, i32 } %1151, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1164 = call { ptr, i160 } %result.i79.i1218({ ptr, ptr, ptr, i32 } %1151, { ptr, ptr, ptr, i32 } %1151, ptr nonnull align 8 %2) #7
  %1165 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1166 = load ptr, ptr %33, align 8
  %1167 = call i1 %1166({ ptr, i160 } %1164, { ptr, i160 } %997) #7
  br i1 %1167, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1230, label %1241

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1230: ; preds = %._crit_edge.i1217
  %1168 = load ptr, ptr %result.i268, align 8
  %1169 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1170 = load ptr, ptr %27, align 8
  %1171 = load ptr, ptr %1168, align 8, !alias.scope !92
  %1172 = getelementptr i8, ptr %1171, i64 72
  %1173 = load ptr, ptr %1172, align 8, !alias.scope !92
  %result.i.i.i1222 = call { i64, i64 } %1173(ptr nocapture nofree nonnull readonly %1168) #5, !alias.scope !92
  %1174 = extractvalue { i64, i64 } %result.i.i.i1222, 0
  %1175 = extractvalue { i64, i64 } %result.i.i.i1222, 1
  %1176 = urem i64 20, %1175
  %1177 = icmp eq i64 %1176, 0
  %1178 = sub i64 %1175, %1176
  %1179 = select i1 %1177, i64 0, i64 %1178
  %1180 = add i64 %1174, 20
  %1181 = add i64 %1180, %1179
  %1182 = load ptr, ptr %1170, align 8, !alias.scope !92
  %1183 = getelementptr i8, ptr %1182, i64 72
  %1184 = load ptr, ptr %1183, align 8, !alias.scope !92
  %result.i1.i.i1223 = call { i64, i64 } %1184(ptr nocapture nofree nonnull readonly %1170) #5, !alias.scope !92
  %1185 = extractvalue { i64, i64 } %result.i1.i.i1223, 0
  %1186 = extractvalue { i64, i64 } %result.i1.i.i1223, 1
  %1187 = call i64 @llvm.umax.i64(i64 %1175, i64 %1186)
  %1188 = call i64 @llvm.umax.i64(i64 %1187, i64 8)
  %1189 = urem i64 %1181, %1186
  %1190 = icmp eq i64 %1189, 0
  %1191 = sub i64 %1186, %1189
  %1192 = select i1 %1190, i64 0, i64 %1191
  %1193 = add i64 %1185, %1181
  %1194 = add i64 %1193, %1192
  %1195 = urem i64 %1194, %1188
  %1196 = icmp eq i64 %1195, 0
  %1197 = sub i64 %1188, %1195
  %1198 = select i1 %1196, i64 0, i64 %1197
  %1199 = add i64 %1198, %1194
  %result.i83.i1224 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1199, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1168, ptr %result.i83.i1224, align 8
  %1200 = getelementptr inbounds i8, ptr %result.i83.i1224, i64 8
  store ptr %1170, ptr %1200, align 8
  %1201 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1224)
  %1202 = load ptr, ptr %1168, align 8
  %1203 = getelementptr i8, ptr %1202, i64 72
  %1204 = load ptr, ptr %1203, align 8
  %result.i.i114.i1225 = call { i64, i64 } %1204(ptr nocapture nofree nonnull readonly %1168) #5
  %1205 = extractvalue { i64, i64 } %result.i.i114.i1225, 1
  %1206 = urem i64 20, %1205
  %1207 = icmp eq i64 %1206, 0
  %reass.sub3116 = sub i64 %1205, %1206
  %1208 = add i64 %reass.sub3116, 20
  %1209 = select i1 %1207, i64 20, i64 %1208
  %1210 = getelementptr i8, ptr %result.i83.i1224, i64 %1209
  %1211 = getelementptr i8, ptr %1202, i64 64
  %1212 = load ptr, ptr %1211, align 8
  call void %1212({ ptr, i160 } %997, ptr nocapture nofree nonnull readonly %1168, ptr nocapture nofree writeonly %1210) #12
  %1213 = load ptr, ptr %result.i83.i1224, align 8
  %1214 = load ptr, ptr %1213, align 8
  %1215 = getelementptr i8, ptr %1214, i64 72
  %1216 = load ptr, ptr %1215, align 8
  %result.i.i115.i1227 = call { i64, i64 } %1216(ptr nocapture nofree nonnull readonly %1213) #5
  %1217 = extractvalue { i64, i64 } %result.i.i115.i1227, 0
  %1218 = extractvalue { i64, i64 } %result.i.i115.i1227, 1
  %1219 = urem i64 20, %1218
  %1220 = icmp eq i64 %1219, 0
  %1221 = sub i64 %1218, %1219
  %1222 = select i1 %1220, i64 0, i64 %1221
  %1223 = add i64 %1217, 20
  %1224 = add i64 %1223, %1222
  %1225 = load ptr, ptr %1200, align 8
  %1226 = load ptr, ptr %1225, align 8
  %1227 = getelementptr i8, ptr %1226, i64 72
  %1228 = load ptr, ptr %1227, align 8
  %result.i1.i116.i1228 = call { i64, i64 } %1228(ptr nocapture nofree nonnull readonly %1225) #5
  %1229 = extractvalue { i64, i64 } %result.i1.i116.i1228, 1
  %1230 = urem i64 %1224, %1229
  %1231 = icmp eq i64 %1230, 0
  %1232 = sub i64 %1229, %1230
  %1233 = select i1 %1231, i64 0, i64 %1232
  %1234 = getelementptr i8, ptr %result.i83.i1224, i64 %1224
  %1235 = getelementptr i8, ptr %1234, i64 %1233
  %1236 = getelementptr i8, ptr %1226, i64 64
  %1237 = load ptr, ptr %1236, align 8
  call void %1237({ ptr, i160 } %998, ptr nocapture nofree nonnull readonly %1225, ptr nocapture nofree writeonly %1235) #12
  %1238 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1239 = getelementptr inbounds i8, ptr %result.i83.i1224, i64 16
  store i32 %1001, ptr %1239, align 8
  store ptr @Entry, ptr %1138, align 8
  %1240 = ptrtoint ptr %result.i83.i1224 to i64
  store i64 %1240, ptr %1140, align 4
  %.sroa_idx28.i1229 = getelementptr i8, ptr %1138, i64 24
  store i32 10, ptr %.sroa_idx28.i1229, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit713

1241:                                             ; preds = %._crit_edge.i1217, %1112, %1143
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1242 = load i32, ptr %988, align 4
  %1243 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1244 = load i32, ptr %34, align 8
  %.not.i677 = icmp slt i32 %1242, %1244
  br i1 %.not.i677, label %._crit_edge.i679, label %1245

1245:                                             ; preds = %1241
  %1246 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1247 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1248 = load ptr, ptr %35, align 8
  %1249 = load ptr, ptr %36, align 8
  %1250 = shl i32 %1244, 1
  %spec.select.i1246 = call i32 @llvm.smax.i32(i32 %1250, i32 16)
  store i32 %spec.select.i1246, ptr %34, align 8
  %1251 = zext nneg i32 %spec.select.i1246 to i64
  %1252 = shl nuw nsw i64 %1251, 5
  %result.i.i1247 = call noalias ptr @bump_malloc_inner(i64 noundef %1252, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1247, ptr %35, align 8
  %result.i20.i1248 = call noalias ptr @bump_malloc_inner(i64 noundef %1252, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1248, ptr %36, align 8
  store i32 0, ptr %988, align 4
  %1253 = icmp sgt i32 %1244, 0
  br i1 %1253, label %.lr.ph.i1942, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1975.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1975.thread: ; preds = %1245
  %1254 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i679

.lr.ph.i1942:                                     ; preds = %1245, %._crit_edge.i1957
  %.060.i1955 = phi i32 [ %1273, %._crit_edge.i1957 ], [ 0, %1245 ]
  %1255 = zext nneg i32 %.060.i1955 to i64
  %1256 = shl nuw nsw i64 %1255, 5
  %1257 = getelementptr i8, ptr %1248, i64 %1256
  %1258 = load ptr, ptr %1257, align 8
  %1259 = icmp ne ptr %1258, @nil_typ
  %1260 = icmp ne ptr %1258, null
  %.not16.i1956 = and i1 %1259, %1260
  br i1 %.not16.i1956, label %1261, label %._crit_edge.i1957

1261:                                             ; preds = %.lr.ph.i1942
  %1262 = getelementptr i8, ptr %1257, i64 8
  %1263 = load i64, ptr %1262, align 4
  %.sroa_idx.i1958 = getelementptr i8, ptr %1257, i64 16
  %1264 = load i64, ptr %.sroa_idx.i1958, align 4
  %1265 = inttoptr i64 %1263 to ptr
  %1266 = inttoptr i64 %1264 to ptr
  %hash_coef_ptr.i.i18.i1959 = getelementptr i8, ptr %1258, i64 8
  %tbl_size_ptr.i.i19.i1960 = getelementptr i8, ptr %1258, i64 16
  %offset_tbl_ptr.i.i20.i1961 = getelementptr i8, ptr %1258, i64 40
  %hash_coef.i.i21.i1962 = load i64, ptr %hash_coef_ptr.i.i18.i1959, align 4, !noalias !22
  %tbl_size.i.i22.i1963 = load i64, ptr %tbl_size_ptr.i.i19.i1960, align 4, !noalias !22
  %offset_tbl.i.i23.i1964 = load ptr, ptr %offset_tbl_ptr.i.i20.i1961, align 8, !noalias !22
  %product.i.i.i24.i1965 = mul i64 %hash_coef.i.i21.i1962, 4015701072841558310
  %shifted.i.i.i25.i1966 = lshr i64 %product.i.i.i24.i1965, 32
  %xored.i.i.i26.i1967 = xor i64 %shifted.i.i.i25.i1966, %product.i.i.i24.i1965
  %hash.i.i.i27.i1968 = and i64 %xored.i.i.i26.i1967, %tbl_size.i.i22.i1963
  %offset_ptr.i.i28.i1969 = getelementptr i32, ptr %offset_tbl.i.i23.i1964, i64 %hash.i.i.i27.i1968
  %offset.i.i43.i1970 = load i32, ptr %offset_ptr.i.i28.i1969, align 4, !noalias !95
  %1267 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1258, 0
  %1268 = insertvalue { ptr, ptr, ptr, i32 } %1267, ptr %1265, 1
  %1269 = insertvalue { ptr, ptr, ptr, i32 } %1268, ptr %1266, 2
  %1270 = insertvalue { ptr, ptr, ptr, i32 } %1269, i32 %offset.i.i43.i1970, 3
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %1272 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %991, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %1270) #7
  br label %._crit_edge.i1957

._crit_edge.i1957:                                ; preds = %1261, %.lr.ph.i1942
  %1273 = add nuw nsw i32 %.060.i1955, 1
  %1274 = icmp slt i32 %1273, %1244
  br i1 %1274, label %.lr.ph.i1942, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1975

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1975: ; preds = %._crit_edge.i1957
  %1275 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1276

1276:                                             ; preds = %._crit_edge.i1993, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1975
  %.060.i1991 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1975 ], [ %1295, %._crit_edge.i1993 ]
  %1277 = zext nneg i32 %.060.i1991 to i64
  %1278 = shl nuw nsw i64 %1277, 5
  %1279 = getelementptr i8, ptr %1249, i64 %1278
  %1280 = load ptr, ptr %1279, align 8
  %1281 = icmp ne ptr %1280, @nil_typ
  %1282 = icmp ne ptr %1280, null
  %.not16.i1992 = and i1 %1281, %1282
  br i1 %.not16.i1992, label %1283, label %._crit_edge.i1993

1283:                                             ; preds = %1276
  %1284 = getelementptr i8, ptr %1279, i64 8
  %1285 = load i64, ptr %1284, align 4
  %.sroa_idx.i1994 = getelementptr i8, ptr %1279, i64 16
  %1286 = load i64, ptr %.sroa_idx.i1994, align 4
  %1287 = inttoptr i64 %1285 to ptr
  %1288 = inttoptr i64 %1286 to ptr
  %hash_coef_ptr.i.i18.i1995 = getelementptr i8, ptr %1280, i64 8
  %tbl_size_ptr.i.i19.i1996 = getelementptr i8, ptr %1280, i64 16
  %offset_tbl_ptr.i.i20.i1997 = getelementptr i8, ptr %1280, i64 40
  %hash_coef.i.i21.i1998 = load i64, ptr %hash_coef_ptr.i.i18.i1995, align 4, !noalias !22
  %tbl_size.i.i22.i1999 = load i64, ptr %tbl_size_ptr.i.i19.i1996, align 4, !noalias !22
  %offset_tbl.i.i23.i2000 = load ptr, ptr %offset_tbl_ptr.i.i20.i1997, align 8, !noalias !22
  %product.i.i.i24.i2001 = mul i64 %hash_coef.i.i21.i1998, 4015701072841558310
  %shifted.i.i.i25.i2002 = lshr i64 %product.i.i.i24.i2001, 32
  %xored.i.i.i26.i2003 = xor i64 %shifted.i.i.i25.i2002, %product.i.i.i24.i2001
  %hash.i.i.i27.i2004 = and i64 %xored.i.i.i26.i2003, %tbl_size.i.i22.i1999
  %offset_ptr.i.i28.i2005 = getelementptr i32, ptr %offset_tbl.i.i23.i2000, i64 %hash.i.i.i27.i2004
  %offset.i.i43.i2006 = load i32, ptr %offset_ptr.i.i28.i2005, align 4, !noalias !98
  %1289 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1280, 0
  %1290 = insertvalue { ptr, ptr, ptr, i32 } %1289, ptr %1287, 1
  %1291 = insertvalue { ptr, ptr, ptr, i32 } %1290, ptr %1288, 2
  %1292 = insertvalue { ptr, ptr, ptr, i32 } %1291, i32 %offset.i.i43.i2006, 3
  %1293 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %1294 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %991, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %1292) #7
  br label %._crit_edge.i1993

._crit_edge.i1993:                                ; preds = %1283, %1276
  %1295 = add nuw nsw i32 %.060.i1991, 1
  %1296 = icmp slt i32 %1295, %1244
  br i1 %1296, label %1276, label %._crit_edge.i679

._crit_edge.i679:                                 ; preds = %._crit_edge.i1993, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1975.thread, %1241
  %1297 = load ptr, ptr %999, align 8
  %1298 = getelementptr i8, ptr %1297, i64 72
  %1299 = load ptr, ptr %1298, align 8
  %result.i.i.i680 = call { i64, i64 } %1299(ptr nocapture nofree nonnull readonly %999) #5
  %1300 = extractvalue { i64, i64 } %result.i.i.i680, 0
  %1301 = extractvalue { i64, i64 } %result.i.i.i680, 1
  %1302 = urem i64 20, %1301
  %1303 = icmp eq i64 %1302, 0
  %1304 = sub i64 %1301, %1302
  %1305 = select i1 %1303, i64 0, i64 %1304
  %1306 = add i64 %1300, 20
  %1307 = add i64 %1306, %1305
  %1308 = load ptr, ptr %1006, align 8
  %1309 = getelementptr i8, ptr %1308, i64 72
  %1310 = load ptr, ptr %1309, align 8
  %result.i1.i.i681 = call { i64, i64 } %1310(ptr nocapture nofree nonnull readonly %1006) #5
  %1311 = extractvalue { i64, i64 } %result.i1.i.i681, 0
  %1312 = extractvalue { i64, i64 } %result.i1.i.i681, 1
  %1313 = call i64 @llvm.umax.i64(i64 %1301, i64 %1312)
  %1314 = call i64 @llvm.umax.i64(i64 %1313, i64 8)
  %1315 = urem i64 %1307, %1312
  %1316 = icmp eq i64 %1315, 0
  %1317 = sub i64 %1312, %1315
  %1318 = select i1 %1316, i64 0, i64 %1317
  %1319 = add i64 %1311, %1307
  %1320 = add i64 %1319, %1318
  %1321 = urem i64 %1320, %1314
  %1322 = icmp eq i64 %1321, 0
  %1323 = sub i64 %1314, %1321
  %1324 = select i1 %1322, i64 0, i64 %1323
  %1325 = add i64 %1324, %1320
  %result.i83.i682 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1325, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %999, ptr %result.i83.i682, align 8
  %1326 = getelementptr inbounds i8, ptr %result.i83.i682, i64 8
  store ptr %1006, ptr %1326, align 8
  %1327 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i682)
  %1328 = load ptr, ptr %999, align 8
  %1329 = getelementptr i8, ptr %1328, i64 72
  %1330 = load ptr, ptr %1329, align 8
  %result.i.i179.i683 = call { i64, i64 } %1330(ptr nocapture nofree nonnull readonly %999) #5
  %1331 = extractvalue { i64, i64 } %result.i.i179.i683, 1
  %1332 = urem i64 20, %1331
  %1333 = icmp eq i64 %1332, 0
  %reass.sub3115 = sub i64 %1331, %1332
  %1334 = add i64 %reass.sub3115, 20
  %1335 = select i1 %1333, i64 20, i64 %1334
  %1336 = getelementptr i8, ptr %result.i83.i682, i64 %1335
  %1337 = getelementptr i8, ptr %1328, i64 64
  %1338 = load ptr, ptr %1337, align 8
  call void %1338({ ptr, i160 } %997, ptr nocapture nofree nonnull readonly %999, ptr nocapture nofree writeonly %1336) #12
  %1339 = load ptr, ptr %result.i83.i682, align 8
  %1340 = load ptr, ptr %1339, align 8
  %1341 = getelementptr i8, ptr %1340, i64 72
  %1342 = load ptr, ptr %1341, align 8
  %result.i.i180.i685 = call { i64, i64 } %1342(ptr nocapture nofree nonnull readonly %1339) #5
  %1343 = extractvalue { i64, i64 } %result.i.i180.i685, 0
  %1344 = extractvalue { i64, i64 } %result.i.i180.i685, 1
  %1345 = urem i64 20, %1344
  %1346 = icmp eq i64 %1345, 0
  %1347 = sub i64 %1344, %1345
  %1348 = select i1 %1346, i64 0, i64 %1347
  %1349 = add i64 %1343, 20
  %1350 = add i64 %1349, %1348
  %1351 = load ptr, ptr %1326, align 8
  %1352 = load ptr, ptr %1351, align 8
  %1353 = getelementptr i8, ptr %1352, i64 72
  %1354 = load ptr, ptr %1353, align 8
  %result.i1.i181.i686 = call { i64, i64 } %1354(ptr nocapture nofree nonnull readonly %1351) #5
  %1355 = extractvalue { i64, i64 } %result.i1.i181.i686, 1
  %1356 = urem i64 %1350, %1355
  %1357 = icmp eq i64 %1356, 0
  %1358 = sub i64 %1355, %1356
  %1359 = select i1 %1357, i64 0, i64 %1358
  %1360 = getelementptr i8, ptr %result.i83.i682, i64 %1350
  %1361 = getelementptr i8, ptr %1360, i64 %1359
  %1362 = getelementptr i8, ptr %1352, i64 64
  %1363 = load ptr, ptr %1362, align 8
  call void %1363({ ptr, i160 } %998, ptr nocapture nofree nonnull readonly %1351, ptr nocapture nofree writeonly %1361) #12
  %1364 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1365 = getelementptr inbounds i8, ptr %result.i83.i682, i64 16
  store i32 %1001, ptr %1365, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %1366 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1367 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1368 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1369

1369:                                             ; preds = %.cont.cont.i1299, %._crit_edge.i679
  %.0566.i1279 = phi i32 [ 0, %._crit_edge.i679 ], [ %1370, %.cont.cont.i1299 ]
  %.070565.i1280 = phi i1 [ true, %._crit_edge.i679 ], [ %1436, %.cont.cont.i1299 ]
  %.sroa.0.0564.i1281 = phi ptr [ @Entry, %._crit_edge.i679 ], [ %vptr.i142.sroa.speculated.i1302, %.cont.cont.i1299 ]
  %.sroa.6.0563.i1282 = phi ptr [ %result.i83.i682, %._crit_edge.i679 ], [ %spec.select539.i1304, %.cont.cont.i1299 ]
  %.sroa.12.0562.i1283 = phi ptr [ undef, %._crit_edge.i679 ], [ %spec.select.i1303, %.cont.cont.i1299 ]
  %.sroa.17.0561.i1284 = phi i32 [ 10, %._crit_edge.i679 ], [ %offset.i.i154.i1316, %.cont.cont.i1299 ]
  %1370 = add nuw nsw i32 %.0566.i1279, 1
  %1371 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1281, 0
  %1372 = insertvalue { ptr, ptr, ptr, i32 } %1371, ptr %.sroa.6.0563.i1282, 1
  %1373 = insertvalue { ptr, ptr, ptr, i32 } %1372, ptr %.sroa.12.0562.i1283, 2
  %1374 = insertvalue { ptr, ptr, ptr, i32 } %1373, i32 %.sroa.17.0561.i1284, 3
  %1375 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1281)
  %1376 = sext i32 %.sroa.17.0561.i1284 to i64
  %1377 = getelementptr ptr, ptr %.sroa.0.0564.i1281, i64 %1376
  %1378 = getelementptr i8, ptr %1377, i64 64
  %1379 = load ptr, ptr %1378, align 8
  %result.i125.i1285 = call ptr %1379({ ptr, ptr, ptr, i32 } %1374, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1380 = call i32 %result.i125.i1285({ ptr, ptr, ptr, i32 } %1374, { ptr, ptr, ptr, i32 } %1374, ptr nonnull align 8 %2) #7
  %1381 = ptrtoint ptr %.sroa.6.0563.i1282 to i64
  %1382 = ptrtoint ptr %.sroa.12.0562.i1283 to i64
  br i1 %.070565.i1280, label %1383, label %1399

1383:                                             ; preds = %1369
  %1384 = load i32, ptr %34, align 8
  %1385 = add i32 %1384, -1
  %1386 = and i32 %1385, %1380
  %1387 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1388 = load ptr, ptr %35, align 8
  %1389 = sext i32 %1386 to i64
  %1390 = shl nsw i64 %1389, 5
  %1391 = getelementptr i8, ptr %1388, i64 %1390
  %1392 = load ptr, ptr %1391, align 8
  %1393 = getelementptr i8, ptr %1391, i64 8
  %1394 = load i160, ptr %1393, align 4
  store ptr %.sroa.0.0564.i1281, ptr %1391, align 8
  store i64 %1381, ptr %1393, align 4
  %.sroa_idx157.i1328 = getelementptr i8, ptr %1391, i64 16
  store i64 %1382, ptr %.sroa_idx157.i1328, align 4
  %.sroa_idx158.i1329 = getelementptr i8, ptr %1391, i64 24
  store i32 %.sroa.17.0561.i1284, ptr %.sroa_idx158.i1329, align 4
  %1395 = icmp ne ptr %1392, @nil_typ
  %1396 = icmp ne ptr %1392, null
  %.not92.i1330 = and i1 %1395, %1396
  %extract.i1332 = lshr i160 %1394, 64
  %1397 = insertelement <2 x i160> poison, i160 %1394, i64 0
  %1398 = insertelement <2 x i160> %1397, i160 %extract.i1332, i64 1
  br i1 %.not92.i1330, label %.cont.cont.i1299, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1334.thread

1399:                                             ; preds = %1369
  %1400 = add i32 %1380, 2127912214
  %1401 = shl i32 %1380, 12
  %1402 = add i32 %1400, %1401
  %1403 = ashr i32 %1402, 19
  %1404 = xor i32 %1402, %1403
  %1405 = xor i32 %1404, -949894596
  %1406 = add i32 %1405, 374761393
  %1407 = shl i32 %1405, 5
  %1408 = add i32 %1406, %1407
  %1409 = add i32 %1408, -744332180
  %1410 = shl i32 %1408, 9
  %1411 = xor i32 %1409, %1410
  %1412 = add i32 %1411, -42973499
  %1413 = shl i32 %1411, 3
  %1414 = add i32 %1412, %1413
  %1415 = ashr i32 %1414, 16
  %1416 = xor i32 %1414, %1415
  %1417 = xor i32 %1416, -1252372727
  %1418 = load i32, ptr %34, align 8
  %1419 = add i32 %1418, -1
  %1420 = and i32 %1419, %1417
  %1421 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1422 = load ptr, ptr %36, align 8
  %1423 = sext i32 %1420 to i64
  %1424 = shl nsw i64 %1423, 5
  %1425 = getelementptr i8, ptr %1422, i64 %1424
  %1426 = load ptr, ptr %1425, align 8
  %1427 = getelementptr i8, ptr %1425, i64 8
  %1428 = load i160, ptr %1427, align 4
  store ptr %.sroa.0.0564.i1281, ptr %1425, align 8
  store i64 %1381, ptr %1427, align 4
  %.sroa_idx161.i1289 = getelementptr i8, ptr %1425, i64 16
  store i64 %1382, ptr %.sroa_idx161.i1289, align 4
  %.sroa_idx162.i1290 = getelementptr i8, ptr %1425, i64 24
  store i32 %.sroa.17.0561.i1284, ptr %.sroa_idx162.i1290, align 4
  %1429 = icmp ne ptr %1426, @nil_typ
  %1430 = icmp ne ptr %1426, null
  %.not90.i1291 = and i1 %1429, %1430
  %extract607.i1293 = lshr i160 %1428, 64
  %1431 = insertelement <2 x i160> poison, i160 %1428, i64 0
  %1432 = insertelement <2 x i160> %1431, i160 %extract607.i1293, i64 1
  br i1 %.not90.i1291, label %.cont.cont.i1299, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1334.thread

.cont.cont.i1299:                                 ; preds = %1399, %1383
  %vptr.i142.sroa.speculated.i1302 = phi ptr [ %1392, %1383 ], [ %1426, %1399 ]
  %.in3122 = phi <2 x i160> [ %1398, %1383 ], [ %1432, %1399 ]
  %1433 = trunc <2 x i160> %.in3122 to <2 x i64>
  %1434 = extractelement <2 x i64> %1433, i64 1
  %spec.select.i1303 = inttoptr i64 %1434 to ptr
  %1435 = extractelement <2 x i64> %1433, i64 0
  %spec.select539.i1304 = inttoptr i64 %1435 to ptr
  %1436 = xor i1 %.070565.i1280, true
  %hash_coef_ptr.i.i143.i1305 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1302, i64 8
  %tbl_size_ptr.i.i144.i1306 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1302, i64 16
  %offset_tbl_ptr.i.i145.i1307 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1302, i64 40
  %hash_coef.i.i146.i1308 = load i64, ptr %hash_coef_ptr.i.i143.i1305, align 4
  %tbl_size.i.i147.i1309 = load i64, ptr %tbl_size_ptr.i.i144.i1306, align 4
  %offset_tbl.i.i148.i1310 = load ptr, ptr %offset_tbl_ptr.i.i145.i1307, align 8
  %product.i.i.i149.i1311 = mul i64 %hash_coef.i.i146.i1308, 4015701072841558310
  %shifted.i.i.i150.i1312 = lshr i64 %product.i.i.i149.i1311, 32
  %xored.i.i.i151.i1313 = xor i64 %shifted.i.i.i150.i1312, %product.i.i.i149.i1311
  %hash.i.i.i152.i1314 = and i64 %xored.i.i.i151.i1313, %tbl_size.i.i147.i1309
  %offset_ptr.i.i153.i1315 = getelementptr i32, ptr %offset_tbl.i.i148.i1310, i64 %hash.i.i.i152.i1314
  %offset.i.i154.i1316 = load i32, ptr %offset_ptr.i.i153.i1315, align 4
  %1437 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1438 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1439 = icmp ult i32 %.0566.i1279, 99
  br i1 %1439, label %1369, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1334

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1334.thread: ; preds = %1383, %1399
  %1440 = phi ptr [ %22, %1399 ], [ %21, %1383 ]
  %1441 = load i32, ptr %988, align 4
  store i32 %1441, ptr %1440, align 4
  %1442 = add i32 %1441, 1
  %1443 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1442, ptr %988, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %HashMap_insert_keyK_valueV.exit713

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1334: ; preds = %.cont.cont.i1299
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  %1444 = icmp eq ptr %vptr.i142.sroa.speculated.i1302, null
  br i1 %1444, label %HashMap_insert_keyK_valueV.exit713, label %1445

1445:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1334
  %1446 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1447 = load ptr, ptr %35, align 8
  %1448 = load ptr, ptr %36, align 8
  %1449 = load i32, ptr %34, align 8
  %1450 = shl i32 %1449, 1
  %spec.select.i1350 = call i32 @llvm.smax.i32(i32 %1450, i32 16)
  store i32 %spec.select.i1350, ptr %34, align 8
  %1451 = zext nneg i32 %spec.select.i1350 to i64
  %1452 = shl nuw nsw i64 %1451, 5
  %result.i.i1351 = call noalias ptr @bump_malloc_inner(i64 noundef %1452, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1351, ptr %35, align 8
  %result.i20.i1352 = call noalias ptr @bump_malloc_inner(i64 noundef %1452, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1352, ptr %36, align 8
  store i32 0, ptr %988, align 4
  %1453 = icmp sgt i32 %1449, 0
  br i1 %1453, label %.lr.ph.i2041, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110

.lr.ph.i2041:                                     ; preds = %1445, %._crit_edge.i2056
  %.060.i2054 = phi i32 [ %1542, %._crit_edge.i2056 ], [ 0, %1445 ]
  %1454 = zext nneg i32 %.060.i2054 to i64
  %1455 = shl nuw nsw i64 %1454, 5
  %1456 = getelementptr i8, ptr %1447, i64 %1455
  %1457 = load ptr, ptr %1456, align 8
  %1458 = icmp ne ptr %1457, @nil_typ
  %1459 = icmp ne ptr %1457, null
  %.not16.i2055 = and i1 %1458, %1459
  br i1 %.not16.i2055, label %1460, label %._crit_edge.i2056

1460:                                             ; preds = %.lr.ph.i2041
  %1461 = getelementptr i8, ptr %1456, i64 8
  %1462 = load <2 x i64>, ptr %1461, align 4
  %hash_coef_ptr.i.i18.i2058 = getelementptr i8, ptr %1457, i64 8
  %tbl_size_ptr.i.i19.i2059 = getelementptr i8, ptr %1457, i64 16
  %offset_tbl_ptr.i.i20.i2060 = getelementptr i8, ptr %1457, i64 40
  %1463 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i2536 = load i64, ptr %hash_coef_ptr.i.i18.i2058, align 4, !noalias !22
  %tbl_size.i.i100.i2537 = load i64, ptr %tbl_size_ptr.i.i19.i2059, align 4, !noalias !22
  %offset_tbl.i.i101.i2538 = load ptr, ptr %offset_tbl_ptr.i.i20.i2060, align 8, !noalias !22
  %product.i.i.i102.i2539 = mul i64 %hash_coef.i.i99.i2536, 4015701072841558310
  %shifted.i.i.i103.i2540 = lshr i64 %product.i.i.i102.i2539, 32
  %xored.i.i.i104.i2541 = xor i64 %shifted.i.i.i103.i2540, %product.i.i.i102.i2539
  %hash.i.i.i105.i2542 = and i64 %xored.i.i.i104.i2541, %tbl_size.i.i100.i2537
  %offset_ptr.i.i106.i2543 = getelementptr i32, ptr %offset_tbl.i.i101.i2538, i64 %hash.i.i.i105.i2542
  %offset.i.i121.i2544 = load i32, ptr %offset_ptr.i.i106.i2543, align 4, !noalias !101
  %1464 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1465 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1466 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1467

1467:                                             ; preds = %.cont.cont.i2565, %1460
  %.0566.i2545 = phi i32 [ 0, %1460 ], [ %1471, %.cont.cont.i2565 ]
  %.070565.i2546 = phi i1 [ true, %1460 ], [ %1533, %.cont.cont.i2565 ]
  %.sroa.0.0564.i2547 = phi ptr [ %1457, %1460 ], [ %vptr.i142.sroa.speculated.i2568, %.cont.cont.i2565 ]
  %.sroa.17.0561.i2550 = phi i32 [ %offset.i.i121.i2544, %1460 ], [ %offset.i.i154.i2582, %.cont.cont.i2565 ]
  %1468 = phi <2 x i64> [ %1462, %1460 ], [ %1532, %.cont.cont.i2565 ]
  %1469 = extractelement <2 x i64> %1468, i64 1
  %.sroa.12.0562.i2549 = inttoptr i64 %1469 to ptr
  %1470 = extractelement <2 x i64> %1468, i64 0
  %.sroa.6.0563.i2548 = inttoptr i64 %1470 to ptr
  %1471 = add nuw nsw i32 %.0566.i2545, 1
  %1472 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2547, 0
  %1473 = insertvalue { ptr, ptr, ptr, i32 } %1472, ptr %.sroa.6.0563.i2548, 1
  %1474 = insertvalue { ptr, ptr, ptr, i32 } %1473, ptr %.sroa.12.0562.i2549, 2
  %1475 = insertvalue { ptr, ptr, ptr, i32 } %1474, i32 %.sroa.17.0561.i2550, 3
  %1476 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2547)
  %1477 = sext i32 %.sroa.17.0561.i2550 to i64
  %1478 = getelementptr ptr, ptr %.sroa.0.0564.i2547, i64 %1477
  %1479 = getelementptr i8, ptr %1478, i64 64
  %1480 = load ptr, ptr %1479, align 8
  %result.i125.i2551 = call ptr %1480({ ptr, ptr, ptr, i32 } %1475, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1481 = call i32 %result.i125.i2551({ ptr, ptr, ptr, i32 } %1475, { ptr, ptr, ptr, i32 } %1475, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2546, label %1482, label %1498

1482:                                             ; preds = %1467
  %1483 = load i32, ptr %34, align 8
  %1484 = add i32 %1483, -1
  %1485 = and i32 %1484, %1481
  %1486 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1487 = load ptr, ptr %35, align 8
  %1488 = sext i32 %1485 to i64
  %1489 = shl nsw i64 %1488, 5
  %1490 = getelementptr i8, ptr %1487, i64 %1489
  %1491 = load ptr, ptr %1490, align 8
  %1492 = getelementptr i8, ptr %1490, i64 8
  %1493 = load i160, ptr %1492, align 4
  store ptr %.sroa.0.0564.i2547, ptr %1490, align 8
  store i64 %1470, ptr %1492, align 4
  %.sroa_idx157.i2594 = getelementptr i8, ptr %1490, i64 16
  store i64 %1469, ptr %.sroa_idx157.i2594, align 4
  %.sroa_idx158.i2595 = getelementptr i8, ptr %1490, i64 24
  store i32 %.sroa.17.0561.i2550, ptr %.sroa_idx158.i2595, align 4
  %1494 = icmp ne ptr %1491, @nil_typ
  %1495 = icmp ne ptr %1491, null
  %.not92.i2596 = and i1 %1494, %1495
  %extract.i2598 = lshr i160 %1493, 64
  %1496 = insertelement <2 x i160> poison, i160 %1493, i64 0
  %1497 = insertelement <2 x i160> %1496, i160 %extract.i2598, i64 1
  br i1 %.not92.i2596, label %.cont.cont.i2565, label %1537

1498:                                             ; preds = %1467
  %1499 = add i32 %1481, 2127912214
  %1500 = shl i32 %1481, 12
  %1501 = add i32 %1499, %1500
  %1502 = ashr i32 %1501, 19
  %1503 = xor i32 %1501, %1502
  %1504 = xor i32 %1503, -949894596
  %1505 = add i32 %1504, 374761393
  %1506 = shl i32 %1504, 5
  %1507 = add i32 %1505, %1506
  %1508 = add i32 %1507, -744332180
  %1509 = shl i32 %1507, 9
  %1510 = xor i32 %1508, %1509
  %1511 = add i32 %1510, -42973499
  %1512 = shl i32 %1510, 3
  %1513 = add i32 %1511, %1512
  %1514 = ashr i32 %1513, 16
  %1515 = xor i32 %1513, %1514
  %1516 = xor i32 %1515, -1252372727
  %1517 = load i32, ptr %34, align 8
  %1518 = add i32 %1517, -1
  %1519 = and i32 %1518, %1516
  %1520 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1521 = load ptr, ptr %36, align 8
  %1522 = sext i32 %1519 to i64
  %1523 = shl nsw i64 %1522, 5
  %1524 = getelementptr i8, ptr %1521, i64 %1523
  %1525 = load ptr, ptr %1524, align 8
  %1526 = getelementptr i8, ptr %1524, i64 8
  %1527 = load i160, ptr %1526, align 4
  store ptr %.sroa.0.0564.i2547, ptr %1524, align 8
  store i64 %1470, ptr %1526, align 4
  %.sroa_idx161.i2555 = getelementptr i8, ptr %1524, i64 16
  store i64 %1469, ptr %.sroa_idx161.i2555, align 4
  %.sroa_idx162.i2556 = getelementptr i8, ptr %1524, i64 24
  store i32 %.sroa.17.0561.i2550, ptr %.sroa_idx162.i2556, align 4
  %1528 = icmp ne ptr %1525, @nil_typ
  %1529 = icmp ne ptr %1525, null
  %.not90.i2557 = and i1 %1528, %1529
  %extract607.i2559 = lshr i160 %1527, 64
  %1530 = insertelement <2 x i160> poison, i160 %1527, i64 0
  %1531 = insertelement <2 x i160> %1530, i160 %extract607.i2559, i64 1
  br i1 %.not90.i2557, label %.cont.cont.i2565, label %1537

.cont.cont.i2565:                                 ; preds = %1498, %1482
  %vptr.i142.sroa.speculated.i2568 = phi ptr [ %1491, %1482 ], [ %1525, %1498 ]
  %.in3123 = phi <2 x i160> [ %1497, %1482 ], [ %1531, %1498 ]
  %1532 = trunc <2 x i160> %.in3123 to <2 x i64>
  %1533 = xor i1 %.070565.i2546, true
  %hash_coef_ptr.i.i143.i2571 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2568, i64 8
  %tbl_size_ptr.i.i144.i2572 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2568, i64 16
  %offset_tbl_ptr.i.i145.i2573 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2568, i64 40
  %hash_coef.i.i146.i2574 = load i64, ptr %hash_coef_ptr.i.i143.i2571, align 4
  %tbl_size.i.i147.i2575 = load i64, ptr %tbl_size_ptr.i.i144.i2572, align 4
  %offset_tbl.i.i148.i2576 = load ptr, ptr %offset_tbl_ptr.i.i145.i2573, align 8
  %product.i.i.i149.i2577 = mul i64 %hash_coef.i.i146.i2574, 4015701072841558310
  %shifted.i.i.i150.i2578 = lshr i64 %product.i.i.i149.i2577, 32
  %xored.i.i.i151.i2579 = xor i64 %shifted.i.i.i150.i2578, %product.i.i.i149.i2577
  %hash.i.i.i152.i2580 = and i64 %xored.i.i.i151.i2579, %tbl_size.i.i147.i2575
  %offset_ptr.i.i153.i2581 = getelementptr i32, ptr %offset_tbl.i.i148.i2576, i64 %hash.i.i.i152.i2580
  %offset.i.i154.i2582 = load i32, ptr %offset_ptr.i.i153.i2581, align 4
  %1534 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1535 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1536 = icmp ult i32 %.0566.i2545, 99
  br i1 %1536, label %1467, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2600

1537:                                             ; preds = %1498, %1482
  %1538 = phi ptr [ %10, %1498 ], [ %9, %1482 ]
  %1539 = load i32, ptr %988, align 4
  store i32 %1539, ptr %1538, align 4
  %1540 = add i32 %1539, 1
  %1541 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1540, ptr %988, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2600

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2600: ; preds = %.cont.cont.i2565, %1537
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i2056

._crit_edge.i2056:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2600, %.lr.ph.i2041
  %1542 = add nuw nsw i32 %.060.i2054, 1
  %1543 = icmp slt i32 %1542, %1449
  br i1 %1543, label %.lr.ph.i2041, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2074

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2074: ; preds = %._crit_edge.i2056, %._crit_edge.i2092
  %.060.i2090 = phi i32 [ %1632, %._crit_edge.i2092 ], [ 0, %._crit_edge.i2056 ]
  %1544 = zext nneg i32 %.060.i2090 to i64
  %1545 = shl nuw nsw i64 %1544, 5
  %1546 = getelementptr i8, ptr %1448, i64 %1545
  %1547 = load ptr, ptr %1546, align 8
  %1548 = icmp ne ptr %1547, @nil_typ
  %1549 = icmp ne ptr %1547, null
  %.not16.i2091 = and i1 %1548, %1549
  br i1 %.not16.i2091, label %1550, label %._crit_edge.i2092

1550:                                             ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2074
  %1551 = getelementptr i8, ptr %1546, i64 8
  %1552 = load <2 x i64>, ptr %1551, align 4
  %hash_coef_ptr.i.i18.i2094 = getelementptr i8, ptr %1547, i64 8
  %tbl_size_ptr.i.i19.i2095 = getelementptr i8, ptr %1547, i64 16
  %offset_tbl_ptr.i.i20.i2096 = getelementptr i8, ptr %1547, i64 40
  %1553 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i2618 = load i64, ptr %hash_coef_ptr.i.i18.i2094, align 4, !noalias !22
  %tbl_size.i.i100.i2619 = load i64, ptr %tbl_size_ptr.i.i19.i2095, align 4, !noalias !22
  %offset_tbl.i.i101.i2620 = load ptr, ptr %offset_tbl_ptr.i.i20.i2096, align 8, !noalias !22
  %product.i.i.i102.i2621 = mul i64 %hash_coef.i.i99.i2618, 4015701072841558310
  %shifted.i.i.i103.i2622 = lshr i64 %product.i.i.i102.i2621, 32
  %xored.i.i.i104.i2623 = xor i64 %shifted.i.i.i103.i2622, %product.i.i.i102.i2621
  %hash.i.i.i105.i2624 = and i64 %xored.i.i.i104.i2623, %tbl_size.i.i100.i2619
  %offset_ptr.i.i106.i2625 = getelementptr i32, ptr %offset_tbl.i.i101.i2620, i64 %hash.i.i.i105.i2624
  %offset.i.i121.i2626 = load i32, ptr %offset_ptr.i.i106.i2625, align 4, !noalias !104
  %1554 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1555 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1556 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1557

1557:                                             ; preds = %.cont.cont.i2647, %1550
  %.0566.i2627 = phi i32 [ 0, %1550 ], [ %1561, %.cont.cont.i2647 ]
  %.070565.i2628 = phi i1 [ true, %1550 ], [ %1623, %.cont.cont.i2647 ]
  %.sroa.0.0564.i2629 = phi ptr [ %1547, %1550 ], [ %vptr.i142.sroa.speculated.i2650, %.cont.cont.i2647 ]
  %.sroa.17.0561.i2632 = phi i32 [ %offset.i.i121.i2626, %1550 ], [ %offset.i.i154.i2664, %.cont.cont.i2647 ]
  %1558 = phi <2 x i64> [ %1552, %1550 ], [ %1622, %.cont.cont.i2647 ]
  %1559 = extractelement <2 x i64> %1558, i64 1
  %.sroa.12.0562.i2631 = inttoptr i64 %1559 to ptr
  %1560 = extractelement <2 x i64> %1558, i64 0
  %.sroa.6.0563.i2630 = inttoptr i64 %1560 to ptr
  %1561 = add nuw nsw i32 %.0566.i2627, 1
  %1562 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2629, 0
  %1563 = insertvalue { ptr, ptr, ptr, i32 } %1562, ptr %.sroa.6.0563.i2630, 1
  %1564 = insertvalue { ptr, ptr, ptr, i32 } %1563, ptr %.sroa.12.0562.i2631, 2
  %1565 = insertvalue { ptr, ptr, ptr, i32 } %1564, i32 %.sroa.17.0561.i2632, 3
  %1566 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2629)
  %1567 = sext i32 %.sroa.17.0561.i2632 to i64
  %1568 = getelementptr ptr, ptr %.sroa.0.0564.i2629, i64 %1567
  %1569 = getelementptr i8, ptr %1568, i64 64
  %1570 = load ptr, ptr %1569, align 8
  %result.i125.i2633 = call ptr %1570({ ptr, ptr, ptr, i32 } %1565, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1571 = call i32 %result.i125.i2633({ ptr, ptr, ptr, i32 } %1565, { ptr, ptr, ptr, i32 } %1565, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2628, label %1572, label %1588

1572:                                             ; preds = %1557
  %1573 = load i32, ptr %34, align 8
  %1574 = add i32 %1573, -1
  %1575 = and i32 %1574, %1571
  %1576 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1577 = load ptr, ptr %35, align 8
  %1578 = sext i32 %1575 to i64
  %1579 = shl nsw i64 %1578, 5
  %1580 = getelementptr i8, ptr %1577, i64 %1579
  %1581 = load ptr, ptr %1580, align 8
  %1582 = getelementptr i8, ptr %1580, i64 8
  %1583 = load i160, ptr %1582, align 4
  store ptr %.sroa.0.0564.i2629, ptr %1580, align 8
  store i64 %1560, ptr %1582, align 4
  %.sroa_idx157.i2676 = getelementptr i8, ptr %1580, i64 16
  store i64 %1559, ptr %.sroa_idx157.i2676, align 4
  %.sroa_idx158.i2677 = getelementptr i8, ptr %1580, i64 24
  store i32 %.sroa.17.0561.i2632, ptr %.sroa_idx158.i2677, align 4
  %1584 = icmp ne ptr %1581, @nil_typ
  %1585 = icmp ne ptr %1581, null
  %.not92.i2678 = and i1 %1584, %1585
  %extract.i2680 = lshr i160 %1583, 64
  %1586 = insertelement <2 x i160> poison, i160 %1583, i64 0
  %1587 = insertelement <2 x i160> %1586, i160 %extract.i2680, i64 1
  br i1 %.not92.i2678, label %.cont.cont.i2647, label %1627

1588:                                             ; preds = %1557
  %1589 = add i32 %1571, 2127912214
  %1590 = shl i32 %1571, 12
  %1591 = add i32 %1589, %1590
  %1592 = ashr i32 %1591, 19
  %1593 = xor i32 %1591, %1592
  %1594 = xor i32 %1593, -949894596
  %1595 = add i32 %1594, 374761393
  %1596 = shl i32 %1594, 5
  %1597 = add i32 %1595, %1596
  %1598 = add i32 %1597, -744332180
  %1599 = shl i32 %1597, 9
  %1600 = xor i32 %1598, %1599
  %1601 = add i32 %1600, -42973499
  %1602 = shl i32 %1600, 3
  %1603 = add i32 %1601, %1602
  %1604 = ashr i32 %1603, 16
  %1605 = xor i32 %1603, %1604
  %1606 = xor i32 %1605, -1252372727
  %1607 = load i32, ptr %34, align 8
  %1608 = add i32 %1607, -1
  %1609 = and i32 %1608, %1606
  %1610 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1611 = load ptr, ptr %36, align 8
  %1612 = sext i32 %1609 to i64
  %1613 = shl nsw i64 %1612, 5
  %1614 = getelementptr i8, ptr %1611, i64 %1613
  %1615 = load ptr, ptr %1614, align 8
  %1616 = getelementptr i8, ptr %1614, i64 8
  %1617 = load i160, ptr %1616, align 4
  store ptr %.sroa.0.0564.i2629, ptr %1614, align 8
  store i64 %1560, ptr %1616, align 4
  %.sroa_idx161.i2637 = getelementptr i8, ptr %1614, i64 16
  store i64 %1559, ptr %.sroa_idx161.i2637, align 4
  %.sroa_idx162.i2638 = getelementptr i8, ptr %1614, i64 24
  store i32 %.sroa.17.0561.i2632, ptr %.sroa_idx162.i2638, align 4
  %1618 = icmp ne ptr %1615, @nil_typ
  %1619 = icmp ne ptr %1615, null
  %.not90.i2639 = and i1 %1618, %1619
  %extract607.i2641 = lshr i160 %1617, 64
  %1620 = insertelement <2 x i160> poison, i160 %1617, i64 0
  %1621 = insertelement <2 x i160> %1620, i160 %extract607.i2641, i64 1
  br i1 %.not90.i2639, label %.cont.cont.i2647, label %1627

.cont.cont.i2647:                                 ; preds = %1588, %1572
  %vptr.i142.sroa.speculated.i2650 = phi ptr [ %1581, %1572 ], [ %1615, %1588 ]
  %.in3124 = phi <2 x i160> [ %1587, %1572 ], [ %1621, %1588 ]
  %1622 = trunc <2 x i160> %.in3124 to <2 x i64>
  %1623 = xor i1 %.070565.i2628, true
  %hash_coef_ptr.i.i143.i2653 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2650, i64 8
  %tbl_size_ptr.i.i144.i2654 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2650, i64 16
  %offset_tbl_ptr.i.i145.i2655 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2650, i64 40
  %hash_coef.i.i146.i2656 = load i64, ptr %hash_coef_ptr.i.i143.i2653, align 4
  %tbl_size.i.i147.i2657 = load i64, ptr %tbl_size_ptr.i.i144.i2654, align 4
  %offset_tbl.i.i148.i2658 = load ptr, ptr %offset_tbl_ptr.i.i145.i2655, align 8
  %product.i.i.i149.i2659 = mul i64 %hash_coef.i.i146.i2656, 4015701072841558310
  %shifted.i.i.i150.i2660 = lshr i64 %product.i.i.i149.i2659, 32
  %xored.i.i.i151.i2661 = xor i64 %shifted.i.i.i150.i2660, %product.i.i.i149.i2659
  %hash.i.i.i152.i2662 = and i64 %xored.i.i.i151.i2661, %tbl_size.i.i147.i2657
  %offset_ptr.i.i153.i2663 = getelementptr i32, ptr %offset_tbl.i.i148.i2658, i64 %hash.i.i.i152.i2662
  %offset.i.i154.i2664 = load i32, ptr %offset_ptr.i.i153.i2663, align 4
  %1624 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1625 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1626 = icmp ult i32 %.0566.i2627, 99
  br i1 %1626, label %1557, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2682

1627:                                             ; preds = %1588, %1572
  %1628 = phi ptr [ %8, %1588 ], [ %7, %1572 ]
  %1629 = load i32, ptr %988, align 4
  store i32 %1629, ptr %1628, align 4
  %1630 = add i32 %1629, 1
  %1631 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1630, ptr %988, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2682

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2682: ; preds = %.cont.cont.i2647, %1627
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i2092

._crit_edge.i2092:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2682, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2074
  %1632 = add nuw nsw i32 %.060.i2090, 1
  %1633 = icmp slt i32 %1632, %1449
  br i1 %1633, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2074, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110: ; preds = %._crit_edge.i2092, %1445
  %1634 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i1373 = load i64, ptr %hash_coef_ptr.i.i143.i1305, align 4, !noalias !22
  %tbl_size.i.i100.i1374 = load i64, ptr %tbl_size_ptr.i.i144.i1306, align 4, !noalias !22
  %offset_tbl.i.i101.i1375 = load ptr, ptr %offset_tbl_ptr.i.i145.i1307, align 8, !noalias !22
  %product.i.i.i102.i1376 = mul i64 %hash_coef.i.i99.i1373, 4015701072841558310
  %shifted.i.i.i103.i1377 = lshr i64 %product.i.i.i102.i1376, 32
  %xored.i.i.i104.i1378 = xor i64 %shifted.i.i.i103.i1377, %product.i.i.i102.i1376
  %hash.i.i.i105.i1379 = and i64 %xored.i.i.i104.i1378, %tbl_size.i.i100.i1374
  %offset_ptr.i.i106.i1380 = getelementptr i32, ptr %offset_tbl.i.i101.i1375, i64 %hash.i.i.i105.i1379
  %offset.i.i121.i1381 = load i32, ptr %offset_ptr.i.i106.i1380, align 4, !noalias !107
  %1635 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1636 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1637 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1638

1638:                                             ; preds = %.cont.cont.i1403, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110
  %.0566.i1383 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110 ], [ %1642, %.cont.cont.i1403 ]
  %.070565.i1384 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110 ], [ %1704, %.cont.cont.i1403 ]
  %.sroa.0.0564.i1385 = phi ptr [ %vptr.i142.sroa.speculated.i1302, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110 ], [ %vptr.i142.sroa.speculated.i1406, %.cont.cont.i1403 ]
  %.sroa.17.0561.i1388 = phi i32 [ %offset.i.i121.i1381, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110 ], [ %offset.i.i154.i1420, %.cont.cont.i1403 ]
  %1639 = phi <2 x i64> [ %1433, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2110 ], [ %1703, %.cont.cont.i1403 ]
  %1640 = extractelement <2 x i64> %1639, i64 1
  %.sroa.12.0562.i1387 = inttoptr i64 %1640 to ptr
  %1641 = extractelement <2 x i64> %1639, i64 0
  %.sroa.6.0563.i1386 = inttoptr i64 %1641 to ptr
  %1642 = add nuw nsw i32 %.0566.i1383, 1
  %1643 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1385, 0
  %1644 = insertvalue { ptr, ptr, ptr, i32 } %1643, ptr %.sroa.6.0563.i1386, 1
  %1645 = insertvalue { ptr, ptr, ptr, i32 } %1644, ptr %.sroa.12.0562.i1387, 2
  %1646 = insertvalue { ptr, ptr, ptr, i32 } %1645, i32 %.sroa.17.0561.i1388, 3
  %1647 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1385)
  %1648 = sext i32 %.sroa.17.0561.i1388 to i64
  %1649 = getelementptr ptr, ptr %.sroa.0.0564.i1385, i64 %1648
  %1650 = getelementptr i8, ptr %1649, i64 64
  %1651 = load ptr, ptr %1650, align 8
  %result.i125.i1389 = call ptr %1651({ ptr, ptr, ptr, i32 } %1646, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1652 = call i32 %result.i125.i1389({ ptr, ptr, ptr, i32 } %1646, { ptr, ptr, ptr, i32 } %1646, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1384, label %1653, label %1669

1653:                                             ; preds = %1638
  %1654 = load i32, ptr %34, align 8
  %1655 = add i32 %1654, -1
  %1656 = and i32 %1655, %1652
  %1657 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1658 = load ptr, ptr %35, align 8
  %1659 = sext i32 %1656 to i64
  %1660 = shl nsw i64 %1659, 5
  %1661 = getelementptr i8, ptr %1658, i64 %1660
  %1662 = load ptr, ptr %1661, align 8
  %1663 = getelementptr i8, ptr %1661, i64 8
  %1664 = load i160, ptr %1663, align 4
  store ptr %.sroa.0.0564.i1385, ptr %1661, align 8
  store i64 %1641, ptr %1663, align 4
  %.sroa_idx157.i1432 = getelementptr i8, ptr %1661, i64 16
  store i64 %1640, ptr %.sroa_idx157.i1432, align 4
  %.sroa_idx158.i1433 = getelementptr i8, ptr %1661, i64 24
  store i32 %.sroa.17.0561.i1388, ptr %.sroa_idx158.i1433, align 4
  %1665 = icmp ne ptr %1662, @nil_typ
  %1666 = icmp ne ptr %1662, null
  %.not92.i1434 = and i1 %1665, %1666
  %extract.i1436 = lshr i160 %1664, 64
  %1667 = insertelement <2 x i160> poison, i160 %1664, i64 0
  %1668 = insertelement <2 x i160> %1667, i160 %extract.i1436, i64 1
  br i1 %.not92.i1434, label %.cont.cont.i1403, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1438.thread

1669:                                             ; preds = %1638
  %1670 = add i32 %1652, 2127912214
  %1671 = shl i32 %1652, 12
  %1672 = add i32 %1670, %1671
  %1673 = ashr i32 %1672, 19
  %1674 = xor i32 %1672, %1673
  %1675 = xor i32 %1674, -949894596
  %1676 = add i32 %1675, 374761393
  %1677 = shl i32 %1675, 5
  %1678 = add i32 %1676, %1677
  %1679 = add i32 %1678, -744332180
  %1680 = shl i32 %1678, 9
  %1681 = xor i32 %1679, %1680
  %1682 = add i32 %1681, -42973499
  %1683 = shl i32 %1681, 3
  %1684 = add i32 %1682, %1683
  %1685 = ashr i32 %1684, 16
  %1686 = xor i32 %1684, %1685
  %1687 = xor i32 %1686, -1252372727
  %1688 = load i32, ptr %34, align 8
  %1689 = add i32 %1688, -1
  %1690 = and i32 %1689, %1687
  %1691 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1692 = load ptr, ptr %36, align 8
  %1693 = sext i32 %1690 to i64
  %1694 = shl nsw i64 %1693, 5
  %1695 = getelementptr i8, ptr %1692, i64 %1694
  %1696 = load ptr, ptr %1695, align 8
  %1697 = getelementptr i8, ptr %1695, i64 8
  %1698 = load i160, ptr %1697, align 4
  store ptr %.sroa.0.0564.i1385, ptr %1695, align 8
  store i64 %1641, ptr %1697, align 4
  %.sroa_idx161.i1393 = getelementptr i8, ptr %1695, i64 16
  store i64 %1640, ptr %.sroa_idx161.i1393, align 4
  %.sroa_idx162.i1394 = getelementptr i8, ptr %1695, i64 24
  store i32 %.sroa.17.0561.i1388, ptr %.sroa_idx162.i1394, align 4
  %1699 = icmp ne ptr %1696, @nil_typ
  %1700 = icmp ne ptr %1696, null
  %.not90.i1395 = and i1 %1699, %1700
  %extract607.i1397 = lshr i160 %1698, 64
  %1701 = insertelement <2 x i160> poison, i160 %1698, i64 0
  %1702 = insertelement <2 x i160> %1701, i160 %extract607.i1397, i64 1
  br i1 %.not90.i1395, label %.cont.cont.i1403, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1438.thread

.cont.cont.i1403:                                 ; preds = %1669, %1653
  %vptr.i142.sroa.speculated.i1406 = phi ptr [ %1662, %1653 ], [ %1696, %1669 ]
  %.in3125 = phi <2 x i160> [ %1668, %1653 ], [ %1702, %1669 ]
  %1703 = trunc <2 x i160> %.in3125 to <2 x i64>
  %1704 = xor i1 %.070565.i1384, true
  %hash_coef_ptr.i.i143.i1409 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1406, i64 8
  %tbl_size_ptr.i.i144.i1410 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1406, i64 16
  %offset_tbl_ptr.i.i145.i1411 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1406, i64 40
  %hash_coef.i.i146.i1412 = load i64, ptr %hash_coef_ptr.i.i143.i1409, align 4
  %tbl_size.i.i147.i1413 = load i64, ptr %tbl_size_ptr.i.i144.i1410, align 4
  %offset_tbl.i.i148.i1414 = load ptr, ptr %offset_tbl_ptr.i.i145.i1411, align 8
  %product.i.i.i149.i1415 = mul i64 %hash_coef.i.i146.i1412, 4015701072841558310
  %shifted.i.i.i150.i1416 = lshr i64 %product.i.i.i149.i1415, 32
  %xored.i.i.i151.i1417 = xor i64 %shifted.i.i.i150.i1416, %product.i.i.i149.i1415
  %hash.i.i.i152.i1418 = and i64 %xored.i.i.i151.i1417, %tbl_size.i.i147.i1413
  %offset_ptr.i.i153.i1419 = getelementptr i32, ptr %offset_tbl.i.i148.i1414, i64 %hash.i.i.i152.i1418
  %offset.i.i154.i1420 = load i32, ptr %offset_ptr.i.i153.i1419, align 4
  %1705 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1706 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1707 = icmp ult i32 %.0566.i1383, 99
  br i1 %1707, label %1638, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1438

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1438.thread: ; preds = %1653, %1669
  %1708 = phi ptr [ %20, %1669 ], [ %19, %1653 ]
  %1709 = load i32, ptr %988, align 4
  store i32 %1709, ptr %1708, align 4
  %1710 = add i32 %1709, 1
  %1711 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1710, ptr %988, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %HashMap_insert_keyK_valueV.exit713

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1438: ; preds = %.cont.cont.i1403
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  %1712 = icmp eq ptr %vptr.i142.sroa.speculated.i1406, null
  br i1 %1712, label %HashMap_insert_keyK_valueV.exit713, label %1713

1713:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1438
  %1714 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1715 = load ptr, ptr %35, align 8
  %1716 = load ptr, ptr %36, align 8
  %1717 = load i32, ptr %34, align 8
  %1718 = shl i32 %1717, 1
  %spec.select.i1454 = call i32 @llvm.smax.i32(i32 %1718, i32 16)
  store i32 %spec.select.i1454, ptr %34, align 8
  %1719 = zext nneg i32 %spec.select.i1454 to i64
  %1720 = shl nuw nsw i64 %1719, 5
  %result.i.i1455 = call noalias ptr @bump_malloc_inner(i64 noundef %1720, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1455, ptr %35, align 8
  %result.i20.i1456 = call noalias ptr @bump_malloc_inner(i64 noundef %1720, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1456, ptr %36, align 8
  store i32 0, ptr %988, align 4
  %1721 = icmp sgt i32 %1717, 0
  br i1 %1721, label %.lr.ph.i2140, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2173.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2173.thread: ; preds = %1713
  %1722 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit713

.lr.ph.i2140:                                     ; preds = %1713, %._crit_edge.i2155
  %.060.i2153 = phi i32 [ %1811, %._crit_edge.i2155 ], [ 0, %1713 ]
  %1723 = zext nneg i32 %.060.i2153 to i64
  %1724 = shl nuw nsw i64 %1723, 5
  %1725 = getelementptr i8, ptr %1715, i64 %1724
  %1726 = load ptr, ptr %1725, align 8
  %1727 = icmp ne ptr %1726, @nil_typ
  %1728 = icmp ne ptr %1726, null
  %.not16.i2154 = and i1 %1727, %1728
  br i1 %.not16.i2154, label %1729, label %._crit_edge.i2155

1729:                                             ; preds = %.lr.ph.i2140
  %1730 = getelementptr i8, ptr %1725, i64 8
  %1731 = load <2 x i64>, ptr %1730, align 4
  %hash_coef_ptr.i.i18.i2157 = getelementptr i8, ptr %1726, i64 8
  %tbl_size_ptr.i.i19.i2158 = getelementptr i8, ptr %1726, i64 16
  %offset_tbl_ptr.i.i20.i2159 = getelementptr i8, ptr %1726, i64 40
  %1732 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i2700 = load i64, ptr %hash_coef_ptr.i.i18.i2157, align 4, !noalias !22
  %tbl_size.i.i100.i2701 = load i64, ptr %tbl_size_ptr.i.i19.i2158, align 4, !noalias !22
  %offset_tbl.i.i101.i2702 = load ptr, ptr %offset_tbl_ptr.i.i20.i2159, align 8, !noalias !22
  %product.i.i.i102.i2703 = mul i64 %hash_coef.i.i99.i2700, 4015701072841558310
  %shifted.i.i.i103.i2704 = lshr i64 %product.i.i.i102.i2703, 32
  %xored.i.i.i104.i2705 = xor i64 %shifted.i.i.i103.i2704, %product.i.i.i102.i2703
  %hash.i.i.i105.i2706 = and i64 %xored.i.i.i104.i2705, %tbl_size.i.i100.i2701
  %offset_ptr.i.i106.i2707 = getelementptr i32, ptr %offset_tbl.i.i101.i2702, i64 %hash.i.i.i105.i2706
  %offset.i.i121.i2708 = load i32, ptr %offset_ptr.i.i106.i2707, align 4, !noalias !110
  %1733 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1734 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1735 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1736

1736:                                             ; preds = %.cont.cont.i2729, %1729
  %.0566.i2709 = phi i32 [ 0, %1729 ], [ %1740, %.cont.cont.i2729 ]
  %.070565.i2710 = phi i1 [ true, %1729 ], [ %1802, %.cont.cont.i2729 ]
  %.sroa.0.0564.i2711 = phi ptr [ %1726, %1729 ], [ %vptr.i142.sroa.speculated.i2732, %.cont.cont.i2729 ]
  %.sroa.17.0561.i2714 = phi i32 [ %offset.i.i121.i2708, %1729 ], [ %offset.i.i154.i2746, %.cont.cont.i2729 ]
  %1737 = phi <2 x i64> [ %1731, %1729 ], [ %1801, %.cont.cont.i2729 ]
  %1738 = extractelement <2 x i64> %1737, i64 1
  %.sroa.12.0562.i2713 = inttoptr i64 %1738 to ptr
  %1739 = extractelement <2 x i64> %1737, i64 0
  %.sroa.6.0563.i2712 = inttoptr i64 %1739 to ptr
  %1740 = add nuw nsw i32 %.0566.i2709, 1
  %1741 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2711, 0
  %1742 = insertvalue { ptr, ptr, ptr, i32 } %1741, ptr %.sroa.6.0563.i2712, 1
  %1743 = insertvalue { ptr, ptr, ptr, i32 } %1742, ptr %.sroa.12.0562.i2713, 2
  %1744 = insertvalue { ptr, ptr, ptr, i32 } %1743, i32 %.sroa.17.0561.i2714, 3
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2711)
  %1746 = sext i32 %.sroa.17.0561.i2714 to i64
  %1747 = getelementptr ptr, ptr %.sroa.0.0564.i2711, i64 %1746
  %1748 = getelementptr i8, ptr %1747, i64 64
  %1749 = load ptr, ptr %1748, align 8
  %result.i125.i2715 = call ptr %1749({ ptr, ptr, ptr, i32 } %1744, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1750 = call i32 %result.i125.i2715({ ptr, ptr, ptr, i32 } %1744, { ptr, ptr, ptr, i32 } %1744, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2710, label %1751, label %1767

1751:                                             ; preds = %1736
  %1752 = load i32, ptr %34, align 8
  %1753 = add i32 %1752, -1
  %1754 = and i32 %1753, %1750
  %1755 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1756 = load ptr, ptr %35, align 8
  %1757 = sext i32 %1754 to i64
  %1758 = shl nsw i64 %1757, 5
  %1759 = getelementptr i8, ptr %1756, i64 %1758
  %1760 = load ptr, ptr %1759, align 8
  %1761 = getelementptr i8, ptr %1759, i64 8
  %1762 = load i160, ptr %1761, align 4
  store ptr %.sroa.0.0564.i2711, ptr %1759, align 8
  store i64 %1739, ptr %1761, align 4
  %.sroa_idx157.i2758 = getelementptr i8, ptr %1759, i64 16
  store i64 %1738, ptr %.sroa_idx157.i2758, align 4
  %.sroa_idx158.i2759 = getelementptr i8, ptr %1759, i64 24
  store i32 %.sroa.17.0561.i2714, ptr %.sroa_idx158.i2759, align 4
  %1763 = icmp ne ptr %1760, @nil_typ
  %1764 = icmp ne ptr %1760, null
  %.not92.i2760 = and i1 %1763, %1764
  %extract.i2762 = lshr i160 %1762, 64
  %1765 = insertelement <2 x i160> poison, i160 %1762, i64 0
  %1766 = insertelement <2 x i160> %1765, i160 %extract.i2762, i64 1
  br i1 %.not92.i2760, label %.cont.cont.i2729, label %1806

1767:                                             ; preds = %1736
  %1768 = add i32 %1750, 2127912214
  %1769 = shl i32 %1750, 12
  %1770 = add i32 %1768, %1769
  %1771 = ashr i32 %1770, 19
  %1772 = xor i32 %1770, %1771
  %1773 = xor i32 %1772, -949894596
  %1774 = add i32 %1773, 374761393
  %1775 = shl i32 %1773, 5
  %1776 = add i32 %1774, %1775
  %1777 = add i32 %1776, -744332180
  %1778 = shl i32 %1776, 9
  %1779 = xor i32 %1777, %1778
  %1780 = add i32 %1779, -42973499
  %1781 = shl i32 %1779, 3
  %1782 = add i32 %1780, %1781
  %1783 = ashr i32 %1782, 16
  %1784 = xor i32 %1782, %1783
  %1785 = xor i32 %1784, -1252372727
  %1786 = load i32, ptr %34, align 8
  %1787 = add i32 %1786, -1
  %1788 = and i32 %1787, %1785
  %1789 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1790 = load ptr, ptr %36, align 8
  %1791 = sext i32 %1788 to i64
  %1792 = shl nsw i64 %1791, 5
  %1793 = getelementptr i8, ptr %1790, i64 %1792
  %1794 = load ptr, ptr %1793, align 8
  %1795 = getelementptr i8, ptr %1793, i64 8
  %1796 = load i160, ptr %1795, align 4
  store ptr %.sroa.0.0564.i2711, ptr %1793, align 8
  store i64 %1739, ptr %1795, align 4
  %.sroa_idx161.i2719 = getelementptr i8, ptr %1793, i64 16
  store i64 %1738, ptr %.sroa_idx161.i2719, align 4
  %.sroa_idx162.i2720 = getelementptr i8, ptr %1793, i64 24
  store i32 %.sroa.17.0561.i2714, ptr %.sroa_idx162.i2720, align 4
  %1797 = icmp ne ptr %1794, @nil_typ
  %1798 = icmp ne ptr %1794, null
  %.not90.i2721 = and i1 %1797, %1798
  %extract607.i2723 = lshr i160 %1796, 64
  %1799 = insertelement <2 x i160> poison, i160 %1796, i64 0
  %1800 = insertelement <2 x i160> %1799, i160 %extract607.i2723, i64 1
  br i1 %.not90.i2721, label %.cont.cont.i2729, label %1806

.cont.cont.i2729:                                 ; preds = %1767, %1751
  %vptr.i142.sroa.speculated.i2732 = phi ptr [ %1760, %1751 ], [ %1794, %1767 ]
  %.in3126 = phi <2 x i160> [ %1766, %1751 ], [ %1800, %1767 ]
  %1801 = trunc <2 x i160> %.in3126 to <2 x i64>
  %1802 = xor i1 %.070565.i2710, true
  %hash_coef_ptr.i.i143.i2735 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2732, i64 8
  %tbl_size_ptr.i.i144.i2736 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2732, i64 16
  %offset_tbl_ptr.i.i145.i2737 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2732, i64 40
  %hash_coef.i.i146.i2738 = load i64, ptr %hash_coef_ptr.i.i143.i2735, align 4
  %tbl_size.i.i147.i2739 = load i64, ptr %tbl_size_ptr.i.i144.i2736, align 4
  %offset_tbl.i.i148.i2740 = load ptr, ptr %offset_tbl_ptr.i.i145.i2737, align 8
  %product.i.i.i149.i2741 = mul i64 %hash_coef.i.i146.i2738, 4015701072841558310
  %shifted.i.i.i150.i2742 = lshr i64 %product.i.i.i149.i2741, 32
  %xored.i.i.i151.i2743 = xor i64 %shifted.i.i.i150.i2742, %product.i.i.i149.i2741
  %hash.i.i.i152.i2744 = and i64 %xored.i.i.i151.i2743, %tbl_size.i.i147.i2739
  %offset_ptr.i.i153.i2745 = getelementptr i32, ptr %offset_tbl.i.i148.i2740, i64 %hash.i.i.i152.i2744
  %offset.i.i154.i2746 = load i32, ptr %offset_ptr.i.i153.i2745, align 4
  %1803 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1804 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1805 = icmp ult i32 %.0566.i2709, 99
  br i1 %1805, label %1736, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2764

1806:                                             ; preds = %1767, %1751
  %1807 = phi ptr [ %6, %1767 ], [ %5, %1751 ]
  %1808 = load i32, ptr %988, align 4
  store i32 %1808, ptr %1807, align 4
  %1809 = add i32 %1808, 1
  %1810 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1809, ptr %988, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2764

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2764: ; preds = %.cont.cont.i2729, %1806
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i2155

._crit_edge.i2155:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2764, %.lr.ph.i2140
  %1811 = add nuw nsw i32 %.060.i2153, 1
  %1812 = icmp slt i32 %1811, %1717
  br i1 %1812, label %.lr.ph.i2140, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2173

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2173: ; preds = %._crit_edge.i2155
  %1813 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1814

1814:                                             ; preds = %._crit_edge.i2191, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2173
  %.060.i2189 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2173 ], [ %1903, %._crit_edge.i2191 ]
  %1815 = zext nneg i32 %.060.i2189 to i64
  %1816 = shl nuw nsw i64 %1815, 5
  %1817 = getelementptr i8, ptr %1716, i64 %1816
  %1818 = load ptr, ptr %1817, align 8
  %1819 = icmp ne ptr %1818, @nil_typ
  %1820 = icmp ne ptr %1818, null
  %.not16.i2190 = and i1 %1819, %1820
  br i1 %.not16.i2190, label %1821, label %._crit_edge.i2191

1821:                                             ; preds = %1814
  %1822 = getelementptr i8, ptr %1817, i64 8
  %1823 = load <2 x i64>, ptr %1822, align 4
  %hash_coef_ptr.i.i18.i2193 = getelementptr i8, ptr %1818, i64 8
  %tbl_size_ptr.i.i19.i2194 = getelementptr i8, ptr %1818, i64 16
  %offset_tbl_ptr.i.i20.i2195 = getelementptr i8, ptr %1818, i64 40
  %1824 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i2782 = load i64, ptr %hash_coef_ptr.i.i18.i2193, align 4, !noalias !22
  %tbl_size.i.i100.i2783 = load i64, ptr %tbl_size_ptr.i.i19.i2194, align 4, !noalias !22
  %offset_tbl.i.i101.i2784 = load ptr, ptr %offset_tbl_ptr.i.i20.i2195, align 8, !noalias !22
  %product.i.i.i102.i2785 = mul i64 %hash_coef.i.i99.i2782, 4015701072841558310
  %shifted.i.i.i103.i2786 = lshr i64 %product.i.i.i102.i2785, 32
  %xored.i.i.i104.i2787 = xor i64 %shifted.i.i.i103.i2786, %product.i.i.i102.i2785
  %hash.i.i.i105.i2788 = and i64 %xored.i.i.i104.i2787, %tbl_size.i.i100.i2783
  %offset_ptr.i.i106.i2789 = getelementptr i32, ptr %offset_tbl.i.i101.i2784, i64 %hash.i.i.i105.i2788
  %offset.i.i121.i2790 = load i32, ptr %offset_ptr.i.i106.i2789, align 4, !noalias !113
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1826 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1827 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1828

1828:                                             ; preds = %.cont.cont.i2811, %1821
  %.0566.i2791 = phi i32 [ 0, %1821 ], [ %1832, %.cont.cont.i2811 ]
  %.070565.i2792 = phi i1 [ true, %1821 ], [ %1894, %.cont.cont.i2811 ]
  %.sroa.0.0564.i2793 = phi ptr [ %1818, %1821 ], [ %vptr.i142.sroa.speculated.i2814, %.cont.cont.i2811 ]
  %.sroa.17.0561.i2796 = phi i32 [ %offset.i.i121.i2790, %1821 ], [ %offset.i.i154.i2828, %.cont.cont.i2811 ]
  %1829 = phi <2 x i64> [ %1823, %1821 ], [ %1893, %.cont.cont.i2811 ]
  %1830 = extractelement <2 x i64> %1829, i64 1
  %.sroa.12.0562.i2795 = inttoptr i64 %1830 to ptr
  %1831 = extractelement <2 x i64> %1829, i64 0
  %.sroa.6.0563.i2794 = inttoptr i64 %1831 to ptr
  %1832 = add nuw nsw i32 %.0566.i2791, 1
  %1833 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2793, 0
  %1834 = insertvalue { ptr, ptr, ptr, i32 } %1833, ptr %.sroa.6.0563.i2794, 1
  %1835 = insertvalue { ptr, ptr, ptr, i32 } %1834, ptr %.sroa.12.0562.i2795, 2
  %1836 = insertvalue { ptr, ptr, ptr, i32 } %1835, i32 %.sroa.17.0561.i2796, 3
  %1837 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2793)
  %1838 = sext i32 %.sroa.17.0561.i2796 to i64
  %1839 = getelementptr ptr, ptr %.sroa.0.0564.i2793, i64 %1838
  %1840 = getelementptr i8, ptr %1839, i64 64
  %1841 = load ptr, ptr %1840, align 8
  %result.i125.i2797 = call ptr %1841({ ptr, ptr, ptr, i32 } %1836, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1842 = call i32 %result.i125.i2797({ ptr, ptr, ptr, i32 } %1836, { ptr, ptr, ptr, i32 } %1836, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2792, label %1843, label %1859

1843:                                             ; preds = %1828
  %1844 = load i32, ptr %34, align 8
  %1845 = add i32 %1844, -1
  %1846 = and i32 %1845, %1842
  %1847 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1848 = load ptr, ptr %35, align 8
  %1849 = sext i32 %1846 to i64
  %1850 = shl nsw i64 %1849, 5
  %1851 = getelementptr i8, ptr %1848, i64 %1850
  %1852 = load ptr, ptr %1851, align 8
  %1853 = getelementptr i8, ptr %1851, i64 8
  %1854 = load i160, ptr %1853, align 4
  store ptr %.sroa.0.0564.i2793, ptr %1851, align 8
  store i64 %1831, ptr %1853, align 4
  %.sroa_idx157.i2840 = getelementptr i8, ptr %1851, i64 16
  store i64 %1830, ptr %.sroa_idx157.i2840, align 4
  %.sroa_idx158.i2841 = getelementptr i8, ptr %1851, i64 24
  store i32 %.sroa.17.0561.i2796, ptr %.sroa_idx158.i2841, align 4
  %1855 = icmp ne ptr %1852, @nil_typ
  %1856 = icmp ne ptr %1852, null
  %.not92.i2842 = and i1 %1855, %1856
  %extract.i2844 = lshr i160 %1854, 64
  %1857 = insertelement <2 x i160> poison, i160 %1854, i64 0
  %1858 = insertelement <2 x i160> %1857, i160 %extract.i2844, i64 1
  br i1 %.not92.i2842, label %.cont.cont.i2811, label %1898

1859:                                             ; preds = %1828
  %1860 = add i32 %1842, 2127912214
  %1861 = shl i32 %1842, 12
  %1862 = add i32 %1860, %1861
  %1863 = ashr i32 %1862, 19
  %1864 = xor i32 %1862, %1863
  %1865 = xor i32 %1864, -949894596
  %1866 = add i32 %1865, 374761393
  %1867 = shl i32 %1865, 5
  %1868 = add i32 %1866, %1867
  %1869 = add i32 %1868, -744332180
  %1870 = shl i32 %1868, 9
  %1871 = xor i32 %1869, %1870
  %1872 = add i32 %1871, -42973499
  %1873 = shl i32 %1871, 3
  %1874 = add i32 %1872, %1873
  %1875 = ashr i32 %1874, 16
  %1876 = xor i32 %1874, %1875
  %1877 = xor i32 %1876, -1252372727
  %1878 = load i32, ptr %34, align 8
  %1879 = add i32 %1878, -1
  %1880 = and i32 %1879, %1877
  %1881 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1882 = load ptr, ptr %36, align 8
  %1883 = sext i32 %1880 to i64
  %1884 = shl nsw i64 %1883, 5
  %1885 = getelementptr i8, ptr %1882, i64 %1884
  %1886 = load ptr, ptr %1885, align 8
  %1887 = getelementptr i8, ptr %1885, i64 8
  %1888 = load i160, ptr %1887, align 4
  store ptr %.sroa.0.0564.i2793, ptr %1885, align 8
  store i64 %1831, ptr %1887, align 4
  %.sroa_idx161.i2801 = getelementptr i8, ptr %1885, i64 16
  store i64 %1830, ptr %.sroa_idx161.i2801, align 4
  %.sroa_idx162.i2802 = getelementptr i8, ptr %1885, i64 24
  store i32 %.sroa.17.0561.i2796, ptr %.sroa_idx162.i2802, align 4
  %1889 = icmp ne ptr %1886, @nil_typ
  %1890 = icmp ne ptr %1886, null
  %.not90.i2803 = and i1 %1889, %1890
  %extract607.i2805 = lshr i160 %1888, 64
  %1891 = insertelement <2 x i160> poison, i160 %1888, i64 0
  %1892 = insertelement <2 x i160> %1891, i160 %extract607.i2805, i64 1
  br i1 %.not90.i2803, label %.cont.cont.i2811, label %1898

.cont.cont.i2811:                                 ; preds = %1859, %1843
  %vptr.i142.sroa.speculated.i2814 = phi ptr [ %1852, %1843 ], [ %1886, %1859 ]
  %.in3127 = phi <2 x i160> [ %1858, %1843 ], [ %1892, %1859 ]
  %1893 = trunc <2 x i160> %.in3127 to <2 x i64>
  %1894 = xor i1 %.070565.i2792, true
  %hash_coef_ptr.i.i143.i2817 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2814, i64 8
  %tbl_size_ptr.i.i144.i2818 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2814, i64 16
  %offset_tbl_ptr.i.i145.i2819 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2814, i64 40
  %hash_coef.i.i146.i2820 = load i64, ptr %hash_coef_ptr.i.i143.i2817, align 4
  %tbl_size.i.i147.i2821 = load i64, ptr %tbl_size_ptr.i.i144.i2818, align 4
  %offset_tbl.i.i148.i2822 = load ptr, ptr %offset_tbl_ptr.i.i145.i2819, align 8
  %product.i.i.i149.i2823 = mul i64 %hash_coef.i.i146.i2820, 4015701072841558310
  %shifted.i.i.i150.i2824 = lshr i64 %product.i.i.i149.i2823, 32
  %xored.i.i.i151.i2825 = xor i64 %shifted.i.i.i150.i2824, %product.i.i.i149.i2823
  %hash.i.i.i152.i2826 = and i64 %xored.i.i.i151.i2825, %tbl_size.i.i147.i2821
  %offset_ptr.i.i153.i2827 = getelementptr i32, ptr %offset_tbl.i.i148.i2822, i64 %hash.i.i.i152.i2826
  %offset.i.i154.i2828 = load i32, ptr %offset_ptr.i.i153.i2827, align 4
  %1895 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1896 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1897 = icmp ult i32 %.0566.i2791, 99
  br i1 %1897, label %1828, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2846

1898:                                             ; preds = %1859, %1843
  %1899 = phi ptr [ %4, %1859 ], [ %3, %1843 ]
  %1900 = load i32, ptr %988, align 4
  store i32 %1900, ptr %1899, align 4
  %1901 = add i32 %1900, 1
  %1902 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1901, ptr %988, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2846

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2846: ; preds = %.cont.cont.i2811, %1898
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i2191

._crit_edge.i2191:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2846, %1814
  %1903 = add nuw nsw i32 %.060.i2189, 1
  %1904 = icmp slt i32 %1903, %1717
  br i1 %1904, label %1814, label %HashMap_insert_keyK_valueV.exit713

HashMap_insert_keyK_valueV.exit713:               ; preds = %._crit_edge.i2191, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2173.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1438.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1334.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1230, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1171, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1334, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1438
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1905 = add nuw nsw i32 %.2249474, 1
  %1906 = icmp slt i32 %1905, %0
  br i1 %1906, label %._crit_edge3, label %._crit_edge5

._crit_edge5:                                     ; preds = %HashMap_insert_keyK_valueV.exit713
  %1907 = call i64 @clock()
  %.sroa.0202.0.insert.ext = zext i32 %spec.select to i160
  %1908 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0202.0.insert.ext, 1
  %1909 = load ptr, ptr %32, align 8
  %1910 = call i32 %1909({ ptr, i160 } %1908) #7
  %1911 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %1912 = load i32, ptr %34, align 8
  %1913 = add i32 %1912, -1
  %1914 = and i32 %1913, %1910
  %1915 = load ptr, ptr %35, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1916 = sext i32 %1914 to i64
  %1917 = shl nsw i64 %1916, 5
  %1918 = getelementptr i8, ptr %1915, i64 %1917
  %1919 = load ptr, ptr %1918, align 8
  %1920 = icmp ne ptr %1919, @nil_typ
  %1921 = icmp ne ptr %1919, null
  %.not44.i = and i1 %1920, %1921
  br i1 %.not44.i, label %1922, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

1922:                                             ; preds = %._crit_edge5
  %1923 = getelementptr i8, ptr %1918, i64 8
  %1924 = load i64, ptr %1923, align 4
  %.sroa_idx.i1499 = getelementptr i8, ptr %1918, i64 16
  %1925 = load i64, ptr %.sroa_idx.i1499, align 4
  %1926 = inttoptr i64 %1924 to ptr
  %1927 = inttoptr i64 %1925 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %1919, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %1919, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %1919, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !116
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !116
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !116
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !116
  %1928 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1919, 0
  %1929 = insertvalue { ptr, ptr, ptr, i32 } %1928, ptr %1926, 1
  %1930 = insertvalue { ptr, ptr, ptr, i32 } %1929, ptr %1927, 2
  %1931 = insertvalue { ptr, ptr, ptr, i32 } %1930, i32 %offset.i.i57.i, 3
  %1932 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1933 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1919) #34
  %1934 = sext i32 %offset.i.i57.i to i64
  %1935 = getelementptr ptr, ptr %1919, i64 %1934
  %1936 = getelementptr i8, ptr %1935, i64 64
  %1937 = load ptr, ptr %1936, align 8
  %result.i.i1500 = call ptr %1937({ ptr, ptr, ptr, i32 } %1931, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1938 = call i32 %result.i.i1500({ ptr, ptr, ptr, i32 } %1931, { ptr, ptr, ptr, i32 } %1931, ptr nonnull align 8 %2) #7
  %1939 = icmp eq i32 %1938, %1910
  br i1 %1939, label %._crit_edge.i1501, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i1501:                                ; preds = %1922
  %1940 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1941 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1919)
  %1942 = getelementptr i8, ptr %1935, i64 48
  %1943 = load ptr, ptr %1942, align 8
  %result.i59.i = call ptr %1943({ ptr, ptr, ptr, i32 } %1931, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1944 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %1931, { ptr, ptr, ptr, i32 } %1931, ptr nonnull align 8 %2) #7
  %1945 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1946 = load ptr, ptr %33, align 8
  %1947 = call i1 %1946({ ptr, i160 } %1944, { ptr, i160 } %1908) #7
  br i1 %1947, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i1501, %._crit_edge5, %1922
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %1955

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1501
  %1948 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1949 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1919)
  %1950 = getelementptr i8, ptr %1935, i64 56
  %1951 = load ptr, ptr %1950, align 8
  %result.i60.i = call ptr %1951({ ptr, ptr, ptr, i32 } %1931, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1952 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %1931, { ptr, ptr, ptr, i32 } %1931, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %1952, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1953 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %1954 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %1953, %1954
  br i1 %.not63.i, label %HashMap_get_keyK.exit, label %1955

1955:                                             ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %1956 = add i32 %1910, 2127912214
  %1957 = shl i32 %1910, 12
  %1958 = add i32 %1956, %1957
  %1959 = ashr i32 %1958, 19
  %1960 = xor i32 %1958, %1959
  %1961 = xor i32 %1960, -949894596
  %1962 = add i32 %1961, 374761393
  %1963 = shl i32 %1961, 5
  %1964 = add i32 %1962, %1963
  %1965 = add i32 %1964, -744332180
  %1966 = shl i32 %1964, 9
  %1967 = xor i32 %1965, %1966
  %1968 = add i32 %1967, -42973499
  %1969 = shl i32 %1967, 3
  %1970 = add i32 %1968, %1969
  %1971 = ashr i32 %1970, 16
  %1972 = xor i32 %1970, %1971
  %1973 = xor i32 %1972, -1252372727
  %1974 = load i32, ptr %34, align 8
  %1975 = add i32 %1974, -1
  %1976 = and i32 %1975, %1973
  %1977 = load ptr, ptr %36, align 8
  %1978 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1979 = sext i32 %1976 to i64
  %1980 = shl nsw i64 %1979, 5
  %1981 = getelementptr i8, ptr %1977, i64 %1980
  %1982 = load ptr, ptr %1981, align 8
  %1983 = icmp ne ptr %1982, @nil_typ
  %1984 = icmp ne ptr %1982, null
  %.not44.i1531 = and i1 %1983, %1984
  br i1 %.not44.i1531, label %1985, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1555

1985:                                             ; preds = %1955
  %1986 = getelementptr i8, ptr %1981, i64 8
  %1987 = load i64, ptr %1986, align 4
  %.sroa_idx.i1535 = getelementptr i8, ptr %1981, i64 16
  %1988 = load i64, ptr %.sroa_idx.i1535, align 4
  %1989 = inttoptr i64 %1987 to ptr
  %1990 = inttoptr i64 %1988 to ptr
  %hash_coef_ptr.i.i46.i1536 = getelementptr i8, ptr %1982, i64 8
  %tbl_size_ptr.i.i47.i1537 = getelementptr i8, ptr %1982, i64 16
  %offset_tbl_ptr.i.i48.i1538 = getelementptr i8, ptr %1982, i64 40
  %hash_coef.i.i49.i1539 = load i64, ptr %hash_coef_ptr.i.i46.i1536, align 4, !noalias !119
  %tbl_size.i.i50.i1540 = load i64, ptr %tbl_size_ptr.i.i47.i1537, align 4, !noalias !119
  %offset_tbl.i.i51.i1541 = load ptr, ptr %offset_tbl_ptr.i.i48.i1538, align 8, !noalias !119
  %product.i.i.i52.i1542 = mul i64 %hash_coef.i.i49.i1539, 4015701072841558310
  %shifted.i.i.i53.i1543 = lshr i64 %product.i.i.i52.i1542, 32
  %xored.i.i.i54.i1544 = xor i64 %shifted.i.i.i53.i1543, %product.i.i.i52.i1542
  %hash.i.i.i55.i1545 = and i64 %xored.i.i.i54.i1544, %tbl_size.i.i50.i1540
  %offset_ptr.i.i56.i1546 = getelementptr i32, ptr %offset_tbl.i.i51.i1541, i64 %hash.i.i.i55.i1545
  %offset.i.i57.i1547 = load i32, ptr %offset_ptr.i.i56.i1546, align 4, !noalias !119
  %1991 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1982, 0
  %1992 = insertvalue { ptr, ptr, ptr, i32 } %1991, ptr %1989, 1
  %1993 = insertvalue { ptr, ptr, ptr, i32 } %1992, ptr %1990, 2
  %1994 = insertvalue { ptr, ptr, ptr, i32 } %1993, i32 %offset.i.i57.i1547, 3
  %1995 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1996 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1982) #34
  %1997 = sext i32 %offset.i.i57.i1547 to i64
  %1998 = getelementptr ptr, ptr %1982, i64 %1997
  %1999 = getelementptr i8, ptr %1998, i64 64
  %2000 = load ptr, ptr %1999, align 8
  %result.i.i1548 = call ptr %2000({ ptr, ptr, ptr, i32 } %1994, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2001 = call i32 %result.i.i1548({ ptr, ptr, ptr, i32 } %1994, { ptr, ptr, ptr, i32 } %1994, ptr nonnull align 8 %2) #7
  %2002 = icmp eq i32 %2001, %1910
  br i1 %2002, label %._crit_edge.i1549, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1555

._crit_edge.i1549:                                ; preds = %1985
  %2003 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2004 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1982)
  %2005 = getelementptr i8, ptr %1998, i64 48
  %2006 = load ptr, ptr %2005, align 8
  %result.i59.i1550 = call ptr %2006({ ptr, ptr, ptr, i32 } %1994, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2007 = call { ptr, i160 } %result.i59.i1550({ ptr, ptr, ptr, i32 } %1994, { ptr, ptr, ptr, i32 } %1994, ptr nonnull align 8 %2) #7
  %2008 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2009 = load ptr, ptr %33, align 8
  %2010 = call i1 %2009({ ptr, i160 } %2007, { ptr, i160 } %1908) #7
  br i1 %2010, label %2011, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1555

2011:                                             ; preds = %._crit_edge.i1549
  %2012 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2013 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1982)
  %2014 = getelementptr i8, ptr %1998, i64 56
  %2015 = load ptr, ptr %2014, align 8
  %result.i60.i1552 = call ptr %2015({ ptr, ptr, ptr, i32 } %1994, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2016 = call { ptr, i160 } %result.i60.i1552({ ptr, ptr, ptr, i32 } %1994, { ptr, ptr, ptr, i32 } %1994, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1553 = extractvalue { ptr, i160 } %2016, 0
  %.fca.1.extract22.i1554 = extractvalue { ptr, i160 } %2016, 1
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1555

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1555: ; preds = %1955, %1985, %._crit_edge.i1549, %2011
  %.reg2mem43.sroa.3.077.i1532 = phi i160 [ %.fca.1.extract22.i1554, %2011 ], [ poison, %._crit_edge.i1549 ], [ poison, %1955 ], [ poison, %1985 ]
  %2017 = phi ptr [ %.fca.0.extract21.i1553, %2011 ], [ @nil_typ, %._crit_edge.i1549 ], [ @nil_typ, %1955 ], [ @nil_typ, %1985 ]
  %.reload40.fca.0.insert.i1533 = insertvalue { ptr, i160 } poison, ptr %2017, 0
  %.reload40.fca.1.insert.i1534 = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i1533, i160 %.reg2mem43.sroa.3.077.i1532, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2018 = icmp ne ptr %2017, @nil_typ
  %2019 = icmp ne ptr %2017, null
  %.not65.not.not.i = and i1 %2018, %2019
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %2017, ptr @nil_typ
  br label %HashMap_get_keyK.exit

HashMap_get_keyK.exit:                            ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1555
  %.pn.i = phi { ptr, i160 } [ %1952, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %.reload40.fca.1.insert.i1534, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1555 ]
  %2020 = phi ptr [ %.fca.0.extract21.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1555 ]
  %2021 = icmp ne ptr %2020, @nil_typ
  %2022 = icmp ne ptr %2020, null
  %.not260 = and i1 %2021, %2022
  br i1 %.not260, label %._crit_edge6, label %._crit_edge7

._crit_edge6:                                     ; preds = %HashMap_get_keyK.exit
  %.fca.1.extract..sroa.354.0101.i = extractvalue { ptr, i160 } %.pn.i, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0101.i to i32
  %2023 = add i32 %spec.select, 1
  %.not264 = icmp eq i32 %2023, %.sroa.2.8.extract.trunc
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %HashMap_get_keyK.exit, %._crit_edge6
  %.2252 = phi i1 [ %.not264, %._crit_edge6 ], [ false, %HashMap_get_keyK.exit ]
  %2024 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2025 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %2026 = load i32, ptr %988, align 4
  %.not265 = icmp eq i32 %2026, %985
  %2027 = select i1 %.not265, i1 %.2252, i1 false
  %2028 = select i1 %2027, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge2._crit_edge.thread, %._crit_edge7
  %2029 = phi i64 [ %986, %._crit_edge7 ], [ %54, %._crit_edge2._crit_edge.thread ]
  %2030 = phi i32 [ %985, %._crit_edge7 ], [ 0, %._crit_edge2._crit_edge.thread ]
  %2031 = phi i64 [ %1907, %._crit_edge7 ], [ %55, %._crit_edge2._crit_edge.thread ]
  %.reg2mem21.0.in = phi <4 x i8> [ %2028, %._crit_edge7 ], [ <i8 80, i8 65, i8 83, i8 83>, %._crit_edge2._crit_edge.thread ]
  %result.i344 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i344, align 16
  %2032 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2033 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2034 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1569 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i1569, ptr noundef nonnull align 16 dereferenceable(13) %result.i344, i64 13, i1 false)
  %2035 = sub i64 %2031, %2029
  %2036 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2037 = getelementptr i8, ptr %result.i.i1569, i64 13
  store i8 0, ptr %2037, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1569)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i376.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376.i)
  %2038 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #16
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i390.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390.i)
  %2039 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2035) #16
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i409.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409.i)
  br i1 %51, label %._crit_edge1.i, label %._crit_edge.lr.ph.i1585

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i
  %2040 = icmp sgt i64 %2035, 0
  br i1 %2040, label %2041, label %._crit_edge.lr.ph.i429.i

2041:                                             ; preds = %._crit_edge1.i
  %2042 = zext nneg i32 %0 to i64
  %2043 = mul i64 %2035, 1000000
  %2044 = sdiv i64 %2043, %2042
  br label %._crit_edge.lr.ph.i429.i

._crit_edge.lr.ph.i429.i:                         ; preds = %2041, %._crit_edge1.i
  %.0.i = phi i64 [ %2044, %2041 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i428.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i)
  %2045 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #16
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %2046 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i447.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %2047 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i374.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447.i)
  br label %._crit_edge.lr.ph.i1585

._crit_edge.lr.ph.i1585:                          ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i429.i
  %result.i348 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i348, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2048 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2049 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1584 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i1584, ptr noundef nonnull align 32 dereferenceable(18) %result.i348, i64 18, i1 false)
  %2050 = getelementptr i8, ptr %result.i.i1584, i64 18
  store i8 0, ptr %2050, align 1
  %puts.i789 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1584)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2051 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2052 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1603 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %.reg2mem21.0.in, ptr %result.i.i1603, align 1
  %2053 = getelementptr i8, ptr %result.i.i1603, i64 4
  store i8 0, ptr %2053, align 1
  %puts.i809 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1603)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i363 = call noalias align 32 dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %result.i363, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2054 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2055 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1622 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(27) %result.i.i1622, ptr noundef nonnull align 32 dereferenceable(27) %result.i363, i64 27, i1 false)
  %2056 = getelementptr i8, ptr %result.i.i1622, i64 27
  store i8 0, ptr %2056, align 1
  %puts.i829 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1622)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2057 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %2030) #16
  %2058 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2059 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2060 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1641 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i8 41, ptr %result.i.i1641, align 1
  %2061 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2062 = getelementptr i8, ptr %result.i.i1641, i64 1
  store i8 0, ptr %2062, align 1
  %puts.i849 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1641)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %oldProtect.i155 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %result.i151 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i151, align 8
  %15 = getelementptr inbounds i8, ptr %result.i151, i64 8
  store ptr @_parameterization_Ptri32, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i151, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i151) #38
  %result.i152 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i153 = call i32 @VirtualProtect(ptr nofree %result.i152, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i152, ptr noalias nofree noundef nonnull readnone @mcvhackynz, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i152) #39
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i152) #38
  %result.i154 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i155)
  %result.i156 = call i32 @VirtualProtect(ptr nofree %result.i154, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i155) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i155)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i154, ptr noalias nofree noundef nonnull readnone @ozgljpgafu, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i157 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i154) #39
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i154) #38
  %20 = getelementptr inbounds i8, ptr %result.i151, i64 48
  store ptr %ret.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i151, i64 56
  store ptr %ret.i157, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i151, i64 40
  store i32 8, ptr %22, align 8
  %result.i.i271 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %23 = getelementptr inbounds i8, ptr %result.i151, i64 24
  store ptr %result.i.i271, ptr %23, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %24 = getelementptr inbounds i8, ptr %result.i151, i64 32
  store ptr %result.i9.i, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %26 = icmp sgt i32 %0, 0
  br i1 %26, label %._crit_edge.preheader, label %._crit_edge1._crit_edge.thread

._crit_edge.preheader:                            ; preds = %1
  %27 = getelementptr inbounds i8, ptr %result.i151, i64 44
  %28 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i151, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr undef, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 10, 3
  br label %._crit_edge

._crit_edge1._crit_edge.thread:                   ; preds = %1
  %31 = call i64 @clock()
  br label %._crit_edge.lr.ph.i806

._crit_edge:                                      ; preds = %._crit_edge.preheader, %HashMap_insert_keyK_valueV.exit
  %.0258 = phi i32 [ %32, %HashMap_insert_keyK_valueV.exit ], [ 0, %._crit_edge.preheader ]
  %.0139257 = phi i64 [ %941, %HashMap_insert_keyK_valueV.exit ], [ 0, %._crit_edge.preheader ]
  %32 = add nuw nsw i32 %.0258, 1
  %33 = zext nneg i32 %32 to i64
  %.sroa.0132.0.insert.ext = zext nneg i32 %.0258 to i160
  %34 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0132.0.insert.ext, 1
  %.sroa.0129.0.insert.ext = zext nneg i32 %32 to i160
  %35 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0129.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %36 = load ptr, ptr %result.i151, align 8
  %37 = load ptr, ptr %20, align 8
  %38 = call i32 %37({ ptr, i160 } %34) #7
  %39 = load i32, ptr %22, align 8
  %40 = add i32 %39, -1
  %41 = and i32 %40, %38
  %42 = load ptr, ptr %23, align 8
  %43 = load ptr, ptr %15, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %45 = sext i32 %41 to i64
  %46 = shl nsw i64 %45, 5
  %47 = getelementptr i8, ptr %42, i64 %46
  %48 = load ptr, ptr %47, align 8
  %49 = getelementptr i8, ptr %47, i64 8
  %50 = icmp ne ptr %48, @nil_typ
  %51 = icmp ne ptr %48, null
  %.not64.i = and i1 %50, %51
  br i1 %.not64.i, label %52, label %149

52:                                               ; preds = %._crit_edge
  %53 = load i64, ptr %49, align 4
  %.sroa_idx.i = getelementptr i8, ptr %47, i64 16
  %54 = load i64, ptr %.sroa_idx.i, align 4
  %55 = inttoptr i64 %53 to ptr
  %56 = inttoptr i64 %54 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %48, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %48, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %48, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !122
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !122
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !122
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !122
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %48, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %55, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %56, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %offset.i.i77.i, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %48) #34
  %63 = sext i32 %offset.i.i77.i to i64
  %64 = getelementptr ptr, ptr %48, i64 %63
  %65 = getelementptr i8, ptr %64, i64 64
  %66 = load ptr, ptr %65, align 8
  %result.i.i = call ptr %66({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly %2) #15
  %67 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %2) #7
  %68 = icmp eq i32 %67, %38
  br i1 %68, label %._crit_edge.i461, label %149

._crit_edge.i461:                                 ; preds = %52
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %48)
  %71 = getelementptr i8, ptr %64, i64 48
  %72 = load ptr, ptr %71, align 8
  %result.i79.i = call ptr %72({ ptr, ptr, ptr, i32 } %60, ptr nocapture nofree noundef nonnull readonly %2) #15
  %73 = call { ptr, i160 } %result.i79.i({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull align 8 %2) #7
  %74 = load ptr, ptr %21, align 8
  %75 = call i1 %74({ ptr, i160 } %73, { ptr, i160 } %34) #7
  br i1 %75, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %149

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i461
  %76 = load ptr, ptr %result.i151, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %78 = load ptr, ptr %15, align 8
  %79 = load ptr, ptr %76, align 8, !alias.scope !125
  %80 = getelementptr i8, ptr %79, i64 72
  %81 = load ptr, ptr %80, align 8, !alias.scope !125
  %result.i.i.i462 = call { i64, i64 } %81(ptr nocapture nofree nonnull readonly %76) #5, !alias.scope !125
  %82 = extractvalue { i64, i64 } %result.i.i.i462, 0
  %83 = extractvalue { i64, i64 } %result.i.i.i462, 1
  %84 = urem i64 20, %83
  %85 = icmp eq i64 %84, 0
  %86 = sub i64 %83, %84
  %87 = select i1 %85, i64 0, i64 %86
  %88 = add i64 %82, 20
  %89 = add i64 %88, %87
  %90 = load ptr, ptr %78, align 8, !alias.scope !125
  %91 = getelementptr i8, ptr %90, i64 72
  %92 = load ptr, ptr %91, align 8, !alias.scope !125
  %result.i1.i.i463 = call { i64, i64 } %92(ptr nocapture nofree nonnull readonly %78) #5, !alias.scope !125
  %93 = extractvalue { i64, i64 } %result.i1.i.i463, 0
  %94 = extractvalue { i64, i64 } %result.i1.i.i463, 1
  %95 = call i64 @llvm.umax.i64(i64 %83, i64 %94)
  %96 = call i64 @llvm.umax.i64(i64 %95, i64 8)
  %97 = urem i64 %89, %94
  %98 = icmp eq i64 %97, 0
  %99 = sub i64 %94, %97
  %100 = select i1 %98, i64 0, i64 %99
  %101 = add i64 %93, %89
  %102 = add i64 %101, %100
  %103 = urem i64 %102, %96
  %104 = icmp eq i64 %103, 0
  %105 = sub i64 %96, %103
  %106 = select i1 %104, i64 0, i64 %105
  %107 = add i64 %106, %102
  %result.i83.i464 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %107, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %76, ptr %result.i83.i464, align 8
  %108 = getelementptr inbounds i8, ptr %result.i83.i464, i64 8
  store ptr %78, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i464)
  %110 = load ptr, ptr %76, align 8
  %111 = getelementptr i8, ptr %110, i64 72
  %112 = load ptr, ptr %111, align 8
  %result.i.i114.i = call { i64, i64 } %112(ptr nocapture nofree nonnull readonly %76) #5
  %113 = extractvalue { i64, i64 } %result.i.i114.i, 1
  %114 = urem i64 20, %113
  %115 = icmp eq i64 %114, 0
  %reass.sub1526 = sub i64 %113, %114
  %116 = add i64 %reass.sub1526, 20
  %117 = select i1 %115, i64 20, i64 %116
  %118 = getelementptr i8, ptr %result.i83.i464, i64 %117
  %119 = getelementptr i8, ptr %110, i64 64
  %120 = load ptr, ptr %119, align 8
  call void %120({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %76, ptr nocapture nofree writeonly %118) #12
  %121 = load ptr, ptr %result.i83.i464, align 8
  %122 = load ptr, ptr %121, align 8
  %123 = getelementptr i8, ptr %122, i64 72
  %124 = load ptr, ptr %123, align 8
  %result.i.i115.i = call { i64, i64 } %124(ptr nocapture nofree nonnull readonly %121) #5
  %125 = extractvalue { i64, i64 } %result.i.i115.i, 0
  %126 = extractvalue { i64, i64 } %result.i.i115.i, 1
  %127 = urem i64 20, %126
  %128 = icmp eq i64 %127, 0
  %129 = sub i64 %126, %127
  %130 = select i1 %128, i64 0, i64 %129
  %131 = add i64 %125, 20
  %132 = add i64 %131, %130
  %133 = load ptr, ptr %108, align 8
  %134 = load ptr, ptr %133, align 8
  %135 = getelementptr i8, ptr %134, i64 72
  %136 = load ptr, ptr %135, align 8
  %result.i1.i116.i = call { i64, i64 } %136(ptr nocapture nofree nonnull readonly %133) #5
  %137 = extractvalue { i64, i64 } %result.i1.i116.i, 1
  %138 = urem i64 %132, %137
  %139 = icmp eq i64 %138, 0
  %140 = sub i64 %137, %138
  %141 = select i1 %139, i64 0, i64 %140
  %142 = getelementptr i8, ptr %result.i83.i464, i64 %132
  %143 = getelementptr i8, ptr %142, i64 %141
  %144 = getelementptr i8, ptr %134, i64 64
  %145 = load ptr, ptr %144, align 8
  call void %145({ ptr, i160 } %35, ptr nocapture nofree nonnull readonly %133, ptr nocapture nofree writeonly %143) #12
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %147 = getelementptr inbounds i8, ptr %result.i83.i464, i64 16
  store i32 %38, ptr %147, align 8
  store ptr @Entry, ptr %47, align 8
  %148 = ptrtoint ptr %result.i83.i464 to i64
  store i64 %148, ptr %49, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %47, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

149:                                              ; preds = %._crit_edge.i461, %._crit_edge, %52
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %150 = add i32 %38, 2127912214
  %151 = shl i32 %38, 12
  %152 = add i32 %150, %151
  %153 = ashr i32 %152, 19
  %154 = xor i32 %152, %153
  %155 = xor i32 %154, -949894596
  %156 = add i32 %155, 374761393
  %157 = shl i32 %155, 5
  %158 = add i32 %156, %157
  %159 = add i32 %158, -744332180
  %160 = shl i32 %158, 9
  %161 = xor i32 %159, %160
  %162 = add i32 %161, -42973499
  %163 = shl i32 %161, 3
  %164 = add i32 %162, %163
  %165 = ashr i32 %164, 16
  %166 = xor i32 %164, %165
  %167 = xor i32 %166, -1252372727
  %168 = load i32, ptr %22, align 8
  %169 = add i32 %168, -1
  %170 = and i32 %169, %167
  %171 = load ptr, ptr %24, align 8
  %172 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %173 = sext i32 %170 to i64
  %174 = shl nsw i64 %173, 5
  %175 = getelementptr i8, ptr %171, i64 %174
  %176 = load ptr, ptr %175, align 8
  %177 = getelementptr i8, ptr %175, i64 8
  %178 = icmp ne ptr %176, @nil_typ
  %179 = icmp ne ptr %176, null
  %.not64.i493 = and i1 %178, %179
  br i1 %.not64.i493, label %180, label %277

180:                                              ; preds = %149
  %181 = load i64, ptr %177, align 4
  %.sroa_idx.i495 = getelementptr i8, ptr %175, i64 16
  %182 = load i64, ptr %.sroa_idx.i495, align 4
  %183 = inttoptr i64 %181 to ptr
  %184 = inttoptr i64 %182 to ptr
  %hash_coef_ptr.i.i66.i496 = getelementptr i8, ptr %176, i64 8
  %tbl_size_ptr.i.i67.i497 = getelementptr i8, ptr %176, i64 16
  %offset_tbl_ptr.i.i68.i498 = getelementptr i8, ptr %176, i64 40
  %hash_coef.i.i69.i499 = load i64, ptr %hash_coef_ptr.i.i66.i496, align 4, !noalias !128
  %tbl_size.i.i70.i500 = load i64, ptr %tbl_size_ptr.i.i67.i497, align 4, !noalias !128
  %offset_tbl.i.i71.i501 = load ptr, ptr %offset_tbl_ptr.i.i68.i498, align 8, !noalias !128
  %product.i.i.i72.i502 = mul i64 %hash_coef.i.i69.i499, 4015701072841558310
  %shifted.i.i.i73.i503 = lshr i64 %product.i.i.i72.i502, 32
  %xored.i.i.i74.i504 = xor i64 %shifted.i.i.i73.i503, %product.i.i.i72.i502
  %hash.i.i.i75.i505 = and i64 %xored.i.i.i74.i504, %tbl_size.i.i70.i500
  %offset_ptr.i.i76.i506 = getelementptr i32, ptr %offset_tbl.i.i71.i501, i64 %hash.i.i.i75.i505
  %offset.i.i77.i507 = load i32, ptr %offset_ptr.i.i76.i506, align 4, !noalias !128
  %185 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %176, 0
  %186 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %183, 1
  %187 = insertvalue { ptr, ptr, ptr, i32 } %186, ptr %184, 2
  %188 = insertvalue { ptr, ptr, ptr, i32 } %187, i32 %offset.i.i77.i507, 3
  %189 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %190 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %176) #34
  %191 = sext i32 %offset.i.i77.i507 to i64
  %192 = getelementptr ptr, ptr %176, i64 %191
  %193 = getelementptr i8, ptr %192, i64 64
  %194 = load ptr, ptr %193, align 8
  %result.i.i508 = call ptr %194({ ptr, ptr, ptr, i32 } %188, ptr nocapture nofree noundef nonnull readonly %2) #15
  %195 = call i32 %result.i.i508({ ptr, ptr, ptr, i32 } %188, { ptr, ptr, ptr, i32 } %188, ptr nonnull align 8 %2) #7
  %196 = icmp eq i32 %195, %38
  br i1 %196, label %._crit_edge.i509, label %277

._crit_edge.i509:                                 ; preds = %180
  %197 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %176)
  %199 = getelementptr i8, ptr %192, i64 48
  %200 = load ptr, ptr %199, align 8
  %result.i79.i510 = call ptr %200({ ptr, ptr, ptr, i32 } %188, ptr nocapture nofree noundef nonnull readonly %2) #15
  %201 = call { ptr, i160 } %result.i79.i510({ ptr, ptr, ptr, i32 } %188, { ptr, ptr, ptr, i32 } %188, ptr nonnull align 8 %2) #7
  %202 = load ptr, ptr %21, align 8
  %203 = call i1 %202({ ptr, i160 } %201, { ptr, i160 } %34) #7
  br i1 %203, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit522, label %277

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit522: ; preds = %._crit_edge.i509
  %204 = load ptr, ptr %result.i151, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %206 = load ptr, ptr %15, align 8
  %207 = load ptr, ptr %204, align 8, !alias.scope !131
  %208 = getelementptr i8, ptr %207, i64 72
  %209 = load ptr, ptr %208, align 8, !alias.scope !131
  %result.i.i.i514 = call { i64, i64 } %209(ptr nocapture nofree nonnull readonly %204) #5, !alias.scope !131
  %210 = extractvalue { i64, i64 } %result.i.i.i514, 0
  %211 = extractvalue { i64, i64 } %result.i.i.i514, 1
  %212 = urem i64 20, %211
  %213 = icmp eq i64 %212, 0
  %214 = sub i64 %211, %212
  %215 = select i1 %213, i64 0, i64 %214
  %216 = add i64 %210, 20
  %217 = add i64 %216, %215
  %218 = load ptr, ptr %206, align 8, !alias.scope !131
  %219 = getelementptr i8, ptr %218, i64 72
  %220 = load ptr, ptr %219, align 8, !alias.scope !131
  %result.i1.i.i515 = call { i64, i64 } %220(ptr nocapture nofree nonnull readonly %206) #5, !alias.scope !131
  %221 = extractvalue { i64, i64 } %result.i1.i.i515, 0
  %222 = extractvalue { i64, i64 } %result.i1.i.i515, 1
  %223 = call i64 @llvm.umax.i64(i64 %211, i64 %222)
  %224 = call i64 @llvm.umax.i64(i64 %223, i64 8)
  %225 = urem i64 %217, %222
  %226 = icmp eq i64 %225, 0
  %227 = sub i64 %222, %225
  %228 = select i1 %226, i64 0, i64 %227
  %229 = add i64 %221, %217
  %230 = add i64 %229, %228
  %231 = urem i64 %230, %224
  %232 = icmp eq i64 %231, 0
  %233 = sub i64 %224, %231
  %234 = select i1 %232, i64 0, i64 %233
  %235 = add i64 %234, %230
  %result.i83.i516 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %235, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %204, ptr %result.i83.i516, align 8
  %236 = getelementptr inbounds i8, ptr %result.i83.i516, i64 8
  store ptr %206, ptr %236, align 8
  %237 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i516)
  %238 = load ptr, ptr %204, align 8
  %239 = getelementptr i8, ptr %238, i64 72
  %240 = load ptr, ptr %239, align 8
  %result.i.i114.i517 = call { i64, i64 } %240(ptr nocapture nofree nonnull readonly %204) #5
  %241 = extractvalue { i64, i64 } %result.i.i114.i517, 1
  %242 = urem i64 20, %241
  %243 = icmp eq i64 %242, 0
  %reass.sub1525 = sub i64 %241, %242
  %244 = add i64 %reass.sub1525, 20
  %245 = select i1 %243, i64 20, i64 %244
  %246 = getelementptr i8, ptr %result.i83.i516, i64 %245
  %247 = getelementptr i8, ptr %238, i64 64
  %248 = load ptr, ptr %247, align 8
  call void %248({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %204, ptr nocapture nofree writeonly %246) #12
  %249 = load ptr, ptr %result.i83.i516, align 8
  %250 = load ptr, ptr %249, align 8
  %251 = getelementptr i8, ptr %250, i64 72
  %252 = load ptr, ptr %251, align 8
  %result.i.i115.i519 = call { i64, i64 } %252(ptr nocapture nofree nonnull readonly %249) #5
  %253 = extractvalue { i64, i64 } %result.i.i115.i519, 0
  %254 = extractvalue { i64, i64 } %result.i.i115.i519, 1
  %255 = urem i64 20, %254
  %256 = icmp eq i64 %255, 0
  %257 = sub i64 %254, %255
  %258 = select i1 %256, i64 0, i64 %257
  %259 = add i64 %253, 20
  %260 = add i64 %259, %258
  %261 = load ptr, ptr %236, align 8
  %262 = load ptr, ptr %261, align 8
  %263 = getelementptr i8, ptr %262, i64 72
  %264 = load ptr, ptr %263, align 8
  %result.i1.i116.i520 = call { i64, i64 } %264(ptr nocapture nofree nonnull readonly %261) #5
  %265 = extractvalue { i64, i64 } %result.i1.i116.i520, 1
  %266 = urem i64 %260, %265
  %267 = icmp eq i64 %266, 0
  %268 = sub i64 %265, %266
  %269 = select i1 %267, i64 0, i64 %268
  %270 = getelementptr i8, ptr %result.i83.i516, i64 %260
  %271 = getelementptr i8, ptr %270, i64 %269
  %272 = getelementptr i8, ptr %262, i64 64
  %273 = load ptr, ptr %272, align 8
  call void %273({ ptr, i160 } %35, ptr nocapture nofree nonnull readonly %261, ptr nocapture nofree writeonly %271) #12
  %274 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %275 = getelementptr inbounds i8, ptr %result.i83.i516, i64 16
  store i32 %38, ptr %275, align 8
  store ptr @Entry, ptr %175, align 8
  %276 = ptrtoint ptr %result.i83.i516 to i64
  store i64 %276, ptr %177, align 4
  %.sroa_idx28.i521 = getelementptr i8, ptr %175, i64 24
  store i32 10, ptr %.sroa_idx28.i521, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

277:                                              ; preds = %._crit_edge.i509, %149, %180
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %278 = load i32, ptr %27, align 4
  %279 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %280 = load i32, ptr %22, align 8
  %.not.i = icmp slt i32 %278, %280
  br i1 %.not.i, label %._crit_edge.i, label %281

281:                                              ; preds = %277
  %282 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %283 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %284 = load ptr, ptr %23, align 8
  %285 = load ptr, ptr %24, align 8
  %286 = shl i32 %280, 1
  %spec.select.i537 = call i32 @llvm.smax.i32(i32 %286, i32 16)
  store i32 %spec.select.i537, ptr %22, align 8
  %287 = zext nneg i32 %spec.select.i537 to i64
  %288 = shl nuw nsw i64 %287, 5
  %result.i.i538 = call noalias ptr @bump_malloc_inner(i64 noundef %288, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i538, ptr %23, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %288, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i, ptr %24, align 8
  store i32 0, ptr %27, align 4
  %289 = icmp sgt i32 %280, 0
  br i1 %289, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread: ; preds = %281
  %290 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i

.lr.ph.i:                                         ; preds = %281, %._crit_edge.i873
  %.060.i = phi i32 [ %309, %._crit_edge.i873 ], [ 0, %281 ]
  %291 = zext nneg i32 %.060.i to i64
  %292 = shl nuw nsw i64 %291, 5
  %293 = getelementptr i8, ptr %284, i64 %292
  %294 = load ptr, ptr %293, align 8
  %295 = icmp ne ptr %294, @nil_typ
  %296 = icmp ne ptr %294, null
  %.not16.i = and i1 %295, %296
  br i1 %.not16.i, label %297, label %._crit_edge.i873

297:                                              ; preds = %.lr.ph.i
  %298 = getelementptr i8, ptr %293, i64 8
  %299 = load i64, ptr %298, align 4
  %.sroa_idx.i874 = getelementptr i8, ptr %293, i64 16
  %300 = load i64, ptr %.sroa_idx.i874, align 4
  %301 = inttoptr i64 %299 to ptr
  %302 = inttoptr i64 %300 to ptr
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %294, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %294, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %294, i64 40
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i43.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !134
  %303 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %294, 0
  %304 = insertvalue { ptr, ptr, ptr, i32 } %303, ptr %301, 1
  %305 = insertvalue { ptr, ptr, ptr, i32 } %304, ptr %302, 2
  %306 = insertvalue { ptr, ptr, ptr, i32 } %305, i32 %offset.i.i43.i, 3
  %307 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %308 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %306) #7
  br label %._crit_edge.i873

._crit_edge.i873:                                 ; preds = %297, %.lr.ph.i
  %309 = add nuw nsw i32 %.060.i, 1
  %310 = icmp slt i32 %309, %280
  br i1 %310, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i873
  %311 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %312

312:                                              ; preds = %._crit_edge.i892, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %.060.i890 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit ], [ %331, %._crit_edge.i892 ]
  %313 = zext nneg i32 %.060.i890 to i64
  %314 = shl nuw nsw i64 %313, 5
  %315 = getelementptr i8, ptr %285, i64 %314
  %316 = load ptr, ptr %315, align 8
  %317 = icmp ne ptr %316, @nil_typ
  %318 = icmp ne ptr %316, null
  %.not16.i891 = and i1 %317, %318
  br i1 %.not16.i891, label %319, label %._crit_edge.i892

319:                                              ; preds = %312
  %320 = getelementptr i8, ptr %315, i64 8
  %321 = load i64, ptr %320, align 4
  %.sroa_idx.i893 = getelementptr i8, ptr %315, i64 16
  %322 = load i64, ptr %.sroa_idx.i893, align 4
  %323 = inttoptr i64 %321 to ptr
  %324 = inttoptr i64 %322 to ptr
  %hash_coef_ptr.i.i18.i894 = getelementptr i8, ptr %316, i64 8
  %tbl_size_ptr.i.i19.i895 = getelementptr i8, ptr %316, i64 16
  %offset_tbl_ptr.i.i20.i896 = getelementptr i8, ptr %316, i64 40
  %hash_coef.i.i21.i897 = load i64, ptr %hash_coef_ptr.i.i18.i894, align 4, !noalias !22
  %tbl_size.i.i22.i898 = load i64, ptr %tbl_size_ptr.i.i19.i895, align 4, !noalias !22
  %offset_tbl.i.i23.i899 = load ptr, ptr %offset_tbl_ptr.i.i20.i896, align 8, !noalias !22
  %product.i.i.i24.i900 = mul i64 %hash_coef.i.i21.i897, 4015701072841558310
  %shifted.i.i.i25.i901 = lshr i64 %product.i.i.i24.i900, 32
  %xored.i.i.i26.i902 = xor i64 %shifted.i.i.i25.i901, %product.i.i.i24.i900
  %hash.i.i.i27.i903 = and i64 %xored.i.i.i26.i902, %tbl_size.i.i22.i898
  %offset_ptr.i.i28.i904 = getelementptr i32, ptr %offset_tbl.i.i23.i899, i64 %hash.i.i.i27.i903
  %offset.i.i43.i905 = load i32, ptr %offset_ptr.i.i28.i904, align 4, !noalias !137
  %325 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %316, 0
  %326 = insertvalue { ptr, ptr, ptr, i32 } %325, ptr %323, 1
  %327 = insertvalue { ptr, ptr, ptr, i32 } %326, ptr %324, 2
  %328 = insertvalue { ptr, ptr, ptr, i32 } %327, i32 %offset.i.i43.i905, 3
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %330 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %328) #7
  br label %._crit_edge.i892

._crit_edge.i892:                                 ; preds = %319, %312
  %331 = add nuw nsw i32 %.060.i890, 1
  %332 = icmp slt i32 %331, %280
  br i1 %332, label %312, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i892, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread, %277
  %333 = load ptr, ptr %36, align 8
  %334 = getelementptr i8, ptr %333, i64 72
  %335 = load ptr, ptr %334, align 8
  %result.i.i.i = call { i64, i64 } %335(ptr nocapture nofree nonnull readonly %36) #5
  %336 = extractvalue { i64, i64 } %result.i.i.i, 0
  %337 = extractvalue { i64, i64 } %result.i.i.i, 1
  %338 = urem i64 20, %337
  %339 = icmp eq i64 %338, 0
  %340 = sub i64 %337, %338
  %341 = select i1 %339, i64 0, i64 %340
  %342 = add i64 %336, 20
  %343 = add i64 %342, %341
  %344 = load ptr, ptr %43, align 8
  %345 = getelementptr i8, ptr %344, i64 72
  %346 = load ptr, ptr %345, align 8
  %result.i1.i.i = call { i64, i64 } %346(ptr nocapture nofree nonnull readonly %43) #5
  %347 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %348 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %349 = call i64 @llvm.umax.i64(i64 %337, i64 %348)
  %350 = call i64 @llvm.umax.i64(i64 %349, i64 8)
  %351 = urem i64 %343, %348
  %352 = icmp eq i64 %351, 0
  %353 = sub i64 %348, %351
  %354 = select i1 %352, i64 0, i64 %353
  %355 = add i64 %347, %343
  %356 = add i64 %355, %354
  %357 = urem i64 %356, %350
  %358 = icmp eq i64 %357, 0
  %359 = sub i64 %350, %357
  %360 = select i1 %358, i64 0, i64 %359
  %361 = add i64 %360, %356
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %361, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %36, ptr %result.i83.i, align 8
  %362 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %43, ptr %362, align 8
  %363 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %364 = load ptr, ptr %36, align 8
  %365 = getelementptr i8, ptr %364, i64 72
  %366 = load ptr, ptr %365, align 8
  %result.i.i179.i = call { i64, i64 } %366(ptr nocapture nofree nonnull readonly %36) #5
  %367 = extractvalue { i64, i64 } %result.i.i179.i, 1
  %368 = urem i64 20, %367
  %369 = icmp eq i64 %368, 0
  %reass.sub = sub i64 %367, %368
  %370 = add i64 %reass.sub, 20
  %371 = select i1 %369, i64 20, i64 %370
  %372 = getelementptr i8, ptr %result.i83.i, i64 %371
  %373 = getelementptr i8, ptr %364, i64 64
  %374 = load ptr, ptr %373, align 8
  call void %374({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %36, ptr nocapture nofree writeonly %372) #12
  %375 = load ptr, ptr %result.i83.i, align 8
  %376 = load ptr, ptr %375, align 8
  %377 = getelementptr i8, ptr %376, i64 72
  %378 = load ptr, ptr %377, align 8
  %result.i.i180.i = call { i64, i64 } %378(ptr nocapture nofree nonnull readonly %375) #5
  %379 = extractvalue { i64, i64 } %result.i.i180.i, 0
  %380 = extractvalue { i64, i64 } %result.i.i180.i, 1
  %381 = urem i64 20, %380
  %382 = icmp eq i64 %381, 0
  %383 = sub i64 %380, %381
  %384 = select i1 %382, i64 0, i64 %383
  %385 = add i64 %379, 20
  %386 = add i64 %385, %384
  %387 = load ptr, ptr %362, align 8
  %388 = load ptr, ptr %387, align 8
  %389 = getelementptr i8, ptr %388, i64 72
  %390 = load ptr, ptr %389, align 8
  %result.i1.i181.i = call { i64, i64 } %390(ptr nocapture nofree nonnull readonly %387) #5
  %391 = extractvalue { i64, i64 } %result.i1.i181.i, 1
  %392 = urem i64 %386, %391
  %393 = icmp eq i64 %392, 0
  %394 = sub i64 %391, %392
  %395 = select i1 %393, i64 0, i64 %394
  %396 = getelementptr i8, ptr %result.i83.i, i64 %386
  %397 = getelementptr i8, ptr %396, i64 %395
  %398 = getelementptr i8, ptr %388, i64 64
  %399 = load ptr, ptr %398, align 8
  call void %399({ ptr, i160 } %35, ptr nocapture nofree nonnull readonly %387, ptr nocapture nofree writeonly %397) #12
  %400 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %401 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %38, ptr %401, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %404 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %405

405:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %406, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %472, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i83.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i554, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %406 = add nuw nsw i32 %.0566.i, 1
  %407 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %408 = insertvalue { ptr, ptr, ptr, i32 } %407, ptr %.sroa.6.0563.i, 1
  %409 = insertvalue { ptr, ptr, ptr, i32 } %408, ptr %.sroa.12.0562.i, 2
  %410 = insertvalue { ptr, ptr, ptr, i32 } %409, i32 %.sroa.17.0561.i, 3
  %411 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %412 = sext i32 %.sroa.17.0561.i to i64
  %413 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %412
  %414 = getelementptr i8, ptr %413, i64 64
  %415 = load ptr, ptr %414, align 8
  %result.i125.i = call ptr %415({ ptr, ptr, ptr, i32 } %410, ptr nocapture nofree noundef nonnull readonly %2) #15
  %416 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %410, { ptr, ptr, ptr, i32 } %410, ptr nonnull align 8 %2) #7
  %417 = ptrtoint ptr %.sroa.6.0563.i to i64
  %418 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %419, label %435

419:                                              ; preds = %405
  %420 = load i32, ptr %22, align 8
  %421 = add i32 %420, -1
  %422 = and i32 %421, %416
  %423 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %424 = load ptr, ptr %23, align 8
  %425 = sext i32 %422 to i64
  %426 = shl nsw i64 %425, 5
  %427 = getelementptr i8, ptr %424, i64 %426
  %428 = load ptr, ptr %427, align 8
  %429 = getelementptr i8, ptr %427, i64 8
  %430 = load i160, ptr %429, align 4
  store ptr %.sroa.0.0564.i, ptr %427, align 8
  store i64 %417, ptr %429, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %427, i64 16
  store i64 %418, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %427, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %431 = icmp ne ptr %428, @nil_typ
  %432 = icmp ne ptr %428, null
  %.not92.i = and i1 %431, %432
  %extract.i = lshr i160 %430, 64
  %433 = insertelement <2 x i160> poison, i160 %430, i64 0
  %434 = insertelement <2 x i160> %433, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

435:                                              ; preds = %405
  %436 = add i32 %416, 2127912214
  %437 = shl i32 %416, 12
  %438 = add i32 %436, %437
  %439 = ashr i32 %438, 19
  %440 = xor i32 %438, %439
  %441 = xor i32 %440, -949894596
  %442 = add i32 %441, 374761393
  %443 = shl i32 %441, 5
  %444 = add i32 %442, %443
  %445 = add i32 %444, -744332180
  %446 = shl i32 %444, 9
  %447 = xor i32 %445, %446
  %448 = add i32 %447, -42973499
  %449 = shl i32 %447, 3
  %450 = add i32 %448, %449
  %451 = ashr i32 %450, 16
  %452 = xor i32 %450, %451
  %453 = xor i32 %452, -1252372727
  %454 = load i32, ptr %22, align 8
  %455 = add i32 %454, -1
  %456 = and i32 %455, %453
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %458 = load ptr, ptr %24, align 8
  %459 = sext i32 %456 to i64
  %460 = shl nsw i64 %459, 5
  %461 = getelementptr i8, ptr %458, i64 %460
  %462 = load ptr, ptr %461, align 8
  %463 = getelementptr i8, ptr %461, i64 8
  %464 = load i160, ptr %463, align 4
  store ptr %.sroa.0.0564.i, ptr %461, align 8
  store i64 %417, ptr %463, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %461, i64 16
  store i64 %418, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %461, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %465 = icmp ne ptr %462, @nil_typ
  %466 = icmp ne ptr %462, null
  %.not90.i = and i1 %465, %466
  %extract607.i = lshr i160 %464, 64
  %467 = insertelement <2 x i160> poison, i160 %464, i64 0
  %468 = insertelement <2 x i160> %467, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %435, %419
  %vptr.i142.sroa.speculated.i = phi ptr [ %428, %419 ], [ %462, %435 ]
  %.in = phi <2 x i160> [ %434, %419 ], [ %468, %435 ]
  %469 = trunc <2 x i160> %.in to <2 x i64>
  %470 = extractelement <2 x i64> %469, i64 1
  %spec.select.i554 = inttoptr i64 %470 to ptr
  %471 = extractelement <2 x i64> %469, i64 0
  %spec.select539.i = inttoptr i64 %471 to ptr
  %472 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %473 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %474 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %475 = icmp ult i32 %.0566.i, 99
  br i1 %475, label %405, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %419, %435
  %476 = phi ptr [ %14, %435 ], [ %13, %419 ]
  %477 = load i32, ptr %27, align 4
  store i32 %477, ptr %476, align 4
  %478 = add i32 %477, 1
  %479 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %478, ptr %27, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  %480 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %480, label %HashMap_insert_keyK_valueV.exit, label %481

481:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %482 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %483 = load ptr, ptr %23, align 8
  %484 = load ptr, ptr %24, align 8
  %485 = load i32, ptr %22, align 8
  %486 = shl i32 %485, 1
  %spec.select.i571 = call i32 @llvm.smax.i32(i32 %486, i32 16)
  store i32 %spec.select.i571, ptr %22, align 8
  %487 = zext nneg i32 %spec.select.i571 to i64
  %488 = shl nuw nsw i64 %487, 5
  %result.i.i572 = call noalias ptr @bump_malloc_inner(i64 noundef %488, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i572, ptr %23, align 8
  %result.i20.i573 = call noalias ptr @bump_malloc_inner(i64 noundef %488, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i573, ptr %24, align 8
  store i32 0, ptr %27, align 4
  %489 = icmp sgt i32 %485, 0
  br i1 %489, label %.lr.ph.i939, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008

.lr.ph.i939:                                      ; preds = %481, %._crit_edge.i954
  %.060.i952 = phi i32 [ %578, %._crit_edge.i954 ], [ 0, %481 ]
  %490 = zext nneg i32 %.060.i952 to i64
  %491 = shl nuw nsw i64 %490, 5
  %492 = getelementptr i8, ptr %483, i64 %491
  %493 = load ptr, ptr %492, align 8
  %494 = icmp ne ptr %493, @nil_typ
  %495 = icmp ne ptr %493, null
  %.not16.i953 = and i1 %494, %495
  br i1 %.not16.i953, label %496, label %._crit_edge.i954

496:                                              ; preds = %.lr.ph.i939
  %497 = getelementptr i8, ptr %492, i64 8
  %498 = load <2 x i64>, ptr %497, align 4
  %hash_coef_ptr.i.i18.i956 = getelementptr i8, ptr %493, i64 8
  %tbl_size_ptr.i.i19.i957 = getelementptr i8, ptr %493, i64 16
  %offset_tbl_ptr.i.i20.i958 = getelementptr i8, ptr %493, i64 40
  %499 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i956, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i957, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i958, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !140
  %500 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %502 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %503

503:                                              ; preds = %.cont.cont.i1132, %496
  %.0566.i1119 = phi i32 [ 0, %496 ], [ %507, %.cont.cont.i1132 ]
  %.070565.i1120 = phi i1 [ true, %496 ], [ %569, %.cont.cont.i1132 ]
  %.sroa.0.0564.i1121 = phi ptr [ %493, %496 ], [ %vptr.i142.sroa.speculated.i1135, %.cont.cont.i1132 ]
  %.sroa.17.0561.i1124 = phi i32 [ %offset.i.i121.i, %496 ], [ %offset.i.i154.i1149, %.cont.cont.i1132 ]
  %504 = phi <2 x i64> [ %498, %496 ], [ %568, %.cont.cont.i1132 ]
  %505 = extractelement <2 x i64> %504, i64 1
  %.sroa.12.0562.i1123 = inttoptr i64 %505 to ptr
  %506 = extractelement <2 x i64> %504, i64 0
  %.sroa.6.0563.i1122 = inttoptr i64 %506 to ptr
  %507 = add nuw nsw i32 %.0566.i1119, 1
  %508 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1121, 0
  %509 = insertvalue { ptr, ptr, ptr, i32 } %508, ptr %.sroa.6.0563.i1122, 1
  %510 = insertvalue { ptr, ptr, ptr, i32 } %509, ptr %.sroa.12.0562.i1123, 2
  %511 = insertvalue { ptr, ptr, ptr, i32 } %510, i32 %.sroa.17.0561.i1124, 3
  %512 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1121)
  %513 = sext i32 %.sroa.17.0561.i1124 to i64
  %514 = getelementptr ptr, ptr %.sroa.0.0564.i1121, i64 %513
  %515 = getelementptr i8, ptr %514, i64 64
  %516 = load ptr, ptr %515, align 8
  %result.i125.i1125 = call ptr %516({ ptr, ptr, ptr, i32 } %511, ptr nocapture nofree noundef nonnull readonly %2) #15
  %517 = call i32 %result.i125.i1125({ ptr, ptr, ptr, i32 } %511, { ptr, ptr, ptr, i32 } %511, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1120, label %518, label %534

518:                                              ; preds = %503
  %519 = load i32, ptr %22, align 8
  %520 = add i32 %519, -1
  %521 = and i32 %520, %517
  %522 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %523 = load ptr, ptr %23, align 8
  %524 = sext i32 %521 to i64
  %525 = shl nsw i64 %524, 5
  %526 = getelementptr i8, ptr %523, i64 %525
  %527 = load ptr, ptr %526, align 8
  %528 = getelementptr i8, ptr %526, i64 8
  %529 = load i160, ptr %528, align 4
  store ptr %.sroa.0.0564.i1121, ptr %526, align 8
  store i64 %506, ptr %528, align 4
  %.sroa_idx157.i1151 = getelementptr i8, ptr %526, i64 16
  store i64 %505, ptr %.sroa_idx157.i1151, align 4
  %.sroa_idx158.i1152 = getelementptr i8, ptr %526, i64 24
  store i32 %.sroa.17.0561.i1124, ptr %.sroa_idx158.i1152, align 4
  %530 = icmp ne ptr %527, @nil_typ
  %531 = icmp ne ptr %527, null
  %.not92.i1153 = and i1 %530, %531
  %extract.i1155 = lshr i160 %529, 64
  %532 = insertelement <2 x i160> poison, i160 %529, i64 0
  %533 = insertelement <2 x i160> %532, i160 %extract.i1155, i64 1
  br i1 %.not92.i1153, label %.cont.cont.i1132, label %573

534:                                              ; preds = %503
  %535 = add i32 %517, 2127912214
  %536 = shl i32 %517, 12
  %537 = add i32 %535, %536
  %538 = ashr i32 %537, 19
  %539 = xor i32 %537, %538
  %540 = xor i32 %539, -949894596
  %541 = add i32 %540, 374761393
  %542 = shl i32 %540, 5
  %543 = add i32 %541, %542
  %544 = add i32 %543, -744332180
  %545 = shl i32 %543, 9
  %546 = xor i32 %544, %545
  %547 = add i32 %546, -42973499
  %548 = shl i32 %546, 3
  %549 = add i32 %547, %548
  %550 = ashr i32 %549, 16
  %551 = xor i32 %549, %550
  %552 = xor i32 %551, -1252372727
  %553 = load i32, ptr %22, align 8
  %554 = add i32 %553, -1
  %555 = and i32 %554, %552
  %556 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %557 = load ptr, ptr %24, align 8
  %558 = sext i32 %555 to i64
  %559 = shl nsw i64 %558, 5
  %560 = getelementptr i8, ptr %557, i64 %559
  %561 = load ptr, ptr %560, align 8
  %562 = getelementptr i8, ptr %560, i64 8
  %563 = load i160, ptr %562, align 4
  store ptr %.sroa.0.0564.i1121, ptr %560, align 8
  store i64 %506, ptr %562, align 4
  %.sroa_idx161.i1126 = getelementptr i8, ptr %560, i64 16
  store i64 %505, ptr %.sroa_idx161.i1126, align 4
  %.sroa_idx162.i1127 = getelementptr i8, ptr %560, i64 24
  store i32 %.sroa.17.0561.i1124, ptr %.sroa_idx162.i1127, align 4
  %564 = icmp ne ptr %561, @nil_typ
  %565 = icmp ne ptr %561, null
  %.not90.i1128 = and i1 %564, %565
  %extract607.i1130 = lshr i160 %563, 64
  %566 = insertelement <2 x i160> poison, i160 %563, i64 0
  %567 = insertelement <2 x i160> %566, i160 %extract607.i1130, i64 1
  br i1 %.not90.i1128, label %.cont.cont.i1132, label %573

.cont.cont.i1132:                                 ; preds = %534, %518
  %vptr.i142.sroa.speculated.i1135 = phi ptr [ %527, %518 ], [ %561, %534 ]
  %.in1527 = phi <2 x i160> [ %533, %518 ], [ %567, %534 ]
  %568 = trunc <2 x i160> %.in1527 to <2 x i64>
  %569 = xor i1 %.070565.i1120, true
  %hash_coef_ptr.i.i143.i1138 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1135, i64 8
  %tbl_size_ptr.i.i144.i1139 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1135, i64 16
  %offset_tbl_ptr.i.i145.i1140 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1135, i64 40
  %hash_coef.i.i146.i1141 = load i64, ptr %hash_coef_ptr.i.i143.i1138, align 4
  %tbl_size.i.i147.i1142 = load i64, ptr %tbl_size_ptr.i.i144.i1139, align 4
  %offset_tbl.i.i148.i1143 = load ptr, ptr %offset_tbl_ptr.i.i145.i1140, align 8
  %product.i.i.i149.i1144 = mul i64 %hash_coef.i.i146.i1141, 4015701072841558310
  %shifted.i.i.i150.i1145 = lshr i64 %product.i.i.i149.i1144, 32
  %xored.i.i.i151.i1146 = xor i64 %shifted.i.i.i150.i1145, %product.i.i.i149.i1144
  %hash.i.i.i152.i1147 = and i64 %xored.i.i.i151.i1146, %tbl_size.i.i147.i1142
  %offset_ptr.i.i153.i1148 = getelementptr i32, ptr %offset_tbl.i.i148.i1143, i64 %hash.i.i.i152.i1147
  %offset.i.i154.i1149 = load i32, ptr %offset_ptr.i.i153.i1148, align 4
  %570 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %571 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %572 = icmp ult i32 %.0566.i1119, 99
  br i1 %572, label %503, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1157

573:                                              ; preds = %534, %518
  %574 = phi ptr [ %10, %534 ], [ %9, %518 ]
  %575 = load i32, ptr %27, align 4
  store i32 %575, ptr %574, align 4
  %576 = add i32 %575, 1
  %577 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %576, ptr %27, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1157

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1157: ; preds = %.cont.cont.i1132, %573
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i954

._crit_edge.i954:                                 ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1157, %.lr.ph.i939
  %578 = add nuw nsw i32 %.060.i952, 1
  %579 = icmp slt i32 %578, %485
  br i1 %579, label %.lr.ph.i939, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972: ; preds = %._crit_edge.i954, %._crit_edge.i990
  %.060.i988 = phi i32 [ %668, %._crit_edge.i990 ], [ 0, %._crit_edge.i954 ]
  %580 = zext nneg i32 %.060.i988 to i64
  %581 = shl nuw nsw i64 %580, 5
  %582 = getelementptr i8, ptr %484, i64 %581
  %583 = load ptr, ptr %582, align 8
  %584 = icmp ne ptr %583, @nil_typ
  %585 = icmp ne ptr %583, null
  %.not16.i989 = and i1 %584, %585
  br i1 %.not16.i989, label %586, label %._crit_edge.i990

586:                                              ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972
  %587 = getelementptr i8, ptr %582, i64 8
  %588 = load <2 x i64>, ptr %587, align 4
  %hash_coef_ptr.i.i18.i992 = getelementptr i8, ptr %583, i64 8
  %tbl_size_ptr.i.i19.i993 = getelementptr i8, ptr %583, i64 16
  %offset_tbl_ptr.i.i20.i994 = getelementptr i8, ptr %583, i64 40
  %589 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i1175 = load i64, ptr %hash_coef_ptr.i.i18.i992, align 4, !noalias !22
  %tbl_size.i.i100.i1176 = load i64, ptr %tbl_size_ptr.i.i19.i993, align 4, !noalias !22
  %offset_tbl.i.i101.i1177 = load ptr, ptr %offset_tbl_ptr.i.i20.i994, align 8, !noalias !22
  %product.i.i.i102.i1178 = mul i64 %hash_coef.i.i99.i1175, 4015701072841558310
  %shifted.i.i.i103.i1179 = lshr i64 %product.i.i.i102.i1178, 32
  %xored.i.i.i104.i1180 = xor i64 %shifted.i.i.i103.i1179, %product.i.i.i102.i1178
  %hash.i.i.i105.i1181 = and i64 %xored.i.i.i104.i1180, %tbl_size.i.i100.i1176
  %offset_ptr.i.i106.i1182 = getelementptr i32, ptr %offset_tbl.i.i101.i1177, i64 %hash.i.i.i105.i1181
  %offset.i.i121.i1183 = load i32, ptr %offset_ptr.i.i106.i1182, align 4, !noalias !143
  %590 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %591 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %592 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %593

593:                                              ; preds = %.cont.cont.i1204, %586
  %.0566.i1184 = phi i32 [ 0, %586 ], [ %597, %.cont.cont.i1204 ]
  %.070565.i1185 = phi i1 [ true, %586 ], [ %659, %.cont.cont.i1204 ]
  %.sroa.0.0564.i1186 = phi ptr [ %583, %586 ], [ %vptr.i142.sroa.speculated.i1207, %.cont.cont.i1204 ]
  %.sroa.17.0561.i1189 = phi i32 [ %offset.i.i121.i1183, %586 ], [ %offset.i.i154.i1221, %.cont.cont.i1204 ]
  %594 = phi <2 x i64> [ %588, %586 ], [ %658, %.cont.cont.i1204 ]
  %595 = extractelement <2 x i64> %594, i64 1
  %.sroa.12.0562.i1188 = inttoptr i64 %595 to ptr
  %596 = extractelement <2 x i64> %594, i64 0
  %.sroa.6.0563.i1187 = inttoptr i64 %596 to ptr
  %597 = add nuw nsw i32 %.0566.i1184, 1
  %598 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1186, 0
  %599 = insertvalue { ptr, ptr, ptr, i32 } %598, ptr %.sroa.6.0563.i1187, 1
  %600 = insertvalue { ptr, ptr, ptr, i32 } %599, ptr %.sroa.12.0562.i1188, 2
  %601 = insertvalue { ptr, ptr, ptr, i32 } %600, i32 %.sroa.17.0561.i1189, 3
  %602 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1186)
  %603 = sext i32 %.sroa.17.0561.i1189 to i64
  %604 = getelementptr ptr, ptr %.sroa.0.0564.i1186, i64 %603
  %605 = getelementptr i8, ptr %604, i64 64
  %606 = load ptr, ptr %605, align 8
  %result.i125.i1190 = call ptr %606({ ptr, ptr, ptr, i32 } %601, ptr nocapture nofree noundef nonnull readonly %2) #15
  %607 = call i32 %result.i125.i1190({ ptr, ptr, ptr, i32 } %601, { ptr, ptr, ptr, i32 } %601, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1185, label %608, label %624

608:                                              ; preds = %593
  %609 = load i32, ptr %22, align 8
  %610 = add i32 %609, -1
  %611 = and i32 %610, %607
  %612 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %613 = load ptr, ptr %23, align 8
  %614 = sext i32 %611 to i64
  %615 = shl nsw i64 %614, 5
  %616 = getelementptr i8, ptr %613, i64 %615
  %617 = load ptr, ptr %616, align 8
  %618 = getelementptr i8, ptr %616, i64 8
  %619 = load i160, ptr %618, align 4
  store ptr %.sroa.0.0564.i1186, ptr %616, align 8
  store i64 %596, ptr %618, align 4
  %.sroa_idx157.i1233 = getelementptr i8, ptr %616, i64 16
  store i64 %595, ptr %.sroa_idx157.i1233, align 4
  %.sroa_idx158.i1234 = getelementptr i8, ptr %616, i64 24
  store i32 %.sroa.17.0561.i1189, ptr %.sroa_idx158.i1234, align 4
  %620 = icmp ne ptr %617, @nil_typ
  %621 = icmp ne ptr %617, null
  %.not92.i1235 = and i1 %620, %621
  %extract.i1237 = lshr i160 %619, 64
  %622 = insertelement <2 x i160> poison, i160 %619, i64 0
  %623 = insertelement <2 x i160> %622, i160 %extract.i1237, i64 1
  br i1 %.not92.i1235, label %.cont.cont.i1204, label %663

624:                                              ; preds = %593
  %625 = add i32 %607, 2127912214
  %626 = shl i32 %607, 12
  %627 = add i32 %625, %626
  %628 = ashr i32 %627, 19
  %629 = xor i32 %627, %628
  %630 = xor i32 %629, -949894596
  %631 = add i32 %630, 374761393
  %632 = shl i32 %630, 5
  %633 = add i32 %631, %632
  %634 = add i32 %633, -744332180
  %635 = shl i32 %633, 9
  %636 = xor i32 %634, %635
  %637 = add i32 %636, -42973499
  %638 = shl i32 %636, 3
  %639 = add i32 %637, %638
  %640 = ashr i32 %639, 16
  %641 = xor i32 %639, %640
  %642 = xor i32 %641, -1252372727
  %643 = load i32, ptr %22, align 8
  %644 = add i32 %643, -1
  %645 = and i32 %644, %642
  %646 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %647 = load ptr, ptr %24, align 8
  %648 = sext i32 %645 to i64
  %649 = shl nsw i64 %648, 5
  %650 = getelementptr i8, ptr %647, i64 %649
  %651 = load ptr, ptr %650, align 8
  %652 = getelementptr i8, ptr %650, i64 8
  %653 = load i160, ptr %652, align 4
  store ptr %.sroa.0.0564.i1186, ptr %650, align 8
  store i64 %596, ptr %652, align 4
  %.sroa_idx161.i1194 = getelementptr i8, ptr %650, i64 16
  store i64 %595, ptr %.sroa_idx161.i1194, align 4
  %.sroa_idx162.i1195 = getelementptr i8, ptr %650, i64 24
  store i32 %.sroa.17.0561.i1189, ptr %.sroa_idx162.i1195, align 4
  %654 = icmp ne ptr %651, @nil_typ
  %655 = icmp ne ptr %651, null
  %.not90.i1196 = and i1 %654, %655
  %extract607.i1198 = lshr i160 %653, 64
  %656 = insertelement <2 x i160> poison, i160 %653, i64 0
  %657 = insertelement <2 x i160> %656, i160 %extract607.i1198, i64 1
  br i1 %.not90.i1196, label %.cont.cont.i1204, label %663

.cont.cont.i1204:                                 ; preds = %624, %608
  %vptr.i142.sroa.speculated.i1207 = phi ptr [ %617, %608 ], [ %651, %624 ]
  %.in1528 = phi <2 x i160> [ %623, %608 ], [ %657, %624 ]
  %658 = trunc <2 x i160> %.in1528 to <2 x i64>
  %659 = xor i1 %.070565.i1185, true
  %hash_coef_ptr.i.i143.i1210 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1207, i64 8
  %tbl_size_ptr.i.i144.i1211 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1207, i64 16
  %offset_tbl_ptr.i.i145.i1212 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1207, i64 40
  %hash_coef.i.i146.i1213 = load i64, ptr %hash_coef_ptr.i.i143.i1210, align 4
  %tbl_size.i.i147.i1214 = load i64, ptr %tbl_size_ptr.i.i144.i1211, align 4
  %offset_tbl.i.i148.i1215 = load ptr, ptr %offset_tbl_ptr.i.i145.i1212, align 8
  %product.i.i.i149.i1216 = mul i64 %hash_coef.i.i146.i1213, 4015701072841558310
  %shifted.i.i.i150.i1217 = lshr i64 %product.i.i.i149.i1216, 32
  %xored.i.i.i151.i1218 = xor i64 %shifted.i.i.i150.i1217, %product.i.i.i149.i1216
  %hash.i.i.i152.i1219 = and i64 %xored.i.i.i151.i1218, %tbl_size.i.i147.i1214
  %offset_ptr.i.i153.i1220 = getelementptr i32, ptr %offset_tbl.i.i148.i1215, i64 %hash.i.i.i152.i1219
  %offset.i.i154.i1221 = load i32, ptr %offset_ptr.i.i153.i1220, align 4
  %660 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %661 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %662 = icmp ult i32 %.0566.i1184, 99
  br i1 %662, label %593, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1239

663:                                              ; preds = %624, %608
  %664 = phi ptr [ %8, %624 ], [ %7, %608 ]
  %665 = load i32, ptr %27, align 4
  store i32 %665, ptr %664, align 4
  %666 = add i32 %665, 1
  %667 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %666, ptr %27, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1239

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1239: ; preds = %.cont.cont.i1204, %663
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i990

._crit_edge.i990:                                 ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1239, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972
  %668 = add nuw nsw i32 %.060.i988, 1
  %669 = icmp slt i32 %668, %485
  br i1 %669, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008: ; preds = %._crit_edge.i990, %481
  %670 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i594 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i595 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i596 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i597 = mul i64 %hash_coef.i.i99.i594, 4015701072841558310
  %shifted.i.i.i103.i598 = lshr i64 %product.i.i.i102.i597, 32
  %xored.i.i.i104.i599 = xor i64 %shifted.i.i.i103.i598, %product.i.i.i102.i597
  %hash.i.i.i105.i600 = and i64 %xored.i.i.i104.i599, %tbl_size.i.i100.i595
  %offset_ptr.i.i106.i601 = getelementptr i32, ptr %offset_tbl.i.i101.i596, i64 %hash.i.i.i105.i600
  %offset.i.i121.i602 = load i32, ptr %offset_ptr.i.i106.i601, align 4, !noalias !146
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %674

674:                                              ; preds = %.cont.cont.i624, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008
  %.0566.i604 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008 ], [ %678, %.cont.cont.i624 ]
  %.070565.i605 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008 ], [ %740, %.cont.cont.i624 ]
  %.sroa.0.0564.i606 = phi ptr [ %vptr.i142.sroa.speculated.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008 ], [ %vptr.i142.sroa.speculated.i627, %.cont.cont.i624 ]
  %.sroa.17.0561.i609 = phi i32 [ %offset.i.i121.i602, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008 ], [ %offset.i.i154.i641, %.cont.cont.i624 ]
  %675 = phi <2 x i64> [ %469, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008 ], [ %739, %.cont.cont.i624 ]
  %676 = extractelement <2 x i64> %675, i64 1
  %.sroa.12.0562.i608 = inttoptr i64 %676 to ptr
  %677 = extractelement <2 x i64> %675, i64 0
  %.sroa.6.0563.i607 = inttoptr i64 %677 to ptr
  %678 = add nuw nsw i32 %.0566.i604, 1
  %679 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i606, 0
  %680 = insertvalue { ptr, ptr, ptr, i32 } %679, ptr %.sroa.6.0563.i607, 1
  %681 = insertvalue { ptr, ptr, ptr, i32 } %680, ptr %.sroa.12.0562.i608, 2
  %682 = insertvalue { ptr, ptr, ptr, i32 } %681, i32 %.sroa.17.0561.i609, 3
  %683 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i606)
  %684 = sext i32 %.sroa.17.0561.i609 to i64
  %685 = getelementptr ptr, ptr %.sroa.0.0564.i606, i64 %684
  %686 = getelementptr i8, ptr %685, i64 64
  %687 = load ptr, ptr %686, align 8
  %result.i125.i610 = call ptr %687({ ptr, ptr, ptr, i32 } %682, ptr nocapture nofree noundef nonnull readonly %2) #15
  %688 = call i32 %result.i125.i610({ ptr, ptr, ptr, i32 } %682, { ptr, ptr, ptr, i32 } %682, ptr nonnull align 8 %2) #7
  br i1 %.070565.i605, label %689, label %705

689:                                              ; preds = %674
  %690 = load i32, ptr %22, align 8
  %691 = add i32 %690, -1
  %692 = and i32 %691, %688
  %693 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %694 = load ptr, ptr %23, align 8
  %695 = sext i32 %692 to i64
  %696 = shl nsw i64 %695, 5
  %697 = getelementptr i8, ptr %694, i64 %696
  %698 = load ptr, ptr %697, align 8
  %699 = getelementptr i8, ptr %697, i64 8
  %700 = load i160, ptr %699, align 4
  store ptr %.sroa.0.0564.i606, ptr %697, align 8
  store i64 %677, ptr %699, align 4
  %.sroa_idx157.i653 = getelementptr i8, ptr %697, i64 16
  store i64 %676, ptr %.sroa_idx157.i653, align 4
  %.sroa_idx158.i654 = getelementptr i8, ptr %697, i64 24
  store i32 %.sroa.17.0561.i609, ptr %.sroa_idx158.i654, align 4
  %701 = icmp ne ptr %698, @nil_typ
  %702 = icmp ne ptr %698, null
  %.not92.i655 = and i1 %701, %702
  %extract.i657 = lshr i160 %700, 64
  %703 = insertelement <2 x i160> poison, i160 %700, i64 0
  %704 = insertelement <2 x i160> %703, i160 %extract.i657, i64 1
  br i1 %.not92.i655, label %.cont.cont.i624, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.thread

705:                                              ; preds = %674
  %706 = add i32 %688, 2127912214
  %707 = shl i32 %688, 12
  %708 = add i32 %706, %707
  %709 = ashr i32 %708, 19
  %710 = xor i32 %708, %709
  %711 = xor i32 %710, -949894596
  %712 = add i32 %711, 374761393
  %713 = shl i32 %711, 5
  %714 = add i32 %712, %713
  %715 = add i32 %714, -744332180
  %716 = shl i32 %714, 9
  %717 = xor i32 %715, %716
  %718 = add i32 %717, -42973499
  %719 = shl i32 %717, 3
  %720 = add i32 %718, %719
  %721 = ashr i32 %720, 16
  %722 = xor i32 %720, %721
  %723 = xor i32 %722, -1252372727
  %724 = load i32, ptr %22, align 8
  %725 = add i32 %724, -1
  %726 = and i32 %725, %723
  %727 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %728 = load ptr, ptr %24, align 8
  %729 = sext i32 %726 to i64
  %730 = shl nsw i64 %729, 5
  %731 = getelementptr i8, ptr %728, i64 %730
  %732 = load ptr, ptr %731, align 8
  %733 = getelementptr i8, ptr %731, i64 8
  %734 = load i160, ptr %733, align 4
  store ptr %.sroa.0.0564.i606, ptr %731, align 8
  store i64 %677, ptr %733, align 4
  %.sroa_idx161.i614 = getelementptr i8, ptr %731, i64 16
  store i64 %676, ptr %.sroa_idx161.i614, align 4
  %.sroa_idx162.i615 = getelementptr i8, ptr %731, i64 24
  store i32 %.sroa.17.0561.i609, ptr %.sroa_idx162.i615, align 4
  %735 = icmp ne ptr %732, @nil_typ
  %736 = icmp ne ptr %732, null
  %.not90.i616 = and i1 %735, %736
  %extract607.i618 = lshr i160 %734, 64
  %737 = insertelement <2 x i160> poison, i160 %734, i64 0
  %738 = insertelement <2 x i160> %737, i160 %extract607.i618, i64 1
  br i1 %.not90.i616, label %.cont.cont.i624, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.thread

.cont.cont.i624:                                  ; preds = %705, %689
  %vptr.i142.sroa.speculated.i627 = phi ptr [ %698, %689 ], [ %732, %705 ]
  %.in1529 = phi <2 x i160> [ %704, %689 ], [ %738, %705 ]
  %739 = trunc <2 x i160> %.in1529 to <2 x i64>
  %740 = xor i1 %.070565.i605, true
  %hash_coef_ptr.i.i143.i630 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i627, i64 8
  %tbl_size_ptr.i.i144.i631 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i627, i64 16
  %offset_tbl_ptr.i.i145.i632 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i627, i64 40
  %hash_coef.i.i146.i633 = load i64, ptr %hash_coef_ptr.i.i143.i630, align 4
  %tbl_size.i.i147.i634 = load i64, ptr %tbl_size_ptr.i.i144.i631, align 4
  %offset_tbl.i.i148.i635 = load ptr, ptr %offset_tbl_ptr.i.i145.i632, align 8
  %product.i.i.i149.i636 = mul i64 %hash_coef.i.i146.i633, 4015701072841558310
  %shifted.i.i.i150.i637 = lshr i64 %product.i.i.i149.i636, 32
  %xored.i.i.i151.i638 = xor i64 %shifted.i.i.i150.i637, %product.i.i.i149.i636
  %hash.i.i.i152.i639 = and i64 %xored.i.i.i151.i638, %tbl_size.i.i147.i634
  %offset_ptr.i.i153.i640 = getelementptr i32, ptr %offset_tbl.i.i148.i635, i64 %hash.i.i.i152.i639
  %offset.i.i154.i641 = load i32, ptr %offset_ptr.i.i153.i640, align 4
  %741 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %742 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %743 = icmp ult i32 %.0566.i604, 99
  br i1 %743, label %674, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.thread: ; preds = %689, %705
  %744 = phi ptr [ %12, %705 ], [ %11, %689 ]
  %745 = load i32, ptr %27, align 4
  store i32 %745, ptr %744, align 4
  %746 = add i32 %745, 1
  %747 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %746, ptr %27, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659: ; preds = %.cont.cont.i624
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  %748 = icmp eq ptr %vptr.i142.sroa.speculated.i627, null
  br i1 %748, label %HashMap_insert_keyK_valueV.exit, label %749

749:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659
  %750 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %751 = load ptr, ptr %23, align 8
  %752 = load ptr, ptr %24, align 8
  %753 = load i32, ptr %22, align 8
  %754 = shl i32 %753, 1
  %spec.select.i675 = call i32 @llvm.smax.i32(i32 %754, i32 16)
  store i32 %spec.select.i675, ptr %22, align 8
  %755 = zext nneg i32 %spec.select.i675 to i64
  %756 = shl nuw nsw i64 %755, 5
  %result.i.i676 = call noalias ptr @bump_malloc_inner(i64 noundef %756, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i676, ptr %23, align 8
  %result.i20.i677 = call noalias ptr @bump_malloc_inner(i64 noundef %756, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i677, ptr %24, align 8
  store i32 0, ptr %27, align 4
  %757 = icmp sgt i32 %753, 0
  br i1 %757, label %.lr.ph.i1038, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.thread: ; preds = %749
  %758 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit

.lr.ph.i1038:                                     ; preds = %749, %._crit_edge.i1053
  %.060.i1051 = phi i32 [ %847, %._crit_edge.i1053 ], [ 0, %749 ]
  %759 = zext nneg i32 %.060.i1051 to i64
  %760 = shl nuw nsw i64 %759, 5
  %761 = getelementptr i8, ptr %751, i64 %760
  %762 = load ptr, ptr %761, align 8
  %763 = icmp ne ptr %762, @nil_typ
  %764 = icmp ne ptr %762, null
  %.not16.i1052 = and i1 %763, %764
  br i1 %.not16.i1052, label %765, label %._crit_edge.i1053

765:                                              ; preds = %.lr.ph.i1038
  %766 = getelementptr i8, ptr %761, i64 8
  %767 = load <2 x i64>, ptr %766, align 4
  %hash_coef_ptr.i.i18.i1055 = getelementptr i8, ptr %762, i64 8
  %tbl_size_ptr.i.i19.i1056 = getelementptr i8, ptr %762, i64 16
  %offset_tbl_ptr.i.i20.i1057 = getelementptr i8, ptr %762, i64 40
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i1257 = load i64, ptr %hash_coef_ptr.i.i18.i1055, align 4, !noalias !22
  %tbl_size.i.i100.i1258 = load i64, ptr %tbl_size_ptr.i.i19.i1056, align 4, !noalias !22
  %offset_tbl.i.i101.i1259 = load ptr, ptr %offset_tbl_ptr.i.i20.i1057, align 8, !noalias !22
  %product.i.i.i102.i1260 = mul i64 %hash_coef.i.i99.i1257, 4015701072841558310
  %shifted.i.i.i103.i1261 = lshr i64 %product.i.i.i102.i1260, 32
  %xored.i.i.i104.i1262 = xor i64 %shifted.i.i.i103.i1261, %product.i.i.i102.i1260
  %hash.i.i.i105.i1263 = and i64 %xored.i.i.i104.i1262, %tbl_size.i.i100.i1258
  %offset_ptr.i.i106.i1264 = getelementptr i32, ptr %offset_tbl.i.i101.i1259, i64 %hash.i.i.i105.i1263
  %offset.i.i121.i1265 = load i32, ptr %offset_ptr.i.i106.i1264, align 4, !noalias !149
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %770 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %771 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %772

772:                                              ; preds = %.cont.cont.i1286, %765
  %.0566.i1266 = phi i32 [ 0, %765 ], [ %776, %.cont.cont.i1286 ]
  %.070565.i1267 = phi i1 [ true, %765 ], [ %838, %.cont.cont.i1286 ]
  %.sroa.0.0564.i1268 = phi ptr [ %762, %765 ], [ %vptr.i142.sroa.speculated.i1289, %.cont.cont.i1286 ]
  %.sroa.17.0561.i1271 = phi i32 [ %offset.i.i121.i1265, %765 ], [ %offset.i.i154.i1303, %.cont.cont.i1286 ]
  %773 = phi <2 x i64> [ %767, %765 ], [ %837, %.cont.cont.i1286 ]
  %774 = extractelement <2 x i64> %773, i64 1
  %.sroa.12.0562.i1270 = inttoptr i64 %774 to ptr
  %775 = extractelement <2 x i64> %773, i64 0
  %.sroa.6.0563.i1269 = inttoptr i64 %775 to ptr
  %776 = add nuw nsw i32 %.0566.i1266, 1
  %777 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1268, 0
  %778 = insertvalue { ptr, ptr, ptr, i32 } %777, ptr %.sroa.6.0563.i1269, 1
  %779 = insertvalue { ptr, ptr, ptr, i32 } %778, ptr %.sroa.12.0562.i1270, 2
  %780 = insertvalue { ptr, ptr, ptr, i32 } %779, i32 %.sroa.17.0561.i1271, 3
  %781 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1268)
  %782 = sext i32 %.sroa.17.0561.i1271 to i64
  %783 = getelementptr ptr, ptr %.sroa.0.0564.i1268, i64 %782
  %784 = getelementptr i8, ptr %783, i64 64
  %785 = load ptr, ptr %784, align 8
  %result.i125.i1272 = call ptr %785({ ptr, ptr, ptr, i32 } %780, ptr nocapture nofree noundef nonnull readonly %2) #15
  %786 = call i32 %result.i125.i1272({ ptr, ptr, ptr, i32 } %780, { ptr, ptr, ptr, i32 } %780, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1267, label %787, label %803

787:                                              ; preds = %772
  %788 = load i32, ptr %22, align 8
  %789 = add i32 %788, -1
  %790 = and i32 %789, %786
  %791 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %792 = load ptr, ptr %23, align 8
  %793 = sext i32 %790 to i64
  %794 = shl nsw i64 %793, 5
  %795 = getelementptr i8, ptr %792, i64 %794
  %796 = load ptr, ptr %795, align 8
  %797 = getelementptr i8, ptr %795, i64 8
  %798 = load i160, ptr %797, align 4
  store ptr %.sroa.0.0564.i1268, ptr %795, align 8
  store i64 %775, ptr %797, align 4
  %.sroa_idx157.i1315 = getelementptr i8, ptr %795, i64 16
  store i64 %774, ptr %.sroa_idx157.i1315, align 4
  %.sroa_idx158.i1316 = getelementptr i8, ptr %795, i64 24
  store i32 %.sroa.17.0561.i1271, ptr %.sroa_idx158.i1316, align 4
  %799 = icmp ne ptr %796, @nil_typ
  %800 = icmp ne ptr %796, null
  %.not92.i1317 = and i1 %799, %800
  %extract.i1319 = lshr i160 %798, 64
  %801 = insertelement <2 x i160> poison, i160 %798, i64 0
  %802 = insertelement <2 x i160> %801, i160 %extract.i1319, i64 1
  br i1 %.not92.i1317, label %.cont.cont.i1286, label %842

803:                                              ; preds = %772
  %804 = add i32 %786, 2127912214
  %805 = shl i32 %786, 12
  %806 = add i32 %804, %805
  %807 = ashr i32 %806, 19
  %808 = xor i32 %806, %807
  %809 = xor i32 %808, -949894596
  %810 = add i32 %809, 374761393
  %811 = shl i32 %809, 5
  %812 = add i32 %810, %811
  %813 = add i32 %812, -744332180
  %814 = shl i32 %812, 9
  %815 = xor i32 %813, %814
  %816 = add i32 %815, -42973499
  %817 = shl i32 %815, 3
  %818 = add i32 %816, %817
  %819 = ashr i32 %818, 16
  %820 = xor i32 %818, %819
  %821 = xor i32 %820, -1252372727
  %822 = load i32, ptr %22, align 8
  %823 = add i32 %822, -1
  %824 = and i32 %823, %821
  %825 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %826 = load ptr, ptr %24, align 8
  %827 = sext i32 %824 to i64
  %828 = shl nsw i64 %827, 5
  %829 = getelementptr i8, ptr %826, i64 %828
  %830 = load ptr, ptr %829, align 8
  %831 = getelementptr i8, ptr %829, i64 8
  %832 = load i160, ptr %831, align 4
  store ptr %.sroa.0.0564.i1268, ptr %829, align 8
  store i64 %775, ptr %831, align 4
  %.sroa_idx161.i1276 = getelementptr i8, ptr %829, i64 16
  store i64 %774, ptr %.sroa_idx161.i1276, align 4
  %.sroa_idx162.i1277 = getelementptr i8, ptr %829, i64 24
  store i32 %.sroa.17.0561.i1271, ptr %.sroa_idx162.i1277, align 4
  %833 = icmp ne ptr %830, @nil_typ
  %834 = icmp ne ptr %830, null
  %.not90.i1278 = and i1 %833, %834
  %extract607.i1280 = lshr i160 %832, 64
  %835 = insertelement <2 x i160> poison, i160 %832, i64 0
  %836 = insertelement <2 x i160> %835, i160 %extract607.i1280, i64 1
  br i1 %.not90.i1278, label %.cont.cont.i1286, label %842

.cont.cont.i1286:                                 ; preds = %803, %787
  %vptr.i142.sroa.speculated.i1289 = phi ptr [ %796, %787 ], [ %830, %803 ]
  %.in1530 = phi <2 x i160> [ %802, %787 ], [ %836, %803 ]
  %837 = trunc <2 x i160> %.in1530 to <2 x i64>
  %838 = xor i1 %.070565.i1267, true
  %hash_coef_ptr.i.i143.i1292 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1289, i64 8
  %tbl_size_ptr.i.i144.i1293 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1289, i64 16
  %offset_tbl_ptr.i.i145.i1294 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1289, i64 40
  %hash_coef.i.i146.i1295 = load i64, ptr %hash_coef_ptr.i.i143.i1292, align 4
  %tbl_size.i.i147.i1296 = load i64, ptr %tbl_size_ptr.i.i144.i1293, align 4
  %offset_tbl.i.i148.i1297 = load ptr, ptr %offset_tbl_ptr.i.i145.i1294, align 8
  %product.i.i.i149.i1298 = mul i64 %hash_coef.i.i146.i1295, 4015701072841558310
  %shifted.i.i.i150.i1299 = lshr i64 %product.i.i.i149.i1298, 32
  %xored.i.i.i151.i1300 = xor i64 %shifted.i.i.i150.i1299, %product.i.i.i149.i1298
  %hash.i.i.i152.i1301 = and i64 %xored.i.i.i151.i1300, %tbl_size.i.i147.i1296
  %offset_ptr.i.i153.i1302 = getelementptr i32, ptr %offset_tbl.i.i148.i1297, i64 %hash.i.i.i152.i1301
  %offset.i.i154.i1303 = load i32, ptr %offset_ptr.i.i153.i1302, align 4
  %839 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %840 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %841 = icmp ult i32 %.0566.i1266, 99
  br i1 %841, label %772, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1321

842:                                              ; preds = %803, %787
  %843 = phi ptr [ %6, %803 ], [ %5, %787 ]
  %844 = load i32, ptr %27, align 4
  store i32 %844, ptr %843, align 4
  %845 = add i32 %844, 1
  %846 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %845, ptr %27, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1321

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1321: ; preds = %.cont.cont.i1286, %842
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i1053

._crit_edge.i1053:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1321, %.lr.ph.i1038
  %847 = add nuw nsw i32 %.060.i1051, 1
  %848 = icmp slt i32 %847, %753
  br i1 %848, label %.lr.ph.i1038, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071: ; preds = %._crit_edge.i1053
  %849 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %850

850:                                              ; preds = %._crit_edge.i1089, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071
  %.060.i1087 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071 ], [ %939, %._crit_edge.i1089 ]
  %851 = zext nneg i32 %.060.i1087 to i64
  %852 = shl nuw nsw i64 %851, 5
  %853 = getelementptr i8, ptr %752, i64 %852
  %854 = load ptr, ptr %853, align 8
  %855 = icmp ne ptr %854, @nil_typ
  %856 = icmp ne ptr %854, null
  %.not16.i1088 = and i1 %855, %856
  br i1 %.not16.i1088, label %857, label %._crit_edge.i1089

857:                                              ; preds = %850
  %858 = getelementptr i8, ptr %853, i64 8
  %859 = load <2 x i64>, ptr %858, align 4
  %hash_coef_ptr.i.i18.i1091 = getelementptr i8, ptr %854, i64 8
  %tbl_size_ptr.i.i19.i1092 = getelementptr i8, ptr %854, i64 16
  %offset_tbl_ptr.i.i20.i1093 = getelementptr i8, ptr %854, i64 40
  %860 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i1339 = load i64, ptr %hash_coef_ptr.i.i18.i1091, align 4, !noalias !22
  %tbl_size.i.i100.i1340 = load i64, ptr %tbl_size_ptr.i.i19.i1092, align 4, !noalias !22
  %offset_tbl.i.i101.i1341 = load ptr, ptr %offset_tbl_ptr.i.i20.i1093, align 8, !noalias !22
  %product.i.i.i102.i1342 = mul i64 %hash_coef.i.i99.i1339, 4015701072841558310
  %shifted.i.i.i103.i1343 = lshr i64 %product.i.i.i102.i1342, 32
  %xored.i.i.i104.i1344 = xor i64 %shifted.i.i.i103.i1343, %product.i.i.i102.i1342
  %hash.i.i.i105.i1345 = and i64 %xored.i.i.i104.i1344, %tbl_size.i.i100.i1340
  %offset_ptr.i.i106.i1346 = getelementptr i32, ptr %offset_tbl.i.i101.i1341, i64 %hash.i.i.i105.i1345
  %offset.i.i121.i1347 = load i32, ptr %offset_ptr.i.i106.i1346, align 4, !noalias !152
  %861 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %862 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %863 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %864

864:                                              ; preds = %.cont.cont.i1368, %857
  %.0566.i1348 = phi i32 [ 0, %857 ], [ %868, %.cont.cont.i1368 ]
  %.070565.i1349 = phi i1 [ true, %857 ], [ %930, %.cont.cont.i1368 ]
  %.sroa.0.0564.i1350 = phi ptr [ %854, %857 ], [ %vptr.i142.sroa.speculated.i1371, %.cont.cont.i1368 ]
  %.sroa.17.0561.i1353 = phi i32 [ %offset.i.i121.i1347, %857 ], [ %offset.i.i154.i1385, %.cont.cont.i1368 ]
  %865 = phi <2 x i64> [ %859, %857 ], [ %929, %.cont.cont.i1368 ]
  %866 = extractelement <2 x i64> %865, i64 1
  %.sroa.12.0562.i1352 = inttoptr i64 %866 to ptr
  %867 = extractelement <2 x i64> %865, i64 0
  %.sroa.6.0563.i1351 = inttoptr i64 %867 to ptr
  %868 = add nuw nsw i32 %.0566.i1348, 1
  %869 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1350, 0
  %870 = insertvalue { ptr, ptr, ptr, i32 } %869, ptr %.sroa.6.0563.i1351, 1
  %871 = insertvalue { ptr, ptr, ptr, i32 } %870, ptr %.sroa.12.0562.i1352, 2
  %872 = insertvalue { ptr, ptr, ptr, i32 } %871, i32 %.sroa.17.0561.i1353, 3
  %873 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1350)
  %874 = sext i32 %.sroa.17.0561.i1353 to i64
  %875 = getelementptr ptr, ptr %.sroa.0.0564.i1350, i64 %874
  %876 = getelementptr i8, ptr %875, i64 64
  %877 = load ptr, ptr %876, align 8
  %result.i125.i1354 = call ptr %877({ ptr, ptr, ptr, i32 } %872, ptr nocapture nofree noundef nonnull readonly %2) #15
  %878 = call i32 %result.i125.i1354({ ptr, ptr, ptr, i32 } %872, { ptr, ptr, ptr, i32 } %872, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1349, label %879, label %895

879:                                              ; preds = %864
  %880 = load i32, ptr %22, align 8
  %881 = add i32 %880, -1
  %882 = and i32 %881, %878
  %883 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %884 = load ptr, ptr %23, align 8
  %885 = sext i32 %882 to i64
  %886 = shl nsw i64 %885, 5
  %887 = getelementptr i8, ptr %884, i64 %886
  %888 = load ptr, ptr %887, align 8
  %889 = getelementptr i8, ptr %887, i64 8
  %890 = load i160, ptr %889, align 4
  store ptr %.sroa.0.0564.i1350, ptr %887, align 8
  store i64 %867, ptr %889, align 4
  %.sroa_idx157.i1397 = getelementptr i8, ptr %887, i64 16
  store i64 %866, ptr %.sroa_idx157.i1397, align 4
  %.sroa_idx158.i1398 = getelementptr i8, ptr %887, i64 24
  store i32 %.sroa.17.0561.i1353, ptr %.sroa_idx158.i1398, align 4
  %891 = icmp ne ptr %888, @nil_typ
  %892 = icmp ne ptr %888, null
  %.not92.i1399 = and i1 %891, %892
  %extract.i1401 = lshr i160 %890, 64
  %893 = insertelement <2 x i160> poison, i160 %890, i64 0
  %894 = insertelement <2 x i160> %893, i160 %extract.i1401, i64 1
  br i1 %.not92.i1399, label %.cont.cont.i1368, label %934

895:                                              ; preds = %864
  %896 = add i32 %878, 2127912214
  %897 = shl i32 %878, 12
  %898 = add i32 %896, %897
  %899 = ashr i32 %898, 19
  %900 = xor i32 %898, %899
  %901 = xor i32 %900, -949894596
  %902 = add i32 %901, 374761393
  %903 = shl i32 %901, 5
  %904 = add i32 %902, %903
  %905 = add i32 %904, -744332180
  %906 = shl i32 %904, 9
  %907 = xor i32 %905, %906
  %908 = add i32 %907, -42973499
  %909 = shl i32 %907, 3
  %910 = add i32 %908, %909
  %911 = ashr i32 %910, 16
  %912 = xor i32 %910, %911
  %913 = xor i32 %912, -1252372727
  %914 = load i32, ptr %22, align 8
  %915 = add i32 %914, -1
  %916 = and i32 %915, %913
  %917 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %918 = load ptr, ptr %24, align 8
  %919 = sext i32 %916 to i64
  %920 = shl nsw i64 %919, 5
  %921 = getelementptr i8, ptr %918, i64 %920
  %922 = load ptr, ptr %921, align 8
  %923 = getelementptr i8, ptr %921, i64 8
  %924 = load i160, ptr %923, align 4
  store ptr %.sroa.0.0564.i1350, ptr %921, align 8
  store i64 %867, ptr %923, align 4
  %.sroa_idx161.i1358 = getelementptr i8, ptr %921, i64 16
  store i64 %866, ptr %.sroa_idx161.i1358, align 4
  %.sroa_idx162.i1359 = getelementptr i8, ptr %921, i64 24
  store i32 %.sroa.17.0561.i1353, ptr %.sroa_idx162.i1359, align 4
  %925 = icmp ne ptr %922, @nil_typ
  %926 = icmp ne ptr %922, null
  %.not90.i1360 = and i1 %925, %926
  %extract607.i1362 = lshr i160 %924, 64
  %927 = insertelement <2 x i160> poison, i160 %924, i64 0
  %928 = insertelement <2 x i160> %927, i160 %extract607.i1362, i64 1
  br i1 %.not90.i1360, label %.cont.cont.i1368, label %934

.cont.cont.i1368:                                 ; preds = %895, %879
  %vptr.i142.sroa.speculated.i1371 = phi ptr [ %888, %879 ], [ %922, %895 ]
  %.in1531 = phi <2 x i160> [ %894, %879 ], [ %928, %895 ]
  %929 = trunc <2 x i160> %.in1531 to <2 x i64>
  %930 = xor i1 %.070565.i1349, true
  %hash_coef_ptr.i.i143.i1374 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1371, i64 8
  %tbl_size_ptr.i.i144.i1375 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1371, i64 16
  %offset_tbl_ptr.i.i145.i1376 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1371, i64 40
  %hash_coef.i.i146.i1377 = load i64, ptr %hash_coef_ptr.i.i143.i1374, align 4
  %tbl_size.i.i147.i1378 = load i64, ptr %tbl_size_ptr.i.i144.i1375, align 4
  %offset_tbl.i.i148.i1379 = load ptr, ptr %offset_tbl_ptr.i.i145.i1376, align 8
  %product.i.i.i149.i1380 = mul i64 %hash_coef.i.i146.i1377, 4015701072841558310
  %shifted.i.i.i150.i1381 = lshr i64 %product.i.i.i149.i1380, 32
  %xored.i.i.i151.i1382 = xor i64 %shifted.i.i.i150.i1381, %product.i.i.i149.i1380
  %hash.i.i.i152.i1383 = and i64 %xored.i.i.i151.i1382, %tbl_size.i.i147.i1378
  %offset_ptr.i.i153.i1384 = getelementptr i32, ptr %offset_tbl.i.i148.i1379, i64 %hash.i.i.i152.i1383
  %offset.i.i154.i1385 = load i32, ptr %offset_ptr.i.i153.i1384, align 4
  %931 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %932 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %933 = icmp ult i32 %.0566.i1348, 99
  br i1 %933, label %864, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1403

934:                                              ; preds = %895, %879
  %935 = phi ptr [ %4, %895 ], [ %3, %879 ]
  %936 = load i32, ptr %27, align 4
  store i32 %936, ptr %935, align 4
  %937 = add i32 %936, 1
  %938 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %937, ptr %27, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1403

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1403: ; preds = %.cont.cont.i1368, %934
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i1089

._crit_edge.i1089:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1403, %850
  %939 = add nuw nsw i32 %.060.i1087, 1
  %940 = icmp slt i32 %939, %753
  br i1 %940, label %850, label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %._crit_edge.i1089, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit522, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %941 = add i64 %.0139257, %33
  %942 = icmp slt i32 %32, %0
  br i1 %942, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %HashMap_insert_keyK_valueV.exit
  %943 = call i64 @clock()
  br label %944

944:                                              ; preds = %.lr.ph, %._crit_edge2
  %.2262 = phi i32 [ 0, %.lr.ph ], [ %1071, %._crit_edge2 ]
  %.0141261 = phi i64 [ 0, %.lr.ph ], [ %.2143, %._crit_edge2 ]
  %.0144260 = phi i1 [ true, %.lr.ph ], [ %.2146, %._crit_edge2 ]
  %.sroa.0117.0.insert.ext = zext nneg i32 %.2262 to i160
  %945 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext, 1
  %946 = load ptr, ptr %20, align 8
  %947 = call i32 %946({ ptr, i160 } %945) #7
  %948 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %949 = load i32, ptr %22, align 8
  %950 = add i32 %949, -1
  %951 = and i32 %950, %947
  %952 = load ptr, ptr %23, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %953 = sext i32 %951 to i64
  %954 = shl nsw i64 %953, 5
  %955 = getelementptr i8, ptr %952, i64 %954
  %956 = load ptr, ptr %955, align 8
  %957 = icmp ne ptr %956, @nil_typ
  %958 = icmp ne ptr %956, null
  %.not44.i = and i1 %957, %958
  br i1 %.not44.i, label %959, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

959:                                              ; preds = %944
  %960 = getelementptr i8, ptr %955, i64 8
  %961 = load i64, ptr %960, align 4
  %.sroa_idx.i720 = getelementptr i8, ptr %955, i64 16
  %962 = load i64, ptr %.sroa_idx.i720, align 4
  %963 = inttoptr i64 %961 to ptr
  %964 = inttoptr i64 %962 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %956, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %956, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %956, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !155
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !155
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !155
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !155
  %965 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %956, 0
  %966 = insertvalue { ptr, ptr, ptr, i32 } %965, ptr %963, 1
  %967 = insertvalue { ptr, ptr, ptr, i32 } %966, ptr %964, 2
  %968 = insertvalue { ptr, ptr, ptr, i32 } %967, i32 %offset.i.i57.i, 3
  %969 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %970 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %956) #34
  %971 = sext i32 %offset.i.i57.i to i64
  %972 = getelementptr ptr, ptr %956, i64 %971
  %973 = getelementptr i8, ptr %972, i64 64
  %974 = load ptr, ptr %973, align 8
  %result.i.i721 = call ptr %974({ ptr, ptr, ptr, i32 } %968, ptr nocapture nofree noundef nonnull readonly %2) #15
  %975 = call i32 %result.i.i721({ ptr, ptr, ptr, i32 } %968, { ptr, ptr, ptr, i32 } %968, ptr nonnull align 8 %2) #7
  %976 = icmp eq i32 %975, %947
  br i1 %976, label %._crit_edge.i722, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i722:                                 ; preds = %959
  %977 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %956)
  %979 = getelementptr i8, ptr %972, i64 48
  %980 = load ptr, ptr %979, align 8
  %result.i59.i = call ptr %980({ ptr, ptr, ptr, i32 } %968, ptr nocapture nofree noundef nonnull readonly %2) #15
  %981 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %968, { ptr, ptr, ptr, i32 } %968, ptr nonnull align 8 %2) #7
  %982 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %983 = load ptr, ptr %21, align 8
  %984 = call i1 %983({ ptr, i160 } %981, { ptr, i160 } %945) #7
  br i1 %984, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i722, %944, %959
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %993

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i722
  %985 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %986 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %956)
  %987 = getelementptr i8, ptr %972, i64 56
  %988 = load ptr, ptr %987, align 8
  %result.i60.i = call ptr %988({ ptr, ptr, ptr, i32 } %968, ptr nocapture nofree noundef nonnull readonly %2) #15
  %989 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %968, { ptr, ptr, ptr, i32 } %968, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %989, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %991 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %992 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %991, %992
  br i1 %.not63.i, label %HashMap_get_keyK.exit, label %993

993:                                              ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %994 = add i32 %947, 2127912214
  %995 = shl i32 %947, 12
  %996 = add i32 %994, %995
  %997 = ashr i32 %996, 19
  %998 = xor i32 %996, %997
  %999 = xor i32 %998, -949894596
  %1000 = add i32 %999, 374761393
  %1001 = shl i32 %999, 5
  %1002 = add i32 %1000, %1001
  %1003 = add i32 %1002, -744332180
  %1004 = shl i32 %1002, 9
  %1005 = xor i32 %1003, %1004
  %1006 = add i32 %1005, -42973499
  %1007 = shl i32 %1005, 3
  %1008 = add i32 %1006, %1007
  %1009 = ashr i32 %1008, 16
  %1010 = xor i32 %1008, %1009
  %1011 = xor i32 %1010, -1252372727
  %1012 = load i32, ptr %22, align 8
  %1013 = add i32 %1012, -1
  %1014 = and i32 %1013, %1011
  %1015 = load ptr, ptr %24, align 8
  %1016 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1017 = sext i32 %1014 to i64
  %1018 = shl nsw i64 %1017, 5
  %1019 = getelementptr i8, ptr %1015, i64 %1018
  %1020 = load ptr, ptr %1019, align 8
  %1021 = icmp ne ptr %1020, @nil_typ
  %1022 = icmp ne ptr %1020, null
  %.not44.i752 = and i1 %1021, %1022
  br i1 %.not44.i752, label %1023, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776

1023:                                             ; preds = %993
  %1024 = getelementptr i8, ptr %1019, i64 8
  %1025 = load i64, ptr %1024, align 4
  %.sroa_idx.i756 = getelementptr i8, ptr %1019, i64 16
  %1026 = load i64, ptr %.sroa_idx.i756, align 4
  %1027 = inttoptr i64 %1025 to ptr
  %1028 = inttoptr i64 %1026 to ptr
  %hash_coef_ptr.i.i46.i757 = getelementptr i8, ptr %1020, i64 8
  %tbl_size_ptr.i.i47.i758 = getelementptr i8, ptr %1020, i64 16
  %offset_tbl_ptr.i.i48.i759 = getelementptr i8, ptr %1020, i64 40
  %hash_coef.i.i49.i760 = load i64, ptr %hash_coef_ptr.i.i46.i757, align 4, !noalias !158
  %tbl_size.i.i50.i761 = load i64, ptr %tbl_size_ptr.i.i47.i758, align 4, !noalias !158
  %offset_tbl.i.i51.i762 = load ptr, ptr %offset_tbl_ptr.i.i48.i759, align 8, !noalias !158
  %product.i.i.i52.i763 = mul i64 %hash_coef.i.i49.i760, 4015701072841558310
  %shifted.i.i.i53.i764 = lshr i64 %product.i.i.i52.i763, 32
  %xored.i.i.i54.i765 = xor i64 %shifted.i.i.i53.i764, %product.i.i.i52.i763
  %hash.i.i.i55.i766 = and i64 %xored.i.i.i54.i765, %tbl_size.i.i50.i761
  %offset_ptr.i.i56.i767 = getelementptr i32, ptr %offset_tbl.i.i51.i762, i64 %hash.i.i.i55.i766
  %offset.i.i57.i768 = load i32, ptr %offset_ptr.i.i56.i767, align 4, !noalias !158
  %1029 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1020, 0
  %1030 = insertvalue { ptr, ptr, ptr, i32 } %1029, ptr %1027, 1
  %1031 = insertvalue { ptr, ptr, ptr, i32 } %1030, ptr %1028, 2
  %1032 = insertvalue { ptr, ptr, ptr, i32 } %1031, i32 %offset.i.i57.i768, 3
  %1033 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1034 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1020) #34
  %1035 = sext i32 %offset.i.i57.i768 to i64
  %1036 = getelementptr ptr, ptr %1020, i64 %1035
  %1037 = getelementptr i8, ptr %1036, i64 64
  %1038 = load ptr, ptr %1037, align 8
  %result.i.i769 = call ptr %1038({ ptr, ptr, ptr, i32 } %1032, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1039 = call i32 %result.i.i769({ ptr, ptr, ptr, i32 } %1032, { ptr, ptr, ptr, i32 } %1032, ptr nonnull align 8 %2) #7
  %1040 = icmp eq i32 %1039, %947
  br i1 %1040, label %._crit_edge.i770, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776

._crit_edge.i770:                                 ; preds = %1023
  %1041 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1042 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1020)
  %1043 = getelementptr i8, ptr %1036, i64 48
  %1044 = load ptr, ptr %1043, align 8
  %result.i59.i771 = call ptr %1044({ ptr, ptr, ptr, i32 } %1032, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1045 = call { ptr, i160 } %result.i59.i771({ ptr, ptr, ptr, i32 } %1032, { ptr, ptr, ptr, i32 } %1032, ptr nonnull align 8 %2) #7
  %1046 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1047 = load ptr, ptr %21, align 8
  %1048 = call i1 %1047({ ptr, i160 } %1045, { ptr, i160 } %945) #7
  br i1 %1048, label %1049, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776

1049:                                             ; preds = %._crit_edge.i770
  %1050 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1051 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1020)
  %1052 = getelementptr i8, ptr %1036, i64 56
  %1053 = load ptr, ptr %1052, align 8
  %result.i60.i773 = call ptr %1053({ ptr, ptr, ptr, i32 } %1032, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1054 = call { ptr, i160 } %result.i60.i773({ ptr, ptr, ptr, i32 } %1032, { ptr, ptr, ptr, i32 } %1032, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i774 = extractvalue { ptr, i160 } %1054, 0
  %.fca.1.extract22.i775 = extractvalue { ptr, i160 } %1054, 1
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776: ; preds = %993, %1023, %._crit_edge.i770, %1049
  %.reg2mem43.sroa.3.077.i753 = phi i160 [ %.fca.1.extract22.i775, %1049 ], [ poison, %._crit_edge.i770 ], [ poison, %993 ], [ poison, %1023 ]
  %1055 = phi ptr [ %.fca.0.extract21.i774, %1049 ], [ @nil_typ, %._crit_edge.i770 ], [ @nil_typ, %993 ], [ @nil_typ, %1023 ]
  %.reload40.fca.0.insert.i754 = insertvalue { ptr, i160 } poison, ptr %1055, 0
  %.reload40.fca.1.insert.i755 = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i754, i160 %.reg2mem43.sroa.3.077.i753, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1056 = icmp ne ptr %1055, @nil_typ
  %1057 = icmp ne ptr %1055, null
  %.not65.not.not.i = and i1 %1056, %1057
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %1055, ptr @nil_typ
  br label %HashMap_get_keyK.exit

HashMap_get_keyK.exit:                            ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776
  %.pn.i = phi { ptr, i160 } [ %989, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %.reload40.fca.1.insert.i755, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776 ]
  %1058 = phi ptr [ %.fca.0.extract21.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776 ]
  %1059 = icmp ne ptr %1058, @nil_typ
  %1060 = icmp ne ptr %1058, null
  %.not150 = and i1 %1059, %1060
  br i1 %.not150, label %1061, label %._crit_edge.lr.ph.i

1061:                                             ; preds = %HashMap_get_keyK.exit
  %.fca.1.extract..sroa.354.0101.i = extractvalue { ptr, i160 } %.pn.i, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0101.i to i32
  %1062 = sext i32 %.sroa.2.8.extract.trunc to i64
  %1063 = add i64 %.0141261, %1062
  br label %._crit_edge2

._crit_edge.lr.ph.i:                              ; preds = %HashMap_get_keyK.exit
  %result.i161 = call noalias align 64 dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %1064 = load <55 x i8>, ptr @tvsrx_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  store <55 x i8> %1064, ptr %result.i161, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1065 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1066 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i790 = call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(55) %result.i.i790, ptr noundef nonnull align 64 dereferenceable(55) %result.i161, i64 55, i1 false)
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1068 = getelementptr i8, ptr %result.i.i790, i64 55
  store i8 0, ptr %1068, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i790)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1070 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2262) #16
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %1061, %._crit_edge.lr.ph.i
  %.2146 = phi i1 [ %.0144260, %1061 ], [ false, %._crit_edge.lr.ph.i ]
  %.2143 = phi i64 [ %1063, %1061 ], [ %.0141261, %._crit_edge.lr.ph.i ]
  %1071 = add nuw nsw i32 %.2262, 1
  %1072 = icmp slt i32 %1071, %0
  br i1 %1072, label %944, label %._crit_edge.lr.ph.i806

._crit_edge.lr.ph.i806:                           ; preds = %._crit_edge2, %._crit_edge1._crit_edge.thread
  %1073 = phi i64 [ %31, %._crit_edge1._crit_edge.thread ], [ %943, %._crit_edge2 ]
  %.0139.lcssa270 = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %941, %._crit_edge2 ]
  %.0144.lcssa = phi i1 [ true, %._crit_edge1._crit_edge.thread ], [ %.2146, %._crit_edge2 ]
  %.0141.lcssa = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %.2143, %._crit_edge2 ]
  %1074 = call i64 @clock()
  %result.i167 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i167, align 32
  %1075 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1076 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1077 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i805 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i805, ptr noundef nonnull align 32 dereferenceable(18) %result.i167, i64 18, i1 false)
  %1078 = sub i64 %1074, %1073
  %1079 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1080 = getelementptr i8, ptr %result.i.i805, i64 18
  store i8 0, ptr %1080, align 1
  %puts.i391 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i805)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i376.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376.i)
  %1081 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #16
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i390.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390.i)
  %1082 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1078) #16
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i409.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409.i)
  br i1 %26, label %._crit_edge1.i, label %._crit_edge.lr.ph.i825

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i806
  %1083 = icmp sgt i64 %1078, 0
  br i1 %1083, label %1084, label %._crit_edge.lr.ph.i429.i

1084:                                             ; preds = %._crit_edge1.i
  %1085 = zext nneg i32 %0 to i64
  %1086 = mul i64 %1078, 1000000
  %1087 = sdiv i64 %1086, %1085
  br label %._crit_edge.lr.ph.i429.i

._crit_edge.lr.ph.i429.i:                         ; preds = %1084, %._crit_edge1.i
  %.0.i = phi i64 [ %1087, %1084 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i428.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i)
  %1088 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #16
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %1089 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i447.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i374.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447.i)
  br label %._crit_edge.lr.ph.i825

._crit_edge.lr.ph.i825:                           ; preds = %._crit_edge.lr.ph.i806, %._crit_edge.lr.ph.i429.i
  %.not = icmp eq i64 %.0141.lcssa, %.0139.lcssa270
  %result.i171 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i171, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1091 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1092 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i824 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i824, ptr noundef nonnull align 32 dereferenceable(18) %result.i171, i64 18, i1 false)
  %spec.select = select i1 %.not, i1 %.0144.lcssa, i1 false
  %1093 = getelementptr i8, ptr %result.i.i824, i64 18
  store i8 0, ptr %1093, align 1
  %puts.i411 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i824)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %spec.select, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %1094 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1095 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1096 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i843 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %., ptr %result.i.i843, align 1
  %1097 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1098 = getelementptr i8, ptr %result.i.i843, i64 4
  store i8 0, ptr %1098, align 1
  %puts.i431 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i843)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca i32, align 4
  %28 = alloca i32, align 4
  %29 = alloca i32, align 4
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i32, align 4
  %34 = alloca i32, align 4
  %oldProtect.i332 = alloca i32, align 4
  %oldProtect.i328 = alloca i32, align 4
  %oldProtect.i287 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0224.sroa.0 = alloca i8, align 8
  %result.i283 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i283, align 8
  %35 = getelementptr inbounds i8, ptr %result.i283, i64 8
  store ptr @_parameterization_Ptri32, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i283, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %36, align 8
  %37 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i283) #38
  %result.i284 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i285 = call i32 @VirtualProtect(ptr nofree %result.i284, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i284, ptr noalias nofree noundef nonnull readnone @fxudcdkewt, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i284) #39
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i284) #38
  %result.i286 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i287)
  %result.i288 = call i32 @VirtualProtect(ptr nofree %result.i286, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i287) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i287)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i286, ptr noalias nofree noundef nonnull readnone @jflfzrlbri, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i289 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i286) #39
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i286) #38
  %40 = getelementptr inbounds i8, ptr %result.i283, i64 48
  store ptr %ret.i, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %result.i283, i64 56
  store ptr %ret.i289, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i283, i64 40
  store i32 8, ptr %42, align 8
  %result.i.i541 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %43 = getelementptr inbounds i8, ptr %result.i283, i64 24
  store ptr %result.i.i541, ptr %43, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %44 = getelementptr inbounds i8, ptr %result.i283, i64 32
  store ptr %result.i9.i, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %46 = sext i32 %0 to i64
  %47 = shl nsw i64 %46, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %47, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %result.i326 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i326, align 8
  %49 = getelementptr inbounds i8, ptr %result.i326, i64 8
  store ptr @_parameterization_Ptri1, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i326, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i326)
  %result.i327 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i328)
  %result.i329 = call i32 @VirtualProtect(ptr nofree %result.i327, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i328) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i328)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i327, ptr noalias nofree noundef nonnull readnone @wvqrefvxqs, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i330 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i327) #39
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i327)
  %result.i331 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i332)
  %result.i333 = call i32 @VirtualProtect(ptr nofree %result.i331, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i332) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i332)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i331, ptr noalias nofree noundef nonnull readnone @nzoueoxdzd, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i334 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i331) #39
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i331)
  %54 = getelementptr inbounds i8, ptr %result.i326, i64 48
  store ptr %ret.i330, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i326, i64 56
  store ptr %ret.i334, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %result.i326, i64 40
  store i32 8, ptr %56, align 8
  %result.i.i581 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %57 = getelementptr inbounds i8, ptr %result.i326, i64 24
  store ptr %result.i.i581, ptr %57, align 8
  %result.i9.i582 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %58 = getelementptr inbounds i8, ptr %result.i326, i64 32
  store ptr %result.i9.i582, ptr %58, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %60 = mul i32 %0, 10
  %61 = icmp sgt i32 %0, 0
  %62 = icmp sgt i32 %60, 0
  %spec.select526 = and i1 %61, %62
  br i1 %spec.select526, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %65 = getelementptr inbounds i8, ptr %result.i283, i64 44
  %66 = getelementptr inbounds i8, ptr %result.i326, i64 44
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  br label %68

68:                                               ; preds = %.lr.ph, %._crit_edge1
  %69 = phi i32 [ 456, %.lr.ph ], [ %72, %._crit_edge1 ]
  %.0264529 = phi i32 [ 0, %.lr.ph ], [ %2293, %._crit_edge1 ]
  %.0266528 = phi i32 [ 0, %.lr.ph ], [ %.2268, %._crit_edge1 ]
  %.0275527 = phi i64 [ 0, %.lr.ph ], [ %.2277, %._crit_edge1 ]
  %70 = mul i32 %69, 1103515245
  %71 = add i32 %70, 12345
  %72 = and i32 %71, 2147483647
  %.sroa.0252.0.insert.ext = zext nneg i32 %72 to i160
  %73 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0252.0.insert.ext, 1
  %74 = load ptr, ptr %54, align 8
  %75 = call i32 %74({ ptr, i160 } %73) #7
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %77 = load i32, ptr %56, align 8
  %78 = add i32 %77, -1
  %79 = and i32 %78, %75
  %80 = load ptr, ptr %57, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %81 = sext i32 %79 to i64
  %82 = shl nsw i64 %81, 5
  %83 = getelementptr i8, ptr %80, i64 %82
  %84 = load ptr, ptr %83, align 8
  %85 = icmp ne ptr %84, @nil_typ
  %86 = icmp ne ptr %84, null
  %.not44.i = and i1 %85, %86
  br i1 %.not44.i, label %87, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

87:                                               ; preds = %68
  %88 = getelementptr i8, ptr %83, i64 8
  %89 = load i64, ptr %88, align 4
  %.sroa_idx.i = getelementptr i8, ptr %83, i64 16
  %90 = load i64, ptr %.sroa_idx.i, align 4
  %91 = inttoptr i64 %89 to ptr
  %92 = inttoptr i64 %90 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %84, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %84, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %84, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !161
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !161
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !161
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !161
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %84, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %91, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %92, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %offset.i.i57.i, 3
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84) #34
  %99 = sext i32 %offset.i.i57.i to i64
  %100 = getelementptr ptr, ptr %84, i64 %99
  %101 = getelementptr i8, ptr %100, i64 64
  %102 = load ptr, ptr %101, align 8
  %result.i.i = call ptr %102({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #15
  %103 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %104 = icmp eq i32 %103, %75
  br i1 %104, label %._crit_edge.i977, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i977:                                 ; preds = %87
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84)
  %107 = getelementptr i8, ptr %100, i64 48
  %108 = load ptr, ptr %107, align 8
  %result.i59.i = call ptr %108({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #15
  %109 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %111 = load ptr, ptr %55, align 8
  %112 = call i1 %111({ ptr, i160 } %109, { ptr, i160 } %73) #7
  br i1 %112, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i977, %68, %87
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %121

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i977
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84)
  %115 = getelementptr i8, ptr %100, i64 56
  %116 = load ptr, ptr %115, align 8
  %result.i60.i = call ptr %116({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #15
  %117 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %117, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %119 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %120 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %119, %120
  br i1 %.not63.i, label %HashMap_get_keyK.exit, label %121

121:                                              ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %122 = add i32 %75, 2127912214
  %123 = shl i32 %75, 12
  %124 = add i32 %122, %123
  %125 = ashr i32 %124, 19
  %126 = xor i32 %124, %125
  %127 = xor i32 %126, -949894596
  %128 = add i32 %127, 374761393
  %129 = shl i32 %127, 5
  %130 = add i32 %128, %129
  %131 = add i32 %130, -744332180
  %132 = shl i32 %130, 9
  %133 = xor i32 %131, %132
  %134 = add i32 %133, -42973499
  %135 = shl i32 %133, 3
  %136 = add i32 %134, %135
  %137 = ashr i32 %136, 16
  %138 = xor i32 %136, %137
  %139 = xor i32 %138, -1252372727
  %140 = load i32, ptr %56, align 8
  %141 = add i32 %140, -1
  %142 = and i32 %141, %139
  %143 = load ptr, ptr %58, align 8
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %145 = sext i32 %142 to i64
  %146 = shl nsw i64 %145, 5
  %147 = getelementptr i8, ptr %143, i64 %146
  %148 = load ptr, ptr %147, align 8
  %149 = icmp ne ptr %148, @nil_typ
  %150 = icmp ne ptr %148, null
  %.not44.i1006 = and i1 %149, %150
  br i1 %.not44.i1006, label %151, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1030

151:                                              ; preds = %121
  %152 = getelementptr i8, ptr %147, i64 8
  %153 = load i64, ptr %152, align 4
  %.sroa_idx.i1010 = getelementptr i8, ptr %147, i64 16
  %154 = load i64, ptr %.sroa_idx.i1010, align 4
  %155 = inttoptr i64 %153 to ptr
  %156 = inttoptr i64 %154 to ptr
  %hash_coef_ptr.i.i46.i1011 = getelementptr i8, ptr %148, i64 8
  %tbl_size_ptr.i.i47.i1012 = getelementptr i8, ptr %148, i64 16
  %offset_tbl_ptr.i.i48.i1013 = getelementptr i8, ptr %148, i64 40
  %hash_coef.i.i49.i1014 = load i64, ptr %hash_coef_ptr.i.i46.i1011, align 4, !noalias !164
  %tbl_size.i.i50.i1015 = load i64, ptr %tbl_size_ptr.i.i47.i1012, align 4, !noalias !164
  %offset_tbl.i.i51.i1016 = load ptr, ptr %offset_tbl_ptr.i.i48.i1013, align 8, !noalias !164
  %product.i.i.i52.i1017 = mul i64 %hash_coef.i.i49.i1014, 4015701072841558310
  %shifted.i.i.i53.i1018 = lshr i64 %product.i.i.i52.i1017, 32
  %xored.i.i.i54.i1019 = xor i64 %shifted.i.i.i53.i1018, %product.i.i.i52.i1017
  %hash.i.i.i55.i1020 = and i64 %xored.i.i.i54.i1019, %tbl_size.i.i50.i1015
  %offset_ptr.i.i56.i1021 = getelementptr i32, ptr %offset_tbl.i.i51.i1016, i64 %hash.i.i.i55.i1020
  %offset.i.i57.i1022 = load i32, ptr %offset_ptr.i.i56.i1021, align 4, !noalias !164
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %148, 0
  %158 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %155, 1
  %159 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %156, 2
  %160 = insertvalue { ptr, ptr, ptr, i32 } %159, i32 %offset.i.i57.i1022, 3
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148) #34
  %163 = sext i32 %offset.i.i57.i1022 to i64
  %164 = getelementptr ptr, ptr %148, i64 %163
  %165 = getelementptr i8, ptr %164, i64 64
  %166 = load ptr, ptr %165, align 8
  %result.i.i1023 = call ptr %166({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #15
  %167 = call i32 %result.i.i1023({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %168 = icmp eq i32 %167, %75
  br i1 %168, label %._crit_edge.i1024, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1030

._crit_edge.i1024:                                ; preds = %151
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148)
  %171 = getelementptr i8, ptr %164, i64 48
  %172 = load ptr, ptr %171, align 8
  %result.i59.i1025 = call ptr %172({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #15
  %173 = call { ptr, i160 } %result.i59.i1025({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %175 = load ptr, ptr %55, align 8
  %176 = call i1 %175({ ptr, i160 } %173, { ptr, i160 } %73) #7
  br i1 %176, label %177, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1030

177:                                              ; preds = %._crit_edge.i1024
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148)
  %180 = getelementptr i8, ptr %164, i64 56
  %181 = load ptr, ptr %180, align 8
  %result.i60.i1027 = call ptr %181({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #15
  %182 = call { ptr, i160 } %result.i60.i1027({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1028 = extractvalue { ptr, i160 } %182, 0
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1030

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1030: ; preds = %121, %151, %._crit_edge.i1024, %177
  %183 = phi ptr [ %.fca.0.extract21.i1028, %177 ], [ @nil_typ, %._crit_edge.i1024 ], [ @nil_typ, %121 ], [ @nil_typ, %151 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %184 = icmp ne ptr %183, @nil_typ
  %185 = icmp ne ptr %183, null
  %.not65.not.not.i = and i1 %184, %185
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %183, ptr @nil_typ
  br label %HashMap_get_keyK.exit

HashMap_get_keyK.exit:                            ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1030
  %186 = phi ptr [ %.fca.0.extract21.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1030 ]
  %187 = icmp eq ptr %186, @nil_typ
  %188 = icmp eq ptr %186, null
  %189 = or i1 %187, %188
  br i1 %189, label %190, label %._crit_edge1

190:                                              ; preds = %HashMap_get_keyK.exit
  %191 = add nuw i32 %72, 1
  %.sroa.0234.0.insert.ext = zext i32 %191 to i160
  %192 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0234.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %193 = load ptr, ptr %result.i283, align 8
  %194 = load ptr, ptr %40, align 8
  %195 = call i32 %194({ ptr, i160 } %73) #7
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %197 = load i32, ptr %42, align 8
  %198 = add i32 %197, -1
  %199 = and i32 %198, %195
  %200 = load ptr, ptr %43, align 8
  %201 = load ptr, ptr %35, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %202 = sext i32 %199 to i64
  %203 = shl nsw i64 %202, 5
  %204 = getelementptr i8, ptr %200, i64 %203
  %205 = load ptr, ptr %204, align 8
  %206 = getelementptr i8, ptr %204, i64 8
  %207 = icmp ne ptr %205, @nil_typ
  %208 = icmp ne ptr %205, null
  %.not64.i = and i1 %207, %208
  br i1 %.not64.i, label %209, label %306

209:                                              ; preds = %190
  %210 = load i64, ptr %206, align 4
  %.sroa_idx.i1071 = getelementptr i8, ptr %204, i64 16
  %211 = load i64, ptr %.sroa_idx.i1071, align 4
  %212 = inttoptr i64 %210 to ptr
  %213 = inttoptr i64 %211 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %205, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %205, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %205, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !167
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !167
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !167
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !167
  %214 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %205, 0
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %212, 1
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, ptr %213, 2
  %217 = insertvalue { ptr, ptr, ptr, i32 } %216, i32 %offset.i.i77.i, 3
  %218 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %205) #34
  %220 = sext i32 %offset.i.i77.i to i64
  %221 = getelementptr ptr, ptr %205, i64 %220
  %222 = getelementptr i8, ptr %221, i64 64
  %223 = load ptr, ptr %222, align 8
  %result.i.i1072 = call ptr %223({ ptr, ptr, ptr, i32 } %217, ptr nocapture nofree noundef nonnull readonly %2) #15
  %224 = call i32 %result.i.i1072({ ptr, ptr, ptr, i32 } %217, { ptr, ptr, ptr, i32 } %217, ptr nonnull align 8 %2) #7
  %225 = icmp eq i32 %224, %195
  br i1 %225, label %._crit_edge.i1073, label %306

._crit_edge.i1073:                                ; preds = %209
  %226 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %227 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %205)
  %228 = getelementptr i8, ptr %221, i64 48
  %229 = load ptr, ptr %228, align 8
  %result.i79.i = call ptr %229({ ptr, ptr, ptr, i32 } %217, ptr nocapture nofree noundef nonnull readonly %2) #15
  %230 = call { ptr, i160 } %result.i79.i({ ptr, ptr, ptr, i32 } %217, { ptr, ptr, ptr, i32 } %217, ptr nonnull align 8 %2) #7
  %231 = load ptr, ptr %41, align 8
  %232 = call i1 %231({ ptr, i160 } %230, { ptr, i160 } %73) #7
  br i1 %232, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %306

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1073
  %233 = load ptr, ptr %result.i283, align 8
  %234 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %235 = load ptr, ptr %35, align 8
  %236 = load ptr, ptr %233, align 8, !alias.scope !170
  %237 = getelementptr i8, ptr %236, i64 72
  %238 = load ptr, ptr %237, align 8, !alias.scope !170
  %result.i.i.i1074 = call { i64, i64 } %238(ptr nocapture nofree nonnull readonly %233) #5, !alias.scope !170
  %239 = extractvalue { i64, i64 } %result.i.i.i1074, 0
  %240 = extractvalue { i64, i64 } %result.i.i.i1074, 1
  %241 = urem i64 20, %240
  %242 = icmp eq i64 %241, 0
  %243 = sub i64 %240, %241
  %244 = select i1 %242, i64 0, i64 %243
  %245 = add i64 %239, 20
  %246 = add i64 %245, %244
  %247 = load ptr, ptr %235, align 8, !alias.scope !170
  %248 = getelementptr i8, ptr %247, i64 72
  %249 = load ptr, ptr %248, align 8, !alias.scope !170
  %result.i1.i.i1075 = call { i64, i64 } %249(ptr nocapture nofree nonnull readonly %235) #5, !alias.scope !170
  %250 = extractvalue { i64, i64 } %result.i1.i.i1075, 0
  %251 = extractvalue { i64, i64 } %result.i1.i.i1075, 1
  %252 = call i64 @llvm.umax.i64(i64 %240, i64 %251)
  %253 = call i64 @llvm.umax.i64(i64 %252, i64 8)
  %254 = urem i64 %246, %251
  %255 = icmp eq i64 %254, 0
  %256 = sub i64 %251, %254
  %257 = select i1 %255, i64 0, i64 %256
  %258 = add i64 %250, %246
  %259 = add i64 %258, %257
  %260 = urem i64 %259, %253
  %261 = icmp eq i64 %260, 0
  %262 = sub i64 %253, %260
  %263 = select i1 %261, i64 0, i64 %262
  %264 = add i64 %263, %259
  %result.i83.i1076 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %264, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %233, ptr %result.i83.i1076, align 8
  %265 = getelementptr inbounds i8, ptr %result.i83.i1076, i64 8
  store ptr %235, ptr %265, align 8
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1076)
  %267 = load ptr, ptr %233, align 8
  %268 = getelementptr i8, ptr %267, i64 72
  %269 = load ptr, ptr %268, align 8
  %result.i.i114.i = call { i64, i64 } %269(ptr nocapture nofree nonnull readonly %233) #5
  %270 = extractvalue { i64, i64 } %result.i.i114.i, 1
  %271 = urem i64 20, %270
  %272 = icmp eq i64 %271, 0
  %reass.sub3804 = sub i64 %270, %271
  %273 = add i64 %reass.sub3804, 20
  %274 = select i1 %272, i64 20, i64 %273
  %275 = getelementptr i8, ptr %result.i83.i1076, i64 %274
  %276 = getelementptr i8, ptr %267, i64 64
  %277 = load ptr, ptr %276, align 8
  call void %277({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %233, ptr nocapture nofree writeonly %275) #12
  %278 = load ptr, ptr %result.i83.i1076, align 8
  %279 = load ptr, ptr %278, align 8
  %280 = getelementptr i8, ptr %279, i64 72
  %281 = load ptr, ptr %280, align 8
  %result.i.i115.i = call { i64, i64 } %281(ptr nocapture nofree nonnull readonly %278) #5
  %282 = extractvalue { i64, i64 } %result.i.i115.i, 0
  %283 = extractvalue { i64, i64 } %result.i.i115.i, 1
  %284 = urem i64 20, %283
  %285 = icmp eq i64 %284, 0
  %286 = sub i64 %283, %284
  %287 = select i1 %285, i64 0, i64 %286
  %288 = add i64 %282, 20
  %289 = add i64 %288, %287
  %290 = load ptr, ptr %265, align 8
  %291 = load ptr, ptr %290, align 8
  %292 = getelementptr i8, ptr %291, i64 72
  %293 = load ptr, ptr %292, align 8
  %result.i1.i116.i = call { i64, i64 } %293(ptr nocapture nofree nonnull readonly %290) #5
  %294 = extractvalue { i64, i64 } %result.i1.i116.i, 1
  %295 = urem i64 %289, %294
  %296 = icmp eq i64 %295, 0
  %297 = sub i64 %294, %295
  %298 = select i1 %296, i64 0, i64 %297
  %299 = getelementptr i8, ptr %result.i83.i1076, i64 %289
  %300 = getelementptr i8, ptr %299, i64 %298
  %301 = getelementptr i8, ptr %291, i64 64
  %302 = load ptr, ptr %301, align 8
  call void %302({ ptr, i160 } %192, ptr nocapture nofree nonnull readonly %290, ptr nocapture nofree writeonly %300) #12
  %303 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %304 = getelementptr inbounds i8, ptr %result.i83.i1076, i64 16
  store i32 %195, ptr %304, align 8
  store ptr @Entry, ptr %204, align 8
  %305 = ptrtoint ptr %result.i83.i1076 to i64
  store i64 %305, ptr %206, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %204, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

306:                                              ; preds = %._crit_edge.i1073, %190, %209
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %307 = add i32 %195, 2127912214
  %308 = shl i32 %195, 12
  %309 = add i32 %307, %308
  %310 = ashr i32 %309, 19
  %311 = xor i32 %309, %310
  %312 = xor i32 %311, -949894596
  %313 = add i32 %312, 374761393
  %314 = shl i32 %312, 5
  %315 = add i32 %313, %314
  %316 = add i32 %315, -744332180
  %317 = shl i32 %315, 9
  %318 = xor i32 %316, %317
  %319 = add i32 %318, -42973499
  %320 = shl i32 %318, 3
  %321 = add i32 %319, %320
  %322 = ashr i32 %321, 16
  %323 = xor i32 %321, %322
  %324 = xor i32 %323, -1252372727
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %326 = load i32, ptr %42, align 8
  %327 = add i32 %326, -1
  %328 = and i32 %327, %324
  %329 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %330 = sext i32 %328 to i64
  %331 = shl nsw i64 %330, 5
  %332 = getelementptr i8, ptr %329, i64 %331
  %333 = load ptr, ptr %332, align 8
  %334 = getelementptr i8, ptr %332, i64 8
  %335 = icmp ne ptr %333, @nil_typ
  %336 = icmp ne ptr %333, null
  %.not64.i1106 = and i1 %335, %336
  br i1 %.not64.i1106, label %337, label %435

337:                                              ; preds = %306
  %338 = load i64, ptr %334, align 4
  %.sroa_idx.i1108 = getelementptr i8, ptr %332, i64 16
  %339 = load i64, ptr %.sroa_idx.i1108, align 4
  %340 = inttoptr i64 %338 to ptr
  %341 = inttoptr i64 %339 to ptr
  %hash_coef_ptr.i.i66.i1109 = getelementptr i8, ptr %333, i64 8
  %tbl_size_ptr.i.i67.i1110 = getelementptr i8, ptr %333, i64 16
  %offset_tbl_ptr.i.i68.i1111 = getelementptr i8, ptr %333, i64 40
  %hash_coef.i.i69.i1112 = load i64, ptr %hash_coef_ptr.i.i66.i1109, align 4, !noalias !173
  %tbl_size.i.i70.i1113 = load i64, ptr %tbl_size_ptr.i.i67.i1110, align 4, !noalias !173
  %offset_tbl.i.i71.i1114 = load ptr, ptr %offset_tbl_ptr.i.i68.i1111, align 8, !noalias !173
  %product.i.i.i72.i1115 = mul i64 %hash_coef.i.i69.i1112, 4015701072841558310
  %shifted.i.i.i73.i1116 = lshr i64 %product.i.i.i72.i1115, 32
  %xored.i.i.i74.i1117 = xor i64 %shifted.i.i.i73.i1116, %product.i.i.i72.i1115
  %hash.i.i.i75.i1118 = and i64 %xored.i.i.i74.i1117, %tbl_size.i.i70.i1113
  %offset_ptr.i.i76.i1119 = getelementptr i32, ptr %offset_tbl.i.i71.i1114, i64 %hash.i.i.i75.i1118
  %offset.i.i77.i1120 = load i32, ptr %offset_ptr.i.i76.i1119, align 4, !noalias !173
  %342 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %333, 0
  %343 = insertvalue { ptr, ptr, ptr, i32 } %342, ptr %340, 1
  %344 = insertvalue { ptr, ptr, ptr, i32 } %343, ptr %341, 2
  %345 = insertvalue { ptr, ptr, ptr, i32 } %344, i32 %offset.i.i77.i1120, 3
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %333) #34
  %348 = sext i32 %offset.i.i77.i1120 to i64
  %349 = getelementptr ptr, ptr %333, i64 %348
  %350 = getelementptr i8, ptr %349, i64 64
  %351 = load ptr, ptr %350, align 8
  %result.i.i1121 = call ptr %351({ ptr, ptr, ptr, i32 } %345, ptr nocapture nofree noundef nonnull readonly %2) #15
  %352 = call i32 %result.i.i1121({ ptr, ptr, ptr, i32 } %345, { ptr, ptr, ptr, i32 } %345, ptr nonnull align 8 %2) #7
  %353 = icmp eq i32 %352, %195
  br i1 %353, label %._crit_edge.i1122, label %435

._crit_edge.i1122:                                ; preds = %337
  %354 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %355 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %333)
  %356 = getelementptr i8, ptr %349, i64 48
  %357 = load ptr, ptr %356, align 8
  %result.i79.i1123 = call ptr %357({ ptr, ptr, ptr, i32 } %345, ptr nocapture nofree noundef nonnull readonly %2) #15
  %358 = call { ptr, i160 } %result.i79.i1123({ ptr, ptr, ptr, i32 } %345, { ptr, ptr, ptr, i32 } %345, ptr nonnull align 8 %2) #7
  %359 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %360 = load ptr, ptr %41, align 8
  %361 = call i1 %360({ ptr, i160 } %358, { ptr, i160 } %73) #7
  br i1 %361, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1135, label %435

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1135: ; preds = %._crit_edge.i1122
  %362 = load ptr, ptr %result.i283, align 8
  %363 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %364 = load ptr, ptr %35, align 8
  %365 = load ptr, ptr %362, align 8, !alias.scope !176
  %366 = getelementptr i8, ptr %365, i64 72
  %367 = load ptr, ptr %366, align 8, !alias.scope !176
  %result.i.i.i1127 = call { i64, i64 } %367(ptr nocapture nofree nonnull readonly %362) #5, !alias.scope !176
  %368 = extractvalue { i64, i64 } %result.i.i.i1127, 0
  %369 = extractvalue { i64, i64 } %result.i.i.i1127, 1
  %370 = urem i64 20, %369
  %371 = icmp eq i64 %370, 0
  %372 = sub i64 %369, %370
  %373 = select i1 %371, i64 0, i64 %372
  %374 = add i64 %368, 20
  %375 = add i64 %374, %373
  %376 = load ptr, ptr %364, align 8, !alias.scope !176
  %377 = getelementptr i8, ptr %376, i64 72
  %378 = load ptr, ptr %377, align 8, !alias.scope !176
  %result.i1.i.i1128 = call { i64, i64 } %378(ptr nocapture nofree nonnull readonly %364) #5, !alias.scope !176
  %379 = extractvalue { i64, i64 } %result.i1.i.i1128, 0
  %380 = extractvalue { i64, i64 } %result.i1.i.i1128, 1
  %381 = call i64 @llvm.umax.i64(i64 %369, i64 %380)
  %382 = call i64 @llvm.umax.i64(i64 %381, i64 8)
  %383 = urem i64 %375, %380
  %384 = icmp eq i64 %383, 0
  %385 = sub i64 %380, %383
  %386 = select i1 %384, i64 0, i64 %385
  %387 = add i64 %379, %375
  %388 = add i64 %387, %386
  %389 = urem i64 %388, %382
  %390 = icmp eq i64 %389, 0
  %391 = sub i64 %382, %389
  %392 = select i1 %390, i64 0, i64 %391
  %393 = add i64 %392, %388
  %result.i83.i1129 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %393, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %362, ptr %result.i83.i1129, align 8
  %394 = getelementptr inbounds i8, ptr %result.i83.i1129, i64 8
  store ptr %364, ptr %394, align 8
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1129)
  %396 = load ptr, ptr %362, align 8
  %397 = getelementptr i8, ptr %396, i64 72
  %398 = load ptr, ptr %397, align 8
  %result.i.i114.i1130 = call { i64, i64 } %398(ptr nocapture nofree nonnull readonly %362) #5
  %399 = extractvalue { i64, i64 } %result.i.i114.i1130, 1
  %400 = urem i64 20, %399
  %401 = icmp eq i64 %400, 0
  %reass.sub3803 = sub i64 %399, %400
  %402 = add i64 %reass.sub3803, 20
  %403 = select i1 %401, i64 20, i64 %402
  %404 = getelementptr i8, ptr %result.i83.i1129, i64 %403
  %405 = getelementptr i8, ptr %396, i64 64
  %406 = load ptr, ptr %405, align 8
  call void %406({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %362, ptr nocapture nofree writeonly %404) #12
  %407 = load ptr, ptr %result.i83.i1129, align 8
  %408 = load ptr, ptr %407, align 8
  %409 = getelementptr i8, ptr %408, i64 72
  %410 = load ptr, ptr %409, align 8
  %result.i.i115.i1132 = call { i64, i64 } %410(ptr nocapture nofree nonnull readonly %407) #5
  %411 = extractvalue { i64, i64 } %result.i.i115.i1132, 0
  %412 = extractvalue { i64, i64 } %result.i.i115.i1132, 1
  %413 = urem i64 20, %412
  %414 = icmp eq i64 %413, 0
  %415 = sub i64 %412, %413
  %416 = select i1 %414, i64 0, i64 %415
  %417 = add i64 %411, 20
  %418 = add i64 %417, %416
  %419 = load ptr, ptr %394, align 8
  %420 = load ptr, ptr %419, align 8
  %421 = getelementptr i8, ptr %420, i64 72
  %422 = load ptr, ptr %421, align 8
  %result.i1.i116.i1133 = call { i64, i64 } %422(ptr nocapture nofree nonnull readonly %419) #5
  %423 = extractvalue { i64, i64 } %result.i1.i116.i1133, 1
  %424 = urem i64 %418, %423
  %425 = icmp eq i64 %424, 0
  %426 = sub i64 %423, %424
  %427 = select i1 %425, i64 0, i64 %426
  %428 = getelementptr i8, ptr %result.i83.i1129, i64 %418
  %429 = getelementptr i8, ptr %428, i64 %427
  %430 = getelementptr i8, ptr %420, i64 64
  %431 = load ptr, ptr %430, align 8
  call void %431({ ptr, i160 } %192, ptr nocapture nofree nonnull readonly %419, ptr nocapture nofree writeonly %429) #12
  %432 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %433 = getelementptr inbounds i8, ptr %result.i83.i1129, i64 16
  store i32 %195, ptr %433, align 8
  store ptr @Entry, ptr %332, align 8
  %434 = ptrtoint ptr %result.i83.i1129 to i64
  store i64 %434, ptr %334, align 4
  %.sroa_idx28.i1134 = getelementptr i8, ptr %332, i64 24
  store i32 10, ptr %.sroa_idx28.i1134, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

435:                                              ; preds = %._crit_edge.i1122, %306, %337
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %436 = load i32, ptr %65, align 4
  %437 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %438 = load i32, ptr %42, align 8
  %.not.i = icmp slt i32 %436, %438
  br i1 %.not.i, label %._crit_edge.i, label %439

439:                                              ; preds = %435
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %441 = load ptr, ptr %43, align 8
  %442 = load ptr, ptr %44, align 8
  %443 = shl i32 %438, 1
  %spec.select.i1150 = call i32 @llvm.smax.i32(i32 %443, i32 16)
  store i32 %spec.select.i1150, ptr %42, align 8
  %444 = zext nneg i32 %spec.select.i1150 to i64
  %445 = shl nuw nsw i64 %444, 5
  %result.i.i1151 = call noalias ptr @bump_malloc_inner(i64 noundef %445, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1151, ptr %43, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %445, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %446 = icmp sgt i32 %438, 0
  br i1 %446, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread: ; preds = %439
  %447 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i

.lr.ph.i:                                         ; preds = %439, %._crit_edge.i1950
  %.060.i = phi i32 [ %536, %._crit_edge.i1950 ], [ 0, %439 ]
  %448 = zext nneg i32 %.060.i to i64
  %449 = shl nuw nsw i64 %448, 5
  %450 = getelementptr i8, ptr %441, i64 %449
  %451 = load ptr, ptr %450, align 8
  %452 = icmp ne ptr %451, @nil_typ
  %453 = icmp ne ptr %451, null
  %.not16.i = and i1 %452, %453
  br i1 %.not16.i, label %454, label %._crit_edge.i1950

454:                                              ; preds = %.lr.ph.i
  %455 = getelementptr i8, ptr %450, i64 8
  %456 = load <2 x i64>, ptr %455, align 4
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %451, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %451, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %451, i64 40
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %26)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !179
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %459 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %461

461:                                              ; preds = %.cont.cont.i2493, %454
  %.0566.i2480 = phi i32 [ 0, %454 ], [ %465, %.cont.cont.i2493 ]
  %.070565.i2481 = phi i1 [ true, %454 ], [ %527, %.cont.cont.i2493 ]
  %.sroa.0.0564.i2482 = phi ptr [ %451, %454 ], [ %vptr.i142.sroa.speculated.i2496, %.cont.cont.i2493 ]
  %.sroa.17.0561.i2485 = phi i32 [ %offset.i.i121.i, %454 ], [ %offset.i.i154.i2510, %.cont.cont.i2493 ]
  %462 = phi <2 x i64> [ %456, %454 ], [ %526, %.cont.cont.i2493 ]
  %463 = extractelement <2 x i64> %462, i64 1
  %.sroa.12.0562.i2484 = inttoptr i64 %463 to ptr
  %464 = extractelement <2 x i64> %462, i64 0
  %.sroa.6.0563.i2483 = inttoptr i64 %464 to ptr
  %465 = add nuw nsw i32 %.0566.i2480, 1
  %466 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2482, 0
  %467 = insertvalue { ptr, ptr, ptr, i32 } %466, ptr %.sroa.6.0563.i2483, 1
  %468 = insertvalue { ptr, ptr, ptr, i32 } %467, ptr %.sroa.12.0562.i2484, 2
  %469 = insertvalue { ptr, ptr, ptr, i32 } %468, i32 %.sroa.17.0561.i2485, 3
  %470 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2482)
  %471 = sext i32 %.sroa.17.0561.i2485 to i64
  %472 = getelementptr ptr, ptr %.sroa.0.0564.i2482, i64 %471
  %473 = getelementptr i8, ptr %472, i64 64
  %474 = load ptr, ptr %473, align 8
  %result.i125.i2486 = call ptr %474({ ptr, ptr, ptr, i32 } %469, ptr nocapture nofree noundef nonnull readonly %2) #15
  %475 = call i32 %result.i125.i2486({ ptr, ptr, ptr, i32 } %469, { ptr, ptr, ptr, i32 } %469, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2481, label %476, label %492

476:                                              ; preds = %461
  %477 = load i32, ptr %42, align 8
  %478 = add i32 %477, -1
  %479 = and i32 %478, %475
  %480 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %481 = load ptr, ptr %43, align 8
  %482 = sext i32 %479 to i64
  %483 = shl nsw i64 %482, 5
  %484 = getelementptr i8, ptr %481, i64 %483
  %485 = load ptr, ptr %484, align 8
  %486 = getelementptr i8, ptr %484, i64 8
  %487 = load i160, ptr %486, align 4
  store ptr %.sroa.0.0564.i2482, ptr %484, align 8
  store i64 %464, ptr %486, align 4
  %.sroa_idx157.i2512 = getelementptr i8, ptr %484, i64 16
  store i64 %463, ptr %.sroa_idx157.i2512, align 4
  %.sroa_idx158.i2513 = getelementptr i8, ptr %484, i64 24
  store i32 %.sroa.17.0561.i2485, ptr %.sroa_idx158.i2513, align 4
  %488 = icmp ne ptr %485, @nil_typ
  %489 = icmp ne ptr %485, null
  %.not92.i2514 = and i1 %488, %489
  %extract.i2516 = lshr i160 %487, 64
  %490 = insertelement <2 x i160> poison, i160 %487, i64 0
  %491 = insertelement <2 x i160> %490, i160 %extract.i2516, i64 1
  br i1 %.not92.i2514, label %.cont.cont.i2493, label %531

492:                                              ; preds = %461
  %493 = add i32 %475, 2127912214
  %494 = shl i32 %475, 12
  %495 = add i32 %493, %494
  %496 = ashr i32 %495, 19
  %497 = xor i32 %495, %496
  %498 = xor i32 %497, -949894596
  %499 = add i32 %498, 374761393
  %500 = shl i32 %498, 5
  %501 = add i32 %499, %500
  %502 = add i32 %501, -744332180
  %503 = shl i32 %501, 9
  %504 = xor i32 %502, %503
  %505 = add i32 %504, -42973499
  %506 = shl i32 %504, 3
  %507 = add i32 %505, %506
  %508 = ashr i32 %507, 16
  %509 = xor i32 %507, %508
  %510 = xor i32 %509, -1252372727
  %511 = load i32, ptr %42, align 8
  %512 = add i32 %511, -1
  %513 = and i32 %512, %510
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %515 = load ptr, ptr %44, align 8
  %516 = sext i32 %513 to i64
  %517 = shl nsw i64 %516, 5
  %518 = getelementptr i8, ptr %515, i64 %517
  %519 = load ptr, ptr %518, align 8
  %520 = getelementptr i8, ptr %518, i64 8
  %521 = load i160, ptr %520, align 4
  store ptr %.sroa.0.0564.i2482, ptr %518, align 8
  store i64 %464, ptr %520, align 4
  %.sroa_idx161.i2487 = getelementptr i8, ptr %518, i64 16
  store i64 %463, ptr %.sroa_idx161.i2487, align 4
  %.sroa_idx162.i2488 = getelementptr i8, ptr %518, i64 24
  store i32 %.sroa.17.0561.i2485, ptr %.sroa_idx162.i2488, align 4
  %522 = icmp ne ptr %519, @nil_typ
  %523 = icmp ne ptr %519, null
  %.not90.i2489 = and i1 %522, %523
  %extract607.i2491 = lshr i160 %521, 64
  %524 = insertelement <2 x i160> poison, i160 %521, i64 0
  %525 = insertelement <2 x i160> %524, i160 %extract607.i2491, i64 1
  br i1 %.not90.i2489, label %.cont.cont.i2493, label %531

.cont.cont.i2493:                                 ; preds = %492, %476
  %vptr.i142.sroa.speculated.i2496 = phi ptr [ %485, %476 ], [ %519, %492 ]
  %.in = phi <2 x i160> [ %491, %476 ], [ %525, %492 ]
  %526 = trunc <2 x i160> %.in to <2 x i64>
  %527 = xor i1 %.070565.i2481, true
  %hash_coef_ptr.i.i143.i2499 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2496, i64 8
  %tbl_size_ptr.i.i144.i2500 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2496, i64 16
  %offset_tbl_ptr.i.i145.i2501 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2496, i64 40
  %hash_coef.i.i146.i2502 = load i64, ptr %hash_coef_ptr.i.i143.i2499, align 4
  %tbl_size.i.i147.i2503 = load i64, ptr %tbl_size_ptr.i.i144.i2500, align 4
  %offset_tbl.i.i148.i2504 = load ptr, ptr %offset_tbl_ptr.i.i145.i2501, align 8
  %product.i.i.i149.i2505 = mul i64 %hash_coef.i.i146.i2502, 4015701072841558310
  %shifted.i.i.i150.i2506 = lshr i64 %product.i.i.i149.i2505, 32
  %xored.i.i.i151.i2507 = xor i64 %shifted.i.i.i150.i2506, %product.i.i.i149.i2505
  %hash.i.i.i152.i2508 = and i64 %xored.i.i.i151.i2507, %tbl_size.i.i147.i2503
  %offset_ptr.i.i153.i2509 = getelementptr i32, ptr %offset_tbl.i.i148.i2504, i64 %hash.i.i.i152.i2508
  %offset.i.i154.i2510 = load i32, ptr %offset_ptr.i.i153.i2509, align 4
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %529 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %530 = icmp ult i32 %.0566.i2480, 99
  br i1 %530, label %461, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2518

531:                                              ; preds = %492, %476
  %532 = phi ptr [ %26, %492 ], [ %25, %476 ]
  %533 = load i32, ptr %65, align 4
  store i32 %533, ptr %532, align 4
  %534 = add i32 %533, 1
  %535 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %534, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2518

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2518: ; preds = %.cont.cont.i2493, %531
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  br label %._crit_edge.i1950

._crit_edge.i1950:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2518, %.lr.ph.i
  %536 = add nuw nsw i32 %.060.i, 1
  %537 = icmp slt i32 %536, %438
  br i1 %537, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i1950
  %538 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %539

539:                                              ; preds = %._crit_edge.i1969, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %.060.i1967 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit ], [ %628, %._crit_edge.i1969 ]
  %540 = zext nneg i32 %.060.i1967 to i64
  %541 = shl nuw nsw i64 %540, 5
  %542 = getelementptr i8, ptr %442, i64 %541
  %543 = load ptr, ptr %542, align 8
  %544 = icmp ne ptr %543, @nil_typ
  %545 = icmp ne ptr %543, null
  %.not16.i1968 = and i1 %544, %545
  br i1 %.not16.i1968, label %546, label %._crit_edge.i1969

546:                                              ; preds = %539
  %547 = getelementptr i8, ptr %542, i64 8
  %548 = load <2 x i64>, ptr %547, align 4
  %hash_coef_ptr.i.i18.i1971 = getelementptr i8, ptr %543, i64 8
  %tbl_size_ptr.i.i19.i1972 = getelementptr i8, ptr %543, i64 16
  %offset_tbl_ptr.i.i20.i1973 = getelementptr i8, ptr %543, i64 40
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %hash_coef.i.i99.i2536 = load i64, ptr %hash_coef_ptr.i.i18.i1971, align 4, !noalias !22
  %tbl_size.i.i100.i2537 = load i64, ptr %tbl_size_ptr.i.i19.i1972, align 4, !noalias !22
  %offset_tbl.i.i101.i2538 = load ptr, ptr %offset_tbl_ptr.i.i20.i1973, align 8, !noalias !22
  %product.i.i.i102.i2539 = mul i64 %hash_coef.i.i99.i2536, 4015701072841558310
  %shifted.i.i.i103.i2540 = lshr i64 %product.i.i.i102.i2539, 32
  %xored.i.i.i104.i2541 = xor i64 %shifted.i.i.i103.i2540, %product.i.i.i102.i2539
  %hash.i.i.i105.i2542 = and i64 %xored.i.i.i104.i2541, %tbl_size.i.i100.i2537
  %offset_ptr.i.i106.i2543 = getelementptr i32, ptr %offset_tbl.i.i101.i2538, i64 %hash.i.i.i105.i2542
  %offset.i.i121.i2544 = load i32, ptr %offset_ptr.i.i106.i2543, align 4, !noalias !182
  %550 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %551 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %552 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %553

553:                                              ; preds = %.cont.cont.i2565, %546
  %.0566.i2545 = phi i32 [ 0, %546 ], [ %557, %.cont.cont.i2565 ]
  %.070565.i2546 = phi i1 [ true, %546 ], [ %619, %.cont.cont.i2565 ]
  %.sroa.0.0564.i2547 = phi ptr [ %543, %546 ], [ %vptr.i142.sroa.speculated.i2568, %.cont.cont.i2565 ]
  %.sroa.17.0561.i2550 = phi i32 [ %offset.i.i121.i2544, %546 ], [ %offset.i.i154.i2582, %.cont.cont.i2565 ]
  %554 = phi <2 x i64> [ %548, %546 ], [ %618, %.cont.cont.i2565 ]
  %555 = extractelement <2 x i64> %554, i64 1
  %.sroa.12.0562.i2549 = inttoptr i64 %555 to ptr
  %556 = extractelement <2 x i64> %554, i64 0
  %.sroa.6.0563.i2548 = inttoptr i64 %556 to ptr
  %557 = add nuw nsw i32 %.0566.i2545, 1
  %558 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2547, 0
  %559 = insertvalue { ptr, ptr, ptr, i32 } %558, ptr %.sroa.6.0563.i2548, 1
  %560 = insertvalue { ptr, ptr, ptr, i32 } %559, ptr %.sroa.12.0562.i2549, 2
  %561 = insertvalue { ptr, ptr, ptr, i32 } %560, i32 %.sroa.17.0561.i2550, 3
  %562 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2547)
  %563 = sext i32 %.sroa.17.0561.i2550 to i64
  %564 = getelementptr ptr, ptr %.sroa.0.0564.i2547, i64 %563
  %565 = getelementptr i8, ptr %564, i64 64
  %566 = load ptr, ptr %565, align 8
  %result.i125.i2551 = call ptr %566({ ptr, ptr, ptr, i32 } %561, ptr nocapture nofree noundef nonnull readonly %2) #15
  %567 = call i32 %result.i125.i2551({ ptr, ptr, ptr, i32 } %561, { ptr, ptr, ptr, i32 } %561, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2546, label %568, label %584

568:                                              ; preds = %553
  %569 = load i32, ptr %42, align 8
  %570 = add i32 %569, -1
  %571 = and i32 %570, %567
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %573 = load ptr, ptr %43, align 8
  %574 = sext i32 %571 to i64
  %575 = shl nsw i64 %574, 5
  %576 = getelementptr i8, ptr %573, i64 %575
  %577 = load ptr, ptr %576, align 8
  %578 = getelementptr i8, ptr %576, i64 8
  %579 = load i160, ptr %578, align 4
  store ptr %.sroa.0.0564.i2547, ptr %576, align 8
  store i64 %556, ptr %578, align 4
  %.sroa_idx157.i2594 = getelementptr i8, ptr %576, i64 16
  store i64 %555, ptr %.sroa_idx157.i2594, align 4
  %.sroa_idx158.i2595 = getelementptr i8, ptr %576, i64 24
  store i32 %.sroa.17.0561.i2550, ptr %.sroa_idx158.i2595, align 4
  %580 = icmp ne ptr %577, @nil_typ
  %581 = icmp ne ptr %577, null
  %.not92.i2596 = and i1 %580, %581
  %extract.i2598 = lshr i160 %579, 64
  %582 = insertelement <2 x i160> poison, i160 %579, i64 0
  %583 = insertelement <2 x i160> %582, i160 %extract.i2598, i64 1
  br i1 %.not92.i2596, label %.cont.cont.i2565, label %623

584:                                              ; preds = %553
  %585 = add i32 %567, 2127912214
  %586 = shl i32 %567, 12
  %587 = add i32 %585, %586
  %588 = ashr i32 %587, 19
  %589 = xor i32 %587, %588
  %590 = xor i32 %589, -949894596
  %591 = add i32 %590, 374761393
  %592 = shl i32 %590, 5
  %593 = add i32 %591, %592
  %594 = add i32 %593, -744332180
  %595 = shl i32 %593, 9
  %596 = xor i32 %594, %595
  %597 = add i32 %596, -42973499
  %598 = shl i32 %596, 3
  %599 = add i32 %597, %598
  %600 = ashr i32 %599, 16
  %601 = xor i32 %599, %600
  %602 = xor i32 %601, -1252372727
  %603 = load i32, ptr %42, align 8
  %604 = add i32 %603, -1
  %605 = and i32 %604, %602
  %606 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %607 = load ptr, ptr %44, align 8
  %608 = sext i32 %605 to i64
  %609 = shl nsw i64 %608, 5
  %610 = getelementptr i8, ptr %607, i64 %609
  %611 = load ptr, ptr %610, align 8
  %612 = getelementptr i8, ptr %610, i64 8
  %613 = load i160, ptr %612, align 4
  store ptr %.sroa.0.0564.i2547, ptr %610, align 8
  store i64 %556, ptr %612, align 4
  %.sroa_idx161.i2555 = getelementptr i8, ptr %610, i64 16
  store i64 %555, ptr %.sroa_idx161.i2555, align 4
  %.sroa_idx162.i2556 = getelementptr i8, ptr %610, i64 24
  store i32 %.sroa.17.0561.i2550, ptr %.sroa_idx162.i2556, align 4
  %614 = icmp ne ptr %611, @nil_typ
  %615 = icmp ne ptr %611, null
  %.not90.i2557 = and i1 %614, %615
  %extract607.i2559 = lshr i160 %613, 64
  %616 = insertelement <2 x i160> poison, i160 %613, i64 0
  %617 = insertelement <2 x i160> %616, i160 %extract607.i2559, i64 1
  br i1 %.not90.i2557, label %.cont.cont.i2565, label %623

.cont.cont.i2565:                                 ; preds = %584, %568
  %vptr.i142.sroa.speculated.i2568 = phi ptr [ %577, %568 ], [ %611, %584 ]
  %.in3807 = phi <2 x i160> [ %583, %568 ], [ %617, %584 ]
  %618 = trunc <2 x i160> %.in3807 to <2 x i64>
  %619 = xor i1 %.070565.i2546, true
  %hash_coef_ptr.i.i143.i2571 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2568, i64 8
  %tbl_size_ptr.i.i144.i2572 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2568, i64 16
  %offset_tbl_ptr.i.i145.i2573 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2568, i64 40
  %hash_coef.i.i146.i2574 = load i64, ptr %hash_coef_ptr.i.i143.i2571, align 4
  %tbl_size.i.i147.i2575 = load i64, ptr %tbl_size_ptr.i.i144.i2572, align 4
  %offset_tbl.i.i148.i2576 = load ptr, ptr %offset_tbl_ptr.i.i145.i2573, align 8
  %product.i.i.i149.i2577 = mul i64 %hash_coef.i.i146.i2574, 4015701072841558310
  %shifted.i.i.i150.i2578 = lshr i64 %product.i.i.i149.i2577, 32
  %xored.i.i.i151.i2579 = xor i64 %shifted.i.i.i150.i2578, %product.i.i.i149.i2577
  %hash.i.i.i152.i2580 = and i64 %xored.i.i.i151.i2579, %tbl_size.i.i147.i2575
  %offset_ptr.i.i153.i2581 = getelementptr i32, ptr %offset_tbl.i.i148.i2576, i64 %hash.i.i.i152.i2580
  %offset.i.i154.i2582 = load i32, ptr %offset_ptr.i.i153.i2581, align 4
  %620 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %621 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %622 = icmp ult i32 %.0566.i2545, 99
  br i1 %622, label %553, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2600

623:                                              ; preds = %584, %568
  %624 = phi ptr [ %24, %584 ], [ %23, %568 ]
  %625 = load i32, ptr %65, align 4
  store i32 %625, ptr %624, align 4
  %626 = add i32 %625, 1
  %627 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %626, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2600

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2600: ; preds = %.cont.cont.i2565, %623
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %._crit_edge.i1969

._crit_edge.i1969:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2600, %539
  %628 = add nuw nsw i32 %.060.i1967, 1
  %629 = icmp slt i32 %628, %438
  br i1 %629, label %539, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i1969, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread, %435
  %630 = load ptr, ptr %193, align 8
  %631 = getelementptr i8, ptr %630, i64 72
  %632 = load ptr, ptr %631, align 8
  %result.i.i.i = call { i64, i64 } %632(ptr nocapture nofree nonnull readonly %193) #5
  %633 = extractvalue { i64, i64 } %result.i.i.i, 0
  %634 = extractvalue { i64, i64 } %result.i.i.i, 1
  %635 = urem i64 20, %634
  %636 = icmp eq i64 %635, 0
  %637 = sub i64 %634, %635
  %638 = select i1 %636, i64 0, i64 %637
  %639 = add i64 %633, 20
  %640 = add i64 %639, %638
  %641 = load ptr, ptr %201, align 8
  %642 = getelementptr i8, ptr %641, i64 72
  %643 = load ptr, ptr %642, align 8
  %result.i1.i.i = call { i64, i64 } %643(ptr nocapture nofree nonnull readonly %201) #5
  %644 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %645 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %646 = call i64 @llvm.umax.i64(i64 %634, i64 %645)
  %647 = call i64 @llvm.umax.i64(i64 %646, i64 8)
  %648 = urem i64 %640, %645
  %649 = icmp eq i64 %648, 0
  %650 = sub i64 %645, %648
  %651 = select i1 %649, i64 0, i64 %650
  %652 = add i64 %644, %640
  %653 = add i64 %652, %651
  %654 = urem i64 %653, %647
  %655 = icmp eq i64 %654, 0
  %656 = sub i64 %647, %654
  %657 = select i1 %655, i64 0, i64 %656
  %658 = add i64 %657, %653
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %658, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %193, ptr %result.i83.i, align 8
  %659 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %201, ptr %659, align 8
  %660 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %661 = load ptr, ptr %193, align 8
  %662 = getelementptr i8, ptr %661, i64 72
  %663 = load ptr, ptr %662, align 8
  %result.i.i179.i = call { i64, i64 } %663(ptr nocapture nofree nonnull readonly %193) #5
  %664 = extractvalue { i64, i64 } %result.i.i179.i, 1
  %665 = urem i64 20, %664
  %666 = icmp eq i64 %665, 0
  %reass.sub3802 = sub i64 %664, %665
  %667 = add i64 %reass.sub3802, 20
  %668 = select i1 %666, i64 20, i64 %667
  %669 = getelementptr i8, ptr %result.i83.i, i64 %668
  %670 = getelementptr i8, ptr %661, i64 64
  %671 = load ptr, ptr %670, align 8
  call void %671({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %193, ptr nocapture nofree writeonly %669) #12
  %672 = load ptr, ptr %result.i83.i, align 8
  %673 = load ptr, ptr %672, align 8
  %674 = getelementptr i8, ptr %673, i64 72
  %675 = load ptr, ptr %674, align 8
  %result.i.i180.i = call { i64, i64 } %675(ptr nocapture nofree nonnull readonly %672) #5
  %676 = extractvalue { i64, i64 } %result.i.i180.i, 0
  %677 = extractvalue { i64, i64 } %result.i.i180.i, 1
  %678 = urem i64 20, %677
  %679 = icmp eq i64 %678, 0
  %680 = sub i64 %677, %678
  %681 = select i1 %679, i64 0, i64 %680
  %682 = add i64 %676, 20
  %683 = add i64 %682, %681
  %684 = load ptr, ptr %659, align 8
  %685 = load ptr, ptr %684, align 8
  %686 = getelementptr i8, ptr %685, i64 72
  %687 = load ptr, ptr %686, align 8
  %result.i1.i181.i = call { i64, i64 } %687(ptr nocapture nofree nonnull readonly %684) #5
  %688 = extractvalue { i64, i64 } %result.i1.i181.i, 1
  %689 = urem i64 %683, %688
  %690 = icmp eq i64 %689, 0
  %691 = sub i64 %688, %689
  %692 = select i1 %690, i64 0, i64 %691
  %693 = getelementptr i8, ptr %result.i83.i, i64 %683
  %694 = getelementptr i8, ptr %693, i64 %692
  %695 = getelementptr i8, ptr %685, i64 64
  %696 = load ptr, ptr %695, align 8
  call void %696({ ptr, i160 } %192, ptr nocapture nofree nonnull readonly %684, ptr nocapture nofree writeonly %694) #12
  %697 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %698 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %195, ptr %698, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %34)
  %699 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %702

702:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %703, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %769, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i83.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i1167, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %703 = add nuw nsw i32 %.0566.i, 1
  %704 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %705 = insertvalue { ptr, ptr, ptr, i32 } %704, ptr %.sroa.6.0563.i, 1
  %706 = insertvalue { ptr, ptr, ptr, i32 } %705, ptr %.sroa.12.0562.i, 2
  %707 = insertvalue { ptr, ptr, ptr, i32 } %706, i32 %.sroa.17.0561.i, 3
  %708 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %709 = sext i32 %.sroa.17.0561.i to i64
  %710 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %709
  %711 = getelementptr i8, ptr %710, i64 64
  %712 = load ptr, ptr %711, align 8
  %result.i125.i = call ptr %712({ ptr, ptr, ptr, i32 } %707, ptr nocapture nofree noundef nonnull readonly %2) #15
  %713 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %707, { ptr, ptr, ptr, i32 } %707, ptr nonnull align 8 %2) #7
  %714 = ptrtoint ptr %.sroa.6.0563.i to i64
  %715 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %716, label %732

716:                                              ; preds = %702
  %717 = load i32, ptr %42, align 8
  %718 = add i32 %717, -1
  %719 = and i32 %718, %713
  %720 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %721 = load ptr, ptr %43, align 8
  %722 = sext i32 %719 to i64
  %723 = shl nsw i64 %722, 5
  %724 = getelementptr i8, ptr %721, i64 %723
  %725 = load ptr, ptr %724, align 8
  %726 = getelementptr i8, ptr %724, i64 8
  %727 = load i160, ptr %726, align 4
  store ptr %.sroa.0.0564.i, ptr %724, align 8
  store i64 %714, ptr %726, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %724, i64 16
  store i64 %715, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %724, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %728 = icmp ne ptr %725, @nil_typ
  %729 = icmp ne ptr %725, null
  %.not92.i = and i1 %728, %729
  %extract.i = lshr i160 %727, 64
  %730 = insertelement <2 x i160> poison, i160 %727, i64 0
  %731 = insertelement <2 x i160> %730, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

732:                                              ; preds = %702
  %733 = add i32 %713, 2127912214
  %734 = shl i32 %713, 12
  %735 = add i32 %733, %734
  %736 = ashr i32 %735, 19
  %737 = xor i32 %735, %736
  %738 = xor i32 %737, -949894596
  %739 = add i32 %738, 374761393
  %740 = shl i32 %738, 5
  %741 = add i32 %739, %740
  %742 = add i32 %741, -744332180
  %743 = shl i32 %741, 9
  %744 = xor i32 %742, %743
  %745 = add i32 %744, -42973499
  %746 = shl i32 %744, 3
  %747 = add i32 %745, %746
  %748 = ashr i32 %747, 16
  %749 = xor i32 %747, %748
  %750 = xor i32 %749, -1252372727
  %751 = load i32, ptr %42, align 8
  %752 = add i32 %751, -1
  %753 = and i32 %752, %750
  %754 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %755 = load ptr, ptr %44, align 8
  %756 = sext i32 %753 to i64
  %757 = shl nsw i64 %756, 5
  %758 = getelementptr i8, ptr %755, i64 %757
  %759 = load ptr, ptr %758, align 8
  %760 = getelementptr i8, ptr %758, i64 8
  %761 = load i160, ptr %760, align 4
  store ptr %.sroa.0.0564.i, ptr %758, align 8
  store i64 %714, ptr %760, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %758, i64 16
  store i64 %715, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %758, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %762 = icmp ne ptr %759, @nil_typ
  %763 = icmp ne ptr %759, null
  %.not90.i = and i1 %762, %763
  %extract607.i = lshr i160 %761, 64
  %764 = insertelement <2 x i160> poison, i160 %761, i64 0
  %765 = insertelement <2 x i160> %764, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %732, %716
  %vptr.i142.sroa.speculated.i = phi ptr [ %725, %716 ], [ %759, %732 ]
  %.in3808 = phi <2 x i160> [ %731, %716 ], [ %765, %732 ]
  %766 = trunc <2 x i160> %.in3808 to <2 x i64>
  %767 = extractelement <2 x i64> %766, i64 1
  %spec.select.i1167 = inttoptr i64 %767 to ptr
  %768 = extractelement <2 x i64> %766, i64 0
  %spec.select539.i = inttoptr i64 %768 to ptr
  %769 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %770 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %771 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %772 = icmp ult i32 %.0566.i, 99
  br i1 %772, label %702, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %716, %732
  %773 = phi ptr [ %34, %732 ], [ %33, %716 ]
  %774 = load i32, ptr %65, align 4
  store i32 %774, ptr %773, align 4
  %775 = add i32 %774, 1
  %776 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %775, ptr %65, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  %777 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %777, label %HashMap_insert_keyK_valueV.exit, label %778

778:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %779 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %780 = load ptr, ptr %43, align 8
  %781 = load ptr, ptr %44, align 8
  %782 = load i32, ptr %42, align 8
  %783 = shl i32 %782, 1
  %spec.select.i1184 = call i32 @llvm.smax.i32(i32 %783, i32 16)
  store i32 %spec.select.i1184, ptr %42, align 8
  %784 = zext nneg i32 %spec.select.i1184 to i64
  %785 = shl nuw nsw i64 %784, 5
  %result.i.i1185 = call noalias ptr @bump_malloc_inner(i64 noundef %785, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1185, ptr %43, align 8
  %result.i20.i1186 = call noalias ptr @bump_malloc_inner(i64 noundef %785, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1186, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %786 = icmp sgt i32 %782, 0
  br i1 %786, label %.lr.ph.i2016, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2049.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2049.thread: ; preds = %778
  %787 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085

.lr.ph.i2016:                                     ; preds = %778, %._crit_edge.i2031
  %.060.i2029 = phi i32 [ %876, %._crit_edge.i2031 ], [ 0, %778 ]
  %788 = zext nneg i32 %.060.i2029 to i64
  %789 = shl nuw nsw i64 %788, 5
  %790 = getelementptr i8, ptr %780, i64 %789
  %791 = load ptr, ptr %790, align 8
  %792 = icmp ne ptr %791, @nil_typ
  %793 = icmp ne ptr %791, null
  %.not16.i2030 = and i1 %792, %793
  br i1 %.not16.i2030, label %794, label %._crit_edge.i2031

794:                                              ; preds = %.lr.ph.i2016
  %795 = getelementptr i8, ptr %790, i64 8
  %796 = load <2 x i64>, ptr %795, align 4
  %hash_coef_ptr.i.i18.i2033 = getelementptr i8, ptr %791, i64 8
  %tbl_size_ptr.i.i19.i2034 = getelementptr i8, ptr %791, i64 16
  %offset_tbl_ptr.i.i20.i2035 = getelementptr i8, ptr %791, i64 40
  %797 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %hash_coef.i.i99.i2618 = load i64, ptr %hash_coef_ptr.i.i18.i2033, align 4, !noalias !22
  %tbl_size.i.i100.i2619 = load i64, ptr %tbl_size_ptr.i.i19.i2034, align 4, !noalias !22
  %offset_tbl.i.i101.i2620 = load ptr, ptr %offset_tbl_ptr.i.i20.i2035, align 8, !noalias !22
  %product.i.i.i102.i2621 = mul i64 %hash_coef.i.i99.i2618, 4015701072841558310
  %shifted.i.i.i103.i2622 = lshr i64 %product.i.i.i102.i2621, 32
  %xored.i.i.i104.i2623 = xor i64 %shifted.i.i.i103.i2622, %product.i.i.i102.i2621
  %hash.i.i.i105.i2624 = and i64 %xored.i.i.i104.i2623, %tbl_size.i.i100.i2619
  %offset_ptr.i.i106.i2625 = getelementptr i32, ptr %offset_tbl.i.i101.i2620, i64 %hash.i.i.i105.i2624
  %offset.i.i121.i2626 = load i32, ptr %offset_ptr.i.i106.i2625, align 4, !noalias !185
  %798 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %799 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %801

801:                                              ; preds = %.cont.cont.i2647, %794
  %.0566.i2627 = phi i32 [ 0, %794 ], [ %805, %.cont.cont.i2647 ]
  %.070565.i2628 = phi i1 [ true, %794 ], [ %867, %.cont.cont.i2647 ]
  %.sroa.0.0564.i2629 = phi ptr [ %791, %794 ], [ %vptr.i142.sroa.speculated.i2650, %.cont.cont.i2647 ]
  %.sroa.17.0561.i2632 = phi i32 [ %offset.i.i121.i2626, %794 ], [ %offset.i.i154.i2664, %.cont.cont.i2647 ]
  %802 = phi <2 x i64> [ %796, %794 ], [ %866, %.cont.cont.i2647 ]
  %803 = extractelement <2 x i64> %802, i64 1
  %.sroa.12.0562.i2631 = inttoptr i64 %803 to ptr
  %804 = extractelement <2 x i64> %802, i64 0
  %.sroa.6.0563.i2630 = inttoptr i64 %804 to ptr
  %805 = add nuw nsw i32 %.0566.i2627, 1
  %806 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2629, 0
  %807 = insertvalue { ptr, ptr, ptr, i32 } %806, ptr %.sroa.6.0563.i2630, 1
  %808 = insertvalue { ptr, ptr, ptr, i32 } %807, ptr %.sroa.12.0562.i2631, 2
  %809 = insertvalue { ptr, ptr, ptr, i32 } %808, i32 %.sroa.17.0561.i2632, 3
  %810 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2629)
  %811 = sext i32 %.sroa.17.0561.i2632 to i64
  %812 = getelementptr ptr, ptr %.sroa.0.0564.i2629, i64 %811
  %813 = getelementptr i8, ptr %812, i64 64
  %814 = load ptr, ptr %813, align 8
  %result.i125.i2633 = call ptr %814({ ptr, ptr, ptr, i32 } %809, ptr nocapture nofree noundef nonnull readonly %2) #15
  %815 = call i32 %result.i125.i2633({ ptr, ptr, ptr, i32 } %809, { ptr, ptr, ptr, i32 } %809, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2628, label %816, label %832

816:                                              ; preds = %801
  %817 = load i32, ptr %42, align 8
  %818 = add i32 %817, -1
  %819 = and i32 %818, %815
  %820 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %821 = load ptr, ptr %43, align 8
  %822 = sext i32 %819 to i64
  %823 = shl nsw i64 %822, 5
  %824 = getelementptr i8, ptr %821, i64 %823
  %825 = load ptr, ptr %824, align 8
  %826 = getelementptr i8, ptr %824, i64 8
  %827 = load i160, ptr %826, align 4
  store ptr %.sroa.0.0564.i2629, ptr %824, align 8
  store i64 %804, ptr %826, align 4
  %.sroa_idx157.i2676 = getelementptr i8, ptr %824, i64 16
  store i64 %803, ptr %.sroa_idx157.i2676, align 4
  %.sroa_idx158.i2677 = getelementptr i8, ptr %824, i64 24
  store i32 %.sroa.17.0561.i2632, ptr %.sroa_idx158.i2677, align 4
  %828 = icmp ne ptr %825, @nil_typ
  %829 = icmp ne ptr %825, null
  %.not92.i2678 = and i1 %828, %829
  %extract.i2680 = lshr i160 %827, 64
  %830 = insertelement <2 x i160> poison, i160 %827, i64 0
  %831 = insertelement <2 x i160> %830, i160 %extract.i2680, i64 1
  br i1 %.not92.i2678, label %.cont.cont.i2647, label %871

832:                                              ; preds = %801
  %833 = add i32 %815, 2127912214
  %834 = shl i32 %815, 12
  %835 = add i32 %833, %834
  %836 = ashr i32 %835, 19
  %837 = xor i32 %835, %836
  %838 = xor i32 %837, -949894596
  %839 = add i32 %838, 374761393
  %840 = shl i32 %838, 5
  %841 = add i32 %839, %840
  %842 = add i32 %841, -744332180
  %843 = shl i32 %841, 9
  %844 = xor i32 %842, %843
  %845 = add i32 %844, -42973499
  %846 = shl i32 %844, 3
  %847 = add i32 %845, %846
  %848 = ashr i32 %847, 16
  %849 = xor i32 %847, %848
  %850 = xor i32 %849, -1252372727
  %851 = load i32, ptr %42, align 8
  %852 = add i32 %851, -1
  %853 = and i32 %852, %850
  %854 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %855 = load ptr, ptr %44, align 8
  %856 = sext i32 %853 to i64
  %857 = shl nsw i64 %856, 5
  %858 = getelementptr i8, ptr %855, i64 %857
  %859 = load ptr, ptr %858, align 8
  %860 = getelementptr i8, ptr %858, i64 8
  %861 = load i160, ptr %860, align 4
  store ptr %.sroa.0.0564.i2629, ptr %858, align 8
  store i64 %804, ptr %860, align 4
  %.sroa_idx161.i2637 = getelementptr i8, ptr %858, i64 16
  store i64 %803, ptr %.sroa_idx161.i2637, align 4
  %.sroa_idx162.i2638 = getelementptr i8, ptr %858, i64 24
  store i32 %.sroa.17.0561.i2632, ptr %.sroa_idx162.i2638, align 4
  %862 = icmp ne ptr %859, @nil_typ
  %863 = icmp ne ptr %859, null
  %.not90.i2639 = and i1 %862, %863
  %extract607.i2641 = lshr i160 %861, 64
  %864 = insertelement <2 x i160> poison, i160 %861, i64 0
  %865 = insertelement <2 x i160> %864, i160 %extract607.i2641, i64 1
  br i1 %.not90.i2639, label %.cont.cont.i2647, label %871

.cont.cont.i2647:                                 ; preds = %832, %816
  %vptr.i142.sroa.speculated.i2650 = phi ptr [ %825, %816 ], [ %859, %832 ]
  %.in3809 = phi <2 x i160> [ %831, %816 ], [ %865, %832 ]
  %866 = trunc <2 x i160> %.in3809 to <2 x i64>
  %867 = xor i1 %.070565.i2628, true
  %hash_coef_ptr.i.i143.i2653 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2650, i64 8
  %tbl_size_ptr.i.i144.i2654 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2650, i64 16
  %offset_tbl_ptr.i.i145.i2655 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2650, i64 40
  %hash_coef.i.i146.i2656 = load i64, ptr %hash_coef_ptr.i.i143.i2653, align 4
  %tbl_size.i.i147.i2657 = load i64, ptr %tbl_size_ptr.i.i144.i2654, align 4
  %offset_tbl.i.i148.i2658 = load ptr, ptr %offset_tbl_ptr.i.i145.i2655, align 8
  %product.i.i.i149.i2659 = mul i64 %hash_coef.i.i146.i2656, 4015701072841558310
  %shifted.i.i.i150.i2660 = lshr i64 %product.i.i.i149.i2659, 32
  %xored.i.i.i151.i2661 = xor i64 %shifted.i.i.i150.i2660, %product.i.i.i149.i2659
  %hash.i.i.i152.i2662 = and i64 %xored.i.i.i151.i2661, %tbl_size.i.i147.i2657
  %offset_ptr.i.i153.i2663 = getelementptr i32, ptr %offset_tbl.i.i148.i2658, i64 %hash.i.i.i152.i2662
  %offset.i.i154.i2664 = load i32, ptr %offset_ptr.i.i153.i2663, align 4
  %868 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %869 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %870 = icmp ult i32 %.0566.i2627, 99
  br i1 %870, label %801, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2682

871:                                              ; preds = %832, %816
  %872 = phi ptr [ %22, %832 ], [ %21, %816 ]
  %873 = load i32, ptr %65, align 4
  store i32 %873, ptr %872, align 4
  %874 = add i32 %873, 1
  %875 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %874, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2682

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2682: ; preds = %.cont.cont.i2647, %871
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %._crit_edge.i2031

._crit_edge.i2031:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2682, %.lr.ph.i2016
  %876 = add nuw nsw i32 %.060.i2029, 1
  %877 = icmp slt i32 %876, %782
  br i1 %877, label %.lr.ph.i2016, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2049

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2049: ; preds = %._crit_edge.i2031
  %878 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %879

879:                                              ; preds = %._crit_edge.i2067, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2049
  %.060.i2065 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2049 ], [ %968, %._crit_edge.i2067 ]
  %880 = zext nneg i32 %.060.i2065 to i64
  %881 = shl nuw nsw i64 %880, 5
  %882 = getelementptr i8, ptr %781, i64 %881
  %883 = load ptr, ptr %882, align 8
  %884 = icmp ne ptr %883, @nil_typ
  %885 = icmp ne ptr %883, null
  %.not16.i2066 = and i1 %884, %885
  br i1 %.not16.i2066, label %886, label %._crit_edge.i2067

886:                                              ; preds = %879
  %887 = getelementptr i8, ptr %882, i64 8
  %888 = load <2 x i64>, ptr %887, align 4
  %hash_coef_ptr.i.i18.i2069 = getelementptr i8, ptr %883, i64 8
  %tbl_size_ptr.i.i19.i2070 = getelementptr i8, ptr %883, i64 16
  %offset_tbl_ptr.i.i20.i2071 = getelementptr i8, ptr %883, i64 40
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i2700 = load i64, ptr %hash_coef_ptr.i.i18.i2069, align 4, !noalias !22
  %tbl_size.i.i100.i2701 = load i64, ptr %tbl_size_ptr.i.i19.i2070, align 4, !noalias !22
  %offset_tbl.i.i101.i2702 = load ptr, ptr %offset_tbl_ptr.i.i20.i2071, align 8, !noalias !22
  %product.i.i.i102.i2703 = mul i64 %hash_coef.i.i99.i2700, 4015701072841558310
  %shifted.i.i.i103.i2704 = lshr i64 %product.i.i.i102.i2703, 32
  %xored.i.i.i104.i2705 = xor i64 %shifted.i.i.i103.i2704, %product.i.i.i102.i2703
  %hash.i.i.i105.i2706 = and i64 %xored.i.i.i104.i2705, %tbl_size.i.i100.i2701
  %offset_ptr.i.i106.i2707 = getelementptr i32, ptr %offset_tbl.i.i101.i2702, i64 %hash.i.i.i105.i2706
  %offset.i.i121.i2708 = load i32, ptr %offset_ptr.i.i106.i2707, align 4, !noalias !188
  %890 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %892 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %893

893:                                              ; preds = %.cont.cont.i2729, %886
  %.0566.i2709 = phi i32 [ 0, %886 ], [ %897, %.cont.cont.i2729 ]
  %.070565.i2710 = phi i1 [ true, %886 ], [ %959, %.cont.cont.i2729 ]
  %.sroa.0.0564.i2711 = phi ptr [ %883, %886 ], [ %vptr.i142.sroa.speculated.i2732, %.cont.cont.i2729 ]
  %.sroa.17.0561.i2714 = phi i32 [ %offset.i.i121.i2708, %886 ], [ %offset.i.i154.i2746, %.cont.cont.i2729 ]
  %894 = phi <2 x i64> [ %888, %886 ], [ %958, %.cont.cont.i2729 ]
  %895 = extractelement <2 x i64> %894, i64 1
  %.sroa.12.0562.i2713 = inttoptr i64 %895 to ptr
  %896 = extractelement <2 x i64> %894, i64 0
  %.sroa.6.0563.i2712 = inttoptr i64 %896 to ptr
  %897 = add nuw nsw i32 %.0566.i2709, 1
  %898 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2711, 0
  %899 = insertvalue { ptr, ptr, ptr, i32 } %898, ptr %.sroa.6.0563.i2712, 1
  %900 = insertvalue { ptr, ptr, ptr, i32 } %899, ptr %.sroa.12.0562.i2713, 2
  %901 = insertvalue { ptr, ptr, ptr, i32 } %900, i32 %.sroa.17.0561.i2714, 3
  %902 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2711)
  %903 = sext i32 %.sroa.17.0561.i2714 to i64
  %904 = getelementptr ptr, ptr %.sroa.0.0564.i2711, i64 %903
  %905 = getelementptr i8, ptr %904, i64 64
  %906 = load ptr, ptr %905, align 8
  %result.i125.i2715 = call ptr %906({ ptr, ptr, ptr, i32 } %901, ptr nocapture nofree noundef nonnull readonly %2) #15
  %907 = call i32 %result.i125.i2715({ ptr, ptr, ptr, i32 } %901, { ptr, ptr, ptr, i32 } %901, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2710, label %908, label %924

908:                                              ; preds = %893
  %909 = load i32, ptr %42, align 8
  %910 = add i32 %909, -1
  %911 = and i32 %910, %907
  %912 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %913 = load ptr, ptr %43, align 8
  %914 = sext i32 %911 to i64
  %915 = shl nsw i64 %914, 5
  %916 = getelementptr i8, ptr %913, i64 %915
  %917 = load ptr, ptr %916, align 8
  %918 = getelementptr i8, ptr %916, i64 8
  %919 = load i160, ptr %918, align 4
  store ptr %.sroa.0.0564.i2711, ptr %916, align 8
  store i64 %896, ptr %918, align 4
  %.sroa_idx157.i2758 = getelementptr i8, ptr %916, i64 16
  store i64 %895, ptr %.sroa_idx157.i2758, align 4
  %.sroa_idx158.i2759 = getelementptr i8, ptr %916, i64 24
  store i32 %.sroa.17.0561.i2714, ptr %.sroa_idx158.i2759, align 4
  %920 = icmp ne ptr %917, @nil_typ
  %921 = icmp ne ptr %917, null
  %.not92.i2760 = and i1 %920, %921
  %extract.i2762 = lshr i160 %919, 64
  %922 = insertelement <2 x i160> poison, i160 %919, i64 0
  %923 = insertelement <2 x i160> %922, i160 %extract.i2762, i64 1
  br i1 %.not92.i2760, label %.cont.cont.i2729, label %963

924:                                              ; preds = %893
  %925 = add i32 %907, 2127912214
  %926 = shl i32 %907, 12
  %927 = add i32 %925, %926
  %928 = ashr i32 %927, 19
  %929 = xor i32 %927, %928
  %930 = xor i32 %929, -949894596
  %931 = add i32 %930, 374761393
  %932 = shl i32 %930, 5
  %933 = add i32 %931, %932
  %934 = add i32 %933, -744332180
  %935 = shl i32 %933, 9
  %936 = xor i32 %934, %935
  %937 = add i32 %936, -42973499
  %938 = shl i32 %936, 3
  %939 = add i32 %937, %938
  %940 = ashr i32 %939, 16
  %941 = xor i32 %939, %940
  %942 = xor i32 %941, -1252372727
  %943 = load i32, ptr %42, align 8
  %944 = add i32 %943, -1
  %945 = and i32 %944, %942
  %946 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %947 = load ptr, ptr %44, align 8
  %948 = sext i32 %945 to i64
  %949 = shl nsw i64 %948, 5
  %950 = getelementptr i8, ptr %947, i64 %949
  %951 = load ptr, ptr %950, align 8
  %952 = getelementptr i8, ptr %950, i64 8
  %953 = load i160, ptr %952, align 4
  store ptr %.sroa.0.0564.i2711, ptr %950, align 8
  store i64 %896, ptr %952, align 4
  %.sroa_idx161.i2719 = getelementptr i8, ptr %950, i64 16
  store i64 %895, ptr %.sroa_idx161.i2719, align 4
  %.sroa_idx162.i2720 = getelementptr i8, ptr %950, i64 24
  store i32 %.sroa.17.0561.i2714, ptr %.sroa_idx162.i2720, align 4
  %954 = icmp ne ptr %951, @nil_typ
  %955 = icmp ne ptr %951, null
  %.not90.i2721 = and i1 %954, %955
  %extract607.i2723 = lshr i160 %953, 64
  %956 = insertelement <2 x i160> poison, i160 %953, i64 0
  %957 = insertelement <2 x i160> %956, i160 %extract607.i2723, i64 1
  br i1 %.not90.i2721, label %.cont.cont.i2729, label %963

.cont.cont.i2729:                                 ; preds = %924, %908
  %vptr.i142.sroa.speculated.i2732 = phi ptr [ %917, %908 ], [ %951, %924 ]
  %.in3810 = phi <2 x i160> [ %923, %908 ], [ %957, %924 ]
  %958 = trunc <2 x i160> %.in3810 to <2 x i64>
  %959 = xor i1 %.070565.i2710, true
  %hash_coef_ptr.i.i143.i2735 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2732, i64 8
  %tbl_size_ptr.i.i144.i2736 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2732, i64 16
  %offset_tbl_ptr.i.i145.i2737 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2732, i64 40
  %hash_coef.i.i146.i2738 = load i64, ptr %hash_coef_ptr.i.i143.i2735, align 4
  %tbl_size.i.i147.i2739 = load i64, ptr %tbl_size_ptr.i.i144.i2736, align 4
  %offset_tbl.i.i148.i2740 = load ptr, ptr %offset_tbl_ptr.i.i145.i2737, align 8
  %product.i.i.i149.i2741 = mul i64 %hash_coef.i.i146.i2738, 4015701072841558310
  %shifted.i.i.i150.i2742 = lshr i64 %product.i.i.i149.i2741, 32
  %xored.i.i.i151.i2743 = xor i64 %shifted.i.i.i150.i2742, %product.i.i.i149.i2741
  %hash.i.i.i152.i2744 = and i64 %xored.i.i.i151.i2743, %tbl_size.i.i147.i2739
  %offset_ptr.i.i153.i2745 = getelementptr i32, ptr %offset_tbl.i.i148.i2740, i64 %hash.i.i.i152.i2744
  %offset.i.i154.i2746 = load i32, ptr %offset_ptr.i.i153.i2745, align 4
  %960 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %961 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %962 = icmp ult i32 %.0566.i2709, 99
  br i1 %962, label %893, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2764

963:                                              ; preds = %924, %908
  %964 = phi ptr [ %20, %924 ], [ %19, %908 ]
  %965 = load i32, ptr %65, align 4
  store i32 %965, ptr %964, align 4
  %966 = add i32 %965, 1
  %967 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %966, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2764

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2764: ; preds = %.cont.cont.i2729, %963
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %._crit_edge.i2067

._crit_edge.i2067:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2764, %879
  %968 = add nuw nsw i32 %.060.i2065, 1
  %969 = icmp slt i32 %968, %782
  br i1 %969, label %879, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085: ; preds = %._crit_edge.i2067, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2049.thread
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %32)
  %hash_coef.i.i99.i1207 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i1208 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1209 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i1210 = mul i64 %hash_coef.i.i99.i1207, 4015701072841558310
  %shifted.i.i.i103.i1211 = lshr i64 %product.i.i.i102.i1210, 32
  %xored.i.i.i104.i1212 = xor i64 %shifted.i.i.i103.i1211, %product.i.i.i102.i1210
  %hash.i.i.i105.i1213 = and i64 %xored.i.i.i104.i1212, %tbl_size.i.i100.i1208
  %offset_ptr.i.i106.i1214 = getelementptr i32, ptr %offset_tbl.i.i101.i1209, i64 %hash.i.i.i105.i1213
  %offset.i.i121.i1215 = load i32, ptr %offset_ptr.i.i106.i1214, align 4, !noalias !191
  %970 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %971 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %973

973:                                              ; preds = %.cont.cont.i1237, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085
  %.0566.i1217 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085 ], [ %977, %.cont.cont.i1237 ]
  %.070565.i1218 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085 ], [ %1039, %.cont.cont.i1237 ]
  %.sroa.0.0564.i1219 = phi ptr [ %vptr.i142.sroa.speculated.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085 ], [ %vptr.i142.sroa.speculated.i1240, %.cont.cont.i1237 ]
  %.sroa.17.0561.i1222 = phi i32 [ %offset.i.i121.i1215, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085 ], [ %offset.i.i154.i1254, %.cont.cont.i1237 ]
  %974 = phi <2 x i64> [ %766, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2085 ], [ %1038, %.cont.cont.i1237 ]
  %975 = extractelement <2 x i64> %974, i64 1
  %.sroa.12.0562.i1221 = inttoptr i64 %975 to ptr
  %976 = extractelement <2 x i64> %974, i64 0
  %.sroa.6.0563.i1220 = inttoptr i64 %976 to ptr
  %977 = add nuw nsw i32 %.0566.i1217, 1
  %978 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1219, 0
  %979 = insertvalue { ptr, ptr, ptr, i32 } %978, ptr %.sroa.6.0563.i1220, 1
  %980 = insertvalue { ptr, ptr, ptr, i32 } %979, ptr %.sroa.12.0562.i1221, 2
  %981 = insertvalue { ptr, ptr, ptr, i32 } %980, i32 %.sroa.17.0561.i1222, 3
  %982 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1219)
  %983 = sext i32 %.sroa.17.0561.i1222 to i64
  %984 = getelementptr ptr, ptr %.sroa.0.0564.i1219, i64 %983
  %985 = getelementptr i8, ptr %984, i64 64
  %986 = load ptr, ptr %985, align 8
  %result.i125.i1223 = call ptr %986({ ptr, ptr, ptr, i32 } %981, ptr nocapture nofree noundef nonnull readonly %2) #15
  %987 = call i32 %result.i125.i1223({ ptr, ptr, ptr, i32 } %981, { ptr, ptr, ptr, i32 } %981, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1218, label %988, label %1004

988:                                              ; preds = %973
  %989 = load i32, ptr %42, align 8
  %990 = add i32 %989, -1
  %991 = and i32 %990, %987
  %992 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %993 = load ptr, ptr %43, align 8
  %994 = sext i32 %991 to i64
  %995 = shl nsw i64 %994, 5
  %996 = getelementptr i8, ptr %993, i64 %995
  %997 = load ptr, ptr %996, align 8
  %998 = getelementptr i8, ptr %996, i64 8
  %999 = load i160, ptr %998, align 4
  store ptr %.sroa.0.0564.i1219, ptr %996, align 8
  store i64 %976, ptr %998, align 4
  %.sroa_idx157.i1266 = getelementptr i8, ptr %996, i64 16
  store i64 %975, ptr %.sroa_idx157.i1266, align 4
  %.sroa_idx158.i1267 = getelementptr i8, ptr %996, i64 24
  store i32 %.sroa.17.0561.i1222, ptr %.sroa_idx158.i1267, align 4
  %1000 = icmp ne ptr %997, @nil_typ
  %1001 = icmp ne ptr %997, null
  %.not92.i1268 = and i1 %1000, %1001
  %extract.i1270 = lshr i160 %999, 64
  %1002 = insertelement <2 x i160> poison, i160 %999, i64 0
  %1003 = insertelement <2 x i160> %1002, i160 %extract.i1270, i64 1
  br i1 %.not92.i1268, label %.cont.cont.i1237, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1272.thread

1004:                                             ; preds = %973
  %1005 = add i32 %987, 2127912214
  %1006 = shl i32 %987, 12
  %1007 = add i32 %1005, %1006
  %1008 = ashr i32 %1007, 19
  %1009 = xor i32 %1007, %1008
  %1010 = xor i32 %1009, -949894596
  %1011 = add i32 %1010, 374761393
  %1012 = shl i32 %1010, 5
  %1013 = add i32 %1011, %1012
  %1014 = add i32 %1013, -744332180
  %1015 = shl i32 %1013, 9
  %1016 = xor i32 %1014, %1015
  %1017 = add i32 %1016, -42973499
  %1018 = shl i32 %1016, 3
  %1019 = add i32 %1017, %1018
  %1020 = ashr i32 %1019, 16
  %1021 = xor i32 %1019, %1020
  %1022 = xor i32 %1021, -1252372727
  %1023 = load i32, ptr %42, align 8
  %1024 = add i32 %1023, -1
  %1025 = and i32 %1024, %1022
  %1026 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1027 = load ptr, ptr %44, align 8
  %1028 = sext i32 %1025 to i64
  %1029 = shl nsw i64 %1028, 5
  %1030 = getelementptr i8, ptr %1027, i64 %1029
  %1031 = load ptr, ptr %1030, align 8
  %1032 = getelementptr i8, ptr %1030, i64 8
  %1033 = load i160, ptr %1032, align 4
  store ptr %.sroa.0.0564.i1219, ptr %1030, align 8
  store i64 %976, ptr %1032, align 4
  %.sroa_idx161.i1227 = getelementptr i8, ptr %1030, i64 16
  store i64 %975, ptr %.sroa_idx161.i1227, align 4
  %.sroa_idx162.i1228 = getelementptr i8, ptr %1030, i64 24
  store i32 %.sroa.17.0561.i1222, ptr %.sroa_idx162.i1228, align 4
  %1034 = icmp ne ptr %1031, @nil_typ
  %1035 = icmp ne ptr %1031, null
  %.not90.i1229 = and i1 %1034, %1035
  %extract607.i1231 = lshr i160 %1033, 64
  %1036 = insertelement <2 x i160> poison, i160 %1033, i64 0
  %1037 = insertelement <2 x i160> %1036, i160 %extract607.i1231, i64 1
  br i1 %.not90.i1229, label %.cont.cont.i1237, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1272.thread

.cont.cont.i1237:                                 ; preds = %1004, %988
  %vptr.i142.sroa.speculated.i1240 = phi ptr [ %997, %988 ], [ %1031, %1004 ]
  %.in3811 = phi <2 x i160> [ %1003, %988 ], [ %1037, %1004 ]
  %1038 = trunc <2 x i160> %.in3811 to <2 x i64>
  %1039 = xor i1 %.070565.i1218, true
  %hash_coef_ptr.i.i143.i1243 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1240, i64 8
  %tbl_size_ptr.i.i144.i1244 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1240, i64 16
  %offset_tbl_ptr.i.i145.i1245 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1240, i64 40
  %hash_coef.i.i146.i1246 = load i64, ptr %hash_coef_ptr.i.i143.i1243, align 4
  %tbl_size.i.i147.i1247 = load i64, ptr %tbl_size_ptr.i.i144.i1244, align 4
  %offset_tbl.i.i148.i1248 = load ptr, ptr %offset_tbl_ptr.i.i145.i1245, align 8
  %product.i.i.i149.i1249 = mul i64 %hash_coef.i.i146.i1246, 4015701072841558310
  %shifted.i.i.i150.i1250 = lshr i64 %product.i.i.i149.i1249, 32
  %xored.i.i.i151.i1251 = xor i64 %shifted.i.i.i150.i1250, %product.i.i.i149.i1249
  %hash.i.i.i152.i1252 = and i64 %xored.i.i.i151.i1251, %tbl_size.i.i147.i1247
  %offset_ptr.i.i153.i1253 = getelementptr i32, ptr %offset_tbl.i.i148.i1248, i64 %hash.i.i.i152.i1252
  %offset.i.i154.i1254 = load i32, ptr %offset_ptr.i.i153.i1253, align 4
  %1040 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1041 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1042 = icmp ult i32 %.0566.i1217, 99
  br i1 %1042, label %973, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1272

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1272.thread: ; preds = %988, %1004
  %1043 = phi ptr [ %32, %1004 ], [ %31, %988 ]
  %1044 = load i32, ptr %65, align 4
  store i32 %1044, ptr %1043, align 4
  %1045 = add i32 %1044, 1
  %1046 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1045, ptr %65, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1272: ; preds = %.cont.cont.i1237
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  %1047 = icmp eq ptr %vptr.i142.sroa.speculated.i1240, null
  br i1 %1047, label %HashMap_insert_keyK_valueV.exit, label %1048

1048:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1272
  %1049 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1050 = load ptr, ptr %43, align 8
  %1051 = load ptr, ptr %44, align 8
  %1052 = load i32, ptr %42, align 8
  %1053 = shl i32 %1052, 1
  %spec.select.i1288 = call i32 @llvm.smax.i32(i32 %1053, i32 16)
  store i32 %spec.select.i1288, ptr %42, align 8
  %1054 = zext nneg i32 %spec.select.i1288 to i64
  %1055 = shl nuw nsw i64 %1054, 5
  %result.i.i1289 = call noalias ptr @bump_malloc_inner(i64 noundef %1055, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1289, ptr %43, align 8
  %result.i20.i1290 = call noalias ptr @bump_malloc_inner(i64 noundef %1055, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1290, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %1056 = icmp sgt i32 %1052, 0
  br i1 %1056, label %.lr.ph.i2115, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2148.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2148.thread: ; preds = %1048
  %1057 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit

.lr.ph.i2115:                                     ; preds = %1048, %._crit_edge.i2130
  %.060.i2128 = phi i32 [ %1146, %._crit_edge.i2130 ], [ 0, %1048 ]
  %1058 = zext nneg i32 %.060.i2128 to i64
  %1059 = shl nuw nsw i64 %1058, 5
  %1060 = getelementptr i8, ptr %1050, i64 %1059
  %1061 = load ptr, ptr %1060, align 8
  %1062 = icmp ne ptr %1061, @nil_typ
  %1063 = icmp ne ptr %1061, null
  %.not16.i2129 = and i1 %1062, %1063
  br i1 %.not16.i2129, label %1064, label %._crit_edge.i2130

1064:                                             ; preds = %.lr.ph.i2115
  %1065 = getelementptr i8, ptr %1060, i64 8
  %1066 = load <2 x i64>, ptr %1065, align 4
  %hash_coef_ptr.i.i18.i2132 = getelementptr i8, ptr %1061, i64 8
  %tbl_size_ptr.i.i19.i2133 = getelementptr i8, ptr %1061, i64 16
  %offset_tbl_ptr.i.i20.i2134 = getelementptr i8, ptr %1061, i64 40
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i2782 = load i64, ptr %hash_coef_ptr.i.i18.i2132, align 4, !noalias !22
  %tbl_size.i.i100.i2783 = load i64, ptr %tbl_size_ptr.i.i19.i2133, align 4, !noalias !22
  %offset_tbl.i.i101.i2784 = load ptr, ptr %offset_tbl_ptr.i.i20.i2134, align 8, !noalias !22
  %product.i.i.i102.i2785 = mul i64 %hash_coef.i.i99.i2782, 4015701072841558310
  %shifted.i.i.i103.i2786 = lshr i64 %product.i.i.i102.i2785, 32
  %xored.i.i.i104.i2787 = xor i64 %shifted.i.i.i103.i2786, %product.i.i.i102.i2785
  %hash.i.i.i105.i2788 = and i64 %xored.i.i.i104.i2787, %tbl_size.i.i100.i2783
  %offset_ptr.i.i106.i2789 = getelementptr i32, ptr %offset_tbl.i.i101.i2784, i64 %hash.i.i.i105.i2788
  %offset.i.i121.i2790 = load i32, ptr %offset_ptr.i.i106.i2789, align 4, !noalias !194
  %1068 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1071

1071:                                             ; preds = %.cont.cont.i2811, %1064
  %.0566.i2791 = phi i32 [ 0, %1064 ], [ %1075, %.cont.cont.i2811 ]
  %.070565.i2792 = phi i1 [ true, %1064 ], [ %1137, %.cont.cont.i2811 ]
  %.sroa.0.0564.i2793 = phi ptr [ %1061, %1064 ], [ %vptr.i142.sroa.speculated.i2814, %.cont.cont.i2811 ]
  %.sroa.17.0561.i2796 = phi i32 [ %offset.i.i121.i2790, %1064 ], [ %offset.i.i154.i2828, %.cont.cont.i2811 ]
  %1072 = phi <2 x i64> [ %1066, %1064 ], [ %1136, %.cont.cont.i2811 ]
  %1073 = extractelement <2 x i64> %1072, i64 1
  %.sroa.12.0562.i2795 = inttoptr i64 %1073 to ptr
  %1074 = extractelement <2 x i64> %1072, i64 0
  %.sroa.6.0563.i2794 = inttoptr i64 %1074 to ptr
  %1075 = add nuw nsw i32 %.0566.i2791, 1
  %1076 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2793, 0
  %1077 = insertvalue { ptr, ptr, ptr, i32 } %1076, ptr %.sroa.6.0563.i2794, 1
  %1078 = insertvalue { ptr, ptr, ptr, i32 } %1077, ptr %.sroa.12.0562.i2795, 2
  %1079 = insertvalue { ptr, ptr, ptr, i32 } %1078, i32 %.sroa.17.0561.i2796, 3
  %1080 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2793)
  %1081 = sext i32 %.sroa.17.0561.i2796 to i64
  %1082 = getelementptr ptr, ptr %.sroa.0.0564.i2793, i64 %1081
  %1083 = getelementptr i8, ptr %1082, i64 64
  %1084 = load ptr, ptr %1083, align 8
  %result.i125.i2797 = call ptr %1084({ ptr, ptr, ptr, i32 } %1079, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1085 = call i32 %result.i125.i2797({ ptr, ptr, ptr, i32 } %1079, { ptr, ptr, ptr, i32 } %1079, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2792, label %1086, label %1102

1086:                                             ; preds = %1071
  %1087 = load i32, ptr %42, align 8
  %1088 = add i32 %1087, -1
  %1089 = and i32 %1088, %1085
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1091 = load ptr, ptr %43, align 8
  %1092 = sext i32 %1089 to i64
  %1093 = shl nsw i64 %1092, 5
  %1094 = getelementptr i8, ptr %1091, i64 %1093
  %1095 = load ptr, ptr %1094, align 8
  %1096 = getelementptr i8, ptr %1094, i64 8
  %1097 = load i160, ptr %1096, align 4
  store ptr %.sroa.0.0564.i2793, ptr %1094, align 8
  store i64 %1074, ptr %1096, align 4
  %.sroa_idx157.i2840 = getelementptr i8, ptr %1094, i64 16
  store i64 %1073, ptr %.sroa_idx157.i2840, align 4
  %.sroa_idx158.i2841 = getelementptr i8, ptr %1094, i64 24
  store i32 %.sroa.17.0561.i2796, ptr %.sroa_idx158.i2841, align 4
  %1098 = icmp ne ptr %1095, @nil_typ
  %1099 = icmp ne ptr %1095, null
  %.not92.i2842 = and i1 %1098, %1099
  %extract.i2844 = lshr i160 %1097, 64
  %1100 = insertelement <2 x i160> poison, i160 %1097, i64 0
  %1101 = insertelement <2 x i160> %1100, i160 %extract.i2844, i64 1
  br i1 %.not92.i2842, label %.cont.cont.i2811, label %1141

1102:                                             ; preds = %1071
  %1103 = add i32 %1085, 2127912214
  %1104 = shl i32 %1085, 12
  %1105 = add i32 %1103, %1104
  %1106 = ashr i32 %1105, 19
  %1107 = xor i32 %1105, %1106
  %1108 = xor i32 %1107, -949894596
  %1109 = add i32 %1108, 374761393
  %1110 = shl i32 %1108, 5
  %1111 = add i32 %1109, %1110
  %1112 = add i32 %1111, -744332180
  %1113 = shl i32 %1111, 9
  %1114 = xor i32 %1112, %1113
  %1115 = add i32 %1114, -42973499
  %1116 = shl i32 %1114, 3
  %1117 = add i32 %1115, %1116
  %1118 = ashr i32 %1117, 16
  %1119 = xor i32 %1117, %1118
  %1120 = xor i32 %1119, -1252372727
  %1121 = load i32, ptr %42, align 8
  %1122 = add i32 %1121, -1
  %1123 = and i32 %1122, %1120
  %1124 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1125 = load ptr, ptr %44, align 8
  %1126 = sext i32 %1123 to i64
  %1127 = shl nsw i64 %1126, 5
  %1128 = getelementptr i8, ptr %1125, i64 %1127
  %1129 = load ptr, ptr %1128, align 8
  %1130 = getelementptr i8, ptr %1128, i64 8
  %1131 = load i160, ptr %1130, align 4
  store ptr %.sroa.0.0564.i2793, ptr %1128, align 8
  store i64 %1074, ptr %1130, align 4
  %.sroa_idx161.i2801 = getelementptr i8, ptr %1128, i64 16
  store i64 %1073, ptr %.sroa_idx161.i2801, align 4
  %.sroa_idx162.i2802 = getelementptr i8, ptr %1128, i64 24
  store i32 %.sroa.17.0561.i2796, ptr %.sroa_idx162.i2802, align 4
  %1132 = icmp ne ptr %1129, @nil_typ
  %1133 = icmp ne ptr %1129, null
  %.not90.i2803 = and i1 %1132, %1133
  %extract607.i2805 = lshr i160 %1131, 64
  %1134 = insertelement <2 x i160> poison, i160 %1131, i64 0
  %1135 = insertelement <2 x i160> %1134, i160 %extract607.i2805, i64 1
  br i1 %.not90.i2803, label %.cont.cont.i2811, label %1141

.cont.cont.i2811:                                 ; preds = %1102, %1086
  %vptr.i142.sroa.speculated.i2814 = phi ptr [ %1095, %1086 ], [ %1129, %1102 ]
  %.in3812 = phi <2 x i160> [ %1101, %1086 ], [ %1135, %1102 ]
  %1136 = trunc <2 x i160> %.in3812 to <2 x i64>
  %1137 = xor i1 %.070565.i2792, true
  %hash_coef_ptr.i.i143.i2817 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2814, i64 8
  %tbl_size_ptr.i.i144.i2818 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2814, i64 16
  %offset_tbl_ptr.i.i145.i2819 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2814, i64 40
  %hash_coef.i.i146.i2820 = load i64, ptr %hash_coef_ptr.i.i143.i2817, align 4
  %tbl_size.i.i147.i2821 = load i64, ptr %tbl_size_ptr.i.i144.i2818, align 4
  %offset_tbl.i.i148.i2822 = load ptr, ptr %offset_tbl_ptr.i.i145.i2819, align 8
  %product.i.i.i149.i2823 = mul i64 %hash_coef.i.i146.i2820, 4015701072841558310
  %shifted.i.i.i150.i2824 = lshr i64 %product.i.i.i149.i2823, 32
  %xored.i.i.i151.i2825 = xor i64 %shifted.i.i.i150.i2824, %product.i.i.i149.i2823
  %hash.i.i.i152.i2826 = and i64 %xored.i.i.i151.i2825, %tbl_size.i.i147.i2821
  %offset_ptr.i.i153.i2827 = getelementptr i32, ptr %offset_tbl.i.i148.i2822, i64 %hash.i.i.i152.i2826
  %offset.i.i154.i2828 = load i32, ptr %offset_ptr.i.i153.i2827, align 4
  %1138 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1139 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1140 = icmp ult i32 %.0566.i2791, 99
  br i1 %1140, label %1071, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2846

1141:                                             ; preds = %1102, %1086
  %1142 = phi ptr [ %18, %1102 ], [ %17, %1086 ]
  %1143 = load i32, ptr %65, align 4
  store i32 %1143, ptr %1142, align 4
  %1144 = add i32 %1143, 1
  %1145 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1144, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2846

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2846: ; preds = %.cont.cont.i2811, %1141
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i2130

._crit_edge.i2130:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2846, %.lr.ph.i2115
  %1146 = add nuw nsw i32 %.060.i2128, 1
  %1147 = icmp slt i32 %1146, %1052
  br i1 %1147, label %.lr.ph.i2115, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2148

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2148: ; preds = %._crit_edge.i2130
  %1148 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1149

1149:                                             ; preds = %._crit_edge.i2166, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2148
  %.060.i2164 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2148 ], [ %1238, %._crit_edge.i2166 ]
  %1150 = zext nneg i32 %.060.i2164 to i64
  %1151 = shl nuw nsw i64 %1150, 5
  %1152 = getelementptr i8, ptr %1051, i64 %1151
  %1153 = load ptr, ptr %1152, align 8
  %1154 = icmp ne ptr %1153, @nil_typ
  %1155 = icmp ne ptr %1153, null
  %.not16.i2165 = and i1 %1154, %1155
  br i1 %.not16.i2165, label %1156, label %._crit_edge.i2166

1156:                                             ; preds = %1149
  %1157 = getelementptr i8, ptr %1152, i64 8
  %1158 = load <2 x i64>, ptr %1157, align 4
  %hash_coef_ptr.i.i18.i2168 = getelementptr i8, ptr %1153, i64 8
  %tbl_size_ptr.i.i19.i2169 = getelementptr i8, ptr %1153, i64 16
  %offset_tbl_ptr.i.i20.i2170 = getelementptr i8, ptr %1153, i64 40
  %1159 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i2864 = load i64, ptr %hash_coef_ptr.i.i18.i2168, align 4, !noalias !22
  %tbl_size.i.i100.i2865 = load i64, ptr %tbl_size_ptr.i.i19.i2169, align 4, !noalias !22
  %offset_tbl.i.i101.i2866 = load ptr, ptr %offset_tbl_ptr.i.i20.i2170, align 8, !noalias !22
  %product.i.i.i102.i2867 = mul i64 %hash_coef.i.i99.i2864, 4015701072841558310
  %shifted.i.i.i103.i2868 = lshr i64 %product.i.i.i102.i2867, 32
  %xored.i.i.i104.i2869 = xor i64 %shifted.i.i.i103.i2868, %product.i.i.i102.i2867
  %hash.i.i.i105.i2870 = and i64 %xored.i.i.i104.i2869, %tbl_size.i.i100.i2865
  %offset_ptr.i.i106.i2871 = getelementptr i32, ptr %offset_tbl.i.i101.i2866, i64 %hash.i.i.i105.i2870
  %offset.i.i121.i2872 = load i32, ptr %offset_ptr.i.i106.i2871, align 4, !noalias !197
  %1160 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1162 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1163

1163:                                             ; preds = %.cont.cont.i2893, %1156
  %.0566.i2873 = phi i32 [ 0, %1156 ], [ %1167, %.cont.cont.i2893 ]
  %.070565.i2874 = phi i1 [ true, %1156 ], [ %1229, %.cont.cont.i2893 ]
  %.sroa.0.0564.i2875 = phi ptr [ %1153, %1156 ], [ %vptr.i142.sroa.speculated.i2896, %.cont.cont.i2893 ]
  %.sroa.17.0561.i2878 = phi i32 [ %offset.i.i121.i2872, %1156 ], [ %offset.i.i154.i2910, %.cont.cont.i2893 ]
  %1164 = phi <2 x i64> [ %1158, %1156 ], [ %1228, %.cont.cont.i2893 ]
  %1165 = extractelement <2 x i64> %1164, i64 1
  %.sroa.12.0562.i2877 = inttoptr i64 %1165 to ptr
  %1166 = extractelement <2 x i64> %1164, i64 0
  %.sroa.6.0563.i2876 = inttoptr i64 %1166 to ptr
  %1167 = add nuw nsw i32 %.0566.i2873, 1
  %1168 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2875, 0
  %1169 = insertvalue { ptr, ptr, ptr, i32 } %1168, ptr %.sroa.6.0563.i2876, 1
  %1170 = insertvalue { ptr, ptr, ptr, i32 } %1169, ptr %.sroa.12.0562.i2877, 2
  %1171 = insertvalue { ptr, ptr, ptr, i32 } %1170, i32 %.sroa.17.0561.i2878, 3
  %1172 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2875)
  %1173 = sext i32 %.sroa.17.0561.i2878 to i64
  %1174 = getelementptr ptr, ptr %.sroa.0.0564.i2875, i64 %1173
  %1175 = getelementptr i8, ptr %1174, i64 64
  %1176 = load ptr, ptr %1175, align 8
  %result.i125.i2879 = call ptr %1176({ ptr, ptr, ptr, i32 } %1171, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1177 = call i32 %result.i125.i2879({ ptr, ptr, ptr, i32 } %1171, { ptr, ptr, ptr, i32 } %1171, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2874, label %1178, label %1194

1178:                                             ; preds = %1163
  %1179 = load i32, ptr %42, align 8
  %1180 = add i32 %1179, -1
  %1181 = and i32 %1180, %1177
  %1182 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1183 = load ptr, ptr %43, align 8
  %1184 = sext i32 %1181 to i64
  %1185 = shl nsw i64 %1184, 5
  %1186 = getelementptr i8, ptr %1183, i64 %1185
  %1187 = load ptr, ptr %1186, align 8
  %1188 = getelementptr i8, ptr %1186, i64 8
  %1189 = load i160, ptr %1188, align 4
  store ptr %.sroa.0.0564.i2875, ptr %1186, align 8
  store i64 %1166, ptr %1188, align 4
  %.sroa_idx157.i2922 = getelementptr i8, ptr %1186, i64 16
  store i64 %1165, ptr %.sroa_idx157.i2922, align 4
  %.sroa_idx158.i2923 = getelementptr i8, ptr %1186, i64 24
  store i32 %.sroa.17.0561.i2878, ptr %.sroa_idx158.i2923, align 4
  %1190 = icmp ne ptr %1187, @nil_typ
  %1191 = icmp ne ptr %1187, null
  %.not92.i2924 = and i1 %1190, %1191
  %extract.i2926 = lshr i160 %1189, 64
  %1192 = insertelement <2 x i160> poison, i160 %1189, i64 0
  %1193 = insertelement <2 x i160> %1192, i160 %extract.i2926, i64 1
  br i1 %.not92.i2924, label %.cont.cont.i2893, label %1233

1194:                                             ; preds = %1163
  %1195 = add i32 %1177, 2127912214
  %1196 = shl i32 %1177, 12
  %1197 = add i32 %1195, %1196
  %1198 = ashr i32 %1197, 19
  %1199 = xor i32 %1197, %1198
  %1200 = xor i32 %1199, -949894596
  %1201 = add i32 %1200, 374761393
  %1202 = shl i32 %1200, 5
  %1203 = add i32 %1201, %1202
  %1204 = add i32 %1203, -744332180
  %1205 = shl i32 %1203, 9
  %1206 = xor i32 %1204, %1205
  %1207 = add i32 %1206, -42973499
  %1208 = shl i32 %1206, 3
  %1209 = add i32 %1207, %1208
  %1210 = ashr i32 %1209, 16
  %1211 = xor i32 %1209, %1210
  %1212 = xor i32 %1211, -1252372727
  %1213 = load i32, ptr %42, align 8
  %1214 = add i32 %1213, -1
  %1215 = and i32 %1214, %1212
  %1216 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1217 = load ptr, ptr %44, align 8
  %1218 = sext i32 %1215 to i64
  %1219 = shl nsw i64 %1218, 5
  %1220 = getelementptr i8, ptr %1217, i64 %1219
  %1221 = load ptr, ptr %1220, align 8
  %1222 = getelementptr i8, ptr %1220, i64 8
  %1223 = load i160, ptr %1222, align 4
  store ptr %.sroa.0.0564.i2875, ptr %1220, align 8
  store i64 %1166, ptr %1222, align 4
  %.sroa_idx161.i2883 = getelementptr i8, ptr %1220, i64 16
  store i64 %1165, ptr %.sroa_idx161.i2883, align 4
  %.sroa_idx162.i2884 = getelementptr i8, ptr %1220, i64 24
  store i32 %.sroa.17.0561.i2878, ptr %.sroa_idx162.i2884, align 4
  %1224 = icmp ne ptr %1221, @nil_typ
  %1225 = icmp ne ptr %1221, null
  %.not90.i2885 = and i1 %1224, %1225
  %extract607.i2887 = lshr i160 %1223, 64
  %1226 = insertelement <2 x i160> poison, i160 %1223, i64 0
  %1227 = insertelement <2 x i160> %1226, i160 %extract607.i2887, i64 1
  br i1 %.not90.i2885, label %.cont.cont.i2893, label %1233

.cont.cont.i2893:                                 ; preds = %1194, %1178
  %vptr.i142.sroa.speculated.i2896 = phi ptr [ %1187, %1178 ], [ %1221, %1194 ]
  %.in3813 = phi <2 x i160> [ %1193, %1178 ], [ %1227, %1194 ]
  %1228 = trunc <2 x i160> %.in3813 to <2 x i64>
  %1229 = xor i1 %.070565.i2874, true
  %hash_coef_ptr.i.i143.i2899 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2896, i64 8
  %tbl_size_ptr.i.i144.i2900 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2896, i64 16
  %offset_tbl_ptr.i.i145.i2901 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2896, i64 40
  %hash_coef.i.i146.i2902 = load i64, ptr %hash_coef_ptr.i.i143.i2899, align 4
  %tbl_size.i.i147.i2903 = load i64, ptr %tbl_size_ptr.i.i144.i2900, align 4
  %offset_tbl.i.i148.i2904 = load ptr, ptr %offset_tbl_ptr.i.i145.i2901, align 8
  %product.i.i.i149.i2905 = mul i64 %hash_coef.i.i146.i2902, 4015701072841558310
  %shifted.i.i.i150.i2906 = lshr i64 %product.i.i.i149.i2905, 32
  %xored.i.i.i151.i2907 = xor i64 %shifted.i.i.i150.i2906, %product.i.i.i149.i2905
  %hash.i.i.i152.i2908 = and i64 %xored.i.i.i151.i2907, %tbl_size.i.i147.i2903
  %offset_ptr.i.i153.i2909 = getelementptr i32, ptr %offset_tbl.i.i148.i2904, i64 %hash.i.i.i152.i2908
  %offset.i.i154.i2910 = load i32, ptr %offset_ptr.i.i153.i2909, align 4
  %1230 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1231 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1232 = icmp ult i32 %.0566.i2873, 99
  br i1 %1232, label %1163, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2928

1233:                                             ; preds = %1194, %1178
  %1234 = phi ptr [ %16, %1194 ], [ %15, %1178 ]
  %1235 = load i32, ptr %65, align 4
  store i32 %1235, ptr %1234, align 4
  %1236 = add i32 %1235, 1
  %1237 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1236, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2928

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2928: ; preds = %.cont.cont.i2893, %1233
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i2166

._crit_edge.i2166:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2928, %1149
  %1238 = add nuw nsw i32 %.060.i2164, 1
  %1239 = icmp slt i32 %1238, %1052
  br i1 %1239, label %1149, label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %._crit_edge.i2166, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2148.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1272.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1135, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1272
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1240 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %1241 = sext i32 %.0266528 to i64
  %1242 = shl nsw i64 %1241, 2
  %1243 = getelementptr i8, ptr %result.i4.i, i64 %1242
  store i32 %72, ptr %1243, align 1
  store i1 true, ptr %.sroa.0224.sroa.0, align 8
  %.sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.0. = load i8, ptr %.sroa.0224.sroa.0, align 8
  %.sroa.0224.0.insert.ext = zext i8 %.sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.0. to i160
  %1244 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0224.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1245 = load ptr, ptr %result.i326, align 8
  %1246 = load ptr, ptr %54, align 8
  %1247 = call i32 %1246({ ptr, i160 } %73) #7
  %1248 = load i32, ptr %56, align 8
  %1249 = add i32 %1248, -1
  %1250 = and i32 %1249, %1247
  %1251 = load ptr, ptr %57, align 8
  %1252 = load ptr, ptr %49, align 8
  %1253 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1254 = sext i32 %1250 to i64
  %1255 = shl nsw i64 %1254, 5
  %1256 = getelementptr i8, ptr %1251, i64 %1255
  %1257 = load ptr, ptr %1256, align 8
  %1258 = getelementptr i8, ptr %1256, i64 8
  %1259 = icmp ne ptr %1257, @nil_typ
  %1260 = icmp ne ptr %1257, null
  %.not64.i1335 = and i1 %1259, %1260
  br i1 %.not64.i1335, label %1261, label %1358

1261:                                             ; preds = %HashMap_insert_keyK_valueV.exit
  %1262 = load i64, ptr %1258, align 4
  %.sroa_idx.i1337 = getelementptr i8, ptr %1256, i64 16
  %1263 = load i64, ptr %.sroa_idx.i1337, align 4
  %1264 = inttoptr i64 %1262 to ptr
  %1265 = inttoptr i64 %1263 to ptr
  %hash_coef_ptr.i.i66.i1338 = getelementptr i8, ptr %1257, i64 8
  %tbl_size_ptr.i.i67.i1339 = getelementptr i8, ptr %1257, i64 16
  %offset_tbl_ptr.i.i68.i1340 = getelementptr i8, ptr %1257, i64 40
  %hash_coef.i.i69.i1341 = load i64, ptr %hash_coef_ptr.i.i66.i1338, align 4, !noalias !200
  %tbl_size.i.i70.i1342 = load i64, ptr %tbl_size_ptr.i.i67.i1339, align 4, !noalias !200
  %offset_tbl.i.i71.i1343 = load ptr, ptr %offset_tbl_ptr.i.i68.i1340, align 8, !noalias !200
  %product.i.i.i72.i1344 = mul i64 %hash_coef.i.i69.i1341, 4015701072841558310
  %shifted.i.i.i73.i1345 = lshr i64 %product.i.i.i72.i1344, 32
  %xored.i.i.i74.i1346 = xor i64 %shifted.i.i.i73.i1345, %product.i.i.i72.i1344
  %hash.i.i.i75.i1347 = and i64 %xored.i.i.i74.i1346, %tbl_size.i.i70.i1342
  %offset_ptr.i.i76.i1348 = getelementptr i32, ptr %offset_tbl.i.i71.i1343, i64 %hash.i.i.i75.i1347
  %offset.i.i77.i1349 = load i32, ptr %offset_ptr.i.i76.i1348, align 4, !noalias !200
  %1266 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1257, 0
  %1267 = insertvalue { ptr, ptr, ptr, i32 } %1266, ptr %1264, 1
  %1268 = insertvalue { ptr, ptr, ptr, i32 } %1267, ptr %1265, 2
  %1269 = insertvalue { ptr, ptr, ptr, i32 } %1268, i32 %offset.i.i77.i1349, 3
  %1270 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1257) #34
  %1272 = sext i32 %offset.i.i77.i1349 to i64
  %1273 = getelementptr ptr, ptr %1257, i64 %1272
  %1274 = getelementptr i8, ptr %1273, i64 64
  %1275 = load ptr, ptr %1274, align 8
  %result.i.i1350 = call ptr %1275({ ptr, ptr, ptr, i32 } %1269, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1276 = call i32 %result.i.i1350({ ptr, ptr, ptr, i32 } %1269, { ptr, ptr, ptr, i32 } %1269, ptr nonnull align 8 %2) #7
  %1277 = icmp eq i32 %1276, %1247
  br i1 %1277, label %._crit_edge.i1351, label %1358

._crit_edge.i1351:                                ; preds = %1261
  %1278 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1279 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1257)
  %1280 = getelementptr i8, ptr %1273, i64 48
  %1281 = load ptr, ptr %1280, align 8
  %result.i79.i1352 = call ptr %1281({ ptr, ptr, ptr, i32 } %1269, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1282 = call { ptr, i160 } %result.i79.i1352({ ptr, ptr, ptr, i32 } %1269, { ptr, ptr, ptr, i32 } %1269, ptr nonnull align 8 %2) #7
  %1283 = load ptr, ptr %55, align 8
  %1284 = call i1 %1283({ ptr, i160 } %1282, { ptr, i160 } %73) #7
  br i1 %1284, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1364, label %1358

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1364: ; preds = %._crit_edge.i1351
  %1285 = load ptr, ptr %result.i326, align 8
  %1286 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1287 = load ptr, ptr %49, align 8
  %1288 = load ptr, ptr %1285, align 8, !alias.scope !203
  %1289 = getelementptr i8, ptr %1288, i64 72
  %1290 = load ptr, ptr %1289, align 8, !alias.scope !203
  %result.i.i.i1356 = call { i64, i64 } %1290(ptr nocapture nofree nonnull readonly %1285) #5, !alias.scope !203
  %1291 = extractvalue { i64, i64 } %result.i.i.i1356, 0
  %1292 = extractvalue { i64, i64 } %result.i.i.i1356, 1
  %1293 = urem i64 20, %1292
  %1294 = icmp eq i64 %1293, 0
  %1295 = sub i64 %1292, %1293
  %1296 = select i1 %1294, i64 0, i64 %1295
  %1297 = add i64 %1291, 20
  %1298 = add i64 %1297, %1296
  %1299 = load ptr, ptr %1287, align 8, !alias.scope !203
  %1300 = getelementptr i8, ptr %1299, i64 72
  %1301 = load ptr, ptr %1300, align 8, !alias.scope !203
  %result.i1.i.i1357 = call { i64, i64 } %1301(ptr nocapture nofree nonnull readonly %1287) #5, !alias.scope !203
  %1302 = extractvalue { i64, i64 } %result.i1.i.i1357, 0
  %1303 = extractvalue { i64, i64 } %result.i1.i.i1357, 1
  %1304 = call i64 @llvm.umax.i64(i64 %1292, i64 %1303)
  %1305 = call i64 @llvm.umax.i64(i64 %1304, i64 8)
  %1306 = urem i64 %1298, %1303
  %1307 = icmp eq i64 %1306, 0
  %1308 = sub i64 %1303, %1306
  %1309 = select i1 %1307, i64 0, i64 %1308
  %1310 = add i64 %1302, %1298
  %1311 = add i64 %1310, %1309
  %1312 = urem i64 %1311, %1305
  %1313 = icmp eq i64 %1312, 0
  %1314 = sub i64 %1305, %1312
  %1315 = select i1 %1313, i64 0, i64 %1314
  %1316 = add i64 %1315, %1311
  %result.i83.i1358 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1316, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1285, ptr %result.i83.i1358, align 8
  %1317 = getelementptr inbounds i8, ptr %result.i83.i1358, i64 8
  store ptr %1287, ptr %1317, align 8
  %1318 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1358)
  %1319 = load ptr, ptr %1285, align 8
  %1320 = getelementptr i8, ptr %1319, i64 72
  %1321 = load ptr, ptr %1320, align 8
  %result.i.i114.i1359 = call { i64, i64 } %1321(ptr nocapture nofree nonnull readonly %1285) #5
  %1322 = extractvalue { i64, i64 } %result.i.i114.i1359, 1
  %1323 = urem i64 20, %1322
  %1324 = icmp eq i64 %1323, 0
  %reass.sub = sub i64 %1322, %1323
  %1325 = add i64 %reass.sub, 20
  %1326 = select i1 %1324, i64 20, i64 %1325
  %1327 = getelementptr i8, ptr %result.i83.i1358, i64 %1326
  %1328 = getelementptr i8, ptr %1319, i64 64
  %1329 = load ptr, ptr %1328, align 8
  call void %1329({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1285, ptr nocapture nofree writeonly %1327) #12
  %1330 = load ptr, ptr %result.i83.i1358, align 8
  %1331 = load ptr, ptr %1330, align 8
  %1332 = getelementptr i8, ptr %1331, i64 72
  %1333 = load ptr, ptr %1332, align 8
  %result.i.i115.i1361 = call { i64, i64 } %1333(ptr nocapture nofree nonnull readonly %1330) #5
  %1334 = extractvalue { i64, i64 } %result.i.i115.i1361, 0
  %1335 = extractvalue { i64, i64 } %result.i.i115.i1361, 1
  %1336 = urem i64 20, %1335
  %1337 = icmp eq i64 %1336, 0
  %1338 = sub i64 %1335, %1336
  %1339 = select i1 %1337, i64 0, i64 %1338
  %1340 = add i64 %1334, 20
  %1341 = add i64 %1340, %1339
  %1342 = load ptr, ptr %1317, align 8
  %1343 = load ptr, ptr %1342, align 8
  %1344 = getelementptr i8, ptr %1343, i64 72
  %1345 = load ptr, ptr %1344, align 8
  %result.i1.i116.i1362 = call { i64, i64 } %1345(ptr nocapture nofree nonnull readonly %1342) #5
  %1346 = extractvalue { i64, i64 } %result.i1.i116.i1362, 1
  %1347 = urem i64 %1341, %1346
  %1348 = icmp eq i64 %1347, 0
  %1349 = sub i64 %1346, %1347
  %1350 = select i1 %1348, i64 0, i64 %1349
  %1351 = getelementptr i8, ptr %result.i83.i1358, i64 %1341
  %1352 = getelementptr i8, ptr %1351, i64 %1350
  %1353 = getelementptr i8, ptr %1343, i64 64
  %1354 = load ptr, ptr %1353, align 8
  call void %1354({ ptr, i160 } %1244, ptr nocapture nofree nonnull readonly %1342, ptr nocapture nofree writeonly %1352) #12
  %1355 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1356 = getelementptr inbounds i8, ptr %result.i83.i1358, i64 16
  store i32 %1247, ptr %1356, align 8
  store ptr @Entry, ptr %1256, align 8
  %1357 = ptrtoint ptr %result.i83.i1358 to i64
  store i64 %1357, ptr %1258, align 4
  %.sroa_idx28.i1363 = getelementptr i8, ptr %1256, i64 24
  store i32 10, ptr %.sroa_idx28.i1363, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit785

1358:                                             ; preds = %._crit_edge.i1351, %HashMap_insert_keyK_valueV.exit, %1261
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1359 = add i32 %1247, 2127912214
  %1360 = shl i32 %1247, 12
  %1361 = add i32 %1359, %1360
  %1362 = ashr i32 %1361, 19
  %1363 = xor i32 %1361, %1362
  %1364 = xor i32 %1363, -949894596
  %1365 = add i32 %1364, 374761393
  %1366 = shl i32 %1364, 5
  %1367 = add i32 %1365, %1366
  %1368 = add i32 %1367, -744332180
  %1369 = shl i32 %1367, 9
  %1370 = xor i32 %1368, %1369
  %1371 = add i32 %1370, -42973499
  %1372 = shl i32 %1370, 3
  %1373 = add i32 %1371, %1372
  %1374 = ashr i32 %1373, 16
  %1375 = xor i32 %1373, %1374
  %1376 = xor i32 %1375, -1252372727
  %1377 = load i32, ptr %56, align 8
  %1378 = add i32 %1377, -1
  %1379 = and i32 %1378, %1376
  %1380 = load ptr, ptr %58, align 8
  %1381 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1382 = sext i32 %1379 to i64
  %1383 = shl nsw i64 %1382, 5
  %1384 = getelementptr i8, ptr %1380, i64 %1383
  %1385 = load ptr, ptr %1384, align 8
  %1386 = getelementptr i8, ptr %1384, i64 8
  %1387 = icmp ne ptr %1385, @nil_typ
  %1388 = icmp ne ptr %1385, null
  %.not64.i1394 = and i1 %1387, %1388
  br i1 %.not64.i1394, label %1389, label %1487

1389:                                             ; preds = %1358
  %1390 = load i64, ptr %1386, align 4
  %.sroa_idx.i1396 = getelementptr i8, ptr %1384, i64 16
  %1391 = load i64, ptr %.sroa_idx.i1396, align 4
  %1392 = inttoptr i64 %1390 to ptr
  %1393 = inttoptr i64 %1391 to ptr
  %hash_coef_ptr.i.i66.i1397 = getelementptr i8, ptr %1385, i64 8
  %tbl_size_ptr.i.i67.i1398 = getelementptr i8, ptr %1385, i64 16
  %offset_tbl_ptr.i.i68.i1399 = getelementptr i8, ptr %1385, i64 40
  %hash_coef.i.i69.i1400 = load i64, ptr %hash_coef_ptr.i.i66.i1397, align 4, !noalias !206
  %tbl_size.i.i70.i1401 = load i64, ptr %tbl_size_ptr.i.i67.i1398, align 4, !noalias !206
  %offset_tbl.i.i71.i1402 = load ptr, ptr %offset_tbl_ptr.i.i68.i1399, align 8, !noalias !206
  %product.i.i.i72.i1403 = mul i64 %hash_coef.i.i69.i1400, 4015701072841558310
  %shifted.i.i.i73.i1404 = lshr i64 %product.i.i.i72.i1403, 32
  %xored.i.i.i74.i1405 = xor i64 %shifted.i.i.i73.i1404, %product.i.i.i72.i1403
  %hash.i.i.i75.i1406 = and i64 %xored.i.i.i74.i1405, %tbl_size.i.i70.i1401
  %offset_ptr.i.i76.i1407 = getelementptr i32, ptr %offset_tbl.i.i71.i1402, i64 %hash.i.i.i75.i1406
  %offset.i.i77.i1408 = load i32, ptr %offset_ptr.i.i76.i1407, align 4, !noalias !206
  %1394 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1385, 0
  %1395 = insertvalue { ptr, ptr, ptr, i32 } %1394, ptr %1392, 1
  %1396 = insertvalue { ptr, ptr, ptr, i32 } %1395, ptr %1393, 2
  %1397 = insertvalue { ptr, ptr, ptr, i32 } %1396, i32 %offset.i.i77.i1408, 3
  %1398 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1399 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1385) #34
  %1400 = sext i32 %offset.i.i77.i1408 to i64
  %1401 = getelementptr ptr, ptr %1385, i64 %1400
  %1402 = getelementptr i8, ptr %1401, i64 64
  %1403 = load ptr, ptr %1402, align 8
  %result.i.i1409 = call ptr %1403({ ptr, ptr, ptr, i32 } %1397, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1404 = call i32 %result.i.i1409({ ptr, ptr, ptr, i32 } %1397, { ptr, ptr, ptr, i32 } %1397, ptr nonnull align 8 %2) #7
  %1405 = icmp eq i32 %1404, %1247
  br i1 %1405, label %._crit_edge.i1410, label %1487

._crit_edge.i1410:                                ; preds = %1389
  %1406 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1407 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1385)
  %1408 = getelementptr i8, ptr %1401, i64 48
  %1409 = load ptr, ptr %1408, align 8
  %result.i79.i1411 = call ptr %1409({ ptr, ptr, ptr, i32 } %1397, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1410 = call { ptr, i160 } %result.i79.i1411({ ptr, ptr, ptr, i32 } %1397, { ptr, ptr, ptr, i32 } %1397, ptr nonnull align 8 %2) #7
  %1411 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1412 = load ptr, ptr %55, align 8
  %1413 = call i1 %1412({ ptr, i160 } %1410, { ptr, i160 } %73) #7
  br i1 %1413, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1423, label %1487

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1423: ; preds = %._crit_edge.i1410
  %1414 = load ptr, ptr %result.i326, align 8
  %1415 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1416 = load ptr, ptr %49, align 8
  %1417 = load ptr, ptr %1414, align 8, !alias.scope !209
  %1418 = getelementptr i8, ptr %1417, i64 72
  %1419 = load ptr, ptr %1418, align 8, !alias.scope !209
  %result.i.i.i1415 = call { i64, i64 } %1419(ptr nocapture nofree nonnull readonly %1414) #5, !alias.scope !209
  %1420 = extractvalue { i64, i64 } %result.i.i.i1415, 0
  %1421 = extractvalue { i64, i64 } %result.i.i.i1415, 1
  %1422 = urem i64 20, %1421
  %1423 = icmp eq i64 %1422, 0
  %1424 = sub i64 %1421, %1422
  %1425 = select i1 %1423, i64 0, i64 %1424
  %1426 = add i64 %1420, 20
  %1427 = add i64 %1426, %1425
  %1428 = load ptr, ptr %1416, align 8, !alias.scope !209
  %1429 = getelementptr i8, ptr %1428, i64 72
  %1430 = load ptr, ptr %1429, align 8, !alias.scope !209
  %result.i1.i.i1416 = call { i64, i64 } %1430(ptr nocapture nofree nonnull readonly %1416) #5, !alias.scope !209
  %1431 = extractvalue { i64, i64 } %result.i1.i.i1416, 0
  %1432 = extractvalue { i64, i64 } %result.i1.i.i1416, 1
  %1433 = call i64 @llvm.umax.i64(i64 %1421, i64 %1432)
  %1434 = call i64 @llvm.umax.i64(i64 %1433, i64 8)
  %1435 = urem i64 %1427, %1432
  %1436 = icmp eq i64 %1435, 0
  %1437 = sub i64 %1432, %1435
  %1438 = select i1 %1436, i64 0, i64 %1437
  %1439 = add i64 %1431, %1427
  %1440 = add i64 %1439, %1438
  %1441 = urem i64 %1440, %1434
  %1442 = icmp eq i64 %1441, 0
  %1443 = sub i64 %1434, %1441
  %1444 = select i1 %1442, i64 0, i64 %1443
  %1445 = add i64 %1444, %1440
  %result.i83.i1417 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1445, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1414, ptr %result.i83.i1417, align 8
  %1446 = getelementptr inbounds i8, ptr %result.i83.i1417, i64 8
  store ptr %1416, ptr %1446, align 8
  %1447 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1417)
  %1448 = load ptr, ptr %1414, align 8
  %1449 = getelementptr i8, ptr %1448, i64 72
  %1450 = load ptr, ptr %1449, align 8
  %result.i.i114.i1418 = call { i64, i64 } %1450(ptr nocapture nofree nonnull readonly %1414) #5
  %1451 = extractvalue { i64, i64 } %result.i.i114.i1418, 1
  %1452 = urem i64 20, %1451
  %1453 = icmp eq i64 %1452, 0
  %reass.sub3806 = sub i64 %1451, %1452
  %1454 = add i64 %reass.sub3806, 20
  %1455 = select i1 %1453, i64 20, i64 %1454
  %1456 = getelementptr i8, ptr %result.i83.i1417, i64 %1455
  %1457 = getelementptr i8, ptr %1448, i64 64
  %1458 = load ptr, ptr %1457, align 8
  call void %1458({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1414, ptr nocapture nofree writeonly %1456) #12
  %1459 = load ptr, ptr %result.i83.i1417, align 8
  %1460 = load ptr, ptr %1459, align 8
  %1461 = getelementptr i8, ptr %1460, i64 72
  %1462 = load ptr, ptr %1461, align 8
  %result.i.i115.i1420 = call { i64, i64 } %1462(ptr nocapture nofree nonnull readonly %1459) #5
  %1463 = extractvalue { i64, i64 } %result.i.i115.i1420, 0
  %1464 = extractvalue { i64, i64 } %result.i.i115.i1420, 1
  %1465 = urem i64 20, %1464
  %1466 = icmp eq i64 %1465, 0
  %1467 = sub i64 %1464, %1465
  %1468 = select i1 %1466, i64 0, i64 %1467
  %1469 = add i64 %1463, 20
  %1470 = add i64 %1469, %1468
  %1471 = load ptr, ptr %1446, align 8
  %1472 = load ptr, ptr %1471, align 8
  %1473 = getelementptr i8, ptr %1472, i64 72
  %1474 = load ptr, ptr %1473, align 8
  %result.i1.i116.i1421 = call { i64, i64 } %1474(ptr nocapture nofree nonnull readonly %1471) #5
  %1475 = extractvalue { i64, i64 } %result.i1.i116.i1421, 1
  %1476 = urem i64 %1470, %1475
  %1477 = icmp eq i64 %1476, 0
  %1478 = sub i64 %1475, %1476
  %1479 = select i1 %1477, i64 0, i64 %1478
  %1480 = getelementptr i8, ptr %result.i83.i1417, i64 %1470
  %1481 = getelementptr i8, ptr %1480, i64 %1479
  %1482 = getelementptr i8, ptr %1472, i64 64
  %1483 = load ptr, ptr %1482, align 8
  call void %1483({ ptr, i160 } %1244, ptr nocapture nofree nonnull readonly %1471, ptr nocapture nofree writeonly %1481) #12
  %1484 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1485 = getelementptr inbounds i8, ptr %result.i83.i1417, i64 16
  store i32 %1247, ptr %1485, align 8
  store ptr @Entry, ptr %1384, align 8
  %1486 = ptrtoint ptr %result.i83.i1417 to i64
  store i64 %1486, ptr %1386, align 4
  %.sroa_idx28.i1422 = getelementptr i8, ptr %1384, i64 24
  store i32 10, ptr %.sroa_idx28.i1422, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit785

1487:                                             ; preds = %._crit_edge.i1410, %1358, %1389
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1488 = load i32, ptr %66, align 4
  %1489 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1490 = load i32, ptr %56, align 8
  %.not.i749 = icmp slt i32 %1488, %1490
  br i1 %.not.i749, label %._crit_edge.i751, label %1491

1491:                                             ; preds = %1487
  %1492 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1493 = load ptr, ptr %57, align 8
  %1494 = load ptr, ptr %58, align 8
  %1495 = shl i32 %1490, 1
  %spec.select.i1439 = call i32 @llvm.smax.i32(i32 %1495, i32 16)
  store i32 %spec.select.i1439, ptr %56, align 8
  %1496 = zext nneg i32 %spec.select.i1439 to i64
  %1497 = shl nuw nsw i64 %1496, 5
  %result.i.i1440 = call noalias ptr @bump_malloc_inner(i64 noundef %1497, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1440, ptr %57, align 8
  %result.i20.i1441 = call noalias ptr @bump_malloc_inner(i64 noundef %1497, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1441, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %1498 = icmp sgt i32 %1490, 0
  br i1 %1498, label %.lr.ph.i2187, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2220.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2220.thread: ; preds = %1491
  %1499 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i751

.lr.ph.i2187:                                     ; preds = %1491, %._crit_edge.i2202
  %.060.i2200 = phi i32 [ %1588, %._crit_edge.i2202 ], [ 0, %1491 ]
  %1500 = zext nneg i32 %.060.i2200 to i64
  %1501 = shl nuw nsw i64 %1500, 5
  %1502 = getelementptr i8, ptr %1493, i64 %1501
  %1503 = load ptr, ptr %1502, align 8
  %1504 = icmp ne ptr %1503, @nil_typ
  %1505 = icmp ne ptr %1503, null
  %.not16.i2201 = and i1 %1504, %1505
  br i1 %.not16.i2201, label %1506, label %._crit_edge.i2202

1506:                                             ; preds = %.lr.ph.i2187
  %1507 = getelementptr i8, ptr %1502, i64 8
  %1508 = load <2 x i64>, ptr %1507, align 4
  %hash_coef_ptr.i.i18.i2204 = getelementptr i8, ptr %1503, i64 8
  %tbl_size_ptr.i.i19.i2205 = getelementptr i8, ptr %1503, i64 16
  %offset_tbl_ptr.i.i20.i2206 = getelementptr i8, ptr %1503, i64 40
  %1509 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i2946 = load i64, ptr %hash_coef_ptr.i.i18.i2204, align 4, !noalias !22
  %tbl_size.i.i100.i2947 = load i64, ptr %tbl_size_ptr.i.i19.i2205, align 4, !noalias !22
  %offset_tbl.i.i101.i2948 = load ptr, ptr %offset_tbl_ptr.i.i20.i2206, align 8, !noalias !22
  %product.i.i.i102.i2949 = mul i64 %hash_coef.i.i99.i2946, 4015701072841558310
  %shifted.i.i.i103.i2950 = lshr i64 %product.i.i.i102.i2949, 32
  %xored.i.i.i104.i2951 = xor i64 %shifted.i.i.i103.i2950, %product.i.i.i102.i2949
  %hash.i.i.i105.i2952 = and i64 %xored.i.i.i104.i2951, %tbl_size.i.i100.i2947
  %offset_ptr.i.i106.i2953 = getelementptr i32, ptr %offset_tbl.i.i101.i2948, i64 %hash.i.i.i105.i2952
  %offset.i.i121.i2954 = load i32, ptr %offset_ptr.i.i106.i2953, align 4, !noalias !212
  %1510 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1511 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1512 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1513

1513:                                             ; preds = %.cont.cont.i2975, %1506
  %.0566.i2955 = phi i32 [ 0, %1506 ], [ %1517, %.cont.cont.i2975 ]
  %.070565.i2956 = phi i1 [ true, %1506 ], [ %1579, %.cont.cont.i2975 ]
  %.sroa.0.0564.i2957 = phi ptr [ %1503, %1506 ], [ %vptr.i142.sroa.speculated.i2978, %.cont.cont.i2975 ]
  %.sroa.17.0561.i2960 = phi i32 [ %offset.i.i121.i2954, %1506 ], [ %offset.i.i154.i2992, %.cont.cont.i2975 ]
  %1514 = phi <2 x i64> [ %1508, %1506 ], [ %1578, %.cont.cont.i2975 ]
  %1515 = extractelement <2 x i64> %1514, i64 1
  %.sroa.12.0562.i2959 = inttoptr i64 %1515 to ptr
  %1516 = extractelement <2 x i64> %1514, i64 0
  %.sroa.6.0563.i2958 = inttoptr i64 %1516 to ptr
  %1517 = add nuw nsw i32 %.0566.i2955, 1
  %1518 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2957, 0
  %1519 = insertvalue { ptr, ptr, ptr, i32 } %1518, ptr %.sroa.6.0563.i2958, 1
  %1520 = insertvalue { ptr, ptr, ptr, i32 } %1519, ptr %.sroa.12.0562.i2959, 2
  %1521 = insertvalue { ptr, ptr, ptr, i32 } %1520, i32 %.sroa.17.0561.i2960, 3
  %1522 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2957)
  %1523 = sext i32 %.sroa.17.0561.i2960 to i64
  %1524 = getelementptr ptr, ptr %.sroa.0.0564.i2957, i64 %1523
  %1525 = getelementptr i8, ptr %1524, i64 64
  %1526 = load ptr, ptr %1525, align 8
  %result.i125.i2961 = call ptr %1526({ ptr, ptr, ptr, i32 } %1521, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1527 = call i32 %result.i125.i2961({ ptr, ptr, ptr, i32 } %1521, { ptr, ptr, ptr, i32 } %1521, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2956, label %1528, label %1544

1528:                                             ; preds = %1513
  %1529 = load i32, ptr %56, align 8
  %1530 = add i32 %1529, -1
  %1531 = and i32 %1530, %1527
  %1532 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1533 = load ptr, ptr %57, align 8
  %1534 = sext i32 %1531 to i64
  %1535 = shl nsw i64 %1534, 5
  %1536 = getelementptr i8, ptr %1533, i64 %1535
  %1537 = load ptr, ptr %1536, align 8
  %1538 = getelementptr i8, ptr %1536, i64 8
  %1539 = load i160, ptr %1538, align 4
  store ptr %.sroa.0.0564.i2957, ptr %1536, align 8
  store i64 %1516, ptr %1538, align 4
  %.sroa_idx157.i3004 = getelementptr i8, ptr %1536, i64 16
  store i64 %1515, ptr %.sroa_idx157.i3004, align 4
  %.sroa_idx158.i3005 = getelementptr i8, ptr %1536, i64 24
  store i32 %.sroa.17.0561.i2960, ptr %.sroa_idx158.i3005, align 4
  %1540 = icmp ne ptr %1537, @nil_typ
  %1541 = icmp ne ptr %1537, null
  %.not92.i3006 = and i1 %1540, %1541
  %extract.i3008 = lshr i160 %1539, 64
  %1542 = insertelement <2 x i160> poison, i160 %1539, i64 0
  %1543 = insertelement <2 x i160> %1542, i160 %extract.i3008, i64 1
  br i1 %.not92.i3006, label %.cont.cont.i2975, label %1583

1544:                                             ; preds = %1513
  %1545 = add i32 %1527, 2127912214
  %1546 = shl i32 %1527, 12
  %1547 = add i32 %1545, %1546
  %1548 = ashr i32 %1547, 19
  %1549 = xor i32 %1547, %1548
  %1550 = xor i32 %1549, -949894596
  %1551 = add i32 %1550, 374761393
  %1552 = shl i32 %1550, 5
  %1553 = add i32 %1551, %1552
  %1554 = add i32 %1553, -744332180
  %1555 = shl i32 %1553, 9
  %1556 = xor i32 %1554, %1555
  %1557 = add i32 %1556, -42973499
  %1558 = shl i32 %1556, 3
  %1559 = add i32 %1557, %1558
  %1560 = ashr i32 %1559, 16
  %1561 = xor i32 %1559, %1560
  %1562 = xor i32 %1561, -1252372727
  %1563 = load i32, ptr %56, align 8
  %1564 = add i32 %1563, -1
  %1565 = and i32 %1564, %1562
  %1566 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1567 = load ptr, ptr %58, align 8
  %1568 = sext i32 %1565 to i64
  %1569 = shl nsw i64 %1568, 5
  %1570 = getelementptr i8, ptr %1567, i64 %1569
  %1571 = load ptr, ptr %1570, align 8
  %1572 = getelementptr i8, ptr %1570, i64 8
  %1573 = load i160, ptr %1572, align 4
  store ptr %.sroa.0.0564.i2957, ptr %1570, align 8
  store i64 %1516, ptr %1572, align 4
  %.sroa_idx161.i2965 = getelementptr i8, ptr %1570, i64 16
  store i64 %1515, ptr %.sroa_idx161.i2965, align 4
  %.sroa_idx162.i2966 = getelementptr i8, ptr %1570, i64 24
  store i32 %.sroa.17.0561.i2960, ptr %.sroa_idx162.i2966, align 4
  %1574 = icmp ne ptr %1571, @nil_typ
  %1575 = icmp ne ptr %1571, null
  %.not90.i2967 = and i1 %1574, %1575
  %extract607.i2969 = lshr i160 %1573, 64
  %1576 = insertelement <2 x i160> poison, i160 %1573, i64 0
  %1577 = insertelement <2 x i160> %1576, i160 %extract607.i2969, i64 1
  br i1 %.not90.i2967, label %.cont.cont.i2975, label %1583

.cont.cont.i2975:                                 ; preds = %1544, %1528
  %vptr.i142.sroa.speculated.i2978 = phi ptr [ %1537, %1528 ], [ %1571, %1544 ]
  %.in3814 = phi <2 x i160> [ %1543, %1528 ], [ %1577, %1544 ]
  %1578 = trunc <2 x i160> %.in3814 to <2 x i64>
  %1579 = xor i1 %.070565.i2956, true
  %hash_coef_ptr.i.i143.i2981 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2978, i64 8
  %tbl_size_ptr.i.i144.i2982 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2978, i64 16
  %offset_tbl_ptr.i.i145.i2983 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2978, i64 40
  %hash_coef.i.i146.i2984 = load i64, ptr %hash_coef_ptr.i.i143.i2981, align 4
  %tbl_size.i.i147.i2985 = load i64, ptr %tbl_size_ptr.i.i144.i2982, align 4
  %offset_tbl.i.i148.i2986 = load ptr, ptr %offset_tbl_ptr.i.i145.i2983, align 8
  %product.i.i.i149.i2987 = mul i64 %hash_coef.i.i146.i2984, 4015701072841558310
  %shifted.i.i.i150.i2988 = lshr i64 %product.i.i.i149.i2987, 32
  %xored.i.i.i151.i2989 = xor i64 %shifted.i.i.i150.i2988, %product.i.i.i149.i2987
  %hash.i.i.i152.i2990 = and i64 %xored.i.i.i151.i2989, %tbl_size.i.i147.i2985
  %offset_ptr.i.i153.i2991 = getelementptr i32, ptr %offset_tbl.i.i148.i2986, i64 %hash.i.i.i152.i2990
  %offset.i.i154.i2992 = load i32, ptr %offset_ptr.i.i153.i2991, align 4
  %1580 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1581 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1582 = icmp ult i32 %.0566.i2955, 99
  br i1 %1582, label %1513, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3010

1583:                                             ; preds = %1544, %1528
  %1584 = phi ptr [ %14, %1544 ], [ %13, %1528 ]
  %1585 = load i32, ptr %66, align 4
  store i32 %1585, ptr %1584, align 4
  %1586 = add i32 %1585, 1
  %1587 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1586, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3010

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3010: ; preds = %.cont.cont.i2975, %1583
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i2202

._crit_edge.i2202:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3010, %.lr.ph.i2187
  %1588 = add nuw nsw i32 %.060.i2200, 1
  %1589 = icmp slt i32 %1588, %1490
  br i1 %1589, label %.lr.ph.i2187, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2220

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2220: ; preds = %._crit_edge.i2202
  %1590 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1591

1591:                                             ; preds = %._crit_edge.i2238, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2220
  %.060.i2236 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2220 ], [ %1680, %._crit_edge.i2238 ]
  %1592 = zext nneg i32 %.060.i2236 to i64
  %1593 = shl nuw nsw i64 %1592, 5
  %1594 = getelementptr i8, ptr %1494, i64 %1593
  %1595 = load ptr, ptr %1594, align 8
  %1596 = icmp ne ptr %1595, @nil_typ
  %1597 = icmp ne ptr %1595, null
  %.not16.i2237 = and i1 %1596, %1597
  br i1 %.not16.i2237, label %1598, label %._crit_edge.i2238

1598:                                             ; preds = %1591
  %1599 = getelementptr i8, ptr %1594, i64 8
  %1600 = load <2 x i64>, ptr %1599, align 4
  %hash_coef_ptr.i.i18.i2240 = getelementptr i8, ptr %1595, i64 8
  %tbl_size_ptr.i.i19.i2241 = getelementptr i8, ptr %1595, i64 16
  %offset_tbl_ptr.i.i20.i2242 = getelementptr i8, ptr %1595, i64 40
  %1601 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i3028 = load i64, ptr %hash_coef_ptr.i.i18.i2240, align 4, !noalias !22
  %tbl_size.i.i100.i3029 = load i64, ptr %tbl_size_ptr.i.i19.i2241, align 4, !noalias !22
  %offset_tbl.i.i101.i3030 = load ptr, ptr %offset_tbl_ptr.i.i20.i2242, align 8, !noalias !22
  %product.i.i.i102.i3031 = mul i64 %hash_coef.i.i99.i3028, 4015701072841558310
  %shifted.i.i.i103.i3032 = lshr i64 %product.i.i.i102.i3031, 32
  %xored.i.i.i104.i3033 = xor i64 %shifted.i.i.i103.i3032, %product.i.i.i102.i3031
  %hash.i.i.i105.i3034 = and i64 %xored.i.i.i104.i3033, %tbl_size.i.i100.i3029
  %offset_ptr.i.i106.i3035 = getelementptr i32, ptr %offset_tbl.i.i101.i3030, i64 %hash.i.i.i105.i3034
  %offset.i.i121.i3036 = load i32, ptr %offset_ptr.i.i106.i3035, align 4, !noalias !215
  %1602 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1603 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1604 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1605

1605:                                             ; preds = %.cont.cont.i3057, %1598
  %.0566.i3037 = phi i32 [ 0, %1598 ], [ %1609, %.cont.cont.i3057 ]
  %.070565.i3038 = phi i1 [ true, %1598 ], [ %1671, %.cont.cont.i3057 ]
  %.sroa.0.0564.i3039 = phi ptr [ %1595, %1598 ], [ %vptr.i142.sroa.speculated.i3060, %.cont.cont.i3057 ]
  %.sroa.17.0561.i3042 = phi i32 [ %offset.i.i121.i3036, %1598 ], [ %offset.i.i154.i3074, %.cont.cont.i3057 ]
  %1606 = phi <2 x i64> [ %1600, %1598 ], [ %1670, %.cont.cont.i3057 ]
  %1607 = extractelement <2 x i64> %1606, i64 1
  %.sroa.12.0562.i3041 = inttoptr i64 %1607 to ptr
  %1608 = extractelement <2 x i64> %1606, i64 0
  %.sroa.6.0563.i3040 = inttoptr i64 %1608 to ptr
  %1609 = add nuw nsw i32 %.0566.i3037, 1
  %1610 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3039, 0
  %1611 = insertvalue { ptr, ptr, ptr, i32 } %1610, ptr %.sroa.6.0563.i3040, 1
  %1612 = insertvalue { ptr, ptr, ptr, i32 } %1611, ptr %.sroa.12.0562.i3041, 2
  %1613 = insertvalue { ptr, ptr, ptr, i32 } %1612, i32 %.sroa.17.0561.i3042, 3
  %1614 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3039)
  %1615 = sext i32 %.sroa.17.0561.i3042 to i64
  %1616 = getelementptr ptr, ptr %.sroa.0.0564.i3039, i64 %1615
  %1617 = getelementptr i8, ptr %1616, i64 64
  %1618 = load ptr, ptr %1617, align 8
  %result.i125.i3043 = call ptr %1618({ ptr, ptr, ptr, i32 } %1613, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1619 = call i32 %result.i125.i3043({ ptr, ptr, ptr, i32 } %1613, { ptr, ptr, ptr, i32 } %1613, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3038, label %1620, label %1636

1620:                                             ; preds = %1605
  %1621 = load i32, ptr %56, align 8
  %1622 = add i32 %1621, -1
  %1623 = and i32 %1622, %1619
  %1624 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1625 = load ptr, ptr %57, align 8
  %1626 = sext i32 %1623 to i64
  %1627 = shl nsw i64 %1626, 5
  %1628 = getelementptr i8, ptr %1625, i64 %1627
  %1629 = load ptr, ptr %1628, align 8
  %1630 = getelementptr i8, ptr %1628, i64 8
  %1631 = load i160, ptr %1630, align 4
  store ptr %.sroa.0.0564.i3039, ptr %1628, align 8
  store i64 %1608, ptr %1630, align 4
  %.sroa_idx157.i3086 = getelementptr i8, ptr %1628, i64 16
  store i64 %1607, ptr %.sroa_idx157.i3086, align 4
  %.sroa_idx158.i3087 = getelementptr i8, ptr %1628, i64 24
  store i32 %.sroa.17.0561.i3042, ptr %.sroa_idx158.i3087, align 4
  %1632 = icmp ne ptr %1629, @nil_typ
  %1633 = icmp ne ptr %1629, null
  %.not92.i3088 = and i1 %1632, %1633
  %extract.i3090 = lshr i160 %1631, 64
  %1634 = insertelement <2 x i160> poison, i160 %1631, i64 0
  %1635 = insertelement <2 x i160> %1634, i160 %extract.i3090, i64 1
  br i1 %.not92.i3088, label %.cont.cont.i3057, label %1675

1636:                                             ; preds = %1605
  %1637 = add i32 %1619, 2127912214
  %1638 = shl i32 %1619, 12
  %1639 = add i32 %1637, %1638
  %1640 = ashr i32 %1639, 19
  %1641 = xor i32 %1639, %1640
  %1642 = xor i32 %1641, -949894596
  %1643 = add i32 %1642, 374761393
  %1644 = shl i32 %1642, 5
  %1645 = add i32 %1643, %1644
  %1646 = add i32 %1645, -744332180
  %1647 = shl i32 %1645, 9
  %1648 = xor i32 %1646, %1647
  %1649 = add i32 %1648, -42973499
  %1650 = shl i32 %1648, 3
  %1651 = add i32 %1649, %1650
  %1652 = ashr i32 %1651, 16
  %1653 = xor i32 %1651, %1652
  %1654 = xor i32 %1653, -1252372727
  %1655 = load i32, ptr %56, align 8
  %1656 = add i32 %1655, -1
  %1657 = and i32 %1656, %1654
  %1658 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1659 = load ptr, ptr %58, align 8
  %1660 = sext i32 %1657 to i64
  %1661 = shl nsw i64 %1660, 5
  %1662 = getelementptr i8, ptr %1659, i64 %1661
  %1663 = load ptr, ptr %1662, align 8
  %1664 = getelementptr i8, ptr %1662, i64 8
  %1665 = load i160, ptr %1664, align 4
  store ptr %.sroa.0.0564.i3039, ptr %1662, align 8
  store i64 %1608, ptr %1664, align 4
  %.sroa_idx161.i3047 = getelementptr i8, ptr %1662, i64 16
  store i64 %1607, ptr %.sroa_idx161.i3047, align 4
  %.sroa_idx162.i3048 = getelementptr i8, ptr %1662, i64 24
  store i32 %.sroa.17.0561.i3042, ptr %.sroa_idx162.i3048, align 4
  %1666 = icmp ne ptr %1663, @nil_typ
  %1667 = icmp ne ptr %1663, null
  %.not90.i3049 = and i1 %1666, %1667
  %extract607.i3051 = lshr i160 %1665, 64
  %1668 = insertelement <2 x i160> poison, i160 %1665, i64 0
  %1669 = insertelement <2 x i160> %1668, i160 %extract607.i3051, i64 1
  br i1 %.not90.i3049, label %.cont.cont.i3057, label %1675

.cont.cont.i3057:                                 ; preds = %1636, %1620
  %vptr.i142.sroa.speculated.i3060 = phi ptr [ %1629, %1620 ], [ %1663, %1636 ]
  %.in3815 = phi <2 x i160> [ %1635, %1620 ], [ %1669, %1636 ]
  %1670 = trunc <2 x i160> %.in3815 to <2 x i64>
  %1671 = xor i1 %.070565.i3038, true
  %hash_coef_ptr.i.i143.i3063 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3060, i64 8
  %tbl_size_ptr.i.i144.i3064 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3060, i64 16
  %offset_tbl_ptr.i.i145.i3065 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3060, i64 40
  %hash_coef.i.i146.i3066 = load i64, ptr %hash_coef_ptr.i.i143.i3063, align 4
  %tbl_size.i.i147.i3067 = load i64, ptr %tbl_size_ptr.i.i144.i3064, align 4
  %offset_tbl.i.i148.i3068 = load ptr, ptr %offset_tbl_ptr.i.i145.i3065, align 8
  %product.i.i.i149.i3069 = mul i64 %hash_coef.i.i146.i3066, 4015701072841558310
  %shifted.i.i.i150.i3070 = lshr i64 %product.i.i.i149.i3069, 32
  %xored.i.i.i151.i3071 = xor i64 %shifted.i.i.i150.i3070, %product.i.i.i149.i3069
  %hash.i.i.i152.i3072 = and i64 %xored.i.i.i151.i3071, %tbl_size.i.i147.i3067
  %offset_ptr.i.i153.i3073 = getelementptr i32, ptr %offset_tbl.i.i148.i3068, i64 %hash.i.i.i152.i3072
  %offset.i.i154.i3074 = load i32, ptr %offset_ptr.i.i153.i3073, align 4
  %1672 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1674 = icmp ult i32 %.0566.i3037, 99
  br i1 %1674, label %1605, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3092

1675:                                             ; preds = %1636, %1620
  %1676 = phi ptr [ %12, %1636 ], [ %11, %1620 ]
  %1677 = load i32, ptr %66, align 4
  store i32 %1677, ptr %1676, align 4
  %1678 = add i32 %1677, 1
  %1679 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1678, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3092

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3092: ; preds = %.cont.cont.i3057, %1675
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %._crit_edge.i2238

._crit_edge.i2238:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3092, %1591
  %1680 = add nuw nsw i32 %.060.i2236, 1
  %1681 = icmp slt i32 %1680, %1490
  br i1 %1681, label %1591, label %._crit_edge.i751

._crit_edge.i751:                                 ; preds = %._crit_edge.i2238, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2220.thread, %1487
  %1682 = load ptr, ptr %1245, align 8
  %1683 = getelementptr i8, ptr %1682, i64 72
  %1684 = load ptr, ptr %1683, align 8
  %result.i.i.i752 = call { i64, i64 } %1684(ptr nocapture nofree nonnull readonly %1245) #5
  %1685 = extractvalue { i64, i64 } %result.i.i.i752, 0
  %1686 = extractvalue { i64, i64 } %result.i.i.i752, 1
  %1687 = urem i64 20, %1686
  %1688 = icmp eq i64 %1687, 0
  %1689 = sub i64 %1686, %1687
  %1690 = select i1 %1688, i64 0, i64 %1689
  %1691 = add i64 %1685, 20
  %1692 = add i64 %1691, %1690
  %1693 = load ptr, ptr %1252, align 8
  %1694 = getelementptr i8, ptr %1693, i64 72
  %1695 = load ptr, ptr %1694, align 8
  %result.i1.i.i753 = call { i64, i64 } %1695(ptr nocapture nofree nonnull readonly %1252) #5
  %1696 = extractvalue { i64, i64 } %result.i1.i.i753, 0
  %1697 = extractvalue { i64, i64 } %result.i1.i.i753, 1
  %1698 = call i64 @llvm.umax.i64(i64 %1686, i64 %1697)
  %1699 = call i64 @llvm.umax.i64(i64 %1698, i64 8)
  %1700 = urem i64 %1692, %1697
  %1701 = icmp eq i64 %1700, 0
  %1702 = sub i64 %1697, %1700
  %1703 = select i1 %1701, i64 0, i64 %1702
  %1704 = add i64 %1696, %1692
  %1705 = add i64 %1704, %1703
  %1706 = urem i64 %1705, %1699
  %1707 = icmp eq i64 %1706, 0
  %1708 = sub i64 %1699, %1706
  %1709 = select i1 %1707, i64 0, i64 %1708
  %1710 = add i64 %1709, %1705
  %result.i83.i754 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1710, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1245, ptr %result.i83.i754, align 8
  %1711 = getelementptr inbounds i8, ptr %result.i83.i754, i64 8
  store ptr %1252, ptr %1711, align 8
  %1712 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i754)
  %1713 = load ptr, ptr %1245, align 8
  %1714 = getelementptr i8, ptr %1713, i64 72
  %1715 = load ptr, ptr %1714, align 8
  %result.i.i179.i755 = call { i64, i64 } %1715(ptr nocapture nofree nonnull readonly %1245) #5
  %1716 = extractvalue { i64, i64 } %result.i.i179.i755, 1
  %1717 = urem i64 20, %1716
  %1718 = icmp eq i64 %1717, 0
  %reass.sub3805 = sub i64 %1716, %1717
  %1719 = add i64 %reass.sub3805, 20
  %1720 = select i1 %1718, i64 20, i64 %1719
  %1721 = getelementptr i8, ptr %result.i83.i754, i64 %1720
  %1722 = getelementptr i8, ptr %1713, i64 64
  %1723 = load ptr, ptr %1722, align 8
  call void %1723({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1245, ptr nocapture nofree writeonly %1721) #12
  %1724 = load ptr, ptr %result.i83.i754, align 8
  %1725 = load ptr, ptr %1724, align 8
  %1726 = getelementptr i8, ptr %1725, i64 72
  %1727 = load ptr, ptr %1726, align 8
  %result.i.i180.i757 = call { i64, i64 } %1727(ptr nocapture nofree nonnull readonly %1724) #5
  %1728 = extractvalue { i64, i64 } %result.i.i180.i757, 0
  %1729 = extractvalue { i64, i64 } %result.i.i180.i757, 1
  %1730 = urem i64 20, %1729
  %1731 = icmp eq i64 %1730, 0
  %1732 = sub i64 %1729, %1730
  %1733 = select i1 %1731, i64 0, i64 %1732
  %1734 = add i64 %1728, 20
  %1735 = add i64 %1734, %1733
  %1736 = load ptr, ptr %1711, align 8
  %1737 = load ptr, ptr %1736, align 8
  %1738 = getelementptr i8, ptr %1737, i64 72
  %1739 = load ptr, ptr %1738, align 8
  %result.i1.i181.i758 = call { i64, i64 } %1739(ptr nocapture nofree nonnull readonly %1736) #5
  %1740 = extractvalue { i64, i64 } %result.i1.i181.i758, 1
  %1741 = urem i64 %1735, %1740
  %1742 = icmp eq i64 %1741, 0
  %1743 = sub i64 %1740, %1741
  %1744 = select i1 %1742, i64 0, i64 %1743
  %1745 = getelementptr i8, ptr %result.i83.i754, i64 %1735
  %1746 = getelementptr i8, ptr %1745, i64 %1744
  %1747 = getelementptr i8, ptr %1737, i64 64
  %1748 = load ptr, ptr %1747, align 8
  call void %1748({ ptr, i160 } %1244, ptr nocapture nofree nonnull readonly %1736, ptr nocapture nofree writeonly %1746) #12
  %1749 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1750 = getelementptr inbounds i8, ptr %result.i83.i754, i64 16
  store i32 %1247, ptr %1750, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %30)
  %1751 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1752 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1753 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1754

1754:                                             ; preds = %.cont.cont.i1492, %._crit_edge.i751
  %.0566.i1472 = phi i32 [ 0, %._crit_edge.i751 ], [ %1755, %.cont.cont.i1492 ]
  %.070565.i1473 = phi i1 [ true, %._crit_edge.i751 ], [ %1821, %.cont.cont.i1492 ]
  %.sroa.0.0564.i1474 = phi ptr [ @Entry, %._crit_edge.i751 ], [ %vptr.i142.sroa.speculated.i1495, %.cont.cont.i1492 ]
  %.sroa.6.0563.i1475 = phi ptr [ %result.i83.i754, %._crit_edge.i751 ], [ %spec.select539.i1497, %.cont.cont.i1492 ]
  %.sroa.12.0562.i1476 = phi ptr [ undef, %._crit_edge.i751 ], [ %spec.select.i1496, %.cont.cont.i1492 ]
  %.sroa.17.0561.i1477 = phi i32 [ 10, %._crit_edge.i751 ], [ %offset.i.i154.i1509, %.cont.cont.i1492 ]
  %1755 = add nuw nsw i32 %.0566.i1472, 1
  %1756 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1474, 0
  %1757 = insertvalue { ptr, ptr, ptr, i32 } %1756, ptr %.sroa.6.0563.i1475, 1
  %1758 = insertvalue { ptr, ptr, ptr, i32 } %1757, ptr %.sroa.12.0562.i1476, 2
  %1759 = insertvalue { ptr, ptr, ptr, i32 } %1758, i32 %.sroa.17.0561.i1477, 3
  %1760 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1474)
  %1761 = sext i32 %.sroa.17.0561.i1477 to i64
  %1762 = getelementptr ptr, ptr %.sroa.0.0564.i1474, i64 %1761
  %1763 = getelementptr i8, ptr %1762, i64 64
  %1764 = load ptr, ptr %1763, align 8
  %result.i125.i1478 = call ptr %1764({ ptr, ptr, ptr, i32 } %1759, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1765 = call i32 %result.i125.i1478({ ptr, ptr, ptr, i32 } %1759, { ptr, ptr, ptr, i32 } %1759, ptr nonnull align 8 %2) #7
  %1766 = ptrtoint ptr %.sroa.6.0563.i1475 to i64
  %1767 = ptrtoint ptr %.sroa.12.0562.i1476 to i64
  br i1 %.070565.i1473, label %1768, label %1784

1768:                                             ; preds = %1754
  %1769 = load i32, ptr %56, align 8
  %1770 = add i32 %1769, -1
  %1771 = and i32 %1770, %1765
  %1772 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1773 = load ptr, ptr %57, align 8
  %1774 = sext i32 %1771 to i64
  %1775 = shl nsw i64 %1774, 5
  %1776 = getelementptr i8, ptr %1773, i64 %1775
  %1777 = load ptr, ptr %1776, align 8
  %1778 = getelementptr i8, ptr %1776, i64 8
  %1779 = load i160, ptr %1778, align 4
  store ptr %.sroa.0.0564.i1474, ptr %1776, align 8
  store i64 %1766, ptr %1778, align 4
  %.sroa_idx157.i1521 = getelementptr i8, ptr %1776, i64 16
  store i64 %1767, ptr %.sroa_idx157.i1521, align 4
  %.sroa_idx158.i1522 = getelementptr i8, ptr %1776, i64 24
  store i32 %.sroa.17.0561.i1477, ptr %.sroa_idx158.i1522, align 4
  %1780 = icmp ne ptr %1777, @nil_typ
  %1781 = icmp ne ptr %1777, null
  %.not92.i1523 = and i1 %1780, %1781
  %extract.i1525 = lshr i160 %1779, 64
  %1782 = insertelement <2 x i160> poison, i160 %1779, i64 0
  %1783 = insertelement <2 x i160> %1782, i160 %extract.i1525, i64 1
  br i1 %.not92.i1523, label %.cont.cont.i1492, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1527.thread

1784:                                             ; preds = %1754
  %1785 = add i32 %1765, 2127912214
  %1786 = shl i32 %1765, 12
  %1787 = add i32 %1785, %1786
  %1788 = ashr i32 %1787, 19
  %1789 = xor i32 %1787, %1788
  %1790 = xor i32 %1789, -949894596
  %1791 = add i32 %1790, 374761393
  %1792 = shl i32 %1790, 5
  %1793 = add i32 %1791, %1792
  %1794 = add i32 %1793, -744332180
  %1795 = shl i32 %1793, 9
  %1796 = xor i32 %1794, %1795
  %1797 = add i32 %1796, -42973499
  %1798 = shl i32 %1796, 3
  %1799 = add i32 %1797, %1798
  %1800 = ashr i32 %1799, 16
  %1801 = xor i32 %1799, %1800
  %1802 = xor i32 %1801, -1252372727
  %1803 = load i32, ptr %56, align 8
  %1804 = add i32 %1803, -1
  %1805 = and i32 %1804, %1802
  %1806 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1807 = load ptr, ptr %58, align 8
  %1808 = sext i32 %1805 to i64
  %1809 = shl nsw i64 %1808, 5
  %1810 = getelementptr i8, ptr %1807, i64 %1809
  %1811 = load ptr, ptr %1810, align 8
  %1812 = getelementptr i8, ptr %1810, i64 8
  %1813 = load i160, ptr %1812, align 4
  store ptr %.sroa.0.0564.i1474, ptr %1810, align 8
  store i64 %1766, ptr %1812, align 4
  %.sroa_idx161.i1482 = getelementptr i8, ptr %1810, i64 16
  store i64 %1767, ptr %.sroa_idx161.i1482, align 4
  %.sroa_idx162.i1483 = getelementptr i8, ptr %1810, i64 24
  store i32 %.sroa.17.0561.i1477, ptr %.sroa_idx162.i1483, align 4
  %1814 = icmp ne ptr %1811, @nil_typ
  %1815 = icmp ne ptr %1811, null
  %.not90.i1484 = and i1 %1814, %1815
  %extract607.i1486 = lshr i160 %1813, 64
  %1816 = insertelement <2 x i160> poison, i160 %1813, i64 0
  %1817 = insertelement <2 x i160> %1816, i160 %extract607.i1486, i64 1
  br i1 %.not90.i1484, label %.cont.cont.i1492, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1527.thread

.cont.cont.i1492:                                 ; preds = %1784, %1768
  %vptr.i142.sroa.speculated.i1495 = phi ptr [ %1777, %1768 ], [ %1811, %1784 ]
  %.in3816 = phi <2 x i160> [ %1783, %1768 ], [ %1817, %1784 ]
  %1818 = trunc <2 x i160> %.in3816 to <2 x i64>
  %1819 = extractelement <2 x i64> %1818, i64 1
  %spec.select.i1496 = inttoptr i64 %1819 to ptr
  %1820 = extractelement <2 x i64> %1818, i64 0
  %spec.select539.i1497 = inttoptr i64 %1820 to ptr
  %1821 = xor i1 %.070565.i1473, true
  %hash_coef_ptr.i.i143.i1498 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1495, i64 8
  %tbl_size_ptr.i.i144.i1499 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1495, i64 16
  %offset_tbl_ptr.i.i145.i1500 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1495, i64 40
  %hash_coef.i.i146.i1501 = load i64, ptr %hash_coef_ptr.i.i143.i1498, align 4
  %tbl_size.i.i147.i1502 = load i64, ptr %tbl_size_ptr.i.i144.i1499, align 4
  %offset_tbl.i.i148.i1503 = load ptr, ptr %offset_tbl_ptr.i.i145.i1500, align 8
  %product.i.i.i149.i1504 = mul i64 %hash_coef.i.i146.i1501, 4015701072841558310
  %shifted.i.i.i150.i1505 = lshr i64 %product.i.i.i149.i1504, 32
  %xored.i.i.i151.i1506 = xor i64 %shifted.i.i.i150.i1505, %product.i.i.i149.i1504
  %hash.i.i.i152.i1507 = and i64 %xored.i.i.i151.i1506, %tbl_size.i.i147.i1502
  %offset_ptr.i.i153.i1508 = getelementptr i32, ptr %offset_tbl.i.i148.i1503, i64 %hash.i.i.i152.i1507
  %offset.i.i154.i1509 = load i32, ptr %offset_ptr.i.i153.i1508, align 4
  %1822 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1823 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1824 = icmp ult i32 %.0566.i1472, 99
  br i1 %1824, label %1754, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1527

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1527.thread: ; preds = %1768, %1784
  %1825 = phi ptr [ %30, %1784 ], [ %29, %1768 ]
  %1826 = load i32, ptr %66, align 4
  store i32 %1826, ptr %1825, align 4
  %1827 = add i32 %1826, 1
  %1828 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1827, ptr %66, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  br label %HashMap_insert_keyK_valueV.exit785

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1527: ; preds = %.cont.cont.i1492
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  %1829 = icmp eq ptr %vptr.i142.sroa.speculated.i1495, null
  br i1 %1829, label %HashMap_insert_keyK_valueV.exit785, label %1830

1830:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1527
  %1831 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1832 = load ptr, ptr %57, align 8
  %1833 = load ptr, ptr %58, align 8
  %1834 = load i32, ptr %56, align 8
  %1835 = shl i32 %1834, 1
  %spec.select.i1543 = call i32 @llvm.smax.i32(i32 %1835, i32 16)
  store i32 %spec.select.i1543, ptr %56, align 8
  %1836 = zext nneg i32 %spec.select.i1543 to i64
  %1837 = shl nuw nsw i64 %1836, 5
  %result.i.i1544 = call noalias ptr @bump_malloc_inner(i64 noundef %1837, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1544, ptr %57, align 8
  %result.i20.i1545 = call noalias ptr @bump_malloc_inner(i64 noundef %1837, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1545, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %1838 = icmp sgt i32 %1834, 0
  br i1 %1838, label %.lr.ph.i2286, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355

.lr.ph.i2286:                                     ; preds = %1830, %._crit_edge.i2301
  %.060.i2299 = phi i32 [ %1927, %._crit_edge.i2301 ], [ 0, %1830 ]
  %1839 = zext nneg i32 %.060.i2299 to i64
  %1840 = shl nuw nsw i64 %1839, 5
  %1841 = getelementptr i8, ptr %1832, i64 %1840
  %1842 = load ptr, ptr %1841, align 8
  %1843 = icmp ne ptr %1842, @nil_typ
  %1844 = icmp ne ptr %1842, null
  %.not16.i2300 = and i1 %1843, %1844
  br i1 %.not16.i2300, label %1845, label %._crit_edge.i2301

1845:                                             ; preds = %.lr.ph.i2286
  %1846 = getelementptr i8, ptr %1841, i64 8
  %1847 = load <2 x i64>, ptr %1846, align 4
  %hash_coef_ptr.i.i18.i2303 = getelementptr i8, ptr %1842, i64 8
  %tbl_size_ptr.i.i19.i2304 = getelementptr i8, ptr %1842, i64 16
  %offset_tbl_ptr.i.i20.i2305 = getelementptr i8, ptr %1842, i64 40
  %1848 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i3110 = load i64, ptr %hash_coef_ptr.i.i18.i2303, align 4, !noalias !22
  %tbl_size.i.i100.i3111 = load i64, ptr %tbl_size_ptr.i.i19.i2304, align 4, !noalias !22
  %offset_tbl.i.i101.i3112 = load ptr, ptr %offset_tbl_ptr.i.i20.i2305, align 8, !noalias !22
  %product.i.i.i102.i3113 = mul i64 %hash_coef.i.i99.i3110, 4015701072841558310
  %shifted.i.i.i103.i3114 = lshr i64 %product.i.i.i102.i3113, 32
  %xored.i.i.i104.i3115 = xor i64 %shifted.i.i.i103.i3114, %product.i.i.i102.i3113
  %hash.i.i.i105.i3116 = and i64 %xored.i.i.i104.i3115, %tbl_size.i.i100.i3111
  %offset_ptr.i.i106.i3117 = getelementptr i32, ptr %offset_tbl.i.i101.i3112, i64 %hash.i.i.i105.i3116
  %offset.i.i121.i3118 = load i32, ptr %offset_ptr.i.i106.i3117, align 4, !noalias !218
  %1849 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1850 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1851 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1852

1852:                                             ; preds = %.cont.cont.i3139, %1845
  %.0566.i3119 = phi i32 [ 0, %1845 ], [ %1856, %.cont.cont.i3139 ]
  %.070565.i3120 = phi i1 [ true, %1845 ], [ %1918, %.cont.cont.i3139 ]
  %.sroa.0.0564.i3121 = phi ptr [ %1842, %1845 ], [ %vptr.i142.sroa.speculated.i3142, %.cont.cont.i3139 ]
  %.sroa.17.0561.i3124 = phi i32 [ %offset.i.i121.i3118, %1845 ], [ %offset.i.i154.i3156, %.cont.cont.i3139 ]
  %1853 = phi <2 x i64> [ %1847, %1845 ], [ %1917, %.cont.cont.i3139 ]
  %1854 = extractelement <2 x i64> %1853, i64 1
  %.sroa.12.0562.i3123 = inttoptr i64 %1854 to ptr
  %1855 = extractelement <2 x i64> %1853, i64 0
  %.sroa.6.0563.i3122 = inttoptr i64 %1855 to ptr
  %1856 = add nuw nsw i32 %.0566.i3119, 1
  %1857 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3121, 0
  %1858 = insertvalue { ptr, ptr, ptr, i32 } %1857, ptr %.sroa.6.0563.i3122, 1
  %1859 = insertvalue { ptr, ptr, ptr, i32 } %1858, ptr %.sroa.12.0562.i3123, 2
  %1860 = insertvalue { ptr, ptr, ptr, i32 } %1859, i32 %.sroa.17.0561.i3124, 3
  %1861 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3121)
  %1862 = sext i32 %.sroa.17.0561.i3124 to i64
  %1863 = getelementptr ptr, ptr %.sroa.0.0564.i3121, i64 %1862
  %1864 = getelementptr i8, ptr %1863, i64 64
  %1865 = load ptr, ptr %1864, align 8
  %result.i125.i3125 = call ptr %1865({ ptr, ptr, ptr, i32 } %1860, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1866 = call i32 %result.i125.i3125({ ptr, ptr, ptr, i32 } %1860, { ptr, ptr, ptr, i32 } %1860, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3120, label %1867, label %1883

1867:                                             ; preds = %1852
  %1868 = load i32, ptr %56, align 8
  %1869 = add i32 %1868, -1
  %1870 = and i32 %1869, %1866
  %1871 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1872 = load ptr, ptr %57, align 8
  %1873 = sext i32 %1870 to i64
  %1874 = shl nsw i64 %1873, 5
  %1875 = getelementptr i8, ptr %1872, i64 %1874
  %1876 = load ptr, ptr %1875, align 8
  %1877 = getelementptr i8, ptr %1875, i64 8
  %1878 = load i160, ptr %1877, align 4
  store ptr %.sroa.0.0564.i3121, ptr %1875, align 8
  store i64 %1855, ptr %1877, align 4
  %.sroa_idx157.i3168 = getelementptr i8, ptr %1875, i64 16
  store i64 %1854, ptr %.sroa_idx157.i3168, align 4
  %.sroa_idx158.i3169 = getelementptr i8, ptr %1875, i64 24
  store i32 %.sroa.17.0561.i3124, ptr %.sroa_idx158.i3169, align 4
  %1879 = icmp ne ptr %1876, @nil_typ
  %1880 = icmp ne ptr %1876, null
  %.not92.i3170 = and i1 %1879, %1880
  %extract.i3172 = lshr i160 %1878, 64
  %1881 = insertelement <2 x i160> poison, i160 %1878, i64 0
  %1882 = insertelement <2 x i160> %1881, i160 %extract.i3172, i64 1
  br i1 %.not92.i3170, label %.cont.cont.i3139, label %1922

1883:                                             ; preds = %1852
  %1884 = add i32 %1866, 2127912214
  %1885 = shl i32 %1866, 12
  %1886 = add i32 %1884, %1885
  %1887 = ashr i32 %1886, 19
  %1888 = xor i32 %1886, %1887
  %1889 = xor i32 %1888, -949894596
  %1890 = add i32 %1889, 374761393
  %1891 = shl i32 %1889, 5
  %1892 = add i32 %1890, %1891
  %1893 = add i32 %1892, -744332180
  %1894 = shl i32 %1892, 9
  %1895 = xor i32 %1893, %1894
  %1896 = add i32 %1895, -42973499
  %1897 = shl i32 %1895, 3
  %1898 = add i32 %1896, %1897
  %1899 = ashr i32 %1898, 16
  %1900 = xor i32 %1898, %1899
  %1901 = xor i32 %1900, -1252372727
  %1902 = load i32, ptr %56, align 8
  %1903 = add i32 %1902, -1
  %1904 = and i32 %1903, %1901
  %1905 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1906 = load ptr, ptr %58, align 8
  %1907 = sext i32 %1904 to i64
  %1908 = shl nsw i64 %1907, 5
  %1909 = getelementptr i8, ptr %1906, i64 %1908
  %1910 = load ptr, ptr %1909, align 8
  %1911 = getelementptr i8, ptr %1909, i64 8
  %1912 = load i160, ptr %1911, align 4
  store ptr %.sroa.0.0564.i3121, ptr %1909, align 8
  store i64 %1855, ptr %1911, align 4
  %.sroa_idx161.i3129 = getelementptr i8, ptr %1909, i64 16
  store i64 %1854, ptr %.sroa_idx161.i3129, align 4
  %.sroa_idx162.i3130 = getelementptr i8, ptr %1909, i64 24
  store i32 %.sroa.17.0561.i3124, ptr %.sroa_idx162.i3130, align 4
  %1913 = icmp ne ptr %1910, @nil_typ
  %1914 = icmp ne ptr %1910, null
  %.not90.i3131 = and i1 %1913, %1914
  %extract607.i3133 = lshr i160 %1912, 64
  %1915 = insertelement <2 x i160> poison, i160 %1912, i64 0
  %1916 = insertelement <2 x i160> %1915, i160 %extract607.i3133, i64 1
  br i1 %.not90.i3131, label %.cont.cont.i3139, label %1922

.cont.cont.i3139:                                 ; preds = %1883, %1867
  %vptr.i142.sroa.speculated.i3142 = phi ptr [ %1876, %1867 ], [ %1910, %1883 ]
  %.in3817 = phi <2 x i160> [ %1882, %1867 ], [ %1916, %1883 ]
  %1917 = trunc <2 x i160> %.in3817 to <2 x i64>
  %1918 = xor i1 %.070565.i3120, true
  %hash_coef_ptr.i.i143.i3145 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3142, i64 8
  %tbl_size_ptr.i.i144.i3146 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3142, i64 16
  %offset_tbl_ptr.i.i145.i3147 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3142, i64 40
  %hash_coef.i.i146.i3148 = load i64, ptr %hash_coef_ptr.i.i143.i3145, align 4
  %tbl_size.i.i147.i3149 = load i64, ptr %tbl_size_ptr.i.i144.i3146, align 4
  %offset_tbl.i.i148.i3150 = load ptr, ptr %offset_tbl_ptr.i.i145.i3147, align 8
  %product.i.i.i149.i3151 = mul i64 %hash_coef.i.i146.i3148, 4015701072841558310
  %shifted.i.i.i150.i3152 = lshr i64 %product.i.i.i149.i3151, 32
  %xored.i.i.i151.i3153 = xor i64 %shifted.i.i.i150.i3152, %product.i.i.i149.i3151
  %hash.i.i.i152.i3154 = and i64 %xored.i.i.i151.i3153, %tbl_size.i.i147.i3149
  %offset_ptr.i.i153.i3155 = getelementptr i32, ptr %offset_tbl.i.i148.i3150, i64 %hash.i.i.i152.i3154
  %offset.i.i154.i3156 = load i32, ptr %offset_ptr.i.i153.i3155, align 4
  %1919 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1920 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1921 = icmp ult i32 %.0566.i3119, 99
  br i1 %1921, label %1852, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3174

1922:                                             ; preds = %1883, %1867
  %1923 = phi ptr [ %10, %1883 ], [ %9, %1867 ]
  %1924 = load i32, ptr %66, align 4
  store i32 %1924, ptr %1923, align 4
  %1925 = add i32 %1924, 1
  %1926 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1925, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3174

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3174: ; preds = %.cont.cont.i3139, %1922
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i2301

._crit_edge.i2301:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3174, %.lr.ph.i2286
  %1927 = add nuw nsw i32 %.060.i2299, 1
  %1928 = icmp slt i32 %1927, %1834
  br i1 %1928, label %.lr.ph.i2286, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2319

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2319: ; preds = %._crit_edge.i2301, %._crit_edge.i2337
  %.060.i2335 = phi i32 [ %2017, %._crit_edge.i2337 ], [ 0, %._crit_edge.i2301 ]
  %1929 = zext nneg i32 %.060.i2335 to i64
  %1930 = shl nuw nsw i64 %1929, 5
  %1931 = getelementptr i8, ptr %1833, i64 %1930
  %1932 = load ptr, ptr %1931, align 8
  %1933 = icmp ne ptr %1932, @nil_typ
  %1934 = icmp ne ptr %1932, null
  %.not16.i2336 = and i1 %1933, %1934
  br i1 %.not16.i2336, label %1935, label %._crit_edge.i2337

1935:                                             ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2319
  %1936 = getelementptr i8, ptr %1931, i64 8
  %1937 = load <2 x i64>, ptr %1936, align 4
  %hash_coef_ptr.i.i18.i2339 = getelementptr i8, ptr %1932, i64 8
  %tbl_size_ptr.i.i19.i2340 = getelementptr i8, ptr %1932, i64 16
  %offset_tbl_ptr.i.i20.i2341 = getelementptr i8, ptr %1932, i64 40
  %1938 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i3192 = load i64, ptr %hash_coef_ptr.i.i18.i2339, align 4, !noalias !22
  %tbl_size.i.i100.i3193 = load i64, ptr %tbl_size_ptr.i.i19.i2340, align 4, !noalias !22
  %offset_tbl.i.i101.i3194 = load ptr, ptr %offset_tbl_ptr.i.i20.i2341, align 8, !noalias !22
  %product.i.i.i102.i3195 = mul i64 %hash_coef.i.i99.i3192, 4015701072841558310
  %shifted.i.i.i103.i3196 = lshr i64 %product.i.i.i102.i3195, 32
  %xored.i.i.i104.i3197 = xor i64 %shifted.i.i.i103.i3196, %product.i.i.i102.i3195
  %hash.i.i.i105.i3198 = and i64 %xored.i.i.i104.i3197, %tbl_size.i.i100.i3193
  %offset_ptr.i.i106.i3199 = getelementptr i32, ptr %offset_tbl.i.i101.i3194, i64 %hash.i.i.i105.i3198
  %offset.i.i121.i3200 = load i32, ptr %offset_ptr.i.i106.i3199, align 4, !noalias !221
  %1939 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1940 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1941 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1942

1942:                                             ; preds = %.cont.cont.i3221, %1935
  %.0566.i3201 = phi i32 [ 0, %1935 ], [ %1946, %.cont.cont.i3221 ]
  %.070565.i3202 = phi i1 [ true, %1935 ], [ %2008, %.cont.cont.i3221 ]
  %.sroa.0.0564.i3203 = phi ptr [ %1932, %1935 ], [ %vptr.i142.sroa.speculated.i3224, %.cont.cont.i3221 ]
  %.sroa.17.0561.i3206 = phi i32 [ %offset.i.i121.i3200, %1935 ], [ %offset.i.i154.i3238, %.cont.cont.i3221 ]
  %1943 = phi <2 x i64> [ %1937, %1935 ], [ %2007, %.cont.cont.i3221 ]
  %1944 = extractelement <2 x i64> %1943, i64 1
  %.sroa.12.0562.i3205 = inttoptr i64 %1944 to ptr
  %1945 = extractelement <2 x i64> %1943, i64 0
  %.sroa.6.0563.i3204 = inttoptr i64 %1945 to ptr
  %1946 = add nuw nsw i32 %.0566.i3201, 1
  %1947 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3203, 0
  %1948 = insertvalue { ptr, ptr, ptr, i32 } %1947, ptr %.sroa.6.0563.i3204, 1
  %1949 = insertvalue { ptr, ptr, ptr, i32 } %1948, ptr %.sroa.12.0562.i3205, 2
  %1950 = insertvalue { ptr, ptr, ptr, i32 } %1949, i32 %.sroa.17.0561.i3206, 3
  %1951 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3203)
  %1952 = sext i32 %.sroa.17.0561.i3206 to i64
  %1953 = getelementptr ptr, ptr %.sroa.0.0564.i3203, i64 %1952
  %1954 = getelementptr i8, ptr %1953, i64 64
  %1955 = load ptr, ptr %1954, align 8
  %result.i125.i3207 = call ptr %1955({ ptr, ptr, ptr, i32 } %1950, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1956 = call i32 %result.i125.i3207({ ptr, ptr, ptr, i32 } %1950, { ptr, ptr, ptr, i32 } %1950, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3202, label %1957, label %1973

1957:                                             ; preds = %1942
  %1958 = load i32, ptr %56, align 8
  %1959 = add i32 %1958, -1
  %1960 = and i32 %1959, %1956
  %1961 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1962 = load ptr, ptr %57, align 8
  %1963 = sext i32 %1960 to i64
  %1964 = shl nsw i64 %1963, 5
  %1965 = getelementptr i8, ptr %1962, i64 %1964
  %1966 = load ptr, ptr %1965, align 8
  %1967 = getelementptr i8, ptr %1965, i64 8
  %1968 = load i160, ptr %1967, align 4
  store ptr %.sroa.0.0564.i3203, ptr %1965, align 8
  store i64 %1945, ptr %1967, align 4
  %.sroa_idx157.i3250 = getelementptr i8, ptr %1965, i64 16
  store i64 %1944, ptr %.sroa_idx157.i3250, align 4
  %.sroa_idx158.i3251 = getelementptr i8, ptr %1965, i64 24
  store i32 %.sroa.17.0561.i3206, ptr %.sroa_idx158.i3251, align 4
  %1969 = icmp ne ptr %1966, @nil_typ
  %1970 = icmp ne ptr %1966, null
  %.not92.i3252 = and i1 %1969, %1970
  %extract.i3254 = lshr i160 %1968, 64
  %1971 = insertelement <2 x i160> poison, i160 %1968, i64 0
  %1972 = insertelement <2 x i160> %1971, i160 %extract.i3254, i64 1
  br i1 %.not92.i3252, label %.cont.cont.i3221, label %2012

1973:                                             ; preds = %1942
  %1974 = add i32 %1956, 2127912214
  %1975 = shl i32 %1956, 12
  %1976 = add i32 %1974, %1975
  %1977 = ashr i32 %1976, 19
  %1978 = xor i32 %1976, %1977
  %1979 = xor i32 %1978, -949894596
  %1980 = add i32 %1979, 374761393
  %1981 = shl i32 %1979, 5
  %1982 = add i32 %1980, %1981
  %1983 = add i32 %1982, -744332180
  %1984 = shl i32 %1982, 9
  %1985 = xor i32 %1983, %1984
  %1986 = add i32 %1985, -42973499
  %1987 = shl i32 %1985, 3
  %1988 = add i32 %1986, %1987
  %1989 = ashr i32 %1988, 16
  %1990 = xor i32 %1988, %1989
  %1991 = xor i32 %1990, -1252372727
  %1992 = load i32, ptr %56, align 8
  %1993 = add i32 %1992, -1
  %1994 = and i32 %1993, %1991
  %1995 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1996 = load ptr, ptr %58, align 8
  %1997 = sext i32 %1994 to i64
  %1998 = shl nsw i64 %1997, 5
  %1999 = getelementptr i8, ptr %1996, i64 %1998
  %2000 = load ptr, ptr %1999, align 8
  %2001 = getelementptr i8, ptr %1999, i64 8
  %2002 = load i160, ptr %2001, align 4
  store ptr %.sroa.0.0564.i3203, ptr %1999, align 8
  store i64 %1945, ptr %2001, align 4
  %.sroa_idx161.i3211 = getelementptr i8, ptr %1999, i64 16
  store i64 %1944, ptr %.sroa_idx161.i3211, align 4
  %.sroa_idx162.i3212 = getelementptr i8, ptr %1999, i64 24
  store i32 %.sroa.17.0561.i3206, ptr %.sroa_idx162.i3212, align 4
  %2003 = icmp ne ptr %2000, @nil_typ
  %2004 = icmp ne ptr %2000, null
  %.not90.i3213 = and i1 %2003, %2004
  %extract607.i3215 = lshr i160 %2002, 64
  %2005 = insertelement <2 x i160> poison, i160 %2002, i64 0
  %2006 = insertelement <2 x i160> %2005, i160 %extract607.i3215, i64 1
  br i1 %.not90.i3213, label %.cont.cont.i3221, label %2012

.cont.cont.i3221:                                 ; preds = %1973, %1957
  %vptr.i142.sroa.speculated.i3224 = phi ptr [ %1966, %1957 ], [ %2000, %1973 ]
  %.in3818 = phi <2 x i160> [ %1972, %1957 ], [ %2006, %1973 ]
  %2007 = trunc <2 x i160> %.in3818 to <2 x i64>
  %2008 = xor i1 %.070565.i3202, true
  %hash_coef_ptr.i.i143.i3227 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3224, i64 8
  %tbl_size_ptr.i.i144.i3228 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3224, i64 16
  %offset_tbl_ptr.i.i145.i3229 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3224, i64 40
  %hash_coef.i.i146.i3230 = load i64, ptr %hash_coef_ptr.i.i143.i3227, align 4
  %tbl_size.i.i147.i3231 = load i64, ptr %tbl_size_ptr.i.i144.i3228, align 4
  %offset_tbl.i.i148.i3232 = load ptr, ptr %offset_tbl_ptr.i.i145.i3229, align 8
  %product.i.i.i149.i3233 = mul i64 %hash_coef.i.i146.i3230, 4015701072841558310
  %shifted.i.i.i150.i3234 = lshr i64 %product.i.i.i149.i3233, 32
  %xored.i.i.i151.i3235 = xor i64 %shifted.i.i.i150.i3234, %product.i.i.i149.i3233
  %hash.i.i.i152.i3236 = and i64 %xored.i.i.i151.i3235, %tbl_size.i.i147.i3231
  %offset_ptr.i.i153.i3237 = getelementptr i32, ptr %offset_tbl.i.i148.i3232, i64 %hash.i.i.i152.i3236
  %offset.i.i154.i3238 = load i32, ptr %offset_ptr.i.i153.i3237, align 4
  %2009 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2010 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2011 = icmp ult i32 %.0566.i3201, 99
  br i1 %2011, label %1942, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3256

2012:                                             ; preds = %1973, %1957
  %2013 = phi ptr [ %8, %1973 ], [ %7, %1957 ]
  %2014 = load i32, ptr %66, align 4
  store i32 %2014, ptr %2013, align 4
  %2015 = add i32 %2014, 1
  %2016 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2015, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3256

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3256: ; preds = %.cont.cont.i3221, %2012
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i2337

._crit_edge.i2337:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3256, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2319
  %2017 = add nuw nsw i32 %.060.i2335, 1
  %2018 = icmp slt i32 %2017, %1834
  br i1 %2018, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2319, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355: ; preds = %._crit_edge.i2337, %1830
  %2019 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %28)
  %hash_coef.i.i99.i1566 = load i64, ptr %hash_coef_ptr.i.i143.i1498, align 4, !noalias !22
  %tbl_size.i.i100.i1567 = load i64, ptr %tbl_size_ptr.i.i144.i1499, align 4, !noalias !22
  %offset_tbl.i.i101.i1568 = load ptr, ptr %offset_tbl_ptr.i.i145.i1500, align 8, !noalias !22
  %product.i.i.i102.i1569 = mul i64 %hash_coef.i.i99.i1566, 4015701072841558310
  %shifted.i.i.i103.i1570 = lshr i64 %product.i.i.i102.i1569, 32
  %xored.i.i.i104.i1571 = xor i64 %shifted.i.i.i103.i1570, %product.i.i.i102.i1569
  %hash.i.i.i105.i1572 = and i64 %xored.i.i.i104.i1571, %tbl_size.i.i100.i1567
  %offset_ptr.i.i106.i1573 = getelementptr i32, ptr %offset_tbl.i.i101.i1568, i64 %hash.i.i.i105.i1572
  %offset.i.i121.i1574 = load i32, ptr %offset_ptr.i.i106.i1573, align 4, !noalias !224
  %2020 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2021 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2022 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2023

2023:                                             ; preds = %.cont.cont.i1596, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355
  %.0566.i1576 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355 ], [ %2027, %.cont.cont.i1596 ]
  %.070565.i1577 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355 ], [ %2089, %.cont.cont.i1596 ]
  %.sroa.0.0564.i1578 = phi ptr [ %vptr.i142.sroa.speculated.i1495, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355 ], [ %vptr.i142.sroa.speculated.i1599, %.cont.cont.i1596 ]
  %.sroa.17.0561.i1581 = phi i32 [ %offset.i.i121.i1574, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355 ], [ %offset.i.i154.i1613, %.cont.cont.i1596 ]
  %2024 = phi <2 x i64> [ %1818, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2355 ], [ %2088, %.cont.cont.i1596 ]
  %2025 = extractelement <2 x i64> %2024, i64 1
  %.sroa.12.0562.i1580 = inttoptr i64 %2025 to ptr
  %2026 = extractelement <2 x i64> %2024, i64 0
  %.sroa.6.0563.i1579 = inttoptr i64 %2026 to ptr
  %2027 = add nuw nsw i32 %.0566.i1576, 1
  %2028 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1578, 0
  %2029 = insertvalue { ptr, ptr, ptr, i32 } %2028, ptr %.sroa.6.0563.i1579, 1
  %2030 = insertvalue { ptr, ptr, ptr, i32 } %2029, ptr %.sroa.12.0562.i1580, 2
  %2031 = insertvalue { ptr, ptr, ptr, i32 } %2030, i32 %.sroa.17.0561.i1581, 3
  %2032 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1578)
  %2033 = sext i32 %.sroa.17.0561.i1581 to i64
  %2034 = getelementptr ptr, ptr %.sroa.0.0564.i1578, i64 %2033
  %2035 = getelementptr i8, ptr %2034, i64 64
  %2036 = load ptr, ptr %2035, align 8
  %result.i125.i1582 = call ptr %2036({ ptr, ptr, ptr, i32 } %2031, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2037 = call i32 %result.i125.i1582({ ptr, ptr, ptr, i32 } %2031, { ptr, ptr, ptr, i32 } %2031, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1577, label %2038, label %2054

2038:                                             ; preds = %2023
  %2039 = load i32, ptr %56, align 8
  %2040 = add i32 %2039, -1
  %2041 = and i32 %2040, %2037
  %2042 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2043 = load ptr, ptr %57, align 8
  %2044 = sext i32 %2041 to i64
  %2045 = shl nsw i64 %2044, 5
  %2046 = getelementptr i8, ptr %2043, i64 %2045
  %2047 = load ptr, ptr %2046, align 8
  %2048 = getelementptr i8, ptr %2046, i64 8
  %2049 = load i160, ptr %2048, align 4
  store ptr %.sroa.0.0564.i1578, ptr %2046, align 8
  store i64 %2026, ptr %2048, align 4
  %.sroa_idx157.i1625 = getelementptr i8, ptr %2046, i64 16
  store i64 %2025, ptr %.sroa_idx157.i1625, align 4
  %.sroa_idx158.i1626 = getelementptr i8, ptr %2046, i64 24
  store i32 %.sroa.17.0561.i1581, ptr %.sroa_idx158.i1626, align 4
  %2050 = icmp ne ptr %2047, @nil_typ
  %2051 = icmp ne ptr %2047, null
  %.not92.i1627 = and i1 %2050, %2051
  %extract.i1629 = lshr i160 %2049, 64
  %2052 = insertelement <2 x i160> poison, i160 %2049, i64 0
  %2053 = insertelement <2 x i160> %2052, i160 %extract.i1629, i64 1
  br i1 %.not92.i1627, label %.cont.cont.i1596, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1631.thread

2054:                                             ; preds = %2023
  %2055 = add i32 %2037, 2127912214
  %2056 = shl i32 %2037, 12
  %2057 = add i32 %2055, %2056
  %2058 = ashr i32 %2057, 19
  %2059 = xor i32 %2057, %2058
  %2060 = xor i32 %2059, -949894596
  %2061 = add i32 %2060, 374761393
  %2062 = shl i32 %2060, 5
  %2063 = add i32 %2061, %2062
  %2064 = add i32 %2063, -744332180
  %2065 = shl i32 %2063, 9
  %2066 = xor i32 %2064, %2065
  %2067 = add i32 %2066, -42973499
  %2068 = shl i32 %2066, 3
  %2069 = add i32 %2067, %2068
  %2070 = ashr i32 %2069, 16
  %2071 = xor i32 %2069, %2070
  %2072 = xor i32 %2071, -1252372727
  %2073 = load i32, ptr %56, align 8
  %2074 = add i32 %2073, -1
  %2075 = and i32 %2074, %2072
  %2076 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2077 = load ptr, ptr %58, align 8
  %2078 = sext i32 %2075 to i64
  %2079 = shl nsw i64 %2078, 5
  %2080 = getelementptr i8, ptr %2077, i64 %2079
  %2081 = load ptr, ptr %2080, align 8
  %2082 = getelementptr i8, ptr %2080, i64 8
  %2083 = load i160, ptr %2082, align 4
  store ptr %.sroa.0.0564.i1578, ptr %2080, align 8
  store i64 %2026, ptr %2082, align 4
  %.sroa_idx161.i1586 = getelementptr i8, ptr %2080, i64 16
  store i64 %2025, ptr %.sroa_idx161.i1586, align 4
  %.sroa_idx162.i1587 = getelementptr i8, ptr %2080, i64 24
  store i32 %.sroa.17.0561.i1581, ptr %.sroa_idx162.i1587, align 4
  %2084 = icmp ne ptr %2081, @nil_typ
  %2085 = icmp ne ptr %2081, null
  %.not90.i1588 = and i1 %2084, %2085
  %extract607.i1590 = lshr i160 %2083, 64
  %2086 = insertelement <2 x i160> poison, i160 %2083, i64 0
  %2087 = insertelement <2 x i160> %2086, i160 %extract607.i1590, i64 1
  br i1 %.not90.i1588, label %.cont.cont.i1596, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1631.thread

.cont.cont.i1596:                                 ; preds = %2054, %2038
  %vptr.i142.sroa.speculated.i1599 = phi ptr [ %2047, %2038 ], [ %2081, %2054 ]
  %.in3819 = phi <2 x i160> [ %2053, %2038 ], [ %2087, %2054 ]
  %2088 = trunc <2 x i160> %.in3819 to <2 x i64>
  %2089 = xor i1 %.070565.i1577, true
  %hash_coef_ptr.i.i143.i1602 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1599, i64 8
  %tbl_size_ptr.i.i144.i1603 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1599, i64 16
  %offset_tbl_ptr.i.i145.i1604 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1599, i64 40
  %hash_coef.i.i146.i1605 = load i64, ptr %hash_coef_ptr.i.i143.i1602, align 4
  %tbl_size.i.i147.i1606 = load i64, ptr %tbl_size_ptr.i.i144.i1603, align 4
  %offset_tbl.i.i148.i1607 = load ptr, ptr %offset_tbl_ptr.i.i145.i1604, align 8
  %product.i.i.i149.i1608 = mul i64 %hash_coef.i.i146.i1605, 4015701072841558310
  %shifted.i.i.i150.i1609 = lshr i64 %product.i.i.i149.i1608, 32
  %xored.i.i.i151.i1610 = xor i64 %shifted.i.i.i150.i1609, %product.i.i.i149.i1608
  %hash.i.i.i152.i1611 = and i64 %xored.i.i.i151.i1610, %tbl_size.i.i147.i1606
  %offset_ptr.i.i153.i1612 = getelementptr i32, ptr %offset_tbl.i.i148.i1607, i64 %hash.i.i.i152.i1611
  %offset.i.i154.i1613 = load i32, ptr %offset_ptr.i.i153.i1612, align 4
  %2090 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2091 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2092 = icmp ult i32 %.0566.i1576, 99
  br i1 %2092, label %2023, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1631

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1631.thread: ; preds = %2038, %2054
  %2093 = phi ptr [ %28, %2054 ], [ %27, %2038 ]
  %2094 = load i32, ptr %66, align 4
  store i32 %2094, ptr %2093, align 4
  %2095 = add i32 %2094, 1
  %2096 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2095, ptr %66, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  br label %HashMap_insert_keyK_valueV.exit785

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1631: ; preds = %.cont.cont.i1596
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  %2097 = icmp eq ptr %vptr.i142.sroa.speculated.i1599, null
  br i1 %2097, label %HashMap_insert_keyK_valueV.exit785, label %2098

2098:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1631
  %2099 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2100 = load ptr, ptr %57, align 8
  %2101 = load ptr, ptr %58, align 8
  %2102 = load i32, ptr %56, align 8
  %2103 = shl i32 %2102, 1
  %spec.select.i1647 = call i32 @llvm.smax.i32(i32 %2103, i32 16)
  store i32 %spec.select.i1647, ptr %56, align 8
  %2104 = zext nneg i32 %spec.select.i1647 to i64
  %2105 = shl nuw nsw i64 %2104, 5
  %result.i.i1648 = call noalias ptr @bump_malloc_inner(i64 noundef %2105, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1648, ptr %57, align 8
  %result.i20.i1649 = call noalias ptr @bump_malloc_inner(i64 noundef %2105, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1649, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %2106 = icmp sgt i32 %2102, 0
  br i1 %2106, label %.lr.ph.i2385, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2418.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2418.thread: ; preds = %2098
  %2107 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit785

.lr.ph.i2385:                                     ; preds = %2098, %._crit_edge.i2400
  %.060.i2398 = phi i32 [ %2196, %._crit_edge.i2400 ], [ 0, %2098 ]
  %2108 = zext nneg i32 %.060.i2398 to i64
  %2109 = shl nuw nsw i64 %2108, 5
  %2110 = getelementptr i8, ptr %2100, i64 %2109
  %2111 = load ptr, ptr %2110, align 8
  %2112 = icmp ne ptr %2111, @nil_typ
  %2113 = icmp ne ptr %2111, null
  %.not16.i2399 = and i1 %2112, %2113
  br i1 %.not16.i2399, label %2114, label %._crit_edge.i2400

2114:                                             ; preds = %.lr.ph.i2385
  %2115 = getelementptr i8, ptr %2110, i64 8
  %2116 = load <2 x i64>, ptr %2115, align 4
  %hash_coef_ptr.i.i18.i2402 = getelementptr i8, ptr %2111, i64 8
  %tbl_size_ptr.i.i19.i2403 = getelementptr i8, ptr %2111, i64 16
  %offset_tbl_ptr.i.i20.i2404 = getelementptr i8, ptr %2111, i64 40
  %2117 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i3274 = load i64, ptr %hash_coef_ptr.i.i18.i2402, align 4, !noalias !22
  %tbl_size.i.i100.i3275 = load i64, ptr %tbl_size_ptr.i.i19.i2403, align 4, !noalias !22
  %offset_tbl.i.i101.i3276 = load ptr, ptr %offset_tbl_ptr.i.i20.i2404, align 8, !noalias !22
  %product.i.i.i102.i3277 = mul i64 %hash_coef.i.i99.i3274, 4015701072841558310
  %shifted.i.i.i103.i3278 = lshr i64 %product.i.i.i102.i3277, 32
  %xored.i.i.i104.i3279 = xor i64 %shifted.i.i.i103.i3278, %product.i.i.i102.i3277
  %hash.i.i.i105.i3280 = and i64 %xored.i.i.i104.i3279, %tbl_size.i.i100.i3275
  %offset_ptr.i.i106.i3281 = getelementptr i32, ptr %offset_tbl.i.i101.i3276, i64 %hash.i.i.i105.i3280
  %offset.i.i121.i3282 = load i32, ptr %offset_ptr.i.i106.i3281, align 4, !noalias !227
  %2118 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2119 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2120 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2121

2121:                                             ; preds = %.cont.cont.i3303, %2114
  %.0566.i3283 = phi i32 [ 0, %2114 ], [ %2125, %.cont.cont.i3303 ]
  %.070565.i3284 = phi i1 [ true, %2114 ], [ %2187, %.cont.cont.i3303 ]
  %.sroa.0.0564.i3285 = phi ptr [ %2111, %2114 ], [ %vptr.i142.sroa.speculated.i3306, %.cont.cont.i3303 ]
  %.sroa.17.0561.i3288 = phi i32 [ %offset.i.i121.i3282, %2114 ], [ %offset.i.i154.i3320, %.cont.cont.i3303 ]
  %2122 = phi <2 x i64> [ %2116, %2114 ], [ %2186, %.cont.cont.i3303 ]
  %2123 = extractelement <2 x i64> %2122, i64 1
  %.sroa.12.0562.i3287 = inttoptr i64 %2123 to ptr
  %2124 = extractelement <2 x i64> %2122, i64 0
  %.sroa.6.0563.i3286 = inttoptr i64 %2124 to ptr
  %2125 = add nuw nsw i32 %.0566.i3283, 1
  %2126 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3285, 0
  %2127 = insertvalue { ptr, ptr, ptr, i32 } %2126, ptr %.sroa.6.0563.i3286, 1
  %2128 = insertvalue { ptr, ptr, ptr, i32 } %2127, ptr %.sroa.12.0562.i3287, 2
  %2129 = insertvalue { ptr, ptr, ptr, i32 } %2128, i32 %.sroa.17.0561.i3288, 3
  %2130 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3285)
  %2131 = sext i32 %.sroa.17.0561.i3288 to i64
  %2132 = getelementptr ptr, ptr %.sroa.0.0564.i3285, i64 %2131
  %2133 = getelementptr i8, ptr %2132, i64 64
  %2134 = load ptr, ptr %2133, align 8
  %result.i125.i3289 = call ptr %2134({ ptr, ptr, ptr, i32 } %2129, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2135 = call i32 %result.i125.i3289({ ptr, ptr, ptr, i32 } %2129, { ptr, ptr, ptr, i32 } %2129, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3284, label %2136, label %2152

2136:                                             ; preds = %2121
  %2137 = load i32, ptr %56, align 8
  %2138 = add i32 %2137, -1
  %2139 = and i32 %2138, %2135
  %2140 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2141 = load ptr, ptr %57, align 8
  %2142 = sext i32 %2139 to i64
  %2143 = shl nsw i64 %2142, 5
  %2144 = getelementptr i8, ptr %2141, i64 %2143
  %2145 = load ptr, ptr %2144, align 8
  %2146 = getelementptr i8, ptr %2144, i64 8
  %2147 = load i160, ptr %2146, align 4
  store ptr %.sroa.0.0564.i3285, ptr %2144, align 8
  store i64 %2124, ptr %2146, align 4
  %.sroa_idx157.i3332 = getelementptr i8, ptr %2144, i64 16
  store i64 %2123, ptr %.sroa_idx157.i3332, align 4
  %.sroa_idx158.i3333 = getelementptr i8, ptr %2144, i64 24
  store i32 %.sroa.17.0561.i3288, ptr %.sroa_idx158.i3333, align 4
  %2148 = icmp ne ptr %2145, @nil_typ
  %2149 = icmp ne ptr %2145, null
  %.not92.i3334 = and i1 %2148, %2149
  %extract.i3336 = lshr i160 %2147, 64
  %2150 = insertelement <2 x i160> poison, i160 %2147, i64 0
  %2151 = insertelement <2 x i160> %2150, i160 %extract.i3336, i64 1
  br i1 %.not92.i3334, label %.cont.cont.i3303, label %2191

2152:                                             ; preds = %2121
  %2153 = add i32 %2135, 2127912214
  %2154 = shl i32 %2135, 12
  %2155 = add i32 %2153, %2154
  %2156 = ashr i32 %2155, 19
  %2157 = xor i32 %2155, %2156
  %2158 = xor i32 %2157, -949894596
  %2159 = add i32 %2158, 374761393
  %2160 = shl i32 %2158, 5
  %2161 = add i32 %2159, %2160
  %2162 = add i32 %2161, -744332180
  %2163 = shl i32 %2161, 9
  %2164 = xor i32 %2162, %2163
  %2165 = add i32 %2164, -42973499
  %2166 = shl i32 %2164, 3
  %2167 = add i32 %2165, %2166
  %2168 = ashr i32 %2167, 16
  %2169 = xor i32 %2167, %2168
  %2170 = xor i32 %2169, -1252372727
  %2171 = load i32, ptr %56, align 8
  %2172 = add i32 %2171, -1
  %2173 = and i32 %2172, %2170
  %2174 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2175 = load ptr, ptr %58, align 8
  %2176 = sext i32 %2173 to i64
  %2177 = shl nsw i64 %2176, 5
  %2178 = getelementptr i8, ptr %2175, i64 %2177
  %2179 = load ptr, ptr %2178, align 8
  %2180 = getelementptr i8, ptr %2178, i64 8
  %2181 = load i160, ptr %2180, align 4
  store ptr %.sroa.0.0564.i3285, ptr %2178, align 8
  store i64 %2124, ptr %2180, align 4
  %.sroa_idx161.i3293 = getelementptr i8, ptr %2178, i64 16
  store i64 %2123, ptr %.sroa_idx161.i3293, align 4
  %.sroa_idx162.i3294 = getelementptr i8, ptr %2178, i64 24
  store i32 %.sroa.17.0561.i3288, ptr %.sroa_idx162.i3294, align 4
  %2182 = icmp ne ptr %2179, @nil_typ
  %2183 = icmp ne ptr %2179, null
  %.not90.i3295 = and i1 %2182, %2183
  %extract607.i3297 = lshr i160 %2181, 64
  %2184 = insertelement <2 x i160> poison, i160 %2181, i64 0
  %2185 = insertelement <2 x i160> %2184, i160 %extract607.i3297, i64 1
  br i1 %.not90.i3295, label %.cont.cont.i3303, label %2191

.cont.cont.i3303:                                 ; preds = %2152, %2136
  %vptr.i142.sroa.speculated.i3306 = phi ptr [ %2145, %2136 ], [ %2179, %2152 ]
  %.in3820 = phi <2 x i160> [ %2151, %2136 ], [ %2185, %2152 ]
  %2186 = trunc <2 x i160> %.in3820 to <2 x i64>
  %2187 = xor i1 %.070565.i3284, true
  %hash_coef_ptr.i.i143.i3309 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3306, i64 8
  %tbl_size_ptr.i.i144.i3310 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3306, i64 16
  %offset_tbl_ptr.i.i145.i3311 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3306, i64 40
  %hash_coef.i.i146.i3312 = load i64, ptr %hash_coef_ptr.i.i143.i3309, align 4
  %tbl_size.i.i147.i3313 = load i64, ptr %tbl_size_ptr.i.i144.i3310, align 4
  %offset_tbl.i.i148.i3314 = load ptr, ptr %offset_tbl_ptr.i.i145.i3311, align 8
  %product.i.i.i149.i3315 = mul i64 %hash_coef.i.i146.i3312, 4015701072841558310
  %shifted.i.i.i150.i3316 = lshr i64 %product.i.i.i149.i3315, 32
  %xored.i.i.i151.i3317 = xor i64 %shifted.i.i.i150.i3316, %product.i.i.i149.i3315
  %hash.i.i.i152.i3318 = and i64 %xored.i.i.i151.i3317, %tbl_size.i.i147.i3313
  %offset_ptr.i.i153.i3319 = getelementptr i32, ptr %offset_tbl.i.i148.i3314, i64 %hash.i.i.i152.i3318
  %offset.i.i154.i3320 = load i32, ptr %offset_ptr.i.i153.i3319, align 4
  %2188 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2189 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2190 = icmp ult i32 %.0566.i3283, 99
  br i1 %2190, label %2121, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3338

2191:                                             ; preds = %2152, %2136
  %2192 = phi ptr [ %6, %2152 ], [ %5, %2136 ]
  %2193 = load i32, ptr %66, align 4
  store i32 %2193, ptr %2192, align 4
  %2194 = add i32 %2193, 1
  %2195 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2194, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3338

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3338: ; preds = %.cont.cont.i3303, %2191
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i2400

._crit_edge.i2400:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3338, %.lr.ph.i2385
  %2196 = add nuw nsw i32 %.060.i2398, 1
  %2197 = icmp slt i32 %2196, %2102
  br i1 %2197, label %.lr.ph.i2385, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2418

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2418: ; preds = %._crit_edge.i2400
  %2198 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %2199

2199:                                             ; preds = %._crit_edge.i2436, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2418
  %.060.i2434 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2418 ], [ %2288, %._crit_edge.i2436 ]
  %2200 = zext nneg i32 %.060.i2434 to i64
  %2201 = shl nuw nsw i64 %2200, 5
  %2202 = getelementptr i8, ptr %2101, i64 %2201
  %2203 = load ptr, ptr %2202, align 8
  %2204 = icmp ne ptr %2203, @nil_typ
  %2205 = icmp ne ptr %2203, null
  %.not16.i2435 = and i1 %2204, %2205
  br i1 %.not16.i2435, label %2206, label %._crit_edge.i2436

2206:                                             ; preds = %2199
  %2207 = getelementptr i8, ptr %2202, i64 8
  %2208 = load <2 x i64>, ptr %2207, align 4
  %hash_coef_ptr.i.i18.i2438 = getelementptr i8, ptr %2203, i64 8
  %tbl_size_ptr.i.i19.i2439 = getelementptr i8, ptr %2203, i64 16
  %offset_tbl_ptr.i.i20.i2440 = getelementptr i8, ptr %2203, i64 40
  %2209 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i3356 = load i64, ptr %hash_coef_ptr.i.i18.i2438, align 4, !noalias !22
  %tbl_size.i.i100.i3357 = load i64, ptr %tbl_size_ptr.i.i19.i2439, align 4, !noalias !22
  %offset_tbl.i.i101.i3358 = load ptr, ptr %offset_tbl_ptr.i.i20.i2440, align 8, !noalias !22
  %product.i.i.i102.i3359 = mul i64 %hash_coef.i.i99.i3356, 4015701072841558310
  %shifted.i.i.i103.i3360 = lshr i64 %product.i.i.i102.i3359, 32
  %xored.i.i.i104.i3361 = xor i64 %shifted.i.i.i103.i3360, %product.i.i.i102.i3359
  %hash.i.i.i105.i3362 = and i64 %xored.i.i.i104.i3361, %tbl_size.i.i100.i3357
  %offset_ptr.i.i106.i3363 = getelementptr i32, ptr %offset_tbl.i.i101.i3358, i64 %hash.i.i.i105.i3362
  %offset.i.i121.i3364 = load i32, ptr %offset_ptr.i.i106.i3363, align 4, !noalias !230
  %2210 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2211 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2212 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2213

2213:                                             ; preds = %.cont.cont.i3385, %2206
  %.0566.i3365 = phi i32 [ 0, %2206 ], [ %2217, %.cont.cont.i3385 ]
  %.070565.i3366 = phi i1 [ true, %2206 ], [ %2279, %.cont.cont.i3385 ]
  %.sroa.0.0564.i3367 = phi ptr [ %2203, %2206 ], [ %vptr.i142.sroa.speculated.i3388, %.cont.cont.i3385 ]
  %.sroa.17.0561.i3370 = phi i32 [ %offset.i.i121.i3364, %2206 ], [ %offset.i.i154.i3402, %.cont.cont.i3385 ]
  %2214 = phi <2 x i64> [ %2208, %2206 ], [ %2278, %.cont.cont.i3385 ]
  %2215 = extractelement <2 x i64> %2214, i64 1
  %.sroa.12.0562.i3369 = inttoptr i64 %2215 to ptr
  %2216 = extractelement <2 x i64> %2214, i64 0
  %.sroa.6.0563.i3368 = inttoptr i64 %2216 to ptr
  %2217 = add nuw nsw i32 %.0566.i3365, 1
  %2218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3367, 0
  %2219 = insertvalue { ptr, ptr, ptr, i32 } %2218, ptr %.sroa.6.0563.i3368, 1
  %2220 = insertvalue { ptr, ptr, ptr, i32 } %2219, ptr %.sroa.12.0562.i3369, 2
  %2221 = insertvalue { ptr, ptr, ptr, i32 } %2220, i32 %.sroa.17.0561.i3370, 3
  %2222 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3367)
  %2223 = sext i32 %.sroa.17.0561.i3370 to i64
  %2224 = getelementptr ptr, ptr %.sroa.0.0564.i3367, i64 %2223
  %2225 = getelementptr i8, ptr %2224, i64 64
  %2226 = load ptr, ptr %2225, align 8
  %result.i125.i3371 = call ptr %2226({ ptr, ptr, ptr, i32 } %2221, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2227 = call i32 %result.i125.i3371({ ptr, ptr, ptr, i32 } %2221, { ptr, ptr, ptr, i32 } %2221, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3366, label %2228, label %2244

2228:                                             ; preds = %2213
  %2229 = load i32, ptr %56, align 8
  %2230 = add i32 %2229, -1
  %2231 = and i32 %2230, %2227
  %2232 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2233 = load ptr, ptr %57, align 8
  %2234 = sext i32 %2231 to i64
  %2235 = shl nsw i64 %2234, 5
  %2236 = getelementptr i8, ptr %2233, i64 %2235
  %2237 = load ptr, ptr %2236, align 8
  %2238 = getelementptr i8, ptr %2236, i64 8
  %2239 = load i160, ptr %2238, align 4
  store ptr %.sroa.0.0564.i3367, ptr %2236, align 8
  store i64 %2216, ptr %2238, align 4
  %.sroa_idx157.i3414 = getelementptr i8, ptr %2236, i64 16
  store i64 %2215, ptr %.sroa_idx157.i3414, align 4
  %.sroa_idx158.i3415 = getelementptr i8, ptr %2236, i64 24
  store i32 %.sroa.17.0561.i3370, ptr %.sroa_idx158.i3415, align 4
  %2240 = icmp ne ptr %2237, @nil_typ
  %2241 = icmp ne ptr %2237, null
  %.not92.i3416 = and i1 %2240, %2241
  %extract.i3418 = lshr i160 %2239, 64
  %2242 = insertelement <2 x i160> poison, i160 %2239, i64 0
  %2243 = insertelement <2 x i160> %2242, i160 %extract.i3418, i64 1
  br i1 %.not92.i3416, label %.cont.cont.i3385, label %2283

2244:                                             ; preds = %2213
  %2245 = add i32 %2227, 2127912214
  %2246 = shl i32 %2227, 12
  %2247 = add i32 %2245, %2246
  %2248 = ashr i32 %2247, 19
  %2249 = xor i32 %2247, %2248
  %2250 = xor i32 %2249, -949894596
  %2251 = add i32 %2250, 374761393
  %2252 = shl i32 %2250, 5
  %2253 = add i32 %2251, %2252
  %2254 = add i32 %2253, -744332180
  %2255 = shl i32 %2253, 9
  %2256 = xor i32 %2254, %2255
  %2257 = add i32 %2256, -42973499
  %2258 = shl i32 %2256, 3
  %2259 = add i32 %2257, %2258
  %2260 = ashr i32 %2259, 16
  %2261 = xor i32 %2259, %2260
  %2262 = xor i32 %2261, -1252372727
  %2263 = load i32, ptr %56, align 8
  %2264 = add i32 %2263, -1
  %2265 = and i32 %2264, %2262
  %2266 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2267 = load ptr, ptr %58, align 8
  %2268 = sext i32 %2265 to i64
  %2269 = shl nsw i64 %2268, 5
  %2270 = getelementptr i8, ptr %2267, i64 %2269
  %2271 = load ptr, ptr %2270, align 8
  %2272 = getelementptr i8, ptr %2270, i64 8
  %2273 = load i160, ptr %2272, align 4
  store ptr %.sroa.0.0564.i3367, ptr %2270, align 8
  store i64 %2216, ptr %2272, align 4
  %.sroa_idx161.i3375 = getelementptr i8, ptr %2270, i64 16
  store i64 %2215, ptr %.sroa_idx161.i3375, align 4
  %.sroa_idx162.i3376 = getelementptr i8, ptr %2270, i64 24
  store i32 %.sroa.17.0561.i3370, ptr %.sroa_idx162.i3376, align 4
  %2274 = icmp ne ptr %2271, @nil_typ
  %2275 = icmp ne ptr %2271, null
  %.not90.i3377 = and i1 %2274, %2275
  %extract607.i3379 = lshr i160 %2273, 64
  %2276 = insertelement <2 x i160> poison, i160 %2273, i64 0
  %2277 = insertelement <2 x i160> %2276, i160 %extract607.i3379, i64 1
  br i1 %.not90.i3377, label %.cont.cont.i3385, label %2283

.cont.cont.i3385:                                 ; preds = %2244, %2228
  %vptr.i142.sroa.speculated.i3388 = phi ptr [ %2237, %2228 ], [ %2271, %2244 ]
  %.in3821 = phi <2 x i160> [ %2243, %2228 ], [ %2277, %2244 ]
  %2278 = trunc <2 x i160> %.in3821 to <2 x i64>
  %2279 = xor i1 %.070565.i3366, true
  %hash_coef_ptr.i.i143.i3391 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3388, i64 8
  %tbl_size_ptr.i.i144.i3392 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3388, i64 16
  %offset_tbl_ptr.i.i145.i3393 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3388, i64 40
  %hash_coef.i.i146.i3394 = load i64, ptr %hash_coef_ptr.i.i143.i3391, align 4
  %tbl_size.i.i147.i3395 = load i64, ptr %tbl_size_ptr.i.i144.i3392, align 4
  %offset_tbl.i.i148.i3396 = load ptr, ptr %offset_tbl_ptr.i.i145.i3393, align 8
  %product.i.i.i149.i3397 = mul i64 %hash_coef.i.i146.i3394, 4015701072841558310
  %shifted.i.i.i150.i3398 = lshr i64 %product.i.i.i149.i3397, 32
  %xored.i.i.i151.i3399 = xor i64 %shifted.i.i.i150.i3398, %product.i.i.i149.i3397
  %hash.i.i.i152.i3400 = and i64 %xored.i.i.i151.i3399, %tbl_size.i.i147.i3395
  %offset_ptr.i.i153.i3401 = getelementptr i32, ptr %offset_tbl.i.i148.i3396, i64 %hash.i.i.i152.i3400
  %offset.i.i154.i3402 = load i32, ptr %offset_ptr.i.i153.i3401, align 4
  %2280 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2281 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2282 = icmp ult i32 %.0566.i3365, 99
  br i1 %2282, label %2213, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3420

2283:                                             ; preds = %2244, %2228
  %2284 = phi ptr [ %4, %2244 ], [ %3, %2228 ]
  %2285 = load i32, ptr %66, align 4
  store i32 %2285, ptr %2284, align 4
  %2286 = add i32 %2285, 1
  %2287 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2286, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3420

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3420: ; preds = %.cont.cont.i3385, %2283
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i2436

._crit_edge.i2436:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3420, %2199
  %2288 = add nuw nsw i32 %.060.i2434, 1
  %2289 = icmp slt i32 %2288, %2102
  br i1 %2289, label %2199, label %HashMap_insert_keyK_valueV.exit785

HashMap_insert_keyK_valueV.exit785:               ; preds = %._crit_edge.i2436, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2418.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1631.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1527.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1423, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1364, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1527, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1631
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2290 = sext i32 %191 to i64
  %2291 = add i64 %.0275527, %2290
  %2292 = add nsw i32 %.0266528, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %HashMap_insert_keyK_valueV.exit785, %HashMap_get_keyK.exit
  %.2277 = phi i64 [ %2291, %HashMap_insert_keyK_valueV.exit785 ], [ %.0275527, %HashMap_get_keyK.exit ]
  %.2268 = phi i32 [ %2292, %HashMap_insert_keyK_valueV.exit785 ], [ %.0266528, %HashMap_get_keyK.exit ]
  %2293 = add nuw nsw i32 %.0264529, 1
  %2294 = icmp slt i32 %.2268, %0
  %2295 = icmp slt i32 %2293, %60
  %spec.select = select i1 %2294, i1 %2295, i1 false
  br i1 %spec.select, label %68, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %.0275.lcssa = phi i64 [ 0, %1 ], [ %.2277, %._crit_edge1 ]
  %.0266.lcssa = phi i32 [ 0, %1 ], [ %.2268, %._crit_edge1 ]
  %2296 = icmp slt i32 %.0266.lcssa, %0
  br i1 %2296, label %._crit_edge.lr.ph.i, label %._crit_edge4

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge3._crit_edge
  %result.i355 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i355, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2297 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2298 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1665 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i1665, ptr noundef nonnull align 32 dereferenceable(29) %result.i355, i64 29, i1 false)
  %2299 = getelementptr i8, ptr %result.i.i1665, i64 29
  store i8 0, ptr %2299, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1665)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2300 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0266.lcssa) #16
  %result.i361 = call noalias align 64 dereferenceable_or_null(34) ptr @bump_malloc_inner(i64 noundef 34, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2301 = load <33 x i8>, ptr @qyaaw__unique_keys_for_random_hit_test, align 64
  store <33 x i8> %2301, ptr %result.i361, align 64
  %2302 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2303 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2304 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1680 = call noalias dereferenceable_or_null(34) ptr @bump_malloc_inner(i64 noundef 34, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(33) %result.i.i1680, ptr noundef nonnull align 64 dereferenceable(33) %result.i361, i64 33, i1 false)
  %2305 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2306 = getelementptr i8, ptr %result.i.i1680, i64 33
  store i8 0, ptr %2306, align 1
  %puts.i820 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1680)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3._crit_edge, %._crit_edge.lr.ph.i
  %.0274 = phi i32 [ %.0266.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge3._crit_edge ]
  %2307 = call i64 @clock()
  %2308 = icmp sgt i32 %.0274, 0
  br i1 %2308, label %.lr.ph535.preheader, label %._crit_edge.lr.ph.i1839

.lr.ph535.preheader:                              ; preds = %._crit_edge4
  %2309 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  br label %.lr.ph535

.lr.ph535:                                        ; preds = %.lr.ph535.preheader, %._crit_edge5
  %.0263534 = phi i64 [ %.2, %._crit_edge5 ], [ 0, %.lr.ph535.preheader ]
  %.0269533 = phi i1 [ %.2271, %._crit_edge5 ], [ true, %.lr.ph535.preheader ]
  %.0272532 = phi i32 [ %2440, %._crit_edge5 ], [ 0, %.lr.ph535.preheader ]
  %2310 = zext nneg i32 %.0272532 to i64
  %2311 = shl nuw nsw i64 %2310, 2
  %2312 = getelementptr i8, ptr %result.i4.i, i64 %2311
  %2313 = load i32, ptr %2312, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %2313 to i160
  %2314 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %2315 = load ptr, ptr %40, align 8
  %2316 = call i32 %2315({ ptr, i160 } %2314) #7
  %2317 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %2318 = load i32, ptr %42, align 8
  %2319 = add i32 %2318, -1
  %2320 = and i32 %2319, %2316
  %2321 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2322 = sext i32 %2320 to i64
  %2323 = shl nsw i64 %2322, 5
  %2324 = getelementptr i8, ptr %2321, i64 %2323
  %2325 = load ptr, ptr %2324, align 8
  %2326 = icmp ne ptr %2325, @nil_typ
  %2327 = icmp ne ptr %2325, null
  %.not44.i1727 = and i1 %2326, %2327
  br i1 %.not44.i1727, label %2328, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751.thread

2328:                                             ; preds = %.lr.ph535
  %2329 = getelementptr i8, ptr %2324, i64 8
  %2330 = load i64, ptr %2329, align 4
  %.sroa_idx.i1731 = getelementptr i8, ptr %2324, i64 16
  %2331 = load i64, ptr %.sroa_idx.i1731, align 4
  %2332 = inttoptr i64 %2330 to ptr
  %2333 = inttoptr i64 %2331 to ptr
  %hash_coef_ptr.i.i46.i1732 = getelementptr i8, ptr %2325, i64 8
  %tbl_size_ptr.i.i47.i1733 = getelementptr i8, ptr %2325, i64 16
  %offset_tbl_ptr.i.i48.i1734 = getelementptr i8, ptr %2325, i64 40
  %hash_coef.i.i49.i1735 = load i64, ptr %hash_coef_ptr.i.i46.i1732, align 4, !noalias !233
  %tbl_size.i.i50.i1736 = load i64, ptr %tbl_size_ptr.i.i47.i1733, align 4, !noalias !233
  %offset_tbl.i.i51.i1737 = load ptr, ptr %offset_tbl_ptr.i.i48.i1734, align 8, !noalias !233
  %product.i.i.i52.i1738 = mul i64 %hash_coef.i.i49.i1735, 4015701072841558310
  %shifted.i.i.i53.i1739 = lshr i64 %product.i.i.i52.i1738, 32
  %xored.i.i.i54.i1740 = xor i64 %shifted.i.i.i53.i1739, %product.i.i.i52.i1738
  %hash.i.i.i55.i1741 = and i64 %xored.i.i.i54.i1740, %tbl_size.i.i50.i1736
  %offset_ptr.i.i56.i1742 = getelementptr i32, ptr %offset_tbl.i.i51.i1737, i64 %hash.i.i.i55.i1741
  %offset.i.i57.i1743 = load i32, ptr %offset_ptr.i.i56.i1742, align 4, !noalias !233
  %2334 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2325, 0
  %2335 = insertvalue { ptr, ptr, ptr, i32 } %2334, ptr %2332, 1
  %2336 = insertvalue { ptr, ptr, ptr, i32 } %2335, ptr %2333, 2
  %2337 = insertvalue { ptr, ptr, ptr, i32 } %2336, i32 %offset.i.i57.i1743, 3
  %2338 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2339 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2325) #34
  %2340 = sext i32 %offset.i.i57.i1743 to i64
  %2341 = getelementptr ptr, ptr %2325, i64 %2340
  %2342 = getelementptr i8, ptr %2341, i64 64
  %2343 = load ptr, ptr %2342, align 8
  %result.i.i1744 = call ptr %2343({ ptr, ptr, ptr, i32 } %2337, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2344 = call i32 %result.i.i1744({ ptr, ptr, ptr, i32 } %2337, { ptr, ptr, ptr, i32 } %2337, ptr nonnull align 8 %2) #7
  %2345 = icmp eq i32 %2344, %2316
  br i1 %2345, label %._crit_edge.i1745, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751.thread

._crit_edge.i1745:                                ; preds = %2328
  %2346 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2347 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2325)
  %2348 = getelementptr i8, ptr %2341, i64 48
  %2349 = load ptr, ptr %2348, align 8
  %result.i59.i1746 = call ptr %2349({ ptr, ptr, ptr, i32 } %2337, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2350 = call { ptr, i160 } %result.i59.i1746({ ptr, ptr, ptr, i32 } %2337, { ptr, ptr, ptr, i32 } %2337, ptr nonnull align 8 %2) #7
  %2351 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2352 = load ptr, ptr %41, align 8
  %2353 = call i1 %2352({ ptr, i160 } %2350, { ptr, i160 } %2314) #7
  br i1 %2353, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751.thread: ; preds = %._crit_edge.i1745, %.lr.ph535, %2328
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2362

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751: ; preds = %._crit_edge.i1745
  %2354 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2355 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2325)
  %2356 = getelementptr i8, ptr %2341, i64 56
  %2357 = load ptr, ptr %2356, align 8
  %result.i60.i1748 = call ptr %2357({ ptr, ptr, ptr, i32 } %2337, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2358 = call { ptr, i160 } %result.i60.i1748({ ptr, ptr, ptr, i32 } %2337, { ptr, ptr, ptr, i32 } %2337, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1749 = extractvalue { ptr, i160 } %2358, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2359 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2360 = icmp ne ptr %.fca.0.extract21.i1749, @nil_typ
  %2361 = icmp ne ptr %.fca.0.extract21.i1749, null
  %.not63.i855 = and i1 %2360, %2361
  br i1 %.not63.i855, label %HashMap_get_keyK.exit866, label %2362

2362:                                             ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751
  %2363 = add i32 %2316, 2127912214
  %2364 = shl i32 %2316, 12
  %2365 = add i32 %2363, %2364
  %2366 = ashr i32 %2365, 19
  %2367 = xor i32 %2365, %2366
  %2368 = xor i32 %2367, -949894596
  %2369 = add i32 %2368, 374761393
  %2370 = shl i32 %2368, 5
  %2371 = add i32 %2369, %2370
  %2372 = add i32 %2371, -744332180
  %2373 = shl i32 %2371, 9
  %2374 = xor i32 %2372, %2373
  %2375 = add i32 %2374, -42973499
  %2376 = shl i32 %2374, 3
  %2377 = add i32 %2375, %2376
  %2378 = ashr i32 %2377, 16
  %2379 = xor i32 %2377, %2378
  %2380 = xor i32 %2379, -1252372727
  %2381 = load i32, ptr %42, align 8
  %2382 = add i32 %2381, -1
  %2383 = and i32 %2382, %2380
  %2384 = load ptr, ptr %44, align 8
  %2385 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2386 = sext i32 %2383 to i64
  %2387 = shl nsw i64 %2386, 5
  %2388 = getelementptr i8, ptr %2384, i64 %2387
  %2389 = load ptr, ptr %2388, align 8
  %2390 = icmp ne ptr %2389, @nil_typ
  %2391 = icmp ne ptr %2389, null
  %.not44.i1781 = and i1 %2390, %2391
  br i1 %.not44.i1781, label %2392, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1805

2392:                                             ; preds = %2362
  %2393 = getelementptr i8, ptr %2388, i64 8
  %2394 = load i64, ptr %2393, align 4
  %.sroa_idx.i1785 = getelementptr i8, ptr %2388, i64 16
  %2395 = load i64, ptr %.sroa_idx.i1785, align 4
  %2396 = inttoptr i64 %2394 to ptr
  %2397 = inttoptr i64 %2395 to ptr
  %hash_coef_ptr.i.i46.i1786 = getelementptr i8, ptr %2389, i64 8
  %tbl_size_ptr.i.i47.i1787 = getelementptr i8, ptr %2389, i64 16
  %offset_tbl_ptr.i.i48.i1788 = getelementptr i8, ptr %2389, i64 40
  %hash_coef.i.i49.i1789 = load i64, ptr %hash_coef_ptr.i.i46.i1786, align 4, !noalias !236
  %tbl_size.i.i50.i1790 = load i64, ptr %tbl_size_ptr.i.i47.i1787, align 4, !noalias !236
  %offset_tbl.i.i51.i1791 = load ptr, ptr %offset_tbl_ptr.i.i48.i1788, align 8, !noalias !236
  %product.i.i.i52.i1792 = mul i64 %hash_coef.i.i49.i1789, 4015701072841558310
  %shifted.i.i.i53.i1793 = lshr i64 %product.i.i.i52.i1792, 32
  %xored.i.i.i54.i1794 = xor i64 %shifted.i.i.i53.i1793, %product.i.i.i52.i1792
  %hash.i.i.i55.i1795 = and i64 %xored.i.i.i54.i1794, %tbl_size.i.i50.i1790
  %offset_ptr.i.i56.i1796 = getelementptr i32, ptr %offset_tbl.i.i51.i1791, i64 %hash.i.i.i55.i1795
  %offset.i.i57.i1797 = load i32, ptr %offset_ptr.i.i56.i1796, align 4, !noalias !236
  %2398 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2389, 0
  %2399 = insertvalue { ptr, ptr, ptr, i32 } %2398, ptr %2396, 1
  %2400 = insertvalue { ptr, ptr, ptr, i32 } %2399, ptr %2397, 2
  %2401 = insertvalue { ptr, ptr, ptr, i32 } %2400, i32 %offset.i.i57.i1797, 3
  %2402 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2403 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2389) #34
  %2404 = sext i32 %offset.i.i57.i1797 to i64
  %2405 = getelementptr ptr, ptr %2389, i64 %2404
  %2406 = getelementptr i8, ptr %2405, i64 64
  %2407 = load ptr, ptr %2406, align 8
  %result.i.i1798 = call ptr %2407({ ptr, ptr, ptr, i32 } %2401, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2408 = call i32 %result.i.i1798({ ptr, ptr, ptr, i32 } %2401, { ptr, ptr, ptr, i32 } %2401, ptr nonnull align 8 %2) #7
  %2409 = icmp eq i32 %2408, %2316
  br i1 %2409, label %._crit_edge.i1799, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1805

._crit_edge.i1799:                                ; preds = %2392
  %2410 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2411 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2389)
  %2412 = getelementptr i8, ptr %2405, i64 48
  %2413 = load ptr, ptr %2412, align 8
  %result.i59.i1800 = call ptr %2413({ ptr, ptr, ptr, i32 } %2401, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2414 = call { ptr, i160 } %result.i59.i1800({ ptr, ptr, ptr, i32 } %2401, { ptr, ptr, ptr, i32 } %2401, ptr nonnull align 8 %2) #7
  %2415 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2416 = load ptr, ptr %41, align 8
  %2417 = call i1 %2416({ ptr, i160 } %2414, { ptr, i160 } %2314) #7
  br i1 %2417, label %2418, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1805

2418:                                             ; preds = %._crit_edge.i1799
  %2419 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2420 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2389)
  %2421 = getelementptr i8, ptr %2405, i64 56
  %2422 = load ptr, ptr %2421, align 8
  %result.i60.i1802 = call ptr %2422({ ptr, ptr, ptr, i32 } %2401, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2423 = call { ptr, i160 } %result.i60.i1802({ ptr, ptr, ptr, i32 } %2401, { ptr, ptr, ptr, i32 } %2401, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1803 = extractvalue { ptr, i160 } %2423, 0
  %.fca.1.extract22.i1804 = extractvalue { ptr, i160 } %2423, 1
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1805

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1805: ; preds = %2362, %2392, %._crit_edge.i1799, %2418
  %.reg2mem43.sroa.3.077.i1782 = phi i160 [ %.fca.1.extract22.i1804, %2418 ], [ poison, %._crit_edge.i1799 ], [ poison, %2362 ], [ poison, %2392 ]
  %2424 = phi ptr [ %.fca.0.extract21.i1803, %2418 ], [ @nil_typ, %._crit_edge.i1799 ], [ @nil_typ, %2362 ], [ @nil_typ, %2392 ]
  %.reload40.fca.0.insert.i1783 = insertvalue { ptr, i160 } poison, ptr %2424, 0
  %.reload40.fca.1.insert.i1784 = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i1783, i160 %.reg2mem43.sroa.3.077.i1782, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2425 = icmp ne ptr %2424, @nil_typ
  %2426 = icmp ne ptr %2424, null
  %.not65.not.not.i859 = and i1 %2425, %2426
  %cond.fr.i860 = freeze i1 %.not65.not.not.i859
  %spec.select.i861 = select i1 %cond.fr.i860, ptr %2424, ptr @nil_typ
  br label %HashMap_get_keyK.exit866

HashMap_get_keyK.exit866:                         ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1805
  %.pn.i862 = phi { ptr, i160 } [ %2358, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751 ], [ %.reload40.fca.1.insert.i1784, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1805 ]
  %2427 = phi ptr [ %.fca.0.extract21.i1749, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1751 ], [ %spec.select.i861, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1805 ]
  %2428 = icmp ne ptr %2427, @nil_typ
  %2429 = icmp ne ptr %2427, null
  %.not281 = and i1 %2428, %2429
  br i1 %.not281, label %2430, label %._crit_edge.lr.ph.i1820

2430:                                             ; preds = %HashMap_get_keyK.exit866
  %.fca.1.extract..sroa.354.0101.i863 = extractvalue { ptr, i160 } %.pn.i862, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0101.i863 to i32
  %2431 = sext i32 %.sroa.2.8.extract.trunc to i64
  %2432 = add i64 %.0263534, %2431
  br label %._crit_edge5

._crit_edge.lr.ph.i1820:                          ; preds = %HashMap_get_keyK.exit866
  %result.i368 = call noalias align 64 dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2433 = load <51 x i8>, ptr @euodo_Error_Nil_returned_during_random_hit_test_for_key_, align 64
  store <51 x i8> %2433, ptr %result.i368, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2434 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2435 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1819 = call noalias dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(51) %result.i.i1819, ptr noundef nonnull align 64 dereferenceable(51) %result.i368, i64 51, i1 false)
  %2436 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2437 = getelementptr i8, ptr %result.i.i1819, i64 51
  store i8 0, ptr %2437, align 1
  %puts.i886 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1819)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2438 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2439 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %2313) #16
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %2430, %._crit_edge.lr.ph.i1820
  %.2271 = phi i1 [ %.0269533, %2430 ], [ false, %._crit_edge.lr.ph.i1820 ]
  %.2 = phi i64 [ %2432, %2430 ], [ %.0263534, %._crit_edge.lr.ph.i1820 ]
  %2440 = add nuw nsw i32 %.0272532, 1
  %2441 = icmp slt i32 %2440, %.0274
  br i1 %2441, label %.lr.ph535, label %._crit_edge.lr.ph.i1839

._crit_edge.lr.ph.i1839:                          ; preds = %._crit_edge5, %._crit_edge4
  %.0269.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.2271, %._crit_edge5 ]
  %.0263.lcssa = phi i64 [ 0, %._crit_edge4 ], [ %.2, %._crit_edge5 ]
  %2442 = call i64 @clock()
  %result.i374 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %result.i374, align 16
  %2443 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2444 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2445 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1838 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i1838, ptr noundef nonnull align 16 dereferenceable(14) %result.i374, i64 14, i1 false)
  %2446 = sub i64 %2442, %2307
  %2447 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2448 = getelementptr i8, ptr %result.i.i1838, i64 14
  store i8 0, ptr %2448, align 1
  %puts.i906 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1838)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i376.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376.i)
  %2449 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0274) #16
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i390.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390.i)
  %2450 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2446) #16
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i409.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409.i)
  br i1 %2308, label %._crit_edge1.i, label %._crit_edge.lr.ph.i1858

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i1839
  %2451 = icmp sgt i64 %2446, 0
  br i1 %2451, label %2452, label %._crit_edge.lr.ph.i429.i

2452:                                             ; preds = %._crit_edge1.i
  %2453 = zext nneg i32 %.0274 to i64
  %2454 = mul i64 %2446, 1000000
  %2455 = sdiv i64 %2454, %2453
  br label %._crit_edge.lr.ph.i429.i

._crit_edge.lr.ph.i429.i:                         ; preds = %2452, %._crit_edge1.i
  %.0.i = phi i64 [ %2455, %2452 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i428.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i)
  %2456 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #16
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %2457 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i447.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %2458 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i374.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447.i)
  br label %._crit_edge.lr.ph.i1858

._crit_edge.lr.ph.i1858:                          ; preds = %._crit_edge.lr.ph.i1839, %._crit_edge.lr.ph.i429.i
  %.not = icmp eq i64 %.0263.lcssa, %.0275.lcssa
  %result.i378 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i378, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2459 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2460 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1857 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i1857, ptr noundef nonnull align 32 dereferenceable(18) %result.i378, i64 18, i1 false)
  %spec.select282 = select i1 %.not, i1 %.0269.lcssa, i1 false
  %2461 = getelementptr i8, ptr %result.i.i1857, i64 18
  store i8 0, ptr %2461, align 1
  %puts.i926 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1857)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %spec.select282, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %2462 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2463 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2464 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1876 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %., ptr %result.i.i1876, align 1
  %2465 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2466 = getelementptr i8, ptr %result.i.i1876, i64 4
  store i8 0, ptr %2466, align 1
  %puts.i946 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1876)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca i32, align 4
  %28 = alloca i32, align 4
  %29 = alloca i32, align 4
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i32, align 4
  %34 = alloca i32, align 4
  %oldProtect.i434 = alloca i32, align 4
  %oldProtect.i430 = alloca i32, align 4
  %oldProtect.i389 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0323.sroa.0 = alloca i8, align 8
  %result.i385 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i385, align 8
  %35 = getelementptr inbounds i8, ptr %result.i385, i64 8
  store ptr @_parameterization_Ptri32, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i385, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %36, align 8
  %37 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i385) #38
  %result.i386 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i387 = call i32 @VirtualProtect(ptr nofree %result.i386, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i386, ptr noalias nofree noundef nonnull readnone @zatzdtouuc, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i386) #39
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i386) #38
  %result.i388 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i389)
  %result.i390 = call i32 @VirtualProtect(ptr nofree %result.i388, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i389) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i389)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i388, ptr noalias nofree noundef nonnull readnone @axlszbyysq, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i391 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i388) #39
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i388) #38
  %40 = getelementptr inbounds i8, ptr %result.i385, i64 48
  store ptr %ret.i, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %result.i385, i64 56
  store ptr %ret.i391, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i385, i64 40
  store i32 8, ptr %42, align 8
  %result.i.i724 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %43 = getelementptr inbounds i8, ptr %result.i385, i64 24
  store ptr %result.i.i724, ptr %43, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %44 = getelementptr inbounds i8, ptr %result.i385, i64 32
  store ptr %result.i9.i, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %result.i428 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i428, align 8
  %46 = getelementptr inbounds i8, ptr %result.i428, i64 8
  store ptr @_parameterization_Ptri1, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i428, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i428)
  %result.i429 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i430)
  %result.i431 = call i32 @VirtualProtect(ptr nofree %result.i429, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i430) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i430)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i429, ptr noalias nofree noundef nonnull readnone @hcbtagnexk, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i432 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i429) #39
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i429)
  %result.i433 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i434)
  %result.i435 = call i32 @VirtualProtect(ptr nofree %result.i433, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i434) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i434)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i433, ptr noalias nofree noundef nonnull readnone @ublvkccrts, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i436 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i433) #39
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i433)
  %51 = getelementptr inbounds i8, ptr %result.i428, i64 48
  store ptr %ret.i432, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i428, i64 56
  store ptr %ret.i436, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i428, i64 40
  store i32 8, ptr %53, align 8
  %result.i.i763 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %54 = getelementptr inbounds i8, ptr %result.i428, i64 24
  store ptr %result.i.i763, ptr %54, align 8
  %result.i9.i764 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %55 = getelementptr inbounds i8, ptr %result.i428, i64 32
  store ptr %result.i9.i764, ptr %55, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %57 = mul i32 %0, 10
  %58 = icmp sgt i32 %0, 0
  %59 = icmp sgt i32 %57, 0
  %spec.select706 = and i1 %58, %59
  br i1 %spec.select706, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %62 = getelementptr inbounds i8, ptr %result.i385, i64 44
  %63 = getelementptr inbounds i8, ptr %result.i428, i64 44
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  br label %65

65:                                               ; preds = %.lr.ph, %._crit_edge1
  %66 = phi i32 [ 789, %.lr.ph ], [ %69, %._crit_edge1 ]
  %.0358708 = phi i32 [ 0, %.lr.ph ], [ %2284, %._crit_edge1 ]
  %.0361707 = phi i32 [ 0, %.lr.ph ], [ %.2363, %._crit_edge1 ]
  %67 = mul i32 %66, 1103515245
  %68 = add i32 %67, 12345
  %69 = and i32 %68, 2147483647
  %.sroa.0347.0.insert.ext = zext nneg i32 %69 to i160
  %70 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0347.0.insert.ext, 1
  %71 = load ptr, ptr %51, align 8
  %72 = call i32 %71({ ptr, i160 } %70) #7
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %74 = load i32, ptr %53, align 8
  %75 = add i32 %74, -1
  %76 = and i32 %75, %72
  %77 = load ptr, ptr %54, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %78 = sext i32 %76 to i64
  %79 = shl nsw i64 %78, 5
  %80 = getelementptr i8, ptr %77, i64 %79
  %81 = load ptr, ptr %80, align 8
  %82 = icmp ne ptr %81, @nil_typ
  %83 = icmp ne ptr %81, null
  %.not44.i = and i1 %82, %83
  br i1 %.not44.i, label %84, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

84:                                               ; preds = %65
  %85 = getelementptr i8, ptr %80, i64 8
  %86 = load i64, ptr %85, align 4
  %.sroa_idx.i = getelementptr i8, ptr %80, i64 16
  %87 = load i64, ptr %.sroa_idx.i, align 4
  %88 = inttoptr i64 %86 to ptr
  %89 = inttoptr i64 %87 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %81, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %81, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %81, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !239
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !239
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !239
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !239
  %90 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %81, 0
  %91 = insertvalue { ptr, ptr, ptr, i32 } %90, ptr %88, 1
  %92 = insertvalue { ptr, ptr, ptr, i32 } %91, ptr %89, 2
  %93 = insertvalue { ptr, ptr, ptr, i32 } %92, i32 %offset.i.i57.i, 3
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %81) #34
  %96 = sext i32 %offset.i.i57.i to i64
  %97 = getelementptr ptr, ptr %81, i64 %96
  %98 = getelementptr i8, ptr %97, i64 64
  %99 = load ptr, ptr %98, align 8
  %result.i.i = call ptr %99({ ptr, ptr, ptr, i32 } %93, ptr nocapture nofree noundef nonnull readonly %2) #15
  %100 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %93, { ptr, ptr, ptr, i32 } %93, ptr nonnull align 8 %2) #7
  %101 = icmp eq i32 %100, %72
  br i1 %101, label %._crit_edge.i1282, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i1282:                                ; preds = %84
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %81)
  %104 = getelementptr i8, ptr %97, i64 48
  %105 = load ptr, ptr %104, align 8
  %result.i59.i = call ptr %105({ ptr, ptr, ptr, i32 } %93, ptr nocapture nofree noundef nonnull readonly %2) #15
  %106 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %93, { ptr, ptr, ptr, i32 } %93, ptr nonnull align 8 %2) #7
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %108 = load ptr, ptr %52, align 8
  %109 = call i1 %108({ ptr, i160 } %106, { ptr, i160 } %70) #7
  br i1 %109, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i1282, %65, %84
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %118

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1282
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %111 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %81)
  %112 = getelementptr i8, ptr %97, i64 56
  %113 = load ptr, ptr %112, align 8
  %result.i60.i = call ptr %113({ ptr, ptr, ptr, i32 } %93, ptr nocapture nofree noundef nonnull readonly %2) #15
  %114 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %93, { ptr, ptr, ptr, i32 } %93, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %114, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %116 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %117 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %116, %117
  br i1 %.not63.i, label %HashMap_get_keyK.exit, label %118

118:                                              ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %119 = add i32 %72, 2127912214
  %120 = shl i32 %72, 12
  %121 = add i32 %119, %120
  %122 = ashr i32 %121, 19
  %123 = xor i32 %121, %122
  %124 = xor i32 %123, -949894596
  %125 = add i32 %124, 374761393
  %126 = shl i32 %124, 5
  %127 = add i32 %125, %126
  %128 = add i32 %127, -744332180
  %129 = shl i32 %127, 9
  %130 = xor i32 %128, %129
  %131 = add i32 %130, -42973499
  %132 = shl i32 %130, 3
  %133 = add i32 %131, %132
  %134 = ashr i32 %133, 16
  %135 = xor i32 %133, %134
  %136 = xor i32 %135, -1252372727
  %137 = load i32, ptr %53, align 8
  %138 = add i32 %137, -1
  %139 = and i32 %138, %136
  %140 = load ptr, ptr %55, align 8
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %142 = sext i32 %139 to i64
  %143 = shl nsw i64 %142, 5
  %144 = getelementptr i8, ptr %140, i64 %143
  %145 = load ptr, ptr %144, align 8
  %146 = icmp ne ptr %145, @nil_typ
  %147 = icmp ne ptr %145, null
  %.not44.i1311 = and i1 %146, %147
  br i1 %.not44.i1311, label %148, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1335

148:                                              ; preds = %118
  %149 = getelementptr i8, ptr %144, i64 8
  %150 = load i64, ptr %149, align 4
  %.sroa_idx.i1315 = getelementptr i8, ptr %144, i64 16
  %151 = load i64, ptr %.sroa_idx.i1315, align 4
  %152 = inttoptr i64 %150 to ptr
  %153 = inttoptr i64 %151 to ptr
  %hash_coef_ptr.i.i46.i1316 = getelementptr i8, ptr %145, i64 8
  %tbl_size_ptr.i.i47.i1317 = getelementptr i8, ptr %145, i64 16
  %offset_tbl_ptr.i.i48.i1318 = getelementptr i8, ptr %145, i64 40
  %hash_coef.i.i49.i1319 = load i64, ptr %hash_coef_ptr.i.i46.i1316, align 4, !noalias !242
  %tbl_size.i.i50.i1320 = load i64, ptr %tbl_size_ptr.i.i47.i1317, align 4, !noalias !242
  %offset_tbl.i.i51.i1321 = load ptr, ptr %offset_tbl_ptr.i.i48.i1318, align 8, !noalias !242
  %product.i.i.i52.i1322 = mul i64 %hash_coef.i.i49.i1319, 4015701072841558310
  %shifted.i.i.i53.i1323 = lshr i64 %product.i.i.i52.i1322, 32
  %xored.i.i.i54.i1324 = xor i64 %shifted.i.i.i53.i1323, %product.i.i.i52.i1322
  %hash.i.i.i55.i1325 = and i64 %xored.i.i.i54.i1324, %tbl_size.i.i50.i1320
  %offset_ptr.i.i56.i1326 = getelementptr i32, ptr %offset_tbl.i.i51.i1321, i64 %hash.i.i.i55.i1325
  %offset.i.i57.i1327 = load i32, ptr %offset_ptr.i.i56.i1326, align 4, !noalias !242
  %154 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %145, 0
  %155 = insertvalue { ptr, ptr, ptr, i32 } %154, ptr %152, 1
  %156 = insertvalue { ptr, ptr, ptr, i32 } %155, ptr %153, 2
  %157 = insertvalue { ptr, ptr, ptr, i32 } %156, i32 %offset.i.i57.i1327, 3
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %145) #34
  %160 = sext i32 %offset.i.i57.i1327 to i64
  %161 = getelementptr ptr, ptr %145, i64 %160
  %162 = getelementptr i8, ptr %161, i64 64
  %163 = load ptr, ptr %162, align 8
  %result.i.i1328 = call ptr %163({ ptr, ptr, ptr, i32 } %157, ptr nocapture nofree noundef nonnull readonly %2) #15
  %164 = call i32 %result.i.i1328({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr nonnull align 8 %2) #7
  %165 = icmp eq i32 %164, %72
  br i1 %165, label %._crit_edge.i1329, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1335

._crit_edge.i1329:                                ; preds = %148
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %145)
  %168 = getelementptr i8, ptr %161, i64 48
  %169 = load ptr, ptr %168, align 8
  %result.i59.i1330 = call ptr %169({ ptr, ptr, ptr, i32 } %157, ptr nocapture nofree noundef nonnull readonly %2) #15
  %170 = call { ptr, i160 } %result.i59.i1330({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr nonnull align 8 %2) #7
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %172 = load ptr, ptr %52, align 8
  %173 = call i1 %172({ ptr, i160 } %170, { ptr, i160 } %70) #7
  br i1 %173, label %174, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1335

174:                                              ; preds = %._crit_edge.i1329
  %175 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %145)
  %177 = getelementptr i8, ptr %161, i64 56
  %178 = load ptr, ptr %177, align 8
  %result.i60.i1332 = call ptr %178({ ptr, ptr, ptr, i32 } %157, ptr nocapture nofree noundef nonnull readonly %2) #15
  %179 = call { ptr, i160 } %result.i60.i1332({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1333 = extractvalue { ptr, i160 } %179, 0
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1335

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1335: ; preds = %118, %148, %._crit_edge.i1329, %174
  %180 = phi ptr [ %.fca.0.extract21.i1333, %174 ], [ @nil_typ, %._crit_edge.i1329 ], [ @nil_typ, %118 ], [ @nil_typ, %148 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %181 = icmp ne ptr %180, @nil_typ
  %182 = icmp ne ptr %180, null
  %.not65.not.not.i = and i1 %181, %182
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %180, ptr @nil_typ
  br label %HashMap_get_keyK.exit

HashMap_get_keyK.exit:                            ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1335
  %183 = phi ptr [ %.fca.0.extract21.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1335 ]
  %184 = icmp eq ptr %183, @nil_typ
  %185 = icmp eq ptr %183, null
  %186 = or i1 %184, %185
  br i1 %186, label %187, label %._crit_edge1

187:                                              ; preds = %HashMap_get_keyK.exit
  %188 = add nuw i32 %69, 1
  %.sroa.0330.0.insert.ext = zext i32 %188 to i160
  %189 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0330.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %190 = load ptr, ptr %result.i385, align 8
  %191 = load ptr, ptr %40, align 8
  %192 = call i32 %191({ ptr, i160 } %70) #7
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %194 = load i32, ptr %42, align 8
  %195 = add i32 %194, -1
  %196 = and i32 %195, %192
  %197 = load ptr, ptr %43, align 8
  %198 = load ptr, ptr %35, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %199 = sext i32 %196 to i64
  %200 = shl nsw i64 %199, 5
  %201 = getelementptr i8, ptr %197, i64 %200
  %202 = load ptr, ptr %201, align 8
  %203 = getelementptr i8, ptr %201, i64 8
  %204 = icmp ne ptr %202, @nil_typ
  %205 = icmp ne ptr %202, null
  %.not64.i = and i1 %204, %205
  br i1 %.not64.i, label %206, label %303

206:                                              ; preds = %187
  %207 = load i64, ptr %203, align 4
  %.sroa_idx.i1376 = getelementptr i8, ptr %201, i64 16
  %208 = load i64, ptr %.sroa_idx.i1376, align 4
  %209 = inttoptr i64 %207 to ptr
  %210 = inttoptr i64 %208 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %202, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %202, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %202, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !245
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !245
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !245
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !245
  %211 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %202, 0
  %212 = insertvalue { ptr, ptr, ptr, i32 } %211, ptr %209, 1
  %213 = insertvalue { ptr, ptr, ptr, i32 } %212, ptr %210, 2
  %214 = insertvalue { ptr, ptr, ptr, i32 } %213, i32 %offset.i.i77.i, 3
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %216 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %202) #34
  %217 = sext i32 %offset.i.i77.i to i64
  %218 = getelementptr ptr, ptr %202, i64 %217
  %219 = getelementptr i8, ptr %218, i64 64
  %220 = load ptr, ptr %219, align 8
  %result.i.i1377 = call ptr %220({ ptr, ptr, ptr, i32 } %214, ptr nocapture nofree noundef nonnull readonly %2) #15
  %221 = call i32 %result.i.i1377({ ptr, ptr, ptr, i32 } %214, { ptr, ptr, ptr, i32 } %214, ptr nonnull align 8 %2) #7
  %222 = icmp eq i32 %221, %192
  br i1 %222, label %._crit_edge.i1378, label %303

._crit_edge.i1378:                                ; preds = %206
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %202)
  %225 = getelementptr i8, ptr %218, i64 48
  %226 = load ptr, ptr %225, align 8
  %result.i79.i = call ptr %226({ ptr, ptr, ptr, i32 } %214, ptr nocapture nofree noundef nonnull readonly %2) #15
  %227 = call { ptr, i160 } %result.i79.i({ ptr, ptr, ptr, i32 } %214, { ptr, ptr, ptr, i32 } %214, ptr nonnull align 8 %2) #7
  %228 = load ptr, ptr %41, align 8
  %229 = call i1 %228({ ptr, i160 } %227, { ptr, i160 } %70) #7
  br i1 %229, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %303

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1378
  %230 = load ptr, ptr %result.i385, align 8
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %232 = load ptr, ptr %35, align 8
  %233 = load ptr, ptr %230, align 8, !alias.scope !248
  %234 = getelementptr i8, ptr %233, i64 72
  %235 = load ptr, ptr %234, align 8, !alias.scope !248
  %result.i.i.i1379 = call { i64, i64 } %235(ptr nocapture nofree nonnull readonly %230) #5, !alias.scope !248
  %236 = extractvalue { i64, i64 } %result.i.i.i1379, 0
  %237 = extractvalue { i64, i64 } %result.i.i.i1379, 1
  %238 = urem i64 20, %237
  %239 = icmp eq i64 %238, 0
  %240 = sub i64 %237, %238
  %241 = select i1 %239, i64 0, i64 %240
  %242 = add i64 %236, 20
  %243 = add i64 %242, %241
  %244 = load ptr, ptr %232, align 8, !alias.scope !248
  %245 = getelementptr i8, ptr %244, i64 72
  %246 = load ptr, ptr %245, align 8, !alias.scope !248
  %result.i1.i.i1380 = call { i64, i64 } %246(ptr nocapture nofree nonnull readonly %232) #5, !alias.scope !248
  %247 = extractvalue { i64, i64 } %result.i1.i.i1380, 0
  %248 = extractvalue { i64, i64 } %result.i1.i.i1380, 1
  %249 = call i64 @llvm.umax.i64(i64 %237, i64 %248)
  %250 = call i64 @llvm.umax.i64(i64 %249, i64 8)
  %251 = urem i64 %243, %248
  %252 = icmp eq i64 %251, 0
  %253 = sub i64 %248, %251
  %254 = select i1 %252, i64 0, i64 %253
  %255 = add i64 %247, %243
  %256 = add i64 %255, %254
  %257 = urem i64 %256, %250
  %258 = icmp eq i64 %257, 0
  %259 = sub i64 %250, %257
  %260 = select i1 %258, i64 0, i64 %259
  %261 = add i64 %260, %256
  %result.i83.i1381 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %261, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %230, ptr %result.i83.i1381, align 8
  %262 = getelementptr inbounds i8, ptr %result.i83.i1381, i64 8
  store ptr %232, ptr %262, align 8
  %263 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1381)
  %264 = load ptr, ptr %230, align 8
  %265 = getelementptr i8, ptr %264, i64 72
  %266 = load ptr, ptr %265, align 8
  %result.i.i114.i = call { i64, i64 } %266(ptr nocapture nofree nonnull readonly %230) #5
  %267 = extractvalue { i64, i64 } %result.i.i114.i, 1
  %268 = urem i64 20, %267
  %269 = icmp eq i64 %268, 0
  %reass.sub4277 = sub i64 %267, %268
  %270 = add i64 %reass.sub4277, 20
  %271 = select i1 %269, i64 20, i64 %270
  %272 = getelementptr i8, ptr %result.i83.i1381, i64 %271
  %273 = getelementptr i8, ptr %264, i64 64
  %274 = load ptr, ptr %273, align 8
  call void %274({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %230, ptr nocapture nofree writeonly %272) #12
  %275 = load ptr, ptr %result.i83.i1381, align 8
  %276 = load ptr, ptr %275, align 8
  %277 = getelementptr i8, ptr %276, i64 72
  %278 = load ptr, ptr %277, align 8
  %result.i.i115.i = call { i64, i64 } %278(ptr nocapture nofree nonnull readonly %275) #5
  %279 = extractvalue { i64, i64 } %result.i.i115.i, 0
  %280 = extractvalue { i64, i64 } %result.i.i115.i, 1
  %281 = urem i64 20, %280
  %282 = icmp eq i64 %281, 0
  %283 = sub i64 %280, %281
  %284 = select i1 %282, i64 0, i64 %283
  %285 = add i64 %279, 20
  %286 = add i64 %285, %284
  %287 = load ptr, ptr %262, align 8
  %288 = load ptr, ptr %287, align 8
  %289 = getelementptr i8, ptr %288, i64 72
  %290 = load ptr, ptr %289, align 8
  %result.i1.i116.i = call { i64, i64 } %290(ptr nocapture nofree nonnull readonly %287) #5
  %291 = extractvalue { i64, i64 } %result.i1.i116.i, 1
  %292 = urem i64 %286, %291
  %293 = icmp eq i64 %292, 0
  %294 = sub i64 %291, %292
  %295 = select i1 %293, i64 0, i64 %294
  %296 = getelementptr i8, ptr %result.i83.i1381, i64 %286
  %297 = getelementptr i8, ptr %296, i64 %295
  %298 = getelementptr i8, ptr %288, i64 64
  %299 = load ptr, ptr %298, align 8
  call void %299({ ptr, i160 } %189, ptr nocapture nofree nonnull readonly %287, ptr nocapture nofree writeonly %297) #12
  %300 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %301 = getelementptr inbounds i8, ptr %result.i83.i1381, i64 16
  store i32 %192, ptr %301, align 8
  store ptr @Entry, ptr %201, align 8
  %302 = ptrtoint ptr %result.i83.i1381 to i64
  store i64 %302, ptr %203, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %201, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

303:                                              ; preds = %._crit_edge.i1378, %187, %206
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %304 = add i32 %192, 2127912214
  %305 = shl i32 %192, 12
  %306 = add i32 %304, %305
  %307 = ashr i32 %306, 19
  %308 = xor i32 %306, %307
  %309 = xor i32 %308, -949894596
  %310 = add i32 %309, 374761393
  %311 = shl i32 %309, 5
  %312 = add i32 %310, %311
  %313 = add i32 %312, -744332180
  %314 = shl i32 %312, 9
  %315 = xor i32 %313, %314
  %316 = add i32 %315, -42973499
  %317 = shl i32 %315, 3
  %318 = add i32 %316, %317
  %319 = ashr i32 %318, 16
  %320 = xor i32 %318, %319
  %321 = xor i32 %320, -1252372727
  %322 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %323 = load i32, ptr %42, align 8
  %324 = add i32 %323, -1
  %325 = and i32 %324, %321
  %326 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %327 = sext i32 %325 to i64
  %328 = shl nsw i64 %327, 5
  %329 = getelementptr i8, ptr %326, i64 %328
  %330 = load ptr, ptr %329, align 8
  %331 = getelementptr i8, ptr %329, i64 8
  %332 = icmp ne ptr %330, @nil_typ
  %333 = icmp ne ptr %330, null
  %.not64.i1411 = and i1 %332, %333
  br i1 %.not64.i1411, label %334, label %432

334:                                              ; preds = %303
  %335 = load i64, ptr %331, align 4
  %.sroa_idx.i1413 = getelementptr i8, ptr %329, i64 16
  %336 = load i64, ptr %.sroa_idx.i1413, align 4
  %337 = inttoptr i64 %335 to ptr
  %338 = inttoptr i64 %336 to ptr
  %hash_coef_ptr.i.i66.i1414 = getelementptr i8, ptr %330, i64 8
  %tbl_size_ptr.i.i67.i1415 = getelementptr i8, ptr %330, i64 16
  %offset_tbl_ptr.i.i68.i1416 = getelementptr i8, ptr %330, i64 40
  %hash_coef.i.i69.i1417 = load i64, ptr %hash_coef_ptr.i.i66.i1414, align 4, !noalias !251
  %tbl_size.i.i70.i1418 = load i64, ptr %tbl_size_ptr.i.i67.i1415, align 4, !noalias !251
  %offset_tbl.i.i71.i1419 = load ptr, ptr %offset_tbl_ptr.i.i68.i1416, align 8, !noalias !251
  %product.i.i.i72.i1420 = mul i64 %hash_coef.i.i69.i1417, 4015701072841558310
  %shifted.i.i.i73.i1421 = lshr i64 %product.i.i.i72.i1420, 32
  %xored.i.i.i74.i1422 = xor i64 %shifted.i.i.i73.i1421, %product.i.i.i72.i1420
  %hash.i.i.i75.i1423 = and i64 %xored.i.i.i74.i1422, %tbl_size.i.i70.i1418
  %offset_ptr.i.i76.i1424 = getelementptr i32, ptr %offset_tbl.i.i71.i1419, i64 %hash.i.i.i75.i1423
  %offset.i.i77.i1425 = load i32, ptr %offset_ptr.i.i76.i1424, align 4, !noalias !251
  %339 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %330, 0
  %340 = insertvalue { ptr, ptr, ptr, i32 } %339, ptr %337, 1
  %341 = insertvalue { ptr, ptr, ptr, i32 } %340, ptr %338, 2
  %342 = insertvalue { ptr, ptr, ptr, i32 } %341, i32 %offset.i.i77.i1425, 3
  %343 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %344 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %330) #34
  %345 = sext i32 %offset.i.i77.i1425 to i64
  %346 = getelementptr ptr, ptr %330, i64 %345
  %347 = getelementptr i8, ptr %346, i64 64
  %348 = load ptr, ptr %347, align 8
  %result.i.i1426 = call ptr %348({ ptr, ptr, ptr, i32 } %342, ptr nocapture nofree noundef nonnull readonly %2) #15
  %349 = call i32 %result.i.i1426({ ptr, ptr, ptr, i32 } %342, { ptr, ptr, ptr, i32 } %342, ptr nonnull align 8 %2) #7
  %350 = icmp eq i32 %349, %192
  br i1 %350, label %._crit_edge.i1427, label %432

._crit_edge.i1427:                                ; preds = %334
  %351 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %352 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %330)
  %353 = getelementptr i8, ptr %346, i64 48
  %354 = load ptr, ptr %353, align 8
  %result.i79.i1428 = call ptr %354({ ptr, ptr, ptr, i32 } %342, ptr nocapture nofree noundef nonnull readonly %2) #15
  %355 = call { ptr, i160 } %result.i79.i1428({ ptr, ptr, ptr, i32 } %342, { ptr, ptr, ptr, i32 } %342, ptr nonnull align 8 %2) #7
  %356 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %357 = load ptr, ptr %41, align 8
  %358 = call i1 %357({ ptr, i160 } %355, { ptr, i160 } %70) #7
  br i1 %358, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1440, label %432

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1440: ; preds = %._crit_edge.i1427
  %359 = load ptr, ptr %result.i385, align 8
  %360 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %361 = load ptr, ptr %35, align 8
  %362 = load ptr, ptr %359, align 8, !alias.scope !254
  %363 = getelementptr i8, ptr %362, i64 72
  %364 = load ptr, ptr %363, align 8, !alias.scope !254
  %result.i.i.i1432 = call { i64, i64 } %364(ptr nocapture nofree nonnull readonly %359) #5, !alias.scope !254
  %365 = extractvalue { i64, i64 } %result.i.i.i1432, 0
  %366 = extractvalue { i64, i64 } %result.i.i.i1432, 1
  %367 = urem i64 20, %366
  %368 = icmp eq i64 %367, 0
  %369 = sub i64 %366, %367
  %370 = select i1 %368, i64 0, i64 %369
  %371 = add i64 %365, 20
  %372 = add i64 %371, %370
  %373 = load ptr, ptr %361, align 8, !alias.scope !254
  %374 = getelementptr i8, ptr %373, i64 72
  %375 = load ptr, ptr %374, align 8, !alias.scope !254
  %result.i1.i.i1433 = call { i64, i64 } %375(ptr nocapture nofree nonnull readonly %361) #5, !alias.scope !254
  %376 = extractvalue { i64, i64 } %result.i1.i.i1433, 0
  %377 = extractvalue { i64, i64 } %result.i1.i.i1433, 1
  %378 = call i64 @llvm.umax.i64(i64 %366, i64 %377)
  %379 = call i64 @llvm.umax.i64(i64 %378, i64 8)
  %380 = urem i64 %372, %377
  %381 = icmp eq i64 %380, 0
  %382 = sub i64 %377, %380
  %383 = select i1 %381, i64 0, i64 %382
  %384 = add i64 %376, %372
  %385 = add i64 %384, %383
  %386 = urem i64 %385, %379
  %387 = icmp eq i64 %386, 0
  %388 = sub i64 %379, %386
  %389 = select i1 %387, i64 0, i64 %388
  %390 = add i64 %389, %385
  %result.i83.i1434 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %390, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %359, ptr %result.i83.i1434, align 8
  %391 = getelementptr inbounds i8, ptr %result.i83.i1434, i64 8
  store ptr %361, ptr %391, align 8
  %392 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1434)
  %393 = load ptr, ptr %359, align 8
  %394 = getelementptr i8, ptr %393, i64 72
  %395 = load ptr, ptr %394, align 8
  %result.i.i114.i1435 = call { i64, i64 } %395(ptr nocapture nofree nonnull readonly %359) #5
  %396 = extractvalue { i64, i64 } %result.i.i114.i1435, 1
  %397 = urem i64 20, %396
  %398 = icmp eq i64 %397, 0
  %reass.sub4276 = sub i64 %396, %397
  %399 = add i64 %reass.sub4276, 20
  %400 = select i1 %398, i64 20, i64 %399
  %401 = getelementptr i8, ptr %result.i83.i1434, i64 %400
  %402 = getelementptr i8, ptr %393, i64 64
  %403 = load ptr, ptr %402, align 8
  call void %403({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %359, ptr nocapture nofree writeonly %401) #12
  %404 = load ptr, ptr %result.i83.i1434, align 8
  %405 = load ptr, ptr %404, align 8
  %406 = getelementptr i8, ptr %405, i64 72
  %407 = load ptr, ptr %406, align 8
  %result.i.i115.i1437 = call { i64, i64 } %407(ptr nocapture nofree nonnull readonly %404) #5
  %408 = extractvalue { i64, i64 } %result.i.i115.i1437, 0
  %409 = extractvalue { i64, i64 } %result.i.i115.i1437, 1
  %410 = urem i64 20, %409
  %411 = icmp eq i64 %410, 0
  %412 = sub i64 %409, %410
  %413 = select i1 %411, i64 0, i64 %412
  %414 = add i64 %408, 20
  %415 = add i64 %414, %413
  %416 = load ptr, ptr %391, align 8
  %417 = load ptr, ptr %416, align 8
  %418 = getelementptr i8, ptr %417, i64 72
  %419 = load ptr, ptr %418, align 8
  %result.i1.i116.i1438 = call { i64, i64 } %419(ptr nocapture nofree nonnull readonly %416) #5
  %420 = extractvalue { i64, i64 } %result.i1.i116.i1438, 1
  %421 = urem i64 %415, %420
  %422 = icmp eq i64 %421, 0
  %423 = sub i64 %420, %421
  %424 = select i1 %422, i64 0, i64 %423
  %425 = getelementptr i8, ptr %result.i83.i1434, i64 %415
  %426 = getelementptr i8, ptr %425, i64 %424
  %427 = getelementptr i8, ptr %417, i64 64
  %428 = load ptr, ptr %427, align 8
  call void %428({ ptr, i160 } %189, ptr nocapture nofree nonnull readonly %416, ptr nocapture nofree writeonly %426) #12
  %429 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %430 = getelementptr inbounds i8, ptr %result.i83.i1434, i64 16
  store i32 %192, ptr %430, align 8
  store ptr @Entry, ptr %329, align 8
  %431 = ptrtoint ptr %result.i83.i1434 to i64
  store i64 %431, ptr %331, align 4
  %.sroa_idx28.i1439 = getelementptr i8, ptr %329, i64 24
  store i32 10, ptr %.sroa_idx28.i1439, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

432:                                              ; preds = %._crit_edge.i1427, %303, %334
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %433 = load i32, ptr %62, align 4
  %434 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %435 = load i32, ptr %42, align 8
  %.not.i = icmp slt i32 %433, %435
  br i1 %.not.i, label %._crit_edge.i, label %436

436:                                              ; preds = %432
  %437 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %438 = load ptr, ptr %43, align 8
  %439 = load ptr, ptr %44, align 8
  %440 = shl i32 %435, 1
  %spec.select.i1455 = call i32 @llvm.smax.i32(i32 %440, i32 16)
  store i32 %spec.select.i1455, ptr %42, align 8
  %441 = zext nneg i32 %spec.select.i1455 to i64
  %442 = shl nuw nsw i64 %441, 5
  %result.i.i1456 = call noalias ptr @bump_malloc_inner(i64 noundef %442, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1456, ptr %43, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %442, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i, ptr %44, align 8
  store i32 0, ptr %62, align 4
  %443 = icmp sgt i32 %435, 0
  br i1 %443, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread: ; preds = %436
  %444 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i

.lr.ph.i:                                         ; preds = %436, %._crit_edge.i2422
  %.060.i = phi i32 [ %533, %._crit_edge.i2422 ], [ 0, %436 ]
  %445 = zext nneg i32 %.060.i to i64
  %446 = shl nuw nsw i64 %445, 5
  %447 = getelementptr i8, ptr %438, i64 %446
  %448 = load ptr, ptr %447, align 8
  %449 = icmp ne ptr %448, @nil_typ
  %450 = icmp ne ptr %448, null
  %.not16.i = and i1 %449, %450
  br i1 %.not16.i, label %451, label %._crit_edge.i2422

451:                                              ; preds = %.lr.ph.i
  %452 = getelementptr i8, ptr %447, i64 8
  %453 = load <2 x i64>, ptr %452, align 4
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %448, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %448, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %448, i64 40
  %454 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %26)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !257
  %455 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %456 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %458

458:                                              ; preds = %.cont.cont.i2966, %451
  %.0566.i2953 = phi i32 [ 0, %451 ], [ %462, %.cont.cont.i2966 ]
  %.070565.i2954 = phi i1 [ true, %451 ], [ %524, %.cont.cont.i2966 ]
  %.sroa.0.0564.i2955 = phi ptr [ %448, %451 ], [ %vptr.i142.sroa.speculated.i2969, %.cont.cont.i2966 ]
  %.sroa.17.0561.i2958 = phi i32 [ %offset.i.i121.i, %451 ], [ %offset.i.i154.i2983, %.cont.cont.i2966 ]
  %459 = phi <2 x i64> [ %453, %451 ], [ %523, %.cont.cont.i2966 ]
  %460 = extractelement <2 x i64> %459, i64 1
  %.sroa.12.0562.i2957 = inttoptr i64 %460 to ptr
  %461 = extractelement <2 x i64> %459, i64 0
  %.sroa.6.0563.i2956 = inttoptr i64 %461 to ptr
  %462 = add nuw nsw i32 %.0566.i2953, 1
  %463 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2955, 0
  %464 = insertvalue { ptr, ptr, ptr, i32 } %463, ptr %.sroa.6.0563.i2956, 1
  %465 = insertvalue { ptr, ptr, ptr, i32 } %464, ptr %.sroa.12.0562.i2957, 2
  %466 = insertvalue { ptr, ptr, ptr, i32 } %465, i32 %.sroa.17.0561.i2958, 3
  %467 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2955)
  %468 = sext i32 %.sroa.17.0561.i2958 to i64
  %469 = getelementptr ptr, ptr %.sroa.0.0564.i2955, i64 %468
  %470 = getelementptr i8, ptr %469, i64 64
  %471 = load ptr, ptr %470, align 8
  %result.i125.i2959 = call ptr %471({ ptr, ptr, ptr, i32 } %466, ptr nocapture nofree noundef nonnull readonly %2) #15
  %472 = call i32 %result.i125.i2959({ ptr, ptr, ptr, i32 } %466, { ptr, ptr, ptr, i32 } %466, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2954, label %473, label %489

473:                                              ; preds = %458
  %474 = load i32, ptr %42, align 8
  %475 = add i32 %474, -1
  %476 = and i32 %475, %472
  %477 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %478 = load ptr, ptr %43, align 8
  %479 = sext i32 %476 to i64
  %480 = shl nsw i64 %479, 5
  %481 = getelementptr i8, ptr %478, i64 %480
  %482 = load ptr, ptr %481, align 8
  %483 = getelementptr i8, ptr %481, i64 8
  %484 = load i160, ptr %483, align 4
  store ptr %.sroa.0.0564.i2955, ptr %481, align 8
  store i64 %461, ptr %483, align 4
  %.sroa_idx157.i2985 = getelementptr i8, ptr %481, i64 16
  store i64 %460, ptr %.sroa_idx157.i2985, align 4
  %.sroa_idx158.i2986 = getelementptr i8, ptr %481, i64 24
  store i32 %.sroa.17.0561.i2958, ptr %.sroa_idx158.i2986, align 4
  %485 = icmp ne ptr %482, @nil_typ
  %486 = icmp ne ptr %482, null
  %.not92.i2987 = and i1 %485, %486
  %extract.i2989 = lshr i160 %484, 64
  %487 = insertelement <2 x i160> poison, i160 %484, i64 0
  %488 = insertelement <2 x i160> %487, i160 %extract.i2989, i64 1
  br i1 %.not92.i2987, label %.cont.cont.i2966, label %528

489:                                              ; preds = %458
  %490 = add i32 %472, 2127912214
  %491 = shl i32 %472, 12
  %492 = add i32 %490, %491
  %493 = ashr i32 %492, 19
  %494 = xor i32 %492, %493
  %495 = xor i32 %494, -949894596
  %496 = add i32 %495, 374761393
  %497 = shl i32 %495, 5
  %498 = add i32 %496, %497
  %499 = add i32 %498, -744332180
  %500 = shl i32 %498, 9
  %501 = xor i32 %499, %500
  %502 = add i32 %501, -42973499
  %503 = shl i32 %501, 3
  %504 = add i32 %502, %503
  %505 = ashr i32 %504, 16
  %506 = xor i32 %504, %505
  %507 = xor i32 %506, -1252372727
  %508 = load i32, ptr %42, align 8
  %509 = add i32 %508, -1
  %510 = and i32 %509, %507
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %512 = load ptr, ptr %44, align 8
  %513 = sext i32 %510 to i64
  %514 = shl nsw i64 %513, 5
  %515 = getelementptr i8, ptr %512, i64 %514
  %516 = load ptr, ptr %515, align 8
  %517 = getelementptr i8, ptr %515, i64 8
  %518 = load i160, ptr %517, align 4
  store ptr %.sroa.0.0564.i2955, ptr %515, align 8
  store i64 %461, ptr %517, align 4
  %.sroa_idx161.i2960 = getelementptr i8, ptr %515, i64 16
  store i64 %460, ptr %.sroa_idx161.i2960, align 4
  %.sroa_idx162.i2961 = getelementptr i8, ptr %515, i64 24
  store i32 %.sroa.17.0561.i2958, ptr %.sroa_idx162.i2961, align 4
  %519 = icmp ne ptr %516, @nil_typ
  %520 = icmp ne ptr %516, null
  %.not90.i2962 = and i1 %519, %520
  %extract607.i2964 = lshr i160 %518, 64
  %521 = insertelement <2 x i160> poison, i160 %518, i64 0
  %522 = insertelement <2 x i160> %521, i160 %extract607.i2964, i64 1
  br i1 %.not90.i2962, label %.cont.cont.i2966, label %528

.cont.cont.i2966:                                 ; preds = %489, %473
  %vptr.i142.sroa.speculated.i2969 = phi ptr [ %482, %473 ], [ %516, %489 ]
  %.in = phi <2 x i160> [ %488, %473 ], [ %522, %489 ]
  %523 = trunc <2 x i160> %.in to <2 x i64>
  %524 = xor i1 %.070565.i2954, true
  %hash_coef_ptr.i.i143.i2972 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2969, i64 8
  %tbl_size_ptr.i.i144.i2973 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2969, i64 16
  %offset_tbl_ptr.i.i145.i2974 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2969, i64 40
  %hash_coef.i.i146.i2975 = load i64, ptr %hash_coef_ptr.i.i143.i2972, align 4
  %tbl_size.i.i147.i2976 = load i64, ptr %tbl_size_ptr.i.i144.i2973, align 4
  %offset_tbl.i.i148.i2977 = load ptr, ptr %offset_tbl_ptr.i.i145.i2974, align 8
  %product.i.i.i149.i2978 = mul i64 %hash_coef.i.i146.i2975, 4015701072841558310
  %shifted.i.i.i150.i2979 = lshr i64 %product.i.i.i149.i2978, 32
  %xored.i.i.i151.i2980 = xor i64 %shifted.i.i.i150.i2979, %product.i.i.i149.i2978
  %hash.i.i.i152.i2981 = and i64 %xored.i.i.i151.i2980, %tbl_size.i.i147.i2976
  %offset_ptr.i.i153.i2982 = getelementptr i32, ptr %offset_tbl.i.i148.i2977, i64 %hash.i.i.i152.i2981
  %offset.i.i154.i2983 = load i32, ptr %offset_ptr.i.i153.i2982, align 4
  %525 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %526 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %527 = icmp ult i32 %.0566.i2953, 99
  br i1 %527, label %458, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2991

528:                                              ; preds = %489, %473
  %529 = phi ptr [ %26, %489 ], [ %25, %473 ]
  %530 = load i32, ptr %62, align 4
  store i32 %530, ptr %529, align 4
  %531 = add i32 %530, 1
  %532 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %531, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2991

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2991: ; preds = %.cont.cont.i2966, %528
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  br label %._crit_edge.i2422

._crit_edge.i2422:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2991, %.lr.ph.i
  %533 = add nuw nsw i32 %.060.i, 1
  %534 = icmp slt i32 %533, %435
  br i1 %534, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i2422
  %535 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %536

536:                                              ; preds = %._crit_edge.i2441, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %.060.i2439 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit ], [ %625, %._crit_edge.i2441 ]
  %537 = zext nneg i32 %.060.i2439 to i64
  %538 = shl nuw nsw i64 %537, 5
  %539 = getelementptr i8, ptr %439, i64 %538
  %540 = load ptr, ptr %539, align 8
  %541 = icmp ne ptr %540, @nil_typ
  %542 = icmp ne ptr %540, null
  %.not16.i2440 = and i1 %541, %542
  br i1 %.not16.i2440, label %543, label %._crit_edge.i2441

543:                                              ; preds = %536
  %544 = getelementptr i8, ptr %539, i64 8
  %545 = load <2 x i64>, ptr %544, align 4
  %hash_coef_ptr.i.i18.i2443 = getelementptr i8, ptr %540, i64 8
  %tbl_size_ptr.i.i19.i2444 = getelementptr i8, ptr %540, i64 16
  %offset_tbl_ptr.i.i20.i2445 = getelementptr i8, ptr %540, i64 40
  %546 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %hash_coef.i.i99.i3009 = load i64, ptr %hash_coef_ptr.i.i18.i2443, align 4, !noalias !22
  %tbl_size.i.i100.i3010 = load i64, ptr %tbl_size_ptr.i.i19.i2444, align 4, !noalias !22
  %offset_tbl.i.i101.i3011 = load ptr, ptr %offset_tbl_ptr.i.i20.i2445, align 8, !noalias !22
  %product.i.i.i102.i3012 = mul i64 %hash_coef.i.i99.i3009, 4015701072841558310
  %shifted.i.i.i103.i3013 = lshr i64 %product.i.i.i102.i3012, 32
  %xored.i.i.i104.i3014 = xor i64 %shifted.i.i.i103.i3013, %product.i.i.i102.i3012
  %hash.i.i.i105.i3015 = and i64 %xored.i.i.i104.i3014, %tbl_size.i.i100.i3010
  %offset_ptr.i.i106.i3016 = getelementptr i32, ptr %offset_tbl.i.i101.i3011, i64 %hash.i.i.i105.i3015
  %offset.i.i121.i3017 = load i32, ptr %offset_ptr.i.i106.i3016, align 4, !noalias !260
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %548 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %550

550:                                              ; preds = %.cont.cont.i3038, %543
  %.0566.i3018 = phi i32 [ 0, %543 ], [ %554, %.cont.cont.i3038 ]
  %.070565.i3019 = phi i1 [ true, %543 ], [ %616, %.cont.cont.i3038 ]
  %.sroa.0.0564.i3020 = phi ptr [ %540, %543 ], [ %vptr.i142.sroa.speculated.i3041, %.cont.cont.i3038 ]
  %.sroa.17.0561.i3023 = phi i32 [ %offset.i.i121.i3017, %543 ], [ %offset.i.i154.i3055, %.cont.cont.i3038 ]
  %551 = phi <2 x i64> [ %545, %543 ], [ %615, %.cont.cont.i3038 ]
  %552 = extractelement <2 x i64> %551, i64 1
  %.sroa.12.0562.i3022 = inttoptr i64 %552 to ptr
  %553 = extractelement <2 x i64> %551, i64 0
  %.sroa.6.0563.i3021 = inttoptr i64 %553 to ptr
  %554 = add nuw nsw i32 %.0566.i3018, 1
  %555 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3020, 0
  %556 = insertvalue { ptr, ptr, ptr, i32 } %555, ptr %.sroa.6.0563.i3021, 1
  %557 = insertvalue { ptr, ptr, ptr, i32 } %556, ptr %.sroa.12.0562.i3022, 2
  %558 = insertvalue { ptr, ptr, ptr, i32 } %557, i32 %.sroa.17.0561.i3023, 3
  %559 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3020)
  %560 = sext i32 %.sroa.17.0561.i3023 to i64
  %561 = getelementptr ptr, ptr %.sroa.0.0564.i3020, i64 %560
  %562 = getelementptr i8, ptr %561, i64 64
  %563 = load ptr, ptr %562, align 8
  %result.i125.i3024 = call ptr %563({ ptr, ptr, ptr, i32 } %558, ptr nocapture nofree noundef nonnull readonly %2) #15
  %564 = call i32 %result.i125.i3024({ ptr, ptr, ptr, i32 } %558, { ptr, ptr, ptr, i32 } %558, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3019, label %565, label %581

565:                                              ; preds = %550
  %566 = load i32, ptr %42, align 8
  %567 = add i32 %566, -1
  %568 = and i32 %567, %564
  %569 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %570 = load ptr, ptr %43, align 8
  %571 = sext i32 %568 to i64
  %572 = shl nsw i64 %571, 5
  %573 = getelementptr i8, ptr %570, i64 %572
  %574 = load ptr, ptr %573, align 8
  %575 = getelementptr i8, ptr %573, i64 8
  %576 = load i160, ptr %575, align 4
  store ptr %.sroa.0.0564.i3020, ptr %573, align 8
  store i64 %553, ptr %575, align 4
  %.sroa_idx157.i3067 = getelementptr i8, ptr %573, i64 16
  store i64 %552, ptr %.sroa_idx157.i3067, align 4
  %.sroa_idx158.i3068 = getelementptr i8, ptr %573, i64 24
  store i32 %.sroa.17.0561.i3023, ptr %.sroa_idx158.i3068, align 4
  %577 = icmp ne ptr %574, @nil_typ
  %578 = icmp ne ptr %574, null
  %.not92.i3069 = and i1 %577, %578
  %extract.i3071 = lshr i160 %576, 64
  %579 = insertelement <2 x i160> poison, i160 %576, i64 0
  %580 = insertelement <2 x i160> %579, i160 %extract.i3071, i64 1
  br i1 %.not92.i3069, label %.cont.cont.i3038, label %620

581:                                              ; preds = %550
  %582 = add i32 %564, 2127912214
  %583 = shl i32 %564, 12
  %584 = add i32 %582, %583
  %585 = ashr i32 %584, 19
  %586 = xor i32 %584, %585
  %587 = xor i32 %586, -949894596
  %588 = add i32 %587, 374761393
  %589 = shl i32 %587, 5
  %590 = add i32 %588, %589
  %591 = add i32 %590, -744332180
  %592 = shl i32 %590, 9
  %593 = xor i32 %591, %592
  %594 = add i32 %593, -42973499
  %595 = shl i32 %593, 3
  %596 = add i32 %594, %595
  %597 = ashr i32 %596, 16
  %598 = xor i32 %596, %597
  %599 = xor i32 %598, -1252372727
  %600 = load i32, ptr %42, align 8
  %601 = add i32 %600, -1
  %602 = and i32 %601, %599
  %603 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %604 = load ptr, ptr %44, align 8
  %605 = sext i32 %602 to i64
  %606 = shl nsw i64 %605, 5
  %607 = getelementptr i8, ptr %604, i64 %606
  %608 = load ptr, ptr %607, align 8
  %609 = getelementptr i8, ptr %607, i64 8
  %610 = load i160, ptr %609, align 4
  store ptr %.sroa.0.0564.i3020, ptr %607, align 8
  store i64 %553, ptr %609, align 4
  %.sroa_idx161.i3028 = getelementptr i8, ptr %607, i64 16
  store i64 %552, ptr %.sroa_idx161.i3028, align 4
  %.sroa_idx162.i3029 = getelementptr i8, ptr %607, i64 24
  store i32 %.sroa.17.0561.i3023, ptr %.sroa_idx162.i3029, align 4
  %611 = icmp ne ptr %608, @nil_typ
  %612 = icmp ne ptr %608, null
  %.not90.i3030 = and i1 %611, %612
  %extract607.i3032 = lshr i160 %610, 64
  %613 = insertelement <2 x i160> poison, i160 %610, i64 0
  %614 = insertelement <2 x i160> %613, i160 %extract607.i3032, i64 1
  br i1 %.not90.i3030, label %.cont.cont.i3038, label %620

.cont.cont.i3038:                                 ; preds = %581, %565
  %vptr.i142.sroa.speculated.i3041 = phi ptr [ %574, %565 ], [ %608, %581 ]
  %.in4280 = phi <2 x i160> [ %580, %565 ], [ %614, %581 ]
  %615 = trunc <2 x i160> %.in4280 to <2 x i64>
  %616 = xor i1 %.070565.i3019, true
  %hash_coef_ptr.i.i143.i3044 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3041, i64 8
  %tbl_size_ptr.i.i144.i3045 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3041, i64 16
  %offset_tbl_ptr.i.i145.i3046 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3041, i64 40
  %hash_coef.i.i146.i3047 = load i64, ptr %hash_coef_ptr.i.i143.i3044, align 4
  %tbl_size.i.i147.i3048 = load i64, ptr %tbl_size_ptr.i.i144.i3045, align 4
  %offset_tbl.i.i148.i3049 = load ptr, ptr %offset_tbl_ptr.i.i145.i3046, align 8
  %product.i.i.i149.i3050 = mul i64 %hash_coef.i.i146.i3047, 4015701072841558310
  %shifted.i.i.i150.i3051 = lshr i64 %product.i.i.i149.i3050, 32
  %xored.i.i.i151.i3052 = xor i64 %shifted.i.i.i150.i3051, %product.i.i.i149.i3050
  %hash.i.i.i152.i3053 = and i64 %xored.i.i.i151.i3052, %tbl_size.i.i147.i3048
  %offset_ptr.i.i153.i3054 = getelementptr i32, ptr %offset_tbl.i.i148.i3049, i64 %hash.i.i.i152.i3053
  %offset.i.i154.i3055 = load i32, ptr %offset_ptr.i.i153.i3054, align 4
  %617 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %618 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %619 = icmp ult i32 %.0566.i3018, 99
  br i1 %619, label %550, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3073

620:                                              ; preds = %581, %565
  %621 = phi ptr [ %24, %581 ], [ %23, %565 ]
  %622 = load i32, ptr %62, align 4
  store i32 %622, ptr %621, align 4
  %623 = add i32 %622, 1
  %624 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %623, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3073

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3073: ; preds = %.cont.cont.i3038, %620
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %._crit_edge.i2441

._crit_edge.i2441:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3073, %536
  %625 = add nuw nsw i32 %.060.i2439, 1
  %626 = icmp slt i32 %625, %435
  br i1 %626, label %536, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i2441, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread, %432
  %627 = load ptr, ptr %190, align 8
  %628 = getelementptr i8, ptr %627, i64 72
  %629 = load ptr, ptr %628, align 8
  %result.i.i.i = call { i64, i64 } %629(ptr nocapture nofree nonnull readonly %190) #5
  %630 = extractvalue { i64, i64 } %result.i.i.i, 0
  %631 = extractvalue { i64, i64 } %result.i.i.i, 1
  %632 = urem i64 20, %631
  %633 = icmp eq i64 %632, 0
  %634 = sub i64 %631, %632
  %635 = select i1 %633, i64 0, i64 %634
  %636 = add i64 %630, 20
  %637 = add i64 %636, %635
  %638 = load ptr, ptr %198, align 8
  %639 = getelementptr i8, ptr %638, i64 72
  %640 = load ptr, ptr %639, align 8
  %result.i1.i.i = call { i64, i64 } %640(ptr nocapture nofree nonnull readonly %198) #5
  %641 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %642 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %643 = call i64 @llvm.umax.i64(i64 %631, i64 %642)
  %644 = call i64 @llvm.umax.i64(i64 %643, i64 8)
  %645 = urem i64 %637, %642
  %646 = icmp eq i64 %645, 0
  %647 = sub i64 %642, %645
  %648 = select i1 %646, i64 0, i64 %647
  %649 = add i64 %641, %637
  %650 = add i64 %649, %648
  %651 = urem i64 %650, %644
  %652 = icmp eq i64 %651, 0
  %653 = sub i64 %644, %651
  %654 = select i1 %652, i64 0, i64 %653
  %655 = add i64 %654, %650
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %655, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %190, ptr %result.i83.i, align 8
  %656 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %198, ptr %656, align 8
  %657 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %658 = load ptr, ptr %190, align 8
  %659 = getelementptr i8, ptr %658, i64 72
  %660 = load ptr, ptr %659, align 8
  %result.i.i179.i = call { i64, i64 } %660(ptr nocapture nofree nonnull readonly %190) #5
  %661 = extractvalue { i64, i64 } %result.i.i179.i, 1
  %662 = urem i64 20, %661
  %663 = icmp eq i64 %662, 0
  %reass.sub4275 = sub i64 %661, %662
  %664 = add i64 %reass.sub4275, 20
  %665 = select i1 %663, i64 20, i64 %664
  %666 = getelementptr i8, ptr %result.i83.i, i64 %665
  %667 = getelementptr i8, ptr %658, i64 64
  %668 = load ptr, ptr %667, align 8
  call void %668({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %190, ptr nocapture nofree writeonly %666) #12
  %669 = load ptr, ptr %result.i83.i, align 8
  %670 = load ptr, ptr %669, align 8
  %671 = getelementptr i8, ptr %670, i64 72
  %672 = load ptr, ptr %671, align 8
  %result.i.i180.i = call { i64, i64 } %672(ptr nocapture nofree nonnull readonly %669) #5
  %673 = extractvalue { i64, i64 } %result.i.i180.i, 0
  %674 = extractvalue { i64, i64 } %result.i.i180.i, 1
  %675 = urem i64 20, %674
  %676 = icmp eq i64 %675, 0
  %677 = sub i64 %674, %675
  %678 = select i1 %676, i64 0, i64 %677
  %679 = add i64 %673, 20
  %680 = add i64 %679, %678
  %681 = load ptr, ptr %656, align 8
  %682 = load ptr, ptr %681, align 8
  %683 = getelementptr i8, ptr %682, i64 72
  %684 = load ptr, ptr %683, align 8
  %result.i1.i181.i = call { i64, i64 } %684(ptr nocapture nofree nonnull readonly %681) #5
  %685 = extractvalue { i64, i64 } %result.i1.i181.i, 1
  %686 = urem i64 %680, %685
  %687 = icmp eq i64 %686, 0
  %688 = sub i64 %685, %686
  %689 = select i1 %687, i64 0, i64 %688
  %690 = getelementptr i8, ptr %result.i83.i, i64 %680
  %691 = getelementptr i8, ptr %690, i64 %689
  %692 = getelementptr i8, ptr %682, i64 64
  %693 = load ptr, ptr %692, align 8
  call void %693({ ptr, i160 } %189, ptr nocapture nofree nonnull readonly %681, ptr nocapture nofree writeonly %691) #12
  %694 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %695 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %192, ptr %695, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %34)
  %696 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %697 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %698 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %699

699:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %700, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %766, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i83.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i1472, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %700 = add nuw nsw i32 %.0566.i, 1
  %701 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %702 = insertvalue { ptr, ptr, ptr, i32 } %701, ptr %.sroa.6.0563.i, 1
  %703 = insertvalue { ptr, ptr, ptr, i32 } %702, ptr %.sroa.12.0562.i, 2
  %704 = insertvalue { ptr, ptr, ptr, i32 } %703, i32 %.sroa.17.0561.i, 3
  %705 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %706 = sext i32 %.sroa.17.0561.i to i64
  %707 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %706
  %708 = getelementptr i8, ptr %707, i64 64
  %709 = load ptr, ptr %708, align 8
  %result.i125.i = call ptr %709({ ptr, ptr, ptr, i32 } %704, ptr nocapture nofree noundef nonnull readonly %2) #15
  %710 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %704, { ptr, ptr, ptr, i32 } %704, ptr nonnull align 8 %2) #7
  %711 = ptrtoint ptr %.sroa.6.0563.i to i64
  %712 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %713, label %729

713:                                              ; preds = %699
  %714 = load i32, ptr %42, align 8
  %715 = add i32 %714, -1
  %716 = and i32 %715, %710
  %717 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %718 = load ptr, ptr %43, align 8
  %719 = sext i32 %716 to i64
  %720 = shl nsw i64 %719, 5
  %721 = getelementptr i8, ptr %718, i64 %720
  %722 = load ptr, ptr %721, align 8
  %723 = getelementptr i8, ptr %721, i64 8
  %724 = load i160, ptr %723, align 4
  store ptr %.sroa.0.0564.i, ptr %721, align 8
  store i64 %711, ptr %723, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %721, i64 16
  store i64 %712, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %721, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %725 = icmp ne ptr %722, @nil_typ
  %726 = icmp ne ptr %722, null
  %.not92.i = and i1 %725, %726
  %extract.i = lshr i160 %724, 64
  %727 = insertelement <2 x i160> poison, i160 %724, i64 0
  %728 = insertelement <2 x i160> %727, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

729:                                              ; preds = %699
  %730 = add i32 %710, 2127912214
  %731 = shl i32 %710, 12
  %732 = add i32 %730, %731
  %733 = ashr i32 %732, 19
  %734 = xor i32 %732, %733
  %735 = xor i32 %734, -949894596
  %736 = add i32 %735, 374761393
  %737 = shl i32 %735, 5
  %738 = add i32 %736, %737
  %739 = add i32 %738, -744332180
  %740 = shl i32 %738, 9
  %741 = xor i32 %739, %740
  %742 = add i32 %741, -42973499
  %743 = shl i32 %741, 3
  %744 = add i32 %742, %743
  %745 = ashr i32 %744, 16
  %746 = xor i32 %744, %745
  %747 = xor i32 %746, -1252372727
  %748 = load i32, ptr %42, align 8
  %749 = add i32 %748, -1
  %750 = and i32 %749, %747
  %751 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %752 = load ptr, ptr %44, align 8
  %753 = sext i32 %750 to i64
  %754 = shl nsw i64 %753, 5
  %755 = getelementptr i8, ptr %752, i64 %754
  %756 = load ptr, ptr %755, align 8
  %757 = getelementptr i8, ptr %755, i64 8
  %758 = load i160, ptr %757, align 4
  store ptr %.sroa.0.0564.i, ptr %755, align 8
  store i64 %711, ptr %757, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %755, i64 16
  store i64 %712, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %755, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %759 = icmp ne ptr %756, @nil_typ
  %760 = icmp ne ptr %756, null
  %.not90.i = and i1 %759, %760
  %extract607.i = lshr i160 %758, 64
  %761 = insertelement <2 x i160> poison, i160 %758, i64 0
  %762 = insertelement <2 x i160> %761, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %729, %713
  %vptr.i142.sroa.speculated.i = phi ptr [ %722, %713 ], [ %756, %729 ]
  %.in4281 = phi <2 x i160> [ %728, %713 ], [ %762, %729 ]
  %763 = trunc <2 x i160> %.in4281 to <2 x i64>
  %764 = extractelement <2 x i64> %763, i64 1
  %spec.select.i1472 = inttoptr i64 %764 to ptr
  %765 = extractelement <2 x i64> %763, i64 0
  %spec.select539.i = inttoptr i64 %765 to ptr
  %766 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %767 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %769 = icmp ult i32 %.0566.i, 99
  br i1 %769, label %699, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %713, %729
  %770 = phi ptr [ %34, %729 ], [ %33, %713 ]
  %771 = load i32, ptr %62, align 4
  store i32 %771, ptr %770, align 4
  %772 = add i32 %771, 1
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %772, ptr %62, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  %774 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %774, label %HashMap_insert_keyK_valueV.exit, label %775

775:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %776 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %777 = load ptr, ptr %43, align 8
  %778 = load ptr, ptr %44, align 8
  %779 = load i32, ptr %42, align 8
  %780 = shl i32 %779, 1
  %spec.select.i1489 = call i32 @llvm.smax.i32(i32 %780, i32 16)
  store i32 %spec.select.i1489, ptr %42, align 8
  %781 = zext nneg i32 %spec.select.i1489 to i64
  %782 = shl nuw nsw i64 %781, 5
  %result.i.i1490 = call noalias ptr @bump_malloc_inner(i64 noundef %782, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1490, ptr %43, align 8
  %result.i20.i1491 = call noalias ptr @bump_malloc_inner(i64 noundef %782, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1491, ptr %44, align 8
  store i32 0, ptr %62, align 4
  %783 = icmp sgt i32 %779, 0
  br i1 %783, label %.lr.ph.i2488, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2521.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2521.thread: ; preds = %775
  %784 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557

.lr.ph.i2488:                                     ; preds = %775, %._crit_edge.i2503
  %.060.i2501 = phi i32 [ %873, %._crit_edge.i2503 ], [ 0, %775 ]
  %785 = zext nneg i32 %.060.i2501 to i64
  %786 = shl nuw nsw i64 %785, 5
  %787 = getelementptr i8, ptr %777, i64 %786
  %788 = load ptr, ptr %787, align 8
  %789 = icmp ne ptr %788, @nil_typ
  %790 = icmp ne ptr %788, null
  %.not16.i2502 = and i1 %789, %790
  br i1 %.not16.i2502, label %791, label %._crit_edge.i2503

791:                                              ; preds = %.lr.ph.i2488
  %792 = getelementptr i8, ptr %787, i64 8
  %793 = load <2 x i64>, ptr %792, align 4
  %hash_coef_ptr.i.i18.i2505 = getelementptr i8, ptr %788, i64 8
  %tbl_size_ptr.i.i19.i2506 = getelementptr i8, ptr %788, i64 16
  %offset_tbl_ptr.i.i20.i2507 = getelementptr i8, ptr %788, i64 40
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %hash_coef.i.i99.i3091 = load i64, ptr %hash_coef_ptr.i.i18.i2505, align 4, !noalias !22
  %tbl_size.i.i100.i3092 = load i64, ptr %tbl_size_ptr.i.i19.i2506, align 4, !noalias !22
  %offset_tbl.i.i101.i3093 = load ptr, ptr %offset_tbl_ptr.i.i20.i2507, align 8, !noalias !22
  %product.i.i.i102.i3094 = mul i64 %hash_coef.i.i99.i3091, 4015701072841558310
  %shifted.i.i.i103.i3095 = lshr i64 %product.i.i.i102.i3094, 32
  %xored.i.i.i104.i3096 = xor i64 %shifted.i.i.i103.i3095, %product.i.i.i102.i3094
  %hash.i.i.i105.i3097 = and i64 %xored.i.i.i104.i3096, %tbl_size.i.i100.i3092
  %offset_ptr.i.i106.i3098 = getelementptr i32, ptr %offset_tbl.i.i101.i3093, i64 %hash.i.i.i105.i3097
  %offset.i.i121.i3099 = load i32, ptr %offset_ptr.i.i106.i3098, align 4, !noalias !263
  %795 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %796 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %797 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %798

798:                                              ; preds = %.cont.cont.i3120, %791
  %.0566.i3100 = phi i32 [ 0, %791 ], [ %802, %.cont.cont.i3120 ]
  %.070565.i3101 = phi i1 [ true, %791 ], [ %864, %.cont.cont.i3120 ]
  %.sroa.0.0564.i3102 = phi ptr [ %788, %791 ], [ %vptr.i142.sroa.speculated.i3123, %.cont.cont.i3120 ]
  %.sroa.17.0561.i3105 = phi i32 [ %offset.i.i121.i3099, %791 ], [ %offset.i.i154.i3137, %.cont.cont.i3120 ]
  %799 = phi <2 x i64> [ %793, %791 ], [ %863, %.cont.cont.i3120 ]
  %800 = extractelement <2 x i64> %799, i64 1
  %.sroa.12.0562.i3104 = inttoptr i64 %800 to ptr
  %801 = extractelement <2 x i64> %799, i64 0
  %.sroa.6.0563.i3103 = inttoptr i64 %801 to ptr
  %802 = add nuw nsw i32 %.0566.i3100, 1
  %803 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3102, 0
  %804 = insertvalue { ptr, ptr, ptr, i32 } %803, ptr %.sroa.6.0563.i3103, 1
  %805 = insertvalue { ptr, ptr, ptr, i32 } %804, ptr %.sroa.12.0562.i3104, 2
  %806 = insertvalue { ptr, ptr, ptr, i32 } %805, i32 %.sroa.17.0561.i3105, 3
  %807 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3102)
  %808 = sext i32 %.sroa.17.0561.i3105 to i64
  %809 = getelementptr ptr, ptr %.sroa.0.0564.i3102, i64 %808
  %810 = getelementptr i8, ptr %809, i64 64
  %811 = load ptr, ptr %810, align 8
  %result.i125.i3106 = call ptr %811({ ptr, ptr, ptr, i32 } %806, ptr nocapture nofree noundef nonnull readonly %2) #15
  %812 = call i32 %result.i125.i3106({ ptr, ptr, ptr, i32 } %806, { ptr, ptr, ptr, i32 } %806, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3101, label %813, label %829

813:                                              ; preds = %798
  %814 = load i32, ptr %42, align 8
  %815 = add i32 %814, -1
  %816 = and i32 %815, %812
  %817 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %818 = load ptr, ptr %43, align 8
  %819 = sext i32 %816 to i64
  %820 = shl nsw i64 %819, 5
  %821 = getelementptr i8, ptr %818, i64 %820
  %822 = load ptr, ptr %821, align 8
  %823 = getelementptr i8, ptr %821, i64 8
  %824 = load i160, ptr %823, align 4
  store ptr %.sroa.0.0564.i3102, ptr %821, align 8
  store i64 %801, ptr %823, align 4
  %.sroa_idx157.i3149 = getelementptr i8, ptr %821, i64 16
  store i64 %800, ptr %.sroa_idx157.i3149, align 4
  %.sroa_idx158.i3150 = getelementptr i8, ptr %821, i64 24
  store i32 %.sroa.17.0561.i3105, ptr %.sroa_idx158.i3150, align 4
  %825 = icmp ne ptr %822, @nil_typ
  %826 = icmp ne ptr %822, null
  %.not92.i3151 = and i1 %825, %826
  %extract.i3153 = lshr i160 %824, 64
  %827 = insertelement <2 x i160> poison, i160 %824, i64 0
  %828 = insertelement <2 x i160> %827, i160 %extract.i3153, i64 1
  br i1 %.not92.i3151, label %.cont.cont.i3120, label %868

829:                                              ; preds = %798
  %830 = add i32 %812, 2127912214
  %831 = shl i32 %812, 12
  %832 = add i32 %830, %831
  %833 = ashr i32 %832, 19
  %834 = xor i32 %832, %833
  %835 = xor i32 %834, -949894596
  %836 = add i32 %835, 374761393
  %837 = shl i32 %835, 5
  %838 = add i32 %836, %837
  %839 = add i32 %838, -744332180
  %840 = shl i32 %838, 9
  %841 = xor i32 %839, %840
  %842 = add i32 %841, -42973499
  %843 = shl i32 %841, 3
  %844 = add i32 %842, %843
  %845 = ashr i32 %844, 16
  %846 = xor i32 %844, %845
  %847 = xor i32 %846, -1252372727
  %848 = load i32, ptr %42, align 8
  %849 = add i32 %848, -1
  %850 = and i32 %849, %847
  %851 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %852 = load ptr, ptr %44, align 8
  %853 = sext i32 %850 to i64
  %854 = shl nsw i64 %853, 5
  %855 = getelementptr i8, ptr %852, i64 %854
  %856 = load ptr, ptr %855, align 8
  %857 = getelementptr i8, ptr %855, i64 8
  %858 = load i160, ptr %857, align 4
  store ptr %.sroa.0.0564.i3102, ptr %855, align 8
  store i64 %801, ptr %857, align 4
  %.sroa_idx161.i3110 = getelementptr i8, ptr %855, i64 16
  store i64 %800, ptr %.sroa_idx161.i3110, align 4
  %.sroa_idx162.i3111 = getelementptr i8, ptr %855, i64 24
  store i32 %.sroa.17.0561.i3105, ptr %.sroa_idx162.i3111, align 4
  %859 = icmp ne ptr %856, @nil_typ
  %860 = icmp ne ptr %856, null
  %.not90.i3112 = and i1 %859, %860
  %extract607.i3114 = lshr i160 %858, 64
  %861 = insertelement <2 x i160> poison, i160 %858, i64 0
  %862 = insertelement <2 x i160> %861, i160 %extract607.i3114, i64 1
  br i1 %.not90.i3112, label %.cont.cont.i3120, label %868

.cont.cont.i3120:                                 ; preds = %829, %813
  %vptr.i142.sroa.speculated.i3123 = phi ptr [ %822, %813 ], [ %856, %829 ]
  %.in4282 = phi <2 x i160> [ %828, %813 ], [ %862, %829 ]
  %863 = trunc <2 x i160> %.in4282 to <2 x i64>
  %864 = xor i1 %.070565.i3101, true
  %hash_coef_ptr.i.i143.i3126 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3123, i64 8
  %tbl_size_ptr.i.i144.i3127 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3123, i64 16
  %offset_tbl_ptr.i.i145.i3128 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3123, i64 40
  %hash_coef.i.i146.i3129 = load i64, ptr %hash_coef_ptr.i.i143.i3126, align 4
  %tbl_size.i.i147.i3130 = load i64, ptr %tbl_size_ptr.i.i144.i3127, align 4
  %offset_tbl.i.i148.i3131 = load ptr, ptr %offset_tbl_ptr.i.i145.i3128, align 8
  %product.i.i.i149.i3132 = mul i64 %hash_coef.i.i146.i3129, 4015701072841558310
  %shifted.i.i.i150.i3133 = lshr i64 %product.i.i.i149.i3132, 32
  %xored.i.i.i151.i3134 = xor i64 %shifted.i.i.i150.i3133, %product.i.i.i149.i3132
  %hash.i.i.i152.i3135 = and i64 %xored.i.i.i151.i3134, %tbl_size.i.i147.i3130
  %offset_ptr.i.i153.i3136 = getelementptr i32, ptr %offset_tbl.i.i148.i3131, i64 %hash.i.i.i152.i3135
  %offset.i.i154.i3137 = load i32, ptr %offset_ptr.i.i153.i3136, align 4
  %865 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %866 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %867 = icmp ult i32 %.0566.i3100, 99
  br i1 %867, label %798, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3155

868:                                              ; preds = %829, %813
  %869 = phi ptr [ %22, %829 ], [ %21, %813 ]
  %870 = load i32, ptr %62, align 4
  store i32 %870, ptr %869, align 4
  %871 = add i32 %870, 1
  %872 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %871, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3155

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3155: ; preds = %.cont.cont.i3120, %868
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %._crit_edge.i2503

._crit_edge.i2503:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3155, %.lr.ph.i2488
  %873 = add nuw nsw i32 %.060.i2501, 1
  %874 = icmp slt i32 %873, %779
  br i1 %874, label %.lr.ph.i2488, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2521

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2521: ; preds = %._crit_edge.i2503
  %875 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %876

876:                                              ; preds = %._crit_edge.i2539, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2521
  %.060.i2537 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2521 ], [ %965, %._crit_edge.i2539 ]
  %877 = zext nneg i32 %.060.i2537 to i64
  %878 = shl nuw nsw i64 %877, 5
  %879 = getelementptr i8, ptr %778, i64 %878
  %880 = load ptr, ptr %879, align 8
  %881 = icmp ne ptr %880, @nil_typ
  %882 = icmp ne ptr %880, null
  %.not16.i2538 = and i1 %881, %882
  br i1 %.not16.i2538, label %883, label %._crit_edge.i2539

883:                                              ; preds = %876
  %884 = getelementptr i8, ptr %879, i64 8
  %885 = load <2 x i64>, ptr %884, align 4
  %hash_coef_ptr.i.i18.i2541 = getelementptr i8, ptr %880, i64 8
  %tbl_size_ptr.i.i19.i2542 = getelementptr i8, ptr %880, i64 16
  %offset_tbl_ptr.i.i20.i2543 = getelementptr i8, ptr %880, i64 40
  %886 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i3173 = load i64, ptr %hash_coef_ptr.i.i18.i2541, align 4, !noalias !22
  %tbl_size.i.i100.i3174 = load i64, ptr %tbl_size_ptr.i.i19.i2542, align 4, !noalias !22
  %offset_tbl.i.i101.i3175 = load ptr, ptr %offset_tbl_ptr.i.i20.i2543, align 8, !noalias !22
  %product.i.i.i102.i3176 = mul i64 %hash_coef.i.i99.i3173, 4015701072841558310
  %shifted.i.i.i103.i3177 = lshr i64 %product.i.i.i102.i3176, 32
  %xored.i.i.i104.i3178 = xor i64 %shifted.i.i.i103.i3177, %product.i.i.i102.i3176
  %hash.i.i.i105.i3179 = and i64 %xored.i.i.i104.i3178, %tbl_size.i.i100.i3174
  %offset_ptr.i.i106.i3180 = getelementptr i32, ptr %offset_tbl.i.i101.i3175, i64 %hash.i.i.i105.i3179
  %offset.i.i121.i3181 = load i32, ptr %offset_ptr.i.i106.i3180, align 4, !noalias !266
  %887 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %888 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %890

890:                                              ; preds = %.cont.cont.i3202, %883
  %.0566.i3182 = phi i32 [ 0, %883 ], [ %894, %.cont.cont.i3202 ]
  %.070565.i3183 = phi i1 [ true, %883 ], [ %956, %.cont.cont.i3202 ]
  %.sroa.0.0564.i3184 = phi ptr [ %880, %883 ], [ %vptr.i142.sroa.speculated.i3205, %.cont.cont.i3202 ]
  %.sroa.17.0561.i3187 = phi i32 [ %offset.i.i121.i3181, %883 ], [ %offset.i.i154.i3219, %.cont.cont.i3202 ]
  %891 = phi <2 x i64> [ %885, %883 ], [ %955, %.cont.cont.i3202 ]
  %892 = extractelement <2 x i64> %891, i64 1
  %.sroa.12.0562.i3186 = inttoptr i64 %892 to ptr
  %893 = extractelement <2 x i64> %891, i64 0
  %.sroa.6.0563.i3185 = inttoptr i64 %893 to ptr
  %894 = add nuw nsw i32 %.0566.i3182, 1
  %895 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3184, 0
  %896 = insertvalue { ptr, ptr, ptr, i32 } %895, ptr %.sroa.6.0563.i3185, 1
  %897 = insertvalue { ptr, ptr, ptr, i32 } %896, ptr %.sroa.12.0562.i3186, 2
  %898 = insertvalue { ptr, ptr, ptr, i32 } %897, i32 %.sroa.17.0561.i3187, 3
  %899 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3184)
  %900 = sext i32 %.sroa.17.0561.i3187 to i64
  %901 = getelementptr ptr, ptr %.sroa.0.0564.i3184, i64 %900
  %902 = getelementptr i8, ptr %901, i64 64
  %903 = load ptr, ptr %902, align 8
  %result.i125.i3188 = call ptr %903({ ptr, ptr, ptr, i32 } %898, ptr nocapture nofree noundef nonnull readonly %2) #15
  %904 = call i32 %result.i125.i3188({ ptr, ptr, ptr, i32 } %898, { ptr, ptr, ptr, i32 } %898, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3183, label %905, label %921

905:                                              ; preds = %890
  %906 = load i32, ptr %42, align 8
  %907 = add i32 %906, -1
  %908 = and i32 %907, %904
  %909 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %910 = load ptr, ptr %43, align 8
  %911 = sext i32 %908 to i64
  %912 = shl nsw i64 %911, 5
  %913 = getelementptr i8, ptr %910, i64 %912
  %914 = load ptr, ptr %913, align 8
  %915 = getelementptr i8, ptr %913, i64 8
  %916 = load i160, ptr %915, align 4
  store ptr %.sroa.0.0564.i3184, ptr %913, align 8
  store i64 %893, ptr %915, align 4
  %.sroa_idx157.i3231 = getelementptr i8, ptr %913, i64 16
  store i64 %892, ptr %.sroa_idx157.i3231, align 4
  %.sroa_idx158.i3232 = getelementptr i8, ptr %913, i64 24
  store i32 %.sroa.17.0561.i3187, ptr %.sroa_idx158.i3232, align 4
  %917 = icmp ne ptr %914, @nil_typ
  %918 = icmp ne ptr %914, null
  %.not92.i3233 = and i1 %917, %918
  %extract.i3235 = lshr i160 %916, 64
  %919 = insertelement <2 x i160> poison, i160 %916, i64 0
  %920 = insertelement <2 x i160> %919, i160 %extract.i3235, i64 1
  br i1 %.not92.i3233, label %.cont.cont.i3202, label %960

921:                                              ; preds = %890
  %922 = add i32 %904, 2127912214
  %923 = shl i32 %904, 12
  %924 = add i32 %922, %923
  %925 = ashr i32 %924, 19
  %926 = xor i32 %924, %925
  %927 = xor i32 %926, -949894596
  %928 = add i32 %927, 374761393
  %929 = shl i32 %927, 5
  %930 = add i32 %928, %929
  %931 = add i32 %930, -744332180
  %932 = shl i32 %930, 9
  %933 = xor i32 %931, %932
  %934 = add i32 %933, -42973499
  %935 = shl i32 %933, 3
  %936 = add i32 %934, %935
  %937 = ashr i32 %936, 16
  %938 = xor i32 %936, %937
  %939 = xor i32 %938, -1252372727
  %940 = load i32, ptr %42, align 8
  %941 = add i32 %940, -1
  %942 = and i32 %941, %939
  %943 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %944 = load ptr, ptr %44, align 8
  %945 = sext i32 %942 to i64
  %946 = shl nsw i64 %945, 5
  %947 = getelementptr i8, ptr %944, i64 %946
  %948 = load ptr, ptr %947, align 8
  %949 = getelementptr i8, ptr %947, i64 8
  %950 = load i160, ptr %949, align 4
  store ptr %.sroa.0.0564.i3184, ptr %947, align 8
  store i64 %893, ptr %949, align 4
  %.sroa_idx161.i3192 = getelementptr i8, ptr %947, i64 16
  store i64 %892, ptr %.sroa_idx161.i3192, align 4
  %.sroa_idx162.i3193 = getelementptr i8, ptr %947, i64 24
  store i32 %.sroa.17.0561.i3187, ptr %.sroa_idx162.i3193, align 4
  %951 = icmp ne ptr %948, @nil_typ
  %952 = icmp ne ptr %948, null
  %.not90.i3194 = and i1 %951, %952
  %extract607.i3196 = lshr i160 %950, 64
  %953 = insertelement <2 x i160> poison, i160 %950, i64 0
  %954 = insertelement <2 x i160> %953, i160 %extract607.i3196, i64 1
  br i1 %.not90.i3194, label %.cont.cont.i3202, label %960

.cont.cont.i3202:                                 ; preds = %921, %905
  %vptr.i142.sroa.speculated.i3205 = phi ptr [ %914, %905 ], [ %948, %921 ]
  %.in4283 = phi <2 x i160> [ %920, %905 ], [ %954, %921 ]
  %955 = trunc <2 x i160> %.in4283 to <2 x i64>
  %956 = xor i1 %.070565.i3183, true
  %hash_coef_ptr.i.i143.i3208 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3205, i64 8
  %tbl_size_ptr.i.i144.i3209 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3205, i64 16
  %offset_tbl_ptr.i.i145.i3210 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3205, i64 40
  %hash_coef.i.i146.i3211 = load i64, ptr %hash_coef_ptr.i.i143.i3208, align 4
  %tbl_size.i.i147.i3212 = load i64, ptr %tbl_size_ptr.i.i144.i3209, align 4
  %offset_tbl.i.i148.i3213 = load ptr, ptr %offset_tbl_ptr.i.i145.i3210, align 8
  %product.i.i.i149.i3214 = mul i64 %hash_coef.i.i146.i3211, 4015701072841558310
  %shifted.i.i.i150.i3215 = lshr i64 %product.i.i.i149.i3214, 32
  %xored.i.i.i151.i3216 = xor i64 %shifted.i.i.i150.i3215, %product.i.i.i149.i3214
  %hash.i.i.i152.i3217 = and i64 %xored.i.i.i151.i3216, %tbl_size.i.i147.i3212
  %offset_ptr.i.i153.i3218 = getelementptr i32, ptr %offset_tbl.i.i148.i3213, i64 %hash.i.i.i152.i3217
  %offset.i.i154.i3219 = load i32, ptr %offset_ptr.i.i153.i3218, align 4
  %957 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %958 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %959 = icmp ult i32 %.0566.i3182, 99
  br i1 %959, label %890, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3237

960:                                              ; preds = %921, %905
  %961 = phi ptr [ %20, %921 ], [ %19, %905 ]
  %962 = load i32, ptr %62, align 4
  store i32 %962, ptr %961, align 4
  %963 = add i32 %962, 1
  %964 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %963, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3237

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3237: ; preds = %.cont.cont.i3202, %960
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %._crit_edge.i2539

._crit_edge.i2539:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3237, %876
  %965 = add nuw nsw i32 %.060.i2537, 1
  %966 = icmp slt i32 %965, %779
  br i1 %966, label %876, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557: ; preds = %._crit_edge.i2539, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2521.thread
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %32)
  %hash_coef.i.i99.i1512 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i1513 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1514 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i1515 = mul i64 %hash_coef.i.i99.i1512, 4015701072841558310
  %shifted.i.i.i103.i1516 = lshr i64 %product.i.i.i102.i1515, 32
  %xored.i.i.i104.i1517 = xor i64 %shifted.i.i.i103.i1516, %product.i.i.i102.i1515
  %hash.i.i.i105.i1518 = and i64 %xored.i.i.i104.i1517, %tbl_size.i.i100.i1513
  %offset_ptr.i.i106.i1519 = getelementptr i32, ptr %offset_tbl.i.i101.i1514, i64 %hash.i.i.i105.i1518
  %offset.i.i121.i1520 = load i32, ptr %offset_ptr.i.i106.i1519, align 4, !noalias !269
  %967 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %968 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %969 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %970

970:                                              ; preds = %.cont.cont.i1542, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557
  %.0566.i1522 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557 ], [ %974, %.cont.cont.i1542 ]
  %.070565.i1523 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557 ], [ %1036, %.cont.cont.i1542 ]
  %.sroa.0.0564.i1524 = phi ptr [ %vptr.i142.sroa.speculated.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557 ], [ %vptr.i142.sroa.speculated.i1545, %.cont.cont.i1542 ]
  %.sroa.17.0561.i1527 = phi i32 [ %offset.i.i121.i1520, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557 ], [ %offset.i.i154.i1559, %.cont.cont.i1542 ]
  %971 = phi <2 x i64> [ %763, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2557 ], [ %1035, %.cont.cont.i1542 ]
  %972 = extractelement <2 x i64> %971, i64 1
  %.sroa.12.0562.i1526 = inttoptr i64 %972 to ptr
  %973 = extractelement <2 x i64> %971, i64 0
  %.sroa.6.0563.i1525 = inttoptr i64 %973 to ptr
  %974 = add nuw nsw i32 %.0566.i1522, 1
  %975 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1524, 0
  %976 = insertvalue { ptr, ptr, ptr, i32 } %975, ptr %.sroa.6.0563.i1525, 1
  %977 = insertvalue { ptr, ptr, ptr, i32 } %976, ptr %.sroa.12.0562.i1526, 2
  %978 = insertvalue { ptr, ptr, ptr, i32 } %977, i32 %.sroa.17.0561.i1527, 3
  %979 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1524)
  %980 = sext i32 %.sroa.17.0561.i1527 to i64
  %981 = getelementptr ptr, ptr %.sroa.0.0564.i1524, i64 %980
  %982 = getelementptr i8, ptr %981, i64 64
  %983 = load ptr, ptr %982, align 8
  %result.i125.i1528 = call ptr %983({ ptr, ptr, ptr, i32 } %978, ptr nocapture nofree noundef nonnull readonly %2) #15
  %984 = call i32 %result.i125.i1528({ ptr, ptr, ptr, i32 } %978, { ptr, ptr, ptr, i32 } %978, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1523, label %985, label %1001

985:                                              ; preds = %970
  %986 = load i32, ptr %42, align 8
  %987 = add i32 %986, -1
  %988 = and i32 %987, %984
  %989 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %990 = load ptr, ptr %43, align 8
  %991 = sext i32 %988 to i64
  %992 = shl nsw i64 %991, 5
  %993 = getelementptr i8, ptr %990, i64 %992
  %994 = load ptr, ptr %993, align 8
  %995 = getelementptr i8, ptr %993, i64 8
  %996 = load i160, ptr %995, align 4
  store ptr %.sroa.0.0564.i1524, ptr %993, align 8
  store i64 %973, ptr %995, align 4
  %.sroa_idx157.i1571 = getelementptr i8, ptr %993, i64 16
  store i64 %972, ptr %.sroa_idx157.i1571, align 4
  %.sroa_idx158.i1572 = getelementptr i8, ptr %993, i64 24
  store i32 %.sroa.17.0561.i1527, ptr %.sroa_idx158.i1572, align 4
  %997 = icmp ne ptr %994, @nil_typ
  %998 = icmp ne ptr %994, null
  %.not92.i1573 = and i1 %997, %998
  %extract.i1575 = lshr i160 %996, 64
  %999 = insertelement <2 x i160> poison, i160 %996, i64 0
  %1000 = insertelement <2 x i160> %999, i160 %extract.i1575, i64 1
  br i1 %.not92.i1573, label %.cont.cont.i1542, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1577.thread

1001:                                             ; preds = %970
  %1002 = add i32 %984, 2127912214
  %1003 = shl i32 %984, 12
  %1004 = add i32 %1002, %1003
  %1005 = ashr i32 %1004, 19
  %1006 = xor i32 %1004, %1005
  %1007 = xor i32 %1006, -949894596
  %1008 = add i32 %1007, 374761393
  %1009 = shl i32 %1007, 5
  %1010 = add i32 %1008, %1009
  %1011 = add i32 %1010, -744332180
  %1012 = shl i32 %1010, 9
  %1013 = xor i32 %1011, %1012
  %1014 = add i32 %1013, -42973499
  %1015 = shl i32 %1013, 3
  %1016 = add i32 %1014, %1015
  %1017 = ashr i32 %1016, 16
  %1018 = xor i32 %1016, %1017
  %1019 = xor i32 %1018, -1252372727
  %1020 = load i32, ptr %42, align 8
  %1021 = add i32 %1020, -1
  %1022 = and i32 %1021, %1019
  %1023 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1024 = load ptr, ptr %44, align 8
  %1025 = sext i32 %1022 to i64
  %1026 = shl nsw i64 %1025, 5
  %1027 = getelementptr i8, ptr %1024, i64 %1026
  %1028 = load ptr, ptr %1027, align 8
  %1029 = getelementptr i8, ptr %1027, i64 8
  %1030 = load i160, ptr %1029, align 4
  store ptr %.sroa.0.0564.i1524, ptr %1027, align 8
  store i64 %973, ptr %1029, align 4
  %.sroa_idx161.i1532 = getelementptr i8, ptr %1027, i64 16
  store i64 %972, ptr %.sroa_idx161.i1532, align 4
  %.sroa_idx162.i1533 = getelementptr i8, ptr %1027, i64 24
  store i32 %.sroa.17.0561.i1527, ptr %.sroa_idx162.i1533, align 4
  %1031 = icmp ne ptr %1028, @nil_typ
  %1032 = icmp ne ptr %1028, null
  %.not90.i1534 = and i1 %1031, %1032
  %extract607.i1536 = lshr i160 %1030, 64
  %1033 = insertelement <2 x i160> poison, i160 %1030, i64 0
  %1034 = insertelement <2 x i160> %1033, i160 %extract607.i1536, i64 1
  br i1 %.not90.i1534, label %.cont.cont.i1542, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1577.thread

.cont.cont.i1542:                                 ; preds = %1001, %985
  %vptr.i142.sroa.speculated.i1545 = phi ptr [ %994, %985 ], [ %1028, %1001 ]
  %.in4284 = phi <2 x i160> [ %1000, %985 ], [ %1034, %1001 ]
  %1035 = trunc <2 x i160> %.in4284 to <2 x i64>
  %1036 = xor i1 %.070565.i1523, true
  %hash_coef_ptr.i.i143.i1548 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1545, i64 8
  %tbl_size_ptr.i.i144.i1549 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1545, i64 16
  %offset_tbl_ptr.i.i145.i1550 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1545, i64 40
  %hash_coef.i.i146.i1551 = load i64, ptr %hash_coef_ptr.i.i143.i1548, align 4
  %tbl_size.i.i147.i1552 = load i64, ptr %tbl_size_ptr.i.i144.i1549, align 4
  %offset_tbl.i.i148.i1553 = load ptr, ptr %offset_tbl_ptr.i.i145.i1550, align 8
  %product.i.i.i149.i1554 = mul i64 %hash_coef.i.i146.i1551, 4015701072841558310
  %shifted.i.i.i150.i1555 = lshr i64 %product.i.i.i149.i1554, 32
  %xored.i.i.i151.i1556 = xor i64 %shifted.i.i.i150.i1555, %product.i.i.i149.i1554
  %hash.i.i.i152.i1557 = and i64 %xored.i.i.i151.i1556, %tbl_size.i.i147.i1552
  %offset_ptr.i.i153.i1558 = getelementptr i32, ptr %offset_tbl.i.i148.i1553, i64 %hash.i.i.i152.i1557
  %offset.i.i154.i1559 = load i32, ptr %offset_ptr.i.i153.i1558, align 4
  %1037 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1038 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1039 = icmp ult i32 %.0566.i1522, 99
  br i1 %1039, label %970, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1577

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1577.thread: ; preds = %985, %1001
  %1040 = phi ptr [ %32, %1001 ], [ %31, %985 ]
  %1041 = load i32, ptr %62, align 4
  store i32 %1041, ptr %1040, align 4
  %1042 = add i32 %1041, 1
  %1043 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1042, ptr %62, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1577: ; preds = %.cont.cont.i1542
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  %1044 = icmp eq ptr %vptr.i142.sroa.speculated.i1545, null
  br i1 %1044, label %HashMap_insert_keyK_valueV.exit, label %1045

1045:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1577
  %1046 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1047 = load ptr, ptr %43, align 8
  %1048 = load ptr, ptr %44, align 8
  %1049 = load i32, ptr %42, align 8
  %1050 = shl i32 %1049, 1
  %spec.select.i1593 = call i32 @llvm.smax.i32(i32 %1050, i32 16)
  store i32 %spec.select.i1593, ptr %42, align 8
  %1051 = zext nneg i32 %spec.select.i1593 to i64
  %1052 = shl nuw nsw i64 %1051, 5
  %result.i.i1594 = call noalias ptr @bump_malloc_inner(i64 noundef %1052, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1594, ptr %43, align 8
  %result.i20.i1595 = call noalias ptr @bump_malloc_inner(i64 noundef %1052, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1595, ptr %44, align 8
  store i32 0, ptr %62, align 4
  %1053 = icmp sgt i32 %1049, 0
  br i1 %1053, label %.lr.ph.i2587, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2620.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2620.thread: ; preds = %1045
  %1054 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit

.lr.ph.i2587:                                     ; preds = %1045, %._crit_edge.i2602
  %.060.i2600 = phi i32 [ %1143, %._crit_edge.i2602 ], [ 0, %1045 ]
  %1055 = zext nneg i32 %.060.i2600 to i64
  %1056 = shl nuw nsw i64 %1055, 5
  %1057 = getelementptr i8, ptr %1047, i64 %1056
  %1058 = load ptr, ptr %1057, align 8
  %1059 = icmp ne ptr %1058, @nil_typ
  %1060 = icmp ne ptr %1058, null
  %.not16.i2601 = and i1 %1059, %1060
  br i1 %.not16.i2601, label %1061, label %._crit_edge.i2602

1061:                                             ; preds = %.lr.ph.i2587
  %1062 = getelementptr i8, ptr %1057, i64 8
  %1063 = load <2 x i64>, ptr %1062, align 4
  %hash_coef_ptr.i.i18.i2604 = getelementptr i8, ptr %1058, i64 8
  %tbl_size_ptr.i.i19.i2605 = getelementptr i8, ptr %1058, i64 16
  %offset_tbl_ptr.i.i20.i2606 = getelementptr i8, ptr %1058, i64 40
  %1064 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i3255 = load i64, ptr %hash_coef_ptr.i.i18.i2604, align 4, !noalias !22
  %tbl_size.i.i100.i3256 = load i64, ptr %tbl_size_ptr.i.i19.i2605, align 4, !noalias !22
  %offset_tbl.i.i101.i3257 = load ptr, ptr %offset_tbl_ptr.i.i20.i2606, align 8, !noalias !22
  %product.i.i.i102.i3258 = mul i64 %hash_coef.i.i99.i3255, 4015701072841558310
  %shifted.i.i.i103.i3259 = lshr i64 %product.i.i.i102.i3258, 32
  %xored.i.i.i104.i3260 = xor i64 %shifted.i.i.i103.i3259, %product.i.i.i102.i3258
  %hash.i.i.i105.i3261 = and i64 %xored.i.i.i104.i3260, %tbl_size.i.i100.i3256
  %offset_ptr.i.i106.i3262 = getelementptr i32, ptr %offset_tbl.i.i101.i3257, i64 %hash.i.i.i105.i3261
  %offset.i.i121.i3263 = load i32, ptr %offset_ptr.i.i106.i3262, align 4, !noalias !272
  %1065 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1066 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1068

1068:                                             ; preds = %.cont.cont.i3284, %1061
  %.0566.i3264 = phi i32 [ 0, %1061 ], [ %1072, %.cont.cont.i3284 ]
  %.070565.i3265 = phi i1 [ true, %1061 ], [ %1134, %.cont.cont.i3284 ]
  %.sroa.0.0564.i3266 = phi ptr [ %1058, %1061 ], [ %vptr.i142.sroa.speculated.i3287, %.cont.cont.i3284 ]
  %.sroa.17.0561.i3269 = phi i32 [ %offset.i.i121.i3263, %1061 ], [ %offset.i.i154.i3301, %.cont.cont.i3284 ]
  %1069 = phi <2 x i64> [ %1063, %1061 ], [ %1133, %.cont.cont.i3284 ]
  %1070 = extractelement <2 x i64> %1069, i64 1
  %.sroa.12.0562.i3268 = inttoptr i64 %1070 to ptr
  %1071 = extractelement <2 x i64> %1069, i64 0
  %.sroa.6.0563.i3267 = inttoptr i64 %1071 to ptr
  %1072 = add nuw nsw i32 %.0566.i3264, 1
  %1073 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3266, 0
  %1074 = insertvalue { ptr, ptr, ptr, i32 } %1073, ptr %.sroa.6.0563.i3267, 1
  %1075 = insertvalue { ptr, ptr, ptr, i32 } %1074, ptr %.sroa.12.0562.i3268, 2
  %1076 = insertvalue { ptr, ptr, ptr, i32 } %1075, i32 %.sroa.17.0561.i3269, 3
  %1077 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3266)
  %1078 = sext i32 %.sroa.17.0561.i3269 to i64
  %1079 = getelementptr ptr, ptr %.sroa.0.0564.i3266, i64 %1078
  %1080 = getelementptr i8, ptr %1079, i64 64
  %1081 = load ptr, ptr %1080, align 8
  %result.i125.i3270 = call ptr %1081({ ptr, ptr, ptr, i32 } %1076, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1082 = call i32 %result.i125.i3270({ ptr, ptr, ptr, i32 } %1076, { ptr, ptr, ptr, i32 } %1076, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3265, label %1083, label %1099

1083:                                             ; preds = %1068
  %1084 = load i32, ptr %42, align 8
  %1085 = add i32 %1084, -1
  %1086 = and i32 %1085, %1082
  %1087 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1088 = load ptr, ptr %43, align 8
  %1089 = sext i32 %1086 to i64
  %1090 = shl nsw i64 %1089, 5
  %1091 = getelementptr i8, ptr %1088, i64 %1090
  %1092 = load ptr, ptr %1091, align 8
  %1093 = getelementptr i8, ptr %1091, i64 8
  %1094 = load i160, ptr %1093, align 4
  store ptr %.sroa.0.0564.i3266, ptr %1091, align 8
  store i64 %1071, ptr %1093, align 4
  %.sroa_idx157.i3313 = getelementptr i8, ptr %1091, i64 16
  store i64 %1070, ptr %.sroa_idx157.i3313, align 4
  %.sroa_idx158.i3314 = getelementptr i8, ptr %1091, i64 24
  store i32 %.sroa.17.0561.i3269, ptr %.sroa_idx158.i3314, align 4
  %1095 = icmp ne ptr %1092, @nil_typ
  %1096 = icmp ne ptr %1092, null
  %.not92.i3315 = and i1 %1095, %1096
  %extract.i3317 = lshr i160 %1094, 64
  %1097 = insertelement <2 x i160> poison, i160 %1094, i64 0
  %1098 = insertelement <2 x i160> %1097, i160 %extract.i3317, i64 1
  br i1 %.not92.i3315, label %.cont.cont.i3284, label %1138

1099:                                             ; preds = %1068
  %1100 = add i32 %1082, 2127912214
  %1101 = shl i32 %1082, 12
  %1102 = add i32 %1100, %1101
  %1103 = ashr i32 %1102, 19
  %1104 = xor i32 %1102, %1103
  %1105 = xor i32 %1104, -949894596
  %1106 = add i32 %1105, 374761393
  %1107 = shl i32 %1105, 5
  %1108 = add i32 %1106, %1107
  %1109 = add i32 %1108, -744332180
  %1110 = shl i32 %1108, 9
  %1111 = xor i32 %1109, %1110
  %1112 = add i32 %1111, -42973499
  %1113 = shl i32 %1111, 3
  %1114 = add i32 %1112, %1113
  %1115 = ashr i32 %1114, 16
  %1116 = xor i32 %1114, %1115
  %1117 = xor i32 %1116, -1252372727
  %1118 = load i32, ptr %42, align 8
  %1119 = add i32 %1118, -1
  %1120 = and i32 %1119, %1117
  %1121 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1122 = load ptr, ptr %44, align 8
  %1123 = sext i32 %1120 to i64
  %1124 = shl nsw i64 %1123, 5
  %1125 = getelementptr i8, ptr %1122, i64 %1124
  %1126 = load ptr, ptr %1125, align 8
  %1127 = getelementptr i8, ptr %1125, i64 8
  %1128 = load i160, ptr %1127, align 4
  store ptr %.sroa.0.0564.i3266, ptr %1125, align 8
  store i64 %1071, ptr %1127, align 4
  %.sroa_idx161.i3274 = getelementptr i8, ptr %1125, i64 16
  store i64 %1070, ptr %.sroa_idx161.i3274, align 4
  %.sroa_idx162.i3275 = getelementptr i8, ptr %1125, i64 24
  store i32 %.sroa.17.0561.i3269, ptr %.sroa_idx162.i3275, align 4
  %1129 = icmp ne ptr %1126, @nil_typ
  %1130 = icmp ne ptr %1126, null
  %.not90.i3276 = and i1 %1129, %1130
  %extract607.i3278 = lshr i160 %1128, 64
  %1131 = insertelement <2 x i160> poison, i160 %1128, i64 0
  %1132 = insertelement <2 x i160> %1131, i160 %extract607.i3278, i64 1
  br i1 %.not90.i3276, label %.cont.cont.i3284, label %1138

.cont.cont.i3284:                                 ; preds = %1099, %1083
  %vptr.i142.sroa.speculated.i3287 = phi ptr [ %1092, %1083 ], [ %1126, %1099 ]
  %.in4285 = phi <2 x i160> [ %1098, %1083 ], [ %1132, %1099 ]
  %1133 = trunc <2 x i160> %.in4285 to <2 x i64>
  %1134 = xor i1 %.070565.i3265, true
  %hash_coef_ptr.i.i143.i3290 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3287, i64 8
  %tbl_size_ptr.i.i144.i3291 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3287, i64 16
  %offset_tbl_ptr.i.i145.i3292 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3287, i64 40
  %hash_coef.i.i146.i3293 = load i64, ptr %hash_coef_ptr.i.i143.i3290, align 4
  %tbl_size.i.i147.i3294 = load i64, ptr %tbl_size_ptr.i.i144.i3291, align 4
  %offset_tbl.i.i148.i3295 = load ptr, ptr %offset_tbl_ptr.i.i145.i3292, align 8
  %product.i.i.i149.i3296 = mul i64 %hash_coef.i.i146.i3293, 4015701072841558310
  %shifted.i.i.i150.i3297 = lshr i64 %product.i.i.i149.i3296, 32
  %xored.i.i.i151.i3298 = xor i64 %shifted.i.i.i150.i3297, %product.i.i.i149.i3296
  %hash.i.i.i152.i3299 = and i64 %xored.i.i.i151.i3298, %tbl_size.i.i147.i3294
  %offset_ptr.i.i153.i3300 = getelementptr i32, ptr %offset_tbl.i.i148.i3295, i64 %hash.i.i.i152.i3299
  %offset.i.i154.i3301 = load i32, ptr %offset_ptr.i.i153.i3300, align 4
  %1135 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1136 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1137 = icmp ult i32 %.0566.i3264, 99
  br i1 %1137, label %1068, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3319

1138:                                             ; preds = %1099, %1083
  %1139 = phi ptr [ %18, %1099 ], [ %17, %1083 ]
  %1140 = load i32, ptr %62, align 4
  store i32 %1140, ptr %1139, align 4
  %1141 = add i32 %1140, 1
  %1142 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1141, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3319

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3319: ; preds = %.cont.cont.i3284, %1138
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i2602

._crit_edge.i2602:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3319, %.lr.ph.i2587
  %1143 = add nuw nsw i32 %.060.i2600, 1
  %1144 = icmp slt i32 %1143, %1049
  br i1 %1144, label %.lr.ph.i2587, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2620

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2620: ; preds = %._crit_edge.i2602
  %1145 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1146

1146:                                             ; preds = %._crit_edge.i2638, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2620
  %.060.i2636 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2620 ], [ %1235, %._crit_edge.i2638 ]
  %1147 = zext nneg i32 %.060.i2636 to i64
  %1148 = shl nuw nsw i64 %1147, 5
  %1149 = getelementptr i8, ptr %1048, i64 %1148
  %1150 = load ptr, ptr %1149, align 8
  %1151 = icmp ne ptr %1150, @nil_typ
  %1152 = icmp ne ptr %1150, null
  %.not16.i2637 = and i1 %1151, %1152
  br i1 %.not16.i2637, label %1153, label %._crit_edge.i2638

1153:                                             ; preds = %1146
  %1154 = getelementptr i8, ptr %1149, i64 8
  %1155 = load <2 x i64>, ptr %1154, align 4
  %hash_coef_ptr.i.i18.i2640 = getelementptr i8, ptr %1150, i64 8
  %tbl_size_ptr.i.i19.i2641 = getelementptr i8, ptr %1150, i64 16
  %offset_tbl_ptr.i.i20.i2642 = getelementptr i8, ptr %1150, i64 40
  %1156 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i3337 = load i64, ptr %hash_coef_ptr.i.i18.i2640, align 4, !noalias !22
  %tbl_size.i.i100.i3338 = load i64, ptr %tbl_size_ptr.i.i19.i2641, align 4, !noalias !22
  %offset_tbl.i.i101.i3339 = load ptr, ptr %offset_tbl_ptr.i.i20.i2642, align 8, !noalias !22
  %product.i.i.i102.i3340 = mul i64 %hash_coef.i.i99.i3337, 4015701072841558310
  %shifted.i.i.i103.i3341 = lshr i64 %product.i.i.i102.i3340, 32
  %xored.i.i.i104.i3342 = xor i64 %shifted.i.i.i103.i3341, %product.i.i.i102.i3340
  %hash.i.i.i105.i3343 = and i64 %xored.i.i.i104.i3342, %tbl_size.i.i100.i3338
  %offset_ptr.i.i106.i3344 = getelementptr i32, ptr %offset_tbl.i.i101.i3339, i64 %hash.i.i.i105.i3343
  %offset.i.i121.i3345 = load i32, ptr %offset_ptr.i.i106.i3344, align 4, !noalias !275
  %1157 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1158 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1160

1160:                                             ; preds = %.cont.cont.i3366, %1153
  %.0566.i3346 = phi i32 [ 0, %1153 ], [ %1164, %.cont.cont.i3366 ]
  %.070565.i3347 = phi i1 [ true, %1153 ], [ %1226, %.cont.cont.i3366 ]
  %.sroa.0.0564.i3348 = phi ptr [ %1150, %1153 ], [ %vptr.i142.sroa.speculated.i3369, %.cont.cont.i3366 ]
  %.sroa.17.0561.i3351 = phi i32 [ %offset.i.i121.i3345, %1153 ], [ %offset.i.i154.i3383, %.cont.cont.i3366 ]
  %1161 = phi <2 x i64> [ %1155, %1153 ], [ %1225, %.cont.cont.i3366 ]
  %1162 = extractelement <2 x i64> %1161, i64 1
  %.sroa.12.0562.i3350 = inttoptr i64 %1162 to ptr
  %1163 = extractelement <2 x i64> %1161, i64 0
  %.sroa.6.0563.i3349 = inttoptr i64 %1163 to ptr
  %1164 = add nuw nsw i32 %.0566.i3346, 1
  %1165 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3348, 0
  %1166 = insertvalue { ptr, ptr, ptr, i32 } %1165, ptr %.sroa.6.0563.i3349, 1
  %1167 = insertvalue { ptr, ptr, ptr, i32 } %1166, ptr %.sroa.12.0562.i3350, 2
  %1168 = insertvalue { ptr, ptr, ptr, i32 } %1167, i32 %.sroa.17.0561.i3351, 3
  %1169 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3348)
  %1170 = sext i32 %.sroa.17.0561.i3351 to i64
  %1171 = getelementptr ptr, ptr %.sroa.0.0564.i3348, i64 %1170
  %1172 = getelementptr i8, ptr %1171, i64 64
  %1173 = load ptr, ptr %1172, align 8
  %result.i125.i3352 = call ptr %1173({ ptr, ptr, ptr, i32 } %1168, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1174 = call i32 %result.i125.i3352({ ptr, ptr, ptr, i32 } %1168, { ptr, ptr, ptr, i32 } %1168, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3347, label %1175, label %1191

1175:                                             ; preds = %1160
  %1176 = load i32, ptr %42, align 8
  %1177 = add i32 %1176, -1
  %1178 = and i32 %1177, %1174
  %1179 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1180 = load ptr, ptr %43, align 8
  %1181 = sext i32 %1178 to i64
  %1182 = shl nsw i64 %1181, 5
  %1183 = getelementptr i8, ptr %1180, i64 %1182
  %1184 = load ptr, ptr %1183, align 8
  %1185 = getelementptr i8, ptr %1183, i64 8
  %1186 = load i160, ptr %1185, align 4
  store ptr %.sroa.0.0564.i3348, ptr %1183, align 8
  store i64 %1163, ptr %1185, align 4
  %.sroa_idx157.i3395 = getelementptr i8, ptr %1183, i64 16
  store i64 %1162, ptr %.sroa_idx157.i3395, align 4
  %.sroa_idx158.i3396 = getelementptr i8, ptr %1183, i64 24
  store i32 %.sroa.17.0561.i3351, ptr %.sroa_idx158.i3396, align 4
  %1187 = icmp ne ptr %1184, @nil_typ
  %1188 = icmp ne ptr %1184, null
  %.not92.i3397 = and i1 %1187, %1188
  %extract.i3399 = lshr i160 %1186, 64
  %1189 = insertelement <2 x i160> poison, i160 %1186, i64 0
  %1190 = insertelement <2 x i160> %1189, i160 %extract.i3399, i64 1
  br i1 %.not92.i3397, label %.cont.cont.i3366, label %1230

1191:                                             ; preds = %1160
  %1192 = add i32 %1174, 2127912214
  %1193 = shl i32 %1174, 12
  %1194 = add i32 %1192, %1193
  %1195 = ashr i32 %1194, 19
  %1196 = xor i32 %1194, %1195
  %1197 = xor i32 %1196, -949894596
  %1198 = add i32 %1197, 374761393
  %1199 = shl i32 %1197, 5
  %1200 = add i32 %1198, %1199
  %1201 = add i32 %1200, -744332180
  %1202 = shl i32 %1200, 9
  %1203 = xor i32 %1201, %1202
  %1204 = add i32 %1203, -42973499
  %1205 = shl i32 %1203, 3
  %1206 = add i32 %1204, %1205
  %1207 = ashr i32 %1206, 16
  %1208 = xor i32 %1206, %1207
  %1209 = xor i32 %1208, -1252372727
  %1210 = load i32, ptr %42, align 8
  %1211 = add i32 %1210, -1
  %1212 = and i32 %1211, %1209
  %1213 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1214 = load ptr, ptr %44, align 8
  %1215 = sext i32 %1212 to i64
  %1216 = shl nsw i64 %1215, 5
  %1217 = getelementptr i8, ptr %1214, i64 %1216
  %1218 = load ptr, ptr %1217, align 8
  %1219 = getelementptr i8, ptr %1217, i64 8
  %1220 = load i160, ptr %1219, align 4
  store ptr %.sroa.0.0564.i3348, ptr %1217, align 8
  store i64 %1163, ptr %1219, align 4
  %.sroa_idx161.i3356 = getelementptr i8, ptr %1217, i64 16
  store i64 %1162, ptr %.sroa_idx161.i3356, align 4
  %.sroa_idx162.i3357 = getelementptr i8, ptr %1217, i64 24
  store i32 %.sroa.17.0561.i3351, ptr %.sroa_idx162.i3357, align 4
  %1221 = icmp ne ptr %1218, @nil_typ
  %1222 = icmp ne ptr %1218, null
  %.not90.i3358 = and i1 %1221, %1222
  %extract607.i3360 = lshr i160 %1220, 64
  %1223 = insertelement <2 x i160> poison, i160 %1220, i64 0
  %1224 = insertelement <2 x i160> %1223, i160 %extract607.i3360, i64 1
  br i1 %.not90.i3358, label %.cont.cont.i3366, label %1230

.cont.cont.i3366:                                 ; preds = %1191, %1175
  %vptr.i142.sroa.speculated.i3369 = phi ptr [ %1184, %1175 ], [ %1218, %1191 ]
  %.in4286 = phi <2 x i160> [ %1190, %1175 ], [ %1224, %1191 ]
  %1225 = trunc <2 x i160> %.in4286 to <2 x i64>
  %1226 = xor i1 %.070565.i3347, true
  %hash_coef_ptr.i.i143.i3372 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3369, i64 8
  %tbl_size_ptr.i.i144.i3373 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3369, i64 16
  %offset_tbl_ptr.i.i145.i3374 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3369, i64 40
  %hash_coef.i.i146.i3375 = load i64, ptr %hash_coef_ptr.i.i143.i3372, align 4
  %tbl_size.i.i147.i3376 = load i64, ptr %tbl_size_ptr.i.i144.i3373, align 4
  %offset_tbl.i.i148.i3377 = load ptr, ptr %offset_tbl_ptr.i.i145.i3374, align 8
  %product.i.i.i149.i3378 = mul i64 %hash_coef.i.i146.i3375, 4015701072841558310
  %shifted.i.i.i150.i3379 = lshr i64 %product.i.i.i149.i3378, 32
  %xored.i.i.i151.i3380 = xor i64 %shifted.i.i.i150.i3379, %product.i.i.i149.i3378
  %hash.i.i.i152.i3381 = and i64 %xored.i.i.i151.i3380, %tbl_size.i.i147.i3376
  %offset_ptr.i.i153.i3382 = getelementptr i32, ptr %offset_tbl.i.i148.i3377, i64 %hash.i.i.i152.i3381
  %offset.i.i154.i3383 = load i32, ptr %offset_ptr.i.i153.i3382, align 4
  %1227 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1228 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1229 = icmp ult i32 %.0566.i3346, 99
  br i1 %1229, label %1160, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3401

1230:                                             ; preds = %1191, %1175
  %1231 = phi ptr [ %16, %1191 ], [ %15, %1175 ]
  %1232 = load i32, ptr %62, align 4
  store i32 %1232, ptr %1231, align 4
  %1233 = add i32 %1232, 1
  %1234 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1233, ptr %62, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3401

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3401: ; preds = %.cont.cont.i3366, %1230
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i2638

._crit_edge.i2638:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3401, %1146
  %1235 = add nuw nsw i32 %.060.i2636, 1
  %1236 = icmp slt i32 %1235, %1049
  br i1 %1236, label %1146, label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %._crit_edge.i2638, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2620.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1577.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1440, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1577
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i1 true, ptr %.sroa.0323.sroa.0, align 8
  %.sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.0. = load i8, ptr %.sroa.0323.sroa.0, align 8
  %.sroa.0323.0.insert.ext = zext i8 %.sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.0. to i160
  %1237 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0323.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1238 = load ptr, ptr %result.i428, align 8
  %1239 = load ptr, ptr %51, align 8
  %1240 = call i32 %1239({ ptr, i160 } %70) #7
  %1241 = load i32, ptr %53, align 8
  %1242 = add i32 %1241, -1
  %1243 = and i32 %1242, %1240
  %1244 = load ptr, ptr %54, align 8
  %1245 = load ptr, ptr %46, align 8
  %1246 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1247 = sext i32 %1243 to i64
  %1248 = shl nsw i64 %1247, 5
  %1249 = getelementptr i8, ptr %1244, i64 %1248
  %1250 = load ptr, ptr %1249, align 8
  %1251 = getelementptr i8, ptr %1249, i64 8
  %1252 = icmp ne ptr %1250, @nil_typ
  %1253 = icmp ne ptr %1250, null
  %.not64.i1639 = and i1 %1252, %1253
  br i1 %.not64.i1639, label %1254, label %1351

1254:                                             ; preds = %HashMap_insert_keyK_valueV.exit
  %1255 = load i64, ptr %1251, align 4
  %.sroa_idx.i1641 = getelementptr i8, ptr %1249, i64 16
  %1256 = load i64, ptr %.sroa_idx.i1641, align 4
  %1257 = inttoptr i64 %1255 to ptr
  %1258 = inttoptr i64 %1256 to ptr
  %hash_coef_ptr.i.i66.i1642 = getelementptr i8, ptr %1250, i64 8
  %tbl_size_ptr.i.i67.i1643 = getelementptr i8, ptr %1250, i64 16
  %offset_tbl_ptr.i.i68.i1644 = getelementptr i8, ptr %1250, i64 40
  %hash_coef.i.i69.i1645 = load i64, ptr %hash_coef_ptr.i.i66.i1642, align 4, !noalias !278
  %tbl_size.i.i70.i1646 = load i64, ptr %tbl_size_ptr.i.i67.i1643, align 4, !noalias !278
  %offset_tbl.i.i71.i1647 = load ptr, ptr %offset_tbl_ptr.i.i68.i1644, align 8, !noalias !278
  %product.i.i.i72.i1648 = mul i64 %hash_coef.i.i69.i1645, 4015701072841558310
  %shifted.i.i.i73.i1649 = lshr i64 %product.i.i.i72.i1648, 32
  %xored.i.i.i74.i1650 = xor i64 %shifted.i.i.i73.i1649, %product.i.i.i72.i1648
  %hash.i.i.i75.i1651 = and i64 %xored.i.i.i74.i1650, %tbl_size.i.i70.i1646
  %offset_ptr.i.i76.i1652 = getelementptr i32, ptr %offset_tbl.i.i71.i1647, i64 %hash.i.i.i75.i1651
  %offset.i.i77.i1653 = load i32, ptr %offset_ptr.i.i76.i1652, align 4, !noalias !278
  %1259 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1250, 0
  %1260 = insertvalue { ptr, ptr, ptr, i32 } %1259, ptr %1257, 1
  %1261 = insertvalue { ptr, ptr, ptr, i32 } %1260, ptr %1258, 2
  %1262 = insertvalue { ptr, ptr, ptr, i32 } %1261, i32 %offset.i.i77.i1653, 3
  %1263 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1264 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1250) #34
  %1265 = sext i32 %offset.i.i77.i1653 to i64
  %1266 = getelementptr ptr, ptr %1250, i64 %1265
  %1267 = getelementptr i8, ptr %1266, i64 64
  %1268 = load ptr, ptr %1267, align 8
  %result.i.i1654 = call ptr %1268({ ptr, ptr, ptr, i32 } %1262, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1269 = call i32 %result.i.i1654({ ptr, ptr, ptr, i32 } %1262, { ptr, ptr, ptr, i32 } %1262, ptr nonnull align 8 %2) #7
  %1270 = icmp eq i32 %1269, %1240
  br i1 %1270, label %._crit_edge.i1655, label %1351

._crit_edge.i1655:                                ; preds = %1254
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1272 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1250)
  %1273 = getelementptr i8, ptr %1266, i64 48
  %1274 = load ptr, ptr %1273, align 8
  %result.i79.i1656 = call ptr %1274({ ptr, ptr, ptr, i32 } %1262, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1275 = call { ptr, i160 } %result.i79.i1656({ ptr, ptr, ptr, i32 } %1262, { ptr, ptr, ptr, i32 } %1262, ptr nonnull align 8 %2) #7
  %1276 = load ptr, ptr %52, align 8
  %1277 = call i1 %1276({ ptr, i160 } %1275, { ptr, i160 } %70) #7
  br i1 %1277, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1668, label %1351

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1668: ; preds = %._crit_edge.i1655
  %1278 = load ptr, ptr %result.i428, align 8
  %1279 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1280 = load ptr, ptr %46, align 8
  %1281 = load ptr, ptr %1278, align 8, !alias.scope !281
  %1282 = getelementptr i8, ptr %1281, i64 72
  %1283 = load ptr, ptr %1282, align 8, !alias.scope !281
  %result.i.i.i1660 = call { i64, i64 } %1283(ptr nocapture nofree nonnull readonly %1278) #5, !alias.scope !281
  %1284 = extractvalue { i64, i64 } %result.i.i.i1660, 0
  %1285 = extractvalue { i64, i64 } %result.i.i.i1660, 1
  %1286 = urem i64 20, %1285
  %1287 = icmp eq i64 %1286, 0
  %1288 = sub i64 %1285, %1286
  %1289 = select i1 %1287, i64 0, i64 %1288
  %1290 = add i64 %1284, 20
  %1291 = add i64 %1290, %1289
  %1292 = load ptr, ptr %1280, align 8, !alias.scope !281
  %1293 = getelementptr i8, ptr %1292, i64 72
  %1294 = load ptr, ptr %1293, align 8, !alias.scope !281
  %result.i1.i.i1661 = call { i64, i64 } %1294(ptr nocapture nofree nonnull readonly %1280) #5, !alias.scope !281
  %1295 = extractvalue { i64, i64 } %result.i1.i.i1661, 0
  %1296 = extractvalue { i64, i64 } %result.i1.i.i1661, 1
  %1297 = call i64 @llvm.umax.i64(i64 %1285, i64 %1296)
  %1298 = call i64 @llvm.umax.i64(i64 %1297, i64 8)
  %1299 = urem i64 %1291, %1296
  %1300 = icmp eq i64 %1299, 0
  %1301 = sub i64 %1296, %1299
  %1302 = select i1 %1300, i64 0, i64 %1301
  %1303 = add i64 %1295, %1291
  %1304 = add i64 %1303, %1302
  %1305 = urem i64 %1304, %1298
  %1306 = icmp eq i64 %1305, 0
  %1307 = sub i64 %1298, %1305
  %1308 = select i1 %1306, i64 0, i64 %1307
  %1309 = add i64 %1308, %1304
  %result.i83.i1662 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1309, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1278, ptr %result.i83.i1662, align 8
  %1310 = getelementptr inbounds i8, ptr %result.i83.i1662, i64 8
  store ptr %1280, ptr %1310, align 8
  %1311 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1662)
  %1312 = load ptr, ptr %1278, align 8
  %1313 = getelementptr i8, ptr %1312, i64 72
  %1314 = load ptr, ptr %1313, align 8
  %result.i.i114.i1663 = call { i64, i64 } %1314(ptr nocapture nofree nonnull readonly %1278) #5
  %1315 = extractvalue { i64, i64 } %result.i.i114.i1663, 1
  %1316 = urem i64 20, %1315
  %1317 = icmp eq i64 %1316, 0
  %reass.sub = sub i64 %1315, %1316
  %1318 = add i64 %reass.sub, 20
  %1319 = select i1 %1317, i64 20, i64 %1318
  %1320 = getelementptr i8, ptr %result.i83.i1662, i64 %1319
  %1321 = getelementptr i8, ptr %1312, i64 64
  %1322 = load ptr, ptr %1321, align 8
  call void %1322({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %1278, ptr nocapture nofree writeonly %1320) #12
  %1323 = load ptr, ptr %result.i83.i1662, align 8
  %1324 = load ptr, ptr %1323, align 8
  %1325 = getelementptr i8, ptr %1324, i64 72
  %1326 = load ptr, ptr %1325, align 8
  %result.i.i115.i1665 = call { i64, i64 } %1326(ptr nocapture nofree nonnull readonly %1323) #5
  %1327 = extractvalue { i64, i64 } %result.i.i115.i1665, 0
  %1328 = extractvalue { i64, i64 } %result.i.i115.i1665, 1
  %1329 = urem i64 20, %1328
  %1330 = icmp eq i64 %1329, 0
  %1331 = sub i64 %1328, %1329
  %1332 = select i1 %1330, i64 0, i64 %1331
  %1333 = add i64 %1327, 20
  %1334 = add i64 %1333, %1332
  %1335 = load ptr, ptr %1310, align 8
  %1336 = load ptr, ptr %1335, align 8
  %1337 = getelementptr i8, ptr %1336, i64 72
  %1338 = load ptr, ptr %1337, align 8
  %result.i1.i116.i1666 = call { i64, i64 } %1338(ptr nocapture nofree nonnull readonly %1335) #5
  %1339 = extractvalue { i64, i64 } %result.i1.i116.i1666, 1
  %1340 = urem i64 %1334, %1339
  %1341 = icmp eq i64 %1340, 0
  %1342 = sub i64 %1339, %1340
  %1343 = select i1 %1341, i64 0, i64 %1342
  %1344 = getelementptr i8, ptr %result.i83.i1662, i64 %1334
  %1345 = getelementptr i8, ptr %1344, i64 %1343
  %1346 = getelementptr i8, ptr %1336, i64 64
  %1347 = load ptr, ptr %1346, align 8
  call void %1347({ ptr, i160 } %1237, ptr nocapture nofree nonnull readonly %1335, ptr nocapture nofree writeonly %1345) #12
  %1348 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1349 = getelementptr inbounds i8, ptr %result.i83.i1662, i64 16
  store i32 %1240, ptr %1349, align 8
  store ptr @Entry, ptr %1249, align 8
  %1350 = ptrtoint ptr %result.i83.i1662 to i64
  store i64 %1350, ptr %1251, align 4
  %.sroa_idx28.i1667 = getelementptr i8, ptr %1249, i64 24
  store i32 10, ptr %.sroa_idx28.i1667, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit991

1351:                                             ; preds = %._crit_edge.i1655, %HashMap_insert_keyK_valueV.exit, %1254
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1352 = add i32 %1240, 2127912214
  %1353 = shl i32 %1240, 12
  %1354 = add i32 %1352, %1353
  %1355 = ashr i32 %1354, 19
  %1356 = xor i32 %1354, %1355
  %1357 = xor i32 %1356, -949894596
  %1358 = add i32 %1357, 374761393
  %1359 = shl i32 %1357, 5
  %1360 = add i32 %1358, %1359
  %1361 = add i32 %1360, -744332180
  %1362 = shl i32 %1360, 9
  %1363 = xor i32 %1361, %1362
  %1364 = add i32 %1363, -42973499
  %1365 = shl i32 %1363, 3
  %1366 = add i32 %1364, %1365
  %1367 = ashr i32 %1366, 16
  %1368 = xor i32 %1366, %1367
  %1369 = xor i32 %1368, -1252372727
  %1370 = load i32, ptr %53, align 8
  %1371 = add i32 %1370, -1
  %1372 = and i32 %1371, %1369
  %1373 = load ptr, ptr %55, align 8
  %1374 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1375 = sext i32 %1372 to i64
  %1376 = shl nsw i64 %1375, 5
  %1377 = getelementptr i8, ptr %1373, i64 %1376
  %1378 = load ptr, ptr %1377, align 8
  %1379 = getelementptr i8, ptr %1377, i64 8
  %1380 = icmp ne ptr %1378, @nil_typ
  %1381 = icmp ne ptr %1378, null
  %.not64.i1698 = and i1 %1380, %1381
  br i1 %.not64.i1698, label %1382, label %1480

1382:                                             ; preds = %1351
  %1383 = load i64, ptr %1379, align 4
  %.sroa_idx.i1700 = getelementptr i8, ptr %1377, i64 16
  %1384 = load i64, ptr %.sroa_idx.i1700, align 4
  %1385 = inttoptr i64 %1383 to ptr
  %1386 = inttoptr i64 %1384 to ptr
  %hash_coef_ptr.i.i66.i1701 = getelementptr i8, ptr %1378, i64 8
  %tbl_size_ptr.i.i67.i1702 = getelementptr i8, ptr %1378, i64 16
  %offset_tbl_ptr.i.i68.i1703 = getelementptr i8, ptr %1378, i64 40
  %hash_coef.i.i69.i1704 = load i64, ptr %hash_coef_ptr.i.i66.i1701, align 4, !noalias !284
  %tbl_size.i.i70.i1705 = load i64, ptr %tbl_size_ptr.i.i67.i1702, align 4, !noalias !284
  %offset_tbl.i.i71.i1706 = load ptr, ptr %offset_tbl_ptr.i.i68.i1703, align 8, !noalias !284
  %product.i.i.i72.i1707 = mul i64 %hash_coef.i.i69.i1704, 4015701072841558310
  %shifted.i.i.i73.i1708 = lshr i64 %product.i.i.i72.i1707, 32
  %xored.i.i.i74.i1709 = xor i64 %shifted.i.i.i73.i1708, %product.i.i.i72.i1707
  %hash.i.i.i75.i1710 = and i64 %xored.i.i.i74.i1709, %tbl_size.i.i70.i1705
  %offset_ptr.i.i76.i1711 = getelementptr i32, ptr %offset_tbl.i.i71.i1706, i64 %hash.i.i.i75.i1710
  %offset.i.i77.i1712 = load i32, ptr %offset_ptr.i.i76.i1711, align 4, !noalias !284
  %1387 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1378, 0
  %1388 = insertvalue { ptr, ptr, ptr, i32 } %1387, ptr %1385, 1
  %1389 = insertvalue { ptr, ptr, ptr, i32 } %1388, ptr %1386, 2
  %1390 = insertvalue { ptr, ptr, ptr, i32 } %1389, i32 %offset.i.i77.i1712, 3
  %1391 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1392 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1378) #34
  %1393 = sext i32 %offset.i.i77.i1712 to i64
  %1394 = getelementptr ptr, ptr %1378, i64 %1393
  %1395 = getelementptr i8, ptr %1394, i64 64
  %1396 = load ptr, ptr %1395, align 8
  %result.i.i1713 = call ptr %1396({ ptr, ptr, ptr, i32 } %1390, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1397 = call i32 %result.i.i1713({ ptr, ptr, ptr, i32 } %1390, { ptr, ptr, ptr, i32 } %1390, ptr nonnull align 8 %2) #7
  %1398 = icmp eq i32 %1397, %1240
  br i1 %1398, label %._crit_edge.i1714, label %1480

._crit_edge.i1714:                                ; preds = %1382
  %1399 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1400 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1378)
  %1401 = getelementptr i8, ptr %1394, i64 48
  %1402 = load ptr, ptr %1401, align 8
  %result.i79.i1715 = call ptr %1402({ ptr, ptr, ptr, i32 } %1390, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1403 = call { ptr, i160 } %result.i79.i1715({ ptr, ptr, ptr, i32 } %1390, { ptr, ptr, ptr, i32 } %1390, ptr nonnull align 8 %2) #7
  %1404 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1405 = load ptr, ptr %52, align 8
  %1406 = call i1 %1405({ ptr, i160 } %1403, { ptr, i160 } %70) #7
  br i1 %1406, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1727, label %1480

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1727: ; preds = %._crit_edge.i1714
  %1407 = load ptr, ptr %result.i428, align 8
  %1408 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1409 = load ptr, ptr %46, align 8
  %1410 = load ptr, ptr %1407, align 8, !alias.scope !287
  %1411 = getelementptr i8, ptr %1410, i64 72
  %1412 = load ptr, ptr %1411, align 8, !alias.scope !287
  %result.i.i.i1719 = call { i64, i64 } %1412(ptr nocapture nofree nonnull readonly %1407) #5, !alias.scope !287
  %1413 = extractvalue { i64, i64 } %result.i.i.i1719, 0
  %1414 = extractvalue { i64, i64 } %result.i.i.i1719, 1
  %1415 = urem i64 20, %1414
  %1416 = icmp eq i64 %1415, 0
  %1417 = sub i64 %1414, %1415
  %1418 = select i1 %1416, i64 0, i64 %1417
  %1419 = add i64 %1413, 20
  %1420 = add i64 %1419, %1418
  %1421 = load ptr, ptr %1409, align 8, !alias.scope !287
  %1422 = getelementptr i8, ptr %1421, i64 72
  %1423 = load ptr, ptr %1422, align 8, !alias.scope !287
  %result.i1.i.i1720 = call { i64, i64 } %1423(ptr nocapture nofree nonnull readonly %1409) #5, !alias.scope !287
  %1424 = extractvalue { i64, i64 } %result.i1.i.i1720, 0
  %1425 = extractvalue { i64, i64 } %result.i1.i.i1720, 1
  %1426 = call i64 @llvm.umax.i64(i64 %1414, i64 %1425)
  %1427 = call i64 @llvm.umax.i64(i64 %1426, i64 8)
  %1428 = urem i64 %1420, %1425
  %1429 = icmp eq i64 %1428, 0
  %1430 = sub i64 %1425, %1428
  %1431 = select i1 %1429, i64 0, i64 %1430
  %1432 = add i64 %1424, %1420
  %1433 = add i64 %1432, %1431
  %1434 = urem i64 %1433, %1427
  %1435 = icmp eq i64 %1434, 0
  %1436 = sub i64 %1427, %1434
  %1437 = select i1 %1435, i64 0, i64 %1436
  %1438 = add i64 %1437, %1433
  %result.i83.i1721 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1438, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1407, ptr %result.i83.i1721, align 8
  %1439 = getelementptr inbounds i8, ptr %result.i83.i1721, i64 8
  store ptr %1409, ptr %1439, align 8
  %1440 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1721)
  %1441 = load ptr, ptr %1407, align 8
  %1442 = getelementptr i8, ptr %1441, i64 72
  %1443 = load ptr, ptr %1442, align 8
  %result.i.i114.i1722 = call { i64, i64 } %1443(ptr nocapture nofree nonnull readonly %1407) #5
  %1444 = extractvalue { i64, i64 } %result.i.i114.i1722, 1
  %1445 = urem i64 20, %1444
  %1446 = icmp eq i64 %1445, 0
  %reass.sub4279 = sub i64 %1444, %1445
  %1447 = add i64 %reass.sub4279, 20
  %1448 = select i1 %1446, i64 20, i64 %1447
  %1449 = getelementptr i8, ptr %result.i83.i1721, i64 %1448
  %1450 = getelementptr i8, ptr %1441, i64 64
  %1451 = load ptr, ptr %1450, align 8
  call void %1451({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %1407, ptr nocapture nofree writeonly %1449) #12
  %1452 = load ptr, ptr %result.i83.i1721, align 8
  %1453 = load ptr, ptr %1452, align 8
  %1454 = getelementptr i8, ptr %1453, i64 72
  %1455 = load ptr, ptr %1454, align 8
  %result.i.i115.i1724 = call { i64, i64 } %1455(ptr nocapture nofree nonnull readonly %1452) #5
  %1456 = extractvalue { i64, i64 } %result.i.i115.i1724, 0
  %1457 = extractvalue { i64, i64 } %result.i.i115.i1724, 1
  %1458 = urem i64 20, %1457
  %1459 = icmp eq i64 %1458, 0
  %1460 = sub i64 %1457, %1458
  %1461 = select i1 %1459, i64 0, i64 %1460
  %1462 = add i64 %1456, 20
  %1463 = add i64 %1462, %1461
  %1464 = load ptr, ptr %1439, align 8
  %1465 = load ptr, ptr %1464, align 8
  %1466 = getelementptr i8, ptr %1465, i64 72
  %1467 = load ptr, ptr %1466, align 8
  %result.i1.i116.i1725 = call { i64, i64 } %1467(ptr nocapture nofree nonnull readonly %1464) #5
  %1468 = extractvalue { i64, i64 } %result.i1.i116.i1725, 1
  %1469 = urem i64 %1463, %1468
  %1470 = icmp eq i64 %1469, 0
  %1471 = sub i64 %1468, %1469
  %1472 = select i1 %1470, i64 0, i64 %1471
  %1473 = getelementptr i8, ptr %result.i83.i1721, i64 %1463
  %1474 = getelementptr i8, ptr %1473, i64 %1472
  %1475 = getelementptr i8, ptr %1465, i64 64
  %1476 = load ptr, ptr %1475, align 8
  call void %1476({ ptr, i160 } %1237, ptr nocapture nofree nonnull readonly %1464, ptr nocapture nofree writeonly %1474) #12
  %1477 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1478 = getelementptr inbounds i8, ptr %result.i83.i1721, i64 16
  store i32 %1240, ptr %1478, align 8
  store ptr @Entry, ptr %1377, align 8
  %1479 = ptrtoint ptr %result.i83.i1721 to i64
  store i64 %1479, ptr %1379, align 4
  %.sroa_idx28.i1726 = getelementptr i8, ptr %1377, i64 24
  store i32 10, ptr %.sroa_idx28.i1726, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit991

1480:                                             ; preds = %._crit_edge.i1714, %1351, %1382
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1481 = load i32, ptr %63, align 4
  %1482 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1483 = load i32, ptr %53, align 8
  %.not.i955 = icmp slt i32 %1481, %1483
  br i1 %.not.i955, label %._crit_edge.i957, label %1484

1484:                                             ; preds = %1480
  %1485 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1486 = load ptr, ptr %54, align 8
  %1487 = load ptr, ptr %55, align 8
  %1488 = shl i32 %1483, 1
  %spec.select.i1743 = call i32 @llvm.smax.i32(i32 %1488, i32 16)
  store i32 %spec.select.i1743, ptr %53, align 8
  %1489 = zext nneg i32 %spec.select.i1743 to i64
  %1490 = shl nuw nsw i64 %1489, 5
  %result.i.i1744 = call noalias ptr @bump_malloc_inner(i64 noundef %1490, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1744, ptr %54, align 8
  %result.i20.i1745 = call noalias ptr @bump_malloc_inner(i64 noundef %1490, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1745, ptr %55, align 8
  store i32 0, ptr %63, align 4
  %1491 = icmp sgt i32 %1483, 0
  br i1 %1491, label %.lr.ph.i2659, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2692.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2692.thread: ; preds = %1484
  %1492 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i957

.lr.ph.i2659:                                     ; preds = %1484, %._crit_edge.i2674
  %.060.i2672 = phi i32 [ %1581, %._crit_edge.i2674 ], [ 0, %1484 ]
  %1493 = zext nneg i32 %.060.i2672 to i64
  %1494 = shl nuw nsw i64 %1493, 5
  %1495 = getelementptr i8, ptr %1486, i64 %1494
  %1496 = load ptr, ptr %1495, align 8
  %1497 = icmp ne ptr %1496, @nil_typ
  %1498 = icmp ne ptr %1496, null
  %.not16.i2673 = and i1 %1497, %1498
  br i1 %.not16.i2673, label %1499, label %._crit_edge.i2674

1499:                                             ; preds = %.lr.ph.i2659
  %1500 = getelementptr i8, ptr %1495, i64 8
  %1501 = load <2 x i64>, ptr %1500, align 4
  %hash_coef_ptr.i.i18.i2676 = getelementptr i8, ptr %1496, i64 8
  %tbl_size_ptr.i.i19.i2677 = getelementptr i8, ptr %1496, i64 16
  %offset_tbl_ptr.i.i20.i2678 = getelementptr i8, ptr %1496, i64 40
  %1502 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i3419 = load i64, ptr %hash_coef_ptr.i.i18.i2676, align 4, !noalias !22
  %tbl_size.i.i100.i3420 = load i64, ptr %tbl_size_ptr.i.i19.i2677, align 4, !noalias !22
  %offset_tbl.i.i101.i3421 = load ptr, ptr %offset_tbl_ptr.i.i20.i2678, align 8, !noalias !22
  %product.i.i.i102.i3422 = mul i64 %hash_coef.i.i99.i3419, 4015701072841558310
  %shifted.i.i.i103.i3423 = lshr i64 %product.i.i.i102.i3422, 32
  %xored.i.i.i104.i3424 = xor i64 %shifted.i.i.i103.i3423, %product.i.i.i102.i3422
  %hash.i.i.i105.i3425 = and i64 %xored.i.i.i104.i3424, %tbl_size.i.i100.i3420
  %offset_ptr.i.i106.i3426 = getelementptr i32, ptr %offset_tbl.i.i101.i3421, i64 %hash.i.i.i105.i3425
  %offset.i.i121.i3427 = load i32, ptr %offset_ptr.i.i106.i3426, align 4, !noalias !290
  %1503 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1504 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1505 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1506

1506:                                             ; preds = %.cont.cont.i3448, %1499
  %.0566.i3428 = phi i32 [ 0, %1499 ], [ %1510, %.cont.cont.i3448 ]
  %.070565.i3429 = phi i1 [ true, %1499 ], [ %1572, %.cont.cont.i3448 ]
  %.sroa.0.0564.i3430 = phi ptr [ %1496, %1499 ], [ %vptr.i142.sroa.speculated.i3451, %.cont.cont.i3448 ]
  %.sroa.17.0561.i3433 = phi i32 [ %offset.i.i121.i3427, %1499 ], [ %offset.i.i154.i3465, %.cont.cont.i3448 ]
  %1507 = phi <2 x i64> [ %1501, %1499 ], [ %1571, %.cont.cont.i3448 ]
  %1508 = extractelement <2 x i64> %1507, i64 1
  %.sroa.12.0562.i3432 = inttoptr i64 %1508 to ptr
  %1509 = extractelement <2 x i64> %1507, i64 0
  %.sroa.6.0563.i3431 = inttoptr i64 %1509 to ptr
  %1510 = add nuw nsw i32 %.0566.i3428, 1
  %1511 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3430, 0
  %1512 = insertvalue { ptr, ptr, ptr, i32 } %1511, ptr %.sroa.6.0563.i3431, 1
  %1513 = insertvalue { ptr, ptr, ptr, i32 } %1512, ptr %.sroa.12.0562.i3432, 2
  %1514 = insertvalue { ptr, ptr, ptr, i32 } %1513, i32 %.sroa.17.0561.i3433, 3
  %1515 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3430)
  %1516 = sext i32 %.sroa.17.0561.i3433 to i64
  %1517 = getelementptr ptr, ptr %.sroa.0.0564.i3430, i64 %1516
  %1518 = getelementptr i8, ptr %1517, i64 64
  %1519 = load ptr, ptr %1518, align 8
  %result.i125.i3434 = call ptr %1519({ ptr, ptr, ptr, i32 } %1514, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1520 = call i32 %result.i125.i3434({ ptr, ptr, ptr, i32 } %1514, { ptr, ptr, ptr, i32 } %1514, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3429, label %1521, label %1537

1521:                                             ; preds = %1506
  %1522 = load i32, ptr %53, align 8
  %1523 = add i32 %1522, -1
  %1524 = and i32 %1523, %1520
  %1525 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1526 = load ptr, ptr %54, align 8
  %1527 = sext i32 %1524 to i64
  %1528 = shl nsw i64 %1527, 5
  %1529 = getelementptr i8, ptr %1526, i64 %1528
  %1530 = load ptr, ptr %1529, align 8
  %1531 = getelementptr i8, ptr %1529, i64 8
  %1532 = load i160, ptr %1531, align 4
  store ptr %.sroa.0.0564.i3430, ptr %1529, align 8
  store i64 %1509, ptr %1531, align 4
  %.sroa_idx157.i3477 = getelementptr i8, ptr %1529, i64 16
  store i64 %1508, ptr %.sroa_idx157.i3477, align 4
  %.sroa_idx158.i3478 = getelementptr i8, ptr %1529, i64 24
  store i32 %.sroa.17.0561.i3433, ptr %.sroa_idx158.i3478, align 4
  %1533 = icmp ne ptr %1530, @nil_typ
  %1534 = icmp ne ptr %1530, null
  %.not92.i3479 = and i1 %1533, %1534
  %extract.i3481 = lshr i160 %1532, 64
  %1535 = insertelement <2 x i160> poison, i160 %1532, i64 0
  %1536 = insertelement <2 x i160> %1535, i160 %extract.i3481, i64 1
  br i1 %.not92.i3479, label %.cont.cont.i3448, label %1576

1537:                                             ; preds = %1506
  %1538 = add i32 %1520, 2127912214
  %1539 = shl i32 %1520, 12
  %1540 = add i32 %1538, %1539
  %1541 = ashr i32 %1540, 19
  %1542 = xor i32 %1540, %1541
  %1543 = xor i32 %1542, -949894596
  %1544 = add i32 %1543, 374761393
  %1545 = shl i32 %1543, 5
  %1546 = add i32 %1544, %1545
  %1547 = add i32 %1546, -744332180
  %1548 = shl i32 %1546, 9
  %1549 = xor i32 %1547, %1548
  %1550 = add i32 %1549, -42973499
  %1551 = shl i32 %1549, 3
  %1552 = add i32 %1550, %1551
  %1553 = ashr i32 %1552, 16
  %1554 = xor i32 %1552, %1553
  %1555 = xor i32 %1554, -1252372727
  %1556 = load i32, ptr %53, align 8
  %1557 = add i32 %1556, -1
  %1558 = and i32 %1557, %1555
  %1559 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1560 = load ptr, ptr %55, align 8
  %1561 = sext i32 %1558 to i64
  %1562 = shl nsw i64 %1561, 5
  %1563 = getelementptr i8, ptr %1560, i64 %1562
  %1564 = load ptr, ptr %1563, align 8
  %1565 = getelementptr i8, ptr %1563, i64 8
  %1566 = load i160, ptr %1565, align 4
  store ptr %.sroa.0.0564.i3430, ptr %1563, align 8
  store i64 %1509, ptr %1565, align 4
  %.sroa_idx161.i3438 = getelementptr i8, ptr %1563, i64 16
  store i64 %1508, ptr %.sroa_idx161.i3438, align 4
  %.sroa_idx162.i3439 = getelementptr i8, ptr %1563, i64 24
  store i32 %.sroa.17.0561.i3433, ptr %.sroa_idx162.i3439, align 4
  %1567 = icmp ne ptr %1564, @nil_typ
  %1568 = icmp ne ptr %1564, null
  %.not90.i3440 = and i1 %1567, %1568
  %extract607.i3442 = lshr i160 %1566, 64
  %1569 = insertelement <2 x i160> poison, i160 %1566, i64 0
  %1570 = insertelement <2 x i160> %1569, i160 %extract607.i3442, i64 1
  br i1 %.not90.i3440, label %.cont.cont.i3448, label %1576

.cont.cont.i3448:                                 ; preds = %1537, %1521
  %vptr.i142.sroa.speculated.i3451 = phi ptr [ %1530, %1521 ], [ %1564, %1537 ]
  %.in4287 = phi <2 x i160> [ %1536, %1521 ], [ %1570, %1537 ]
  %1571 = trunc <2 x i160> %.in4287 to <2 x i64>
  %1572 = xor i1 %.070565.i3429, true
  %hash_coef_ptr.i.i143.i3454 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3451, i64 8
  %tbl_size_ptr.i.i144.i3455 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3451, i64 16
  %offset_tbl_ptr.i.i145.i3456 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3451, i64 40
  %hash_coef.i.i146.i3457 = load i64, ptr %hash_coef_ptr.i.i143.i3454, align 4
  %tbl_size.i.i147.i3458 = load i64, ptr %tbl_size_ptr.i.i144.i3455, align 4
  %offset_tbl.i.i148.i3459 = load ptr, ptr %offset_tbl_ptr.i.i145.i3456, align 8
  %product.i.i.i149.i3460 = mul i64 %hash_coef.i.i146.i3457, 4015701072841558310
  %shifted.i.i.i150.i3461 = lshr i64 %product.i.i.i149.i3460, 32
  %xored.i.i.i151.i3462 = xor i64 %shifted.i.i.i150.i3461, %product.i.i.i149.i3460
  %hash.i.i.i152.i3463 = and i64 %xored.i.i.i151.i3462, %tbl_size.i.i147.i3458
  %offset_ptr.i.i153.i3464 = getelementptr i32, ptr %offset_tbl.i.i148.i3459, i64 %hash.i.i.i152.i3463
  %offset.i.i154.i3465 = load i32, ptr %offset_ptr.i.i153.i3464, align 4
  %1573 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1574 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1575 = icmp ult i32 %.0566.i3428, 99
  br i1 %1575, label %1506, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3483

1576:                                             ; preds = %1537, %1521
  %1577 = phi ptr [ %14, %1537 ], [ %13, %1521 ]
  %1578 = load i32, ptr %63, align 4
  store i32 %1578, ptr %1577, align 4
  %1579 = add i32 %1578, 1
  %1580 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1579, ptr %63, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3483

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3483: ; preds = %.cont.cont.i3448, %1576
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i2674

._crit_edge.i2674:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3483, %.lr.ph.i2659
  %1581 = add nuw nsw i32 %.060.i2672, 1
  %1582 = icmp slt i32 %1581, %1483
  br i1 %1582, label %.lr.ph.i2659, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2692

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2692: ; preds = %._crit_edge.i2674
  %1583 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1584

1584:                                             ; preds = %._crit_edge.i2710, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2692
  %.060.i2708 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2692 ], [ %1673, %._crit_edge.i2710 ]
  %1585 = zext nneg i32 %.060.i2708 to i64
  %1586 = shl nuw nsw i64 %1585, 5
  %1587 = getelementptr i8, ptr %1487, i64 %1586
  %1588 = load ptr, ptr %1587, align 8
  %1589 = icmp ne ptr %1588, @nil_typ
  %1590 = icmp ne ptr %1588, null
  %.not16.i2709 = and i1 %1589, %1590
  br i1 %.not16.i2709, label %1591, label %._crit_edge.i2710

1591:                                             ; preds = %1584
  %1592 = getelementptr i8, ptr %1587, i64 8
  %1593 = load <2 x i64>, ptr %1592, align 4
  %hash_coef_ptr.i.i18.i2712 = getelementptr i8, ptr %1588, i64 8
  %tbl_size_ptr.i.i19.i2713 = getelementptr i8, ptr %1588, i64 16
  %offset_tbl_ptr.i.i20.i2714 = getelementptr i8, ptr %1588, i64 40
  %1594 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i3501 = load i64, ptr %hash_coef_ptr.i.i18.i2712, align 4, !noalias !22
  %tbl_size.i.i100.i3502 = load i64, ptr %tbl_size_ptr.i.i19.i2713, align 4, !noalias !22
  %offset_tbl.i.i101.i3503 = load ptr, ptr %offset_tbl_ptr.i.i20.i2714, align 8, !noalias !22
  %product.i.i.i102.i3504 = mul i64 %hash_coef.i.i99.i3501, 4015701072841558310
  %shifted.i.i.i103.i3505 = lshr i64 %product.i.i.i102.i3504, 32
  %xored.i.i.i104.i3506 = xor i64 %shifted.i.i.i103.i3505, %product.i.i.i102.i3504
  %hash.i.i.i105.i3507 = and i64 %xored.i.i.i104.i3506, %tbl_size.i.i100.i3502
  %offset_ptr.i.i106.i3508 = getelementptr i32, ptr %offset_tbl.i.i101.i3503, i64 %hash.i.i.i105.i3507
  %offset.i.i121.i3509 = load i32, ptr %offset_ptr.i.i106.i3508, align 4, !noalias !293
  %1595 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1596 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1597 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1598

1598:                                             ; preds = %.cont.cont.i3530, %1591
  %.0566.i3510 = phi i32 [ 0, %1591 ], [ %1602, %.cont.cont.i3530 ]
  %.070565.i3511 = phi i1 [ true, %1591 ], [ %1664, %.cont.cont.i3530 ]
  %.sroa.0.0564.i3512 = phi ptr [ %1588, %1591 ], [ %vptr.i142.sroa.speculated.i3533, %.cont.cont.i3530 ]
  %.sroa.17.0561.i3515 = phi i32 [ %offset.i.i121.i3509, %1591 ], [ %offset.i.i154.i3547, %.cont.cont.i3530 ]
  %1599 = phi <2 x i64> [ %1593, %1591 ], [ %1663, %.cont.cont.i3530 ]
  %1600 = extractelement <2 x i64> %1599, i64 1
  %.sroa.12.0562.i3514 = inttoptr i64 %1600 to ptr
  %1601 = extractelement <2 x i64> %1599, i64 0
  %.sroa.6.0563.i3513 = inttoptr i64 %1601 to ptr
  %1602 = add nuw nsw i32 %.0566.i3510, 1
  %1603 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3512, 0
  %1604 = insertvalue { ptr, ptr, ptr, i32 } %1603, ptr %.sroa.6.0563.i3513, 1
  %1605 = insertvalue { ptr, ptr, ptr, i32 } %1604, ptr %.sroa.12.0562.i3514, 2
  %1606 = insertvalue { ptr, ptr, ptr, i32 } %1605, i32 %.sroa.17.0561.i3515, 3
  %1607 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3512)
  %1608 = sext i32 %.sroa.17.0561.i3515 to i64
  %1609 = getelementptr ptr, ptr %.sroa.0.0564.i3512, i64 %1608
  %1610 = getelementptr i8, ptr %1609, i64 64
  %1611 = load ptr, ptr %1610, align 8
  %result.i125.i3516 = call ptr %1611({ ptr, ptr, ptr, i32 } %1606, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1612 = call i32 %result.i125.i3516({ ptr, ptr, ptr, i32 } %1606, { ptr, ptr, ptr, i32 } %1606, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3511, label %1613, label %1629

1613:                                             ; preds = %1598
  %1614 = load i32, ptr %53, align 8
  %1615 = add i32 %1614, -1
  %1616 = and i32 %1615, %1612
  %1617 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1618 = load ptr, ptr %54, align 8
  %1619 = sext i32 %1616 to i64
  %1620 = shl nsw i64 %1619, 5
  %1621 = getelementptr i8, ptr %1618, i64 %1620
  %1622 = load ptr, ptr %1621, align 8
  %1623 = getelementptr i8, ptr %1621, i64 8
  %1624 = load i160, ptr %1623, align 4
  store ptr %.sroa.0.0564.i3512, ptr %1621, align 8
  store i64 %1601, ptr %1623, align 4
  %.sroa_idx157.i3559 = getelementptr i8, ptr %1621, i64 16
  store i64 %1600, ptr %.sroa_idx157.i3559, align 4
  %.sroa_idx158.i3560 = getelementptr i8, ptr %1621, i64 24
  store i32 %.sroa.17.0561.i3515, ptr %.sroa_idx158.i3560, align 4
  %1625 = icmp ne ptr %1622, @nil_typ
  %1626 = icmp ne ptr %1622, null
  %.not92.i3561 = and i1 %1625, %1626
  %extract.i3563 = lshr i160 %1624, 64
  %1627 = insertelement <2 x i160> poison, i160 %1624, i64 0
  %1628 = insertelement <2 x i160> %1627, i160 %extract.i3563, i64 1
  br i1 %.not92.i3561, label %.cont.cont.i3530, label %1668

1629:                                             ; preds = %1598
  %1630 = add i32 %1612, 2127912214
  %1631 = shl i32 %1612, 12
  %1632 = add i32 %1630, %1631
  %1633 = ashr i32 %1632, 19
  %1634 = xor i32 %1632, %1633
  %1635 = xor i32 %1634, -949894596
  %1636 = add i32 %1635, 374761393
  %1637 = shl i32 %1635, 5
  %1638 = add i32 %1636, %1637
  %1639 = add i32 %1638, -744332180
  %1640 = shl i32 %1638, 9
  %1641 = xor i32 %1639, %1640
  %1642 = add i32 %1641, -42973499
  %1643 = shl i32 %1641, 3
  %1644 = add i32 %1642, %1643
  %1645 = ashr i32 %1644, 16
  %1646 = xor i32 %1644, %1645
  %1647 = xor i32 %1646, -1252372727
  %1648 = load i32, ptr %53, align 8
  %1649 = add i32 %1648, -1
  %1650 = and i32 %1649, %1647
  %1651 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1652 = load ptr, ptr %55, align 8
  %1653 = sext i32 %1650 to i64
  %1654 = shl nsw i64 %1653, 5
  %1655 = getelementptr i8, ptr %1652, i64 %1654
  %1656 = load ptr, ptr %1655, align 8
  %1657 = getelementptr i8, ptr %1655, i64 8
  %1658 = load i160, ptr %1657, align 4
  store ptr %.sroa.0.0564.i3512, ptr %1655, align 8
  store i64 %1601, ptr %1657, align 4
  %.sroa_idx161.i3520 = getelementptr i8, ptr %1655, i64 16
  store i64 %1600, ptr %.sroa_idx161.i3520, align 4
  %.sroa_idx162.i3521 = getelementptr i8, ptr %1655, i64 24
  store i32 %.sroa.17.0561.i3515, ptr %.sroa_idx162.i3521, align 4
  %1659 = icmp ne ptr %1656, @nil_typ
  %1660 = icmp ne ptr %1656, null
  %.not90.i3522 = and i1 %1659, %1660
  %extract607.i3524 = lshr i160 %1658, 64
  %1661 = insertelement <2 x i160> poison, i160 %1658, i64 0
  %1662 = insertelement <2 x i160> %1661, i160 %extract607.i3524, i64 1
  br i1 %.not90.i3522, label %.cont.cont.i3530, label %1668

.cont.cont.i3530:                                 ; preds = %1629, %1613
  %vptr.i142.sroa.speculated.i3533 = phi ptr [ %1622, %1613 ], [ %1656, %1629 ]
  %.in4288 = phi <2 x i160> [ %1628, %1613 ], [ %1662, %1629 ]
  %1663 = trunc <2 x i160> %.in4288 to <2 x i64>
  %1664 = xor i1 %.070565.i3511, true
  %hash_coef_ptr.i.i143.i3536 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3533, i64 8
  %tbl_size_ptr.i.i144.i3537 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3533, i64 16
  %offset_tbl_ptr.i.i145.i3538 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3533, i64 40
  %hash_coef.i.i146.i3539 = load i64, ptr %hash_coef_ptr.i.i143.i3536, align 4
  %tbl_size.i.i147.i3540 = load i64, ptr %tbl_size_ptr.i.i144.i3537, align 4
  %offset_tbl.i.i148.i3541 = load ptr, ptr %offset_tbl_ptr.i.i145.i3538, align 8
  %product.i.i.i149.i3542 = mul i64 %hash_coef.i.i146.i3539, 4015701072841558310
  %shifted.i.i.i150.i3543 = lshr i64 %product.i.i.i149.i3542, 32
  %xored.i.i.i151.i3544 = xor i64 %shifted.i.i.i150.i3543, %product.i.i.i149.i3542
  %hash.i.i.i152.i3545 = and i64 %xored.i.i.i151.i3544, %tbl_size.i.i147.i3540
  %offset_ptr.i.i153.i3546 = getelementptr i32, ptr %offset_tbl.i.i148.i3541, i64 %hash.i.i.i152.i3545
  %offset.i.i154.i3547 = load i32, ptr %offset_ptr.i.i153.i3546, align 4
  %1665 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1666 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1667 = icmp ult i32 %.0566.i3510, 99
  br i1 %1667, label %1598, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3565

1668:                                             ; preds = %1629, %1613
  %1669 = phi ptr [ %12, %1629 ], [ %11, %1613 ]
  %1670 = load i32, ptr %63, align 4
  store i32 %1670, ptr %1669, align 4
  %1671 = add i32 %1670, 1
  %1672 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1671, ptr %63, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3565

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3565: ; preds = %.cont.cont.i3530, %1668
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %._crit_edge.i2710

._crit_edge.i2710:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3565, %1584
  %1673 = add nuw nsw i32 %.060.i2708, 1
  %1674 = icmp slt i32 %1673, %1483
  br i1 %1674, label %1584, label %._crit_edge.i957

._crit_edge.i957:                                 ; preds = %._crit_edge.i2710, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2692.thread, %1480
  %1675 = load ptr, ptr %1238, align 8
  %1676 = getelementptr i8, ptr %1675, i64 72
  %1677 = load ptr, ptr %1676, align 8
  %result.i.i.i958 = call { i64, i64 } %1677(ptr nocapture nofree nonnull readonly %1238) #5
  %1678 = extractvalue { i64, i64 } %result.i.i.i958, 0
  %1679 = extractvalue { i64, i64 } %result.i.i.i958, 1
  %1680 = urem i64 20, %1679
  %1681 = icmp eq i64 %1680, 0
  %1682 = sub i64 %1679, %1680
  %1683 = select i1 %1681, i64 0, i64 %1682
  %1684 = add i64 %1678, 20
  %1685 = add i64 %1684, %1683
  %1686 = load ptr, ptr %1245, align 8
  %1687 = getelementptr i8, ptr %1686, i64 72
  %1688 = load ptr, ptr %1687, align 8
  %result.i1.i.i959 = call { i64, i64 } %1688(ptr nocapture nofree nonnull readonly %1245) #5
  %1689 = extractvalue { i64, i64 } %result.i1.i.i959, 0
  %1690 = extractvalue { i64, i64 } %result.i1.i.i959, 1
  %1691 = call i64 @llvm.umax.i64(i64 %1679, i64 %1690)
  %1692 = call i64 @llvm.umax.i64(i64 %1691, i64 8)
  %1693 = urem i64 %1685, %1690
  %1694 = icmp eq i64 %1693, 0
  %1695 = sub i64 %1690, %1693
  %1696 = select i1 %1694, i64 0, i64 %1695
  %1697 = add i64 %1689, %1685
  %1698 = add i64 %1697, %1696
  %1699 = urem i64 %1698, %1692
  %1700 = icmp eq i64 %1699, 0
  %1701 = sub i64 %1692, %1699
  %1702 = select i1 %1700, i64 0, i64 %1701
  %1703 = add i64 %1702, %1698
  %result.i83.i960 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1703, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1238, ptr %result.i83.i960, align 8
  %1704 = getelementptr inbounds i8, ptr %result.i83.i960, i64 8
  store ptr %1245, ptr %1704, align 8
  %1705 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i960)
  %1706 = load ptr, ptr %1238, align 8
  %1707 = getelementptr i8, ptr %1706, i64 72
  %1708 = load ptr, ptr %1707, align 8
  %result.i.i179.i961 = call { i64, i64 } %1708(ptr nocapture nofree nonnull readonly %1238) #5
  %1709 = extractvalue { i64, i64 } %result.i.i179.i961, 1
  %1710 = urem i64 20, %1709
  %1711 = icmp eq i64 %1710, 0
  %reass.sub4278 = sub i64 %1709, %1710
  %1712 = add i64 %reass.sub4278, 20
  %1713 = select i1 %1711, i64 20, i64 %1712
  %1714 = getelementptr i8, ptr %result.i83.i960, i64 %1713
  %1715 = getelementptr i8, ptr %1706, i64 64
  %1716 = load ptr, ptr %1715, align 8
  call void %1716({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %1238, ptr nocapture nofree writeonly %1714) #12
  %1717 = load ptr, ptr %result.i83.i960, align 8
  %1718 = load ptr, ptr %1717, align 8
  %1719 = getelementptr i8, ptr %1718, i64 72
  %1720 = load ptr, ptr %1719, align 8
  %result.i.i180.i963 = call { i64, i64 } %1720(ptr nocapture nofree nonnull readonly %1717) #5
  %1721 = extractvalue { i64, i64 } %result.i.i180.i963, 0
  %1722 = extractvalue { i64, i64 } %result.i.i180.i963, 1
  %1723 = urem i64 20, %1722
  %1724 = icmp eq i64 %1723, 0
  %1725 = sub i64 %1722, %1723
  %1726 = select i1 %1724, i64 0, i64 %1725
  %1727 = add i64 %1721, 20
  %1728 = add i64 %1727, %1726
  %1729 = load ptr, ptr %1704, align 8
  %1730 = load ptr, ptr %1729, align 8
  %1731 = getelementptr i8, ptr %1730, i64 72
  %1732 = load ptr, ptr %1731, align 8
  %result.i1.i181.i964 = call { i64, i64 } %1732(ptr nocapture nofree nonnull readonly %1729) #5
  %1733 = extractvalue { i64, i64 } %result.i1.i181.i964, 1
  %1734 = urem i64 %1728, %1733
  %1735 = icmp eq i64 %1734, 0
  %1736 = sub i64 %1733, %1734
  %1737 = select i1 %1735, i64 0, i64 %1736
  %1738 = getelementptr i8, ptr %result.i83.i960, i64 %1728
  %1739 = getelementptr i8, ptr %1738, i64 %1737
  %1740 = getelementptr i8, ptr %1730, i64 64
  %1741 = load ptr, ptr %1740, align 8
  call void %1741({ ptr, i160 } %1237, ptr nocapture nofree nonnull readonly %1729, ptr nocapture nofree writeonly %1739) #12
  %1742 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1743 = getelementptr inbounds i8, ptr %result.i83.i960, i64 16
  store i32 %1240, ptr %1743, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %30)
  %1744 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1746 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1747

1747:                                             ; preds = %.cont.cont.i1796, %._crit_edge.i957
  %.0566.i1776 = phi i32 [ 0, %._crit_edge.i957 ], [ %1748, %.cont.cont.i1796 ]
  %.070565.i1777 = phi i1 [ true, %._crit_edge.i957 ], [ %1814, %.cont.cont.i1796 ]
  %.sroa.0.0564.i1778 = phi ptr [ @Entry, %._crit_edge.i957 ], [ %vptr.i142.sroa.speculated.i1799, %.cont.cont.i1796 ]
  %.sroa.6.0563.i1779 = phi ptr [ %result.i83.i960, %._crit_edge.i957 ], [ %spec.select539.i1801, %.cont.cont.i1796 ]
  %.sroa.12.0562.i1780 = phi ptr [ undef, %._crit_edge.i957 ], [ %spec.select.i1800, %.cont.cont.i1796 ]
  %.sroa.17.0561.i1781 = phi i32 [ 10, %._crit_edge.i957 ], [ %offset.i.i154.i1813, %.cont.cont.i1796 ]
  %1748 = add nuw nsw i32 %.0566.i1776, 1
  %1749 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1778, 0
  %1750 = insertvalue { ptr, ptr, ptr, i32 } %1749, ptr %.sroa.6.0563.i1779, 1
  %1751 = insertvalue { ptr, ptr, ptr, i32 } %1750, ptr %.sroa.12.0562.i1780, 2
  %1752 = insertvalue { ptr, ptr, ptr, i32 } %1751, i32 %.sroa.17.0561.i1781, 3
  %1753 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1778)
  %1754 = sext i32 %.sroa.17.0561.i1781 to i64
  %1755 = getelementptr ptr, ptr %.sroa.0.0564.i1778, i64 %1754
  %1756 = getelementptr i8, ptr %1755, i64 64
  %1757 = load ptr, ptr %1756, align 8
  %result.i125.i1782 = call ptr %1757({ ptr, ptr, ptr, i32 } %1752, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1758 = call i32 %result.i125.i1782({ ptr, ptr, ptr, i32 } %1752, { ptr, ptr, ptr, i32 } %1752, ptr nonnull align 8 %2) #7
  %1759 = ptrtoint ptr %.sroa.6.0563.i1779 to i64
  %1760 = ptrtoint ptr %.sroa.12.0562.i1780 to i64
  br i1 %.070565.i1777, label %1761, label %1777

1761:                                             ; preds = %1747
  %1762 = load i32, ptr %53, align 8
  %1763 = add i32 %1762, -1
  %1764 = and i32 %1763, %1758
  %1765 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1766 = load ptr, ptr %54, align 8
  %1767 = sext i32 %1764 to i64
  %1768 = shl nsw i64 %1767, 5
  %1769 = getelementptr i8, ptr %1766, i64 %1768
  %1770 = load ptr, ptr %1769, align 8
  %1771 = getelementptr i8, ptr %1769, i64 8
  %1772 = load i160, ptr %1771, align 4
  store ptr %.sroa.0.0564.i1778, ptr %1769, align 8
  store i64 %1759, ptr %1771, align 4
  %.sroa_idx157.i1825 = getelementptr i8, ptr %1769, i64 16
  store i64 %1760, ptr %.sroa_idx157.i1825, align 4
  %.sroa_idx158.i1826 = getelementptr i8, ptr %1769, i64 24
  store i32 %.sroa.17.0561.i1781, ptr %.sroa_idx158.i1826, align 4
  %1773 = icmp ne ptr %1770, @nil_typ
  %1774 = icmp ne ptr %1770, null
  %.not92.i1827 = and i1 %1773, %1774
  %extract.i1829 = lshr i160 %1772, 64
  %1775 = insertelement <2 x i160> poison, i160 %1772, i64 0
  %1776 = insertelement <2 x i160> %1775, i160 %extract.i1829, i64 1
  br i1 %.not92.i1827, label %.cont.cont.i1796, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1831.thread

1777:                                             ; preds = %1747
  %1778 = add i32 %1758, 2127912214
  %1779 = shl i32 %1758, 12
  %1780 = add i32 %1778, %1779
  %1781 = ashr i32 %1780, 19
  %1782 = xor i32 %1780, %1781
  %1783 = xor i32 %1782, -949894596
  %1784 = add i32 %1783, 374761393
  %1785 = shl i32 %1783, 5
  %1786 = add i32 %1784, %1785
  %1787 = add i32 %1786, -744332180
  %1788 = shl i32 %1786, 9
  %1789 = xor i32 %1787, %1788
  %1790 = add i32 %1789, -42973499
  %1791 = shl i32 %1789, 3
  %1792 = add i32 %1790, %1791
  %1793 = ashr i32 %1792, 16
  %1794 = xor i32 %1792, %1793
  %1795 = xor i32 %1794, -1252372727
  %1796 = load i32, ptr %53, align 8
  %1797 = add i32 %1796, -1
  %1798 = and i32 %1797, %1795
  %1799 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1800 = load ptr, ptr %55, align 8
  %1801 = sext i32 %1798 to i64
  %1802 = shl nsw i64 %1801, 5
  %1803 = getelementptr i8, ptr %1800, i64 %1802
  %1804 = load ptr, ptr %1803, align 8
  %1805 = getelementptr i8, ptr %1803, i64 8
  %1806 = load i160, ptr %1805, align 4
  store ptr %.sroa.0.0564.i1778, ptr %1803, align 8
  store i64 %1759, ptr %1805, align 4
  %.sroa_idx161.i1786 = getelementptr i8, ptr %1803, i64 16
  store i64 %1760, ptr %.sroa_idx161.i1786, align 4
  %.sroa_idx162.i1787 = getelementptr i8, ptr %1803, i64 24
  store i32 %.sroa.17.0561.i1781, ptr %.sroa_idx162.i1787, align 4
  %1807 = icmp ne ptr %1804, @nil_typ
  %1808 = icmp ne ptr %1804, null
  %.not90.i1788 = and i1 %1807, %1808
  %extract607.i1790 = lshr i160 %1806, 64
  %1809 = insertelement <2 x i160> poison, i160 %1806, i64 0
  %1810 = insertelement <2 x i160> %1809, i160 %extract607.i1790, i64 1
  br i1 %.not90.i1788, label %.cont.cont.i1796, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1831.thread

.cont.cont.i1796:                                 ; preds = %1777, %1761
  %vptr.i142.sroa.speculated.i1799 = phi ptr [ %1770, %1761 ], [ %1804, %1777 ]
  %.in4289 = phi <2 x i160> [ %1776, %1761 ], [ %1810, %1777 ]
  %1811 = trunc <2 x i160> %.in4289 to <2 x i64>
  %1812 = extractelement <2 x i64> %1811, i64 1
  %spec.select.i1800 = inttoptr i64 %1812 to ptr
  %1813 = extractelement <2 x i64> %1811, i64 0
  %spec.select539.i1801 = inttoptr i64 %1813 to ptr
  %1814 = xor i1 %.070565.i1777, true
  %hash_coef_ptr.i.i143.i1802 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1799, i64 8
  %tbl_size_ptr.i.i144.i1803 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1799, i64 16
  %offset_tbl_ptr.i.i145.i1804 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1799, i64 40
  %hash_coef.i.i146.i1805 = load i64, ptr %hash_coef_ptr.i.i143.i1802, align 4
  %tbl_size.i.i147.i1806 = load i64, ptr %tbl_size_ptr.i.i144.i1803, align 4
  %offset_tbl.i.i148.i1807 = load ptr, ptr %offset_tbl_ptr.i.i145.i1804, align 8
  %product.i.i.i149.i1808 = mul i64 %hash_coef.i.i146.i1805, 4015701072841558310
  %shifted.i.i.i150.i1809 = lshr i64 %product.i.i.i149.i1808, 32
  %xored.i.i.i151.i1810 = xor i64 %shifted.i.i.i150.i1809, %product.i.i.i149.i1808
  %hash.i.i.i152.i1811 = and i64 %xored.i.i.i151.i1810, %tbl_size.i.i147.i1806
  %offset_ptr.i.i153.i1812 = getelementptr i32, ptr %offset_tbl.i.i148.i1807, i64 %hash.i.i.i152.i1811
  %offset.i.i154.i1813 = load i32, ptr %offset_ptr.i.i153.i1812, align 4
  %1815 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1816 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1817 = icmp ult i32 %.0566.i1776, 99
  br i1 %1817, label %1747, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1831

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1831.thread: ; preds = %1761, %1777
  %1818 = phi ptr [ %30, %1777 ], [ %29, %1761 ]
  %1819 = load i32, ptr %63, align 4
  store i32 %1819, ptr %1818, align 4
  %1820 = add i32 %1819, 1
  %1821 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1820, ptr %63, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  br label %HashMap_insert_keyK_valueV.exit991

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1831: ; preds = %.cont.cont.i1796
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  %1822 = icmp eq ptr %vptr.i142.sroa.speculated.i1799, null
  br i1 %1822, label %HashMap_insert_keyK_valueV.exit991, label %1823

1823:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1831
  %1824 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1825 = load ptr, ptr %54, align 8
  %1826 = load ptr, ptr %55, align 8
  %1827 = load i32, ptr %53, align 8
  %1828 = shl i32 %1827, 1
  %spec.select.i1847 = call i32 @llvm.smax.i32(i32 %1828, i32 16)
  store i32 %spec.select.i1847, ptr %53, align 8
  %1829 = zext nneg i32 %spec.select.i1847 to i64
  %1830 = shl nuw nsw i64 %1829, 5
  %result.i.i1848 = call noalias ptr @bump_malloc_inner(i64 noundef %1830, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1848, ptr %54, align 8
  %result.i20.i1849 = call noalias ptr @bump_malloc_inner(i64 noundef %1830, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1849, ptr %55, align 8
  store i32 0, ptr %63, align 4
  %1831 = icmp sgt i32 %1827, 0
  br i1 %1831, label %.lr.ph.i2758, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827

.lr.ph.i2758:                                     ; preds = %1823, %._crit_edge.i2773
  %.060.i2771 = phi i32 [ %1920, %._crit_edge.i2773 ], [ 0, %1823 ]
  %1832 = zext nneg i32 %.060.i2771 to i64
  %1833 = shl nuw nsw i64 %1832, 5
  %1834 = getelementptr i8, ptr %1825, i64 %1833
  %1835 = load ptr, ptr %1834, align 8
  %1836 = icmp ne ptr %1835, @nil_typ
  %1837 = icmp ne ptr %1835, null
  %.not16.i2772 = and i1 %1836, %1837
  br i1 %.not16.i2772, label %1838, label %._crit_edge.i2773

1838:                                             ; preds = %.lr.ph.i2758
  %1839 = getelementptr i8, ptr %1834, i64 8
  %1840 = load <2 x i64>, ptr %1839, align 4
  %hash_coef_ptr.i.i18.i2775 = getelementptr i8, ptr %1835, i64 8
  %tbl_size_ptr.i.i19.i2776 = getelementptr i8, ptr %1835, i64 16
  %offset_tbl_ptr.i.i20.i2777 = getelementptr i8, ptr %1835, i64 40
  %1841 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i3583 = load i64, ptr %hash_coef_ptr.i.i18.i2775, align 4, !noalias !22
  %tbl_size.i.i100.i3584 = load i64, ptr %tbl_size_ptr.i.i19.i2776, align 4, !noalias !22
  %offset_tbl.i.i101.i3585 = load ptr, ptr %offset_tbl_ptr.i.i20.i2777, align 8, !noalias !22
  %product.i.i.i102.i3586 = mul i64 %hash_coef.i.i99.i3583, 4015701072841558310
  %shifted.i.i.i103.i3587 = lshr i64 %product.i.i.i102.i3586, 32
  %xored.i.i.i104.i3588 = xor i64 %shifted.i.i.i103.i3587, %product.i.i.i102.i3586
  %hash.i.i.i105.i3589 = and i64 %xored.i.i.i104.i3588, %tbl_size.i.i100.i3584
  %offset_ptr.i.i106.i3590 = getelementptr i32, ptr %offset_tbl.i.i101.i3585, i64 %hash.i.i.i105.i3589
  %offset.i.i121.i3591 = load i32, ptr %offset_ptr.i.i106.i3590, align 4, !noalias !296
  %1842 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1843 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1844 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1845

1845:                                             ; preds = %.cont.cont.i3612, %1838
  %.0566.i3592 = phi i32 [ 0, %1838 ], [ %1849, %.cont.cont.i3612 ]
  %.070565.i3593 = phi i1 [ true, %1838 ], [ %1911, %.cont.cont.i3612 ]
  %.sroa.0.0564.i3594 = phi ptr [ %1835, %1838 ], [ %vptr.i142.sroa.speculated.i3615, %.cont.cont.i3612 ]
  %.sroa.17.0561.i3597 = phi i32 [ %offset.i.i121.i3591, %1838 ], [ %offset.i.i154.i3629, %.cont.cont.i3612 ]
  %1846 = phi <2 x i64> [ %1840, %1838 ], [ %1910, %.cont.cont.i3612 ]
  %1847 = extractelement <2 x i64> %1846, i64 1
  %.sroa.12.0562.i3596 = inttoptr i64 %1847 to ptr
  %1848 = extractelement <2 x i64> %1846, i64 0
  %.sroa.6.0563.i3595 = inttoptr i64 %1848 to ptr
  %1849 = add nuw nsw i32 %.0566.i3592, 1
  %1850 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3594, 0
  %1851 = insertvalue { ptr, ptr, ptr, i32 } %1850, ptr %.sroa.6.0563.i3595, 1
  %1852 = insertvalue { ptr, ptr, ptr, i32 } %1851, ptr %.sroa.12.0562.i3596, 2
  %1853 = insertvalue { ptr, ptr, ptr, i32 } %1852, i32 %.sroa.17.0561.i3597, 3
  %1854 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3594)
  %1855 = sext i32 %.sroa.17.0561.i3597 to i64
  %1856 = getelementptr ptr, ptr %.sroa.0.0564.i3594, i64 %1855
  %1857 = getelementptr i8, ptr %1856, i64 64
  %1858 = load ptr, ptr %1857, align 8
  %result.i125.i3598 = call ptr %1858({ ptr, ptr, ptr, i32 } %1853, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1859 = call i32 %result.i125.i3598({ ptr, ptr, ptr, i32 } %1853, { ptr, ptr, ptr, i32 } %1853, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3593, label %1860, label %1876

1860:                                             ; preds = %1845
  %1861 = load i32, ptr %53, align 8
  %1862 = add i32 %1861, -1
  %1863 = and i32 %1862, %1859
  %1864 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1865 = load ptr, ptr %54, align 8
  %1866 = sext i32 %1863 to i64
  %1867 = shl nsw i64 %1866, 5
  %1868 = getelementptr i8, ptr %1865, i64 %1867
  %1869 = load ptr, ptr %1868, align 8
  %1870 = getelementptr i8, ptr %1868, i64 8
  %1871 = load i160, ptr %1870, align 4
  store ptr %.sroa.0.0564.i3594, ptr %1868, align 8
  store i64 %1848, ptr %1870, align 4
  %.sroa_idx157.i3641 = getelementptr i8, ptr %1868, i64 16
  store i64 %1847, ptr %.sroa_idx157.i3641, align 4
  %.sroa_idx158.i3642 = getelementptr i8, ptr %1868, i64 24
  store i32 %.sroa.17.0561.i3597, ptr %.sroa_idx158.i3642, align 4
  %1872 = icmp ne ptr %1869, @nil_typ
  %1873 = icmp ne ptr %1869, null
  %.not92.i3643 = and i1 %1872, %1873
  %extract.i3645 = lshr i160 %1871, 64
  %1874 = insertelement <2 x i160> poison, i160 %1871, i64 0
  %1875 = insertelement <2 x i160> %1874, i160 %extract.i3645, i64 1
  br i1 %.not92.i3643, label %.cont.cont.i3612, label %1915

1876:                                             ; preds = %1845
  %1877 = add i32 %1859, 2127912214
  %1878 = shl i32 %1859, 12
  %1879 = add i32 %1877, %1878
  %1880 = ashr i32 %1879, 19
  %1881 = xor i32 %1879, %1880
  %1882 = xor i32 %1881, -949894596
  %1883 = add i32 %1882, 374761393
  %1884 = shl i32 %1882, 5
  %1885 = add i32 %1883, %1884
  %1886 = add i32 %1885, -744332180
  %1887 = shl i32 %1885, 9
  %1888 = xor i32 %1886, %1887
  %1889 = add i32 %1888, -42973499
  %1890 = shl i32 %1888, 3
  %1891 = add i32 %1889, %1890
  %1892 = ashr i32 %1891, 16
  %1893 = xor i32 %1891, %1892
  %1894 = xor i32 %1893, -1252372727
  %1895 = load i32, ptr %53, align 8
  %1896 = add i32 %1895, -1
  %1897 = and i32 %1896, %1894
  %1898 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1899 = load ptr, ptr %55, align 8
  %1900 = sext i32 %1897 to i64
  %1901 = shl nsw i64 %1900, 5
  %1902 = getelementptr i8, ptr %1899, i64 %1901
  %1903 = load ptr, ptr %1902, align 8
  %1904 = getelementptr i8, ptr %1902, i64 8
  %1905 = load i160, ptr %1904, align 4
  store ptr %.sroa.0.0564.i3594, ptr %1902, align 8
  store i64 %1848, ptr %1904, align 4
  %.sroa_idx161.i3602 = getelementptr i8, ptr %1902, i64 16
  store i64 %1847, ptr %.sroa_idx161.i3602, align 4
  %.sroa_idx162.i3603 = getelementptr i8, ptr %1902, i64 24
  store i32 %.sroa.17.0561.i3597, ptr %.sroa_idx162.i3603, align 4
  %1906 = icmp ne ptr %1903, @nil_typ
  %1907 = icmp ne ptr %1903, null
  %.not90.i3604 = and i1 %1906, %1907
  %extract607.i3606 = lshr i160 %1905, 64
  %1908 = insertelement <2 x i160> poison, i160 %1905, i64 0
  %1909 = insertelement <2 x i160> %1908, i160 %extract607.i3606, i64 1
  br i1 %.not90.i3604, label %.cont.cont.i3612, label %1915

.cont.cont.i3612:                                 ; preds = %1876, %1860
  %vptr.i142.sroa.speculated.i3615 = phi ptr [ %1869, %1860 ], [ %1903, %1876 ]
  %.in4290 = phi <2 x i160> [ %1875, %1860 ], [ %1909, %1876 ]
  %1910 = trunc <2 x i160> %.in4290 to <2 x i64>
  %1911 = xor i1 %.070565.i3593, true
  %hash_coef_ptr.i.i143.i3618 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3615, i64 8
  %tbl_size_ptr.i.i144.i3619 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3615, i64 16
  %offset_tbl_ptr.i.i145.i3620 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3615, i64 40
  %hash_coef.i.i146.i3621 = load i64, ptr %hash_coef_ptr.i.i143.i3618, align 4
  %tbl_size.i.i147.i3622 = load i64, ptr %tbl_size_ptr.i.i144.i3619, align 4
  %offset_tbl.i.i148.i3623 = load ptr, ptr %offset_tbl_ptr.i.i145.i3620, align 8
  %product.i.i.i149.i3624 = mul i64 %hash_coef.i.i146.i3621, 4015701072841558310
  %shifted.i.i.i150.i3625 = lshr i64 %product.i.i.i149.i3624, 32
  %xored.i.i.i151.i3626 = xor i64 %shifted.i.i.i150.i3625, %product.i.i.i149.i3624
  %hash.i.i.i152.i3627 = and i64 %xored.i.i.i151.i3626, %tbl_size.i.i147.i3622
  %offset_ptr.i.i153.i3628 = getelementptr i32, ptr %offset_tbl.i.i148.i3623, i64 %hash.i.i.i152.i3627
  %offset.i.i154.i3629 = load i32, ptr %offset_ptr.i.i153.i3628, align 4
  %1912 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1913 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1914 = icmp ult i32 %.0566.i3592, 99
  br i1 %1914, label %1845, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3647

1915:                                             ; preds = %1876, %1860
  %1916 = phi ptr [ %10, %1876 ], [ %9, %1860 ]
  %1917 = load i32, ptr %63, align 4
  store i32 %1917, ptr %1916, align 4
  %1918 = add i32 %1917, 1
  %1919 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1918, ptr %63, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3647

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3647: ; preds = %.cont.cont.i3612, %1915
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i2773

._crit_edge.i2773:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3647, %.lr.ph.i2758
  %1920 = add nuw nsw i32 %.060.i2771, 1
  %1921 = icmp slt i32 %1920, %1827
  br i1 %1921, label %.lr.ph.i2758, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2791

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2791: ; preds = %._crit_edge.i2773, %._crit_edge.i2809
  %.060.i2807 = phi i32 [ %2010, %._crit_edge.i2809 ], [ 0, %._crit_edge.i2773 ]
  %1922 = zext nneg i32 %.060.i2807 to i64
  %1923 = shl nuw nsw i64 %1922, 5
  %1924 = getelementptr i8, ptr %1826, i64 %1923
  %1925 = load ptr, ptr %1924, align 8
  %1926 = icmp ne ptr %1925, @nil_typ
  %1927 = icmp ne ptr %1925, null
  %.not16.i2808 = and i1 %1926, %1927
  br i1 %.not16.i2808, label %1928, label %._crit_edge.i2809

1928:                                             ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2791
  %1929 = getelementptr i8, ptr %1924, i64 8
  %1930 = load <2 x i64>, ptr %1929, align 4
  %hash_coef_ptr.i.i18.i2811 = getelementptr i8, ptr %1925, i64 8
  %tbl_size_ptr.i.i19.i2812 = getelementptr i8, ptr %1925, i64 16
  %offset_tbl_ptr.i.i20.i2813 = getelementptr i8, ptr %1925, i64 40
  %1931 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i3665 = load i64, ptr %hash_coef_ptr.i.i18.i2811, align 4, !noalias !22
  %tbl_size.i.i100.i3666 = load i64, ptr %tbl_size_ptr.i.i19.i2812, align 4, !noalias !22
  %offset_tbl.i.i101.i3667 = load ptr, ptr %offset_tbl_ptr.i.i20.i2813, align 8, !noalias !22
  %product.i.i.i102.i3668 = mul i64 %hash_coef.i.i99.i3665, 4015701072841558310
  %shifted.i.i.i103.i3669 = lshr i64 %product.i.i.i102.i3668, 32
  %xored.i.i.i104.i3670 = xor i64 %shifted.i.i.i103.i3669, %product.i.i.i102.i3668
  %hash.i.i.i105.i3671 = and i64 %xored.i.i.i104.i3670, %tbl_size.i.i100.i3666
  %offset_ptr.i.i106.i3672 = getelementptr i32, ptr %offset_tbl.i.i101.i3667, i64 %hash.i.i.i105.i3671
  %offset.i.i121.i3673 = load i32, ptr %offset_ptr.i.i106.i3672, align 4, !noalias !299
  %1932 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1933 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1934 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1935

1935:                                             ; preds = %.cont.cont.i3694, %1928
  %.0566.i3674 = phi i32 [ 0, %1928 ], [ %1939, %.cont.cont.i3694 ]
  %.070565.i3675 = phi i1 [ true, %1928 ], [ %2001, %.cont.cont.i3694 ]
  %.sroa.0.0564.i3676 = phi ptr [ %1925, %1928 ], [ %vptr.i142.sroa.speculated.i3697, %.cont.cont.i3694 ]
  %.sroa.17.0561.i3679 = phi i32 [ %offset.i.i121.i3673, %1928 ], [ %offset.i.i154.i3711, %.cont.cont.i3694 ]
  %1936 = phi <2 x i64> [ %1930, %1928 ], [ %2000, %.cont.cont.i3694 ]
  %1937 = extractelement <2 x i64> %1936, i64 1
  %.sroa.12.0562.i3678 = inttoptr i64 %1937 to ptr
  %1938 = extractelement <2 x i64> %1936, i64 0
  %.sroa.6.0563.i3677 = inttoptr i64 %1938 to ptr
  %1939 = add nuw nsw i32 %.0566.i3674, 1
  %1940 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3676, 0
  %1941 = insertvalue { ptr, ptr, ptr, i32 } %1940, ptr %.sroa.6.0563.i3677, 1
  %1942 = insertvalue { ptr, ptr, ptr, i32 } %1941, ptr %.sroa.12.0562.i3678, 2
  %1943 = insertvalue { ptr, ptr, ptr, i32 } %1942, i32 %.sroa.17.0561.i3679, 3
  %1944 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3676)
  %1945 = sext i32 %.sroa.17.0561.i3679 to i64
  %1946 = getelementptr ptr, ptr %.sroa.0.0564.i3676, i64 %1945
  %1947 = getelementptr i8, ptr %1946, i64 64
  %1948 = load ptr, ptr %1947, align 8
  %result.i125.i3680 = call ptr %1948({ ptr, ptr, ptr, i32 } %1943, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1949 = call i32 %result.i125.i3680({ ptr, ptr, ptr, i32 } %1943, { ptr, ptr, ptr, i32 } %1943, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3675, label %1950, label %1966

1950:                                             ; preds = %1935
  %1951 = load i32, ptr %53, align 8
  %1952 = add i32 %1951, -1
  %1953 = and i32 %1952, %1949
  %1954 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1955 = load ptr, ptr %54, align 8
  %1956 = sext i32 %1953 to i64
  %1957 = shl nsw i64 %1956, 5
  %1958 = getelementptr i8, ptr %1955, i64 %1957
  %1959 = load ptr, ptr %1958, align 8
  %1960 = getelementptr i8, ptr %1958, i64 8
  %1961 = load i160, ptr %1960, align 4
  store ptr %.sroa.0.0564.i3676, ptr %1958, align 8
  store i64 %1938, ptr %1960, align 4
  %.sroa_idx157.i3723 = getelementptr i8, ptr %1958, i64 16
  store i64 %1937, ptr %.sroa_idx157.i3723, align 4
  %.sroa_idx158.i3724 = getelementptr i8, ptr %1958, i64 24
  store i32 %.sroa.17.0561.i3679, ptr %.sroa_idx158.i3724, align 4
  %1962 = icmp ne ptr %1959, @nil_typ
  %1963 = icmp ne ptr %1959, null
  %.not92.i3725 = and i1 %1962, %1963
  %extract.i3727 = lshr i160 %1961, 64
  %1964 = insertelement <2 x i160> poison, i160 %1961, i64 0
  %1965 = insertelement <2 x i160> %1964, i160 %extract.i3727, i64 1
  br i1 %.not92.i3725, label %.cont.cont.i3694, label %2005

1966:                                             ; preds = %1935
  %1967 = add i32 %1949, 2127912214
  %1968 = shl i32 %1949, 12
  %1969 = add i32 %1967, %1968
  %1970 = ashr i32 %1969, 19
  %1971 = xor i32 %1969, %1970
  %1972 = xor i32 %1971, -949894596
  %1973 = add i32 %1972, 374761393
  %1974 = shl i32 %1972, 5
  %1975 = add i32 %1973, %1974
  %1976 = add i32 %1975, -744332180
  %1977 = shl i32 %1975, 9
  %1978 = xor i32 %1976, %1977
  %1979 = add i32 %1978, -42973499
  %1980 = shl i32 %1978, 3
  %1981 = add i32 %1979, %1980
  %1982 = ashr i32 %1981, 16
  %1983 = xor i32 %1981, %1982
  %1984 = xor i32 %1983, -1252372727
  %1985 = load i32, ptr %53, align 8
  %1986 = add i32 %1985, -1
  %1987 = and i32 %1986, %1984
  %1988 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1989 = load ptr, ptr %55, align 8
  %1990 = sext i32 %1987 to i64
  %1991 = shl nsw i64 %1990, 5
  %1992 = getelementptr i8, ptr %1989, i64 %1991
  %1993 = load ptr, ptr %1992, align 8
  %1994 = getelementptr i8, ptr %1992, i64 8
  %1995 = load i160, ptr %1994, align 4
  store ptr %.sroa.0.0564.i3676, ptr %1992, align 8
  store i64 %1938, ptr %1994, align 4
  %.sroa_idx161.i3684 = getelementptr i8, ptr %1992, i64 16
  store i64 %1937, ptr %.sroa_idx161.i3684, align 4
  %.sroa_idx162.i3685 = getelementptr i8, ptr %1992, i64 24
  store i32 %.sroa.17.0561.i3679, ptr %.sroa_idx162.i3685, align 4
  %1996 = icmp ne ptr %1993, @nil_typ
  %1997 = icmp ne ptr %1993, null
  %.not90.i3686 = and i1 %1996, %1997
  %extract607.i3688 = lshr i160 %1995, 64
  %1998 = insertelement <2 x i160> poison, i160 %1995, i64 0
  %1999 = insertelement <2 x i160> %1998, i160 %extract607.i3688, i64 1
  br i1 %.not90.i3686, label %.cont.cont.i3694, label %2005

.cont.cont.i3694:                                 ; preds = %1966, %1950
  %vptr.i142.sroa.speculated.i3697 = phi ptr [ %1959, %1950 ], [ %1993, %1966 ]
  %.in4291 = phi <2 x i160> [ %1965, %1950 ], [ %1999, %1966 ]
  %2000 = trunc <2 x i160> %.in4291 to <2 x i64>
  %2001 = xor i1 %.070565.i3675, true
  %hash_coef_ptr.i.i143.i3700 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3697, i64 8
  %tbl_size_ptr.i.i144.i3701 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3697, i64 16
  %offset_tbl_ptr.i.i145.i3702 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3697, i64 40
  %hash_coef.i.i146.i3703 = load i64, ptr %hash_coef_ptr.i.i143.i3700, align 4
  %tbl_size.i.i147.i3704 = load i64, ptr %tbl_size_ptr.i.i144.i3701, align 4
  %offset_tbl.i.i148.i3705 = load ptr, ptr %offset_tbl_ptr.i.i145.i3702, align 8
  %product.i.i.i149.i3706 = mul i64 %hash_coef.i.i146.i3703, 4015701072841558310
  %shifted.i.i.i150.i3707 = lshr i64 %product.i.i.i149.i3706, 32
  %xored.i.i.i151.i3708 = xor i64 %shifted.i.i.i150.i3707, %product.i.i.i149.i3706
  %hash.i.i.i152.i3709 = and i64 %xored.i.i.i151.i3708, %tbl_size.i.i147.i3704
  %offset_ptr.i.i153.i3710 = getelementptr i32, ptr %offset_tbl.i.i148.i3705, i64 %hash.i.i.i152.i3709
  %offset.i.i154.i3711 = load i32, ptr %offset_ptr.i.i153.i3710, align 4
  %2002 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2003 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2004 = icmp ult i32 %.0566.i3674, 99
  br i1 %2004, label %1935, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3729

2005:                                             ; preds = %1966, %1950
  %2006 = phi ptr [ %8, %1966 ], [ %7, %1950 ]
  %2007 = load i32, ptr %63, align 4
  store i32 %2007, ptr %2006, align 4
  %2008 = add i32 %2007, 1
  %2009 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2008, ptr %63, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3729

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3729: ; preds = %.cont.cont.i3694, %2005
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i2809

._crit_edge.i2809:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3729, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2791
  %2010 = add nuw nsw i32 %.060.i2807, 1
  %2011 = icmp slt i32 %2010, %1827
  br i1 %2011, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2791, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827: ; preds = %._crit_edge.i2809, %1823
  %2012 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %28)
  %hash_coef.i.i99.i1870 = load i64, ptr %hash_coef_ptr.i.i143.i1802, align 4, !noalias !22
  %tbl_size.i.i100.i1871 = load i64, ptr %tbl_size_ptr.i.i144.i1803, align 4, !noalias !22
  %offset_tbl.i.i101.i1872 = load ptr, ptr %offset_tbl_ptr.i.i145.i1804, align 8, !noalias !22
  %product.i.i.i102.i1873 = mul i64 %hash_coef.i.i99.i1870, 4015701072841558310
  %shifted.i.i.i103.i1874 = lshr i64 %product.i.i.i102.i1873, 32
  %xored.i.i.i104.i1875 = xor i64 %shifted.i.i.i103.i1874, %product.i.i.i102.i1873
  %hash.i.i.i105.i1876 = and i64 %xored.i.i.i104.i1875, %tbl_size.i.i100.i1871
  %offset_ptr.i.i106.i1877 = getelementptr i32, ptr %offset_tbl.i.i101.i1872, i64 %hash.i.i.i105.i1876
  %offset.i.i121.i1878 = load i32, ptr %offset_ptr.i.i106.i1877, align 4, !noalias !302
  %2013 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2014 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2015 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2016

2016:                                             ; preds = %.cont.cont.i1900, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827
  %.0566.i1880 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827 ], [ %2020, %.cont.cont.i1900 ]
  %.070565.i1881 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827 ], [ %2082, %.cont.cont.i1900 ]
  %.sroa.0.0564.i1882 = phi ptr [ %vptr.i142.sroa.speculated.i1799, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827 ], [ %vptr.i142.sroa.speculated.i1903, %.cont.cont.i1900 ]
  %.sroa.17.0561.i1885 = phi i32 [ %offset.i.i121.i1878, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827 ], [ %offset.i.i154.i1917, %.cont.cont.i1900 ]
  %2017 = phi <2 x i64> [ %1811, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2827 ], [ %2081, %.cont.cont.i1900 ]
  %2018 = extractelement <2 x i64> %2017, i64 1
  %.sroa.12.0562.i1884 = inttoptr i64 %2018 to ptr
  %2019 = extractelement <2 x i64> %2017, i64 0
  %.sroa.6.0563.i1883 = inttoptr i64 %2019 to ptr
  %2020 = add nuw nsw i32 %.0566.i1880, 1
  %2021 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1882, 0
  %2022 = insertvalue { ptr, ptr, ptr, i32 } %2021, ptr %.sroa.6.0563.i1883, 1
  %2023 = insertvalue { ptr, ptr, ptr, i32 } %2022, ptr %.sroa.12.0562.i1884, 2
  %2024 = insertvalue { ptr, ptr, ptr, i32 } %2023, i32 %.sroa.17.0561.i1885, 3
  %2025 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1882)
  %2026 = sext i32 %.sroa.17.0561.i1885 to i64
  %2027 = getelementptr ptr, ptr %.sroa.0.0564.i1882, i64 %2026
  %2028 = getelementptr i8, ptr %2027, i64 64
  %2029 = load ptr, ptr %2028, align 8
  %result.i125.i1886 = call ptr %2029({ ptr, ptr, ptr, i32 } %2024, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2030 = call i32 %result.i125.i1886({ ptr, ptr, ptr, i32 } %2024, { ptr, ptr, ptr, i32 } %2024, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1881, label %2031, label %2047

2031:                                             ; preds = %2016
  %2032 = load i32, ptr %53, align 8
  %2033 = add i32 %2032, -1
  %2034 = and i32 %2033, %2030
  %2035 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2036 = load ptr, ptr %54, align 8
  %2037 = sext i32 %2034 to i64
  %2038 = shl nsw i64 %2037, 5
  %2039 = getelementptr i8, ptr %2036, i64 %2038
  %2040 = load ptr, ptr %2039, align 8
  %2041 = getelementptr i8, ptr %2039, i64 8
  %2042 = load i160, ptr %2041, align 4
  store ptr %.sroa.0.0564.i1882, ptr %2039, align 8
  store i64 %2019, ptr %2041, align 4
  %.sroa_idx157.i1929 = getelementptr i8, ptr %2039, i64 16
  store i64 %2018, ptr %.sroa_idx157.i1929, align 4
  %.sroa_idx158.i1930 = getelementptr i8, ptr %2039, i64 24
  store i32 %.sroa.17.0561.i1885, ptr %.sroa_idx158.i1930, align 4
  %2043 = icmp ne ptr %2040, @nil_typ
  %2044 = icmp ne ptr %2040, null
  %.not92.i1931 = and i1 %2043, %2044
  %extract.i1933 = lshr i160 %2042, 64
  %2045 = insertelement <2 x i160> poison, i160 %2042, i64 0
  %2046 = insertelement <2 x i160> %2045, i160 %extract.i1933, i64 1
  br i1 %.not92.i1931, label %.cont.cont.i1900, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1935.thread

2047:                                             ; preds = %2016
  %2048 = add i32 %2030, 2127912214
  %2049 = shl i32 %2030, 12
  %2050 = add i32 %2048, %2049
  %2051 = ashr i32 %2050, 19
  %2052 = xor i32 %2050, %2051
  %2053 = xor i32 %2052, -949894596
  %2054 = add i32 %2053, 374761393
  %2055 = shl i32 %2053, 5
  %2056 = add i32 %2054, %2055
  %2057 = add i32 %2056, -744332180
  %2058 = shl i32 %2056, 9
  %2059 = xor i32 %2057, %2058
  %2060 = add i32 %2059, -42973499
  %2061 = shl i32 %2059, 3
  %2062 = add i32 %2060, %2061
  %2063 = ashr i32 %2062, 16
  %2064 = xor i32 %2062, %2063
  %2065 = xor i32 %2064, -1252372727
  %2066 = load i32, ptr %53, align 8
  %2067 = add i32 %2066, -1
  %2068 = and i32 %2067, %2065
  %2069 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2070 = load ptr, ptr %55, align 8
  %2071 = sext i32 %2068 to i64
  %2072 = shl nsw i64 %2071, 5
  %2073 = getelementptr i8, ptr %2070, i64 %2072
  %2074 = load ptr, ptr %2073, align 8
  %2075 = getelementptr i8, ptr %2073, i64 8
  %2076 = load i160, ptr %2075, align 4
  store ptr %.sroa.0.0564.i1882, ptr %2073, align 8
  store i64 %2019, ptr %2075, align 4
  %.sroa_idx161.i1890 = getelementptr i8, ptr %2073, i64 16
  store i64 %2018, ptr %.sroa_idx161.i1890, align 4
  %.sroa_idx162.i1891 = getelementptr i8, ptr %2073, i64 24
  store i32 %.sroa.17.0561.i1885, ptr %.sroa_idx162.i1891, align 4
  %2077 = icmp ne ptr %2074, @nil_typ
  %2078 = icmp ne ptr %2074, null
  %.not90.i1892 = and i1 %2077, %2078
  %extract607.i1894 = lshr i160 %2076, 64
  %2079 = insertelement <2 x i160> poison, i160 %2076, i64 0
  %2080 = insertelement <2 x i160> %2079, i160 %extract607.i1894, i64 1
  br i1 %.not90.i1892, label %.cont.cont.i1900, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1935.thread

.cont.cont.i1900:                                 ; preds = %2047, %2031
  %vptr.i142.sroa.speculated.i1903 = phi ptr [ %2040, %2031 ], [ %2074, %2047 ]
  %.in4292 = phi <2 x i160> [ %2046, %2031 ], [ %2080, %2047 ]
  %2081 = trunc <2 x i160> %.in4292 to <2 x i64>
  %2082 = xor i1 %.070565.i1881, true
  %hash_coef_ptr.i.i143.i1906 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1903, i64 8
  %tbl_size_ptr.i.i144.i1907 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1903, i64 16
  %offset_tbl_ptr.i.i145.i1908 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1903, i64 40
  %hash_coef.i.i146.i1909 = load i64, ptr %hash_coef_ptr.i.i143.i1906, align 4
  %tbl_size.i.i147.i1910 = load i64, ptr %tbl_size_ptr.i.i144.i1907, align 4
  %offset_tbl.i.i148.i1911 = load ptr, ptr %offset_tbl_ptr.i.i145.i1908, align 8
  %product.i.i.i149.i1912 = mul i64 %hash_coef.i.i146.i1909, 4015701072841558310
  %shifted.i.i.i150.i1913 = lshr i64 %product.i.i.i149.i1912, 32
  %xored.i.i.i151.i1914 = xor i64 %shifted.i.i.i150.i1913, %product.i.i.i149.i1912
  %hash.i.i.i152.i1915 = and i64 %xored.i.i.i151.i1914, %tbl_size.i.i147.i1910
  %offset_ptr.i.i153.i1916 = getelementptr i32, ptr %offset_tbl.i.i148.i1911, i64 %hash.i.i.i152.i1915
  %offset.i.i154.i1917 = load i32, ptr %offset_ptr.i.i153.i1916, align 4
  %2083 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2084 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2085 = icmp ult i32 %.0566.i1880, 99
  br i1 %2085, label %2016, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1935

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1935.thread: ; preds = %2031, %2047
  %2086 = phi ptr [ %28, %2047 ], [ %27, %2031 ]
  %2087 = load i32, ptr %63, align 4
  store i32 %2087, ptr %2086, align 4
  %2088 = add i32 %2087, 1
  %2089 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2088, ptr %63, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  br label %HashMap_insert_keyK_valueV.exit991

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1935: ; preds = %.cont.cont.i1900
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  %2090 = icmp eq ptr %vptr.i142.sroa.speculated.i1903, null
  br i1 %2090, label %HashMap_insert_keyK_valueV.exit991, label %2091

2091:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1935
  %2092 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2093 = load ptr, ptr %54, align 8
  %2094 = load ptr, ptr %55, align 8
  %2095 = load i32, ptr %53, align 8
  %2096 = shl i32 %2095, 1
  %spec.select.i1951 = call i32 @llvm.smax.i32(i32 %2096, i32 16)
  store i32 %spec.select.i1951, ptr %53, align 8
  %2097 = zext nneg i32 %spec.select.i1951 to i64
  %2098 = shl nuw nsw i64 %2097, 5
  %result.i.i1952 = call noalias ptr @bump_malloc_inner(i64 noundef %2098, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1952, ptr %54, align 8
  %result.i20.i1953 = call noalias ptr @bump_malloc_inner(i64 noundef %2098, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1953, ptr %55, align 8
  store i32 0, ptr %63, align 4
  %2099 = icmp sgt i32 %2095, 0
  br i1 %2099, label %.lr.ph.i2857, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2890.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2890.thread: ; preds = %2091
  %2100 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit991

.lr.ph.i2857:                                     ; preds = %2091, %._crit_edge.i2872
  %.060.i2870 = phi i32 [ %2189, %._crit_edge.i2872 ], [ 0, %2091 ]
  %2101 = zext nneg i32 %.060.i2870 to i64
  %2102 = shl nuw nsw i64 %2101, 5
  %2103 = getelementptr i8, ptr %2093, i64 %2102
  %2104 = load ptr, ptr %2103, align 8
  %2105 = icmp ne ptr %2104, @nil_typ
  %2106 = icmp ne ptr %2104, null
  %.not16.i2871 = and i1 %2105, %2106
  br i1 %.not16.i2871, label %2107, label %._crit_edge.i2872

2107:                                             ; preds = %.lr.ph.i2857
  %2108 = getelementptr i8, ptr %2103, i64 8
  %2109 = load <2 x i64>, ptr %2108, align 4
  %hash_coef_ptr.i.i18.i2874 = getelementptr i8, ptr %2104, i64 8
  %tbl_size_ptr.i.i19.i2875 = getelementptr i8, ptr %2104, i64 16
  %offset_tbl_ptr.i.i20.i2876 = getelementptr i8, ptr %2104, i64 40
  %2110 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i3747 = load i64, ptr %hash_coef_ptr.i.i18.i2874, align 4, !noalias !22
  %tbl_size.i.i100.i3748 = load i64, ptr %tbl_size_ptr.i.i19.i2875, align 4, !noalias !22
  %offset_tbl.i.i101.i3749 = load ptr, ptr %offset_tbl_ptr.i.i20.i2876, align 8, !noalias !22
  %product.i.i.i102.i3750 = mul i64 %hash_coef.i.i99.i3747, 4015701072841558310
  %shifted.i.i.i103.i3751 = lshr i64 %product.i.i.i102.i3750, 32
  %xored.i.i.i104.i3752 = xor i64 %shifted.i.i.i103.i3751, %product.i.i.i102.i3750
  %hash.i.i.i105.i3753 = and i64 %xored.i.i.i104.i3752, %tbl_size.i.i100.i3748
  %offset_ptr.i.i106.i3754 = getelementptr i32, ptr %offset_tbl.i.i101.i3749, i64 %hash.i.i.i105.i3753
  %offset.i.i121.i3755 = load i32, ptr %offset_ptr.i.i106.i3754, align 4, !noalias !305
  %2111 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2112 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2114

2114:                                             ; preds = %.cont.cont.i3776, %2107
  %.0566.i3756 = phi i32 [ 0, %2107 ], [ %2118, %.cont.cont.i3776 ]
  %.070565.i3757 = phi i1 [ true, %2107 ], [ %2180, %.cont.cont.i3776 ]
  %.sroa.0.0564.i3758 = phi ptr [ %2104, %2107 ], [ %vptr.i142.sroa.speculated.i3779, %.cont.cont.i3776 ]
  %.sroa.17.0561.i3761 = phi i32 [ %offset.i.i121.i3755, %2107 ], [ %offset.i.i154.i3793, %.cont.cont.i3776 ]
  %2115 = phi <2 x i64> [ %2109, %2107 ], [ %2179, %.cont.cont.i3776 ]
  %2116 = extractelement <2 x i64> %2115, i64 1
  %.sroa.12.0562.i3760 = inttoptr i64 %2116 to ptr
  %2117 = extractelement <2 x i64> %2115, i64 0
  %.sroa.6.0563.i3759 = inttoptr i64 %2117 to ptr
  %2118 = add nuw nsw i32 %.0566.i3756, 1
  %2119 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3758, 0
  %2120 = insertvalue { ptr, ptr, ptr, i32 } %2119, ptr %.sroa.6.0563.i3759, 1
  %2121 = insertvalue { ptr, ptr, ptr, i32 } %2120, ptr %.sroa.12.0562.i3760, 2
  %2122 = insertvalue { ptr, ptr, ptr, i32 } %2121, i32 %.sroa.17.0561.i3761, 3
  %2123 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3758)
  %2124 = sext i32 %.sroa.17.0561.i3761 to i64
  %2125 = getelementptr ptr, ptr %.sroa.0.0564.i3758, i64 %2124
  %2126 = getelementptr i8, ptr %2125, i64 64
  %2127 = load ptr, ptr %2126, align 8
  %result.i125.i3762 = call ptr %2127({ ptr, ptr, ptr, i32 } %2122, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2128 = call i32 %result.i125.i3762({ ptr, ptr, ptr, i32 } %2122, { ptr, ptr, ptr, i32 } %2122, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3757, label %2129, label %2145

2129:                                             ; preds = %2114
  %2130 = load i32, ptr %53, align 8
  %2131 = add i32 %2130, -1
  %2132 = and i32 %2131, %2128
  %2133 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2134 = load ptr, ptr %54, align 8
  %2135 = sext i32 %2132 to i64
  %2136 = shl nsw i64 %2135, 5
  %2137 = getelementptr i8, ptr %2134, i64 %2136
  %2138 = load ptr, ptr %2137, align 8
  %2139 = getelementptr i8, ptr %2137, i64 8
  %2140 = load i160, ptr %2139, align 4
  store ptr %.sroa.0.0564.i3758, ptr %2137, align 8
  store i64 %2117, ptr %2139, align 4
  %.sroa_idx157.i3805 = getelementptr i8, ptr %2137, i64 16
  store i64 %2116, ptr %.sroa_idx157.i3805, align 4
  %.sroa_idx158.i3806 = getelementptr i8, ptr %2137, i64 24
  store i32 %.sroa.17.0561.i3761, ptr %.sroa_idx158.i3806, align 4
  %2141 = icmp ne ptr %2138, @nil_typ
  %2142 = icmp ne ptr %2138, null
  %.not92.i3807 = and i1 %2141, %2142
  %extract.i3809 = lshr i160 %2140, 64
  %2143 = insertelement <2 x i160> poison, i160 %2140, i64 0
  %2144 = insertelement <2 x i160> %2143, i160 %extract.i3809, i64 1
  br i1 %.not92.i3807, label %.cont.cont.i3776, label %2184

2145:                                             ; preds = %2114
  %2146 = add i32 %2128, 2127912214
  %2147 = shl i32 %2128, 12
  %2148 = add i32 %2146, %2147
  %2149 = ashr i32 %2148, 19
  %2150 = xor i32 %2148, %2149
  %2151 = xor i32 %2150, -949894596
  %2152 = add i32 %2151, 374761393
  %2153 = shl i32 %2151, 5
  %2154 = add i32 %2152, %2153
  %2155 = add i32 %2154, -744332180
  %2156 = shl i32 %2154, 9
  %2157 = xor i32 %2155, %2156
  %2158 = add i32 %2157, -42973499
  %2159 = shl i32 %2157, 3
  %2160 = add i32 %2158, %2159
  %2161 = ashr i32 %2160, 16
  %2162 = xor i32 %2160, %2161
  %2163 = xor i32 %2162, -1252372727
  %2164 = load i32, ptr %53, align 8
  %2165 = add i32 %2164, -1
  %2166 = and i32 %2165, %2163
  %2167 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2168 = load ptr, ptr %55, align 8
  %2169 = sext i32 %2166 to i64
  %2170 = shl nsw i64 %2169, 5
  %2171 = getelementptr i8, ptr %2168, i64 %2170
  %2172 = load ptr, ptr %2171, align 8
  %2173 = getelementptr i8, ptr %2171, i64 8
  %2174 = load i160, ptr %2173, align 4
  store ptr %.sroa.0.0564.i3758, ptr %2171, align 8
  store i64 %2117, ptr %2173, align 4
  %.sroa_idx161.i3766 = getelementptr i8, ptr %2171, i64 16
  store i64 %2116, ptr %.sroa_idx161.i3766, align 4
  %.sroa_idx162.i3767 = getelementptr i8, ptr %2171, i64 24
  store i32 %.sroa.17.0561.i3761, ptr %.sroa_idx162.i3767, align 4
  %2175 = icmp ne ptr %2172, @nil_typ
  %2176 = icmp ne ptr %2172, null
  %.not90.i3768 = and i1 %2175, %2176
  %extract607.i3770 = lshr i160 %2174, 64
  %2177 = insertelement <2 x i160> poison, i160 %2174, i64 0
  %2178 = insertelement <2 x i160> %2177, i160 %extract607.i3770, i64 1
  br i1 %.not90.i3768, label %.cont.cont.i3776, label %2184

.cont.cont.i3776:                                 ; preds = %2145, %2129
  %vptr.i142.sroa.speculated.i3779 = phi ptr [ %2138, %2129 ], [ %2172, %2145 ]
  %.in4293 = phi <2 x i160> [ %2144, %2129 ], [ %2178, %2145 ]
  %2179 = trunc <2 x i160> %.in4293 to <2 x i64>
  %2180 = xor i1 %.070565.i3757, true
  %hash_coef_ptr.i.i143.i3782 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3779, i64 8
  %tbl_size_ptr.i.i144.i3783 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3779, i64 16
  %offset_tbl_ptr.i.i145.i3784 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3779, i64 40
  %hash_coef.i.i146.i3785 = load i64, ptr %hash_coef_ptr.i.i143.i3782, align 4
  %tbl_size.i.i147.i3786 = load i64, ptr %tbl_size_ptr.i.i144.i3783, align 4
  %offset_tbl.i.i148.i3787 = load ptr, ptr %offset_tbl_ptr.i.i145.i3784, align 8
  %product.i.i.i149.i3788 = mul i64 %hash_coef.i.i146.i3785, 4015701072841558310
  %shifted.i.i.i150.i3789 = lshr i64 %product.i.i.i149.i3788, 32
  %xored.i.i.i151.i3790 = xor i64 %shifted.i.i.i150.i3789, %product.i.i.i149.i3788
  %hash.i.i.i152.i3791 = and i64 %xored.i.i.i151.i3790, %tbl_size.i.i147.i3786
  %offset_ptr.i.i153.i3792 = getelementptr i32, ptr %offset_tbl.i.i148.i3787, i64 %hash.i.i.i152.i3791
  %offset.i.i154.i3793 = load i32, ptr %offset_ptr.i.i153.i3792, align 4
  %2181 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2182 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2183 = icmp ult i32 %.0566.i3756, 99
  br i1 %2183, label %2114, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3811

2184:                                             ; preds = %2145, %2129
  %2185 = phi ptr [ %6, %2145 ], [ %5, %2129 ]
  %2186 = load i32, ptr %63, align 4
  store i32 %2186, ptr %2185, align 4
  %2187 = add i32 %2186, 1
  %2188 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2187, ptr %63, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3811

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3811: ; preds = %.cont.cont.i3776, %2184
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i2872

._crit_edge.i2872:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3811, %.lr.ph.i2857
  %2189 = add nuw nsw i32 %.060.i2870, 1
  %2190 = icmp slt i32 %2189, %2095
  br i1 %2190, label %.lr.ph.i2857, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2890

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2890: ; preds = %._crit_edge.i2872
  %2191 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %2192

2192:                                             ; preds = %._crit_edge.i2908, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2890
  %.060.i2906 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2890 ], [ %2281, %._crit_edge.i2908 ]
  %2193 = zext nneg i32 %.060.i2906 to i64
  %2194 = shl nuw nsw i64 %2193, 5
  %2195 = getelementptr i8, ptr %2094, i64 %2194
  %2196 = load ptr, ptr %2195, align 8
  %2197 = icmp ne ptr %2196, @nil_typ
  %2198 = icmp ne ptr %2196, null
  %.not16.i2907 = and i1 %2197, %2198
  br i1 %.not16.i2907, label %2199, label %._crit_edge.i2908

2199:                                             ; preds = %2192
  %2200 = getelementptr i8, ptr %2195, i64 8
  %2201 = load <2 x i64>, ptr %2200, align 4
  %hash_coef_ptr.i.i18.i2910 = getelementptr i8, ptr %2196, i64 8
  %tbl_size_ptr.i.i19.i2911 = getelementptr i8, ptr %2196, i64 16
  %offset_tbl_ptr.i.i20.i2912 = getelementptr i8, ptr %2196, i64 40
  %2202 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i3829 = load i64, ptr %hash_coef_ptr.i.i18.i2910, align 4, !noalias !22
  %tbl_size.i.i100.i3830 = load i64, ptr %tbl_size_ptr.i.i19.i2911, align 4, !noalias !22
  %offset_tbl.i.i101.i3831 = load ptr, ptr %offset_tbl_ptr.i.i20.i2912, align 8, !noalias !22
  %product.i.i.i102.i3832 = mul i64 %hash_coef.i.i99.i3829, 4015701072841558310
  %shifted.i.i.i103.i3833 = lshr i64 %product.i.i.i102.i3832, 32
  %xored.i.i.i104.i3834 = xor i64 %shifted.i.i.i103.i3833, %product.i.i.i102.i3832
  %hash.i.i.i105.i3835 = and i64 %xored.i.i.i104.i3834, %tbl_size.i.i100.i3830
  %offset_ptr.i.i106.i3836 = getelementptr i32, ptr %offset_tbl.i.i101.i3831, i64 %hash.i.i.i105.i3835
  %offset.i.i121.i3837 = load i32, ptr %offset_ptr.i.i106.i3836, align 4, !noalias !308
  %2203 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2204 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2205 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2206

2206:                                             ; preds = %.cont.cont.i3858, %2199
  %.0566.i3838 = phi i32 [ 0, %2199 ], [ %2210, %.cont.cont.i3858 ]
  %.070565.i3839 = phi i1 [ true, %2199 ], [ %2272, %.cont.cont.i3858 ]
  %.sroa.0.0564.i3840 = phi ptr [ %2196, %2199 ], [ %vptr.i142.sroa.speculated.i3861, %.cont.cont.i3858 ]
  %.sroa.17.0561.i3843 = phi i32 [ %offset.i.i121.i3837, %2199 ], [ %offset.i.i154.i3875, %.cont.cont.i3858 ]
  %2207 = phi <2 x i64> [ %2201, %2199 ], [ %2271, %.cont.cont.i3858 ]
  %2208 = extractelement <2 x i64> %2207, i64 1
  %.sroa.12.0562.i3842 = inttoptr i64 %2208 to ptr
  %2209 = extractelement <2 x i64> %2207, i64 0
  %.sroa.6.0563.i3841 = inttoptr i64 %2209 to ptr
  %2210 = add nuw nsw i32 %.0566.i3838, 1
  %2211 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3840, 0
  %2212 = insertvalue { ptr, ptr, ptr, i32 } %2211, ptr %.sroa.6.0563.i3841, 1
  %2213 = insertvalue { ptr, ptr, ptr, i32 } %2212, ptr %.sroa.12.0562.i3842, 2
  %2214 = insertvalue { ptr, ptr, ptr, i32 } %2213, i32 %.sroa.17.0561.i3843, 3
  %2215 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3840)
  %2216 = sext i32 %.sroa.17.0561.i3843 to i64
  %2217 = getelementptr ptr, ptr %.sroa.0.0564.i3840, i64 %2216
  %2218 = getelementptr i8, ptr %2217, i64 64
  %2219 = load ptr, ptr %2218, align 8
  %result.i125.i3844 = call ptr %2219({ ptr, ptr, ptr, i32 } %2214, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2220 = call i32 %result.i125.i3844({ ptr, ptr, ptr, i32 } %2214, { ptr, ptr, ptr, i32 } %2214, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3839, label %2221, label %2237

2221:                                             ; preds = %2206
  %2222 = load i32, ptr %53, align 8
  %2223 = add i32 %2222, -1
  %2224 = and i32 %2223, %2220
  %2225 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2226 = load ptr, ptr %54, align 8
  %2227 = sext i32 %2224 to i64
  %2228 = shl nsw i64 %2227, 5
  %2229 = getelementptr i8, ptr %2226, i64 %2228
  %2230 = load ptr, ptr %2229, align 8
  %2231 = getelementptr i8, ptr %2229, i64 8
  %2232 = load i160, ptr %2231, align 4
  store ptr %.sroa.0.0564.i3840, ptr %2229, align 8
  store i64 %2209, ptr %2231, align 4
  %.sroa_idx157.i3887 = getelementptr i8, ptr %2229, i64 16
  store i64 %2208, ptr %.sroa_idx157.i3887, align 4
  %.sroa_idx158.i3888 = getelementptr i8, ptr %2229, i64 24
  store i32 %.sroa.17.0561.i3843, ptr %.sroa_idx158.i3888, align 4
  %2233 = icmp ne ptr %2230, @nil_typ
  %2234 = icmp ne ptr %2230, null
  %.not92.i3889 = and i1 %2233, %2234
  %extract.i3891 = lshr i160 %2232, 64
  %2235 = insertelement <2 x i160> poison, i160 %2232, i64 0
  %2236 = insertelement <2 x i160> %2235, i160 %extract.i3891, i64 1
  br i1 %.not92.i3889, label %.cont.cont.i3858, label %2276

2237:                                             ; preds = %2206
  %2238 = add i32 %2220, 2127912214
  %2239 = shl i32 %2220, 12
  %2240 = add i32 %2238, %2239
  %2241 = ashr i32 %2240, 19
  %2242 = xor i32 %2240, %2241
  %2243 = xor i32 %2242, -949894596
  %2244 = add i32 %2243, 374761393
  %2245 = shl i32 %2243, 5
  %2246 = add i32 %2244, %2245
  %2247 = add i32 %2246, -744332180
  %2248 = shl i32 %2246, 9
  %2249 = xor i32 %2247, %2248
  %2250 = add i32 %2249, -42973499
  %2251 = shl i32 %2249, 3
  %2252 = add i32 %2250, %2251
  %2253 = ashr i32 %2252, 16
  %2254 = xor i32 %2252, %2253
  %2255 = xor i32 %2254, -1252372727
  %2256 = load i32, ptr %53, align 8
  %2257 = add i32 %2256, -1
  %2258 = and i32 %2257, %2255
  %2259 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2260 = load ptr, ptr %55, align 8
  %2261 = sext i32 %2258 to i64
  %2262 = shl nsw i64 %2261, 5
  %2263 = getelementptr i8, ptr %2260, i64 %2262
  %2264 = load ptr, ptr %2263, align 8
  %2265 = getelementptr i8, ptr %2263, i64 8
  %2266 = load i160, ptr %2265, align 4
  store ptr %.sroa.0.0564.i3840, ptr %2263, align 8
  store i64 %2209, ptr %2265, align 4
  %.sroa_idx161.i3848 = getelementptr i8, ptr %2263, i64 16
  store i64 %2208, ptr %.sroa_idx161.i3848, align 4
  %.sroa_idx162.i3849 = getelementptr i8, ptr %2263, i64 24
  store i32 %.sroa.17.0561.i3843, ptr %.sroa_idx162.i3849, align 4
  %2267 = icmp ne ptr %2264, @nil_typ
  %2268 = icmp ne ptr %2264, null
  %.not90.i3850 = and i1 %2267, %2268
  %extract607.i3852 = lshr i160 %2266, 64
  %2269 = insertelement <2 x i160> poison, i160 %2266, i64 0
  %2270 = insertelement <2 x i160> %2269, i160 %extract607.i3852, i64 1
  br i1 %.not90.i3850, label %.cont.cont.i3858, label %2276

.cont.cont.i3858:                                 ; preds = %2237, %2221
  %vptr.i142.sroa.speculated.i3861 = phi ptr [ %2230, %2221 ], [ %2264, %2237 ]
  %.in4294 = phi <2 x i160> [ %2236, %2221 ], [ %2270, %2237 ]
  %2271 = trunc <2 x i160> %.in4294 to <2 x i64>
  %2272 = xor i1 %.070565.i3839, true
  %hash_coef_ptr.i.i143.i3864 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3861, i64 8
  %tbl_size_ptr.i.i144.i3865 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3861, i64 16
  %offset_tbl_ptr.i.i145.i3866 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3861, i64 40
  %hash_coef.i.i146.i3867 = load i64, ptr %hash_coef_ptr.i.i143.i3864, align 4
  %tbl_size.i.i147.i3868 = load i64, ptr %tbl_size_ptr.i.i144.i3865, align 4
  %offset_tbl.i.i148.i3869 = load ptr, ptr %offset_tbl_ptr.i.i145.i3866, align 8
  %product.i.i.i149.i3870 = mul i64 %hash_coef.i.i146.i3867, 4015701072841558310
  %shifted.i.i.i150.i3871 = lshr i64 %product.i.i.i149.i3870, 32
  %xored.i.i.i151.i3872 = xor i64 %shifted.i.i.i150.i3871, %product.i.i.i149.i3870
  %hash.i.i.i152.i3873 = and i64 %xored.i.i.i151.i3872, %tbl_size.i.i147.i3868
  %offset_ptr.i.i153.i3874 = getelementptr i32, ptr %offset_tbl.i.i148.i3869, i64 %hash.i.i.i152.i3873
  %offset.i.i154.i3875 = load i32, ptr %offset_ptr.i.i153.i3874, align 4
  %2273 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2274 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2275 = icmp ult i32 %.0566.i3838, 99
  br i1 %2275, label %2206, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3893

2276:                                             ; preds = %2237, %2221
  %2277 = phi ptr [ %4, %2237 ], [ %3, %2221 ]
  %2278 = load i32, ptr %63, align 4
  store i32 %2278, ptr %2277, align 4
  %2279 = add i32 %2278, 1
  %2280 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2279, ptr %63, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3893

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3893: ; preds = %.cont.cont.i3858, %2276
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i2908

._crit_edge.i2908:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3893, %2192
  %2281 = add nuw nsw i32 %.060.i2906, 1
  %2282 = icmp slt i32 %2281, %2095
  br i1 %2282, label %2192, label %HashMap_insert_keyK_valueV.exit991

HashMap_insert_keyK_valueV.exit991:               ; preds = %._crit_edge.i2908, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2890.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1935.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1831.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1727, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1668, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1831, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1935
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2283 = add nsw i32 %.0361707, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %HashMap_insert_keyK_valueV.exit991, %HashMap_get_keyK.exit
  %.2363 = phi i32 [ %2283, %HashMap_insert_keyK_valueV.exit991 ], [ %.0361707, %HashMap_get_keyK.exit ]
  %2284 = add nuw nsw i32 %.0358708, 1
  %2285 = icmp slt i32 %.2363, %0
  %2286 = icmp slt i32 %2284, %57
  %spec.select = select i1 %2285, i1 %2286, i1 false
  br i1 %spec.select, label %65, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %2287 = sext i32 %0 to i64
  %2288 = shl nsw i64 %2287, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %2288, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2289 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %2290 = mul i32 %0, 20
  %2291 = icmp sgt i32 %2290, 0
  %spec.select384709 = and i1 %58, %2291
  br i1 %spec.select384709, label %.lr.ph712, label %._crit_edge7._crit_edge

.lr.ph712:                                        ; preds = %._crit_edge3._crit_edge
  %2292 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2293 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2294 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  br label %2295

2295:                                             ; preds = %.lr.ph712, %._crit_edge5
  %2296 = phi i32 [ 987, %.lr.ph712 ], [ %2299, %._crit_edge5 ]
  %.0357711 = phi i32 [ 0, %.lr.ph712 ], [ %.2, %._crit_edge5 ]
  %.2360710 = phi i32 [ 0, %.lr.ph712 ], [ %2423, %._crit_edge5 ]
  %2297 = mul i32 %2296, 1103515245
  %2298 = add i32 %2297, 12345
  %2299 = and i32 %2298, 2147483647
  %.sroa.0285.0.insert.ext = zext nneg i32 %2299 to i160
  %2300 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0285.0.insert.ext, 1
  %2301 = load ptr, ptr %51, align 8
  %2302 = call i32 %2301({ ptr, i160 } %2300) #7
  %2303 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %2304 = load i32, ptr %53, align 8
  %2305 = add i32 %2304, -1
  %2306 = and i32 %2305, %2302
  %2307 = load ptr, ptr %54, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2308 = sext i32 %2306 to i64
  %2309 = shl nsw i64 %2308, 5
  %2310 = getelementptr i8, ptr %2307, i64 %2309
  %2311 = load ptr, ptr %2310, align 8
  %2312 = icmp ne ptr %2311, @nil_typ
  %2313 = icmp ne ptr %2311, null
  %.not44.i1997 = and i1 %2312, %2313
  br i1 %.not44.i1997, label %2314, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021.thread

2314:                                             ; preds = %2295
  %2315 = getelementptr i8, ptr %2310, i64 8
  %2316 = load i64, ptr %2315, align 4
  %.sroa_idx.i2001 = getelementptr i8, ptr %2310, i64 16
  %2317 = load i64, ptr %.sroa_idx.i2001, align 4
  %2318 = inttoptr i64 %2316 to ptr
  %2319 = inttoptr i64 %2317 to ptr
  %hash_coef_ptr.i.i46.i2002 = getelementptr i8, ptr %2311, i64 8
  %tbl_size_ptr.i.i47.i2003 = getelementptr i8, ptr %2311, i64 16
  %offset_tbl_ptr.i.i48.i2004 = getelementptr i8, ptr %2311, i64 40
  %hash_coef.i.i49.i2005 = load i64, ptr %hash_coef_ptr.i.i46.i2002, align 4, !noalias !311
  %tbl_size.i.i50.i2006 = load i64, ptr %tbl_size_ptr.i.i47.i2003, align 4, !noalias !311
  %offset_tbl.i.i51.i2007 = load ptr, ptr %offset_tbl_ptr.i.i48.i2004, align 8, !noalias !311
  %product.i.i.i52.i2008 = mul i64 %hash_coef.i.i49.i2005, 4015701072841558310
  %shifted.i.i.i53.i2009 = lshr i64 %product.i.i.i52.i2008, 32
  %xored.i.i.i54.i2010 = xor i64 %shifted.i.i.i53.i2009, %product.i.i.i52.i2008
  %hash.i.i.i55.i2011 = and i64 %xored.i.i.i54.i2010, %tbl_size.i.i50.i2006
  %offset_ptr.i.i56.i2012 = getelementptr i32, ptr %offset_tbl.i.i51.i2007, i64 %hash.i.i.i55.i2011
  %offset.i.i57.i2013 = load i32, ptr %offset_ptr.i.i56.i2012, align 4, !noalias !311
  %2320 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2311, 0
  %2321 = insertvalue { ptr, ptr, ptr, i32 } %2320, ptr %2318, 1
  %2322 = insertvalue { ptr, ptr, ptr, i32 } %2321, ptr %2319, 2
  %2323 = insertvalue { ptr, ptr, ptr, i32 } %2322, i32 %offset.i.i57.i2013, 3
  %2324 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2325 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2311) #34
  %2326 = sext i32 %offset.i.i57.i2013 to i64
  %2327 = getelementptr ptr, ptr %2311, i64 %2326
  %2328 = getelementptr i8, ptr %2327, i64 64
  %2329 = load ptr, ptr %2328, align 8
  %result.i.i2014 = call ptr %2329({ ptr, ptr, ptr, i32 } %2323, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2330 = call i32 %result.i.i2014({ ptr, ptr, ptr, i32 } %2323, { ptr, ptr, ptr, i32 } %2323, ptr nonnull align 8 %2) #7
  %2331 = icmp eq i32 %2330, %2302
  br i1 %2331, label %._crit_edge.i2015, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021.thread

._crit_edge.i2015:                                ; preds = %2314
  %2332 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2333 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2311)
  %2334 = getelementptr i8, ptr %2327, i64 48
  %2335 = load ptr, ptr %2334, align 8
  %result.i59.i2016 = call ptr %2335({ ptr, ptr, ptr, i32 } %2323, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2336 = call { ptr, i160 } %result.i59.i2016({ ptr, ptr, ptr, i32 } %2323, { ptr, ptr, ptr, i32 } %2323, ptr nonnull align 8 %2) #7
  %2337 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2338 = load ptr, ptr %52, align 8
  %2339 = call i1 %2338({ ptr, i160 } %2336, { ptr, i160 } %2300) #7
  br i1 %2339, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021.thread: ; preds = %._crit_edge.i2015, %2295, %2314
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2348

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021: ; preds = %._crit_edge.i2015
  %2340 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2341 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2311)
  %2342 = getelementptr i8, ptr %2327, i64 56
  %2343 = load ptr, ptr %2342, align 8
  %result.i60.i2018 = call ptr %2343({ ptr, ptr, ptr, i32 } %2323, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2344 = call { ptr, i160 } %result.i60.i2018({ ptr, ptr, ptr, i32 } %2323, { ptr, ptr, ptr, i32 } %2323, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2019 = extractvalue { ptr, i160 } %2344, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2345 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2346 = icmp ne ptr %.fca.0.extract21.i2019, @nil_typ
  %2347 = icmp ne ptr %.fca.0.extract21.i2019, null
  %.not63.i1025 = and i1 %2346, %2347
  br i1 %.not63.i1025, label %HashMap_get_keyK.exit1036, label %2348

2348:                                             ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021
  %2349 = add i32 %2302, 2127912214
  %2350 = shl i32 %2302, 12
  %2351 = add i32 %2349, %2350
  %2352 = ashr i32 %2351, 19
  %2353 = xor i32 %2351, %2352
  %2354 = xor i32 %2353, -949894596
  %2355 = add i32 %2354, 374761393
  %2356 = shl i32 %2354, 5
  %2357 = add i32 %2355, %2356
  %2358 = add i32 %2357, -744332180
  %2359 = shl i32 %2357, 9
  %2360 = xor i32 %2358, %2359
  %2361 = add i32 %2360, -42973499
  %2362 = shl i32 %2360, 3
  %2363 = add i32 %2361, %2362
  %2364 = ashr i32 %2363, 16
  %2365 = xor i32 %2363, %2364
  %2366 = xor i32 %2365, -1252372727
  %2367 = load i32, ptr %53, align 8
  %2368 = add i32 %2367, -1
  %2369 = and i32 %2368, %2366
  %2370 = load ptr, ptr %55, align 8
  %2371 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2372 = sext i32 %2369 to i64
  %2373 = shl nsw i64 %2372, 5
  %2374 = getelementptr i8, ptr %2370, i64 %2373
  %2375 = load ptr, ptr %2374, align 8
  %2376 = icmp ne ptr %2375, @nil_typ
  %2377 = icmp ne ptr %2375, null
  %.not44.i2051 = and i1 %2376, %2377
  br i1 %.not44.i2051, label %2378, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2075

2378:                                             ; preds = %2348
  %2379 = getelementptr i8, ptr %2374, i64 8
  %2380 = load i64, ptr %2379, align 4
  %.sroa_idx.i2055 = getelementptr i8, ptr %2374, i64 16
  %2381 = load i64, ptr %.sroa_idx.i2055, align 4
  %2382 = inttoptr i64 %2380 to ptr
  %2383 = inttoptr i64 %2381 to ptr
  %hash_coef_ptr.i.i46.i2056 = getelementptr i8, ptr %2375, i64 8
  %tbl_size_ptr.i.i47.i2057 = getelementptr i8, ptr %2375, i64 16
  %offset_tbl_ptr.i.i48.i2058 = getelementptr i8, ptr %2375, i64 40
  %hash_coef.i.i49.i2059 = load i64, ptr %hash_coef_ptr.i.i46.i2056, align 4, !noalias !314
  %tbl_size.i.i50.i2060 = load i64, ptr %tbl_size_ptr.i.i47.i2057, align 4, !noalias !314
  %offset_tbl.i.i51.i2061 = load ptr, ptr %offset_tbl_ptr.i.i48.i2058, align 8, !noalias !314
  %product.i.i.i52.i2062 = mul i64 %hash_coef.i.i49.i2059, 4015701072841558310
  %shifted.i.i.i53.i2063 = lshr i64 %product.i.i.i52.i2062, 32
  %xored.i.i.i54.i2064 = xor i64 %shifted.i.i.i53.i2063, %product.i.i.i52.i2062
  %hash.i.i.i55.i2065 = and i64 %xored.i.i.i54.i2064, %tbl_size.i.i50.i2060
  %offset_ptr.i.i56.i2066 = getelementptr i32, ptr %offset_tbl.i.i51.i2061, i64 %hash.i.i.i55.i2065
  %offset.i.i57.i2067 = load i32, ptr %offset_ptr.i.i56.i2066, align 4, !noalias !314
  %2384 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2375, 0
  %2385 = insertvalue { ptr, ptr, ptr, i32 } %2384, ptr %2382, 1
  %2386 = insertvalue { ptr, ptr, ptr, i32 } %2385, ptr %2383, 2
  %2387 = insertvalue { ptr, ptr, ptr, i32 } %2386, i32 %offset.i.i57.i2067, 3
  %2388 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2389 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2375) #34
  %2390 = sext i32 %offset.i.i57.i2067 to i64
  %2391 = getelementptr ptr, ptr %2375, i64 %2390
  %2392 = getelementptr i8, ptr %2391, i64 64
  %2393 = load ptr, ptr %2392, align 8
  %result.i.i2068 = call ptr %2393({ ptr, ptr, ptr, i32 } %2387, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2394 = call i32 %result.i.i2068({ ptr, ptr, ptr, i32 } %2387, { ptr, ptr, ptr, i32 } %2387, ptr nonnull align 8 %2) #7
  %2395 = icmp eq i32 %2394, %2302
  br i1 %2395, label %._crit_edge.i2069, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2075

._crit_edge.i2069:                                ; preds = %2378
  %2396 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2397 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2375)
  %2398 = getelementptr i8, ptr %2391, i64 48
  %2399 = load ptr, ptr %2398, align 8
  %result.i59.i2070 = call ptr %2399({ ptr, ptr, ptr, i32 } %2387, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2400 = call { ptr, i160 } %result.i59.i2070({ ptr, ptr, ptr, i32 } %2387, { ptr, ptr, ptr, i32 } %2387, ptr nonnull align 8 %2) #7
  %2401 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2402 = load ptr, ptr %52, align 8
  %2403 = call i1 %2402({ ptr, i160 } %2400, { ptr, i160 } %2300) #7
  br i1 %2403, label %2404, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2075

2404:                                             ; preds = %._crit_edge.i2069
  %2405 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2406 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2375)
  %2407 = getelementptr i8, ptr %2391, i64 56
  %2408 = load ptr, ptr %2407, align 8
  %result.i60.i2072 = call ptr %2408({ ptr, ptr, ptr, i32 } %2387, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2409 = call { ptr, i160 } %result.i60.i2072({ ptr, ptr, ptr, i32 } %2387, { ptr, ptr, ptr, i32 } %2387, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2073 = extractvalue { ptr, i160 } %2409, 0
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2075

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2075: ; preds = %2348, %2378, %._crit_edge.i2069, %2404
  %2410 = phi ptr [ %.fca.0.extract21.i2073, %2404 ], [ @nil_typ, %._crit_edge.i2069 ], [ @nil_typ, %2348 ], [ @nil_typ, %2378 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2411 = icmp ne ptr %2410, @nil_typ
  %2412 = icmp ne ptr %2410, null
  %.not65.not.not.i1029 = and i1 %2411, %2412
  %cond.fr.i1030 = freeze i1 %.not65.not.not.i1029
  %spec.select.i1031 = select i1 %cond.fr.i1030, ptr %2410, ptr @nil_typ
  br label %HashMap_get_keyK.exit1036

HashMap_get_keyK.exit1036:                        ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2075
  %2413 = phi ptr [ %.fca.0.extract21.i2019, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2021 ], [ %spec.select.i1031, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2075 ]
  %2414 = icmp eq ptr %2413, @nil_typ
  %2415 = icmp eq ptr %2413, null
  %2416 = or i1 %2414, %2415
  br i1 %2416, label %2417, label %._crit_edge5

2417:                                             ; preds = %HashMap_get_keyK.exit1036
  %2418 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %2419 = sext i32 %.0357711 to i64
  %2420 = shl nsw i64 %2419, 2
  %2421 = getelementptr i8, ptr %result.i4.i, i64 %2420
  store i32 %2299, ptr %2421, align 1
  %2422 = add nsw i32 %.0357711, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %2417, %HashMap_get_keyK.exit1036
  %.2 = phi i32 [ %2422, %2417 ], [ %.0357711, %HashMap_get_keyK.exit1036 ]
  %2423 = add nuw nsw i32 %.2360710, 1
  %2424 = icmp slt i32 %.2, %0
  %2425 = icmp slt i32 %2423, %2290
  %spec.select384 = select i1 %2424, i1 %2425, i1 false
  br i1 %spec.select384, label %2295, label %._crit_edge7._crit_edge

._crit_edge7._crit_edge:                          ; preds = %._crit_edge5, %._crit_edge3._crit_edge
  %.0357.lcssa = phi i32 [ 0, %._crit_edge3._crit_edge ], [ %.2, %._crit_edge5 ]
  %2426 = icmp slt i32 %.0357.lcssa, %0
  br i1 %2426, label %._crit_edge.lr.ph.i, label %._crit_edge8

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge7._crit_edge
  %result.i476 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i476, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2427 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2428 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2089 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i2089, ptr noundef nonnull align 32 dereferenceable(29) %result.i476, i64 29, i1 false)
  %2429 = getelementptr i8, ptr %result.i.i2089, i64 29
  store i8 0, ptr %2429, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2089)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2430 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0357.lcssa) #16
  %result.i482 = call noalias align 32 dereferenceable_or_null(23) ptr @bump_malloc_inner(i64 noundef 23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <22 x i8> <i8 32, i8 103, i8 117, i8 97, i8 114, i8 97, i8 110, i8 116, i8 101, i8 101, i8 100, i8 32, i8 109, i8 105, i8 115, i8 115, i8 32, i8 107, i8 101, i8 121, i8 115, i8 46>, ptr %result.i482, align 32
  %2431 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2432 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2433 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2104 = call noalias dereferenceable_or_null(23) ptr @bump_malloc_inner(i64 noundef 23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(22) %result.i.i2104, ptr noundef nonnull align 32 dereferenceable(22) %result.i482, i64 22, i1 false)
  %2434 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2435 = getelementptr i8, ptr %result.i.i2104, i64 22
  store i8 0, ptr %2435, align 1
  %puts.i1085 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2104)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge7._crit_edge, %._crit_edge.lr.ph.i
  %.0380 = phi i32 [ %.0357.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge7._crit_edge ]
  %2436 = call i64 @clock()
  %2437 = icmp sgt i32 %.0380, 0
  br i1 %2437, label %._crit_edge9.preheader, label %2569

._crit_edge9.preheader:                           ; preds = %._crit_edge8
  %2438 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  br label %._crit_edge9

._crit_edge9:                                     ; preds = %._crit_edge9.preheader, %HashMap_get_keyK.exit1131
  %.0365715 = phi i32 [ %.2367, %HashMap_get_keyK.exit1131 ], [ 0, %._crit_edge9.preheader ]
  %.0368714 = phi i32 [ %.2370, %HashMap_get_keyK.exit1131 ], [ 0, %._crit_edge9.preheader ]
  %.0371713 = phi i32 [ %2561, %HashMap_get_keyK.exit1131 ], [ 0, %._crit_edge9.preheader ]
  %2439 = zext nneg i32 %.0371713 to i64
  %2440 = shl nuw nsw i64 %2439, 2
  %2441 = getelementptr i8, ptr %result.i4.i, i64 %2440
  %2442 = load i32, ptr %2441, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %2442 to i160
  %2443 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %2444 = load ptr, ptr %40, align 8
  %2445 = call i32 %2444({ ptr, i160 } %2443) #7
  %2446 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %2447 = load i32, ptr %42, align 8
  %2448 = add i32 %2447, -1
  %2449 = and i32 %2448, %2445
  %2450 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2451 = sext i32 %2449 to i64
  %2452 = shl nsw i64 %2451, 5
  %2453 = getelementptr i8, ptr %2450, i64 %2452
  %2454 = load ptr, ptr %2453, align 8
  %2455 = icmp ne ptr %2454, @nil_typ
  %2456 = icmp ne ptr %2454, null
  %.not44.i2151 = and i1 %2455, %2456
  br i1 %.not44.i2151, label %2457, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175.thread

2457:                                             ; preds = %._crit_edge9
  %2458 = getelementptr i8, ptr %2453, i64 8
  %2459 = load i64, ptr %2458, align 4
  %.sroa_idx.i2155 = getelementptr i8, ptr %2453, i64 16
  %2460 = load i64, ptr %.sroa_idx.i2155, align 4
  %2461 = inttoptr i64 %2459 to ptr
  %2462 = inttoptr i64 %2460 to ptr
  %hash_coef_ptr.i.i46.i2156 = getelementptr i8, ptr %2454, i64 8
  %tbl_size_ptr.i.i47.i2157 = getelementptr i8, ptr %2454, i64 16
  %offset_tbl_ptr.i.i48.i2158 = getelementptr i8, ptr %2454, i64 40
  %hash_coef.i.i49.i2159 = load i64, ptr %hash_coef_ptr.i.i46.i2156, align 4, !noalias !317
  %tbl_size.i.i50.i2160 = load i64, ptr %tbl_size_ptr.i.i47.i2157, align 4, !noalias !317
  %offset_tbl.i.i51.i2161 = load ptr, ptr %offset_tbl_ptr.i.i48.i2158, align 8, !noalias !317
  %product.i.i.i52.i2162 = mul i64 %hash_coef.i.i49.i2159, 4015701072841558310
  %shifted.i.i.i53.i2163 = lshr i64 %product.i.i.i52.i2162, 32
  %xored.i.i.i54.i2164 = xor i64 %shifted.i.i.i53.i2163, %product.i.i.i52.i2162
  %hash.i.i.i55.i2165 = and i64 %xored.i.i.i54.i2164, %tbl_size.i.i50.i2160
  %offset_ptr.i.i56.i2166 = getelementptr i32, ptr %offset_tbl.i.i51.i2161, i64 %hash.i.i.i55.i2165
  %offset.i.i57.i2167 = load i32, ptr %offset_ptr.i.i56.i2166, align 4, !noalias !317
  %2463 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2454, 0
  %2464 = insertvalue { ptr, ptr, ptr, i32 } %2463, ptr %2461, 1
  %2465 = insertvalue { ptr, ptr, ptr, i32 } %2464, ptr %2462, 2
  %2466 = insertvalue { ptr, ptr, ptr, i32 } %2465, i32 %offset.i.i57.i2167, 3
  %2467 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2468 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2454) #34
  %2469 = sext i32 %offset.i.i57.i2167 to i64
  %2470 = getelementptr ptr, ptr %2454, i64 %2469
  %2471 = getelementptr i8, ptr %2470, i64 64
  %2472 = load ptr, ptr %2471, align 8
  %result.i.i2168 = call ptr %2472({ ptr, ptr, ptr, i32 } %2466, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2473 = call i32 %result.i.i2168({ ptr, ptr, ptr, i32 } %2466, { ptr, ptr, ptr, i32 } %2466, ptr nonnull align 8 %2) #7
  %2474 = icmp eq i32 %2473, %2445
  br i1 %2474, label %._crit_edge.i2169, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175.thread

._crit_edge.i2169:                                ; preds = %2457
  %2475 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2476 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2454)
  %2477 = getelementptr i8, ptr %2470, i64 48
  %2478 = load ptr, ptr %2477, align 8
  %result.i59.i2170 = call ptr %2478({ ptr, ptr, ptr, i32 } %2466, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2479 = call { ptr, i160 } %result.i59.i2170({ ptr, ptr, ptr, i32 } %2466, { ptr, ptr, ptr, i32 } %2466, ptr nonnull align 8 %2) #7
  %2480 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2481 = load ptr, ptr %41, align 8
  %2482 = call i1 %2481({ ptr, i160 } %2479, { ptr, i160 } %2443) #7
  br i1 %2482, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175.thread: ; preds = %._crit_edge.i2169, %._crit_edge9, %2457
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2491

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175: ; preds = %._crit_edge.i2169
  %2483 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2484 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2454)
  %2485 = getelementptr i8, ptr %2470, i64 56
  %2486 = load ptr, ptr %2485, align 8
  %result.i60.i2172 = call ptr %2486({ ptr, ptr, ptr, i32 } %2466, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2487 = call { ptr, i160 } %result.i60.i2172({ ptr, ptr, ptr, i32 } %2466, { ptr, ptr, ptr, i32 } %2466, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2173 = extractvalue { ptr, i160 } %2487, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2488 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2489 = icmp ne ptr %.fca.0.extract21.i2173, @nil_typ
  %2490 = icmp ne ptr %.fca.0.extract21.i2173, null
  %.not63.i1120 = and i1 %2489, %2490
  br i1 %.not63.i1120, label %HashMap_get_keyK.exit1131, label %2491

2491:                                             ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175
  %2492 = add i32 %2445, 2127912214
  %2493 = shl i32 %2445, 12
  %2494 = add i32 %2492, %2493
  %2495 = ashr i32 %2494, 19
  %2496 = xor i32 %2494, %2495
  %2497 = xor i32 %2496, -949894596
  %2498 = add i32 %2497, 374761393
  %2499 = shl i32 %2497, 5
  %2500 = add i32 %2498, %2499
  %2501 = add i32 %2500, -744332180
  %2502 = shl i32 %2500, 9
  %2503 = xor i32 %2501, %2502
  %2504 = add i32 %2503, -42973499
  %2505 = shl i32 %2503, 3
  %2506 = add i32 %2504, %2505
  %2507 = ashr i32 %2506, 16
  %2508 = xor i32 %2506, %2507
  %2509 = xor i32 %2508, -1252372727
  %2510 = load i32, ptr %42, align 8
  %2511 = add i32 %2510, -1
  %2512 = and i32 %2511, %2509
  %2513 = load ptr, ptr %44, align 8
  %2514 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2515 = sext i32 %2512 to i64
  %2516 = shl nsw i64 %2515, 5
  %2517 = getelementptr i8, ptr %2513, i64 %2516
  %2518 = load ptr, ptr %2517, align 8
  %2519 = icmp ne ptr %2518, @nil_typ
  %2520 = icmp ne ptr %2518, null
  %.not44.i2205 = and i1 %2519, %2520
  br i1 %.not44.i2205, label %2521, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2229

2521:                                             ; preds = %2491
  %2522 = getelementptr i8, ptr %2517, i64 8
  %2523 = load i64, ptr %2522, align 4
  %.sroa_idx.i2209 = getelementptr i8, ptr %2517, i64 16
  %2524 = load i64, ptr %.sroa_idx.i2209, align 4
  %2525 = inttoptr i64 %2523 to ptr
  %2526 = inttoptr i64 %2524 to ptr
  %hash_coef_ptr.i.i46.i2210 = getelementptr i8, ptr %2518, i64 8
  %tbl_size_ptr.i.i47.i2211 = getelementptr i8, ptr %2518, i64 16
  %offset_tbl_ptr.i.i48.i2212 = getelementptr i8, ptr %2518, i64 40
  %hash_coef.i.i49.i2213 = load i64, ptr %hash_coef_ptr.i.i46.i2210, align 4, !noalias !320
  %tbl_size.i.i50.i2214 = load i64, ptr %tbl_size_ptr.i.i47.i2211, align 4, !noalias !320
  %offset_tbl.i.i51.i2215 = load ptr, ptr %offset_tbl_ptr.i.i48.i2212, align 8, !noalias !320
  %product.i.i.i52.i2216 = mul i64 %hash_coef.i.i49.i2213, 4015701072841558310
  %shifted.i.i.i53.i2217 = lshr i64 %product.i.i.i52.i2216, 32
  %xored.i.i.i54.i2218 = xor i64 %shifted.i.i.i53.i2217, %product.i.i.i52.i2216
  %hash.i.i.i55.i2219 = and i64 %xored.i.i.i54.i2218, %tbl_size.i.i50.i2214
  %offset_ptr.i.i56.i2220 = getelementptr i32, ptr %offset_tbl.i.i51.i2215, i64 %hash.i.i.i55.i2219
  %offset.i.i57.i2221 = load i32, ptr %offset_ptr.i.i56.i2220, align 4, !noalias !320
  %2527 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2518, 0
  %2528 = insertvalue { ptr, ptr, ptr, i32 } %2527, ptr %2525, 1
  %2529 = insertvalue { ptr, ptr, ptr, i32 } %2528, ptr %2526, 2
  %2530 = insertvalue { ptr, ptr, ptr, i32 } %2529, i32 %offset.i.i57.i2221, 3
  %2531 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2532 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2518) #34
  %2533 = sext i32 %offset.i.i57.i2221 to i64
  %2534 = getelementptr ptr, ptr %2518, i64 %2533
  %2535 = getelementptr i8, ptr %2534, i64 64
  %2536 = load ptr, ptr %2535, align 8
  %result.i.i2222 = call ptr %2536({ ptr, ptr, ptr, i32 } %2530, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2537 = call i32 %result.i.i2222({ ptr, ptr, ptr, i32 } %2530, { ptr, ptr, ptr, i32 } %2530, ptr nonnull align 8 %2) #7
  %2538 = icmp eq i32 %2537, %2445
  br i1 %2538, label %._crit_edge.i2223, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2229

._crit_edge.i2223:                                ; preds = %2521
  %2539 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2540 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2518)
  %2541 = getelementptr i8, ptr %2534, i64 48
  %2542 = load ptr, ptr %2541, align 8
  %result.i59.i2224 = call ptr %2542({ ptr, ptr, ptr, i32 } %2530, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2543 = call { ptr, i160 } %result.i59.i2224({ ptr, ptr, ptr, i32 } %2530, { ptr, ptr, ptr, i32 } %2530, ptr nonnull align 8 %2) #7
  %2544 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2545 = load ptr, ptr %41, align 8
  %2546 = call i1 %2545({ ptr, i160 } %2543, { ptr, i160 } %2443) #7
  br i1 %2546, label %2547, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2229

2547:                                             ; preds = %._crit_edge.i2223
  %2548 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2549 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2518)
  %2550 = getelementptr i8, ptr %2534, i64 56
  %2551 = load ptr, ptr %2550, align 8
  %result.i60.i2226 = call ptr %2551({ ptr, ptr, ptr, i32 } %2530, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2552 = call { ptr, i160 } %result.i60.i2226({ ptr, ptr, ptr, i32 } %2530, { ptr, ptr, ptr, i32 } %2530, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2227 = extractvalue { ptr, i160 } %2552, 0
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2229

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2229: ; preds = %2491, %2521, %._crit_edge.i2223, %2547
  %2553 = phi ptr [ %.fca.0.extract21.i2227, %2547 ], [ @nil_typ, %._crit_edge.i2223 ], [ @nil_typ, %2491 ], [ @nil_typ, %2521 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2554 = icmp ne ptr %2553, @nil_typ
  %2555 = icmp ne ptr %2553, null
  %.not65.not.not.i1124 = and i1 %2554, %2555
  %cond.fr.i1125 = freeze i1 %.not65.not.not.i1124
  %spec.select.i1126 = select i1 %cond.fr.i1125, ptr %2553, ptr @nil_typ
  br label %HashMap_get_keyK.exit1131

HashMap_get_keyK.exit1131:                        ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2229
  %2556 = phi ptr [ %.fca.0.extract21.i2173, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2175 ], [ %spec.select.i1126, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2229 ]
  %2557 = icmp eq ptr %2556, @nil_typ
  %2558 = icmp eq ptr %2556, null
  %2559 = or i1 %2557, %2558
  %.0365..0368 = select i1 %2559, i32 %.0365715, i32 %.0368714
  %2560 = add i32 %.0365..0368, 1
  %.2370 = select i1 %2559, i32 %.0368714, i32 %2560
  %.2367 = select i1 %2559, i32 %2560, i32 %.0365715
  %2561 = add nuw nsw i32 %.0371713, 1
  %2562 = icmp slt i32 %2561, %.0380
  br i1 %2562, label %._crit_edge9, label %2563

2563:                                             ; preds = %HashMap_get_keyK.exit1131
  %2564 = call i64 @clock()
  %2565 = mul i32 %.2370, 100
  %2566 = sdiv i32 %2565, %.0380
  %2567 = icmp slt i32 %2566, 5
  %2568 = select i1 %2567, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  br label %._crit_edge.lr.ph.i2244

2569:                                             ; preds = %._crit_edge8
  %2570 = call i64 @clock()
  br label %._crit_edge.lr.ph.i2244

._crit_edge.lr.ph.i2244:                          ; preds = %2569, %2563
  %2571 = phi i64 [ %2564, %2563 ], [ %2570, %2569 ]
  %.0365.lcssa722 = phi i32 [ %.2367, %2563 ], [ 0, %2569 ]
  %.0368.lcssa720 = phi i32 [ %.2370, %2563 ], [ 0, %2569 ]
  %.reg2mem27.0.in = phi <4 x i8> [ %2568, %2563 ], [ <i8 80, i8 65, i8 83, i8 83>, %2569 ]
  %result.i489 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %result.i489, align 16
  %2572 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2573 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2574 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2243 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i2243, ptr noundef nonnull align 16 dereferenceable(15) %result.i489, i64 15, i1 false)
  %2575 = sub i64 %2571, %2436
  %2576 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2577 = getelementptr i8, ptr %result.i.i2243, i64 15
  store i8 0, ptr %2577, align 1
  %puts.i1151 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2243)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i376.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376.i)
  %2578 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0380) #16
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i390.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390.i)
  %2579 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2575) #16
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i409.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409.i)
  br i1 %2437, label %._crit_edge1.i, label %._crit_edge.lr.ph.i2263

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i2244
  %2580 = icmp sgt i64 %2575, 0
  br i1 %2580, label %2581, label %._crit_edge.lr.ph.i429.i

2581:                                             ; preds = %._crit_edge1.i
  %2582 = zext nneg i32 %.0380 to i64
  %2583 = mul i64 %2575, 1000000
  %2584 = sdiv i64 %2583, %2582
  br label %._crit_edge.lr.ph.i429.i

._crit_edge.lr.ph.i429.i:                         ; preds = %2581, %._crit_edge1.i
  %.0.i = phi i64 [ %2584, %2581 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i428.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i)
  %2585 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #16
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %result.i.i447.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %puts.i374.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447.i)
  br label %._crit_edge.lr.ph.i2263

._crit_edge.lr.ph.i2263:                          ; preds = %._crit_edge.lr.ph.i2244, %._crit_edge.lr.ph.i429.i
  %result.i493 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i493, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2586 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2587 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2262 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i2262, ptr noundef nonnull align 32 dereferenceable(18) %result.i493, i64 18, i1 false)
  %2588 = getelementptr i8, ptr %result.i.i2262, i64 18
  store i8 0, ptr %2588, align 1
  %puts.i1171 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2262)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2589 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2590 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2281 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %.reg2mem27.0.in, ptr %result.i.i2281, align 1
  %2591 = getelementptr i8, ptr %result.i.i2281, i64 4
  store i8 0, ptr %2591, align 1
  %puts.i1191 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2281)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i508 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <13 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %result.i508, align 16
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2592 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2593 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2300 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i2300, ptr noundef nonnull align 16 dereferenceable(13) %result.i508, i64 13, i1 false)
  %2594 = getelementptr i8, ptr %result.i.i2300, i64 13
  store i8 0, ptr %2594, align 1
  %puts.i1211 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2300)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2595 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0365.lcssa722) #16
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2596 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2597 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2319 = call noalias dereferenceable_or_null(9) ptr @bump_malloc_inner(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i64 2322295501682647084, ptr %result.i.i2319, align 1
  %2598 = getelementptr i8, ptr %result.i.i2319, i64 8
  store i8 0, ptr %2598, align 1
  %puts.i1231 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2319)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2599 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0368.lcssa720) #16
  %2600 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2601 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2602 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2338 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i8 41, ptr %result.i.i2338, align 1
  %2603 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2604 = getelementptr i8, ptr %result.i.i2338, i64 1
  store i8 0, ptr %2604, align 1
  %puts.i1251 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2338)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca i32, align 4
  %28 = alloca i32, align 4
  %29 = alloca i32, align 4
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i32, align 4
  %34 = alloca i32, align 4
  %oldProtect.i427 = alloca i32, align 4
  %oldProtect.i423 = alloca i32, align 4
  %oldProtect.i382 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0316.sroa.0 = alloca i8, align 8
  %result.i378 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i378, align 8
  %35 = getelementptr inbounds i8, ptr %result.i378, i64 8
  store ptr @_parameterization_Ptri32, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i378, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %36, align 8
  %37 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i378) #38
  %result.i379 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i380 = call i32 @VirtualProtect(ptr nofree %result.i379, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i379, ptr noalias nofree noundef nonnull readnone @zbeuwobpin, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i379) #39
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i379) #38
  %result.i381 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i382)
  %result.i383 = call i32 @VirtualProtect(ptr nofree %result.i381, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i382) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i382)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i381, ptr noalias nofree noundef nonnull readnone @vdgbvvguid, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i384 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i381) #39
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i381) #38
  %40 = getelementptr inbounds i8, ptr %result.i378, i64 48
  store ptr %ret.i, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %result.i378, i64 56
  store ptr %ret.i384, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i378, i64 40
  store i32 8, ptr %42, align 8
  %result.i.i735 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %43 = getelementptr inbounds i8, ptr %result.i378, i64 24
  store ptr %result.i.i735, ptr %43, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %44 = getelementptr inbounds i8, ptr %result.i378, i64 32
  store ptr %result.i9.i, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %46 = sext i32 %0 to i64
  %47 = shl nsw i64 %46, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %47, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %result.i421 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i421, align 8
  %49 = getelementptr inbounds i8, ptr %result.i421, i64 8
  store ptr @_parameterization_Ptri1, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i421, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i421)
  %result.i422 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i423)
  %result.i424 = call i32 @VirtualProtect(ptr nofree %result.i422, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i423) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i423)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i422, ptr noalias nofree noundef nonnull readnone @sshndfvtsv, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i425 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i422) #39
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i422)
  %result.i426 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i427)
  %result.i428 = call i32 @VirtualProtect(ptr nofree %result.i426, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i427) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i427)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i426, ptr noalias nofree noundef nonnull readnone @jtsshqxerx, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i429 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i426) #39
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i426)
  %54 = getelementptr inbounds i8, ptr %result.i421, i64 48
  store ptr %ret.i425, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i421, i64 56
  store ptr %ret.i429, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %result.i421, i64 40
  store i32 8, ptr %56, align 8
  %result.i.i775 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %57 = getelementptr inbounds i8, ptr %result.i421, i64 24
  store ptr %result.i.i775, ptr %57, align 8
  %result.i9.i776 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %58 = getelementptr inbounds i8, ptr %result.i421, i64 32
  store ptr %result.i9.i776, ptr %58, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %60 = mul i32 %0, 10
  %61 = icmp sgt i32 %0, 0
  %62 = icmp sgt i32 %60, 0
  %spec.select714 = and i1 %61, %62
  br i1 %spec.select714, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %65 = getelementptr inbounds i8, ptr %result.i378, i64 44
  %66 = getelementptr inbounds i8, ptr %result.i421, i64 44
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  br label %68

68:                                               ; preds = %.lr.ph, %._crit_edge1
  %69 = phi i32 [ 101112, %.lr.ph ], [ %72, %._crit_edge1 ]
  %.0355716 = phi i32 [ 0, %.lr.ph ], [ %2291, %._crit_edge1 ]
  %.0357715 = phi i32 [ 0, %.lr.ph ], [ %.2359, %._crit_edge1 ]
  %70 = mul i32 %69, 1103515245
  %71 = add i32 %70, 12345
  %72 = and i32 %71, 2147483647
  %.sroa.0343.0.insert.ext = zext nneg i32 %72 to i160
  %73 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0343.0.insert.ext, 1
  %74 = load ptr, ptr %54, align 8
  %75 = call i32 %74({ ptr, i160 } %73) #7
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %77 = load i32, ptr %56, align 8
  %78 = add i32 %77, -1
  %79 = and i32 %78, %75
  %80 = load ptr, ptr %57, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %81 = sext i32 %79 to i64
  %82 = shl nsw i64 %81, 5
  %83 = getelementptr i8, ptr %80, i64 %82
  %84 = load ptr, ptr %83, align 8
  %85 = icmp ne ptr %84, @nil_typ
  %86 = icmp ne ptr %84, null
  %.not44.i = and i1 %85, %86
  br i1 %.not44.i, label %87, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

87:                                               ; preds = %68
  %88 = getelementptr i8, ptr %83, i64 8
  %89 = load i64, ptr %88, align 4
  %.sroa_idx.i = getelementptr i8, ptr %83, i64 16
  %90 = load i64, ptr %.sroa_idx.i, align 4
  %91 = inttoptr i64 %89 to ptr
  %92 = inttoptr i64 %90 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %84, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %84, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %84, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !323
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !323
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !323
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !323
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %84, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %91, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %92, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %offset.i.i57.i, 3
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84) #34
  %99 = sext i32 %offset.i.i57.i to i64
  %100 = getelementptr ptr, ptr %84, i64 %99
  %101 = getelementptr i8, ptr %100, i64 64
  %102 = load ptr, ptr %101, align 8
  %result.i.i = call ptr %102({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #15
  %103 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %104 = icmp eq i32 %103, %75
  br i1 %104, label %._crit_edge.i1332, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i1332:                                ; preds = %87
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84)
  %107 = getelementptr i8, ptr %100, i64 48
  %108 = load ptr, ptr %107, align 8
  %result.i59.i = call ptr %108({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #15
  %109 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %111 = load ptr, ptr %55, align 8
  %112 = call i1 %111({ ptr, i160 } %109, { ptr, i160 } %73) #7
  br i1 %112, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i1332, %68, %87
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %121

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1332
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84)
  %115 = getelementptr i8, ptr %100, i64 56
  %116 = load ptr, ptr %115, align 8
  %result.i60.i = call ptr %116({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #15
  %117 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %117, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %119 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %120 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %119, %120
  br i1 %.not63.i, label %HashMap_get_keyK.exit, label %121

121:                                              ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %122 = add i32 %75, 2127912214
  %123 = shl i32 %75, 12
  %124 = add i32 %122, %123
  %125 = ashr i32 %124, 19
  %126 = xor i32 %124, %125
  %127 = xor i32 %126, -949894596
  %128 = add i32 %127, 374761393
  %129 = shl i32 %127, 5
  %130 = add i32 %128, %129
  %131 = add i32 %130, -744332180
  %132 = shl i32 %130, 9
  %133 = xor i32 %131, %132
  %134 = add i32 %133, -42973499
  %135 = shl i32 %133, 3
  %136 = add i32 %134, %135
  %137 = ashr i32 %136, 16
  %138 = xor i32 %136, %137
  %139 = xor i32 %138, -1252372727
  %140 = load i32, ptr %56, align 8
  %141 = add i32 %140, -1
  %142 = and i32 %141, %139
  %143 = load ptr, ptr %58, align 8
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %145 = sext i32 %142 to i64
  %146 = shl nsw i64 %145, 5
  %147 = getelementptr i8, ptr %143, i64 %146
  %148 = load ptr, ptr %147, align 8
  %149 = icmp ne ptr %148, @nil_typ
  %150 = icmp ne ptr %148, null
  %.not44.i1361 = and i1 %149, %150
  br i1 %.not44.i1361, label %151, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1385

151:                                              ; preds = %121
  %152 = getelementptr i8, ptr %147, i64 8
  %153 = load i64, ptr %152, align 4
  %.sroa_idx.i1365 = getelementptr i8, ptr %147, i64 16
  %154 = load i64, ptr %.sroa_idx.i1365, align 4
  %155 = inttoptr i64 %153 to ptr
  %156 = inttoptr i64 %154 to ptr
  %hash_coef_ptr.i.i46.i1366 = getelementptr i8, ptr %148, i64 8
  %tbl_size_ptr.i.i47.i1367 = getelementptr i8, ptr %148, i64 16
  %offset_tbl_ptr.i.i48.i1368 = getelementptr i8, ptr %148, i64 40
  %hash_coef.i.i49.i1369 = load i64, ptr %hash_coef_ptr.i.i46.i1366, align 4, !noalias !326
  %tbl_size.i.i50.i1370 = load i64, ptr %tbl_size_ptr.i.i47.i1367, align 4, !noalias !326
  %offset_tbl.i.i51.i1371 = load ptr, ptr %offset_tbl_ptr.i.i48.i1368, align 8, !noalias !326
  %product.i.i.i52.i1372 = mul i64 %hash_coef.i.i49.i1369, 4015701072841558310
  %shifted.i.i.i53.i1373 = lshr i64 %product.i.i.i52.i1372, 32
  %xored.i.i.i54.i1374 = xor i64 %shifted.i.i.i53.i1373, %product.i.i.i52.i1372
  %hash.i.i.i55.i1375 = and i64 %xored.i.i.i54.i1374, %tbl_size.i.i50.i1370
  %offset_ptr.i.i56.i1376 = getelementptr i32, ptr %offset_tbl.i.i51.i1371, i64 %hash.i.i.i55.i1375
  %offset.i.i57.i1377 = load i32, ptr %offset_ptr.i.i56.i1376, align 4, !noalias !326
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %148, 0
  %158 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %155, 1
  %159 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %156, 2
  %160 = insertvalue { ptr, ptr, ptr, i32 } %159, i32 %offset.i.i57.i1377, 3
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148) #34
  %163 = sext i32 %offset.i.i57.i1377 to i64
  %164 = getelementptr ptr, ptr %148, i64 %163
  %165 = getelementptr i8, ptr %164, i64 64
  %166 = load ptr, ptr %165, align 8
  %result.i.i1378 = call ptr %166({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #15
  %167 = call i32 %result.i.i1378({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %168 = icmp eq i32 %167, %75
  br i1 %168, label %._crit_edge.i1379, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1385

._crit_edge.i1379:                                ; preds = %151
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148)
  %171 = getelementptr i8, ptr %164, i64 48
  %172 = load ptr, ptr %171, align 8
  %result.i59.i1380 = call ptr %172({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #15
  %173 = call { ptr, i160 } %result.i59.i1380({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %175 = load ptr, ptr %55, align 8
  %176 = call i1 %175({ ptr, i160 } %173, { ptr, i160 } %73) #7
  br i1 %176, label %177, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1385

177:                                              ; preds = %._crit_edge.i1379
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148)
  %180 = getelementptr i8, ptr %164, i64 56
  %181 = load ptr, ptr %180, align 8
  %result.i60.i1382 = call ptr %181({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #15
  %182 = call { ptr, i160 } %result.i60.i1382({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1383 = extractvalue { ptr, i160 } %182, 0
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1385

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1385: ; preds = %121, %151, %._crit_edge.i1379, %177
  %183 = phi ptr [ %.fca.0.extract21.i1383, %177 ], [ @nil_typ, %._crit_edge.i1379 ], [ @nil_typ, %121 ], [ @nil_typ, %151 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %184 = icmp ne ptr %183, @nil_typ
  %185 = icmp ne ptr %183, null
  %.not65.not.not.i = and i1 %184, %185
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %183, ptr @nil_typ
  br label %HashMap_get_keyK.exit

HashMap_get_keyK.exit:                            ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1385
  %186 = phi ptr [ %.fca.0.extract21.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1385 ]
  %187 = icmp eq ptr %186, @nil_typ
  %188 = icmp eq ptr %186, null
  %189 = or i1 %187, %188
  br i1 %189, label %190, label %._crit_edge1

190:                                              ; preds = %HashMap_get_keyK.exit
  %191 = add nuw i32 %72, 1
  %.sroa.0326.0.insert.ext = zext i32 %191 to i160
  %192 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0326.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %193 = load ptr, ptr %result.i378, align 8
  %194 = load ptr, ptr %40, align 8
  %195 = call i32 %194({ ptr, i160 } %73) #7
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %197 = load i32, ptr %42, align 8
  %198 = add i32 %197, -1
  %199 = and i32 %198, %195
  %200 = load ptr, ptr %43, align 8
  %201 = load ptr, ptr %35, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %202 = sext i32 %199 to i64
  %203 = shl nsw i64 %202, 5
  %204 = getelementptr i8, ptr %200, i64 %203
  %205 = load ptr, ptr %204, align 8
  %206 = getelementptr i8, ptr %204, i64 8
  %207 = icmp ne ptr %205, @nil_typ
  %208 = icmp ne ptr %205, null
  %.not64.i = and i1 %207, %208
  br i1 %.not64.i, label %209, label %306

209:                                              ; preds = %190
  %210 = load i64, ptr %206, align 4
  %.sroa_idx.i1426 = getelementptr i8, ptr %204, i64 16
  %211 = load i64, ptr %.sroa_idx.i1426, align 4
  %212 = inttoptr i64 %210 to ptr
  %213 = inttoptr i64 %211 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %205, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %205, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %205, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !329
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !329
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !329
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !329
  %214 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %205, 0
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %212, 1
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, ptr %213, 2
  %217 = insertvalue { ptr, ptr, ptr, i32 } %216, i32 %offset.i.i77.i, 3
  %218 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %205) #34
  %220 = sext i32 %offset.i.i77.i to i64
  %221 = getelementptr ptr, ptr %205, i64 %220
  %222 = getelementptr i8, ptr %221, i64 64
  %223 = load ptr, ptr %222, align 8
  %result.i.i1427 = call ptr %223({ ptr, ptr, ptr, i32 } %217, ptr nocapture nofree noundef nonnull readonly %2) #15
  %224 = call i32 %result.i.i1427({ ptr, ptr, ptr, i32 } %217, { ptr, ptr, ptr, i32 } %217, ptr nonnull align 8 %2) #7
  %225 = icmp eq i32 %224, %195
  br i1 %225, label %._crit_edge.i1428, label %306

._crit_edge.i1428:                                ; preds = %209
  %226 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %227 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %205)
  %228 = getelementptr i8, ptr %221, i64 48
  %229 = load ptr, ptr %228, align 8
  %result.i79.i = call ptr %229({ ptr, ptr, ptr, i32 } %217, ptr nocapture nofree noundef nonnull readonly %2) #15
  %230 = call { ptr, i160 } %result.i79.i({ ptr, ptr, ptr, i32 } %217, { ptr, ptr, ptr, i32 } %217, ptr nonnull align 8 %2) #7
  %231 = load ptr, ptr %41, align 8
  %232 = call i1 %231({ ptr, i160 } %230, { ptr, i160 } %73) #7
  br i1 %232, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %306

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1428
  %233 = load ptr, ptr %result.i378, align 8
  %234 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %235 = load ptr, ptr %35, align 8
  %236 = load ptr, ptr %233, align 8, !alias.scope !332
  %237 = getelementptr i8, ptr %236, i64 72
  %238 = load ptr, ptr %237, align 8, !alias.scope !332
  %result.i.i.i1429 = call { i64, i64 } %238(ptr nocapture nofree nonnull readonly %233) #5, !alias.scope !332
  %239 = extractvalue { i64, i64 } %result.i.i.i1429, 0
  %240 = extractvalue { i64, i64 } %result.i.i.i1429, 1
  %241 = urem i64 20, %240
  %242 = icmp eq i64 %241, 0
  %243 = sub i64 %240, %241
  %244 = select i1 %242, i64 0, i64 %243
  %245 = add i64 %239, 20
  %246 = add i64 %245, %244
  %247 = load ptr, ptr %235, align 8, !alias.scope !332
  %248 = getelementptr i8, ptr %247, i64 72
  %249 = load ptr, ptr %248, align 8, !alias.scope !332
  %result.i1.i.i1430 = call { i64, i64 } %249(ptr nocapture nofree nonnull readonly %235) #5, !alias.scope !332
  %250 = extractvalue { i64, i64 } %result.i1.i.i1430, 0
  %251 = extractvalue { i64, i64 } %result.i1.i.i1430, 1
  %252 = call i64 @llvm.umax.i64(i64 %240, i64 %251)
  %253 = call i64 @llvm.umax.i64(i64 %252, i64 8)
  %254 = urem i64 %246, %251
  %255 = icmp eq i64 %254, 0
  %256 = sub i64 %251, %254
  %257 = select i1 %255, i64 0, i64 %256
  %258 = add i64 %250, %246
  %259 = add i64 %258, %257
  %260 = urem i64 %259, %253
  %261 = icmp eq i64 %260, 0
  %262 = sub i64 %253, %260
  %263 = select i1 %261, i64 0, i64 %262
  %264 = add i64 %263, %259
  %result.i83.i1431 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %264, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %233, ptr %result.i83.i1431, align 8
  %265 = getelementptr inbounds i8, ptr %result.i83.i1431, i64 8
  store ptr %235, ptr %265, align 8
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1431)
  %267 = load ptr, ptr %233, align 8
  %268 = getelementptr i8, ptr %267, i64 72
  %269 = load ptr, ptr %268, align 8
  %result.i.i114.i = call { i64, i64 } %269(ptr nocapture nofree nonnull readonly %233) #5
  %270 = extractvalue { i64, i64 } %result.i.i114.i, 1
  %271 = urem i64 20, %270
  %272 = icmp eq i64 %271, 0
  %reass.sub4325 = sub i64 %270, %271
  %273 = add i64 %reass.sub4325, 20
  %274 = select i1 %272, i64 20, i64 %273
  %275 = getelementptr i8, ptr %result.i83.i1431, i64 %274
  %276 = getelementptr i8, ptr %267, i64 64
  %277 = load ptr, ptr %276, align 8
  call void %277({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %233, ptr nocapture nofree writeonly %275) #12
  %278 = load ptr, ptr %result.i83.i1431, align 8
  %279 = load ptr, ptr %278, align 8
  %280 = getelementptr i8, ptr %279, i64 72
  %281 = load ptr, ptr %280, align 8
  %result.i.i115.i = call { i64, i64 } %281(ptr nocapture nofree nonnull readonly %278) #5
  %282 = extractvalue { i64, i64 } %result.i.i115.i, 0
  %283 = extractvalue { i64, i64 } %result.i.i115.i, 1
  %284 = urem i64 20, %283
  %285 = icmp eq i64 %284, 0
  %286 = sub i64 %283, %284
  %287 = select i1 %285, i64 0, i64 %286
  %288 = add i64 %282, 20
  %289 = add i64 %288, %287
  %290 = load ptr, ptr %265, align 8
  %291 = load ptr, ptr %290, align 8
  %292 = getelementptr i8, ptr %291, i64 72
  %293 = load ptr, ptr %292, align 8
  %result.i1.i116.i = call { i64, i64 } %293(ptr nocapture nofree nonnull readonly %290) #5
  %294 = extractvalue { i64, i64 } %result.i1.i116.i, 1
  %295 = urem i64 %289, %294
  %296 = icmp eq i64 %295, 0
  %297 = sub i64 %294, %295
  %298 = select i1 %296, i64 0, i64 %297
  %299 = getelementptr i8, ptr %result.i83.i1431, i64 %289
  %300 = getelementptr i8, ptr %299, i64 %298
  %301 = getelementptr i8, ptr %291, i64 64
  %302 = load ptr, ptr %301, align 8
  call void %302({ ptr, i160 } %192, ptr nocapture nofree nonnull readonly %290, ptr nocapture nofree writeonly %300) #12
  %303 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %304 = getelementptr inbounds i8, ptr %result.i83.i1431, i64 16
  store i32 %195, ptr %304, align 8
  store ptr @Entry, ptr %204, align 8
  %305 = ptrtoint ptr %result.i83.i1431 to i64
  store i64 %305, ptr %206, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %204, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

306:                                              ; preds = %._crit_edge.i1428, %190, %209
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %307 = add i32 %195, 2127912214
  %308 = shl i32 %195, 12
  %309 = add i32 %307, %308
  %310 = ashr i32 %309, 19
  %311 = xor i32 %309, %310
  %312 = xor i32 %311, -949894596
  %313 = add i32 %312, 374761393
  %314 = shl i32 %312, 5
  %315 = add i32 %313, %314
  %316 = add i32 %315, -744332180
  %317 = shl i32 %315, 9
  %318 = xor i32 %316, %317
  %319 = add i32 %318, -42973499
  %320 = shl i32 %318, 3
  %321 = add i32 %319, %320
  %322 = ashr i32 %321, 16
  %323 = xor i32 %321, %322
  %324 = xor i32 %323, -1252372727
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %326 = load i32, ptr %42, align 8
  %327 = add i32 %326, -1
  %328 = and i32 %327, %324
  %329 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %330 = sext i32 %328 to i64
  %331 = shl nsw i64 %330, 5
  %332 = getelementptr i8, ptr %329, i64 %331
  %333 = load ptr, ptr %332, align 8
  %334 = getelementptr i8, ptr %332, i64 8
  %335 = icmp ne ptr %333, @nil_typ
  %336 = icmp ne ptr %333, null
  %.not64.i1461 = and i1 %335, %336
  br i1 %.not64.i1461, label %337, label %435

337:                                              ; preds = %306
  %338 = load i64, ptr %334, align 4
  %.sroa_idx.i1463 = getelementptr i8, ptr %332, i64 16
  %339 = load i64, ptr %.sroa_idx.i1463, align 4
  %340 = inttoptr i64 %338 to ptr
  %341 = inttoptr i64 %339 to ptr
  %hash_coef_ptr.i.i66.i1464 = getelementptr i8, ptr %333, i64 8
  %tbl_size_ptr.i.i67.i1465 = getelementptr i8, ptr %333, i64 16
  %offset_tbl_ptr.i.i68.i1466 = getelementptr i8, ptr %333, i64 40
  %hash_coef.i.i69.i1467 = load i64, ptr %hash_coef_ptr.i.i66.i1464, align 4, !noalias !335
  %tbl_size.i.i70.i1468 = load i64, ptr %tbl_size_ptr.i.i67.i1465, align 4, !noalias !335
  %offset_tbl.i.i71.i1469 = load ptr, ptr %offset_tbl_ptr.i.i68.i1466, align 8, !noalias !335
  %product.i.i.i72.i1470 = mul i64 %hash_coef.i.i69.i1467, 4015701072841558310
  %shifted.i.i.i73.i1471 = lshr i64 %product.i.i.i72.i1470, 32
  %xored.i.i.i74.i1472 = xor i64 %shifted.i.i.i73.i1471, %product.i.i.i72.i1470
  %hash.i.i.i75.i1473 = and i64 %xored.i.i.i74.i1472, %tbl_size.i.i70.i1468
  %offset_ptr.i.i76.i1474 = getelementptr i32, ptr %offset_tbl.i.i71.i1469, i64 %hash.i.i.i75.i1473
  %offset.i.i77.i1475 = load i32, ptr %offset_ptr.i.i76.i1474, align 4, !noalias !335
  %342 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %333, 0
  %343 = insertvalue { ptr, ptr, ptr, i32 } %342, ptr %340, 1
  %344 = insertvalue { ptr, ptr, ptr, i32 } %343, ptr %341, 2
  %345 = insertvalue { ptr, ptr, ptr, i32 } %344, i32 %offset.i.i77.i1475, 3
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %333) #34
  %348 = sext i32 %offset.i.i77.i1475 to i64
  %349 = getelementptr ptr, ptr %333, i64 %348
  %350 = getelementptr i8, ptr %349, i64 64
  %351 = load ptr, ptr %350, align 8
  %result.i.i1476 = call ptr %351({ ptr, ptr, ptr, i32 } %345, ptr nocapture nofree noundef nonnull readonly %2) #15
  %352 = call i32 %result.i.i1476({ ptr, ptr, ptr, i32 } %345, { ptr, ptr, ptr, i32 } %345, ptr nonnull align 8 %2) #7
  %353 = icmp eq i32 %352, %195
  br i1 %353, label %._crit_edge.i1477, label %435

._crit_edge.i1477:                                ; preds = %337
  %354 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %355 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %333)
  %356 = getelementptr i8, ptr %349, i64 48
  %357 = load ptr, ptr %356, align 8
  %result.i79.i1478 = call ptr %357({ ptr, ptr, ptr, i32 } %345, ptr nocapture nofree noundef nonnull readonly %2) #15
  %358 = call { ptr, i160 } %result.i79.i1478({ ptr, ptr, ptr, i32 } %345, { ptr, ptr, ptr, i32 } %345, ptr nonnull align 8 %2) #7
  %359 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %360 = load ptr, ptr %41, align 8
  %361 = call i1 %360({ ptr, i160 } %358, { ptr, i160 } %73) #7
  br i1 %361, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1490, label %435

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1490: ; preds = %._crit_edge.i1477
  %362 = load ptr, ptr %result.i378, align 8
  %363 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %364 = load ptr, ptr %35, align 8
  %365 = load ptr, ptr %362, align 8, !alias.scope !338
  %366 = getelementptr i8, ptr %365, i64 72
  %367 = load ptr, ptr %366, align 8, !alias.scope !338
  %result.i.i.i1482 = call { i64, i64 } %367(ptr nocapture nofree nonnull readonly %362) #5, !alias.scope !338
  %368 = extractvalue { i64, i64 } %result.i.i.i1482, 0
  %369 = extractvalue { i64, i64 } %result.i.i.i1482, 1
  %370 = urem i64 20, %369
  %371 = icmp eq i64 %370, 0
  %372 = sub i64 %369, %370
  %373 = select i1 %371, i64 0, i64 %372
  %374 = add i64 %368, 20
  %375 = add i64 %374, %373
  %376 = load ptr, ptr %364, align 8, !alias.scope !338
  %377 = getelementptr i8, ptr %376, i64 72
  %378 = load ptr, ptr %377, align 8, !alias.scope !338
  %result.i1.i.i1483 = call { i64, i64 } %378(ptr nocapture nofree nonnull readonly %364) #5, !alias.scope !338
  %379 = extractvalue { i64, i64 } %result.i1.i.i1483, 0
  %380 = extractvalue { i64, i64 } %result.i1.i.i1483, 1
  %381 = call i64 @llvm.umax.i64(i64 %369, i64 %380)
  %382 = call i64 @llvm.umax.i64(i64 %381, i64 8)
  %383 = urem i64 %375, %380
  %384 = icmp eq i64 %383, 0
  %385 = sub i64 %380, %383
  %386 = select i1 %384, i64 0, i64 %385
  %387 = add i64 %379, %375
  %388 = add i64 %387, %386
  %389 = urem i64 %388, %382
  %390 = icmp eq i64 %389, 0
  %391 = sub i64 %382, %389
  %392 = select i1 %390, i64 0, i64 %391
  %393 = add i64 %392, %388
  %result.i83.i1484 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %393, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %362, ptr %result.i83.i1484, align 8
  %394 = getelementptr inbounds i8, ptr %result.i83.i1484, i64 8
  store ptr %364, ptr %394, align 8
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1484)
  %396 = load ptr, ptr %362, align 8
  %397 = getelementptr i8, ptr %396, i64 72
  %398 = load ptr, ptr %397, align 8
  %result.i.i114.i1485 = call { i64, i64 } %398(ptr nocapture nofree nonnull readonly %362) #5
  %399 = extractvalue { i64, i64 } %result.i.i114.i1485, 1
  %400 = urem i64 20, %399
  %401 = icmp eq i64 %400, 0
  %reass.sub4324 = sub i64 %399, %400
  %402 = add i64 %reass.sub4324, 20
  %403 = select i1 %401, i64 20, i64 %402
  %404 = getelementptr i8, ptr %result.i83.i1484, i64 %403
  %405 = getelementptr i8, ptr %396, i64 64
  %406 = load ptr, ptr %405, align 8
  call void %406({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %362, ptr nocapture nofree writeonly %404) #12
  %407 = load ptr, ptr %result.i83.i1484, align 8
  %408 = load ptr, ptr %407, align 8
  %409 = getelementptr i8, ptr %408, i64 72
  %410 = load ptr, ptr %409, align 8
  %result.i.i115.i1487 = call { i64, i64 } %410(ptr nocapture nofree nonnull readonly %407) #5
  %411 = extractvalue { i64, i64 } %result.i.i115.i1487, 0
  %412 = extractvalue { i64, i64 } %result.i.i115.i1487, 1
  %413 = urem i64 20, %412
  %414 = icmp eq i64 %413, 0
  %415 = sub i64 %412, %413
  %416 = select i1 %414, i64 0, i64 %415
  %417 = add i64 %411, 20
  %418 = add i64 %417, %416
  %419 = load ptr, ptr %394, align 8
  %420 = load ptr, ptr %419, align 8
  %421 = getelementptr i8, ptr %420, i64 72
  %422 = load ptr, ptr %421, align 8
  %result.i1.i116.i1488 = call { i64, i64 } %422(ptr nocapture nofree nonnull readonly %419) #5
  %423 = extractvalue { i64, i64 } %result.i1.i116.i1488, 1
  %424 = urem i64 %418, %423
  %425 = icmp eq i64 %424, 0
  %426 = sub i64 %423, %424
  %427 = select i1 %425, i64 0, i64 %426
  %428 = getelementptr i8, ptr %result.i83.i1484, i64 %418
  %429 = getelementptr i8, ptr %428, i64 %427
  %430 = getelementptr i8, ptr %420, i64 64
  %431 = load ptr, ptr %430, align 8
  call void %431({ ptr, i160 } %192, ptr nocapture nofree nonnull readonly %419, ptr nocapture nofree writeonly %429) #12
  %432 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %433 = getelementptr inbounds i8, ptr %result.i83.i1484, i64 16
  store i32 %195, ptr %433, align 8
  store ptr @Entry, ptr %332, align 8
  %434 = ptrtoint ptr %result.i83.i1484 to i64
  store i64 %434, ptr %334, align 4
  %.sroa_idx28.i1489 = getelementptr i8, ptr %332, i64 24
  store i32 10, ptr %.sroa_idx28.i1489, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit

435:                                              ; preds = %._crit_edge.i1477, %306, %337
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %436 = load i32, ptr %65, align 4
  %437 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %438 = load i32, ptr %42, align 8
  %.not.i = icmp slt i32 %436, %438
  br i1 %.not.i, label %._crit_edge.i, label %439

439:                                              ; preds = %435
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %441 = load ptr, ptr %43, align 8
  %442 = load ptr, ptr %44, align 8
  %443 = shl i32 %438, 1
  %spec.select.i1505 = call i32 @llvm.smax.i32(i32 %443, i32 16)
  store i32 %spec.select.i1505, ptr %42, align 8
  %444 = zext nneg i32 %spec.select.i1505 to i64
  %445 = shl nuw nsw i64 %444, 5
  %result.i.i1506 = call noalias ptr @bump_malloc_inner(i64 noundef %445, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1506, ptr %43, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %445, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %446 = icmp sgt i32 %438, 0
  br i1 %446, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread: ; preds = %439
  %447 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i

.lr.ph.i:                                         ; preds = %439, %._crit_edge.i2470
  %.060.i = phi i32 [ %536, %._crit_edge.i2470 ], [ 0, %439 ]
  %448 = zext nneg i32 %.060.i to i64
  %449 = shl nuw nsw i64 %448, 5
  %450 = getelementptr i8, ptr %441, i64 %449
  %451 = load ptr, ptr %450, align 8
  %452 = icmp ne ptr %451, @nil_typ
  %453 = icmp ne ptr %451, null
  %.not16.i = and i1 %452, %453
  br i1 %.not16.i, label %454, label %._crit_edge.i2470

454:                                              ; preds = %.lr.ph.i
  %455 = getelementptr i8, ptr %450, i64 8
  %456 = load <2 x i64>, ptr %455, align 4
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %451, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %451, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %451, i64 40
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %26)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !341
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %459 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %461

461:                                              ; preds = %.cont.cont.i3014, %454
  %.0566.i3001 = phi i32 [ 0, %454 ], [ %465, %.cont.cont.i3014 ]
  %.070565.i3002 = phi i1 [ true, %454 ], [ %527, %.cont.cont.i3014 ]
  %.sroa.0.0564.i3003 = phi ptr [ %451, %454 ], [ %vptr.i142.sroa.speculated.i3017, %.cont.cont.i3014 ]
  %.sroa.17.0561.i3006 = phi i32 [ %offset.i.i121.i, %454 ], [ %offset.i.i154.i3031, %.cont.cont.i3014 ]
  %462 = phi <2 x i64> [ %456, %454 ], [ %526, %.cont.cont.i3014 ]
  %463 = extractelement <2 x i64> %462, i64 1
  %.sroa.12.0562.i3005 = inttoptr i64 %463 to ptr
  %464 = extractelement <2 x i64> %462, i64 0
  %.sroa.6.0563.i3004 = inttoptr i64 %464 to ptr
  %465 = add nuw nsw i32 %.0566.i3001, 1
  %466 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3003, 0
  %467 = insertvalue { ptr, ptr, ptr, i32 } %466, ptr %.sroa.6.0563.i3004, 1
  %468 = insertvalue { ptr, ptr, ptr, i32 } %467, ptr %.sroa.12.0562.i3005, 2
  %469 = insertvalue { ptr, ptr, ptr, i32 } %468, i32 %.sroa.17.0561.i3006, 3
  %470 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3003)
  %471 = sext i32 %.sroa.17.0561.i3006 to i64
  %472 = getelementptr ptr, ptr %.sroa.0.0564.i3003, i64 %471
  %473 = getelementptr i8, ptr %472, i64 64
  %474 = load ptr, ptr %473, align 8
  %result.i125.i3007 = call ptr %474({ ptr, ptr, ptr, i32 } %469, ptr nocapture nofree noundef nonnull readonly %2) #15
  %475 = call i32 %result.i125.i3007({ ptr, ptr, ptr, i32 } %469, { ptr, ptr, ptr, i32 } %469, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3002, label %476, label %492

476:                                              ; preds = %461
  %477 = load i32, ptr %42, align 8
  %478 = add i32 %477, -1
  %479 = and i32 %478, %475
  %480 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %481 = load ptr, ptr %43, align 8
  %482 = sext i32 %479 to i64
  %483 = shl nsw i64 %482, 5
  %484 = getelementptr i8, ptr %481, i64 %483
  %485 = load ptr, ptr %484, align 8
  %486 = getelementptr i8, ptr %484, i64 8
  %487 = load i160, ptr %486, align 4
  store ptr %.sroa.0.0564.i3003, ptr %484, align 8
  store i64 %464, ptr %486, align 4
  %.sroa_idx157.i3033 = getelementptr i8, ptr %484, i64 16
  store i64 %463, ptr %.sroa_idx157.i3033, align 4
  %.sroa_idx158.i3034 = getelementptr i8, ptr %484, i64 24
  store i32 %.sroa.17.0561.i3006, ptr %.sroa_idx158.i3034, align 4
  %488 = icmp ne ptr %485, @nil_typ
  %489 = icmp ne ptr %485, null
  %.not92.i3035 = and i1 %488, %489
  %extract.i3037 = lshr i160 %487, 64
  %490 = insertelement <2 x i160> poison, i160 %487, i64 0
  %491 = insertelement <2 x i160> %490, i160 %extract.i3037, i64 1
  br i1 %.not92.i3035, label %.cont.cont.i3014, label %531

492:                                              ; preds = %461
  %493 = add i32 %475, 2127912214
  %494 = shl i32 %475, 12
  %495 = add i32 %493, %494
  %496 = ashr i32 %495, 19
  %497 = xor i32 %495, %496
  %498 = xor i32 %497, -949894596
  %499 = add i32 %498, 374761393
  %500 = shl i32 %498, 5
  %501 = add i32 %499, %500
  %502 = add i32 %501, -744332180
  %503 = shl i32 %501, 9
  %504 = xor i32 %502, %503
  %505 = add i32 %504, -42973499
  %506 = shl i32 %504, 3
  %507 = add i32 %505, %506
  %508 = ashr i32 %507, 16
  %509 = xor i32 %507, %508
  %510 = xor i32 %509, -1252372727
  %511 = load i32, ptr %42, align 8
  %512 = add i32 %511, -1
  %513 = and i32 %512, %510
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %515 = load ptr, ptr %44, align 8
  %516 = sext i32 %513 to i64
  %517 = shl nsw i64 %516, 5
  %518 = getelementptr i8, ptr %515, i64 %517
  %519 = load ptr, ptr %518, align 8
  %520 = getelementptr i8, ptr %518, i64 8
  %521 = load i160, ptr %520, align 4
  store ptr %.sroa.0.0564.i3003, ptr %518, align 8
  store i64 %464, ptr %520, align 4
  %.sroa_idx161.i3008 = getelementptr i8, ptr %518, i64 16
  store i64 %463, ptr %.sroa_idx161.i3008, align 4
  %.sroa_idx162.i3009 = getelementptr i8, ptr %518, i64 24
  store i32 %.sroa.17.0561.i3006, ptr %.sroa_idx162.i3009, align 4
  %522 = icmp ne ptr %519, @nil_typ
  %523 = icmp ne ptr %519, null
  %.not90.i3010 = and i1 %522, %523
  %extract607.i3012 = lshr i160 %521, 64
  %524 = insertelement <2 x i160> poison, i160 %521, i64 0
  %525 = insertelement <2 x i160> %524, i160 %extract607.i3012, i64 1
  br i1 %.not90.i3010, label %.cont.cont.i3014, label %531

.cont.cont.i3014:                                 ; preds = %492, %476
  %vptr.i142.sroa.speculated.i3017 = phi ptr [ %485, %476 ], [ %519, %492 ]
  %.in = phi <2 x i160> [ %491, %476 ], [ %525, %492 ]
  %526 = trunc <2 x i160> %.in to <2 x i64>
  %527 = xor i1 %.070565.i3002, true
  %hash_coef_ptr.i.i143.i3020 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3017, i64 8
  %tbl_size_ptr.i.i144.i3021 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3017, i64 16
  %offset_tbl_ptr.i.i145.i3022 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3017, i64 40
  %hash_coef.i.i146.i3023 = load i64, ptr %hash_coef_ptr.i.i143.i3020, align 4
  %tbl_size.i.i147.i3024 = load i64, ptr %tbl_size_ptr.i.i144.i3021, align 4
  %offset_tbl.i.i148.i3025 = load ptr, ptr %offset_tbl_ptr.i.i145.i3022, align 8
  %product.i.i.i149.i3026 = mul i64 %hash_coef.i.i146.i3023, 4015701072841558310
  %shifted.i.i.i150.i3027 = lshr i64 %product.i.i.i149.i3026, 32
  %xored.i.i.i151.i3028 = xor i64 %shifted.i.i.i150.i3027, %product.i.i.i149.i3026
  %hash.i.i.i152.i3029 = and i64 %xored.i.i.i151.i3028, %tbl_size.i.i147.i3024
  %offset_ptr.i.i153.i3030 = getelementptr i32, ptr %offset_tbl.i.i148.i3025, i64 %hash.i.i.i152.i3029
  %offset.i.i154.i3031 = load i32, ptr %offset_ptr.i.i153.i3030, align 4
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %529 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %530 = icmp ult i32 %.0566.i3001, 99
  br i1 %530, label %461, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3039

531:                                              ; preds = %492, %476
  %532 = phi ptr [ %26, %492 ], [ %25, %476 ]
  %533 = load i32, ptr %65, align 4
  store i32 %533, ptr %532, align 4
  %534 = add i32 %533, 1
  %535 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %534, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3039

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3039: ; preds = %.cont.cont.i3014, %531
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  br label %._crit_edge.i2470

._crit_edge.i2470:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3039, %.lr.ph.i
  %536 = add nuw nsw i32 %.060.i, 1
  %537 = icmp slt i32 %536, %438
  br i1 %537, label %.lr.ph.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i2470
  %538 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %539

539:                                              ; preds = %._crit_edge.i2489, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %.060.i2487 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit ], [ %628, %._crit_edge.i2489 ]
  %540 = zext nneg i32 %.060.i2487 to i64
  %541 = shl nuw nsw i64 %540, 5
  %542 = getelementptr i8, ptr %442, i64 %541
  %543 = load ptr, ptr %542, align 8
  %544 = icmp ne ptr %543, @nil_typ
  %545 = icmp ne ptr %543, null
  %.not16.i2488 = and i1 %544, %545
  br i1 %.not16.i2488, label %546, label %._crit_edge.i2489

546:                                              ; preds = %539
  %547 = getelementptr i8, ptr %542, i64 8
  %548 = load <2 x i64>, ptr %547, align 4
  %hash_coef_ptr.i.i18.i2491 = getelementptr i8, ptr %543, i64 8
  %tbl_size_ptr.i.i19.i2492 = getelementptr i8, ptr %543, i64 16
  %offset_tbl_ptr.i.i20.i2493 = getelementptr i8, ptr %543, i64 40
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %hash_coef.i.i99.i3057 = load i64, ptr %hash_coef_ptr.i.i18.i2491, align 4, !noalias !22
  %tbl_size.i.i100.i3058 = load i64, ptr %tbl_size_ptr.i.i19.i2492, align 4, !noalias !22
  %offset_tbl.i.i101.i3059 = load ptr, ptr %offset_tbl_ptr.i.i20.i2493, align 8, !noalias !22
  %product.i.i.i102.i3060 = mul i64 %hash_coef.i.i99.i3057, 4015701072841558310
  %shifted.i.i.i103.i3061 = lshr i64 %product.i.i.i102.i3060, 32
  %xored.i.i.i104.i3062 = xor i64 %shifted.i.i.i103.i3061, %product.i.i.i102.i3060
  %hash.i.i.i105.i3063 = and i64 %xored.i.i.i104.i3062, %tbl_size.i.i100.i3058
  %offset_ptr.i.i106.i3064 = getelementptr i32, ptr %offset_tbl.i.i101.i3059, i64 %hash.i.i.i105.i3063
  %offset.i.i121.i3065 = load i32, ptr %offset_ptr.i.i106.i3064, align 4, !noalias !344
  %550 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %551 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %552 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %553

553:                                              ; preds = %.cont.cont.i3086, %546
  %.0566.i3066 = phi i32 [ 0, %546 ], [ %557, %.cont.cont.i3086 ]
  %.070565.i3067 = phi i1 [ true, %546 ], [ %619, %.cont.cont.i3086 ]
  %.sroa.0.0564.i3068 = phi ptr [ %543, %546 ], [ %vptr.i142.sroa.speculated.i3089, %.cont.cont.i3086 ]
  %.sroa.17.0561.i3071 = phi i32 [ %offset.i.i121.i3065, %546 ], [ %offset.i.i154.i3103, %.cont.cont.i3086 ]
  %554 = phi <2 x i64> [ %548, %546 ], [ %618, %.cont.cont.i3086 ]
  %555 = extractelement <2 x i64> %554, i64 1
  %.sroa.12.0562.i3070 = inttoptr i64 %555 to ptr
  %556 = extractelement <2 x i64> %554, i64 0
  %.sroa.6.0563.i3069 = inttoptr i64 %556 to ptr
  %557 = add nuw nsw i32 %.0566.i3066, 1
  %558 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3068, 0
  %559 = insertvalue { ptr, ptr, ptr, i32 } %558, ptr %.sroa.6.0563.i3069, 1
  %560 = insertvalue { ptr, ptr, ptr, i32 } %559, ptr %.sroa.12.0562.i3070, 2
  %561 = insertvalue { ptr, ptr, ptr, i32 } %560, i32 %.sroa.17.0561.i3071, 3
  %562 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3068)
  %563 = sext i32 %.sroa.17.0561.i3071 to i64
  %564 = getelementptr ptr, ptr %.sroa.0.0564.i3068, i64 %563
  %565 = getelementptr i8, ptr %564, i64 64
  %566 = load ptr, ptr %565, align 8
  %result.i125.i3072 = call ptr %566({ ptr, ptr, ptr, i32 } %561, ptr nocapture nofree noundef nonnull readonly %2) #15
  %567 = call i32 %result.i125.i3072({ ptr, ptr, ptr, i32 } %561, { ptr, ptr, ptr, i32 } %561, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3067, label %568, label %584

568:                                              ; preds = %553
  %569 = load i32, ptr %42, align 8
  %570 = add i32 %569, -1
  %571 = and i32 %570, %567
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %573 = load ptr, ptr %43, align 8
  %574 = sext i32 %571 to i64
  %575 = shl nsw i64 %574, 5
  %576 = getelementptr i8, ptr %573, i64 %575
  %577 = load ptr, ptr %576, align 8
  %578 = getelementptr i8, ptr %576, i64 8
  %579 = load i160, ptr %578, align 4
  store ptr %.sroa.0.0564.i3068, ptr %576, align 8
  store i64 %556, ptr %578, align 4
  %.sroa_idx157.i3115 = getelementptr i8, ptr %576, i64 16
  store i64 %555, ptr %.sroa_idx157.i3115, align 4
  %.sroa_idx158.i3116 = getelementptr i8, ptr %576, i64 24
  store i32 %.sroa.17.0561.i3071, ptr %.sroa_idx158.i3116, align 4
  %580 = icmp ne ptr %577, @nil_typ
  %581 = icmp ne ptr %577, null
  %.not92.i3117 = and i1 %580, %581
  %extract.i3119 = lshr i160 %579, 64
  %582 = insertelement <2 x i160> poison, i160 %579, i64 0
  %583 = insertelement <2 x i160> %582, i160 %extract.i3119, i64 1
  br i1 %.not92.i3117, label %.cont.cont.i3086, label %623

584:                                              ; preds = %553
  %585 = add i32 %567, 2127912214
  %586 = shl i32 %567, 12
  %587 = add i32 %585, %586
  %588 = ashr i32 %587, 19
  %589 = xor i32 %587, %588
  %590 = xor i32 %589, -949894596
  %591 = add i32 %590, 374761393
  %592 = shl i32 %590, 5
  %593 = add i32 %591, %592
  %594 = add i32 %593, -744332180
  %595 = shl i32 %593, 9
  %596 = xor i32 %594, %595
  %597 = add i32 %596, -42973499
  %598 = shl i32 %596, 3
  %599 = add i32 %597, %598
  %600 = ashr i32 %599, 16
  %601 = xor i32 %599, %600
  %602 = xor i32 %601, -1252372727
  %603 = load i32, ptr %42, align 8
  %604 = add i32 %603, -1
  %605 = and i32 %604, %602
  %606 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %607 = load ptr, ptr %44, align 8
  %608 = sext i32 %605 to i64
  %609 = shl nsw i64 %608, 5
  %610 = getelementptr i8, ptr %607, i64 %609
  %611 = load ptr, ptr %610, align 8
  %612 = getelementptr i8, ptr %610, i64 8
  %613 = load i160, ptr %612, align 4
  store ptr %.sroa.0.0564.i3068, ptr %610, align 8
  store i64 %556, ptr %612, align 4
  %.sroa_idx161.i3076 = getelementptr i8, ptr %610, i64 16
  store i64 %555, ptr %.sroa_idx161.i3076, align 4
  %.sroa_idx162.i3077 = getelementptr i8, ptr %610, i64 24
  store i32 %.sroa.17.0561.i3071, ptr %.sroa_idx162.i3077, align 4
  %614 = icmp ne ptr %611, @nil_typ
  %615 = icmp ne ptr %611, null
  %.not90.i3078 = and i1 %614, %615
  %extract607.i3080 = lshr i160 %613, 64
  %616 = insertelement <2 x i160> poison, i160 %613, i64 0
  %617 = insertelement <2 x i160> %616, i160 %extract607.i3080, i64 1
  br i1 %.not90.i3078, label %.cont.cont.i3086, label %623

.cont.cont.i3086:                                 ; preds = %584, %568
  %vptr.i142.sroa.speculated.i3089 = phi ptr [ %577, %568 ], [ %611, %584 ]
  %.in4328 = phi <2 x i160> [ %583, %568 ], [ %617, %584 ]
  %618 = trunc <2 x i160> %.in4328 to <2 x i64>
  %619 = xor i1 %.070565.i3067, true
  %hash_coef_ptr.i.i143.i3092 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3089, i64 8
  %tbl_size_ptr.i.i144.i3093 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3089, i64 16
  %offset_tbl_ptr.i.i145.i3094 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3089, i64 40
  %hash_coef.i.i146.i3095 = load i64, ptr %hash_coef_ptr.i.i143.i3092, align 4
  %tbl_size.i.i147.i3096 = load i64, ptr %tbl_size_ptr.i.i144.i3093, align 4
  %offset_tbl.i.i148.i3097 = load ptr, ptr %offset_tbl_ptr.i.i145.i3094, align 8
  %product.i.i.i149.i3098 = mul i64 %hash_coef.i.i146.i3095, 4015701072841558310
  %shifted.i.i.i150.i3099 = lshr i64 %product.i.i.i149.i3098, 32
  %xored.i.i.i151.i3100 = xor i64 %shifted.i.i.i150.i3099, %product.i.i.i149.i3098
  %hash.i.i.i152.i3101 = and i64 %xored.i.i.i151.i3100, %tbl_size.i.i147.i3096
  %offset_ptr.i.i153.i3102 = getelementptr i32, ptr %offset_tbl.i.i148.i3097, i64 %hash.i.i.i152.i3101
  %offset.i.i154.i3103 = load i32, ptr %offset_ptr.i.i153.i3102, align 4
  %620 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %621 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %622 = icmp ult i32 %.0566.i3066, 99
  br i1 %622, label %553, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3121

623:                                              ; preds = %584, %568
  %624 = phi ptr [ %24, %584 ], [ %23, %568 ]
  %625 = load i32, ptr %65, align 4
  store i32 %625, ptr %624, align 4
  %626 = add i32 %625, 1
  %627 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %626, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3121

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3121: ; preds = %.cont.cont.i3086, %623
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %._crit_edge.i2489

._crit_edge.i2489:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3121, %539
  %628 = add nuw nsw i32 %.060.i2487, 1
  %629 = icmp slt i32 %628, %438
  br i1 %629, label %539, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i2489, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread, %435
  %630 = load ptr, ptr %193, align 8
  %631 = getelementptr i8, ptr %630, i64 72
  %632 = load ptr, ptr %631, align 8
  %result.i.i.i = call { i64, i64 } %632(ptr nocapture nofree nonnull readonly %193) #5
  %633 = extractvalue { i64, i64 } %result.i.i.i, 0
  %634 = extractvalue { i64, i64 } %result.i.i.i, 1
  %635 = urem i64 20, %634
  %636 = icmp eq i64 %635, 0
  %637 = sub i64 %634, %635
  %638 = select i1 %636, i64 0, i64 %637
  %639 = add i64 %633, 20
  %640 = add i64 %639, %638
  %641 = load ptr, ptr %201, align 8
  %642 = getelementptr i8, ptr %641, i64 72
  %643 = load ptr, ptr %642, align 8
  %result.i1.i.i = call { i64, i64 } %643(ptr nocapture nofree nonnull readonly %201) #5
  %644 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %645 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %646 = call i64 @llvm.umax.i64(i64 %634, i64 %645)
  %647 = call i64 @llvm.umax.i64(i64 %646, i64 8)
  %648 = urem i64 %640, %645
  %649 = icmp eq i64 %648, 0
  %650 = sub i64 %645, %648
  %651 = select i1 %649, i64 0, i64 %650
  %652 = add i64 %644, %640
  %653 = add i64 %652, %651
  %654 = urem i64 %653, %647
  %655 = icmp eq i64 %654, 0
  %656 = sub i64 %647, %654
  %657 = select i1 %655, i64 0, i64 %656
  %658 = add i64 %657, %653
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %658, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %193, ptr %result.i83.i, align 8
  %659 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %201, ptr %659, align 8
  %660 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %661 = load ptr, ptr %193, align 8
  %662 = getelementptr i8, ptr %661, i64 72
  %663 = load ptr, ptr %662, align 8
  %result.i.i179.i = call { i64, i64 } %663(ptr nocapture nofree nonnull readonly %193) #5
  %664 = extractvalue { i64, i64 } %result.i.i179.i, 1
  %665 = urem i64 20, %664
  %666 = icmp eq i64 %665, 0
  %reass.sub4323 = sub i64 %664, %665
  %667 = add i64 %reass.sub4323, 20
  %668 = select i1 %666, i64 20, i64 %667
  %669 = getelementptr i8, ptr %result.i83.i, i64 %668
  %670 = getelementptr i8, ptr %661, i64 64
  %671 = load ptr, ptr %670, align 8
  call void %671({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %193, ptr nocapture nofree writeonly %669) #12
  %672 = load ptr, ptr %result.i83.i, align 8
  %673 = load ptr, ptr %672, align 8
  %674 = getelementptr i8, ptr %673, i64 72
  %675 = load ptr, ptr %674, align 8
  %result.i.i180.i = call { i64, i64 } %675(ptr nocapture nofree nonnull readonly %672) #5
  %676 = extractvalue { i64, i64 } %result.i.i180.i, 0
  %677 = extractvalue { i64, i64 } %result.i.i180.i, 1
  %678 = urem i64 20, %677
  %679 = icmp eq i64 %678, 0
  %680 = sub i64 %677, %678
  %681 = select i1 %679, i64 0, i64 %680
  %682 = add i64 %676, 20
  %683 = add i64 %682, %681
  %684 = load ptr, ptr %659, align 8
  %685 = load ptr, ptr %684, align 8
  %686 = getelementptr i8, ptr %685, i64 72
  %687 = load ptr, ptr %686, align 8
  %result.i1.i181.i = call { i64, i64 } %687(ptr nocapture nofree nonnull readonly %684) #5
  %688 = extractvalue { i64, i64 } %result.i1.i181.i, 1
  %689 = urem i64 %683, %688
  %690 = icmp eq i64 %689, 0
  %691 = sub i64 %688, %689
  %692 = select i1 %690, i64 0, i64 %691
  %693 = getelementptr i8, ptr %result.i83.i, i64 %683
  %694 = getelementptr i8, ptr %693, i64 %692
  %695 = getelementptr i8, ptr %685, i64 64
  %696 = load ptr, ptr %695, align 8
  call void %696({ ptr, i160 } %192, ptr nocapture nofree nonnull readonly %684, ptr nocapture nofree writeonly %694) #12
  %697 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %698 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %195, ptr %698, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %34)
  %699 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %702

702:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %703, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %769, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i83.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i1522, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %703 = add nuw nsw i32 %.0566.i, 1
  %704 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %705 = insertvalue { ptr, ptr, ptr, i32 } %704, ptr %.sroa.6.0563.i, 1
  %706 = insertvalue { ptr, ptr, ptr, i32 } %705, ptr %.sroa.12.0562.i, 2
  %707 = insertvalue { ptr, ptr, ptr, i32 } %706, i32 %.sroa.17.0561.i, 3
  %708 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %709 = sext i32 %.sroa.17.0561.i to i64
  %710 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %709
  %711 = getelementptr i8, ptr %710, i64 64
  %712 = load ptr, ptr %711, align 8
  %result.i125.i = call ptr %712({ ptr, ptr, ptr, i32 } %707, ptr nocapture nofree noundef nonnull readonly %2) #15
  %713 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %707, { ptr, ptr, ptr, i32 } %707, ptr nonnull align 8 %2) #7
  %714 = ptrtoint ptr %.sroa.6.0563.i to i64
  %715 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %716, label %732

716:                                              ; preds = %702
  %717 = load i32, ptr %42, align 8
  %718 = add i32 %717, -1
  %719 = and i32 %718, %713
  %720 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %721 = load ptr, ptr %43, align 8
  %722 = sext i32 %719 to i64
  %723 = shl nsw i64 %722, 5
  %724 = getelementptr i8, ptr %721, i64 %723
  %725 = load ptr, ptr %724, align 8
  %726 = getelementptr i8, ptr %724, i64 8
  %727 = load i160, ptr %726, align 4
  store ptr %.sroa.0.0564.i, ptr %724, align 8
  store i64 %714, ptr %726, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %724, i64 16
  store i64 %715, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %724, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %728 = icmp ne ptr %725, @nil_typ
  %729 = icmp ne ptr %725, null
  %.not92.i = and i1 %728, %729
  %extract.i = lshr i160 %727, 64
  %730 = insertelement <2 x i160> poison, i160 %727, i64 0
  %731 = insertelement <2 x i160> %730, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

732:                                              ; preds = %702
  %733 = add i32 %713, 2127912214
  %734 = shl i32 %713, 12
  %735 = add i32 %733, %734
  %736 = ashr i32 %735, 19
  %737 = xor i32 %735, %736
  %738 = xor i32 %737, -949894596
  %739 = add i32 %738, 374761393
  %740 = shl i32 %738, 5
  %741 = add i32 %739, %740
  %742 = add i32 %741, -744332180
  %743 = shl i32 %741, 9
  %744 = xor i32 %742, %743
  %745 = add i32 %744, -42973499
  %746 = shl i32 %744, 3
  %747 = add i32 %745, %746
  %748 = ashr i32 %747, 16
  %749 = xor i32 %747, %748
  %750 = xor i32 %749, -1252372727
  %751 = load i32, ptr %42, align 8
  %752 = add i32 %751, -1
  %753 = and i32 %752, %750
  %754 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %755 = load ptr, ptr %44, align 8
  %756 = sext i32 %753 to i64
  %757 = shl nsw i64 %756, 5
  %758 = getelementptr i8, ptr %755, i64 %757
  %759 = load ptr, ptr %758, align 8
  %760 = getelementptr i8, ptr %758, i64 8
  %761 = load i160, ptr %760, align 4
  store ptr %.sroa.0.0564.i, ptr %758, align 8
  store i64 %714, ptr %760, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %758, i64 16
  store i64 %715, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %758, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %762 = icmp ne ptr %759, @nil_typ
  %763 = icmp ne ptr %759, null
  %.not90.i = and i1 %762, %763
  %extract607.i = lshr i160 %761, 64
  %764 = insertelement <2 x i160> poison, i160 %761, i64 0
  %765 = insertelement <2 x i160> %764, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %732, %716
  %vptr.i142.sroa.speculated.i = phi ptr [ %725, %716 ], [ %759, %732 ]
  %.in4329 = phi <2 x i160> [ %731, %716 ], [ %765, %732 ]
  %766 = trunc <2 x i160> %.in4329 to <2 x i64>
  %767 = extractelement <2 x i64> %766, i64 1
  %spec.select.i1522 = inttoptr i64 %767 to ptr
  %768 = extractelement <2 x i64> %766, i64 0
  %spec.select539.i = inttoptr i64 %768 to ptr
  %769 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %770 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %771 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %772 = icmp ult i32 %.0566.i, 99
  br i1 %772, label %702, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %716, %732
  %773 = phi ptr [ %34, %732 ], [ %33, %716 ]
  %774 = load i32, ptr %65, align 4
  store i32 %774, ptr %773, align 4
  %775 = add i32 %774, 1
  %776 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %775, ptr %65, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  %777 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %777, label %HashMap_insert_keyK_valueV.exit, label %778

778:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %779 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %780 = load ptr, ptr %43, align 8
  %781 = load ptr, ptr %44, align 8
  %782 = load i32, ptr %42, align 8
  %783 = shl i32 %782, 1
  %spec.select.i1539 = call i32 @llvm.smax.i32(i32 %783, i32 16)
  store i32 %spec.select.i1539, ptr %42, align 8
  %784 = zext nneg i32 %spec.select.i1539 to i64
  %785 = shl nuw nsw i64 %784, 5
  %result.i.i1540 = call noalias ptr @bump_malloc_inner(i64 noundef %785, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1540, ptr %43, align 8
  %result.i20.i1541 = call noalias ptr @bump_malloc_inner(i64 noundef %785, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1541, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %786 = icmp sgt i32 %782, 0
  br i1 %786, label %.lr.ph.i2536, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569.thread: ; preds = %778
  %787 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605

.lr.ph.i2536:                                     ; preds = %778, %._crit_edge.i2551
  %.060.i2549 = phi i32 [ %876, %._crit_edge.i2551 ], [ 0, %778 ]
  %788 = zext nneg i32 %.060.i2549 to i64
  %789 = shl nuw nsw i64 %788, 5
  %790 = getelementptr i8, ptr %780, i64 %789
  %791 = load ptr, ptr %790, align 8
  %792 = icmp ne ptr %791, @nil_typ
  %793 = icmp ne ptr %791, null
  %.not16.i2550 = and i1 %792, %793
  br i1 %.not16.i2550, label %794, label %._crit_edge.i2551

794:                                              ; preds = %.lr.ph.i2536
  %795 = getelementptr i8, ptr %790, i64 8
  %796 = load <2 x i64>, ptr %795, align 4
  %hash_coef_ptr.i.i18.i2553 = getelementptr i8, ptr %791, i64 8
  %tbl_size_ptr.i.i19.i2554 = getelementptr i8, ptr %791, i64 16
  %offset_tbl_ptr.i.i20.i2555 = getelementptr i8, ptr %791, i64 40
  %797 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %hash_coef.i.i99.i3139 = load i64, ptr %hash_coef_ptr.i.i18.i2553, align 4, !noalias !22
  %tbl_size.i.i100.i3140 = load i64, ptr %tbl_size_ptr.i.i19.i2554, align 4, !noalias !22
  %offset_tbl.i.i101.i3141 = load ptr, ptr %offset_tbl_ptr.i.i20.i2555, align 8, !noalias !22
  %product.i.i.i102.i3142 = mul i64 %hash_coef.i.i99.i3139, 4015701072841558310
  %shifted.i.i.i103.i3143 = lshr i64 %product.i.i.i102.i3142, 32
  %xored.i.i.i104.i3144 = xor i64 %shifted.i.i.i103.i3143, %product.i.i.i102.i3142
  %hash.i.i.i105.i3145 = and i64 %xored.i.i.i104.i3144, %tbl_size.i.i100.i3140
  %offset_ptr.i.i106.i3146 = getelementptr i32, ptr %offset_tbl.i.i101.i3141, i64 %hash.i.i.i105.i3145
  %offset.i.i121.i3147 = load i32, ptr %offset_ptr.i.i106.i3146, align 4, !noalias !347
  %798 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %799 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %801

801:                                              ; preds = %.cont.cont.i3168, %794
  %.0566.i3148 = phi i32 [ 0, %794 ], [ %805, %.cont.cont.i3168 ]
  %.070565.i3149 = phi i1 [ true, %794 ], [ %867, %.cont.cont.i3168 ]
  %.sroa.0.0564.i3150 = phi ptr [ %791, %794 ], [ %vptr.i142.sroa.speculated.i3171, %.cont.cont.i3168 ]
  %.sroa.17.0561.i3153 = phi i32 [ %offset.i.i121.i3147, %794 ], [ %offset.i.i154.i3185, %.cont.cont.i3168 ]
  %802 = phi <2 x i64> [ %796, %794 ], [ %866, %.cont.cont.i3168 ]
  %803 = extractelement <2 x i64> %802, i64 1
  %.sroa.12.0562.i3152 = inttoptr i64 %803 to ptr
  %804 = extractelement <2 x i64> %802, i64 0
  %.sroa.6.0563.i3151 = inttoptr i64 %804 to ptr
  %805 = add nuw nsw i32 %.0566.i3148, 1
  %806 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3150, 0
  %807 = insertvalue { ptr, ptr, ptr, i32 } %806, ptr %.sroa.6.0563.i3151, 1
  %808 = insertvalue { ptr, ptr, ptr, i32 } %807, ptr %.sroa.12.0562.i3152, 2
  %809 = insertvalue { ptr, ptr, ptr, i32 } %808, i32 %.sroa.17.0561.i3153, 3
  %810 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3150)
  %811 = sext i32 %.sroa.17.0561.i3153 to i64
  %812 = getelementptr ptr, ptr %.sroa.0.0564.i3150, i64 %811
  %813 = getelementptr i8, ptr %812, i64 64
  %814 = load ptr, ptr %813, align 8
  %result.i125.i3154 = call ptr %814({ ptr, ptr, ptr, i32 } %809, ptr nocapture nofree noundef nonnull readonly %2) #15
  %815 = call i32 %result.i125.i3154({ ptr, ptr, ptr, i32 } %809, { ptr, ptr, ptr, i32 } %809, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3149, label %816, label %832

816:                                              ; preds = %801
  %817 = load i32, ptr %42, align 8
  %818 = add i32 %817, -1
  %819 = and i32 %818, %815
  %820 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %821 = load ptr, ptr %43, align 8
  %822 = sext i32 %819 to i64
  %823 = shl nsw i64 %822, 5
  %824 = getelementptr i8, ptr %821, i64 %823
  %825 = load ptr, ptr %824, align 8
  %826 = getelementptr i8, ptr %824, i64 8
  %827 = load i160, ptr %826, align 4
  store ptr %.sroa.0.0564.i3150, ptr %824, align 8
  store i64 %804, ptr %826, align 4
  %.sroa_idx157.i3197 = getelementptr i8, ptr %824, i64 16
  store i64 %803, ptr %.sroa_idx157.i3197, align 4
  %.sroa_idx158.i3198 = getelementptr i8, ptr %824, i64 24
  store i32 %.sroa.17.0561.i3153, ptr %.sroa_idx158.i3198, align 4
  %828 = icmp ne ptr %825, @nil_typ
  %829 = icmp ne ptr %825, null
  %.not92.i3199 = and i1 %828, %829
  %extract.i3201 = lshr i160 %827, 64
  %830 = insertelement <2 x i160> poison, i160 %827, i64 0
  %831 = insertelement <2 x i160> %830, i160 %extract.i3201, i64 1
  br i1 %.not92.i3199, label %.cont.cont.i3168, label %871

832:                                              ; preds = %801
  %833 = add i32 %815, 2127912214
  %834 = shl i32 %815, 12
  %835 = add i32 %833, %834
  %836 = ashr i32 %835, 19
  %837 = xor i32 %835, %836
  %838 = xor i32 %837, -949894596
  %839 = add i32 %838, 374761393
  %840 = shl i32 %838, 5
  %841 = add i32 %839, %840
  %842 = add i32 %841, -744332180
  %843 = shl i32 %841, 9
  %844 = xor i32 %842, %843
  %845 = add i32 %844, -42973499
  %846 = shl i32 %844, 3
  %847 = add i32 %845, %846
  %848 = ashr i32 %847, 16
  %849 = xor i32 %847, %848
  %850 = xor i32 %849, -1252372727
  %851 = load i32, ptr %42, align 8
  %852 = add i32 %851, -1
  %853 = and i32 %852, %850
  %854 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %855 = load ptr, ptr %44, align 8
  %856 = sext i32 %853 to i64
  %857 = shl nsw i64 %856, 5
  %858 = getelementptr i8, ptr %855, i64 %857
  %859 = load ptr, ptr %858, align 8
  %860 = getelementptr i8, ptr %858, i64 8
  %861 = load i160, ptr %860, align 4
  store ptr %.sroa.0.0564.i3150, ptr %858, align 8
  store i64 %804, ptr %860, align 4
  %.sroa_idx161.i3158 = getelementptr i8, ptr %858, i64 16
  store i64 %803, ptr %.sroa_idx161.i3158, align 4
  %.sroa_idx162.i3159 = getelementptr i8, ptr %858, i64 24
  store i32 %.sroa.17.0561.i3153, ptr %.sroa_idx162.i3159, align 4
  %862 = icmp ne ptr %859, @nil_typ
  %863 = icmp ne ptr %859, null
  %.not90.i3160 = and i1 %862, %863
  %extract607.i3162 = lshr i160 %861, 64
  %864 = insertelement <2 x i160> poison, i160 %861, i64 0
  %865 = insertelement <2 x i160> %864, i160 %extract607.i3162, i64 1
  br i1 %.not90.i3160, label %.cont.cont.i3168, label %871

.cont.cont.i3168:                                 ; preds = %832, %816
  %vptr.i142.sroa.speculated.i3171 = phi ptr [ %825, %816 ], [ %859, %832 ]
  %.in4330 = phi <2 x i160> [ %831, %816 ], [ %865, %832 ]
  %866 = trunc <2 x i160> %.in4330 to <2 x i64>
  %867 = xor i1 %.070565.i3149, true
  %hash_coef_ptr.i.i143.i3174 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3171, i64 8
  %tbl_size_ptr.i.i144.i3175 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3171, i64 16
  %offset_tbl_ptr.i.i145.i3176 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3171, i64 40
  %hash_coef.i.i146.i3177 = load i64, ptr %hash_coef_ptr.i.i143.i3174, align 4
  %tbl_size.i.i147.i3178 = load i64, ptr %tbl_size_ptr.i.i144.i3175, align 4
  %offset_tbl.i.i148.i3179 = load ptr, ptr %offset_tbl_ptr.i.i145.i3176, align 8
  %product.i.i.i149.i3180 = mul i64 %hash_coef.i.i146.i3177, 4015701072841558310
  %shifted.i.i.i150.i3181 = lshr i64 %product.i.i.i149.i3180, 32
  %xored.i.i.i151.i3182 = xor i64 %shifted.i.i.i150.i3181, %product.i.i.i149.i3180
  %hash.i.i.i152.i3183 = and i64 %xored.i.i.i151.i3182, %tbl_size.i.i147.i3178
  %offset_ptr.i.i153.i3184 = getelementptr i32, ptr %offset_tbl.i.i148.i3179, i64 %hash.i.i.i152.i3183
  %offset.i.i154.i3185 = load i32, ptr %offset_ptr.i.i153.i3184, align 4
  %868 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %869 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %870 = icmp ult i32 %.0566.i3148, 99
  br i1 %870, label %801, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3203

871:                                              ; preds = %832, %816
  %872 = phi ptr [ %22, %832 ], [ %21, %816 ]
  %873 = load i32, ptr %65, align 4
  store i32 %873, ptr %872, align 4
  %874 = add i32 %873, 1
  %875 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %874, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3203

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3203: ; preds = %.cont.cont.i3168, %871
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %._crit_edge.i2551

._crit_edge.i2551:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3203, %.lr.ph.i2536
  %876 = add nuw nsw i32 %.060.i2549, 1
  %877 = icmp slt i32 %876, %782
  br i1 %877, label %.lr.ph.i2536, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569: ; preds = %._crit_edge.i2551
  %878 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %879

879:                                              ; preds = %._crit_edge.i2587, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569
  %.060.i2585 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569 ], [ %968, %._crit_edge.i2587 ]
  %880 = zext nneg i32 %.060.i2585 to i64
  %881 = shl nuw nsw i64 %880, 5
  %882 = getelementptr i8, ptr %781, i64 %881
  %883 = load ptr, ptr %882, align 8
  %884 = icmp ne ptr %883, @nil_typ
  %885 = icmp ne ptr %883, null
  %.not16.i2586 = and i1 %884, %885
  br i1 %.not16.i2586, label %886, label %._crit_edge.i2587

886:                                              ; preds = %879
  %887 = getelementptr i8, ptr %882, i64 8
  %888 = load <2 x i64>, ptr %887, align 4
  %hash_coef_ptr.i.i18.i2589 = getelementptr i8, ptr %883, i64 8
  %tbl_size_ptr.i.i19.i2590 = getelementptr i8, ptr %883, i64 16
  %offset_tbl_ptr.i.i20.i2591 = getelementptr i8, ptr %883, i64 40
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i3221 = load i64, ptr %hash_coef_ptr.i.i18.i2589, align 4, !noalias !22
  %tbl_size.i.i100.i3222 = load i64, ptr %tbl_size_ptr.i.i19.i2590, align 4, !noalias !22
  %offset_tbl.i.i101.i3223 = load ptr, ptr %offset_tbl_ptr.i.i20.i2591, align 8, !noalias !22
  %product.i.i.i102.i3224 = mul i64 %hash_coef.i.i99.i3221, 4015701072841558310
  %shifted.i.i.i103.i3225 = lshr i64 %product.i.i.i102.i3224, 32
  %xored.i.i.i104.i3226 = xor i64 %shifted.i.i.i103.i3225, %product.i.i.i102.i3224
  %hash.i.i.i105.i3227 = and i64 %xored.i.i.i104.i3226, %tbl_size.i.i100.i3222
  %offset_ptr.i.i106.i3228 = getelementptr i32, ptr %offset_tbl.i.i101.i3223, i64 %hash.i.i.i105.i3227
  %offset.i.i121.i3229 = load i32, ptr %offset_ptr.i.i106.i3228, align 4, !noalias !350
  %890 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %892 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %893

893:                                              ; preds = %.cont.cont.i3250, %886
  %.0566.i3230 = phi i32 [ 0, %886 ], [ %897, %.cont.cont.i3250 ]
  %.070565.i3231 = phi i1 [ true, %886 ], [ %959, %.cont.cont.i3250 ]
  %.sroa.0.0564.i3232 = phi ptr [ %883, %886 ], [ %vptr.i142.sroa.speculated.i3253, %.cont.cont.i3250 ]
  %.sroa.17.0561.i3235 = phi i32 [ %offset.i.i121.i3229, %886 ], [ %offset.i.i154.i3267, %.cont.cont.i3250 ]
  %894 = phi <2 x i64> [ %888, %886 ], [ %958, %.cont.cont.i3250 ]
  %895 = extractelement <2 x i64> %894, i64 1
  %.sroa.12.0562.i3234 = inttoptr i64 %895 to ptr
  %896 = extractelement <2 x i64> %894, i64 0
  %.sroa.6.0563.i3233 = inttoptr i64 %896 to ptr
  %897 = add nuw nsw i32 %.0566.i3230, 1
  %898 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3232, 0
  %899 = insertvalue { ptr, ptr, ptr, i32 } %898, ptr %.sroa.6.0563.i3233, 1
  %900 = insertvalue { ptr, ptr, ptr, i32 } %899, ptr %.sroa.12.0562.i3234, 2
  %901 = insertvalue { ptr, ptr, ptr, i32 } %900, i32 %.sroa.17.0561.i3235, 3
  %902 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3232)
  %903 = sext i32 %.sroa.17.0561.i3235 to i64
  %904 = getelementptr ptr, ptr %.sroa.0.0564.i3232, i64 %903
  %905 = getelementptr i8, ptr %904, i64 64
  %906 = load ptr, ptr %905, align 8
  %result.i125.i3236 = call ptr %906({ ptr, ptr, ptr, i32 } %901, ptr nocapture nofree noundef nonnull readonly %2) #15
  %907 = call i32 %result.i125.i3236({ ptr, ptr, ptr, i32 } %901, { ptr, ptr, ptr, i32 } %901, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3231, label %908, label %924

908:                                              ; preds = %893
  %909 = load i32, ptr %42, align 8
  %910 = add i32 %909, -1
  %911 = and i32 %910, %907
  %912 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %913 = load ptr, ptr %43, align 8
  %914 = sext i32 %911 to i64
  %915 = shl nsw i64 %914, 5
  %916 = getelementptr i8, ptr %913, i64 %915
  %917 = load ptr, ptr %916, align 8
  %918 = getelementptr i8, ptr %916, i64 8
  %919 = load i160, ptr %918, align 4
  store ptr %.sroa.0.0564.i3232, ptr %916, align 8
  store i64 %896, ptr %918, align 4
  %.sroa_idx157.i3279 = getelementptr i8, ptr %916, i64 16
  store i64 %895, ptr %.sroa_idx157.i3279, align 4
  %.sroa_idx158.i3280 = getelementptr i8, ptr %916, i64 24
  store i32 %.sroa.17.0561.i3235, ptr %.sroa_idx158.i3280, align 4
  %920 = icmp ne ptr %917, @nil_typ
  %921 = icmp ne ptr %917, null
  %.not92.i3281 = and i1 %920, %921
  %extract.i3283 = lshr i160 %919, 64
  %922 = insertelement <2 x i160> poison, i160 %919, i64 0
  %923 = insertelement <2 x i160> %922, i160 %extract.i3283, i64 1
  br i1 %.not92.i3281, label %.cont.cont.i3250, label %963

924:                                              ; preds = %893
  %925 = add i32 %907, 2127912214
  %926 = shl i32 %907, 12
  %927 = add i32 %925, %926
  %928 = ashr i32 %927, 19
  %929 = xor i32 %927, %928
  %930 = xor i32 %929, -949894596
  %931 = add i32 %930, 374761393
  %932 = shl i32 %930, 5
  %933 = add i32 %931, %932
  %934 = add i32 %933, -744332180
  %935 = shl i32 %933, 9
  %936 = xor i32 %934, %935
  %937 = add i32 %936, -42973499
  %938 = shl i32 %936, 3
  %939 = add i32 %937, %938
  %940 = ashr i32 %939, 16
  %941 = xor i32 %939, %940
  %942 = xor i32 %941, -1252372727
  %943 = load i32, ptr %42, align 8
  %944 = add i32 %943, -1
  %945 = and i32 %944, %942
  %946 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %947 = load ptr, ptr %44, align 8
  %948 = sext i32 %945 to i64
  %949 = shl nsw i64 %948, 5
  %950 = getelementptr i8, ptr %947, i64 %949
  %951 = load ptr, ptr %950, align 8
  %952 = getelementptr i8, ptr %950, i64 8
  %953 = load i160, ptr %952, align 4
  store ptr %.sroa.0.0564.i3232, ptr %950, align 8
  store i64 %896, ptr %952, align 4
  %.sroa_idx161.i3240 = getelementptr i8, ptr %950, i64 16
  store i64 %895, ptr %.sroa_idx161.i3240, align 4
  %.sroa_idx162.i3241 = getelementptr i8, ptr %950, i64 24
  store i32 %.sroa.17.0561.i3235, ptr %.sroa_idx162.i3241, align 4
  %954 = icmp ne ptr %951, @nil_typ
  %955 = icmp ne ptr %951, null
  %.not90.i3242 = and i1 %954, %955
  %extract607.i3244 = lshr i160 %953, 64
  %956 = insertelement <2 x i160> poison, i160 %953, i64 0
  %957 = insertelement <2 x i160> %956, i160 %extract607.i3244, i64 1
  br i1 %.not90.i3242, label %.cont.cont.i3250, label %963

.cont.cont.i3250:                                 ; preds = %924, %908
  %vptr.i142.sroa.speculated.i3253 = phi ptr [ %917, %908 ], [ %951, %924 ]
  %.in4331 = phi <2 x i160> [ %923, %908 ], [ %957, %924 ]
  %958 = trunc <2 x i160> %.in4331 to <2 x i64>
  %959 = xor i1 %.070565.i3231, true
  %hash_coef_ptr.i.i143.i3256 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3253, i64 8
  %tbl_size_ptr.i.i144.i3257 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3253, i64 16
  %offset_tbl_ptr.i.i145.i3258 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3253, i64 40
  %hash_coef.i.i146.i3259 = load i64, ptr %hash_coef_ptr.i.i143.i3256, align 4
  %tbl_size.i.i147.i3260 = load i64, ptr %tbl_size_ptr.i.i144.i3257, align 4
  %offset_tbl.i.i148.i3261 = load ptr, ptr %offset_tbl_ptr.i.i145.i3258, align 8
  %product.i.i.i149.i3262 = mul i64 %hash_coef.i.i146.i3259, 4015701072841558310
  %shifted.i.i.i150.i3263 = lshr i64 %product.i.i.i149.i3262, 32
  %xored.i.i.i151.i3264 = xor i64 %shifted.i.i.i150.i3263, %product.i.i.i149.i3262
  %hash.i.i.i152.i3265 = and i64 %xored.i.i.i151.i3264, %tbl_size.i.i147.i3260
  %offset_ptr.i.i153.i3266 = getelementptr i32, ptr %offset_tbl.i.i148.i3261, i64 %hash.i.i.i152.i3265
  %offset.i.i154.i3267 = load i32, ptr %offset_ptr.i.i153.i3266, align 4
  %960 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %961 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %962 = icmp ult i32 %.0566.i3230, 99
  br i1 %962, label %893, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3285

963:                                              ; preds = %924, %908
  %964 = phi ptr [ %20, %924 ], [ %19, %908 ]
  %965 = load i32, ptr %65, align 4
  store i32 %965, ptr %964, align 4
  %966 = add i32 %965, 1
  %967 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %966, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3285

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3285: ; preds = %.cont.cont.i3250, %963
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %._crit_edge.i2587

._crit_edge.i2587:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3285, %879
  %968 = add nuw nsw i32 %.060.i2585, 1
  %969 = icmp slt i32 %968, %782
  br i1 %969, label %879, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605: ; preds = %._crit_edge.i2587, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569.thread
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %32)
  %hash_coef.i.i99.i1562 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i1563 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1564 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i1565 = mul i64 %hash_coef.i.i99.i1562, 4015701072841558310
  %shifted.i.i.i103.i1566 = lshr i64 %product.i.i.i102.i1565, 32
  %xored.i.i.i104.i1567 = xor i64 %shifted.i.i.i103.i1566, %product.i.i.i102.i1565
  %hash.i.i.i105.i1568 = and i64 %xored.i.i.i104.i1567, %tbl_size.i.i100.i1563
  %offset_ptr.i.i106.i1569 = getelementptr i32, ptr %offset_tbl.i.i101.i1564, i64 %hash.i.i.i105.i1568
  %offset.i.i121.i1570 = load i32, ptr %offset_ptr.i.i106.i1569, align 4, !noalias !353
  %970 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %971 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %973

973:                                              ; preds = %.cont.cont.i1592, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605
  %.0566.i1572 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %977, %.cont.cont.i1592 ]
  %.070565.i1573 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %1039, %.cont.cont.i1592 ]
  %.sroa.0.0564.i1574 = phi ptr [ %vptr.i142.sroa.speculated.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %vptr.i142.sroa.speculated.i1595, %.cont.cont.i1592 ]
  %.sroa.17.0561.i1577 = phi i32 [ %offset.i.i121.i1570, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %offset.i.i154.i1609, %.cont.cont.i1592 ]
  %974 = phi <2 x i64> [ %766, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %1038, %.cont.cont.i1592 ]
  %975 = extractelement <2 x i64> %974, i64 1
  %.sroa.12.0562.i1576 = inttoptr i64 %975 to ptr
  %976 = extractelement <2 x i64> %974, i64 0
  %.sroa.6.0563.i1575 = inttoptr i64 %976 to ptr
  %977 = add nuw nsw i32 %.0566.i1572, 1
  %978 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1574, 0
  %979 = insertvalue { ptr, ptr, ptr, i32 } %978, ptr %.sroa.6.0563.i1575, 1
  %980 = insertvalue { ptr, ptr, ptr, i32 } %979, ptr %.sroa.12.0562.i1576, 2
  %981 = insertvalue { ptr, ptr, ptr, i32 } %980, i32 %.sroa.17.0561.i1577, 3
  %982 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1574)
  %983 = sext i32 %.sroa.17.0561.i1577 to i64
  %984 = getelementptr ptr, ptr %.sroa.0.0564.i1574, i64 %983
  %985 = getelementptr i8, ptr %984, i64 64
  %986 = load ptr, ptr %985, align 8
  %result.i125.i1578 = call ptr %986({ ptr, ptr, ptr, i32 } %981, ptr nocapture nofree noundef nonnull readonly %2) #15
  %987 = call i32 %result.i125.i1578({ ptr, ptr, ptr, i32 } %981, { ptr, ptr, ptr, i32 } %981, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1573, label %988, label %1004

988:                                              ; preds = %973
  %989 = load i32, ptr %42, align 8
  %990 = add i32 %989, -1
  %991 = and i32 %990, %987
  %992 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %993 = load ptr, ptr %43, align 8
  %994 = sext i32 %991 to i64
  %995 = shl nsw i64 %994, 5
  %996 = getelementptr i8, ptr %993, i64 %995
  %997 = load ptr, ptr %996, align 8
  %998 = getelementptr i8, ptr %996, i64 8
  %999 = load i160, ptr %998, align 4
  store ptr %.sroa.0.0564.i1574, ptr %996, align 8
  store i64 %976, ptr %998, align 4
  %.sroa_idx157.i1621 = getelementptr i8, ptr %996, i64 16
  store i64 %975, ptr %.sroa_idx157.i1621, align 4
  %.sroa_idx158.i1622 = getelementptr i8, ptr %996, i64 24
  store i32 %.sroa.17.0561.i1577, ptr %.sroa_idx158.i1622, align 4
  %1000 = icmp ne ptr %997, @nil_typ
  %1001 = icmp ne ptr %997, null
  %.not92.i1623 = and i1 %1000, %1001
  %extract.i1625 = lshr i160 %999, 64
  %1002 = insertelement <2 x i160> poison, i160 %999, i64 0
  %1003 = insertelement <2 x i160> %1002, i160 %extract.i1625, i64 1
  br i1 %.not92.i1623, label %.cont.cont.i1592, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1627.thread

1004:                                             ; preds = %973
  %1005 = add i32 %987, 2127912214
  %1006 = shl i32 %987, 12
  %1007 = add i32 %1005, %1006
  %1008 = ashr i32 %1007, 19
  %1009 = xor i32 %1007, %1008
  %1010 = xor i32 %1009, -949894596
  %1011 = add i32 %1010, 374761393
  %1012 = shl i32 %1010, 5
  %1013 = add i32 %1011, %1012
  %1014 = add i32 %1013, -744332180
  %1015 = shl i32 %1013, 9
  %1016 = xor i32 %1014, %1015
  %1017 = add i32 %1016, -42973499
  %1018 = shl i32 %1016, 3
  %1019 = add i32 %1017, %1018
  %1020 = ashr i32 %1019, 16
  %1021 = xor i32 %1019, %1020
  %1022 = xor i32 %1021, -1252372727
  %1023 = load i32, ptr %42, align 8
  %1024 = add i32 %1023, -1
  %1025 = and i32 %1024, %1022
  %1026 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1027 = load ptr, ptr %44, align 8
  %1028 = sext i32 %1025 to i64
  %1029 = shl nsw i64 %1028, 5
  %1030 = getelementptr i8, ptr %1027, i64 %1029
  %1031 = load ptr, ptr %1030, align 8
  %1032 = getelementptr i8, ptr %1030, i64 8
  %1033 = load i160, ptr %1032, align 4
  store ptr %.sroa.0.0564.i1574, ptr %1030, align 8
  store i64 %976, ptr %1032, align 4
  %.sroa_idx161.i1582 = getelementptr i8, ptr %1030, i64 16
  store i64 %975, ptr %.sroa_idx161.i1582, align 4
  %.sroa_idx162.i1583 = getelementptr i8, ptr %1030, i64 24
  store i32 %.sroa.17.0561.i1577, ptr %.sroa_idx162.i1583, align 4
  %1034 = icmp ne ptr %1031, @nil_typ
  %1035 = icmp ne ptr %1031, null
  %.not90.i1584 = and i1 %1034, %1035
  %extract607.i1586 = lshr i160 %1033, 64
  %1036 = insertelement <2 x i160> poison, i160 %1033, i64 0
  %1037 = insertelement <2 x i160> %1036, i160 %extract607.i1586, i64 1
  br i1 %.not90.i1584, label %.cont.cont.i1592, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1627.thread

.cont.cont.i1592:                                 ; preds = %1004, %988
  %vptr.i142.sroa.speculated.i1595 = phi ptr [ %997, %988 ], [ %1031, %1004 ]
  %.in4332 = phi <2 x i160> [ %1003, %988 ], [ %1037, %1004 ]
  %1038 = trunc <2 x i160> %.in4332 to <2 x i64>
  %1039 = xor i1 %.070565.i1573, true
  %hash_coef_ptr.i.i143.i1598 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1595, i64 8
  %tbl_size_ptr.i.i144.i1599 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1595, i64 16
  %offset_tbl_ptr.i.i145.i1600 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1595, i64 40
  %hash_coef.i.i146.i1601 = load i64, ptr %hash_coef_ptr.i.i143.i1598, align 4
  %tbl_size.i.i147.i1602 = load i64, ptr %tbl_size_ptr.i.i144.i1599, align 4
  %offset_tbl.i.i148.i1603 = load ptr, ptr %offset_tbl_ptr.i.i145.i1600, align 8
  %product.i.i.i149.i1604 = mul i64 %hash_coef.i.i146.i1601, 4015701072841558310
  %shifted.i.i.i150.i1605 = lshr i64 %product.i.i.i149.i1604, 32
  %xored.i.i.i151.i1606 = xor i64 %shifted.i.i.i150.i1605, %product.i.i.i149.i1604
  %hash.i.i.i152.i1607 = and i64 %xored.i.i.i151.i1606, %tbl_size.i.i147.i1602
  %offset_ptr.i.i153.i1608 = getelementptr i32, ptr %offset_tbl.i.i148.i1603, i64 %hash.i.i.i152.i1607
  %offset.i.i154.i1609 = load i32, ptr %offset_ptr.i.i153.i1608, align 4
  %1040 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1041 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1042 = icmp ult i32 %.0566.i1572, 99
  br i1 %1042, label %973, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1627

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1627.thread: ; preds = %988, %1004
  %1043 = phi ptr [ %32, %1004 ], [ %31, %988 ]
  %1044 = load i32, ptr %65, align 4
  store i32 %1044, ptr %1043, align 4
  %1045 = add i32 %1044, 1
  %1046 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1045, ptr %65, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1627: ; preds = %.cont.cont.i1592
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  %1047 = icmp eq ptr %vptr.i142.sroa.speculated.i1595, null
  br i1 %1047, label %HashMap_insert_keyK_valueV.exit, label %1048

1048:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1627
  %1049 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1050 = load ptr, ptr %43, align 8
  %1051 = load ptr, ptr %44, align 8
  %1052 = load i32, ptr %42, align 8
  %1053 = shl i32 %1052, 1
  %spec.select.i1643 = call i32 @llvm.smax.i32(i32 %1053, i32 16)
  store i32 %spec.select.i1643, ptr %42, align 8
  %1054 = zext nneg i32 %spec.select.i1643 to i64
  %1055 = shl nuw nsw i64 %1054, 5
  %result.i.i1644 = call noalias ptr @bump_malloc_inner(i64 noundef %1055, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1644, ptr %43, align 8
  %result.i20.i1645 = call noalias ptr @bump_malloc_inner(i64 noundef %1055, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1645, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %1056 = icmp sgt i32 %1052, 0
  br i1 %1056, label %.lr.ph.i2635, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668.thread: ; preds = %1048
  %1057 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit

.lr.ph.i2635:                                     ; preds = %1048, %._crit_edge.i2650
  %.060.i2648 = phi i32 [ %1146, %._crit_edge.i2650 ], [ 0, %1048 ]
  %1058 = zext nneg i32 %.060.i2648 to i64
  %1059 = shl nuw nsw i64 %1058, 5
  %1060 = getelementptr i8, ptr %1050, i64 %1059
  %1061 = load ptr, ptr %1060, align 8
  %1062 = icmp ne ptr %1061, @nil_typ
  %1063 = icmp ne ptr %1061, null
  %.not16.i2649 = and i1 %1062, %1063
  br i1 %.not16.i2649, label %1064, label %._crit_edge.i2650

1064:                                             ; preds = %.lr.ph.i2635
  %1065 = getelementptr i8, ptr %1060, i64 8
  %1066 = load <2 x i64>, ptr %1065, align 4
  %hash_coef_ptr.i.i18.i2652 = getelementptr i8, ptr %1061, i64 8
  %tbl_size_ptr.i.i19.i2653 = getelementptr i8, ptr %1061, i64 16
  %offset_tbl_ptr.i.i20.i2654 = getelementptr i8, ptr %1061, i64 40
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i3303 = load i64, ptr %hash_coef_ptr.i.i18.i2652, align 4, !noalias !22
  %tbl_size.i.i100.i3304 = load i64, ptr %tbl_size_ptr.i.i19.i2653, align 4, !noalias !22
  %offset_tbl.i.i101.i3305 = load ptr, ptr %offset_tbl_ptr.i.i20.i2654, align 8, !noalias !22
  %product.i.i.i102.i3306 = mul i64 %hash_coef.i.i99.i3303, 4015701072841558310
  %shifted.i.i.i103.i3307 = lshr i64 %product.i.i.i102.i3306, 32
  %xored.i.i.i104.i3308 = xor i64 %shifted.i.i.i103.i3307, %product.i.i.i102.i3306
  %hash.i.i.i105.i3309 = and i64 %xored.i.i.i104.i3308, %tbl_size.i.i100.i3304
  %offset_ptr.i.i106.i3310 = getelementptr i32, ptr %offset_tbl.i.i101.i3305, i64 %hash.i.i.i105.i3309
  %offset.i.i121.i3311 = load i32, ptr %offset_ptr.i.i106.i3310, align 4, !noalias !356
  %1068 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1071

1071:                                             ; preds = %.cont.cont.i3332, %1064
  %.0566.i3312 = phi i32 [ 0, %1064 ], [ %1075, %.cont.cont.i3332 ]
  %.070565.i3313 = phi i1 [ true, %1064 ], [ %1137, %.cont.cont.i3332 ]
  %.sroa.0.0564.i3314 = phi ptr [ %1061, %1064 ], [ %vptr.i142.sroa.speculated.i3335, %.cont.cont.i3332 ]
  %.sroa.17.0561.i3317 = phi i32 [ %offset.i.i121.i3311, %1064 ], [ %offset.i.i154.i3349, %.cont.cont.i3332 ]
  %1072 = phi <2 x i64> [ %1066, %1064 ], [ %1136, %.cont.cont.i3332 ]
  %1073 = extractelement <2 x i64> %1072, i64 1
  %.sroa.12.0562.i3316 = inttoptr i64 %1073 to ptr
  %1074 = extractelement <2 x i64> %1072, i64 0
  %.sroa.6.0563.i3315 = inttoptr i64 %1074 to ptr
  %1075 = add nuw nsw i32 %.0566.i3312, 1
  %1076 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3314, 0
  %1077 = insertvalue { ptr, ptr, ptr, i32 } %1076, ptr %.sroa.6.0563.i3315, 1
  %1078 = insertvalue { ptr, ptr, ptr, i32 } %1077, ptr %.sroa.12.0562.i3316, 2
  %1079 = insertvalue { ptr, ptr, ptr, i32 } %1078, i32 %.sroa.17.0561.i3317, 3
  %1080 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3314)
  %1081 = sext i32 %.sroa.17.0561.i3317 to i64
  %1082 = getelementptr ptr, ptr %.sroa.0.0564.i3314, i64 %1081
  %1083 = getelementptr i8, ptr %1082, i64 64
  %1084 = load ptr, ptr %1083, align 8
  %result.i125.i3318 = call ptr %1084({ ptr, ptr, ptr, i32 } %1079, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1085 = call i32 %result.i125.i3318({ ptr, ptr, ptr, i32 } %1079, { ptr, ptr, ptr, i32 } %1079, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3313, label %1086, label %1102

1086:                                             ; preds = %1071
  %1087 = load i32, ptr %42, align 8
  %1088 = add i32 %1087, -1
  %1089 = and i32 %1088, %1085
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1091 = load ptr, ptr %43, align 8
  %1092 = sext i32 %1089 to i64
  %1093 = shl nsw i64 %1092, 5
  %1094 = getelementptr i8, ptr %1091, i64 %1093
  %1095 = load ptr, ptr %1094, align 8
  %1096 = getelementptr i8, ptr %1094, i64 8
  %1097 = load i160, ptr %1096, align 4
  store ptr %.sroa.0.0564.i3314, ptr %1094, align 8
  store i64 %1074, ptr %1096, align 4
  %.sroa_idx157.i3361 = getelementptr i8, ptr %1094, i64 16
  store i64 %1073, ptr %.sroa_idx157.i3361, align 4
  %.sroa_idx158.i3362 = getelementptr i8, ptr %1094, i64 24
  store i32 %.sroa.17.0561.i3317, ptr %.sroa_idx158.i3362, align 4
  %1098 = icmp ne ptr %1095, @nil_typ
  %1099 = icmp ne ptr %1095, null
  %.not92.i3363 = and i1 %1098, %1099
  %extract.i3365 = lshr i160 %1097, 64
  %1100 = insertelement <2 x i160> poison, i160 %1097, i64 0
  %1101 = insertelement <2 x i160> %1100, i160 %extract.i3365, i64 1
  br i1 %.not92.i3363, label %.cont.cont.i3332, label %1141

1102:                                             ; preds = %1071
  %1103 = add i32 %1085, 2127912214
  %1104 = shl i32 %1085, 12
  %1105 = add i32 %1103, %1104
  %1106 = ashr i32 %1105, 19
  %1107 = xor i32 %1105, %1106
  %1108 = xor i32 %1107, -949894596
  %1109 = add i32 %1108, 374761393
  %1110 = shl i32 %1108, 5
  %1111 = add i32 %1109, %1110
  %1112 = add i32 %1111, -744332180
  %1113 = shl i32 %1111, 9
  %1114 = xor i32 %1112, %1113
  %1115 = add i32 %1114, -42973499
  %1116 = shl i32 %1114, 3
  %1117 = add i32 %1115, %1116
  %1118 = ashr i32 %1117, 16
  %1119 = xor i32 %1117, %1118
  %1120 = xor i32 %1119, -1252372727
  %1121 = load i32, ptr %42, align 8
  %1122 = add i32 %1121, -1
  %1123 = and i32 %1122, %1120
  %1124 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1125 = load ptr, ptr %44, align 8
  %1126 = sext i32 %1123 to i64
  %1127 = shl nsw i64 %1126, 5
  %1128 = getelementptr i8, ptr %1125, i64 %1127
  %1129 = load ptr, ptr %1128, align 8
  %1130 = getelementptr i8, ptr %1128, i64 8
  %1131 = load i160, ptr %1130, align 4
  store ptr %.sroa.0.0564.i3314, ptr %1128, align 8
  store i64 %1074, ptr %1130, align 4
  %.sroa_idx161.i3322 = getelementptr i8, ptr %1128, i64 16
  store i64 %1073, ptr %.sroa_idx161.i3322, align 4
  %.sroa_idx162.i3323 = getelementptr i8, ptr %1128, i64 24
  store i32 %.sroa.17.0561.i3317, ptr %.sroa_idx162.i3323, align 4
  %1132 = icmp ne ptr %1129, @nil_typ
  %1133 = icmp ne ptr %1129, null
  %.not90.i3324 = and i1 %1132, %1133
  %extract607.i3326 = lshr i160 %1131, 64
  %1134 = insertelement <2 x i160> poison, i160 %1131, i64 0
  %1135 = insertelement <2 x i160> %1134, i160 %extract607.i3326, i64 1
  br i1 %.not90.i3324, label %.cont.cont.i3332, label %1141

.cont.cont.i3332:                                 ; preds = %1102, %1086
  %vptr.i142.sroa.speculated.i3335 = phi ptr [ %1095, %1086 ], [ %1129, %1102 ]
  %.in4333 = phi <2 x i160> [ %1101, %1086 ], [ %1135, %1102 ]
  %1136 = trunc <2 x i160> %.in4333 to <2 x i64>
  %1137 = xor i1 %.070565.i3313, true
  %hash_coef_ptr.i.i143.i3338 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3335, i64 8
  %tbl_size_ptr.i.i144.i3339 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3335, i64 16
  %offset_tbl_ptr.i.i145.i3340 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3335, i64 40
  %hash_coef.i.i146.i3341 = load i64, ptr %hash_coef_ptr.i.i143.i3338, align 4
  %tbl_size.i.i147.i3342 = load i64, ptr %tbl_size_ptr.i.i144.i3339, align 4
  %offset_tbl.i.i148.i3343 = load ptr, ptr %offset_tbl_ptr.i.i145.i3340, align 8
  %product.i.i.i149.i3344 = mul i64 %hash_coef.i.i146.i3341, 4015701072841558310
  %shifted.i.i.i150.i3345 = lshr i64 %product.i.i.i149.i3344, 32
  %xored.i.i.i151.i3346 = xor i64 %shifted.i.i.i150.i3345, %product.i.i.i149.i3344
  %hash.i.i.i152.i3347 = and i64 %xored.i.i.i151.i3346, %tbl_size.i.i147.i3342
  %offset_ptr.i.i153.i3348 = getelementptr i32, ptr %offset_tbl.i.i148.i3343, i64 %hash.i.i.i152.i3347
  %offset.i.i154.i3349 = load i32, ptr %offset_ptr.i.i153.i3348, align 4
  %1138 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1139 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1140 = icmp ult i32 %.0566.i3312, 99
  br i1 %1140, label %1071, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3367

1141:                                             ; preds = %1102, %1086
  %1142 = phi ptr [ %18, %1102 ], [ %17, %1086 ]
  %1143 = load i32, ptr %65, align 4
  store i32 %1143, ptr %1142, align 4
  %1144 = add i32 %1143, 1
  %1145 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1144, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3367

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3367: ; preds = %.cont.cont.i3332, %1141
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i2650

._crit_edge.i2650:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3367, %.lr.ph.i2635
  %1146 = add nuw nsw i32 %.060.i2648, 1
  %1147 = icmp slt i32 %1146, %1052
  br i1 %1147, label %.lr.ph.i2635, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668: ; preds = %._crit_edge.i2650
  %1148 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1149

1149:                                             ; preds = %._crit_edge.i2686, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668
  %.060.i2684 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668 ], [ %1238, %._crit_edge.i2686 ]
  %1150 = zext nneg i32 %.060.i2684 to i64
  %1151 = shl nuw nsw i64 %1150, 5
  %1152 = getelementptr i8, ptr %1051, i64 %1151
  %1153 = load ptr, ptr %1152, align 8
  %1154 = icmp ne ptr %1153, @nil_typ
  %1155 = icmp ne ptr %1153, null
  %.not16.i2685 = and i1 %1154, %1155
  br i1 %.not16.i2685, label %1156, label %._crit_edge.i2686

1156:                                             ; preds = %1149
  %1157 = getelementptr i8, ptr %1152, i64 8
  %1158 = load <2 x i64>, ptr %1157, align 4
  %hash_coef_ptr.i.i18.i2688 = getelementptr i8, ptr %1153, i64 8
  %tbl_size_ptr.i.i19.i2689 = getelementptr i8, ptr %1153, i64 16
  %offset_tbl_ptr.i.i20.i2690 = getelementptr i8, ptr %1153, i64 40
  %1159 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i3385 = load i64, ptr %hash_coef_ptr.i.i18.i2688, align 4, !noalias !22
  %tbl_size.i.i100.i3386 = load i64, ptr %tbl_size_ptr.i.i19.i2689, align 4, !noalias !22
  %offset_tbl.i.i101.i3387 = load ptr, ptr %offset_tbl_ptr.i.i20.i2690, align 8, !noalias !22
  %product.i.i.i102.i3388 = mul i64 %hash_coef.i.i99.i3385, 4015701072841558310
  %shifted.i.i.i103.i3389 = lshr i64 %product.i.i.i102.i3388, 32
  %xored.i.i.i104.i3390 = xor i64 %shifted.i.i.i103.i3389, %product.i.i.i102.i3388
  %hash.i.i.i105.i3391 = and i64 %xored.i.i.i104.i3390, %tbl_size.i.i100.i3386
  %offset_ptr.i.i106.i3392 = getelementptr i32, ptr %offset_tbl.i.i101.i3387, i64 %hash.i.i.i105.i3391
  %offset.i.i121.i3393 = load i32, ptr %offset_ptr.i.i106.i3392, align 4, !noalias !359
  %1160 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1162 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1163

1163:                                             ; preds = %.cont.cont.i3414, %1156
  %.0566.i3394 = phi i32 [ 0, %1156 ], [ %1167, %.cont.cont.i3414 ]
  %.070565.i3395 = phi i1 [ true, %1156 ], [ %1229, %.cont.cont.i3414 ]
  %.sroa.0.0564.i3396 = phi ptr [ %1153, %1156 ], [ %vptr.i142.sroa.speculated.i3417, %.cont.cont.i3414 ]
  %.sroa.17.0561.i3399 = phi i32 [ %offset.i.i121.i3393, %1156 ], [ %offset.i.i154.i3431, %.cont.cont.i3414 ]
  %1164 = phi <2 x i64> [ %1158, %1156 ], [ %1228, %.cont.cont.i3414 ]
  %1165 = extractelement <2 x i64> %1164, i64 1
  %.sroa.12.0562.i3398 = inttoptr i64 %1165 to ptr
  %1166 = extractelement <2 x i64> %1164, i64 0
  %.sroa.6.0563.i3397 = inttoptr i64 %1166 to ptr
  %1167 = add nuw nsw i32 %.0566.i3394, 1
  %1168 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3396, 0
  %1169 = insertvalue { ptr, ptr, ptr, i32 } %1168, ptr %.sroa.6.0563.i3397, 1
  %1170 = insertvalue { ptr, ptr, ptr, i32 } %1169, ptr %.sroa.12.0562.i3398, 2
  %1171 = insertvalue { ptr, ptr, ptr, i32 } %1170, i32 %.sroa.17.0561.i3399, 3
  %1172 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3396)
  %1173 = sext i32 %.sroa.17.0561.i3399 to i64
  %1174 = getelementptr ptr, ptr %.sroa.0.0564.i3396, i64 %1173
  %1175 = getelementptr i8, ptr %1174, i64 64
  %1176 = load ptr, ptr %1175, align 8
  %result.i125.i3400 = call ptr %1176({ ptr, ptr, ptr, i32 } %1171, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1177 = call i32 %result.i125.i3400({ ptr, ptr, ptr, i32 } %1171, { ptr, ptr, ptr, i32 } %1171, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3395, label %1178, label %1194

1178:                                             ; preds = %1163
  %1179 = load i32, ptr %42, align 8
  %1180 = add i32 %1179, -1
  %1181 = and i32 %1180, %1177
  %1182 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1183 = load ptr, ptr %43, align 8
  %1184 = sext i32 %1181 to i64
  %1185 = shl nsw i64 %1184, 5
  %1186 = getelementptr i8, ptr %1183, i64 %1185
  %1187 = load ptr, ptr %1186, align 8
  %1188 = getelementptr i8, ptr %1186, i64 8
  %1189 = load i160, ptr %1188, align 4
  store ptr %.sroa.0.0564.i3396, ptr %1186, align 8
  store i64 %1166, ptr %1188, align 4
  %.sroa_idx157.i3443 = getelementptr i8, ptr %1186, i64 16
  store i64 %1165, ptr %.sroa_idx157.i3443, align 4
  %.sroa_idx158.i3444 = getelementptr i8, ptr %1186, i64 24
  store i32 %.sroa.17.0561.i3399, ptr %.sroa_idx158.i3444, align 4
  %1190 = icmp ne ptr %1187, @nil_typ
  %1191 = icmp ne ptr %1187, null
  %.not92.i3445 = and i1 %1190, %1191
  %extract.i3447 = lshr i160 %1189, 64
  %1192 = insertelement <2 x i160> poison, i160 %1189, i64 0
  %1193 = insertelement <2 x i160> %1192, i160 %extract.i3447, i64 1
  br i1 %.not92.i3445, label %.cont.cont.i3414, label %1233

1194:                                             ; preds = %1163
  %1195 = add i32 %1177, 2127912214
  %1196 = shl i32 %1177, 12
  %1197 = add i32 %1195, %1196
  %1198 = ashr i32 %1197, 19
  %1199 = xor i32 %1197, %1198
  %1200 = xor i32 %1199, -949894596
  %1201 = add i32 %1200, 374761393
  %1202 = shl i32 %1200, 5
  %1203 = add i32 %1201, %1202
  %1204 = add i32 %1203, -744332180
  %1205 = shl i32 %1203, 9
  %1206 = xor i32 %1204, %1205
  %1207 = add i32 %1206, -42973499
  %1208 = shl i32 %1206, 3
  %1209 = add i32 %1207, %1208
  %1210 = ashr i32 %1209, 16
  %1211 = xor i32 %1209, %1210
  %1212 = xor i32 %1211, -1252372727
  %1213 = load i32, ptr %42, align 8
  %1214 = add i32 %1213, -1
  %1215 = and i32 %1214, %1212
  %1216 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1217 = load ptr, ptr %44, align 8
  %1218 = sext i32 %1215 to i64
  %1219 = shl nsw i64 %1218, 5
  %1220 = getelementptr i8, ptr %1217, i64 %1219
  %1221 = load ptr, ptr %1220, align 8
  %1222 = getelementptr i8, ptr %1220, i64 8
  %1223 = load i160, ptr %1222, align 4
  store ptr %.sroa.0.0564.i3396, ptr %1220, align 8
  store i64 %1166, ptr %1222, align 4
  %.sroa_idx161.i3404 = getelementptr i8, ptr %1220, i64 16
  store i64 %1165, ptr %.sroa_idx161.i3404, align 4
  %.sroa_idx162.i3405 = getelementptr i8, ptr %1220, i64 24
  store i32 %.sroa.17.0561.i3399, ptr %.sroa_idx162.i3405, align 4
  %1224 = icmp ne ptr %1221, @nil_typ
  %1225 = icmp ne ptr %1221, null
  %.not90.i3406 = and i1 %1224, %1225
  %extract607.i3408 = lshr i160 %1223, 64
  %1226 = insertelement <2 x i160> poison, i160 %1223, i64 0
  %1227 = insertelement <2 x i160> %1226, i160 %extract607.i3408, i64 1
  br i1 %.not90.i3406, label %.cont.cont.i3414, label %1233

.cont.cont.i3414:                                 ; preds = %1194, %1178
  %vptr.i142.sroa.speculated.i3417 = phi ptr [ %1187, %1178 ], [ %1221, %1194 ]
  %.in4334 = phi <2 x i160> [ %1193, %1178 ], [ %1227, %1194 ]
  %1228 = trunc <2 x i160> %.in4334 to <2 x i64>
  %1229 = xor i1 %.070565.i3395, true
  %hash_coef_ptr.i.i143.i3420 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3417, i64 8
  %tbl_size_ptr.i.i144.i3421 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3417, i64 16
  %offset_tbl_ptr.i.i145.i3422 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3417, i64 40
  %hash_coef.i.i146.i3423 = load i64, ptr %hash_coef_ptr.i.i143.i3420, align 4
  %tbl_size.i.i147.i3424 = load i64, ptr %tbl_size_ptr.i.i144.i3421, align 4
  %offset_tbl.i.i148.i3425 = load ptr, ptr %offset_tbl_ptr.i.i145.i3422, align 8
  %product.i.i.i149.i3426 = mul i64 %hash_coef.i.i146.i3423, 4015701072841558310
  %shifted.i.i.i150.i3427 = lshr i64 %product.i.i.i149.i3426, 32
  %xored.i.i.i151.i3428 = xor i64 %shifted.i.i.i150.i3427, %product.i.i.i149.i3426
  %hash.i.i.i152.i3429 = and i64 %xored.i.i.i151.i3428, %tbl_size.i.i147.i3424
  %offset_ptr.i.i153.i3430 = getelementptr i32, ptr %offset_tbl.i.i148.i3425, i64 %hash.i.i.i152.i3429
  %offset.i.i154.i3431 = load i32, ptr %offset_ptr.i.i153.i3430, align 4
  %1230 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1231 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1232 = icmp ult i32 %.0566.i3394, 99
  br i1 %1232, label %1163, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3449

1233:                                             ; preds = %1194, %1178
  %1234 = phi ptr [ %16, %1194 ], [ %15, %1178 ]
  %1235 = load i32, ptr %65, align 4
  store i32 %1235, ptr %1234, align 4
  %1236 = add i32 %1235, 1
  %1237 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1236, ptr %65, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3449

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3449: ; preds = %.cont.cont.i3414, %1233
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i2686

._crit_edge.i2686:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3449, %1149
  %1238 = add nuw nsw i32 %.060.i2684, 1
  %1239 = icmp slt i32 %1238, %1052
  br i1 %1239, label %1149, label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %._crit_edge.i2686, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1627.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1490, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1627
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1240 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %1241 = sext i32 %.0357715 to i64
  %1242 = shl nsw i64 %1241, 2
  %1243 = getelementptr i8, ptr %result.i4.i, i64 %1242
  store i32 %72, ptr %1243, align 1
  store i1 true, ptr %.sroa.0316.sroa.0, align 8
  %.sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.0. = load i8, ptr %.sroa.0316.sroa.0, align 8
  %.sroa.0316.0.insert.ext = zext i8 %.sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.0. to i160
  %1244 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0316.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1245 = load ptr, ptr %result.i421, align 8
  %1246 = load ptr, ptr %54, align 8
  %1247 = call i32 %1246({ ptr, i160 } %73) #7
  %1248 = load i32, ptr %56, align 8
  %1249 = add i32 %1248, -1
  %1250 = and i32 %1249, %1247
  %1251 = load ptr, ptr %57, align 8
  %1252 = load ptr, ptr %49, align 8
  %1253 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1254 = sext i32 %1250 to i64
  %1255 = shl nsw i64 %1254, 5
  %1256 = getelementptr i8, ptr %1251, i64 %1255
  %1257 = load ptr, ptr %1256, align 8
  %1258 = getelementptr i8, ptr %1256, i64 8
  %1259 = icmp ne ptr %1257, @nil_typ
  %1260 = icmp ne ptr %1257, null
  %.not64.i1689 = and i1 %1259, %1260
  br i1 %.not64.i1689, label %1261, label %1358

1261:                                             ; preds = %HashMap_insert_keyK_valueV.exit
  %1262 = load i64, ptr %1258, align 4
  %.sroa_idx.i1691 = getelementptr i8, ptr %1256, i64 16
  %1263 = load i64, ptr %.sroa_idx.i1691, align 4
  %1264 = inttoptr i64 %1262 to ptr
  %1265 = inttoptr i64 %1263 to ptr
  %hash_coef_ptr.i.i66.i1692 = getelementptr i8, ptr %1257, i64 8
  %tbl_size_ptr.i.i67.i1693 = getelementptr i8, ptr %1257, i64 16
  %offset_tbl_ptr.i.i68.i1694 = getelementptr i8, ptr %1257, i64 40
  %hash_coef.i.i69.i1695 = load i64, ptr %hash_coef_ptr.i.i66.i1692, align 4, !noalias !362
  %tbl_size.i.i70.i1696 = load i64, ptr %tbl_size_ptr.i.i67.i1693, align 4, !noalias !362
  %offset_tbl.i.i71.i1697 = load ptr, ptr %offset_tbl_ptr.i.i68.i1694, align 8, !noalias !362
  %product.i.i.i72.i1698 = mul i64 %hash_coef.i.i69.i1695, 4015701072841558310
  %shifted.i.i.i73.i1699 = lshr i64 %product.i.i.i72.i1698, 32
  %xored.i.i.i74.i1700 = xor i64 %shifted.i.i.i73.i1699, %product.i.i.i72.i1698
  %hash.i.i.i75.i1701 = and i64 %xored.i.i.i74.i1700, %tbl_size.i.i70.i1696
  %offset_ptr.i.i76.i1702 = getelementptr i32, ptr %offset_tbl.i.i71.i1697, i64 %hash.i.i.i75.i1701
  %offset.i.i77.i1703 = load i32, ptr %offset_ptr.i.i76.i1702, align 4, !noalias !362
  %1266 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1257, 0
  %1267 = insertvalue { ptr, ptr, ptr, i32 } %1266, ptr %1264, 1
  %1268 = insertvalue { ptr, ptr, ptr, i32 } %1267, ptr %1265, 2
  %1269 = insertvalue { ptr, ptr, ptr, i32 } %1268, i32 %offset.i.i77.i1703, 3
  %1270 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1257) #34
  %1272 = sext i32 %offset.i.i77.i1703 to i64
  %1273 = getelementptr ptr, ptr %1257, i64 %1272
  %1274 = getelementptr i8, ptr %1273, i64 64
  %1275 = load ptr, ptr %1274, align 8
  %result.i.i1704 = call ptr %1275({ ptr, ptr, ptr, i32 } %1269, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1276 = call i32 %result.i.i1704({ ptr, ptr, ptr, i32 } %1269, { ptr, ptr, ptr, i32 } %1269, ptr nonnull align 8 %2) #7
  %1277 = icmp eq i32 %1276, %1247
  br i1 %1277, label %._crit_edge.i1705, label %1358

._crit_edge.i1705:                                ; preds = %1261
  %1278 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1279 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1257)
  %1280 = getelementptr i8, ptr %1273, i64 48
  %1281 = load ptr, ptr %1280, align 8
  %result.i79.i1706 = call ptr %1281({ ptr, ptr, ptr, i32 } %1269, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1282 = call { ptr, i160 } %result.i79.i1706({ ptr, ptr, ptr, i32 } %1269, { ptr, ptr, ptr, i32 } %1269, ptr nonnull align 8 %2) #7
  %1283 = load ptr, ptr %55, align 8
  %1284 = call i1 %1283({ ptr, i160 } %1282, { ptr, i160 } %73) #7
  br i1 %1284, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1718, label %1358

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1718: ; preds = %._crit_edge.i1705
  %1285 = load ptr, ptr %result.i421, align 8
  %1286 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1287 = load ptr, ptr %49, align 8
  %1288 = load ptr, ptr %1285, align 8, !alias.scope !365
  %1289 = getelementptr i8, ptr %1288, i64 72
  %1290 = load ptr, ptr %1289, align 8, !alias.scope !365
  %result.i.i.i1710 = call { i64, i64 } %1290(ptr nocapture nofree nonnull readonly %1285) #5, !alias.scope !365
  %1291 = extractvalue { i64, i64 } %result.i.i.i1710, 0
  %1292 = extractvalue { i64, i64 } %result.i.i.i1710, 1
  %1293 = urem i64 20, %1292
  %1294 = icmp eq i64 %1293, 0
  %1295 = sub i64 %1292, %1293
  %1296 = select i1 %1294, i64 0, i64 %1295
  %1297 = add i64 %1291, 20
  %1298 = add i64 %1297, %1296
  %1299 = load ptr, ptr %1287, align 8, !alias.scope !365
  %1300 = getelementptr i8, ptr %1299, i64 72
  %1301 = load ptr, ptr %1300, align 8, !alias.scope !365
  %result.i1.i.i1711 = call { i64, i64 } %1301(ptr nocapture nofree nonnull readonly %1287) #5, !alias.scope !365
  %1302 = extractvalue { i64, i64 } %result.i1.i.i1711, 0
  %1303 = extractvalue { i64, i64 } %result.i1.i.i1711, 1
  %1304 = call i64 @llvm.umax.i64(i64 %1292, i64 %1303)
  %1305 = call i64 @llvm.umax.i64(i64 %1304, i64 8)
  %1306 = urem i64 %1298, %1303
  %1307 = icmp eq i64 %1306, 0
  %1308 = sub i64 %1303, %1306
  %1309 = select i1 %1307, i64 0, i64 %1308
  %1310 = add i64 %1302, %1298
  %1311 = add i64 %1310, %1309
  %1312 = urem i64 %1311, %1305
  %1313 = icmp eq i64 %1312, 0
  %1314 = sub i64 %1305, %1312
  %1315 = select i1 %1313, i64 0, i64 %1314
  %1316 = add i64 %1315, %1311
  %result.i83.i1712 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1316, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1285, ptr %result.i83.i1712, align 8
  %1317 = getelementptr inbounds i8, ptr %result.i83.i1712, i64 8
  store ptr %1287, ptr %1317, align 8
  %1318 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1712)
  %1319 = load ptr, ptr %1285, align 8
  %1320 = getelementptr i8, ptr %1319, i64 72
  %1321 = load ptr, ptr %1320, align 8
  %result.i.i114.i1713 = call { i64, i64 } %1321(ptr nocapture nofree nonnull readonly %1285) #5
  %1322 = extractvalue { i64, i64 } %result.i.i114.i1713, 1
  %1323 = urem i64 20, %1322
  %1324 = icmp eq i64 %1323, 0
  %reass.sub = sub i64 %1322, %1323
  %1325 = add i64 %reass.sub, 20
  %1326 = select i1 %1324, i64 20, i64 %1325
  %1327 = getelementptr i8, ptr %result.i83.i1712, i64 %1326
  %1328 = getelementptr i8, ptr %1319, i64 64
  %1329 = load ptr, ptr %1328, align 8
  call void %1329({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1285, ptr nocapture nofree writeonly %1327) #12
  %1330 = load ptr, ptr %result.i83.i1712, align 8
  %1331 = load ptr, ptr %1330, align 8
  %1332 = getelementptr i8, ptr %1331, i64 72
  %1333 = load ptr, ptr %1332, align 8
  %result.i.i115.i1715 = call { i64, i64 } %1333(ptr nocapture nofree nonnull readonly %1330) #5
  %1334 = extractvalue { i64, i64 } %result.i.i115.i1715, 0
  %1335 = extractvalue { i64, i64 } %result.i.i115.i1715, 1
  %1336 = urem i64 20, %1335
  %1337 = icmp eq i64 %1336, 0
  %1338 = sub i64 %1335, %1336
  %1339 = select i1 %1337, i64 0, i64 %1338
  %1340 = add i64 %1334, 20
  %1341 = add i64 %1340, %1339
  %1342 = load ptr, ptr %1317, align 8
  %1343 = load ptr, ptr %1342, align 8
  %1344 = getelementptr i8, ptr %1343, i64 72
  %1345 = load ptr, ptr %1344, align 8
  %result.i1.i116.i1716 = call { i64, i64 } %1345(ptr nocapture nofree nonnull readonly %1342) #5
  %1346 = extractvalue { i64, i64 } %result.i1.i116.i1716, 1
  %1347 = urem i64 %1341, %1346
  %1348 = icmp eq i64 %1347, 0
  %1349 = sub i64 %1346, %1347
  %1350 = select i1 %1348, i64 0, i64 %1349
  %1351 = getelementptr i8, ptr %result.i83.i1712, i64 %1341
  %1352 = getelementptr i8, ptr %1351, i64 %1350
  %1353 = getelementptr i8, ptr %1343, i64 64
  %1354 = load ptr, ptr %1353, align 8
  call void %1354({ ptr, i160 } %1244, ptr nocapture nofree nonnull readonly %1342, ptr nocapture nofree writeonly %1352) #12
  %1355 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1356 = getelementptr inbounds i8, ptr %result.i83.i1712, i64 16
  store i32 %1247, ptr %1356, align 8
  store ptr @Entry, ptr %1256, align 8
  %1357 = ptrtoint ptr %result.i83.i1712 to i64
  store i64 %1357, ptr %1258, align 4
  %.sroa_idx28.i1717 = getelementptr i8, ptr %1256, i64 24
  store i32 10, ptr %.sroa_idx28.i1717, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit1018

1358:                                             ; preds = %._crit_edge.i1705, %HashMap_insert_keyK_valueV.exit, %1261
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1359 = add i32 %1247, 2127912214
  %1360 = shl i32 %1247, 12
  %1361 = add i32 %1359, %1360
  %1362 = ashr i32 %1361, 19
  %1363 = xor i32 %1361, %1362
  %1364 = xor i32 %1363, -949894596
  %1365 = add i32 %1364, 374761393
  %1366 = shl i32 %1364, 5
  %1367 = add i32 %1365, %1366
  %1368 = add i32 %1367, -744332180
  %1369 = shl i32 %1367, 9
  %1370 = xor i32 %1368, %1369
  %1371 = add i32 %1370, -42973499
  %1372 = shl i32 %1370, 3
  %1373 = add i32 %1371, %1372
  %1374 = ashr i32 %1373, 16
  %1375 = xor i32 %1373, %1374
  %1376 = xor i32 %1375, -1252372727
  %1377 = load i32, ptr %56, align 8
  %1378 = add i32 %1377, -1
  %1379 = and i32 %1378, %1376
  %1380 = load ptr, ptr %58, align 8
  %1381 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1382 = sext i32 %1379 to i64
  %1383 = shl nsw i64 %1382, 5
  %1384 = getelementptr i8, ptr %1380, i64 %1383
  %1385 = load ptr, ptr %1384, align 8
  %1386 = getelementptr i8, ptr %1384, i64 8
  %1387 = icmp ne ptr %1385, @nil_typ
  %1388 = icmp ne ptr %1385, null
  %.not64.i1748 = and i1 %1387, %1388
  br i1 %.not64.i1748, label %1389, label %1487

1389:                                             ; preds = %1358
  %1390 = load i64, ptr %1386, align 4
  %.sroa_idx.i1750 = getelementptr i8, ptr %1384, i64 16
  %1391 = load i64, ptr %.sroa_idx.i1750, align 4
  %1392 = inttoptr i64 %1390 to ptr
  %1393 = inttoptr i64 %1391 to ptr
  %hash_coef_ptr.i.i66.i1751 = getelementptr i8, ptr %1385, i64 8
  %tbl_size_ptr.i.i67.i1752 = getelementptr i8, ptr %1385, i64 16
  %offset_tbl_ptr.i.i68.i1753 = getelementptr i8, ptr %1385, i64 40
  %hash_coef.i.i69.i1754 = load i64, ptr %hash_coef_ptr.i.i66.i1751, align 4, !noalias !368
  %tbl_size.i.i70.i1755 = load i64, ptr %tbl_size_ptr.i.i67.i1752, align 4, !noalias !368
  %offset_tbl.i.i71.i1756 = load ptr, ptr %offset_tbl_ptr.i.i68.i1753, align 8, !noalias !368
  %product.i.i.i72.i1757 = mul i64 %hash_coef.i.i69.i1754, 4015701072841558310
  %shifted.i.i.i73.i1758 = lshr i64 %product.i.i.i72.i1757, 32
  %xored.i.i.i74.i1759 = xor i64 %shifted.i.i.i73.i1758, %product.i.i.i72.i1757
  %hash.i.i.i75.i1760 = and i64 %xored.i.i.i74.i1759, %tbl_size.i.i70.i1755
  %offset_ptr.i.i76.i1761 = getelementptr i32, ptr %offset_tbl.i.i71.i1756, i64 %hash.i.i.i75.i1760
  %offset.i.i77.i1762 = load i32, ptr %offset_ptr.i.i76.i1761, align 4, !noalias !368
  %1394 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1385, 0
  %1395 = insertvalue { ptr, ptr, ptr, i32 } %1394, ptr %1392, 1
  %1396 = insertvalue { ptr, ptr, ptr, i32 } %1395, ptr %1393, 2
  %1397 = insertvalue { ptr, ptr, ptr, i32 } %1396, i32 %offset.i.i77.i1762, 3
  %1398 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1399 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1385) #34
  %1400 = sext i32 %offset.i.i77.i1762 to i64
  %1401 = getelementptr ptr, ptr %1385, i64 %1400
  %1402 = getelementptr i8, ptr %1401, i64 64
  %1403 = load ptr, ptr %1402, align 8
  %result.i.i1763 = call ptr %1403({ ptr, ptr, ptr, i32 } %1397, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1404 = call i32 %result.i.i1763({ ptr, ptr, ptr, i32 } %1397, { ptr, ptr, ptr, i32 } %1397, ptr nonnull align 8 %2) #7
  %1405 = icmp eq i32 %1404, %1247
  br i1 %1405, label %._crit_edge.i1764, label %1487

._crit_edge.i1764:                                ; preds = %1389
  %1406 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1407 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1385)
  %1408 = getelementptr i8, ptr %1401, i64 48
  %1409 = load ptr, ptr %1408, align 8
  %result.i79.i1765 = call ptr %1409({ ptr, ptr, ptr, i32 } %1397, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1410 = call { ptr, i160 } %result.i79.i1765({ ptr, ptr, ptr, i32 } %1397, { ptr, ptr, ptr, i32 } %1397, ptr nonnull align 8 %2) #7
  %1411 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1412 = load ptr, ptr %55, align 8
  %1413 = call i1 %1412({ ptr, i160 } %1410, { ptr, i160 } %73) #7
  br i1 %1413, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1777, label %1487

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1777: ; preds = %._crit_edge.i1764
  %1414 = load ptr, ptr %result.i421, align 8
  %1415 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1416 = load ptr, ptr %49, align 8
  %1417 = load ptr, ptr %1414, align 8, !alias.scope !371
  %1418 = getelementptr i8, ptr %1417, i64 72
  %1419 = load ptr, ptr %1418, align 8, !alias.scope !371
  %result.i.i.i1769 = call { i64, i64 } %1419(ptr nocapture nofree nonnull readonly %1414) #5, !alias.scope !371
  %1420 = extractvalue { i64, i64 } %result.i.i.i1769, 0
  %1421 = extractvalue { i64, i64 } %result.i.i.i1769, 1
  %1422 = urem i64 20, %1421
  %1423 = icmp eq i64 %1422, 0
  %1424 = sub i64 %1421, %1422
  %1425 = select i1 %1423, i64 0, i64 %1424
  %1426 = add i64 %1420, 20
  %1427 = add i64 %1426, %1425
  %1428 = load ptr, ptr %1416, align 8, !alias.scope !371
  %1429 = getelementptr i8, ptr %1428, i64 72
  %1430 = load ptr, ptr %1429, align 8, !alias.scope !371
  %result.i1.i.i1770 = call { i64, i64 } %1430(ptr nocapture nofree nonnull readonly %1416) #5, !alias.scope !371
  %1431 = extractvalue { i64, i64 } %result.i1.i.i1770, 0
  %1432 = extractvalue { i64, i64 } %result.i1.i.i1770, 1
  %1433 = call i64 @llvm.umax.i64(i64 %1421, i64 %1432)
  %1434 = call i64 @llvm.umax.i64(i64 %1433, i64 8)
  %1435 = urem i64 %1427, %1432
  %1436 = icmp eq i64 %1435, 0
  %1437 = sub i64 %1432, %1435
  %1438 = select i1 %1436, i64 0, i64 %1437
  %1439 = add i64 %1431, %1427
  %1440 = add i64 %1439, %1438
  %1441 = urem i64 %1440, %1434
  %1442 = icmp eq i64 %1441, 0
  %1443 = sub i64 %1434, %1441
  %1444 = select i1 %1442, i64 0, i64 %1443
  %1445 = add i64 %1444, %1440
  %result.i83.i1771 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1445, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1414, ptr %result.i83.i1771, align 8
  %1446 = getelementptr inbounds i8, ptr %result.i83.i1771, i64 8
  store ptr %1416, ptr %1446, align 8
  %1447 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1771)
  %1448 = load ptr, ptr %1414, align 8
  %1449 = getelementptr i8, ptr %1448, i64 72
  %1450 = load ptr, ptr %1449, align 8
  %result.i.i114.i1772 = call { i64, i64 } %1450(ptr nocapture nofree nonnull readonly %1414) #5
  %1451 = extractvalue { i64, i64 } %result.i.i114.i1772, 1
  %1452 = urem i64 20, %1451
  %1453 = icmp eq i64 %1452, 0
  %reass.sub4327 = sub i64 %1451, %1452
  %1454 = add i64 %reass.sub4327, 20
  %1455 = select i1 %1453, i64 20, i64 %1454
  %1456 = getelementptr i8, ptr %result.i83.i1771, i64 %1455
  %1457 = getelementptr i8, ptr %1448, i64 64
  %1458 = load ptr, ptr %1457, align 8
  call void %1458({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1414, ptr nocapture nofree writeonly %1456) #12
  %1459 = load ptr, ptr %result.i83.i1771, align 8
  %1460 = load ptr, ptr %1459, align 8
  %1461 = getelementptr i8, ptr %1460, i64 72
  %1462 = load ptr, ptr %1461, align 8
  %result.i.i115.i1774 = call { i64, i64 } %1462(ptr nocapture nofree nonnull readonly %1459) #5
  %1463 = extractvalue { i64, i64 } %result.i.i115.i1774, 0
  %1464 = extractvalue { i64, i64 } %result.i.i115.i1774, 1
  %1465 = urem i64 20, %1464
  %1466 = icmp eq i64 %1465, 0
  %1467 = sub i64 %1464, %1465
  %1468 = select i1 %1466, i64 0, i64 %1467
  %1469 = add i64 %1463, 20
  %1470 = add i64 %1469, %1468
  %1471 = load ptr, ptr %1446, align 8
  %1472 = load ptr, ptr %1471, align 8
  %1473 = getelementptr i8, ptr %1472, i64 72
  %1474 = load ptr, ptr %1473, align 8
  %result.i1.i116.i1775 = call { i64, i64 } %1474(ptr nocapture nofree nonnull readonly %1471) #5
  %1475 = extractvalue { i64, i64 } %result.i1.i116.i1775, 1
  %1476 = urem i64 %1470, %1475
  %1477 = icmp eq i64 %1476, 0
  %1478 = sub i64 %1475, %1476
  %1479 = select i1 %1477, i64 0, i64 %1478
  %1480 = getelementptr i8, ptr %result.i83.i1771, i64 %1470
  %1481 = getelementptr i8, ptr %1480, i64 %1479
  %1482 = getelementptr i8, ptr %1472, i64 64
  %1483 = load ptr, ptr %1482, align 8
  call void %1483({ ptr, i160 } %1244, ptr nocapture nofree nonnull readonly %1471, ptr nocapture nofree writeonly %1481) #12
  %1484 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1485 = getelementptr inbounds i8, ptr %result.i83.i1771, i64 16
  store i32 %1247, ptr %1485, align 8
  store ptr @Entry, ptr %1384, align 8
  %1486 = ptrtoint ptr %result.i83.i1771 to i64
  store i64 %1486, ptr %1386, align 4
  %.sroa_idx28.i1776 = getelementptr i8, ptr %1384, i64 24
  store i32 10, ptr %.sroa_idx28.i1776, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_insert_keyK_valueV.exit1018

1487:                                             ; preds = %._crit_edge.i1764, %1358, %1389
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1488 = load i32, ptr %66, align 4
  %1489 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1490 = load i32, ptr %56, align 8
  %.not.i982 = icmp slt i32 %1488, %1490
  br i1 %.not.i982, label %._crit_edge.i984, label %1491

1491:                                             ; preds = %1487
  %1492 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1493 = load ptr, ptr %57, align 8
  %1494 = load ptr, ptr %58, align 8
  %1495 = shl i32 %1490, 1
  %spec.select.i1793 = call i32 @llvm.smax.i32(i32 %1495, i32 16)
  store i32 %spec.select.i1793, ptr %56, align 8
  %1496 = zext nneg i32 %spec.select.i1793 to i64
  %1497 = shl nuw nsw i64 %1496, 5
  %result.i.i1794 = call noalias ptr @bump_malloc_inner(i64 noundef %1497, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1794, ptr %57, align 8
  %result.i20.i1795 = call noalias ptr @bump_malloc_inner(i64 noundef %1497, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1795, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %1498 = icmp sgt i32 %1490, 0
  br i1 %1498, label %.lr.ph.i2707, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740.thread: ; preds = %1491
  %1499 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i984

.lr.ph.i2707:                                     ; preds = %1491, %._crit_edge.i2722
  %.060.i2720 = phi i32 [ %1588, %._crit_edge.i2722 ], [ 0, %1491 ]
  %1500 = zext nneg i32 %.060.i2720 to i64
  %1501 = shl nuw nsw i64 %1500, 5
  %1502 = getelementptr i8, ptr %1493, i64 %1501
  %1503 = load ptr, ptr %1502, align 8
  %1504 = icmp ne ptr %1503, @nil_typ
  %1505 = icmp ne ptr %1503, null
  %.not16.i2721 = and i1 %1504, %1505
  br i1 %.not16.i2721, label %1506, label %._crit_edge.i2722

1506:                                             ; preds = %.lr.ph.i2707
  %1507 = getelementptr i8, ptr %1502, i64 8
  %1508 = load <2 x i64>, ptr %1507, align 4
  %hash_coef_ptr.i.i18.i2724 = getelementptr i8, ptr %1503, i64 8
  %tbl_size_ptr.i.i19.i2725 = getelementptr i8, ptr %1503, i64 16
  %offset_tbl_ptr.i.i20.i2726 = getelementptr i8, ptr %1503, i64 40
  %1509 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i3467 = load i64, ptr %hash_coef_ptr.i.i18.i2724, align 4, !noalias !22
  %tbl_size.i.i100.i3468 = load i64, ptr %tbl_size_ptr.i.i19.i2725, align 4, !noalias !22
  %offset_tbl.i.i101.i3469 = load ptr, ptr %offset_tbl_ptr.i.i20.i2726, align 8, !noalias !22
  %product.i.i.i102.i3470 = mul i64 %hash_coef.i.i99.i3467, 4015701072841558310
  %shifted.i.i.i103.i3471 = lshr i64 %product.i.i.i102.i3470, 32
  %xored.i.i.i104.i3472 = xor i64 %shifted.i.i.i103.i3471, %product.i.i.i102.i3470
  %hash.i.i.i105.i3473 = and i64 %xored.i.i.i104.i3472, %tbl_size.i.i100.i3468
  %offset_ptr.i.i106.i3474 = getelementptr i32, ptr %offset_tbl.i.i101.i3469, i64 %hash.i.i.i105.i3473
  %offset.i.i121.i3475 = load i32, ptr %offset_ptr.i.i106.i3474, align 4, !noalias !374
  %1510 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1511 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1512 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1513

1513:                                             ; preds = %.cont.cont.i3496, %1506
  %.0566.i3476 = phi i32 [ 0, %1506 ], [ %1517, %.cont.cont.i3496 ]
  %.070565.i3477 = phi i1 [ true, %1506 ], [ %1579, %.cont.cont.i3496 ]
  %.sroa.0.0564.i3478 = phi ptr [ %1503, %1506 ], [ %vptr.i142.sroa.speculated.i3499, %.cont.cont.i3496 ]
  %.sroa.17.0561.i3481 = phi i32 [ %offset.i.i121.i3475, %1506 ], [ %offset.i.i154.i3513, %.cont.cont.i3496 ]
  %1514 = phi <2 x i64> [ %1508, %1506 ], [ %1578, %.cont.cont.i3496 ]
  %1515 = extractelement <2 x i64> %1514, i64 1
  %.sroa.12.0562.i3480 = inttoptr i64 %1515 to ptr
  %1516 = extractelement <2 x i64> %1514, i64 0
  %.sroa.6.0563.i3479 = inttoptr i64 %1516 to ptr
  %1517 = add nuw nsw i32 %.0566.i3476, 1
  %1518 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3478, 0
  %1519 = insertvalue { ptr, ptr, ptr, i32 } %1518, ptr %.sroa.6.0563.i3479, 1
  %1520 = insertvalue { ptr, ptr, ptr, i32 } %1519, ptr %.sroa.12.0562.i3480, 2
  %1521 = insertvalue { ptr, ptr, ptr, i32 } %1520, i32 %.sroa.17.0561.i3481, 3
  %1522 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3478)
  %1523 = sext i32 %.sroa.17.0561.i3481 to i64
  %1524 = getelementptr ptr, ptr %.sroa.0.0564.i3478, i64 %1523
  %1525 = getelementptr i8, ptr %1524, i64 64
  %1526 = load ptr, ptr %1525, align 8
  %result.i125.i3482 = call ptr %1526({ ptr, ptr, ptr, i32 } %1521, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1527 = call i32 %result.i125.i3482({ ptr, ptr, ptr, i32 } %1521, { ptr, ptr, ptr, i32 } %1521, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3477, label %1528, label %1544

1528:                                             ; preds = %1513
  %1529 = load i32, ptr %56, align 8
  %1530 = add i32 %1529, -1
  %1531 = and i32 %1530, %1527
  %1532 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1533 = load ptr, ptr %57, align 8
  %1534 = sext i32 %1531 to i64
  %1535 = shl nsw i64 %1534, 5
  %1536 = getelementptr i8, ptr %1533, i64 %1535
  %1537 = load ptr, ptr %1536, align 8
  %1538 = getelementptr i8, ptr %1536, i64 8
  %1539 = load i160, ptr %1538, align 4
  store ptr %.sroa.0.0564.i3478, ptr %1536, align 8
  store i64 %1516, ptr %1538, align 4
  %.sroa_idx157.i3525 = getelementptr i8, ptr %1536, i64 16
  store i64 %1515, ptr %.sroa_idx157.i3525, align 4
  %.sroa_idx158.i3526 = getelementptr i8, ptr %1536, i64 24
  store i32 %.sroa.17.0561.i3481, ptr %.sroa_idx158.i3526, align 4
  %1540 = icmp ne ptr %1537, @nil_typ
  %1541 = icmp ne ptr %1537, null
  %.not92.i3527 = and i1 %1540, %1541
  %extract.i3529 = lshr i160 %1539, 64
  %1542 = insertelement <2 x i160> poison, i160 %1539, i64 0
  %1543 = insertelement <2 x i160> %1542, i160 %extract.i3529, i64 1
  br i1 %.not92.i3527, label %.cont.cont.i3496, label %1583

1544:                                             ; preds = %1513
  %1545 = add i32 %1527, 2127912214
  %1546 = shl i32 %1527, 12
  %1547 = add i32 %1545, %1546
  %1548 = ashr i32 %1547, 19
  %1549 = xor i32 %1547, %1548
  %1550 = xor i32 %1549, -949894596
  %1551 = add i32 %1550, 374761393
  %1552 = shl i32 %1550, 5
  %1553 = add i32 %1551, %1552
  %1554 = add i32 %1553, -744332180
  %1555 = shl i32 %1553, 9
  %1556 = xor i32 %1554, %1555
  %1557 = add i32 %1556, -42973499
  %1558 = shl i32 %1556, 3
  %1559 = add i32 %1557, %1558
  %1560 = ashr i32 %1559, 16
  %1561 = xor i32 %1559, %1560
  %1562 = xor i32 %1561, -1252372727
  %1563 = load i32, ptr %56, align 8
  %1564 = add i32 %1563, -1
  %1565 = and i32 %1564, %1562
  %1566 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1567 = load ptr, ptr %58, align 8
  %1568 = sext i32 %1565 to i64
  %1569 = shl nsw i64 %1568, 5
  %1570 = getelementptr i8, ptr %1567, i64 %1569
  %1571 = load ptr, ptr %1570, align 8
  %1572 = getelementptr i8, ptr %1570, i64 8
  %1573 = load i160, ptr %1572, align 4
  store ptr %.sroa.0.0564.i3478, ptr %1570, align 8
  store i64 %1516, ptr %1572, align 4
  %.sroa_idx161.i3486 = getelementptr i8, ptr %1570, i64 16
  store i64 %1515, ptr %.sroa_idx161.i3486, align 4
  %.sroa_idx162.i3487 = getelementptr i8, ptr %1570, i64 24
  store i32 %.sroa.17.0561.i3481, ptr %.sroa_idx162.i3487, align 4
  %1574 = icmp ne ptr %1571, @nil_typ
  %1575 = icmp ne ptr %1571, null
  %.not90.i3488 = and i1 %1574, %1575
  %extract607.i3490 = lshr i160 %1573, 64
  %1576 = insertelement <2 x i160> poison, i160 %1573, i64 0
  %1577 = insertelement <2 x i160> %1576, i160 %extract607.i3490, i64 1
  br i1 %.not90.i3488, label %.cont.cont.i3496, label %1583

.cont.cont.i3496:                                 ; preds = %1544, %1528
  %vptr.i142.sroa.speculated.i3499 = phi ptr [ %1537, %1528 ], [ %1571, %1544 ]
  %.in4335 = phi <2 x i160> [ %1543, %1528 ], [ %1577, %1544 ]
  %1578 = trunc <2 x i160> %.in4335 to <2 x i64>
  %1579 = xor i1 %.070565.i3477, true
  %hash_coef_ptr.i.i143.i3502 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3499, i64 8
  %tbl_size_ptr.i.i144.i3503 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3499, i64 16
  %offset_tbl_ptr.i.i145.i3504 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3499, i64 40
  %hash_coef.i.i146.i3505 = load i64, ptr %hash_coef_ptr.i.i143.i3502, align 4
  %tbl_size.i.i147.i3506 = load i64, ptr %tbl_size_ptr.i.i144.i3503, align 4
  %offset_tbl.i.i148.i3507 = load ptr, ptr %offset_tbl_ptr.i.i145.i3504, align 8
  %product.i.i.i149.i3508 = mul i64 %hash_coef.i.i146.i3505, 4015701072841558310
  %shifted.i.i.i150.i3509 = lshr i64 %product.i.i.i149.i3508, 32
  %xored.i.i.i151.i3510 = xor i64 %shifted.i.i.i150.i3509, %product.i.i.i149.i3508
  %hash.i.i.i152.i3511 = and i64 %xored.i.i.i151.i3510, %tbl_size.i.i147.i3506
  %offset_ptr.i.i153.i3512 = getelementptr i32, ptr %offset_tbl.i.i148.i3507, i64 %hash.i.i.i152.i3511
  %offset.i.i154.i3513 = load i32, ptr %offset_ptr.i.i153.i3512, align 4
  %1580 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1581 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1582 = icmp ult i32 %.0566.i3476, 99
  br i1 %1582, label %1513, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3531

1583:                                             ; preds = %1544, %1528
  %1584 = phi ptr [ %14, %1544 ], [ %13, %1528 ]
  %1585 = load i32, ptr %66, align 4
  store i32 %1585, ptr %1584, align 4
  %1586 = add i32 %1585, 1
  %1587 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1586, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3531

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3531: ; preds = %.cont.cont.i3496, %1583
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i2722

._crit_edge.i2722:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3531, %.lr.ph.i2707
  %1588 = add nuw nsw i32 %.060.i2720, 1
  %1589 = icmp slt i32 %1588, %1490
  br i1 %1589, label %.lr.ph.i2707, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740: ; preds = %._crit_edge.i2722
  %1590 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1591

1591:                                             ; preds = %._crit_edge.i2758, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740
  %.060.i2756 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740 ], [ %1680, %._crit_edge.i2758 ]
  %1592 = zext nneg i32 %.060.i2756 to i64
  %1593 = shl nuw nsw i64 %1592, 5
  %1594 = getelementptr i8, ptr %1494, i64 %1593
  %1595 = load ptr, ptr %1594, align 8
  %1596 = icmp ne ptr %1595, @nil_typ
  %1597 = icmp ne ptr %1595, null
  %.not16.i2757 = and i1 %1596, %1597
  br i1 %.not16.i2757, label %1598, label %._crit_edge.i2758

1598:                                             ; preds = %1591
  %1599 = getelementptr i8, ptr %1594, i64 8
  %1600 = load <2 x i64>, ptr %1599, align 4
  %hash_coef_ptr.i.i18.i2760 = getelementptr i8, ptr %1595, i64 8
  %tbl_size_ptr.i.i19.i2761 = getelementptr i8, ptr %1595, i64 16
  %offset_tbl_ptr.i.i20.i2762 = getelementptr i8, ptr %1595, i64 40
  %1601 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i3549 = load i64, ptr %hash_coef_ptr.i.i18.i2760, align 4, !noalias !22
  %tbl_size.i.i100.i3550 = load i64, ptr %tbl_size_ptr.i.i19.i2761, align 4, !noalias !22
  %offset_tbl.i.i101.i3551 = load ptr, ptr %offset_tbl_ptr.i.i20.i2762, align 8, !noalias !22
  %product.i.i.i102.i3552 = mul i64 %hash_coef.i.i99.i3549, 4015701072841558310
  %shifted.i.i.i103.i3553 = lshr i64 %product.i.i.i102.i3552, 32
  %xored.i.i.i104.i3554 = xor i64 %shifted.i.i.i103.i3553, %product.i.i.i102.i3552
  %hash.i.i.i105.i3555 = and i64 %xored.i.i.i104.i3554, %tbl_size.i.i100.i3550
  %offset_ptr.i.i106.i3556 = getelementptr i32, ptr %offset_tbl.i.i101.i3551, i64 %hash.i.i.i105.i3555
  %offset.i.i121.i3557 = load i32, ptr %offset_ptr.i.i106.i3556, align 4, !noalias !377
  %1602 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1603 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1604 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1605

1605:                                             ; preds = %.cont.cont.i3578, %1598
  %.0566.i3558 = phi i32 [ 0, %1598 ], [ %1609, %.cont.cont.i3578 ]
  %.070565.i3559 = phi i1 [ true, %1598 ], [ %1671, %.cont.cont.i3578 ]
  %.sroa.0.0564.i3560 = phi ptr [ %1595, %1598 ], [ %vptr.i142.sroa.speculated.i3581, %.cont.cont.i3578 ]
  %.sroa.17.0561.i3563 = phi i32 [ %offset.i.i121.i3557, %1598 ], [ %offset.i.i154.i3595, %.cont.cont.i3578 ]
  %1606 = phi <2 x i64> [ %1600, %1598 ], [ %1670, %.cont.cont.i3578 ]
  %1607 = extractelement <2 x i64> %1606, i64 1
  %.sroa.12.0562.i3562 = inttoptr i64 %1607 to ptr
  %1608 = extractelement <2 x i64> %1606, i64 0
  %.sroa.6.0563.i3561 = inttoptr i64 %1608 to ptr
  %1609 = add nuw nsw i32 %.0566.i3558, 1
  %1610 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3560, 0
  %1611 = insertvalue { ptr, ptr, ptr, i32 } %1610, ptr %.sroa.6.0563.i3561, 1
  %1612 = insertvalue { ptr, ptr, ptr, i32 } %1611, ptr %.sroa.12.0562.i3562, 2
  %1613 = insertvalue { ptr, ptr, ptr, i32 } %1612, i32 %.sroa.17.0561.i3563, 3
  %1614 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3560)
  %1615 = sext i32 %.sroa.17.0561.i3563 to i64
  %1616 = getelementptr ptr, ptr %.sroa.0.0564.i3560, i64 %1615
  %1617 = getelementptr i8, ptr %1616, i64 64
  %1618 = load ptr, ptr %1617, align 8
  %result.i125.i3564 = call ptr %1618({ ptr, ptr, ptr, i32 } %1613, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1619 = call i32 %result.i125.i3564({ ptr, ptr, ptr, i32 } %1613, { ptr, ptr, ptr, i32 } %1613, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3559, label %1620, label %1636

1620:                                             ; preds = %1605
  %1621 = load i32, ptr %56, align 8
  %1622 = add i32 %1621, -1
  %1623 = and i32 %1622, %1619
  %1624 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1625 = load ptr, ptr %57, align 8
  %1626 = sext i32 %1623 to i64
  %1627 = shl nsw i64 %1626, 5
  %1628 = getelementptr i8, ptr %1625, i64 %1627
  %1629 = load ptr, ptr %1628, align 8
  %1630 = getelementptr i8, ptr %1628, i64 8
  %1631 = load i160, ptr %1630, align 4
  store ptr %.sroa.0.0564.i3560, ptr %1628, align 8
  store i64 %1608, ptr %1630, align 4
  %.sroa_idx157.i3607 = getelementptr i8, ptr %1628, i64 16
  store i64 %1607, ptr %.sroa_idx157.i3607, align 4
  %.sroa_idx158.i3608 = getelementptr i8, ptr %1628, i64 24
  store i32 %.sroa.17.0561.i3563, ptr %.sroa_idx158.i3608, align 4
  %1632 = icmp ne ptr %1629, @nil_typ
  %1633 = icmp ne ptr %1629, null
  %.not92.i3609 = and i1 %1632, %1633
  %extract.i3611 = lshr i160 %1631, 64
  %1634 = insertelement <2 x i160> poison, i160 %1631, i64 0
  %1635 = insertelement <2 x i160> %1634, i160 %extract.i3611, i64 1
  br i1 %.not92.i3609, label %.cont.cont.i3578, label %1675

1636:                                             ; preds = %1605
  %1637 = add i32 %1619, 2127912214
  %1638 = shl i32 %1619, 12
  %1639 = add i32 %1637, %1638
  %1640 = ashr i32 %1639, 19
  %1641 = xor i32 %1639, %1640
  %1642 = xor i32 %1641, -949894596
  %1643 = add i32 %1642, 374761393
  %1644 = shl i32 %1642, 5
  %1645 = add i32 %1643, %1644
  %1646 = add i32 %1645, -744332180
  %1647 = shl i32 %1645, 9
  %1648 = xor i32 %1646, %1647
  %1649 = add i32 %1648, -42973499
  %1650 = shl i32 %1648, 3
  %1651 = add i32 %1649, %1650
  %1652 = ashr i32 %1651, 16
  %1653 = xor i32 %1651, %1652
  %1654 = xor i32 %1653, -1252372727
  %1655 = load i32, ptr %56, align 8
  %1656 = add i32 %1655, -1
  %1657 = and i32 %1656, %1654
  %1658 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1659 = load ptr, ptr %58, align 8
  %1660 = sext i32 %1657 to i64
  %1661 = shl nsw i64 %1660, 5
  %1662 = getelementptr i8, ptr %1659, i64 %1661
  %1663 = load ptr, ptr %1662, align 8
  %1664 = getelementptr i8, ptr %1662, i64 8
  %1665 = load i160, ptr %1664, align 4
  store ptr %.sroa.0.0564.i3560, ptr %1662, align 8
  store i64 %1608, ptr %1664, align 4
  %.sroa_idx161.i3568 = getelementptr i8, ptr %1662, i64 16
  store i64 %1607, ptr %.sroa_idx161.i3568, align 4
  %.sroa_idx162.i3569 = getelementptr i8, ptr %1662, i64 24
  store i32 %.sroa.17.0561.i3563, ptr %.sroa_idx162.i3569, align 4
  %1666 = icmp ne ptr %1663, @nil_typ
  %1667 = icmp ne ptr %1663, null
  %.not90.i3570 = and i1 %1666, %1667
  %extract607.i3572 = lshr i160 %1665, 64
  %1668 = insertelement <2 x i160> poison, i160 %1665, i64 0
  %1669 = insertelement <2 x i160> %1668, i160 %extract607.i3572, i64 1
  br i1 %.not90.i3570, label %.cont.cont.i3578, label %1675

.cont.cont.i3578:                                 ; preds = %1636, %1620
  %vptr.i142.sroa.speculated.i3581 = phi ptr [ %1629, %1620 ], [ %1663, %1636 ]
  %.in4336 = phi <2 x i160> [ %1635, %1620 ], [ %1669, %1636 ]
  %1670 = trunc <2 x i160> %.in4336 to <2 x i64>
  %1671 = xor i1 %.070565.i3559, true
  %hash_coef_ptr.i.i143.i3584 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3581, i64 8
  %tbl_size_ptr.i.i144.i3585 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3581, i64 16
  %offset_tbl_ptr.i.i145.i3586 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3581, i64 40
  %hash_coef.i.i146.i3587 = load i64, ptr %hash_coef_ptr.i.i143.i3584, align 4
  %tbl_size.i.i147.i3588 = load i64, ptr %tbl_size_ptr.i.i144.i3585, align 4
  %offset_tbl.i.i148.i3589 = load ptr, ptr %offset_tbl_ptr.i.i145.i3586, align 8
  %product.i.i.i149.i3590 = mul i64 %hash_coef.i.i146.i3587, 4015701072841558310
  %shifted.i.i.i150.i3591 = lshr i64 %product.i.i.i149.i3590, 32
  %xored.i.i.i151.i3592 = xor i64 %shifted.i.i.i150.i3591, %product.i.i.i149.i3590
  %hash.i.i.i152.i3593 = and i64 %xored.i.i.i151.i3592, %tbl_size.i.i147.i3588
  %offset_ptr.i.i153.i3594 = getelementptr i32, ptr %offset_tbl.i.i148.i3589, i64 %hash.i.i.i152.i3593
  %offset.i.i154.i3595 = load i32, ptr %offset_ptr.i.i153.i3594, align 4
  %1672 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1674 = icmp ult i32 %.0566.i3558, 99
  br i1 %1674, label %1605, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3613

1675:                                             ; preds = %1636, %1620
  %1676 = phi ptr [ %12, %1636 ], [ %11, %1620 ]
  %1677 = load i32, ptr %66, align 4
  store i32 %1677, ptr %1676, align 4
  %1678 = add i32 %1677, 1
  %1679 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1678, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3613

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3613: ; preds = %.cont.cont.i3578, %1675
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %._crit_edge.i2758

._crit_edge.i2758:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3613, %1591
  %1680 = add nuw nsw i32 %.060.i2756, 1
  %1681 = icmp slt i32 %1680, %1490
  br i1 %1681, label %1591, label %._crit_edge.i984

._crit_edge.i984:                                 ; preds = %._crit_edge.i2758, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740.thread, %1487
  %1682 = load ptr, ptr %1245, align 8
  %1683 = getelementptr i8, ptr %1682, i64 72
  %1684 = load ptr, ptr %1683, align 8
  %result.i.i.i985 = call { i64, i64 } %1684(ptr nocapture nofree nonnull readonly %1245) #5
  %1685 = extractvalue { i64, i64 } %result.i.i.i985, 0
  %1686 = extractvalue { i64, i64 } %result.i.i.i985, 1
  %1687 = urem i64 20, %1686
  %1688 = icmp eq i64 %1687, 0
  %1689 = sub i64 %1686, %1687
  %1690 = select i1 %1688, i64 0, i64 %1689
  %1691 = add i64 %1685, 20
  %1692 = add i64 %1691, %1690
  %1693 = load ptr, ptr %1252, align 8
  %1694 = getelementptr i8, ptr %1693, i64 72
  %1695 = load ptr, ptr %1694, align 8
  %result.i1.i.i986 = call { i64, i64 } %1695(ptr nocapture nofree nonnull readonly %1252) #5
  %1696 = extractvalue { i64, i64 } %result.i1.i.i986, 0
  %1697 = extractvalue { i64, i64 } %result.i1.i.i986, 1
  %1698 = call i64 @llvm.umax.i64(i64 %1686, i64 %1697)
  %1699 = call i64 @llvm.umax.i64(i64 %1698, i64 8)
  %1700 = urem i64 %1692, %1697
  %1701 = icmp eq i64 %1700, 0
  %1702 = sub i64 %1697, %1700
  %1703 = select i1 %1701, i64 0, i64 %1702
  %1704 = add i64 %1696, %1692
  %1705 = add i64 %1704, %1703
  %1706 = urem i64 %1705, %1699
  %1707 = icmp eq i64 %1706, 0
  %1708 = sub i64 %1699, %1706
  %1709 = select i1 %1707, i64 0, i64 %1708
  %1710 = add i64 %1709, %1705
  %result.i83.i987 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1710, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1245, ptr %result.i83.i987, align 8
  %1711 = getelementptr inbounds i8, ptr %result.i83.i987, i64 8
  store ptr %1252, ptr %1711, align 8
  %1712 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i987)
  %1713 = load ptr, ptr %1245, align 8
  %1714 = getelementptr i8, ptr %1713, i64 72
  %1715 = load ptr, ptr %1714, align 8
  %result.i.i179.i988 = call { i64, i64 } %1715(ptr nocapture nofree nonnull readonly %1245) #5
  %1716 = extractvalue { i64, i64 } %result.i.i179.i988, 1
  %1717 = urem i64 20, %1716
  %1718 = icmp eq i64 %1717, 0
  %reass.sub4326 = sub i64 %1716, %1717
  %1719 = add i64 %reass.sub4326, 20
  %1720 = select i1 %1718, i64 20, i64 %1719
  %1721 = getelementptr i8, ptr %result.i83.i987, i64 %1720
  %1722 = getelementptr i8, ptr %1713, i64 64
  %1723 = load ptr, ptr %1722, align 8
  call void %1723({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1245, ptr nocapture nofree writeonly %1721) #12
  %1724 = load ptr, ptr %result.i83.i987, align 8
  %1725 = load ptr, ptr %1724, align 8
  %1726 = getelementptr i8, ptr %1725, i64 72
  %1727 = load ptr, ptr %1726, align 8
  %result.i.i180.i990 = call { i64, i64 } %1727(ptr nocapture nofree nonnull readonly %1724) #5
  %1728 = extractvalue { i64, i64 } %result.i.i180.i990, 0
  %1729 = extractvalue { i64, i64 } %result.i.i180.i990, 1
  %1730 = urem i64 20, %1729
  %1731 = icmp eq i64 %1730, 0
  %1732 = sub i64 %1729, %1730
  %1733 = select i1 %1731, i64 0, i64 %1732
  %1734 = add i64 %1728, 20
  %1735 = add i64 %1734, %1733
  %1736 = load ptr, ptr %1711, align 8
  %1737 = load ptr, ptr %1736, align 8
  %1738 = getelementptr i8, ptr %1737, i64 72
  %1739 = load ptr, ptr %1738, align 8
  %result.i1.i181.i991 = call { i64, i64 } %1739(ptr nocapture nofree nonnull readonly %1736) #5
  %1740 = extractvalue { i64, i64 } %result.i1.i181.i991, 1
  %1741 = urem i64 %1735, %1740
  %1742 = icmp eq i64 %1741, 0
  %1743 = sub i64 %1740, %1741
  %1744 = select i1 %1742, i64 0, i64 %1743
  %1745 = getelementptr i8, ptr %result.i83.i987, i64 %1735
  %1746 = getelementptr i8, ptr %1745, i64 %1744
  %1747 = getelementptr i8, ptr %1737, i64 64
  %1748 = load ptr, ptr %1747, align 8
  call void %1748({ ptr, i160 } %1244, ptr nocapture nofree nonnull readonly %1736, ptr nocapture nofree writeonly %1746) #12
  %1749 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1750 = getelementptr inbounds i8, ptr %result.i83.i987, i64 16
  store i32 %1247, ptr %1750, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %30)
  %1751 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1752 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1753 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1754

1754:                                             ; preds = %.cont.cont.i1846, %._crit_edge.i984
  %.0566.i1826 = phi i32 [ 0, %._crit_edge.i984 ], [ %1755, %.cont.cont.i1846 ]
  %.070565.i1827 = phi i1 [ true, %._crit_edge.i984 ], [ %1821, %.cont.cont.i1846 ]
  %.sroa.0.0564.i1828 = phi ptr [ @Entry, %._crit_edge.i984 ], [ %vptr.i142.sroa.speculated.i1849, %.cont.cont.i1846 ]
  %.sroa.6.0563.i1829 = phi ptr [ %result.i83.i987, %._crit_edge.i984 ], [ %spec.select539.i1851, %.cont.cont.i1846 ]
  %.sroa.12.0562.i1830 = phi ptr [ undef, %._crit_edge.i984 ], [ %spec.select.i1850, %.cont.cont.i1846 ]
  %.sroa.17.0561.i1831 = phi i32 [ 10, %._crit_edge.i984 ], [ %offset.i.i154.i1863, %.cont.cont.i1846 ]
  %1755 = add nuw nsw i32 %.0566.i1826, 1
  %1756 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1828, 0
  %1757 = insertvalue { ptr, ptr, ptr, i32 } %1756, ptr %.sroa.6.0563.i1829, 1
  %1758 = insertvalue { ptr, ptr, ptr, i32 } %1757, ptr %.sroa.12.0562.i1830, 2
  %1759 = insertvalue { ptr, ptr, ptr, i32 } %1758, i32 %.sroa.17.0561.i1831, 3
  %1760 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1828)
  %1761 = sext i32 %.sroa.17.0561.i1831 to i64
  %1762 = getelementptr ptr, ptr %.sroa.0.0564.i1828, i64 %1761
  %1763 = getelementptr i8, ptr %1762, i64 64
  %1764 = load ptr, ptr %1763, align 8
  %result.i125.i1832 = call ptr %1764({ ptr, ptr, ptr, i32 } %1759, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1765 = call i32 %result.i125.i1832({ ptr, ptr, ptr, i32 } %1759, { ptr, ptr, ptr, i32 } %1759, ptr nonnull align 8 %2) #7
  %1766 = ptrtoint ptr %.sroa.6.0563.i1829 to i64
  %1767 = ptrtoint ptr %.sroa.12.0562.i1830 to i64
  br i1 %.070565.i1827, label %1768, label %1784

1768:                                             ; preds = %1754
  %1769 = load i32, ptr %56, align 8
  %1770 = add i32 %1769, -1
  %1771 = and i32 %1770, %1765
  %1772 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1773 = load ptr, ptr %57, align 8
  %1774 = sext i32 %1771 to i64
  %1775 = shl nsw i64 %1774, 5
  %1776 = getelementptr i8, ptr %1773, i64 %1775
  %1777 = load ptr, ptr %1776, align 8
  %1778 = getelementptr i8, ptr %1776, i64 8
  %1779 = load i160, ptr %1778, align 4
  store ptr %.sroa.0.0564.i1828, ptr %1776, align 8
  store i64 %1766, ptr %1778, align 4
  %.sroa_idx157.i1875 = getelementptr i8, ptr %1776, i64 16
  store i64 %1767, ptr %.sroa_idx157.i1875, align 4
  %.sroa_idx158.i1876 = getelementptr i8, ptr %1776, i64 24
  store i32 %.sroa.17.0561.i1831, ptr %.sroa_idx158.i1876, align 4
  %1780 = icmp ne ptr %1777, @nil_typ
  %1781 = icmp ne ptr %1777, null
  %.not92.i1877 = and i1 %1780, %1781
  %extract.i1879 = lshr i160 %1779, 64
  %1782 = insertelement <2 x i160> poison, i160 %1779, i64 0
  %1783 = insertelement <2 x i160> %1782, i160 %extract.i1879, i64 1
  br i1 %.not92.i1877, label %.cont.cont.i1846, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1881.thread

1784:                                             ; preds = %1754
  %1785 = add i32 %1765, 2127912214
  %1786 = shl i32 %1765, 12
  %1787 = add i32 %1785, %1786
  %1788 = ashr i32 %1787, 19
  %1789 = xor i32 %1787, %1788
  %1790 = xor i32 %1789, -949894596
  %1791 = add i32 %1790, 374761393
  %1792 = shl i32 %1790, 5
  %1793 = add i32 %1791, %1792
  %1794 = add i32 %1793, -744332180
  %1795 = shl i32 %1793, 9
  %1796 = xor i32 %1794, %1795
  %1797 = add i32 %1796, -42973499
  %1798 = shl i32 %1796, 3
  %1799 = add i32 %1797, %1798
  %1800 = ashr i32 %1799, 16
  %1801 = xor i32 %1799, %1800
  %1802 = xor i32 %1801, -1252372727
  %1803 = load i32, ptr %56, align 8
  %1804 = add i32 %1803, -1
  %1805 = and i32 %1804, %1802
  %1806 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1807 = load ptr, ptr %58, align 8
  %1808 = sext i32 %1805 to i64
  %1809 = shl nsw i64 %1808, 5
  %1810 = getelementptr i8, ptr %1807, i64 %1809
  %1811 = load ptr, ptr %1810, align 8
  %1812 = getelementptr i8, ptr %1810, i64 8
  %1813 = load i160, ptr %1812, align 4
  store ptr %.sroa.0.0564.i1828, ptr %1810, align 8
  store i64 %1766, ptr %1812, align 4
  %.sroa_idx161.i1836 = getelementptr i8, ptr %1810, i64 16
  store i64 %1767, ptr %.sroa_idx161.i1836, align 4
  %.sroa_idx162.i1837 = getelementptr i8, ptr %1810, i64 24
  store i32 %.sroa.17.0561.i1831, ptr %.sroa_idx162.i1837, align 4
  %1814 = icmp ne ptr %1811, @nil_typ
  %1815 = icmp ne ptr %1811, null
  %.not90.i1838 = and i1 %1814, %1815
  %extract607.i1840 = lshr i160 %1813, 64
  %1816 = insertelement <2 x i160> poison, i160 %1813, i64 0
  %1817 = insertelement <2 x i160> %1816, i160 %extract607.i1840, i64 1
  br i1 %.not90.i1838, label %.cont.cont.i1846, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1881.thread

.cont.cont.i1846:                                 ; preds = %1784, %1768
  %vptr.i142.sroa.speculated.i1849 = phi ptr [ %1777, %1768 ], [ %1811, %1784 ]
  %.in4337 = phi <2 x i160> [ %1783, %1768 ], [ %1817, %1784 ]
  %1818 = trunc <2 x i160> %.in4337 to <2 x i64>
  %1819 = extractelement <2 x i64> %1818, i64 1
  %spec.select.i1850 = inttoptr i64 %1819 to ptr
  %1820 = extractelement <2 x i64> %1818, i64 0
  %spec.select539.i1851 = inttoptr i64 %1820 to ptr
  %1821 = xor i1 %.070565.i1827, true
  %hash_coef_ptr.i.i143.i1852 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1849, i64 8
  %tbl_size_ptr.i.i144.i1853 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1849, i64 16
  %offset_tbl_ptr.i.i145.i1854 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1849, i64 40
  %hash_coef.i.i146.i1855 = load i64, ptr %hash_coef_ptr.i.i143.i1852, align 4
  %tbl_size.i.i147.i1856 = load i64, ptr %tbl_size_ptr.i.i144.i1853, align 4
  %offset_tbl.i.i148.i1857 = load ptr, ptr %offset_tbl_ptr.i.i145.i1854, align 8
  %product.i.i.i149.i1858 = mul i64 %hash_coef.i.i146.i1855, 4015701072841558310
  %shifted.i.i.i150.i1859 = lshr i64 %product.i.i.i149.i1858, 32
  %xored.i.i.i151.i1860 = xor i64 %shifted.i.i.i150.i1859, %product.i.i.i149.i1858
  %hash.i.i.i152.i1861 = and i64 %xored.i.i.i151.i1860, %tbl_size.i.i147.i1856
  %offset_ptr.i.i153.i1862 = getelementptr i32, ptr %offset_tbl.i.i148.i1857, i64 %hash.i.i.i152.i1861
  %offset.i.i154.i1863 = load i32, ptr %offset_ptr.i.i153.i1862, align 4
  %1822 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1823 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1824 = icmp ult i32 %.0566.i1826, 99
  br i1 %1824, label %1754, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1881

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1881.thread: ; preds = %1768, %1784
  %1825 = phi ptr [ %30, %1784 ], [ %29, %1768 ]
  %1826 = load i32, ptr %66, align 4
  store i32 %1826, ptr %1825, align 4
  %1827 = add i32 %1826, 1
  %1828 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1827, ptr %66, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  br label %HashMap_insert_keyK_valueV.exit1018

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1881: ; preds = %.cont.cont.i1846
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  %1829 = icmp eq ptr %vptr.i142.sroa.speculated.i1849, null
  br i1 %1829, label %HashMap_insert_keyK_valueV.exit1018, label %1830

1830:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1881
  %1831 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1832 = load ptr, ptr %57, align 8
  %1833 = load ptr, ptr %58, align 8
  %1834 = load i32, ptr %56, align 8
  %1835 = shl i32 %1834, 1
  %spec.select.i1897 = call i32 @llvm.smax.i32(i32 %1835, i32 16)
  store i32 %spec.select.i1897, ptr %56, align 8
  %1836 = zext nneg i32 %spec.select.i1897 to i64
  %1837 = shl nuw nsw i64 %1836, 5
  %result.i.i1898 = call noalias ptr @bump_malloc_inner(i64 noundef %1837, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1898, ptr %57, align 8
  %result.i20.i1899 = call noalias ptr @bump_malloc_inner(i64 noundef %1837, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i1899, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %1838 = icmp sgt i32 %1834, 0
  br i1 %1838, label %.lr.ph.i2806, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875

.lr.ph.i2806:                                     ; preds = %1830, %._crit_edge.i2821
  %.060.i2819 = phi i32 [ %1927, %._crit_edge.i2821 ], [ 0, %1830 ]
  %1839 = zext nneg i32 %.060.i2819 to i64
  %1840 = shl nuw nsw i64 %1839, 5
  %1841 = getelementptr i8, ptr %1832, i64 %1840
  %1842 = load ptr, ptr %1841, align 8
  %1843 = icmp ne ptr %1842, @nil_typ
  %1844 = icmp ne ptr %1842, null
  %.not16.i2820 = and i1 %1843, %1844
  br i1 %.not16.i2820, label %1845, label %._crit_edge.i2821

1845:                                             ; preds = %.lr.ph.i2806
  %1846 = getelementptr i8, ptr %1841, i64 8
  %1847 = load <2 x i64>, ptr %1846, align 4
  %hash_coef_ptr.i.i18.i2823 = getelementptr i8, ptr %1842, i64 8
  %tbl_size_ptr.i.i19.i2824 = getelementptr i8, ptr %1842, i64 16
  %offset_tbl_ptr.i.i20.i2825 = getelementptr i8, ptr %1842, i64 40
  %1848 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i3631 = load i64, ptr %hash_coef_ptr.i.i18.i2823, align 4, !noalias !22
  %tbl_size.i.i100.i3632 = load i64, ptr %tbl_size_ptr.i.i19.i2824, align 4, !noalias !22
  %offset_tbl.i.i101.i3633 = load ptr, ptr %offset_tbl_ptr.i.i20.i2825, align 8, !noalias !22
  %product.i.i.i102.i3634 = mul i64 %hash_coef.i.i99.i3631, 4015701072841558310
  %shifted.i.i.i103.i3635 = lshr i64 %product.i.i.i102.i3634, 32
  %xored.i.i.i104.i3636 = xor i64 %shifted.i.i.i103.i3635, %product.i.i.i102.i3634
  %hash.i.i.i105.i3637 = and i64 %xored.i.i.i104.i3636, %tbl_size.i.i100.i3632
  %offset_ptr.i.i106.i3638 = getelementptr i32, ptr %offset_tbl.i.i101.i3633, i64 %hash.i.i.i105.i3637
  %offset.i.i121.i3639 = load i32, ptr %offset_ptr.i.i106.i3638, align 4, !noalias !380
  %1849 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1850 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1851 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1852

1852:                                             ; preds = %.cont.cont.i3660, %1845
  %.0566.i3640 = phi i32 [ 0, %1845 ], [ %1856, %.cont.cont.i3660 ]
  %.070565.i3641 = phi i1 [ true, %1845 ], [ %1918, %.cont.cont.i3660 ]
  %.sroa.0.0564.i3642 = phi ptr [ %1842, %1845 ], [ %vptr.i142.sroa.speculated.i3663, %.cont.cont.i3660 ]
  %.sroa.17.0561.i3645 = phi i32 [ %offset.i.i121.i3639, %1845 ], [ %offset.i.i154.i3677, %.cont.cont.i3660 ]
  %1853 = phi <2 x i64> [ %1847, %1845 ], [ %1917, %.cont.cont.i3660 ]
  %1854 = extractelement <2 x i64> %1853, i64 1
  %.sroa.12.0562.i3644 = inttoptr i64 %1854 to ptr
  %1855 = extractelement <2 x i64> %1853, i64 0
  %.sroa.6.0563.i3643 = inttoptr i64 %1855 to ptr
  %1856 = add nuw nsw i32 %.0566.i3640, 1
  %1857 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3642, 0
  %1858 = insertvalue { ptr, ptr, ptr, i32 } %1857, ptr %.sroa.6.0563.i3643, 1
  %1859 = insertvalue { ptr, ptr, ptr, i32 } %1858, ptr %.sroa.12.0562.i3644, 2
  %1860 = insertvalue { ptr, ptr, ptr, i32 } %1859, i32 %.sroa.17.0561.i3645, 3
  %1861 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3642)
  %1862 = sext i32 %.sroa.17.0561.i3645 to i64
  %1863 = getelementptr ptr, ptr %.sroa.0.0564.i3642, i64 %1862
  %1864 = getelementptr i8, ptr %1863, i64 64
  %1865 = load ptr, ptr %1864, align 8
  %result.i125.i3646 = call ptr %1865({ ptr, ptr, ptr, i32 } %1860, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1866 = call i32 %result.i125.i3646({ ptr, ptr, ptr, i32 } %1860, { ptr, ptr, ptr, i32 } %1860, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3641, label %1867, label %1883

1867:                                             ; preds = %1852
  %1868 = load i32, ptr %56, align 8
  %1869 = add i32 %1868, -1
  %1870 = and i32 %1869, %1866
  %1871 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1872 = load ptr, ptr %57, align 8
  %1873 = sext i32 %1870 to i64
  %1874 = shl nsw i64 %1873, 5
  %1875 = getelementptr i8, ptr %1872, i64 %1874
  %1876 = load ptr, ptr %1875, align 8
  %1877 = getelementptr i8, ptr %1875, i64 8
  %1878 = load i160, ptr %1877, align 4
  store ptr %.sroa.0.0564.i3642, ptr %1875, align 8
  store i64 %1855, ptr %1877, align 4
  %.sroa_idx157.i3689 = getelementptr i8, ptr %1875, i64 16
  store i64 %1854, ptr %.sroa_idx157.i3689, align 4
  %.sroa_idx158.i3690 = getelementptr i8, ptr %1875, i64 24
  store i32 %.sroa.17.0561.i3645, ptr %.sroa_idx158.i3690, align 4
  %1879 = icmp ne ptr %1876, @nil_typ
  %1880 = icmp ne ptr %1876, null
  %.not92.i3691 = and i1 %1879, %1880
  %extract.i3693 = lshr i160 %1878, 64
  %1881 = insertelement <2 x i160> poison, i160 %1878, i64 0
  %1882 = insertelement <2 x i160> %1881, i160 %extract.i3693, i64 1
  br i1 %.not92.i3691, label %.cont.cont.i3660, label %1922

1883:                                             ; preds = %1852
  %1884 = add i32 %1866, 2127912214
  %1885 = shl i32 %1866, 12
  %1886 = add i32 %1884, %1885
  %1887 = ashr i32 %1886, 19
  %1888 = xor i32 %1886, %1887
  %1889 = xor i32 %1888, -949894596
  %1890 = add i32 %1889, 374761393
  %1891 = shl i32 %1889, 5
  %1892 = add i32 %1890, %1891
  %1893 = add i32 %1892, -744332180
  %1894 = shl i32 %1892, 9
  %1895 = xor i32 %1893, %1894
  %1896 = add i32 %1895, -42973499
  %1897 = shl i32 %1895, 3
  %1898 = add i32 %1896, %1897
  %1899 = ashr i32 %1898, 16
  %1900 = xor i32 %1898, %1899
  %1901 = xor i32 %1900, -1252372727
  %1902 = load i32, ptr %56, align 8
  %1903 = add i32 %1902, -1
  %1904 = and i32 %1903, %1901
  %1905 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1906 = load ptr, ptr %58, align 8
  %1907 = sext i32 %1904 to i64
  %1908 = shl nsw i64 %1907, 5
  %1909 = getelementptr i8, ptr %1906, i64 %1908
  %1910 = load ptr, ptr %1909, align 8
  %1911 = getelementptr i8, ptr %1909, i64 8
  %1912 = load i160, ptr %1911, align 4
  store ptr %.sroa.0.0564.i3642, ptr %1909, align 8
  store i64 %1855, ptr %1911, align 4
  %.sroa_idx161.i3650 = getelementptr i8, ptr %1909, i64 16
  store i64 %1854, ptr %.sroa_idx161.i3650, align 4
  %.sroa_idx162.i3651 = getelementptr i8, ptr %1909, i64 24
  store i32 %.sroa.17.0561.i3645, ptr %.sroa_idx162.i3651, align 4
  %1913 = icmp ne ptr %1910, @nil_typ
  %1914 = icmp ne ptr %1910, null
  %.not90.i3652 = and i1 %1913, %1914
  %extract607.i3654 = lshr i160 %1912, 64
  %1915 = insertelement <2 x i160> poison, i160 %1912, i64 0
  %1916 = insertelement <2 x i160> %1915, i160 %extract607.i3654, i64 1
  br i1 %.not90.i3652, label %.cont.cont.i3660, label %1922

.cont.cont.i3660:                                 ; preds = %1883, %1867
  %vptr.i142.sroa.speculated.i3663 = phi ptr [ %1876, %1867 ], [ %1910, %1883 ]
  %.in4338 = phi <2 x i160> [ %1882, %1867 ], [ %1916, %1883 ]
  %1917 = trunc <2 x i160> %.in4338 to <2 x i64>
  %1918 = xor i1 %.070565.i3641, true
  %hash_coef_ptr.i.i143.i3666 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3663, i64 8
  %tbl_size_ptr.i.i144.i3667 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3663, i64 16
  %offset_tbl_ptr.i.i145.i3668 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3663, i64 40
  %hash_coef.i.i146.i3669 = load i64, ptr %hash_coef_ptr.i.i143.i3666, align 4
  %tbl_size.i.i147.i3670 = load i64, ptr %tbl_size_ptr.i.i144.i3667, align 4
  %offset_tbl.i.i148.i3671 = load ptr, ptr %offset_tbl_ptr.i.i145.i3668, align 8
  %product.i.i.i149.i3672 = mul i64 %hash_coef.i.i146.i3669, 4015701072841558310
  %shifted.i.i.i150.i3673 = lshr i64 %product.i.i.i149.i3672, 32
  %xored.i.i.i151.i3674 = xor i64 %shifted.i.i.i150.i3673, %product.i.i.i149.i3672
  %hash.i.i.i152.i3675 = and i64 %xored.i.i.i151.i3674, %tbl_size.i.i147.i3670
  %offset_ptr.i.i153.i3676 = getelementptr i32, ptr %offset_tbl.i.i148.i3671, i64 %hash.i.i.i152.i3675
  %offset.i.i154.i3677 = load i32, ptr %offset_ptr.i.i153.i3676, align 4
  %1919 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1920 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1921 = icmp ult i32 %.0566.i3640, 99
  br i1 %1921, label %1852, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3695

1922:                                             ; preds = %1883, %1867
  %1923 = phi ptr [ %10, %1883 ], [ %9, %1867 ]
  %1924 = load i32, ptr %66, align 4
  store i32 %1924, ptr %1923, align 4
  %1925 = add i32 %1924, 1
  %1926 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1925, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3695

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3695: ; preds = %.cont.cont.i3660, %1922
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i2821

._crit_edge.i2821:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3695, %.lr.ph.i2806
  %1927 = add nuw nsw i32 %.060.i2819, 1
  %1928 = icmp slt i32 %1927, %1834
  br i1 %1928, label %.lr.ph.i2806, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839: ; preds = %._crit_edge.i2821, %._crit_edge.i2857
  %.060.i2855 = phi i32 [ %2017, %._crit_edge.i2857 ], [ 0, %._crit_edge.i2821 ]
  %1929 = zext nneg i32 %.060.i2855 to i64
  %1930 = shl nuw nsw i64 %1929, 5
  %1931 = getelementptr i8, ptr %1833, i64 %1930
  %1932 = load ptr, ptr %1931, align 8
  %1933 = icmp ne ptr %1932, @nil_typ
  %1934 = icmp ne ptr %1932, null
  %.not16.i2856 = and i1 %1933, %1934
  br i1 %.not16.i2856, label %1935, label %._crit_edge.i2857

1935:                                             ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839
  %1936 = getelementptr i8, ptr %1931, i64 8
  %1937 = load <2 x i64>, ptr %1936, align 4
  %hash_coef_ptr.i.i18.i2859 = getelementptr i8, ptr %1932, i64 8
  %tbl_size_ptr.i.i19.i2860 = getelementptr i8, ptr %1932, i64 16
  %offset_tbl_ptr.i.i20.i2861 = getelementptr i8, ptr %1932, i64 40
  %1938 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i3713 = load i64, ptr %hash_coef_ptr.i.i18.i2859, align 4, !noalias !22
  %tbl_size.i.i100.i3714 = load i64, ptr %tbl_size_ptr.i.i19.i2860, align 4, !noalias !22
  %offset_tbl.i.i101.i3715 = load ptr, ptr %offset_tbl_ptr.i.i20.i2861, align 8, !noalias !22
  %product.i.i.i102.i3716 = mul i64 %hash_coef.i.i99.i3713, 4015701072841558310
  %shifted.i.i.i103.i3717 = lshr i64 %product.i.i.i102.i3716, 32
  %xored.i.i.i104.i3718 = xor i64 %shifted.i.i.i103.i3717, %product.i.i.i102.i3716
  %hash.i.i.i105.i3719 = and i64 %xored.i.i.i104.i3718, %tbl_size.i.i100.i3714
  %offset_ptr.i.i106.i3720 = getelementptr i32, ptr %offset_tbl.i.i101.i3715, i64 %hash.i.i.i105.i3719
  %offset.i.i121.i3721 = load i32, ptr %offset_ptr.i.i106.i3720, align 4, !noalias !383
  %1939 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1940 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1941 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1942

1942:                                             ; preds = %.cont.cont.i3742, %1935
  %.0566.i3722 = phi i32 [ 0, %1935 ], [ %1946, %.cont.cont.i3742 ]
  %.070565.i3723 = phi i1 [ true, %1935 ], [ %2008, %.cont.cont.i3742 ]
  %.sroa.0.0564.i3724 = phi ptr [ %1932, %1935 ], [ %vptr.i142.sroa.speculated.i3745, %.cont.cont.i3742 ]
  %.sroa.17.0561.i3727 = phi i32 [ %offset.i.i121.i3721, %1935 ], [ %offset.i.i154.i3759, %.cont.cont.i3742 ]
  %1943 = phi <2 x i64> [ %1937, %1935 ], [ %2007, %.cont.cont.i3742 ]
  %1944 = extractelement <2 x i64> %1943, i64 1
  %.sroa.12.0562.i3726 = inttoptr i64 %1944 to ptr
  %1945 = extractelement <2 x i64> %1943, i64 0
  %.sroa.6.0563.i3725 = inttoptr i64 %1945 to ptr
  %1946 = add nuw nsw i32 %.0566.i3722, 1
  %1947 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3724, 0
  %1948 = insertvalue { ptr, ptr, ptr, i32 } %1947, ptr %.sroa.6.0563.i3725, 1
  %1949 = insertvalue { ptr, ptr, ptr, i32 } %1948, ptr %.sroa.12.0562.i3726, 2
  %1950 = insertvalue { ptr, ptr, ptr, i32 } %1949, i32 %.sroa.17.0561.i3727, 3
  %1951 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3724)
  %1952 = sext i32 %.sroa.17.0561.i3727 to i64
  %1953 = getelementptr ptr, ptr %.sroa.0.0564.i3724, i64 %1952
  %1954 = getelementptr i8, ptr %1953, i64 64
  %1955 = load ptr, ptr %1954, align 8
  %result.i125.i3728 = call ptr %1955({ ptr, ptr, ptr, i32 } %1950, ptr nocapture nofree noundef nonnull readonly %2) #15
  %1956 = call i32 %result.i125.i3728({ ptr, ptr, ptr, i32 } %1950, { ptr, ptr, ptr, i32 } %1950, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3723, label %1957, label %1973

1957:                                             ; preds = %1942
  %1958 = load i32, ptr %56, align 8
  %1959 = add i32 %1958, -1
  %1960 = and i32 %1959, %1956
  %1961 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1962 = load ptr, ptr %57, align 8
  %1963 = sext i32 %1960 to i64
  %1964 = shl nsw i64 %1963, 5
  %1965 = getelementptr i8, ptr %1962, i64 %1964
  %1966 = load ptr, ptr %1965, align 8
  %1967 = getelementptr i8, ptr %1965, i64 8
  %1968 = load i160, ptr %1967, align 4
  store ptr %.sroa.0.0564.i3724, ptr %1965, align 8
  store i64 %1945, ptr %1967, align 4
  %.sroa_idx157.i3771 = getelementptr i8, ptr %1965, i64 16
  store i64 %1944, ptr %.sroa_idx157.i3771, align 4
  %.sroa_idx158.i3772 = getelementptr i8, ptr %1965, i64 24
  store i32 %.sroa.17.0561.i3727, ptr %.sroa_idx158.i3772, align 4
  %1969 = icmp ne ptr %1966, @nil_typ
  %1970 = icmp ne ptr %1966, null
  %.not92.i3773 = and i1 %1969, %1970
  %extract.i3775 = lshr i160 %1968, 64
  %1971 = insertelement <2 x i160> poison, i160 %1968, i64 0
  %1972 = insertelement <2 x i160> %1971, i160 %extract.i3775, i64 1
  br i1 %.not92.i3773, label %.cont.cont.i3742, label %2012

1973:                                             ; preds = %1942
  %1974 = add i32 %1956, 2127912214
  %1975 = shl i32 %1956, 12
  %1976 = add i32 %1974, %1975
  %1977 = ashr i32 %1976, 19
  %1978 = xor i32 %1976, %1977
  %1979 = xor i32 %1978, -949894596
  %1980 = add i32 %1979, 374761393
  %1981 = shl i32 %1979, 5
  %1982 = add i32 %1980, %1981
  %1983 = add i32 %1982, -744332180
  %1984 = shl i32 %1982, 9
  %1985 = xor i32 %1983, %1984
  %1986 = add i32 %1985, -42973499
  %1987 = shl i32 %1985, 3
  %1988 = add i32 %1986, %1987
  %1989 = ashr i32 %1988, 16
  %1990 = xor i32 %1988, %1989
  %1991 = xor i32 %1990, -1252372727
  %1992 = load i32, ptr %56, align 8
  %1993 = add i32 %1992, -1
  %1994 = and i32 %1993, %1991
  %1995 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1996 = load ptr, ptr %58, align 8
  %1997 = sext i32 %1994 to i64
  %1998 = shl nsw i64 %1997, 5
  %1999 = getelementptr i8, ptr %1996, i64 %1998
  %2000 = load ptr, ptr %1999, align 8
  %2001 = getelementptr i8, ptr %1999, i64 8
  %2002 = load i160, ptr %2001, align 4
  store ptr %.sroa.0.0564.i3724, ptr %1999, align 8
  store i64 %1945, ptr %2001, align 4
  %.sroa_idx161.i3732 = getelementptr i8, ptr %1999, i64 16
  store i64 %1944, ptr %.sroa_idx161.i3732, align 4
  %.sroa_idx162.i3733 = getelementptr i8, ptr %1999, i64 24
  store i32 %.sroa.17.0561.i3727, ptr %.sroa_idx162.i3733, align 4
  %2003 = icmp ne ptr %2000, @nil_typ
  %2004 = icmp ne ptr %2000, null
  %.not90.i3734 = and i1 %2003, %2004
  %extract607.i3736 = lshr i160 %2002, 64
  %2005 = insertelement <2 x i160> poison, i160 %2002, i64 0
  %2006 = insertelement <2 x i160> %2005, i160 %extract607.i3736, i64 1
  br i1 %.not90.i3734, label %.cont.cont.i3742, label %2012

.cont.cont.i3742:                                 ; preds = %1973, %1957
  %vptr.i142.sroa.speculated.i3745 = phi ptr [ %1966, %1957 ], [ %2000, %1973 ]
  %.in4339 = phi <2 x i160> [ %1972, %1957 ], [ %2006, %1973 ]
  %2007 = trunc <2 x i160> %.in4339 to <2 x i64>
  %2008 = xor i1 %.070565.i3723, true
  %hash_coef_ptr.i.i143.i3748 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3745, i64 8
  %tbl_size_ptr.i.i144.i3749 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3745, i64 16
  %offset_tbl_ptr.i.i145.i3750 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3745, i64 40
  %hash_coef.i.i146.i3751 = load i64, ptr %hash_coef_ptr.i.i143.i3748, align 4
  %tbl_size.i.i147.i3752 = load i64, ptr %tbl_size_ptr.i.i144.i3749, align 4
  %offset_tbl.i.i148.i3753 = load ptr, ptr %offset_tbl_ptr.i.i145.i3750, align 8
  %product.i.i.i149.i3754 = mul i64 %hash_coef.i.i146.i3751, 4015701072841558310
  %shifted.i.i.i150.i3755 = lshr i64 %product.i.i.i149.i3754, 32
  %xored.i.i.i151.i3756 = xor i64 %shifted.i.i.i150.i3755, %product.i.i.i149.i3754
  %hash.i.i.i152.i3757 = and i64 %xored.i.i.i151.i3756, %tbl_size.i.i147.i3752
  %offset_ptr.i.i153.i3758 = getelementptr i32, ptr %offset_tbl.i.i148.i3753, i64 %hash.i.i.i152.i3757
  %offset.i.i154.i3759 = load i32, ptr %offset_ptr.i.i153.i3758, align 4
  %2009 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2010 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2011 = icmp ult i32 %.0566.i3722, 99
  br i1 %2011, label %1942, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3777

2012:                                             ; preds = %1973, %1957
  %2013 = phi ptr [ %8, %1973 ], [ %7, %1957 ]
  %2014 = load i32, ptr %66, align 4
  store i32 %2014, ptr %2013, align 4
  %2015 = add i32 %2014, 1
  %2016 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2015, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3777

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3777: ; preds = %.cont.cont.i3742, %2012
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i2857

._crit_edge.i2857:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3777, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839
  %2017 = add nuw nsw i32 %.060.i2855, 1
  %2018 = icmp slt i32 %2017, %1834
  br i1 %2018, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875: ; preds = %._crit_edge.i2857, %1830
  %2019 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %28)
  %hash_coef.i.i99.i1920 = load i64, ptr %hash_coef_ptr.i.i143.i1852, align 4, !noalias !22
  %tbl_size.i.i100.i1921 = load i64, ptr %tbl_size_ptr.i.i144.i1853, align 4, !noalias !22
  %offset_tbl.i.i101.i1922 = load ptr, ptr %offset_tbl_ptr.i.i145.i1854, align 8, !noalias !22
  %product.i.i.i102.i1923 = mul i64 %hash_coef.i.i99.i1920, 4015701072841558310
  %shifted.i.i.i103.i1924 = lshr i64 %product.i.i.i102.i1923, 32
  %xored.i.i.i104.i1925 = xor i64 %shifted.i.i.i103.i1924, %product.i.i.i102.i1923
  %hash.i.i.i105.i1926 = and i64 %xored.i.i.i104.i1925, %tbl_size.i.i100.i1921
  %offset_ptr.i.i106.i1927 = getelementptr i32, ptr %offset_tbl.i.i101.i1922, i64 %hash.i.i.i105.i1926
  %offset.i.i121.i1928 = load i32, ptr %offset_ptr.i.i106.i1927, align 4, !noalias !386
  %2020 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2021 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2022 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2023

2023:                                             ; preds = %.cont.cont.i1950, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875
  %.0566.i1930 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %2027, %.cont.cont.i1950 ]
  %.070565.i1931 = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %2089, %.cont.cont.i1950 ]
  %.sroa.0.0564.i1932 = phi ptr [ %vptr.i142.sroa.speculated.i1849, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %vptr.i142.sroa.speculated.i1953, %.cont.cont.i1950 ]
  %.sroa.17.0561.i1935 = phi i32 [ %offset.i.i121.i1928, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %offset.i.i154.i1967, %.cont.cont.i1950 ]
  %2024 = phi <2 x i64> [ %1818, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %2088, %.cont.cont.i1950 ]
  %2025 = extractelement <2 x i64> %2024, i64 1
  %.sroa.12.0562.i1934 = inttoptr i64 %2025 to ptr
  %2026 = extractelement <2 x i64> %2024, i64 0
  %.sroa.6.0563.i1933 = inttoptr i64 %2026 to ptr
  %2027 = add nuw nsw i32 %.0566.i1930, 1
  %2028 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1932, 0
  %2029 = insertvalue { ptr, ptr, ptr, i32 } %2028, ptr %.sroa.6.0563.i1933, 1
  %2030 = insertvalue { ptr, ptr, ptr, i32 } %2029, ptr %.sroa.12.0562.i1934, 2
  %2031 = insertvalue { ptr, ptr, ptr, i32 } %2030, i32 %.sroa.17.0561.i1935, 3
  %2032 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1932)
  %2033 = sext i32 %.sroa.17.0561.i1935 to i64
  %2034 = getelementptr ptr, ptr %.sroa.0.0564.i1932, i64 %2033
  %2035 = getelementptr i8, ptr %2034, i64 64
  %2036 = load ptr, ptr %2035, align 8
  %result.i125.i1936 = call ptr %2036({ ptr, ptr, ptr, i32 } %2031, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2037 = call i32 %result.i125.i1936({ ptr, ptr, ptr, i32 } %2031, { ptr, ptr, ptr, i32 } %2031, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1931, label %2038, label %2054

2038:                                             ; preds = %2023
  %2039 = load i32, ptr %56, align 8
  %2040 = add i32 %2039, -1
  %2041 = and i32 %2040, %2037
  %2042 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2043 = load ptr, ptr %57, align 8
  %2044 = sext i32 %2041 to i64
  %2045 = shl nsw i64 %2044, 5
  %2046 = getelementptr i8, ptr %2043, i64 %2045
  %2047 = load ptr, ptr %2046, align 8
  %2048 = getelementptr i8, ptr %2046, i64 8
  %2049 = load i160, ptr %2048, align 4
  store ptr %.sroa.0.0564.i1932, ptr %2046, align 8
  store i64 %2026, ptr %2048, align 4
  %.sroa_idx157.i1979 = getelementptr i8, ptr %2046, i64 16
  store i64 %2025, ptr %.sroa_idx157.i1979, align 4
  %.sroa_idx158.i1980 = getelementptr i8, ptr %2046, i64 24
  store i32 %.sroa.17.0561.i1935, ptr %.sroa_idx158.i1980, align 4
  %2050 = icmp ne ptr %2047, @nil_typ
  %2051 = icmp ne ptr %2047, null
  %.not92.i1981 = and i1 %2050, %2051
  %extract.i1983 = lshr i160 %2049, 64
  %2052 = insertelement <2 x i160> poison, i160 %2049, i64 0
  %2053 = insertelement <2 x i160> %2052, i160 %extract.i1983, i64 1
  br i1 %.not92.i1981, label %.cont.cont.i1950, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1985.thread

2054:                                             ; preds = %2023
  %2055 = add i32 %2037, 2127912214
  %2056 = shl i32 %2037, 12
  %2057 = add i32 %2055, %2056
  %2058 = ashr i32 %2057, 19
  %2059 = xor i32 %2057, %2058
  %2060 = xor i32 %2059, -949894596
  %2061 = add i32 %2060, 374761393
  %2062 = shl i32 %2060, 5
  %2063 = add i32 %2061, %2062
  %2064 = add i32 %2063, -744332180
  %2065 = shl i32 %2063, 9
  %2066 = xor i32 %2064, %2065
  %2067 = add i32 %2066, -42973499
  %2068 = shl i32 %2066, 3
  %2069 = add i32 %2067, %2068
  %2070 = ashr i32 %2069, 16
  %2071 = xor i32 %2069, %2070
  %2072 = xor i32 %2071, -1252372727
  %2073 = load i32, ptr %56, align 8
  %2074 = add i32 %2073, -1
  %2075 = and i32 %2074, %2072
  %2076 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2077 = load ptr, ptr %58, align 8
  %2078 = sext i32 %2075 to i64
  %2079 = shl nsw i64 %2078, 5
  %2080 = getelementptr i8, ptr %2077, i64 %2079
  %2081 = load ptr, ptr %2080, align 8
  %2082 = getelementptr i8, ptr %2080, i64 8
  %2083 = load i160, ptr %2082, align 4
  store ptr %.sroa.0.0564.i1932, ptr %2080, align 8
  store i64 %2026, ptr %2082, align 4
  %.sroa_idx161.i1940 = getelementptr i8, ptr %2080, i64 16
  store i64 %2025, ptr %.sroa_idx161.i1940, align 4
  %.sroa_idx162.i1941 = getelementptr i8, ptr %2080, i64 24
  store i32 %.sroa.17.0561.i1935, ptr %.sroa_idx162.i1941, align 4
  %2084 = icmp ne ptr %2081, @nil_typ
  %2085 = icmp ne ptr %2081, null
  %.not90.i1942 = and i1 %2084, %2085
  %extract607.i1944 = lshr i160 %2083, 64
  %2086 = insertelement <2 x i160> poison, i160 %2083, i64 0
  %2087 = insertelement <2 x i160> %2086, i160 %extract607.i1944, i64 1
  br i1 %.not90.i1942, label %.cont.cont.i1950, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1985.thread

.cont.cont.i1950:                                 ; preds = %2054, %2038
  %vptr.i142.sroa.speculated.i1953 = phi ptr [ %2047, %2038 ], [ %2081, %2054 ]
  %.in4340 = phi <2 x i160> [ %2053, %2038 ], [ %2087, %2054 ]
  %2088 = trunc <2 x i160> %.in4340 to <2 x i64>
  %2089 = xor i1 %.070565.i1931, true
  %hash_coef_ptr.i.i143.i1956 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1953, i64 8
  %tbl_size_ptr.i.i144.i1957 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1953, i64 16
  %offset_tbl_ptr.i.i145.i1958 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1953, i64 40
  %hash_coef.i.i146.i1959 = load i64, ptr %hash_coef_ptr.i.i143.i1956, align 4
  %tbl_size.i.i147.i1960 = load i64, ptr %tbl_size_ptr.i.i144.i1957, align 4
  %offset_tbl.i.i148.i1961 = load ptr, ptr %offset_tbl_ptr.i.i145.i1958, align 8
  %product.i.i.i149.i1962 = mul i64 %hash_coef.i.i146.i1959, 4015701072841558310
  %shifted.i.i.i150.i1963 = lshr i64 %product.i.i.i149.i1962, 32
  %xored.i.i.i151.i1964 = xor i64 %shifted.i.i.i150.i1963, %product.i.i.i149.i1962
  %hash.i.i.i152.i1965 = and i64 %xored.i.i.i151.i1964, %tbl_size.i.i147.i1960
  %offset_ptr.i.i153.i1966 = getelementptr i32, ptr %offset_tbl.i.i148.i1961, i64 %hash.i.i.i152.i1965
  %offset.i.i154.i1967 = load i32, ptr %offset_ptr.i.i153.i1966, align 4
  %2090 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2091 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2092 = icmp ult i32 %.0566.i1930, 99
  br i1 %2092, label %2023, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1985

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1985.thread: ; preds = %2038, %2054
  %2093 = phi ptr [ %28, %2054 ], [ %27, %2038 ]
  %2094 = load i32, ptr %66, align 4
  store i32 %2094, ptr %2093, align 4
  %2095 = add i32 %2094, 1
  %2096 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2095, ptr %66, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  br label %HashMap_insert_keyK_valueV.exit1018

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1985: ; preds = %.cont.cont.i1950
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  %2097 = icmp eq ptr %vptr.i142.sroa.speculated.i1953, null
  br i1 %2097, label %HashMap_insert_keyK_valueV.exit1018, label %2098

2098:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1985
  %2099 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2100 = load ptr, ptr %57, align 8
  %2101 = load ptr, ptr %58, align 8
  %2102 = load i32, ptr %56, align 8
  %2103 = shl i32 %2102, 1
  %spec.select.i2001 = call i32 @llvm.smax.i32(i32 %2103, i32 16)
  store i32 %spec.select.i2001, ptr %56, align 8
  %2104 = zext nneg i32 %spec.select.i2001 to i64
  %2105 = shl nuw nsw i64 %2104, 5
  %result.i.i2002 = call noalias ptr @bump_malloc_inner(i64 noundef %2105, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i2002, ptr %57, align 8
  %result.i20.i2003 = call noalias ptr @bump_malloc_inner(i64 noundef %2105, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i2003, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %2106 = icmp sgt i32 %2102, 0
  br i1 %2106, label %.lr.ph.i2905, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938.thread

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938.thread: ; preds = %2098
  %2107 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit1018

.lr.ph.i2905:                                     ; preds = %2098, %._crit_edge.i2920
  %.060.i2918 = phi i32 [ %2196, %._crit_edge.i2920 ], [ 0, %2098 ]
  %2108 = zext nneg i32 %.060.i2918 to i64
  %2109 = shl nuw nsw i64 %2108, 5
  %2110 = getelementptr i8, ptr %2100, i64 %2109
  %2111 = load ptr, ptr %2110, align 8
  %2112 = icmp ne ptr %2111, @nil_typ
  %2113 = icmp ne ptr %2111, null
  %.not16.i2919 = and i1 %2112, %2113
  br i1 %.not16.i2919, label %2114, label %._crit_edge.i2920

2114:                                             ; preds = %.lr.ph.i2905
  %2115 = getelementptr i8, ptr %2110, i64 8
  %2116 = load <2 x i64>, ptr %2115, align 4
  %hash_coef_ptr.i.i18.i2922 = getelementptr i8, ptr %2111, i64 8
  %tbl_size_ptr.i.i19.i2923 = getelementptr i8, ptr %2111, i64 16
  %offset_tbl_ptr.i.i20.i2924 = getelementptr i8, ptr %2111, i64 40
  %2117 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i3795 = load i64, ptr %hash_coef_ptr.i.i18.i2922, align 4, !noalias !22
  %tbl_size.i.i100.i3796 = load i64, ptr %tbl_size_ptr.i.i19.i2923, align 4, !noalias !22
  %offset_tbl.i.i101.i3797 = load ptr, ptr %offset_tbl_ptr.i.i20.i2924, align 8, !noalias !22
  %product.i.i.i102.i3798 = mul i64 %hash_coef.i.i99.i3795, 4015701072841558310
  %shifted.i.i.i103.i3799 = lshr i64 %product.i.i.i102.i3798, 32
  %xored.i.i.i104.i3800 = xor i64 %shifted.i.i.i103.i3799, %product.i.i.i102.i3798
  %hash.i.i.i105.i3801 = and i64 %xored.i.i.i104.i3800, %tbl_size.i.i100.i3796
  %offset_ptr.i.i106.i3802 = getelementptr i32, ptr %offset_tbl.i.i101.i3797, i64 %hash.i.i.i105.i3801
  %offset.i.i121.i3803 = load i32, ptr %offset_ptr.i.i106.i3802, align 4, !noalias !389
  %2118 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2119 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2120 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2121

2121:                                             ; preds = %.cont.cont.i3824, %2114
  %.0566.i3804 = phi i32 [ 0, %2114 ], [ %2125, %.cont.cont.i3824 ]
  %.070565.i3805 = phi i1 [ true, %2114 ], [ %2187, %.cont.cont.i3824 ]
  %.sroa.0.0564.i3806 = phi ptr [ %2111, %2114 ], [ %vptr.i142.sroa.speculated.i3827, %.cont.cont.i3824 ]
  %.sroa.17.0561.i3809 = phi i32 [ %offset.i.i121.i3803, %2114 ], [ %offset.i.i154.i3841, %.cont.cont.i3824 ]
  %2122 = phi <2 x i64> [ %2116, %2114 ], [ %2186, %.cont.cont.i3824 ]
  %2123 = extractelement <2 x i64> %2122, i64 1
  %.sroa.12.0562.i3808 = inttoptr i64 %2123 to ptr
  %2124 = extractelement <2 x i64> %2122, i64 0
  %.sroa.6.0563.i3807 = inttoptr i64 %2124 to ptr
  %2125 = add nuw nsw i32 %.0566.i3804, 1
  %2126 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3806, 0
  %2127 = insertvalue { ptr, ptr, ptr, i32 } %2126, ptr %.sroa.6.0563.i3807, 1
  %2128 = insertvalue { ptr, ptr, ptr, i32 } %2127, ptr %.sroa.12.0562.i3808, 2
  %2129 = insertvalue { ptr, ptr, ptr, i32 } %2128, i32 %.sroa.17.0561.i3809, 3
  %2130 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3806)
  %2131 = sext i32 %.sroa.17.0561.i3809 to i64
  %2132 = getelementptr ptr, ptr %.sroa.0.0564.i3806, i64 %2131
  %2133 = getelementptr i8, ptr %2132, i64 64
  %2134 = load ptr, ptr %2133, align 8
  %result.i125.i3810 = call ptr %2134({ ptr, ptr, ptr, i32 } %2129, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2135 = call i32 %result.i125.i3810({ ptr, ptr, ptr, i32 } %2129, { ptr, ptr, ptr, i32 } %2129, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3805, label %2136, label %2152

2136:                                             ; preds = %2121
  %2137 = load i32, ptr %56, align 8
  %2138 = add i32 %2137, -1
  %2139 = and i32 %2138, %2135
  %2140 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2141 = load ptr, ptr %57, align 8
  %2142 = sext i32 %2139 to i64
  %2143 = shl nsw i64 %2142, 5
  %2144 = getelementptr i8, ptr %2141, i64 %2143
  %2145 = load ptr, ptr %2144, align 8
  %2146 = getelementptr i8, ptr %2144, i64 8
  %2147 = load i160, ptr %2146, align 4
  store ptr %.sroa.0.0564.i3806, ptr %2144, align 8
  store i64 %2124, ptr %2146, align 4
  %.sroa_idx157.i3853 = getelementptr i8, ptr %2144, i64 16
  store i64 %2123, ptr %.sroa_idx157.i3853, align 4
  %.sroa_idx158.i3854 = getelementptr i8, ptr %2144, i64 24
  store i32 %.sroa.17.0561.i3809, ptr %.sroa_idx158.i3854, align 4
  %2148 = icmp ne ptr %2145, @nil_typ
  %2149 = icmp ne ptr %2145, null
  %.not92.i3855 = and i1 %2148, %2149
  %extract.i3857 = lshr i160 %2147, 64
  %2150 = insertelement <2 x i160> poison, i160 %2147, i64 0
  %2151 = insertelement <2 x i160> %2150, i160 %extract.i3857, i64 1
  br i1 %.not92.i3855, label %.cont.cont.i3824, label %2191

2152:                                             ; preds = %2121
  %2153 = add i32 %2135, 2127912214
  %2154 = shl i32 %2135, 12
  %2155 = add i32 %2153, %2154
  %2156 = ashr i32 %2155, 19
  %2157 = xor i32 %2155, %2156
  %2158 = xor i32 %2157, -949894596
  %2159 = add i32 %2158, 374761393
  %2160 = shl i32 %2158, 5
  %2161 = add i32 %2159, %2160
  %2162 = add i32 %2161, -744332180
  %2163 = shl i32 %2161, 9
  %2164 = xor i32 %2162, %2163
  %2165 = add i32 %2164, -42973499
  %2166 = shl i32 %2164, 3
  %2167 = add i32 %2165, %2166
  %2168 = ashr i32 %2167, 16
  %2169 = xor i32 %2167, %2168
  %2170 = xor i32 %2169, -1252372727
  %2171 = load i32, ptr %56, align 8
  %2172 = add i32 %2171, -1
  %2173 = and i32 %2172, %2170
  %2174 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2175 = load ptr, ptr %58, align 8
  %2176 = sext i32 %2173 to i64
  %2177 = shl nsw i64 %2176, 5
  %2178 = getelementptr i8, ptr %2175, i64 %2177
  %2179 = load ptr, ptr %2178, align 8
  %2180 = getelementptr i8, ptr %2178, i64 8
  %2181 = load i160, ptr %2180, align 4
  store ptr %.sroa.0.0564.i3806, ptr %2178, align 8
  store i64 %2124, ptr %2180, align 4
  %.sroa_idx161.i3814 = getelementptr i8, ptr %2178, i64 16
  store i64 %2123, ptr %.sroa_idx161.i3814, align 4
  %.sroa_idx162.i3815 = getelementptr i8, ptr %2178, i64 24
  store i32 %.sroa.17.0561.i3809, ptr %.sroa_idx162.i3815, align 4
  %2182 = icmp ne ptr %2179, @nil_typ
  %2183 = icmp ne ptr %2179, null
  %.not90.i3816 = and i1 %2182, %2183
  %extract607.i3818 = lshr i160 %2181, 64
  %2184 = insertelement <2 x i160> poison, i160 %2181, i64 0
  %2185 = insertelement <2 x i160> %2184, i160 %extract607.i3818, i64 1
  br i1 %.not90.i3816, label %.cont.cont.i3824, label %2191

.cont.cont.i3824:                                 ; preds = %2152, %2136
  %vptr.i142.sroa.speculated.i3827 = phi ptr [ %2145, %2136 ], [ %2179, %2152 ]
  %.in4341 = phi <2 x i160> [ %2151, %2136 ], [ %2185, %2152 ]
  %2186 = trunc <2 x i160> %.in4341 to <2 x i64>
  %2187 = xor i1 %.070565.i3805, true
  %hash_coef_ptr.i.i143.i3830 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3827, i64 8
  %tbl_size_ptr.i.i144.i3831 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3827, i64 16
  %offset_tbl_ptr.i.i145.i3832 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3827, i64 40
  %hash_coef.i.i146.i3833 = load i64, ptr %hash_coef_ptr.i.i143.i3830, align 4
  %tbl_size.i.i147.i3834 = load i64, ptr %tbl_size_ptr.i.i144.i3831, align 4
  %offset_tbl.i.i148.i3835 = load ptr, ptr %offset_tbl_ptr.i.i145.i3832, align 8
  %product.i.i.i149.i3836 = mul i64 %hash_coef.i.i146.i3833, 4015701072841558310
  %shifted.i.i.i150.i3837 = lshr i64 %product.i.i.i149.i3836, 32
  %xored.i.i.i151.i3838 = xor i64 %shifted.i.i.i150.i3837, %product.i.i.i149.i3836
  %hash.i.i.i152.i3839 = and i64 %xored.i.i.i151.i3838, %tbl_size.i.i147.i3834
  %offset_ptr.i.i153.i3840 = getelementptr i32, ptr %offset_tbl.i.i148.i3835, i64 %hash.i.i.i152.i3839
  %offset.i.i154.i3841 = load i32, ptr %offset_ptr.i.i153.i3840, align 4
  %2188 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2189 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2190 = icmp ult i32 %.0566.i3804, 99
  br i1 %2190, label %2121, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3859

2191:                                             ; preds = %2152, %2136
  %2192 = phi ptr [ %6, %2152 ], [ %5, %2136 ]
  %2193 = load i32, ptr %66, align 4
  store i32 %2193, ptr %2192, align 4
  %2194 = add i32 %2193, 1
  %2195 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2194, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3859

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3859: ; preds = %.cont.cont.i3824, %2191
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i2920

._crit_edge.i2920:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3859, %.lr.ph.i2905
  %2196 = add nuw nsw i32 %.060.i2918, 1
  %2197 = icmp slt i32 %2196, %2102
  br i1 %2197, label %.lr.ph.i2905, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938: ; preds = %._crit_edge.i2920
  %2198 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %2199

2199:                                             ; preds = %._crit_edge.i2956, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938
  %.060.i2954 = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938 ], [ %2288, %._crit_edge.i2956 ]
  %2200 = zext nneg i32 %.060.i2954 to i64
  %2201 = shl nuw nsw i64 %2200, 5
  %2202 = getelementptr i8, ptr %2101, i64 %2201
  %2203 = load ptr, ptr %2202, align 8
  %2204 = icmp ne ptr %2203, @nil_typ
  %2205 = icmp ne ptr %2203, null
  %.not16.i2955 = and i1 %2204, %2205
  br i1 %.not16.i2955, label %2206, label %._crit_edge.i2956

2206:                                             ; preds = %2199
  %2207 = getelementptr i8, ptr %2202, i64 8
  %2208 = load <2 x i64>, ptr %2207, align 4
  %hash_coef_ptr.i.i18.i2958 = getelementptr i8, ptr %2203, i64 8
  %tbl_size_ptr.i.i19.i2959 = getelementptr i8, ptr %2203, i64 16
  %offset_tbl_ptr.i.i20.i2960 = getelementptr i8, ptr %2203, i64 40
  %2209 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i3877 = load i64, ptr %hash_coef_ptr.i.i18.i2958, align 4, !noalias !22
  %tbl_size.i.i100.i3878 = load i64, ptr %tbl_size_ptr.i.i19.i2959, align 4, !noalias !22
  %offset_tbl.i.i101.i3879 = load ptr, ptr %offset_tbl_ptr.i.i20.i2960, align 8, !noalias !22
  %product.i.i.i102.i3880 = mul i64 %hash_coef.i.i99.i3877, 4015701072841558310
  %shifted.i.i.i103.i3881 = lshr i64 %product.i.i.i102.i3880, 32
  %xored.i.i.i104.i3882 = xor i64 %shifted.i.i.i103.i3881, %product.i.i.i102.i3880
  %hash.i.i.i105.i3883 = and i64 %xored.i.i.i104.i3882, %tbl_size.i.i100.i3878
  %offset_ptr.i.i106.i3884 = getelementptr i32, ptr %offset_tbl.i.i101.i3879, i64 %hash.i.i.i105.i3883
  %offset.i.i121.i3885 = load i32, ptr %offset_ptr.i.i106.i3884, align 4, !noalias !392
  %2210 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2211 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2212 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2213

2213:                                             ; preds = %.cont.cont.i3906, %2206
  %.0566.i3886 = phi i32 [ 0, %2206 ], [ %2217, %.cont.cont.i3906 ]
  %.070565.i3887 = phi i1 [ true, %2206 ], [ %2279, %.cont.cont.i3906 ]
  %.sroa.0.0564.i3888 = phi ptr [ %2203, %2206 ], [ %vptr.i142.sroa.speculated.i3909, %.cont.cont.i3906 ]
  %.sroa.17.0561.i3891 = phi i32 [ %offset.i.i121.i3885, %2206 ], [ %offset.i.i154.i3923, %.cont.cont.i3906 ]
  %2214 = phi <2 x i64> [ %2208, %2206 ], [ %2278, %.cont.cont.i3906 ]
  %2215 = extractelement <2 x i64> %2214, i64 1
  %.sroa.12.0562.i3890 = inttoptr i64 %2215 to ptr
  %2216 = extractelement <2 x i64> %2214, i64 0
  %.sroa.6.0563.i3889 = inttoptr i64 %2216 to ptr
  %2217 = add nuw nsw i32 %.0566.i3886, 1
  %2218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3888, 0
  %2219 = insertvalue { ptr, ptr, ptr, i32 } %2218, ptr %.sroa.6.0563.i3889, 1
  %2220 = insertvalue { ptr, ptr, ptr, i32 } %2219, ptr %.sroa.12.0562.i3890, 2
  %2221 = insertvalue { ptr, ptr, ptr, i32 } %2220, i32 %.sroa.17.0561.i3891, 3
  %2222 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3888)
  %2223 = sext i32 %.sroa.17.0561.i3891 to i64
  %2224 = getelementptr ptr, ptr %.sroa.0.0564.i3888, i64 %2223
  %2225 = getelementptr i8, ptr %2224, i64 64
  %2226 = load ptr, ptr %2225, align 8
  %result.i125.i3892 = call ptr %2226({ ptr, ptr, ptr, i32 } %2221, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2227 = call i32 %result.i125.i3892({ ptr, ptr, ptr, i32 } %2221, { ptr, ptr, ptr, i32 } %2221, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3887, label %2228, label %2244

2228:                                             ; preds = %2213
  %2229 = load i32, ptr %56, align 8
  %2230 = add i32 %2229, -1
  %2231 = and i32 %2230, %2227
  %2232 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2233 = load ptr, ptr %57, align 8
  %2234 = sext i32 %2231 to i64
  %2235 = shl nsw i64 %2234, 5
  %2236 = getelementptr i8, ptr %2233, i64 %2235
  %2237 = load ptr, ptr %2236, align 8
  %2238 = getelementptr i8, ptr %2236, i64 8
  %2239 = load i160, ptr %2238, align 4
  store ptr %.sroa.0.0564.i3888, ptr %2236, align 8
  store i64 %2216, ptr %2238, align 4
  %.sroa_idx157.i3935 = getelementptr i8, ptr %2236, i64 16
  store i64 %2215, ptr %.sroa_idx157.i3935, align 4
  %.sroa_idx158.i3936 = getelementptr i8, ptr %2236, i64 24
  store i32 %.sroa.17.0561.i3891, ptr %.sroa_idx158.i3936, align 4
  %2240 = icmp ne ptr %2237, @nil_typ
  %2241 = icmp ne ptr %2237, null
  %.not92.i3937 = and i1 %2240, %2241
  %extract.i3939 = lshr i160 %2239, 64
  %2242 = insertelement <2 x i160> poison, i160 %2239, i64 0
  %2243 = insertelement <2 x i160> %2242, i160 %extract.i3939, i64 1
  br i1 %.not92.i3937, label %.cont.cont.i3906, label %2283

2244:                                             ; preds = %2213
  %2245 = add i32 %2227, 2127912214
  %2246 = shl i32 %2227, 12
  %2247 = add i32 %2245, %2246
  %2248 = ashr i32 %2247, 19
  %2249 = xor i32 %2247, %2248
  %2250 = xor i32 %2249, -949894596
  %2251 = add i32 %2250, 374761393
  %2252 = shl i32 %2250, 5
  %2253 = add i32 %2251, %2252
  %2254 = add i32 %2253, -744332180
  %2255 = shl i32 %2253, 9
  %2256 = xor i32 %2254, %2255
  %2257 = add i32 %2256, -42973499
  %2258 = shl i32 %2256, 3
  %2259 = add i32 %2257, %2258
  %2260 = ashr i32 %2259, 16
  %2261 = xor i32 %2259, %2260
  %2262 = xor i32 %2261, -1252372727
  %2263 = load i32, ptr %56, align 8
  %2264 = add i32 %2263, -1
  %2265 = and i32 %2264, %2262
  %2266 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2267 = load ptr, ptr %58, align 8
  %2268 = sext i32 %2265 to i64
  %2269 = shl nsw i64 %2268, 5
  %2270 = getelementptr i8, ptr %2267, i64 %2269
  %2271 = load ptr, ptr %2270, align 8
  %2272 = getelementptr i8, ptr %2270, i64 8
  %2273 = load i160, ptr %2272, align 4
  store ptr %.sroa.0.0564.i3888, ptr %2270, align 8
  store i64 %2216, ptr %2272, align 4
  %.sroa_idx161.i3896 = getelementptr i8, ptr %2270, i64 16
  store i64 %2215, ptr %.sroa_idx161.i3896, align 4
  %.sroa_idx162.i3897 = getelementptr i8, ptr %2270, i64 24
  store i32 %.sroa.17.0561.i3891, ptr %.sroa_idx162.i3897, align 4
  %2274 = icmp ne ptr %2271, @nil_typ
  %2275 = icmp ne ptr %2271, null
  %.not90.i3898 = and i1 %2274, %2275
  %extract607.i3900 = lshr i160 %2273, 64
  %2276 = insertelement <2 x i160> poison, i160 %2273, i64 0
  %2277 = insertelement <2 x i160> %2276, i160 %extract607.i3900, i64 1
  br i1 %.not90.i3898, label %.cont.cont.i3906, label %2283

.cont.cont.i3906:                                 ; preds = %2244, %2228
  %vptr.i142.sroa.speculated.i3909 = phi ptr [ %2237, %2228 ], [ %2271, %2244 ]
  %.in4342 = phi <2 x i160> [ %2243, %2228 ], [ %2277, %2244 ]
  %2278 = trunc <2 x i160> %.in4342 to <2 x i64>
  %2279 = xor i1 %.070565.i3887, true
  %hash_coef_ptr.i.i143.i3912 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3909, i64 8
  %tbl_size_ptr.i.i144.i3913 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3909, i64 16
  %offset_tbl_ptr.i.i145.i3914 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3909, i64 40
  %hash_coef.i.i146.i3915 = load i64, ptr %hash_coef_ptr.i.i143.i3912, align 4
  %tbl_size.i.i147.i3916 = load i64, ptr %tbl_size_ptr.i.i144.i3913, align 4
  %offset_tbl.i.i148.i3917 = load ptr, ptr %offset_tbl_ptr.i.i145.i3914, align 8
  %product.i.i.i149.i3918 = mul i64 %hash_coef.i.i146.i3915, 4015701072841558310
  %shifted.i.i.i150.i3919 = lshr i64 %product.i.i.i149.i3918, 32
  %xored.i.i.i151.i3920 = xor i64 %shifted.i.i.i150.i3919, %product.i.i.i149.i3918
  %hash.i.i.i152.i3921 = and i64 %xored.i.i.i151.i3920, %tbl_size.i.i147.i3916
  %offset_ptr.i.i153.i3922 = getelementptr i32, ptr %offset_tbl.i.i148.i3917, i64 %hash.i.i.i152.i3921
  %offset.i.i154.i3923 = load i32, ptr %offset_ptr.i.i153.i3922, align 4
  %2280 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2281 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2282 = icmp ult i32 %.0566.i3886, 99
  br i1 %2282, label %2213, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3941

2283:                                             ; preds = %2244, %2228
  %2284 = phi ptr [ %4, %2244 ], [ %3, %2228 ]
  %2285 = load i32, ptr %66, align 4
  store i32 %2285, ptr %2284, align 4
  %2286 = add i32 %2285, 1
  %2287 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2286, ptr %66, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3941

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3941: ; preds = %.cont.cont.i3906, %2283
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i2956

._crit_edge.i2956:                                ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3941, %2199
  %2288 = add nuw nsw i32 %.060.i2954, 1
  %2289 = icmp slt i32 %2288, %2102
  br i1 %2289, label %2199, label %HashMap_insert_keyK_valueV.exit1018

HashMap_insert_keyK_valueV.exit1018:              ; preds = %._crit_edge.i2956, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1985.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1881.thread, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1777, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1718, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1881, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1985
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2290 = add nsw i32 %.0357715, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %HashMap_insert_keyK_valueV.exit1018, %HashMap_get_keyK.exit
  %.2359 = phi i32 [ %2290, %HashMap_insert_keyK_valueV.exit1018 ], [ %.0357715, %HashMap_get_keyK.exit ]
  %2291 = add nuw nsw i32 %.0355716, 1
  %2292 = icmp slt i32 %.2359, %0
  %2293 = icmp slt i32 %2291, %60
  %spec.select = select i1 %2292, i1 %2293, i1 false
  br i1 %spec.select, label %68, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %.0357.lcssa = phi i32 [ 0, %1 ], [ %.2359, %._crit_edge1 ]
  %2294 = icmp slt i32 %.0357.lcssa, %0
  br i1 %2294, label %._crit_edge.lr.ph.i, label %._crit_edge4

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge3._crit_edge
  %result.i450 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i450, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2295 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2296 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2019 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i2019, ptr noundef nonnull align 32 dereferenceable(29) %result.i450, i64 29, i1 false)
  %2297 = getelementptr i8, ptr %result.i.i2019, i64 29
  store i8 0, ptr %2297, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2019)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2298 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0357.lcssa) #16
  %result.i456 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %result.i456, align 32
  %2299 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2300 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2301 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2034 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i2034, ptr noundef nonnull align 32 dereferenceable(29) %result.i456, i64 29, i1 false)
  %2302 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2303 = getelementptr i8, ptr %result.i.i2034, i64 29
  store i8 0, ptr %2303, align 1
  %puts.i1053 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2034)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3._crit_edge, %._crit_edge.lr.ph.i
  %.0365 = phi i32 [ %.0357.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge3._crit_edge ]
  %2304 = call i64 @clock()
  %2305 = icmp sgt i32 %.0365, 0
  br i1 %2305, label %.lr.ph723.preheader, label %._crit_edge8

.lr.ph723.preheader:                              ; preds = %._crit_edge4
  %2306 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %2307 = getelementptr inbounds i8, ptr %result.i378, i64 44
  br label %.lr.ph723

.lr.ph723:                                        ; preds = %.lr.ph723.preheader, %._crit_edge5
  %.0354722 = phi i32 [ %.2, %._crit_edge5 ], [ 0, %.lr.ph723.preheader ]
  %.0360721 = phi i1 [ %.3, %._crit_edge5 ], [ true, %.lr.ph723.preheader ]
  %.0363720 = phi i32 [ %2450, %._crit_edge5 ], [ 0, %.lr.ph723.preheader ]
  %2308 = zext nneg i32 %.0363720 to i64
  %2309 = shl nuw nsw i64 %2308, 2
  %2310 = getelementptr i8, ptr %result.i4.i, i64 %2309
  %2311 = load i32, ptr %2310, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %2311 to i160
  %2312 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %2313 = load ptr, ptr %40, align 8
  %2314 = call i32 %2313({ ptr, i160 } %2312) #7
  %2315 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %2316 = load i32, ptr %42, align 8
  %2317 = add i32 %2316, -1
  %2318 = and i32 %2317, %2314
  %2319 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2320 = sext i32 %2318 to i64
  %2321 = shl nsw i64 %2320, 5
  %2322 = getelementptr i8, ptr %2319, i64 %2321
  %2323 = load ptr, ptr %2322, align 8
  %2324 = icmp ne ptr %2323, @nil_typ
  %2325 = icmp ne ptr %2323, null
  %.not51.i = and i1 %2324, %2325
  br i1 %.not51.i, label %2326, label %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

2326:                                             ; preds = %.lr.ph723
  %2327 = getelementptr i8, ptr %2322, i64 8
  %2328 = load i64, ptr %2327, align 4
  %.sroa_idx.i2081 = getelementptr i8, ptr %2322, i64 16
  %2329 = load i64, ptr %.sroa_idx.i2081, align 4
  %2330 = inttoptr i64 %2328 to ptr
  %2331 = inttoptr i64 %2329 to ptr
  %hash_coef_ptr.i.i53.i = getelementptr i8, ptr %2323, i64 8
  %tbl_size_ptr.i.i54.i = getelementptr i8, ptr %2323, i64 16
  %offset_tbl_ptr.i.i55.i = getelementptr i8, ptr %2323, i64 40
  %hash_coef.i.i56.i = load i64, ptr %hash_coef_ptr.i.i53.i, align 4, !noalias !395
  %tbl_size.i.i57.i = load i64, ptr %tbl_size_ptr.i.i54.i, align 4, !noalias !395
  %offset_tbl.i.i58.i = load ptr, ptr %offset_tbl_ptr.i.i55.i, align 8, !noalias !395
  %product.i.i.i59.i = mul i64 %hash_coef.i.i56.i, 4015701072841558310
  %shifted.i.i.i60.i = lshr i64 %product.i.i.i59.i, 32
  %xored.i.i.i61.i = xor i64 %shifted.i.i.i60.i, %product.i.i.i59.i
  %hash.i.i.i62.i = and i64 %xored.i.i.i61.i, %tbl_size.i.i57.i
  %offset_ptr.i.i63.i = getelementptr i32, ptr %offset_tbl.i.i58.i, i64 %hash.i.i.i62.i
  %offset.i.i64.i = load i32, ptr %offset_ptr.i.i63.i, align 4, !noalias !395
  %2332 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2323, 0
  %2333 = insertvalue { ptr, ptr, ptr, i32 } %2332, ptr %2330, 1
  %2334 = insertvalue { ptr, ptr, ptr, i32 } %2333, ptr %2331, 2
  %2335 = insertvalue { ptr, ptr, ptr, i32 } %2334, i32 %offset.i.i64.i, 3
  %2336 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2337 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2323) #34
  %2338 = sext i32 %offset.i.i64.i to i64
  %2339 = getelementptr ptr, ptr %2323, i64 %2338
  %2340 = getelementptr i8, ptr %2339, i64 64
  %2341 = load ptr, ptr %2340, align 8
  %result.i.i2082 = call ptr %2341({ ptr, ptr, ptr, i32 } %2335, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2342 = call i32 %result.i.i2082({ ptr, ptr, ptr, i32 } %2335, { ptr, ptr, ptr, i32 } %2335, ptr nonnull align 8 %2) #7
  %2343 = icmp eq i32 %2342, %2314
  br i1 %2343, label %._crit_edge.i2083, label %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i2083:                                ; preds = %2326
  %2344 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2345 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2323)
  %2346 = getelementptr i8, ptr %2339, i64 48
  %2347 = load ptr, ptr %2346, align 8
  %result.i66.i = call ptr %2347({ ptr, ptr, ptr, i32 } %2335, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2348 = call { ptr, i160 } %result.i66.i({ ptr, ptr, ptr, i32 } %2335, { ptr, ptr, ptr, i32 } %2335, ptr nonnull align 8 %2) #7
  %2349 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2350 = load ptr, ptr %41, align 8
  %2351 = call i1 %2350({ ptr, i160 } %2348, { ptr, i160 } %2312) #7
  br i1 %2351, label %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i2083, %.lr.ph723, %2326
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2362

HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i2083
  %2352 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2353 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2323)
  %2354 = getelementptr i8, ptr %2339, i64 56
  %2355 = load ptr, ptr %2354, align 8
  %result.i67.i = call ptr %2355({ ptr, ptr, ptr, i32 } %2335, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2356 = call { ptr, i160 } %result.i67.i({ ptr, ptr, ptr, i32 } %2335, { ptr, ptr, ptr, i32 } %2335, ptr nonnull align 8 %2) #7
  %.fca.0.extract28.i = extractvalue { ptr, i160 } %2356, 0
  store ptr @nil_typ, ptr %2322, align 8
  %2357 = load i32, ptr %2307, align 4
  %2358 = add i32 %2357, -1
  store i32 %2358, ptr %2307, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2359 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2360 = icmp ne ptr %.fca.0.extract28.i, @nil_typ
  %2361 = icmp ne ptr %.fca.0.extract28.i, null
  %.not63.i1088 = and i1 %2360, %2361
  br i1 %.not63.i1088, label %HashMap_remove_keyK.exit, label %2362

2362:                                             ; preds = %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %2363 = add i32 %2314, 2127912214
  %2364 = shl i32 %2314, 12
  %2365 = add i32 %2363, %2364
  %2366 = ashr i32 %2365, 19
  %2367 = xor i32 %2365, %2366
  %2368 = xor i32 %2367, -949894596
  %2369 = add i32 %2368, 374761393
  %2370 = shl i32 %2368, 5
  %2371 = add i32 %2369, %2370
  %2372 = add i32 %2371, -744332180
  %2373 = shl i32 %2371, 9
  %2374 = xor i32 %2372, %2373
  %2375 = add i32 %2374, -42973499
  %2376 = shl i32 %2374, 3
  %2377 = add i32 %2375, %2376
  %2378 = ashr i32 %2377, 16
  %2379 = xor i32 %2377, %2378
  %2380 = xor i32 %2379, -1252372727
  %2381 = load i32, ptr %42, align 8
  %2382 = add i32 %2381, -1
  %2383 = and i32 %2382, %2380
  %2384 = load ptr, ptr %44, align 8
  %2385 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2386 = sext i32 %2383 to i64
  %2387 = shl nsw i64 %2386, 5
  %2388 = getelementptr i8, ptr %2384, i64 %2387
  %2389 = load ptr, ptr %2388, align 8
  %2390 = icmp ne ptr %2389, @nil_typ
  %2391 = icmp ne ptr %2389, null
  %.not51.i2113 = and i1 %2390, %2391
  br i1 %.not51.i2113, label %2392, label %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137

2392:                                             ; preds = %2362
  %2393 = getelementptr i8, ptr %2388, i64 8
  %2394 = load i64, ptr %2393, align 4
  %.sroa_idx.i2117 = getelementptr i8, ptr %2388, i64 16
  %2395 = load i64, ptr %.sroa_idx.i2117, align 4
  %2396 = inttoptr i64 %2394 to ptr
  %2397 = inttoptr i64 %2395 to ptr
  %hash_coef_ptr.i.i53.i2118 = getelementptr i8, ptr %2389, i64 8
  %tbl_size_ptr.i.i54.i2119 = getelementptr i8, ptr %2389, i64 16
  %offset_tbl_ptr.i.i55.i2120 = getelementptr i8, ptr %2389, i64 40
  %hash_coef.i.i56.i2121 = load i64, ptr %hash_coef_ptr.i.i53.i2118, align 4, !noalias !398
  %tbl_size.i.i57.i2122 = load i64, ptr %tbl_size_ptr.i.i54.i2119, align 4, !noalias !398
  %offset_tbl.i.i58.i2123 = load ptr, ptr %offset_tbl_ptr.i.i55.i2120, align 8, !noalias !398
  %product.i.i.i59.i2124 = mul i64 %hash_coef.i.i56.i2121, 4015701072841558310
  %shifted.i.i.i60.i2125 = lshr i64 %product.i.i.i59.i2124, 32
  %xored.i.i.i61.i2126 = xor i64 %shifted.i.i.i60.i2125, %product.i.i.i59.i2124
  %hash.i.i.i62.i2127 = and i64 %xored.i.i.i61.i2126, %tbl_size.i.i57.i2122
  %offset_ptr.i.i63.i2128 = getelementptr i32, ptr %offset_tbl.i.i58.i2123, i64 %hash.i.i.i62.i2127
  %offset.i.i64.i2129 = load i32, ptr %offset_ptr.i.i63.i2128, align 4, !noalias !398
  %2398 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2389, 0
  %2399 = insertvalue { ptr, ptr, ptr, i32 } %2398, ptr %2396, 1
  %2400 = insertvalue { ptr, ptr, ptr, i32 } %2399, ptr %2397, 2
  %2401 = insertvalue { ptr, ptr, ptr, i32 } %2400, i32 %offset.i.i64.i2129, 3
  %2402 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2403 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2389) #34
  %2404 = sext i32 %offset.i.i64.i2129 to i64
  %2405 = getelementptr ptr, ptr %2389, i64 %2404
  %2406 = getelementptr i8, ptr %2405, i64 64
  %2407 = load ptr, ptr %2406, align 8
  %result.i.i2130 = call ptr %2407({ ptr, ptr, ptr, i32 } %2401, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2408 = call i32 %result.i.i2130({ ptr, ptr, ptr, i32 } %2401, { ptr, ptr, ptr, i32 } %2401, ptr nonnull align 8 %2) #7
  %2409 = icmp eq i32 %2408, %2314
  br i1 %2409, label %._crit_edge.i2131, label %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137

._crit_edge.i2131:                                ; preds = %2392
  %2410 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2411 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2389)
  %2412 = getelementptr i8, ptr %2405, i64 48
  %2413 = load ptr, ptr %2412, align 8
  %result.i66.i2132 = call ptr %2413({ ptr, ptr, ptr, i32 } %2401, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2414 = call { ptr, i160 } %result.i66.i2132({ ptr, ptr, ptr, i32 } %2401, { ptr, ptr, ptr, i32 } %2401, ptr nonnull align 8 %2) #7
  %2415 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2416 = load ptr, ptr %41, align 8
  %2417 = call i1 %2416({ ptr, i160 } %2414, { ptr, i160 } %2312) #7
  br i1 %2417, label %2418, label %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137

2418:                                             ; preds = %._crit_edge.i2131
  %2419 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2420 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2389)
  %2421 = getelementptr i8, ptr %2405, i64 56
  %2422 = load ptr, ptr %2421, align 8
  %result.i67.i2134 = call ptr %2422({ ptr, ptr, ptr, i32 } %2401, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2423 = call { ptr, i160 } %result.i67.i2134({ ptr, ptr, ptr, i32 } %2401, { ptr, ptr, ptr, i32 } %2401, ptr nonnull align 8 %2) #7
  %.fca.0.extract28.i2135 = extractvalue { ptr, i160 } %2423, 0
  %.fca.1.extract29.i2136 = extractvalue { ptr, i160 } %2423, 1
  store ptr @nil_typ, ptr %2388, align 8
  %2424 = load i32, ptr %2307, align 4
  %2425 = add i32 %2424, -1
  %2426 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2425, ptr %2307, align 4
  br label %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137

HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137: ; preds = %2362, %2392, %._crit_edge.i2131, %2418
  %.reg2mem47.sroa.3.088.i2114 = phi i160 [ %.fca.1.extract29.i2136, %2418 ], [ poison, %._crit_edge.i2131 ], [ poison, %2362 ], [ poison, %2392 ]
  %2427 = phi ptr [ %.fca.0.extract28.i2135, %2418 ], [ @nil_typ, %._crit_edge.i2131 ], [ @nil_typ, %2362 ], [ @nil_typ, %2392 ]
  %.reload44.fca.0.insert.i2115 = insertvalue { ptr, i160 } poison, ptr %2427, 0
  %.reload44.fca.1.insert.i2116 = insertvalue { ptr, i160 } %.reload44.fca.0.insert.i2115, i160 %.reg2mem47.sroa.3.088.i2114, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2428 = icmp ne ptr %2427, @nil_typ
  %2429 = icmp ne ptr %2427, null
  %.not65.not.not.i1092 = and i1 %2428, %2429
  %cond.fr.i1093 = freeze i1 %.not65.not.not.i1092
  %spec.select.i1094 = select i1 %cond.fr.i1093, ptr %2427, ptr @nil_typ
  br label %HashMap_remove_keyK.exit

HashMap_remove_keyK.exit:                         ; preds = %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137
  %.pn.i1095 = phi { ptr, i160 } [ %2356, %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %.reload44.fca.1.insert.i2116, %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137 ]
  %2430 = phi ptr [ %.fca.0.extract28.i, %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i1094, %HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137 ]
  %2431 = icmp ne ptr %2430, @nil_typ
  %2432 = icmp ne ptr %2430, null
  %.not369 = and i1 %2431, %2432
  br i1 %.not369, label %2433, label %._crit_edge.lr.ph.i2171

2433:                                             ; preds = %HashMap_remove_keyK.exit
  %.fca.1.extract..sroa.354.0101.i1096 = extractvalue { ptr, i160 } %.pn.i1095, 1
  %.sroa.2256.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0101.i1096 to i32
  %2434 = add i32 %2311, 1
  %.not = icmp eq i32 %2434, %.sroa.2256.8.extract.trunc
  br i1 %.not, label %._crit_edge6, label %._crit_edge.lr.ph.i2152

._crit_edge.lr.ph.i2152:                          ; preds = %2433
  %result.i463 = call noalias align 64 dereferenceable_or_null(46) ptr @bump_malloc_inner(i64 noundef 46, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2435 = load <45 x i8>, ptr @rroys_Warning_Remove_returned_wrong_value_for_key_, align 64
  store <45 x i8> %2435, ptr %result.i463, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2436 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2437 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2151 = call noalias dereferenceable_or_null(46) ptr @bump_malloc_inner(i64 noundef 46, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(45) %result.i.i2151, ptr noundef nonnull align 64 dereferenceable(45) %result.i463, i64 45, i1 false)
  %2438 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2439 = getelementptr i8, ptr %result.i.i2151, i64 45
  store i8 0, ptr %2439, align 1
  %puts.i1118 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2151)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2440 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2441 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %2311) #16
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %2433, %._crit_edge.lr.ph.i2152
  %.2362 = phi i1 [ false, %._crit_edge.lr.ph.i2152 ], [ %.0360721, %2433 ]
  %2442 = add i32 %.0354722, 1
  br label %._crit_edge5

._crit_edge.lr.ph.i2171:                          ; preds = %HashMap_remove_keyK.exit
  %result.i469 = call noalias align 64 dereferenceable_or_null(38) ptr @bump_malloc_inner(i64 noundef 38, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2443 = load <37 x i8>, ptr @ndpsw_Warning_Remove_returned_Nil_for_key_, align 64
  store <37 x i8> %2443, ptr %result.i469, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2444 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2445 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2170 = call noalias dereferenceable_or_null(38) ptr @bump_malloc_inner(i64 noundef 38, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(37) %result.i.i2170, ptr noundef nonnull align 64 dereferenceable(37) %result.i469, i64 37, i1 false)
  %2446 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2447 = getelementptr i8, ptr %result.i.i2170, i64 37
  store i8 0, ptr %2447, align 1
  %puts.i1138 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2170)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2448 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2449 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %2311) #16
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge6, %._crit_edge.lr.ph.i2171
  %.3 = phi i1 [ %.2362, %._crit_edge6 ], [ false, %._crit_edge.lr.ph.i2171 ]
  %.2 = phi i32 [ %2442, %._crit_edge6 ], [ %.0354722, %._crit_edge.lr.ph.i2171 ]
  %2450 = add nuw nsw i32 %.0363720, 1
  %2451 = icmp slt i32 %2450, %.0365
  br i1 %2451, label %.lr.ph723, label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge5, %._crit_edge4
  %.0360.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.3, %._crit_edge5 ]
  %.0354.lcssa = phi i32 [ 0, %._crit_edge4 ], [ %.2, %._crit_edge5 ]
  %2452 = call i64 @clock()
  %.not370 = icmp eq i32 %.0354.lcssa, %.0365
  %2453 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %2454 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %2455 = getelementptr inbounds i8, ptr %result.i378, i64 44
  %2456 = load i32, ptr %2455, align 4
  %.not371 = icmp eq i32 %2456, 0
  %2457 = select i1 %.not371, i1 %.not370, i1 false
  %spec.select377 = select i1 %2457, i1 %.0360.lcssa, i1 false
  br i1 %2305, label %2458, label %._crit_edge.lr.ph.i2311

2458:                                             ; preds = %._crit_edge8
  %2459 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %2460 = load i32, ptr %result.i4.i, align 1
  %.sroa.2.sroa.0.0.insert.ext.i2176 = zext i32 %2460 to i160
  %2461 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i2176, 1
  %2462 = load ptr, ptr %40, align 8
  %2463 = call i32 %2462({ ptr, i160 } %2461) #7
  %2464 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %2465 = load i32, ptr %42, align 8
  %2466 = add i32 %2465, -1
  %2467 = and i32 %2466, %2463
  %2468 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2469 = sext i32 %2467 to i64
  %2470 = shl nsw i64 %2469, 5
  %2471 = getelementptr i8, ptr %2468, i64 %2470
  %2472 = load ptr, ptr %2471, align 8
  %2473 = icmp ne ptr %2472, @nil_typ
  %2474 = icmp ne ptr %2472, null
  %.not44.i2218 = and i1 %2473, %2474
  br i1 %.not44.i2218, label %2475, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread

2475:                                             ; preds = %2458
  %2476 = getelementptr i8, ptr %2471, i64 8
  %2477 = load i64, ptr %2476, align 4
  %.sroa_idx.i2222 = getelementptr i8, ptr %2471, i64 16
  %2478 = load i64, ptr %.sroa_idx.i2222, align 4
  %2479 = inttoptr i64 %2477 to ptr
  %2480 = inttoptr i64 %2478 to ptr
  %hash_coef_ptr.i.i46.i2223 = getelementptr i8, ptr %2472, i64 8
  %tbl_size_ptr.i.i47.i2224 = getelementptr i8, ptr %2472, i64 16
  %offset_tbl_ptr.i.i48.i2225 = getelementptr i8, ptr %2472, i64 40
  %hash_coef.i.i49.i2226 = load i64, ptr %hash_coef_ptr.i.i46.i2223, align 4, !noalias !401
  %tbl_size.i.i50.i2227 = load i64, ptr %tbl_size_ptr.i.i47.i2224, align 4, !noalias !401
  %offset_tbl.i.i51.i2228 = load ptr, ptr %offset_tbl_ptr.i.i48.i2225, align 8, !noalias !401
  %product.i.i.i52.i2229 = mul i64 %hash_coef.i.i49.i2226, 4015701072841558310
  %shifted.i.i.i53.i2230 = lshr i64 %product.i.i.i52.i2229, 32
  %xored.i.i.i54.i2231 = xor i64 %shifted.i.i.i53.i2230, %product.i.i.i52.i2229
  %hash.i.i.i55.i2232 = and i64 %xored.i.i.i54.i2231, %tbl_size.i.i50.i2227
  %offset_ptr.i.i56.i2233 = getelementptr i32, ptr %offset_tbl.i.i51.i2228, i64 %hash.i.i.i55.i2232
  %offset.i.i57.i2234 = load i32, ptr %offset_ptr.i.i56.i2233, align 4, !noalias !401
  %2481 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2472, 0
  %2482 = insertvalue { ptr, ptr, ptr, i32 } %2481, ptr %2479, 1
  %2483 = insertvalue { ptr, ptr, ptr, i32 } %2482, ptr %2480, 2
  %2484 = insertvalue { ptr, ptr, ptr, i32 } %2483, i32 %offset.i.i57.i2234, 3
  %2485 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2486 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2472) #34
  %2487 = sext i32 %offset.i.i57.i2234 to i64
  %2488 = getelementptr ptr, ptr %2472, i64 %2487
  %2489 = getelementptr i8, ptr %2488, i64 64
  %2490 = load ptr, ptr %2489, align 8
  %result.i.i2235 = call ptr %2490({ ptr, ptr, ptr, i32 } %2484, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2491 = call i32 %result.i.i2235({ ptr, ptr, ptr, i32 } %2484, { ptr, ptr, ptr, i32 } %2484, ptr nonnull align 8 %2) #7
  %2492 = icmp eq i32 %2491, %2463
  br i1 %2492, label %._crit_edge.i2236, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread

._crit_edge.i2236:                                ; preds = %2475
  %2493 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2494 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2472)
  %2495 = getelementptr i8, ptr %2488, i64 48
  %2496 = load ptr, ptr %2495, align 8
  %result.i59.i2237 = call ptr %2496({ ptr, ptr, ptr, i32 } %2484, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2497 = call { ptr, i160 } %result.i59.i2237({ ptr, ptr, ptr, i32 } %2484, { ptr, ptr, ptr, i32 } %2484, ptr nonnull align 8 %2) #7
  %2498 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2499 = load ptr, ptr %41, align 8
  %2500 = call i1 %2499({ ptr, i160 } %2497, { ptr, i160 } %2461) #7
  br i1 %2500, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread: ; preds = %._crit_edge.i2236, %2458, %2475
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2509

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242: ; preds = %._crit_edge.i2236
  %2501 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2502 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2472)
  %2503 = getelementptr i8, ptr %2488, i64 56
  %2504 = load ptr, ptr %2503, align 8
  %result.i60.i2239 = call ptr %2504({ ptr, ptr, ptr, i32 } %2484, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2505 = call { ptr, i160 } %result.i60.i2239({ ptr, ptr, ptr, i32 } %2484, { ptr, ptr, ptr, i32 } %2484, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2240 = extractvalue { ptr, i160 } %2505, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2506 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2507 = icmp ne ptr %.fca.0.extract21.i2240, @nil_typ
  %2508 = icmp ne ptr %.fca.0.extract21.i2240, null
  %.not63.i1189 = and i1 %2507, %2508
  br i1 %.not63.i1189, label %HashMap_get_keyK.exit1200, label %2509

2509:                                             ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242
  %2510 = add i32 %2463, 2127912214
  %2511 = shl i32 %2463, 12
  %2512 = add i32 %2510, %2511
  %2513 = ashr i32 %2512, 19
  %2514 = xor i32 %2512, %2513
  %2515 = xor i32 %2514, -949894596
  %2516 = add i32 %2515, 374761393
  %2517 = shl i32 %2515, 5
  %2518 = add i32 %2516, %2517
  %2519 = add i32 %2518, -744332180
  %2520 = shl i32 %2518, 9
  %2521 = xor i32 %2519, %2520
  %2522 = add i32 %2521, -42973499
  %2523 = shl i32 %2521, 3
  %2524 = add i32 %2522, %2523
  %2525 = ashr i32 %2524, 16
  %2526 = xor i32 %2524, %2525
  %2527 = xor i32 %2526, -1252372727
  %2528 = load i32, ptr %42, align 8
  %2529 = add i32 %2528, -1
  %2530 = and i32 %2529, %2527
  %2531 = load ptr, ptr %44, align 8
  %2532 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2533 = sext i32 %2530 to i64
  %2534 = shl nsw i64 %2533, 5
  %2535 = getelementptr i8, ptr %2531, i64 %2534
  %2536 = load ptr, ptr %2535, align 8
  %2537 = icmp ne ptr %2536, @nil_typ
  %2538 = icmp ne ptr %2536, null
  %.not44.i2272 = and i1 %2537, %2538
  br i1 %.not44.i2272, label %2539, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296

2539:                                             ; preds = %2509
  %2540 = getelementptr i8, ptr %2535, i64 8
  %2541 = load i64, ptr %2540, align 4
  %.sroa_idx.i2276 = getelementptr i8, ptr %2535, i64 16
  %2542 = load i64, ptr %.sroa_idx.i2276, align 4
  %2543 = inttoptr i64 %2541 to ptr
  %2544 = inttoptr i64 %2542 to ptr
  %hash_coef_ptr.i.i46.i2277 = getelementptr i8, ptr %2536, i64 8
  %tbl_size_ptr.i.i47.i2278 = getelementptr i8, ptr %2536, i64 16
  %offset_tbl_ptr.i.i48.i2279 = getelementptr i8, ptr %2536, i64 40
  %hash_coef.i.i49.i2280 = load i64, ptr %hash_coef_ptr.i.i46.i2277, align 4, !noalias !404
  %tbl_size.i.i50.i2281 = load i64, ptr %tbl_size_ptr.i.i47.i2278, align 4, !noalias !404
  %offset_tbl.i.i51.i2282 = load ptr, ptr %offset_tbl_ptr.i.i48.i2279, align 8, !noalias !404
  %product.i.i.i52.i2283 = mul i64 %hash_coef.i.i49.i2280, 4015701072841558310
  %shifted.i.i.i53.i2284 = lshr i64 %product.i.i.i52.i2283, 32
  %xored.i.i.i54.i2285 = xor i64 %shifted.i.i.i53.i2284, %product.i.i.i52.i2283
  %hash.i.i.i55.i2286 = and i64 %xored.i.i.i54.i2285, %tbl_size.i.i50.i2281
  %offset_ptr.i.i56.i2287 = getelementptr i32, ptr %offset_tbl.i.i51.i2282, i64 %hash.i.i.i55.i2286
  %offset.i.i57.i2288 = load i32, ptr %offset_ptr.i.i56.i2287, align 4, !noalias !404
  %2545 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2536, 0
  %2546 = insertvalue { ptr, ptr, ptr, i32 } %2545, ptr %2543, 1
  %2547 = insertvalue { ptr, ptr, ptr, i32 } %2546, ptr %2544, 2
  %2548 = insertvalue { ptr, ptr, ptr, i32 } %2547, i32 %offset.i.i57.i2288, 3
  %2549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2550 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2536) #34
  %2551 = sext i32 %offset.i.i57.i2288 to i64
  %2552 = getelementptr ptr, ptr %2536, i64 %2551
  %2553 = getelementptr i8, ptr %2552, i64 64
  %2554 = load ptr, ptr %2553, align 8
  %result.i.i2289 = call ptr %2554({ ptr, ptr, ptr, i32 } %2548, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2555 = call i32 %result.i.i2289({ ptr, ptr, ptr, i32 } %2548, { ptr, ptr, ptr, i32 } %2548, ptr nonnull align 8 %2) #7
  %2556 = icmp eq i32 %2555, %2463
  br i1 %2556, label %._crit_edge.i2290, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296

._crit_edge.i2290:                                ; preds = %2539
  %2557 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2558 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2536)
  %2559 = getelementptr i8, ptr %2552, i64 48
  %2560 = load ptr, ptr %2559, align 8
  %result.i59.i2291 = call ptr %2560({ ptr, ptr, ptr, i32 } %2548, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2561 = call { ptr, i160 } %result.i59.i2291({ ptr, ptr, ptr, i32 } %2548, { ptr, ptr, ptr, i32 } %2548, ptr nonnull align 8 %2) #7
  %2562 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2563 = load ptr, ptr %41, align 8
  %2564 = call i1 %2563({ ptr, i160 } %2561, { ptr, i160 } %2461) #7
  br i1 %2564, label %2565, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296

2565:                                             ; preds = %._crit_edge.i2290
  %2566 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2567 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2536)
  %2568 = getelementptr i8, ptr %2552, i64 56
  %2569 = load ptr, ptr %2568, align 8
  %result.i60.i2293 = call ptr %2569({ ptr, ptr, ptr, i32 } %2548, ptr nocapture nofree noundef nonnull readonly %2) #15
  %2570 = call { ptr, i160 } %result.i60.i2293({ ptr, ptr, ptr, i32 } %2548, { ptr, ptr, ptr, i32 } %2548, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2294 = extractvalue { ptr, i160 } %2570, 0
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296: ; preds = %2509, %2539, %._crit_edge.i2290, %2565
  %2571 = phi ptr [ %.fca.0.extract21.i2294, %2565 ], [ @nil_typ, %._crit_edge.i2290 ], [ @nil_typ, %2509 ], [ @nil_typ, %2539 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2572 = icmp ne ptr %2571, @nil_typ
  %2573 = icmp ne ptr %2571, null
  %.not65.not.not.i1193 = and i1 %2572, %2573
  %cond.fr.i1194 = freeze i1 %.not65.not.not.i1193
  %spec.select.i1195 = select i1 %cond.fr.i1194, ptr %2571, ptr @nil_typ
  br label %HashMap_get_keyK.exit1200

HashMap_get_keyK.exit1200:                        ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296
  %2574 = phi ptr [ %.fca.0.extract21.i2240, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242 ], [ %spec.select.i1195, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296 ]
  %2575 = icmp eq ptr %2574, @nil_typ
  %2576 = icmp eq ptr %2574, null
  %.not374.not = or i1 %2575, %2576
  %spec.select376 = select i1 %.not374.not, i1 %spec.select377, i1 false
  br label %._crit_edge.lr.ph.i2311

._crit_edge.lr.ph.i2311:                          ; preds = %HashMap_get_keyK.exit1200, %._crit_edge8
  %.6 = phi i1 [ %spec.select377, %._crit_edge8 ], [ %spec.select376, %HashMap_get_keyK.exit1200 ]
  %result.i478 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i478, align 16
  %2577 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2578 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2579 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2310 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i2310, ptr noundef nonnull align 16 dereferenceable(13) %result.i478, i64 13, i1 false)
  %2580 = sub i64 %2452, %2304
  %2581 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2582 = getelementptr i8, ptr %result.i.i2310, i64 13
  store i8 0, ptr %2582, align 1
  %puts.i1220 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2310)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i376.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376.i)
  %2583 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0365) #16
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i390.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390.i)
  %2584 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2580) #16
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i409.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409.i)
  br i1 %2305, label %._crit_edge1.i, label %._crit_edge.lr.ph.i2330

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i2311
  %2585 = icmp sgt i64 %2580, 0
  br i1 %2585, label %2586, label %._crit_edge.lr.ph.i429.i

2586:                                             ; preds = %._crit_edge1.i
  %2587 = zext nneg i32 %.0365 to i64
  %2588 = mul i64 %2580, 1000000
  %2589 = sdiv i64 %2588, %2587
  br label %._crit_edge.lr.ph.i429.i

._crit_edge.lr.ph.i429.i:                         ; preds = %2586, %._crit_edge1.i
  %.0.i = phi i64 [ %2589, %2586 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i428.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i)
  %2590 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #16
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %2591 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i447.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %2592 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i374.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447.i)
  br label %._crit_edge.lr.ph.i2330

._crit_edge.lr.ph.i2330:                          ; preds = %._crit_edge.lr.ph.i2311, %._crit_edge.lr.ph.i429.i
  %result.i482 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i482, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2593 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2594 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2329 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i2329, ptr noundef nonnull align 32 dereferenceable(18) %result.i482, i64 18, i1 false)
  %2595 = getelementptr i8, ptr %result.i.i2329, i64 18
  store i8 0, ptr %2595, align 1
  %puts.i1240 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2329)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %.6, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2596 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2597 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2348 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %., ptr %result.i.i2348, align 1
  %2598 = getelementptr i8, ptr %result.i.i2348, i64 4
  store i8 0, ptr %2598, align 1
  %puts.i1260 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2348)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i497 = call noalias align 32 dereferenceable_or_null(21) ptr @bump_malloc_inner(i64 noundef 21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <20 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %result.i497, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2599 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2600 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2367 = call noalias dereferenceable_or_null(21) ptr @bump_malloc_inner(i64 noundef 21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(20) %result.i.i2367, ptr noundef nonnull align 32 dereferenceable(20) %result.i497, i64 20, i1 false)
  %2601 = getelementptr i8, ptr %result.i.i2367, i64 20
  store i8 0, ptr %2601, align 1
  %puts.i1280 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2367)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2602 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0354.lcssa) #16
  %2603 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2604 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %2605 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i2386 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i8 41, ptr %result.i.i2386, align 1
  %2606 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2607 = getelementptr i8, ptr %result.i.i2386, i64 1
  store i8 0, ptr %2607, align 1
  %puts.i1301 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2386)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define noundef i32 @main() local_unnamed_addr {
._crit_edge.lr.ph.i:
  %0 = alloca [0 x ptr], align 8
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %oldProtect.i155.i = alloca i32, align 4
  %oldProtect.i.i31 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %oldProtect.i154.i = alloca i32, align 4
  %oldProtect.i.i = alloca i32, align 4
  tail call void @setup_landing_pad()
  %result.i = tail call noalias align 32 dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <26 x i8> <i8 45, i8 45, i8 45, i8 32, i8 72, i8 97, i8 115, i8 104, i8 77, i8 97, i8 112, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 45, i8 45, i8 45>, ptr %result.i, align 32
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i = tail call noalias dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i.i, ptr noundef nonnull align 32 dereferenceable(26) %result.i, i64 26, i1 false)
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i150.i = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i150.i, align 8
  %28 = getelementptr inbounds i8, ptr %result.i150.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i150.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %29, align 8
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i150.i) #38
  %result.i151.i = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i.i)
  %result.i152.i = call i32 @VirtualProtect(ptr nofree %result.i151.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i151.i, ptr noalias nofree noundef nonnull readnone @newiwemfnz, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i151.i) #39
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i151.i) #38
  %result.i153.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i154.i)
  %result.i155.i = call i32 @VirtualProtect(ptr nofree %result.i153.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i154.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i154.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i153.i, ptr noalias nofree noundef nonnull readnone @kbsaabmajz, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i156.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i153.i) #39
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i153.i) #38
  %33 = getelementptr inbounds i8, ptr %result.i150.i, i64 48
  store ptr %ret.i.i, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i150.i, i64 56
  store ptr %ret.i156.i, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i150.i, i64 40
  store i32 8, ptr %35, align 8
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %36 = getelementptr inbounds i8, ptr %result.i150.i, i64 24
  store ptr %result.i.i.i, ptr %36, align 8
  %result.i9.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %37 = getelementptr inbounds i8, ptr %result.i150.i, i64 32
  store ptr %result.i9.i.i, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %39 = call i64 @clock()
  %40 = getelementptr inbounds i8, ptr %result.i150.i, i64 44
  %41 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i150.i, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr undef, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 10, 3
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %HashMap_insert_keyK_valueV.exit.i, %._crit_edge.lr.ph.i
  %.0216.i = phi i32 [ %44, %HashMap_insert_keyK_valueV.exit.i ], [ 0, %._crit_edge.lr.ph.i ]
  %44 = add nuw nsw i32 %.0216.i, 1
  %.sroa.0131.0.insert.ext.i = zext nneg i32 %.0216.i to i160
  %45 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0131.0.insert.ext.i, 1
  %.sroa.0128.0.insert.ext.i = zext nneg i32 %44 to i160
  %46 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0128.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %47 = load ptr, ptr %result.i150.i, align 8
  %48 = load ptr, ptr %33, align 8
  %49 = call i32 %48({ ptr, i160 } %45) #7
  %50 = load i32, ptr %35, align 8
  %51 = add i32 %50, -1
  %52 = and i32 %51, %49
  %53 = load ptr, ptr %36, align 8
  %54 = load ptr, ptr %28, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %56 = sext i32 %52 to i64
  %57 = shl nsw i64 %56, 5
  %58 = getelementptr i8, ptr %53, i64 %57
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %58, i64 8
  %61 = icmp ne ptr %59, @nil_typ
  %62 = icmp ne ptr %59, null
  %.not64.i.i = and i1 %61, %62
  br i1 %.not64.i.i, label %63, label %160

63:                                               ; preds = %._crit_edge.i
  %64 = load i64, ptr %60, align 4
  %.sroa_idx.i.i = getelementptr i8, ptr %58, i64 16
  %65 = load i64, ptr %.sroa_idx.i.i, align 4
  %66 = inttoptr i64 %64 to ptr
  %67 = inttoptr i64 %65 to ptr
  %hash_coef_ptr.i.i66.i.i = getelementptr i8, ptr %59, i64 8
  %tbl_size_ptr.i.i67.i.i = getelementptr i8, ptr %59, i64 16
  %offset_tbl_ptr.i.i68.i.i = getelementptr i8, ptr %59, i64 40
  %hash_coef.i.i69.i.i = load i64, ptr %hash_coef_ptr.i.i66.i.i, align 4, !noalias !407
  %tbl_size.i.i70.i.i = load i64, ptr %tbl_size_ptr.i.i67.i.i, align 4, !noalias !407
  %offset_tbl.i.i71.i.i = load ptr, ptr %offset_tbl_ptr.i.i68.i.i, align 8, !noalias !407
  %product.i.i.i72.i.i = mul i64 %hash_coef.i.i69.i.i, 4015701072841558310
  %shifted.i.i.i73.i.i = lshr i64 %product.i.i.i72.i.i, 32
  %xored.i.i.i74.i.i = xor i64 %shifted.i.i.i73.i.i, %product.i.i.i72.i.i
  %hash.i.i.i75.i.i = and i64 %xored.i.i.i74.i.i, %tbl_size.i.i70.i.i
  %offset_ptr.i.i76.i.i = getelementptr i32, ptr %offset_tbl.i.i71.i.i, i64 %hash.i.i.i75.i.i
  %offset.i.i77.i.i = load i32, ptr %offset_ptr.i.i76.i.i, align 4, !noalias !407
  %68 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %59, 0
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %66, 1
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %67, 2
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %offset.i.i77.i.i, 3
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %59) #34
  %74 = sext i32 %offset.i.i77.i.i to i64
  %75 = getelementptr ptr, ptr %59, i64 %74
  %76 = getelementptr i8, ptr %75, i64 64
  %77 = load ptr, ptr %76, align 8
  %result.i.i399.i = call ptr %77({ ptr, ptr, ptr, i32 } %71, ptr nocapture nofree noundef nonnull readonly %0) #15
  %78 = call i32 %result.i.i399.i({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull align 8 %0) #7
  %79 = icmp eq i32 %78, %49
  br i1 %79, label %._crit_edge.i400.i, label %160

._crit_edge.i400.i:                               ; preds = %63
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %59)
  %82 = getelementptr i8, ptr %75, i64 48
  %83 = load ptr, ptr %82, align 8
  %result.i79.i.i = call ptr %83({ ptr, ptr, ptr, i32 } %71, ptr nocapture nofree noundef nonnull readonly %0) #15
  %84 = call { ptr, i160 } %result.i79.i.i({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull align 8 %0) #7
  %85 = load ptr, ptr %34, align 8
  %86 = call i1 %85({ ptr, i160 } %84, { ptr, i160 } %45) #7
  br i1 %86, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i, label %160

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i: ; preds = %._crit_edge.i400.i
  %87 = load ptr, ptr %result.i150.i, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %89 = load ptr, ptr %28, align 8
  %90 = load ptr, ptr %87, align 8, !alias.scope !410
  %91 = getelementptr i8, ptr %90, i64 72
  %92 = load ptr, ptr %91, align 8, !alias.scope !410
  %result.i.i.i401.i = call { i64, i64 } %92(ptr nocapture nofree nonnull readonly %87) #5, !alias.scope !410
  %93 = extractvalue { i64, i64 } %result.i.i.i401.i, 0
  %94 = extractvalue { i64, i64 } %result.i.i.i401.i, 1
  %95 = urem i64 20, %94
  %96 = icmp eq i64 %95, 0
  %97 = sub i64 %94, %95
  %98 = select i1 %96, i64 0, i64 %97
  %99 = add i64 %93, 20
  %100 = add i64 %99, %98
  %101 = load ptr, ptr %89, align 8, !alias.scope !410
  %102 = getelementptr i8, ptr %101, i64 72
  %103 = load ptr, ptr %102, align 8, !alias.scope !410
  %result.i1.i.i402.i = call { i64, i64 } %103(ptr nocapture nofree nonnull readonly %89) #5, !alias.scope !410
  %104 = extractvalue { i64, i64 } %result.i1.i.i402.i, 0
  %105 = extractvalue { i64, i64 } %result.i1.i.i402.i, 1
  %106 = call i64 @llvm.umax.i64(i64 %94, i64 %105)
  %107 = call i64 @llvm.umax.i64(i64 %106, i64 8)
  %108 = urem i64 %100, %105
  %109 = icmp eq i64 %108, 0
  %110 = sub i64 %105, %108
  %111 = select i1 %109, i64 0, i64 %110
  %112 = add i64 %104, %100
  %113 = add i64 %112, %111
  %114 = urem i64 %113, %107
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %107, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = add i64 %117, %113
  %result.i83.i403.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %118, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %87, ptr %result.i83.i403.i, align 8
  %119 = getelementptr inbounds i8, ptr %result.i83.i403.i, i64 8
  store ptr %89, ptr %119, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i403.i)
  %121 = load ptr, ptr %87, align 8
  %122 = getelementptr i8, ptr %121, i64 72
  %123 = load ptr, ptr %122, align 8
  %result.i.i114.i.i = call { i64, i64 } %123(ptr nocapture nofree nonnull readonly %87) #5
  %124 = extractvalue { i64, i64 } %result.i.i114.i.i, 1
  %125 = urem i64 20, %124
  %126 = icmp eq i64 %125, 0
  %reass.sub310 = sub i64 %124, %125
  %127 = add i64 %reass.sub310, 20
  %128 = select i1 %126, i64 20, i64 %127
  %129 = getelementptr i8, ptr %result.i83.i403.i, i64 %128
  %130 = getelementptr i8, ptr %121, i64 64
  %131 = load ptr, ptr %130, align 8
  call void %131({ ptr, i160 } %45, ptr nocapture nofree nonnull readonly %87, ptr nocapture nofree writeonly %129) #12
  %132 = load ptr, ptr %result.i83.i403.i, align 8
  %133 = load ptr, ptr %132, align 8
  %134 = getelementptr i8, ptr %133, i64 72
  %135 = load ptr, ptr %134, align 8
  %result.i.i115.i.i = call { i64, i64 } %135(ptr nocapture nofree nonnull readonly %132) #5
  %136 = extractvalue { i64, i64 } %result.i.i115.i.i, 0
  %137 = extractvalue { i64, i64 } %result.i.i115.i.i, 1
  %138 = urem i64 20, %137
  %139 = icmp eq i64 %138, 0
  %140 = sub i64 %137, %138
  %141 = select i1 %139, i64 0, i64 %140
  %142 = add i64 %136, 20
  %143 = add i64 %142, %141
  %144 = load ptr, ptr %119, align 8
  %145 = load ptr, ptr %144, align 8
  %146 = getelementptr i8, ptr %145, i64 72
  %147 = load ptr, ptr %146, align 8
  %result.i1.i116.i.i = call { i64, i64 } %147(ptr nocapture nofree nonnull readonly %144) #5
  %148 = extractvalue { i64, i64 } %result.i1.i116.i.i, 1
  %149 = urem i64 %143, %148
  %150 = icmp eq i64 %149, 0
  %151 = sub i64 %148, %149
  %152 = select i1 %150, i64 0, i64 %151
  %153 = getelementptr i8, ptr %result.i83.i403.i, i64 %143
  %154 = getelementptr i8, ptr %153, i64 %152
  %155 = getelementptr i8, ptr %145, i64 64
  %156 = load ptr, ptr %155, align 8
  call void %156({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %144, ptr nocapture nofree writeonly %154) #12
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %158 = getelementptr inbounds i8, ptr %result.i83.i403.i, i64 16
  store i32 %49, ptr %158, align 8
  store ptr @Entry, ptr %58, align 8
  %159 = ptrtoint ptr %result.i83.i403.i to i64
  store i64 %159, ptr %60, align 4
  %.sroa_idx28.i.i = getelementptr i8, ptr %58, i64 24
  store i32 10, ptr %.sroa_idx28.i.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_insert_keyK_valueV.exit.i

160:                                              ; preds = %._crit_edge.i400.i, %63, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %161 = add i32 %49, 2127912214
  %162 = shl i32 %49, 12
  %163 = add i32 %161, %162
  %164 = ashr i32 %163, 19
  %165 = xor i32 %163, %164
  %166 = xor i32 %165, -949894596
  %167 = add i32 %166, 374761393
  %168 = shl i32 %166, 5
  %169 = add i32 %167, %168
  %170 = add i32 %169, -744332180
  %171 = shl i32 %169, 9
  %172 = xor i32 %170, %171
  %173 = add i32 %172, -42973499
  %174 = shl i32 %172, 3
  %175 = add i32 %173, %174
  %176 = ashr i32 %175, 16
  %177 = xor i32 %175, %176
  %178 = xor i32 %177, -1252372727
  %179 = load i32, ptr %35, align 8
  %180 = add i32 %179, -1
  %181 = and i32 %180, %178
  %182 = load ptr, ptr %37, align 8
  %183 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %184 = sext i32 %181 to i64
  %185 = shl nsw i64 %184, 5
  %186 = getelementptr i8, ptr %182, i64 %185
  %187 = load ptr, ptr %186, align 8
  %188 = getelementptr i8, ptr %186, i64 8
  %189 = icmp ne ptr %187, @nil_typ
  %190 = icmp ne ptr %187, null
  %.not64.i432.i = and i1 %189, %190
  br i1 %.not64.i432.i, label %191, label %288

191:                                              ; preds = %160
  %192 = load i64, ptr %188, align 4
  %.sroa_idx.i434.i = getelementptr i8, ptr %186, i64 16
  %193 = load i64, ptr %.sroa_idx.i434.i, align 4
  %194 = inttoptr i64 %192 to ptr
  %195 = inttoptr i64 %193 to ptr
  %hash_coef_ptr.i.i66.i435.i = getelementptr i8, ptr %187, i64 8
  %tbl_size_ptr.i.i67.i436.i = getelementptr i8, ptr %187, i64 16
  %offset_tbl_ptr.i.i68.i437.i = getelementptr i8, ptr %187, i64 40
  %hash_coef.i.i69.i438.i = load i64, ptr %hash_coef_ptr.i.i66.i435.i, align 4, !noalias !413
  %tbl_size.i.i70.i439.i = load i64, ptr %tbl_size_ptr.i.i67.i436.i, align 4, !noalias !413
  %offset_tbl.i.i71.i440.i = load ptr, ptr %offset_tbl_ptr.i.i68.i437.i, align 8, !noalias !413
  %product.i.i.i72.i441.i = mul i64 %hash_coef.i.i69.i438.i, 4015701072841558310
  %shifted.i.i.i73.i442.i = lshr i64 %product.i.i.i72.i441.i, 32
  %xored.i.i.i74.i443.i = xor i64 %shifted.i.i.i73.i442.i, %product.i.i.i72.i441.i
  %hash.i.i.i75.i444.i = and i64 %xored.i.i.i74.i443.i, %tbl_size.i.i70.i439.i
  %offset_ptr.i.i76.i445.i = getelementptr i32, ptr %offset_tbl.i.i71.i440.i, i64 %hash.i.i.i75.i444.i
  %offset.i.i77.i446.i = load i32, ptr %offset_ptr.i.i76.i445.i, align 4, !noalias !413
  %196 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %187, 0
  %197 = insertvalue { ptr, ptr, ptr, i32 } %196, ptr %194, 1
  %198 = insertvalue { ptr, ptr, ptr, i32 } %197, ptr %195, 2
  %199 = insertvalue { ptr, ptr, ptr, i32 } %198, i32 %offset.i.i77.i446.i, 3
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %187) #34
  %202 = sext i32 %offset.i.i77.i446.i to i64
  %203 = getelementptr ptr, ptr %187, i64 %202
  %204 = getelementptr i8, ptr %203, i64 64
  %205 = load ptr, ptr %204, align 8
  %result.i.i447.i = call ptr %205({ ptr, ptr, ptr, i32 } %199, ptr nocapture nofree noundef nonnull readonly %0) #15
  %206 = call i32 %result.i.i447.i({ ptr, ptr, ptr, i32 } %199, { ptr, ptr, ptr, i32 } %199, ptr nonnull align 8 %0) #7
  %207 = icmp eq i32 %206, %49
  br i1 %207, label %._crit_edge.i448.i, label %288

._crit_edge.i448.i:                               ; preds = %191
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %209 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %187)
  %210 = getelementptr i8, ptr %203, i64 48
  %211 = load ptr, ptr %210, align 8
  %result.i79.i449.i = call ptr %211({ ptr, ptr, ptr, i32 } %199, ptr nocapture nofree noundef nonnull readonly %0) #15
  %212 = call { ptr, i160 } %result.i79.i449.i({ ptr, ptr, ptr, i32 } %199, { ptr, ptr, ptr, i32 } %199, ptr nonnull align 8 %0) #7
  %213 = load ptr, ptr %34, align 8
  %214 = call i1 %213({ ptr, i160 } %212, { ptr, i160 } %45) #7
  br i1 %214, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit461.i, label %288

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit461.i: ; preds = %._crit_edge.i448.i
  %215 = load ptr, ptr %result.i150.i, align 8
  %216 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %217 = load ptr, ptr %28, align 8
  %218 = load ptr, ptr %215, align 8, !alias.scope !416
  %219 = getelementptr i8, ptr %218, i64 72
  %220 = load ptr, ptr %219, align 8, !alias.scope !416
  %result.i.i.i453.i = call { i64, i64 } %220(ptr nocapture nofree nonnull readonly %215) #5, !alias.scope !416
  %221 = extractvalue { i64, i64 } %result.i.i.i453.i, 0
  %222 = extractvalue { i64, i64 } %result.i.i.i453.i, 1
  %223 = urem i64 20, %222
  %224 = icmp eq i64 %223, 0
  %225 = sub i64 %222, %223
  %226 = select i1 %224, i64 0, i64 %225
  %227 = add i64 %221, 20
  %228 = add i64 %227, %226
  %229 = load ptr, ptr %217, align 8, !alias.scope !416
  %230 = getelementptr i8, ptr %229, i64 72
  %231 = load ptr, ptr %230, align 8, !alias.scope !416
  %result.i1.i.i454.i = call { i64, i64 } %231(ptr nocapture nofree nonnull readonly %217) #5, !alias.scope !416
  %232 = extractvalue { i64, i64 } %result.i1.i.i454.i, 0
  %233 = extractvalue { i64, i64 } %result.i1.i.i454.i, 1
  %234 = call i64 @llvm.umax.i64(i64 %222, i64 %233)
  %235 = call i64 @llvm.umax.i64(i64 %234, i64 8)
  %236 = urem i64 %228, %233
  %237 = icmp eq i64 %236, 0
  %238 = sub i64 %233, %236
  %239 = select i1 %237, i64 0, i64 %238
  %240 = add i64 %232, %228
  %241 = add i64 %240, %239
  %242 = urem i64 %241, %235
  %243 = icmp eq i64 %242, 0
  %244 = sub i64 %235, %242
  %245 = select i1 %243, i64 0, i64 %244
  %246 = add i64 %245, %241
  %result.i83.i455.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %246, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %215, ptr %result.i83.i455.i, align 8
  %247 = getelementptr inbounds i8, ptr %result.i83.i455.i, i64 8
  store ptr %217, ptr %247, align 8
  %248 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i455.i)
  %249 = load ptr, ptr %215, align 8
  %250 = getelementptr i8, ptr %249, i64 72
  %251 = load ptr, ptr %250, align 8
  %result.i.i114.i456.i = call { i64, i64 } %251(ptr nocapture nofree nonnull readonly %215) #5
  %252 = extractvalue { i64, i64 } %result.i.i114.i456.i, 1
  %253 = urem i64 20, %252
  %254 = icmp eq i64 %253, 0
  %reass.sub309 = sub i64 %252, %253
  %255 = add i64 %reass.sub309, 20
  %256 = select i1 %254, i64 20, i64 %255
  %257 = getelementptr i8, ptr %result.i83.i455.i, i64 %256
  %258 = getelementptr i8, ptr %249, i64 64
  %259 = load ptr, ptr %258, align 8
  call void %259({ ptr, i160 } %45, ptr nocapture nofree nonnull readonly %215, ptr nocapture nofree writeonly %257) #12
  %260 = load ptr, ptr %result.i83.i455.i, align 8
  %261 = load ptr, ptr %260, align 8
  %262 = getelementptr i8, ptr %261, i64 72
  %263 = load ptr, ptr %262, align 8
  %result.i.i115.i458.i = call { i64, i64 } %263(ptr nocapture nofree nonnull readonly %260) #5
  %264 = extractvalue { i64, i64 } %result.i.i115.i458.i, 0
  %265 = extractvalue { i64, i64 } %result.i.i115.i458.i, 1
  %266 = urem i64 20, %265
  %267 = icmp eq i64 %266, 0
  %268 = sub i64 %265, %266
  %269 = select i1 %267, i64 0, i64 %268
  %270 = add i64 %264, 20
  %271 = add i64 %270, %269
  %272 = load ptr, ptr %247, align 8
  %273 = load ptr, ptr %272, align 8
  %274 = getelementptr i8, ptr %273, i64 72
  %275 = load ptr, ptr %274, align 8
  %result.i1.i116.i459.i = call { i64, i64 } %275(ptr nocapture nofree nonnull readonly %272) #5
  %276 = extractvalue { i64, i64 } %result.i1.i116.i459.i, 1
  %277 = urem i64 %271, %276
  %278 = icmp eq i64 %277, 0
  %279 = sub i64 %276, %277
  %280 = select i1 %278, i64 0, i64 %279
  %281 = getelementptr i8, ptr %result.i83.i455.i, i64 %271
  %282 = getelementptr i8, ptr %281, i64 %280
  %283 = getelementptr i8, ptr %273, i64 64
  %284 = load ptr, ptr %283, align 8
  call void %284({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %272, ptr nocapture nofree writeonly %282) #12
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %286 = getelementptr inbounds i8, ptr %result.i83.i455.i, i64 16
  store i32 %49, ptr %286, align 8
  store ptr @Entry, ptr %186, align 8
  %287 = ptrtoint ptr %result.i83.i455.i to i64
  store i64 %287, ptr %188, align 4
  %.sroa_idx28.i460.i = getelementptr i8, ptr %186, i64 24
  store i32 10, ptr %.sroa_idx28.i460.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_insert_keyK_valueV.exit.i

288:                                              ; preds = %._crit_edge.i448.i, %191, %160
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %289 = load i32, ptr %40, align 4
  %290 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %291 = load i32, ptr %35, align 8
  %.not.i.i = icmp slt i32 %289, %291
  br i1 %.not.i.i, label %._crit_edge.i.i, label %292

292:                                              ; preds = %288
  %293 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %294 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %295 = load ptr, ptr %36, align 8
  %296 = load ptr, ptr %37, align 8
  %297 = shl i32 %291, 1
  %spec.select.i476.i = call i32 @llvm.smax.i32(i32 %297, i32 16)
  store i32 %spec.select.i476.i, ptr %35, align 8
  %298 = zext nneg i32 %spec.select.i476.i to i64
  %299 = shl nuw nsw i64 %298, 5
  %result.i.i477.i = call noalias ptr @bump_malloc_inner(i64 noundef %299, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i477.i, ptr %36, align 8
  %result.i20.i.i = call noalias ptr @bump_malloc_inner(i64 noundef %299, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i.i, ptr %37, align 8
  store i32 0, ptr %40, align 4
  %300 = icmp sgt i32 %291, 0
  br i1 %300, label %.lr.ph.i.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread.i: ; preds = %292
  %301 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i.i

.lr.ph.i.i:                                       ; preds = %292, %._crit_edge.i793.i
  %.060.i.i = phi i32 [ %320, %._crit_edge.i793.i ], [ 0, %292 ]
  %302 = zext nneg i32 %.060.i.i to i64
  %303 = shl nuw nsw i64 %302, 5
  %304 = getelementptr i8, ptr %295, i64 %303
  %305 = load ptr, ptr %304, align 8
  %306 = icmp ne ptr %305, @nil_typ
  %307 = icmp ne ptr %305, null
  %.not16.i.i = and i1 %306, %307
  br i1 %.not16.i.i, label %308, label %._crit_edge.i793.i

308:                                              ; preds = %.lr.ph.i.i
  %309 = getelementptr i8, ptr %304, i64 8
  %310 = load i64, ptr %309, align 4
  %.sroa_idx.i794.i = getelementptr i8, ptr %304, i64 16
  %311 = load i64, ptr %.sroa_idx.i794.i, align 4
  %312 = inttoptr i64 %310 to ptr
  %313 = inttoptr i64 %311 to ptr
  %hash_coef_ptr.i.i18.i.i = getelementptr i8, ptr %305, i64 8
  %tbl_size_ptr.i.i19.i.i = getelementptr i8, ptr %305, i64 16
  %offset_tbl_ptr.i.i20.i.i = getelementptr i8, ptr %305, i64 40
  %hash_coef.i.i21.i.i = load i64, ptr %hash_coef_ptr.i.i18.i.i, align 4, !noalias !22
  %tbl_size.i.i22.i.i = load i64, ptr %tbl_size_ptr.i.i19.i.i, align 4, !noalias !22
  %offset_tbl.i.i23.i.i = load ptr, ptr %offset_tbl_ptr.i.i20.i.i, align 8, !noalias !22
  %product.i.i.i24.i.i = mul i64 %hash_coef.i.i21.i.i, 4015701072841558310
  %shifted.i.i.i25.i.i = lshr i64 %product.i.i.i24.i.i, 32
  %xored.i.i.i26.i.i = xor i64 %shifted.i.i.i25.i.i, %product.i.i.i24.i.i
  %hash.i.i.i27.i.i = and i64 %xored.i.i.i26.i.i, %tbl_size.i.i22.i.i
  %offset_ptr.i.i28.i.i = getelementptr i32, ptr %offset_tbl.i.i23.i.i, i64 %hash.i.i.i27.i.i
  %offset.i.i43.i.i = load i32, ptr %offset_ptr.i.i28.i.i, align 4, !noalias !419
  %314 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %305, 0
  %315 = insertvalue { ptr, ptr, ptr, i32 } %314, ptr %312, 1
  %316 = insertvalue { ptr, ptr, ptr, i32 } %315, ptr %313, 2
  %317 = insertvalue { ptr, ptr, ptr, i32 } %316, i32 %offset.i.i43.i.i, 3
  %318 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %319 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %317) #7
  br label %._crit_edge.i793.i

._crit_edge.i793.i:                               ; preds = %308, %.lr.ph.i.i
  %320 = add nuw nsw i32 %.060.i.i, 1
  %321 = icmp slt i32 %320, %291
  br i1 %321, label %.lr.ph.i.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i: ; preds = %._crit_edge.i793.i
  %322 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %323

323:                                              ; preds = %._crit_edge.i812.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i
  %.060.i810.i = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i ], [ %342, %._crit_edge.i812.i ]
  %324 = zext nneg i32 %.060.i810.i to i64
  %325 = shl nuw nsw i64 %324, 5
  %326 = getelementptr i8, ptr %296, i64 %325
  %327 = load ptr, ptr %326, align 8
  %328 = icmp ne ptr %327, @nil_typ
  %329 = icmp ne ptr %327, null
  %.not16.i811.i = and i1 %328, %329
  br i1 %.not16.i811.i, label %330, label %._crit_edge.i812.i

330:                                              ; preds = %323
  %331 = getelementptr i8, ptr %326, i64 8
  %332 = load i64, ptr %331, align 4
  %.sroa_idx.i813.i = getelementptr i8, ptr %326, i64 16
  %333 = load i64, ptr %.sroa_idx.i813.i, align 4
  %334 = inttoptr i64 %332 to ptr
  %335 = inttoptr i64 %333 to ptr
  %hash_coef_ptr.i.i18.i814.i = getelementptr i8, ptr %327, i64 8
  %tbl_size_ptr.i.i19.i815.i = getelementptr i8, ptr %327, i64 16
  %offset_tbl_ptr.i.i20.i816.i = getelementptr i8, ptr %327, i64 40
  %hash_coef.i.i21.i817.i = load i64, ptr %hash_coef_ptr.i.i18.i814.i, align 4, !noalias !22
  %tbl_size.i.i22.i818.i = load i64, ptr %tbl_size_ptr.i.i19.i815.i, align 4, !noalias !22
  %offset_tbl.i.i23.i819.i = load ptr, ptr %offset_tbl_ptr.i.i20.i816.i, align 8, !noalias !22
  %product.i.i.i24.i820.i = mul i64 %hash_coef.i.i21.i817.i, 4015701072841558310
  %shifted.i.i.i25.i821.i = lshr i64 %product.i.i.i24.i820.i, 32
  %xored.i.i.i26.i822.i = xor i64 %shifted.i.i.i25.i821.i, %product.i.i.i24.i820.i
  %hash.i.i.i27.i823.i = and i64 %xored.i.i.i26.i822.i, %tbl_size.i.i22.i818.i
  %offset_ptr.i.i28.i824.i = getelementptr i32, ptr %offset_tbl.i.i23.i819.i, i64 %hash.i.i.i27.i823.i
  %offset.i.i43.i825.i = load i32, ptr %offset_ptr.i.i28.i824.i, align 4, !noalias !422
  %336 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %327, 0
  %337 = insertvalue { ptr, ptr, ptr, i32 } %336, ptr %334, 1
  %338 = insertvalue { ptr, ptr, ptr, i32 } %337, ptr %335, 2
  %339 = insertvalue { ptr, ptr, ptr, i32 } %338, i32 %offset.i.i43.i825.i, 3
  %340 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %341 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %339) #7
  br label %._crit_edge.i812.i

._crit_edge.i812.i:                               ; preds = %330, %323
  %342 = add nuw nsw i32 %.060.i810.i, 1
  %343 = icmp slt i32 %342, %291
  br i1 %343, label %323, label %._crit_edge.i.i

._crit_edge.i.i:                                  ; preds = %._crit_edge.i812.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread.i, %288
  %344 = load ptr, ptr %47, align 8
  %345 = getelementptr i8, ptr %344, i64 72
  %346 = load ptr, ptr %345, align 8
  %result.i.i.i.i = call { i64, i64 } %346(ptr nocapture nofree nonnull readonly %47) #5
  %347 = extractvalue { i64, i64 } %result.i.i.i.i, 0
  %348 = extractvalue { i64, i64 } %result.i.i.i.i, 1
  %349 = urem i64 20, %348
  %350 = icmp eq i64 %349, 0
  %351 = sub i64 %348, %349
  %352 = select i1 %350, i64 0, i64 %351
  %353 = add i64 %347, 20
  %354 = add i64 %353, %352
  %355 = load ptr, ptr %54, align 8
  %356 = getelementptr i8, ptr %355, i64 72
  %357 = load ptr, ptr %356, align 8
  %result.i1.i.i.i = call { i64, i64 } %357(ptr nocapture nofree nonnull readonly %54) #5
  %358 = extractvalue { i64, i64 } %result.i1.i.i.i, 0
  %359 = extractvalue { i64, i64 } %result.i1.i.i.i, 1
  %360 = call i64 @llvm.umax.i64(i64 %348, i64 %359)
  %361 = call i64 @llvm.umax.i64(i64 %360, i64 8)
  %362 = urem i64 %354, %359
  %363 = icmp eq i64 %362, 0
  %364 = sub i64 %359, %362
  %365 = select i1 %363, i64 0, i64 %364
  %366 = add i64 %358, %354
  %367 = add i64 %366, %365
  %368 = urem i64 %367, %361
  %369 = icmp eq i64 %368, 0
  %370 = sub i64 %361, %368
  %371 = select i1 %369, i64 0, i64 %370
  %372 = add i64 %371, %367
  %result.i83.i.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %372, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %47, ptr %result.i83.i.i, align 8
  %373 = getelementptr inbounds i8, ptr %result.i83.i.i, i64 8
  store ptr %54, ptr %373, align 8
  %374 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i.i)
  %375 = load ptr, ptr %47, align 8
  %376 = getelementptr i8, ptr %375, i64 72
  %377 = load ptr, ptr %376, align 8
  %result.i.i179.i.i = call { i64, i64 } %377(ptr nocapture nofree nonnull readonly %47) #5
  %378 = extractvalue { i64, i64 } %result.i.i179.i.i, 1
  %379 = urem i64 20, %378
  %380 = icmp eq i64 %379, 0
  %reass.sub308 = sub i64 %378, %379
  %381 = add i64 %reass.sub308, 20
  %382 = select i1 %380, i64 20, i64 %381
  %383 = getelementptr i8, ptr %result.i83.i.i, i64 %382
  %384 = getelementptr i8, ptr %375, i64 64
  %385 = load ptr, ptr %384, align 8
  call void %385({ ptr, i160 } %45, ptr nocapture nofree nonnull readonly %47, ptr nocapture nofree writeonly %383) #12
  %386 = load ptr, ptr %result.i83.i.i, align 8
  %387 = load ptr, ptr %386, align 8
  %388 = getelementptr i8, ptr %387, i64 72
  %389 = load ptr, ptr %388, align 8
  %result.i.i180.i.i = call { i64, i64 } %389(ptr nocapture nofree nonnull readonly %386) #5
  %390 = extractvalue { i64, i64 } %result.i.i180.i.i, 0
  %391 = extractvalue { i64, i64 } %result.i.i180.i.i, 1
  %392 = urem i64 20, %391
  %393 = icmp eq i64 %392, 0
  %394 = sub i64 %391, %392
  %395 = select i1 %393, i64 0, i64 %394
  %396 = add i64 %390, 20
  %397 = add i64 %396, %395
  %398 = load ptr, ptr %373, align 8
  %399 = load ptr, ptr %398, align 8
  %400 = getelementptr i8, ptr %399, i64 72
  %401 = load ptr, ptr %400, align 8
  %result.i1.i181.i.i = call { i64, i64 } %401(ptr nocapture nofree nonnull readonly %398) #5
  %402 = extractvalue { i64, i64 } %result.i1.i181.i.i, 1
  %403 = urem i64 %397, %402
  %404 = icmp eq i64 %403, 0
  %405 = sub i64 %402, %403
  %406 = select i1 %404, i64 0, i64 %405
  %407 = getelementptr i8, ptr %result.i83.i.i, i64 %397
  %408 = getelementptr i8, ptr %407, i64 %406
  %409 = getelementptr i8, ptr %399, i64 64
  %410 = load ptr, ptr %409, align 8
  call void %410({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %398, ptr nocapture nofree writeonly %408) #12
  %411 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %412 = getelementptr inbounds i8, ptr %result.i83.i.i, i64 16
  store i32 %49, ptr %412, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %413 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %414 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %415 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %416

416:                                              ; preds = %.cont.cont.i.i, %._crit_edge.i.i
  %.0566.i.i = phi i32 [ 0, %._crit_edge.i.i ], [ %417, %.cont.cont.i.i ]
  %.070565.i.i = phi i1 [ true, %._crit_edge.i.i ], [ %483, %.cont.cont.i.i ]
  %.sroa.0.0564.i.i = phi ptr [ @Entry, %._crit_edge.i.i ], [ %vptr.i142.sroa.speculated.i.i, %.cont.cont.i.i ]
  %.sroa.6.0563.i.i = phi ptr [ %result.i83.i.i, %._crit_edge.i.i ], [ %spec.select539.i.i, %.cont.cont.i.i ]
  %.sroa.12.0562.i.i = phi ptr [ undef, %._crit_edge.i.i ], [ %spec.select.i493.i, %.cont.cont.i.i ]
  %.sroa.17.0561.i.i = phi i32 [ 10, %._crit_edge.i.i ], [ %offset.i.i154.i.i, %.cont.cont.i.i ]
  %417 = add nuw nsw i32 %.0566.i.i, 1
  %418 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i.i, 0
  %419 = insertvalue { ptr, ptr, ptr, i32 } %418, ptr %.sroa.6.0563.i.i, 1
  %420 = insertvalue { ptr, ptr, ptr, i32 } %419, ptr %.sroa.12.0562.i.i, 2
  %421 = insertvalue { ptr, ptr, ptr, i32 } %420, i32 %.sroa.17.0561.i.i, 3
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i.i)
  %423 = sext i32 %.sroa.17.0561.i.i to i64
  %424 = getelementptr ptr, ptr %.sroa.0.0564.i.i, i64 %423
  %425 = getelementptr i8, ptr %424, i64 64
  %426 = load ptr, ptr %425, align 8
  %result.i125.i.i = call ptr %426({ ptr, ptr, ptr, i32 } %421, ptr nocapture nofree noundef nonnull readonly %0) #15
  %427 = call i32 %result.i125.i.i({ ptr, ptr, ptr, i32 } %421, { ptr, ptr, ptr, i32 } %421, ptr nonnull align 8 %0) #7
  %428 = ptrtoint ptr %.sroa.6.0563.i.i to i64
  %429 = ptrtoint ptr %.sroa.12.0562.i.i to i64
  br i1 %.070565.i.i, label %430, label %446

430:                                              ; preds = %416
  %431 = load i32, ptr %35, align 8
  %432 = add i32 %431, -1
  %433 = and i32 %432, %427
  %434 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %435 = load ptr, ptr %36, align 8
  %436 = sext i32 %433 to i64
  %437 = shl nsw i64 %436, 5
  %438 = getelementptr i8, ptr %435, i64 %437
  %439 = load ptr, ptr %438, align 8
  %440 = getelementptr i8, ptr %438, i64 8
  %441 = load i160, ptr %440, align 4
  store ptr %.sroa.0.0564.i.i, ptr %438, align 8
  store i64 %428, ptr %440, align 4
  %.sroa_idx157.i.i = getelementptr i8, ptr %438, i64 16
  store i64 %429, ptr %.sroa_idx157.i.i, align 4
  %.sroa_idx158.i.i = getelementptr i8, ptr %438, i64 24
  store i32 %.sroa.17.0561.i.i, ptr %.sroa_idx158.i.i, align 4
  %442 = icmp ne ptr %439, @nil_typ
  %443 = icmp ne ptr %439, null
  %.not92.i.i = and i1 %442, %443
  %extract.i.i = lshr i160 %441, 64
  %444 = insertelement <2 x i160> poison, i160 %441, i64 0
  %445 = insertelement <2 x i160> %444, i160 %extract.i.i, i64 1
  br i1 %.not92.i.i, label %.cont.cont.i.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i

446:                                              ; preds = %416
  %447 = add i32 %427, 2127912214
  %448 = shl i32 %427, 12
  %449 = add i32 %447, %448
  %450 = ashr i32 %449, 19
  %451 = xor i32 %449, %450
  %452 = xor i32 %451, -949894596
  %453 = add i32 %452, 374761393
  %454 = shl i32 %452, 5
  %455 = add i32 %453, %454
  %456 = add i32 %455, -744332180
  %457 = shl i32 %455, 9
  %458 = xor i32 %456, %457
  %459 = add i32 %458, -42973499
  %460 = shl i32 %458, 3
  %461 = add i32 %459, %460
  %462 = ashr i32 %461, 16
  %463 = xor i32 %461, %462
  %464 = xor i32 %463, -1252372727
  %465 = load i32, ptr %35, align 8
  %466 = add i32 %465, -1
  %467 = and i32 %466, %464
  %468 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %469 = load ptr, ptr %37, align 8
  %470 = sext i32 %467 to i64
  %471 = shl nsw i64 %470, 5
  %472 = getelementptr i8, ptr %469, i64 %471
  %473 = load ptr, ptr %472, align 8
  %474 = getelementptr i8, ptr %472, i64 8
  %475 = load i160, ptr %474, align 4
  store ptr %.sroa.0.0564.i.i, ptr %472, align 8
  store i64 %428, ptr %474, align 4
  %.sroa_idx161.i.i = getelementptr i8, ptr %472, i64 16
  store i64 %429, ptr %.sroa_idx161.i.i, align 4
  %.sroa_idx162.i.i = getelementptr i8, ptr %472, i64 24
  store i32 %.sroa.17.0561.i.i, ptr %.sroa_idx162.i.i, align 4
  %476 = icmp ne ptr %473, @nil_typ
  %477 = icmp ne ptr %473, null
  %.not90.i.i = and i1 %476, %477
  %extract607.i.i = lshr i160 %475, 64
  %478 = insertelement <2 x i160> poison, i160 %475, i64 0
  %479 = insertelement <2 x i160> %478, i160 %extract607.i.i, i64 1
  br i1 %.not90.i.i, label %.cont.cont.i.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i

.cont.cont.i.i:                                   ; preds = %446, %430
  %vptr.i142.sroa.speculated.i.i = phi ptr [ %439, %430 ], [ %473, %446 ]
  %.in = phi <2 x i160> [ %445, %430 ], [ %479, %446 ]
  %480 = trunc <2 x i160> %.in to <2 x i64>
  %481 = extractelement <2 x i64> %480, i64 1
  %spec.select.i493.i = inttoptr i64 %481 to ptr
  %482 = extractelement <2 x i64> %480, i64 0
  %spec.select539.i.i = inttoptr i64 %482 to ptr
  %483 = xor i1 %.070565.i.i, true
  %hash_coef_ptr.i.i143.i.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i, i64 8
  %tbl_size_ptr.i.i144.i.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i, i64 16
  %offset_tbl_ptr.i.i145.i.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i, i64 40
  %hash_coef.i.i146.i.i = load i64, ptr %hash_coef_ptr.i.i143.i.i, align 4
  %tbl_size.i.i147.i.i = load i64, ptr %tbl_size_ptr.i.i144.i.i, align 4
  %offset_tbl.i.i148.i.i = load ptr, ptr %offset_tbl_ptr.i.i145.i.i, align 8
  %product.i.i.i149.i.i = mul i64 %hash_coef.i.i146.i.i, 4015701072841558310
  %shifted.i.i.i150.i.i = lshr i64 %product.i.i.i149.i.i, 32
  %xored.i.i.i151.i.i = xor i64 %shifted.i.i.i150.i.i, %product.i.i.i149.i.i
  %hash.i.i.i152.i.i = and i64 %xored.i.i.i151.i.i, %tbl_size.i.i147.i.i
  %offset_ptr.i.i153.i.i = getelementptr i32, ptr %offset_tbl.i.i148.i.i, i64 %hash.i.i.i152.i.i
  %offset.i.i154.i.i = load i32, ptr %offset_ptr.i.i153.i.i, align 4
  %484 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %485 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %486 = icmp ult i32 %.0566.i.i, 99
  br i1 %486, label %416, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i: ; preds = %446, %430
  %487 = phi ptr [ %24, %446 ], [ %23, %430 ]
  %488 = load i32, ptr %40, align 4
  store i32 %488, ptr %487, align 4
  %489 = add i32 %488, 1
  %490 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %489, ptr %40, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %HashMap_insert_keyK_valueV.exit.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i: ; preds = %.cont.cont.i.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  %491 = icmp eq ptr %vptr.i142.sroa.speculated.i.i, null
  br i1 %491, label %HashMap_insert_keyK_valueV.exit.i, label %492

492:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i
  %493 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %494 = load ptr, ptr %36, align 8
  %495 = load ptr, ptr %37, align 8
  %496 = load i32, ptr %35, align 8
  %497 = shl i32 %496, 1
  %spec.select.i510.i = call i32 @llvm.smax.i32(i32 %497, i32 16)
  store i32 %spec.select.i510.i, ptr %35, align 8
  %498 = zext nneg i32 %spec.select.i510.i to i64
  %499 = shl nuw nsw i64 %498, 5
  %result.i.i511.i = call noalias ptr @bump_malloc_inner(i64 noundef %499, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i511.i, ptr %36, align 8
  %result.i20.i512.i = call noalias ptr @bump_malloc_inner(i64 noundef %499, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i512.i, ptr %37, align 8
  store i32 0, ptr %40, align 4
  %500 = icmp sgt i32 %496, 0
  br i1 %500, label %.lr.ph.i859.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i

.lr.ph.i859.i:                                    ; preds = %492, %._crit_edge.i874.i
  %.060.i872.i = phi i32 [ %589, %._crit_edge.i874.i ], [ 0, %492 ]
  %501 = zext nneg i32 %.060.i872.i to i64
  %502 = shl nuw nsw i64 %501, 5
  %503 = getelementptr i8, ptr %494, i64 %502
  %504 = load ptr, ptr %503, align 8
  %505 = icmp ne ptr %504, @nil_typ
  %506 = icmp ne ptr %504, null
  %.not16.i873.i = and i1 %505, %506
  br i1 %.not16.i873.i, label %507, label %._crit_edge.i874.i

507:                                              ; preds = %.lr.ph.i859.i
  %508 = getelementptr i8, ptr %503, i64 8
  %509 = load <2 x i64>, ptr %508, align 4
  %hash_coef_ptr.i.i18.i876.i = getelementptr i8, ptr %504, i64 8
  %tbl_size_ptr.i.i19.i877.i = getelementptr i8, ptr %504, i64 16
  %offset_tbl_ptr.i.i20.i878.i = getelementptr i8, ptr %504, i64 40
  %510 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i.i = load i64, ptr %hash_coef_ptr.i.i18.i876.i, align 4, !noalias !22
  %tbl_size.i.i100.i.i = load i64, ptr %tbl_size_ptr.i.i19.i877.i, align 4, !noalias !22
  %offset_tbl.i.i101.i.i = load ptr, ptr %offset_tbl_ptr.i.i20.i878.i, align 8, !noalias !22
  %product.i.i.i102.i.i = mul i64 %hash_coef.i.i99.i.i, 4015701072841558310
  %shifted.i.i.i103.i.i = lshr i64 %product.i.i.i102.i.i, 32
  %xored.i.i.i104.i.i = xor i64 %shifted.i.i.i103.i.i, %product.i.i.i102.i.i
  %hash.i.i.i105.i.i = and i64 %xored.i.i.i104.i.i, %tbl_size.i.i100.i.i
  %offset_ptr.i.i106.i.i = getelementptr i32, ptr %offset_tbl.i.i101.i.i, i64 %hash.i.i.i105.i.i
  %offset.i.i121.i.i = load i32, ptr %offset_ptr.i.i106.i.i, align 4, !noalias !425
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %512 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %513 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %514

514:                                              ; preds = %.cont.cont.i1052.i, %507
  %.0566.i1039.i = phi i32 [ 0, %507 ], [ %518, %.cont.cont.i1052.i ]
  %.070565.i1040.i = phi i1 [ true, %507 ], [ %580, %.cont.cont.i1052.i ]
  %.sroa.0.0564.i1041.i = phi ptr [ %504, %507 ], [ %vptr.i142.sroa.speculated.i1055.i, %.cont.cont.i1052.i ]
  %.sroa.17.0561.i1044.i = phi i32 [ %offset.i.i121.i.i, %507 ], [ %offset.i.i154.i1069.i, %.cont.cont.i1052.i ]
  %515 = phi <2 x i64> [ %509, %507 ], [ %579, %.cont.cont.i1052.i ]
  %516 = extractelement <2 x i64> %515, i64 1
  %.sroa.12.0562.i1043.i = inttoptr i64 %516 to ptr
  %517 = extractelement <2 x i64> %515, i64 0
  %.sroa.6.0563.i1042.i = inttoptr i64 %517 to ptr
  %518 = add nuw nsw i32 %.0566.i1039.i, 1
  %519 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1041.i, 0
  %520 = insertvalue { ptr, ptr, ptr, i32 } %519, ptr %.sroa.6.0563.i1042.i, 1
  %521 = insertvalue { ptr, ptr, ptr, i32 } %520, ptr %.sroa.12.0562.i1043.i, 2
  %522 = insertvalue { ptr, ptr, ptr, i32 } %521, i32 %.sroa.17.0561.i1044.i, 3
  %523 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1041.i)
  %524 = sext i32 %.sroa.17.0561.i1044.i to i64
  %525 = getelementptr ptr, ptr %.sroa.0.0564.i1041.i, i64 %524
  %526 = getelementptr i8, ptr %525, i64 64
  %527 = load ptr, ptr %526, align 8
  %result.i125.i1045.i = call ptr %527({ ptr, ptr, ptr, i32 } %522, ptr nocapture nofree noundef nonnull readonly %0) #15
  %528 = call i32 %result.i125.i1045.i({ ptr, ptr, ptr, i32 } %522, { ptr, ptr, ptr, i32 } %522, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1040.i, label %529, label %545

529:                                              ; preds = %514
  %530 = load i32, ptr %35, align 8
  %531 = add i32 %530, -1
  %532 = and i32 %531, %528
  %533 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %534 = load ptr, ptr %36, align 8
  %535 = sext i32 %532 to i64
  %536 = shl nsw i64 %535, 5
  %537 = getelementptr i8, ptr %534, i64 %536
  %538 = load ptr, ptr %537, align 8
  %539 = getelementptr i8, ptr %537, i64 8
  %540 = load i160, ptr %539, align 4
  store ptr %.sroa.0.0564.i1041.i, ptr %537, align 8
  store i64 %517, ptr %539, align 4
  %.sroa_idx157.i1071.i = getelementptr i8, ptr %537, i64 16
  store i64 %516, ptr %.sroa_idx157.i1071.i, align 4
  %.sroa_idx158.i1072.i = getelementptr i8, ptr %537, i64 24
  store i32 %.sroa.17.0561.i1044.i, ptr %.sroa_idx158.i1072.i, align 4
  %541 = icmp ne ptr %538, @nil_typ
  %542 = icmp ne ptr %538, null
  %.not92.i1073.i = and i1 %541, %542
  %extract.i1075.i = lshr i160 %540, 64
  %543 = insertelement <2 x i160> poison, i160 %540, i64 0
  %544 = insertelement <2 x i160> %543, i160 %extract.i1075.i, i64 1
  br i1 %.not92.i1073.i, label %.cont.cont.i1052.i, label %584

545:                                              ; preds = %514
  %546 = add i32 %528, 2127912214
  %547 = shl i32 %528, 12
  %548 = add i32 %546, %547
  %549 = ashr i32 %548, 19
  %550 = xor i32 %548, %549
  %551 = xor i32 %550, -949894596
  %552 = add i32 %551, 374761393
  %553 = shl i32 %551, 5
  %554 = add i32 %552, %553
  %555 = add i32 %554, -744332180
  %556 = shl i32 %554, 9
  %557 = xor i32 %555, %556
  %558 = add i32 %557, -42973499
  %559 = shl i32 %557, 3
  %560 = add i32 %558, %559
  %561 = ashr i32 %560, 16
  %562 = xor i32 %560, %561
  %563 = xor i32 %562, -1252372727
  %564 = load i32, ptr %35, align 8
  %565 = add i32 %564, -1
  %566 = and i32 %565, %563
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %568 = load ptr, ptr %37, align 8
  %569 = sext i32 %566 to i64
  %570 = shl nsw i64 %569, 5
  %571 = getelementptr i8, ptr %568, i64 %570
  %572 = load ptr, ptr %571, align 8
  %573 = getelementptr i8, ptr %571, i64 8
  %574 = load i160, ptr %573, align 4
  store ptr %.sroa.0.0564.i1041.i, ptr %571, align 8
  store i64 %517, ptr %573, align 4
  %.sroa_idx161.i1046.i = getelementptr i8, ptr %571, i64 16
  store i64 %516, ptr %.sroa_idx161.i1046.i, align 4
  %.sroa_idx162.i1047.i = getelementptr i8, ptr %571, i64 24
  store i32 %.sroa.17.0561.i1044.i, ptr %.sroa_idx162.i1047.i, align 4
  %575 = icmp ne ptr %572, @nil_typ
  %576 = icmp ne ptr %572, null
  %.not90.i1048.i = and i1 %575, %576
  %extract607.i1050.i = lshr i160 %574, 64
  %577 = insertelement <2 x i160> poison, i160 %574, i64 0
  %578 = insertelement <2 x i160> %577, i160 %extract607.i1050.i, i64 1
  br i1 %.not90.i1048.i, label %.cont.cont.i1052.i, label %584

.cont.cont.i1052.i:                               ; preds = %545, %529
  %vptr.i142.sroa.speculated.i1055.i = phi ptr [ %538, %529 ], [ %572, %545 ]
  %.in313 = phi <2 x i160> [ %544, %529 ], [ %578, %545 ]
  %579 = trunc <2 x i160> %.in313 to <2 x i64>
  %580 = xor i1 %.070565.i1040.i, true
  %hash_coef_ptr.i.i143.i1058.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1055.i, i64 8
  %tbl_size_ptr.i.i144.i1059.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1055.i, i64 16
  %offset_tbl_ptr.i.i145.i1060.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1055.i, i64 40
  %hash_coef.i.i146.i1061.i = load i64, ptr %hash_coef_ptr.i.i143.i1058.i, align 4
  %tbl_size.i.i147.i1062.i = load i64, ptr %tbl_size_ptr.i.i144.i1059.i, align 4
  %offset_tbl.i.i148.i1063.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1060.i, align 8
  %product.i.i.i149.i1064.i = mul i64 %hash_coef.i.i146.i1061.i, 4015701072841558310
  %shifted.i.i.i150.i1065.i = lshr i64 %product.i.i.i149.i1064.i, 32
  %xored.i.i.i151.i1066.i = xor i64 %shifted.i.i.i150.i1065.i, %product.i.i.i149.i1064.i
  %hash.i.i.i152.i1067.i = and i64 %xored.i.i.i151.i1066.i, %tbl_size.i.i147.i1062.i
  %offset_ptr.i.i153.i1068.i = getelementptr i32, ptr %offset_tbl.i.i148.i1063.i, i64 %hash.i.i.i152.i1067.i
  %offset.i.i154.i1069.i = load i32, ptr %offset_ptr.i.i153.i1068.i, align 4
  %581 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %582 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %583 = icmp ult i32 %.0566.i1039.i, 99
  br i1 %583, label %514, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1077.i

584:                                              ; preds = %545, %529
  %585 = phi ptr [ %20, %545 ], [ %19, %529 ]
  %586 = load i32, ptr %40, align 4
  store i32 %586, ptr %585, align 4
  %587 = add i32 %586, 1
  %588 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %587, ptr %40, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1077.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1077.i: ; preds = %.cont.cont.i1052.i, %584
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %._crit_edge.i874.i

._crit_edge.i874.i:                               ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1077.i, %.lr.ph.i859.i
  %589 = add nuw nsw i32 %.060.i872.i, 1
  %590 = icmp slt i32 %589, %496
  br i1 %590, label %.lr.ph.i859.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892.i: ; preds = %._crit_edge.i874.i, %._crit_edge.i910.i
  %.060.i908.i = phi i32 [ %679, %._crit_edge.i910.i ], [ 0, %._crit_edge.i874.i ]
  %591 = zext nneg i32 %.060.i908.i to i64
  %592 = shl nuw nsw i64 %591, 5
  %593 = getelementptr i8, ptr %495, i64 %592
  %594 = load ptr, ptr %593, align 8
  %595 = icmp ne ptr %594, @nil_typ
  %596 = icmp ne ptr %594, null
  %.not16.i909.i = and i1 %595, %596
  br i1 %.not16.i909.i, label %597, label %._crit_edge.i910.i

597:                                              ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892.i
  %598 = getelementptr i8, ptr %593, i64 8
  %599 = load <2 x i64>, ptr %598, align 4
  %hash_coef_ptr.i.i18.i912.i = getelementptr i8, ptr %594, i64 8
  %tbl_size_ptr.i.i19.i913.i = getelementptr i8, ptr %594, i64 16
  %offset_tbl_ptr.i.i20.i914.i = getelementptr i8, ptr %594, i64 40
  %600 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i1095.i = load i64, ptr %hash_coef_ptr.i.i18.i912.i, align 4, !noalias !22
  %tbl_size.i.i100.i1096.i = load i64, ptr %tbl_size_ptr.i.i19.i913.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1097.i = load ptr, ptr %offset_tbl_ptr.i.i20.i914.i, align 8, !noalias !22
  %product.i.i.i102.i1098.i = mul i64 %hash_coef.i.i99.i1095.i, 4015701072841558310
  %shifted.i.i.i103.i1099.i = lshr i64 %product.i.i.i102.i1098.i, 32
  %xored.i.i.i104.i1100.i = xor i64 %shifted.i.i.i103.i1099.i, %product.i.i.i102.i1098.i
  %hash.i.i.i105.i1101.i = and i64 %xored.i.i.i104.i1100.i, %tbl_size.i.i100.i1096.i
  %offset_ptr.i.i106.i1102.i = getelementptr i32, ptr %offset_tbl.i.i101.i1097.i, i64 %hash.i.i.i105.i1101.i
  %offset.i.i121.i1103.i = load i32, ptr %offset_ptr.i.i106.i1102.i, align 4, !noalias !428
  %601 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %602 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %603 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %604

604:                                              ; preds = %.cont.cont.i1124.i, %597
  %.0566.i1104.i = phi i32 [ 0, %597 ], [ %608, %.cont.cont.i1124.i ]
  %.070565.i1105.i = phi i1 [ true, %597 ], [ %670, %.cont.cont.i1124.i ]
  %.sroa.0.0564.i1106.i = phi ptr [ %594, %597 ], [ %vptr.i142.sroa.speculated.i1127.i, %.cont.cont.i1124.i ]
  %.sroa.17.0561.i1109.i = phi i32 [ %offset.i.i121.i1103.i, %597 ], [ %offset.i.i154.i1141.i, %.cont.cont.i1124.i ]
  %605 = phi <2 x i64> [ %599, %597 ], [ %669, %.cont.cont.i1124.i ]
  %606 = extractelement <2 x i64> %605, i64 1
  %.sroa.12.0562.i1108.i = inttoptr i64 %606 to ptr
  %607 = extractelement <2 x i64> %605, i64 0
  %.sroa.6.0563.i1107.i = inttoptr i64 %607 to ptr
  %608 = add nuw nsw i32 %.0566.i1104.i, 1
  %609 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1106.i, 0
  %610 = insertvalue { ptr, ptr, ptr, i32 } %609, ptr %.sroa.6.0563.i1107.i, 1
  %611 = insertvalue { ptr, ptr, ptr, i32 } %610, ptr %.sroa.12.0562.i1108.i, 2
  %612 = insertvalue { ptr, ptr, ptr, i32 } %611, i32 %.sroa.17.0561.i1109.i, 3
  %613 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1106.i)
  %614 = sext i32 %.sroa.17.0561.i1109.i to i64
  %615 = getelementptr ptr, ptr %.sroa.0.0564.i1106.i, i64 %614
  %616 = getelementptr i8, ptr %615, i64 64
  %617 = load ptr, ptr %616, align 8
  %result.i125.i1110.i = call ptr %617({ ptr, ptr, ptr, i32 } %612, ptr nocapture nofree noundef nonnull readonly %0) #15
  %618 = call i32 %result.i125.i1110.i({ ptr, ptr, ptr, i32 } %612, { ptr, ptr, ptr, i32 } %612, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1105.i, label %619, label %635

619:                                              ; preds = %604
  %620 = load i32, ptr %35, align 8
  %621 = add i32 %620, -1
  %622 = and i32 %621, %618
  %623 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %624 = load ptr, ptr %36, align 8
  %625 = sext i32 %622 to i64
  %626 = shl nsw i64 %625, 5
  %627 = getelementptr i8, ptr %624, i64 %626
  %628 = load ptr, ptr %627, align 8
  %629 = getelementptr i8, ptr %627, i64 8
  %630 = load i160, ptr %629, align 4
  store ptr %.sroa.0.0564.i1106.i, ptr %627, align 8
  store i64 %607, ptr %629, align 4
  %.sroa_idx157.i1153.i = getelementptr i8, ptr %627, i64 16
  store i64 %606, ptr %.sroa_idx157.i1153.i, align 4
  %.sroa_idx158.i1154.i = getelementptr i8, ptr %627, i64 24
  store i32 %.sroa.17.0561.i1109.i, ptr %.sroa_idx158.i1154.i, align 4
  %631 = icmp ne ptr %628, @nil_typ
  %632 = icmp ne ptr %628, null
  %.not92.i1155.i = and i1 %631, %632
  %extract.i1157.i = lshr i160 %630, 64
  %633 = insertelement <2 x i160> poison, i160 %630, i64 0
  %634 = insertelement <2 x i160> %633, i160 %extract.i1157.i, i64 1
  br i1 %.not92.i1155.i, label %.cont.cont.i1124.i, label %674

635:                                              ; preds = %604
  %636 = add i32 %618, 2127912214
  %637 = shl i32 %618, 12
  %638 = add i32 %636, %637
  %639 = ashr i32 %638, 19
  %640 = xor i32 %638, %639
  %641 = xor i32 %640, -949894596
  %642 = add i32 %641, 374761393
  %643 = shl i32 %641, 5
  %644 = add i32 %642, %643
  %645 = add i32 %644, -744332180
  %646 = shl i32 %644, 9
  %647 = xor i32 %645, %646
  %648 = add i32 %647, -42973499
  %649 = shl i32 %647, 3
  %650 = add i32 %648, %649
  %651 = ashr i32 %650, 16
  %652 = xor i32 %650, %651
  %653 = xor i32 %652, -1252372727
  %654 = load i32, ptr %35, align 8
  %655 = add i32 %654, -1
  %656 = and i32 %655, %653
  %657 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %658 = load ptr, ptr %37, align 8
  %659 = sext i32 %656 to i64
  %660 = shl nsw i64 %659, 5
  %661 = getelementptr i8, ptr %658, i64 %660
  %662 = load ptr, ptr %661, align 8
  %663 = getelementptr i8, ptr %661, i64 8
  %664 = load i160, ptr %663, align 4
  store ptr %.sroa.0.0564.i1106.i, ptr %661, align 8
  store i64 %607, ptr %663, align 4
  %.sroa_idx161.i1114.i = getelementptr i8, ptr %661, i64 16
  store i64 %606, ptr %.sroa_idx161.i1114.i, align 4
  %.sroa_idx162.i1115.i = getelementptr i8, ptr %661, i64 24
  store i32 %.sroa.17.0561.i1109.i, ptr %.sroa_idx162.i1115.i, align 4
  %665 = icmp ne ptr %662, @nil_typ
  %666 = icmp ne ptr %662, null
  %.not90.i1116.i = and i1 %665, %666
  %extract607.i1118.i = lshr i160 %664, 64
  %667 = insertelement <2 x i160> poison, i160 %664, i64 0
  %668 = insertelement <2 x i160> %667, i160 %extract607.i1118.i, i64 1
  br i1 %.not90.i1116.i, label %.cont.cont.i1124.i, label %674

.cont.cont.i1124.i:                               ; preds = %635, %619
  %vptr.i142.sroa.speculated.i1127.i = phi ptr [ %628, %619 ], [ %662, %635 ]
  %.in314 = phi <2 x i160> [ %634, %619 ], [ %668, %635 ]
  %669 = trunc <2 x i160> %.in314 to <2 x i64>
  %670 = xor i1 %.070565.i1105.i, true
  %hash_coef_ptr.i.i143.i1130.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1127.i, i64 8
  %tbl_size_ptr.i.i144.i1131.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1127.i, i64 16
  %offset_tbl_ptr.i.i145.i1132.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1127.i, i64 40
  %hash_coef.i.i146.i1133.i = load i64, ptr %hash_coef_ptr.i.i143.i1130.i, align 4
  %tbl_size.i.i147.i1134.i = load i64, ptr %tbl_size_ptr.i.i144.i1131.i, align 4
  %offset_tbl.i.i148.i1135.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1132.i, align 8
  %product.i.i.i149.i1136.i = mul i64 %hash_coef.i.i146.i1133.i, 4015701072841558310
  %shifted.i.i.i150.i1137.i = lshr i64 %product.i.i.i149.i1136.i, 32
  %xored.i.i.i151.i1138.i = xor i64 %shifted.i.i.i150.i1137.i, %product.i.i.i149.i1136.i
  %hash.i.i.i152.i1139.i = and i64 %xored.i.i.i151.i1138.i, %tbl_size.i.i147.i1134.i
  %offset_ptr.i.i153.i1140.i = getelementptr i32, ptr %offset_tbl.i.i148.i1135.i, i64 %hash.i.i.i152.i1139.i
  %offset.i.i154.i1141.i = load i32, ptr %offset_ptr.i.i153.i1140.i, align 4
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %673 = icmp ult i32 %.0566.i1104.i, 99
  br i1 %673, label %604, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1159.i

674:                                              ; preds = %635, %619
  %675 = phi ptr [ %18, %635 ], [ %17, %619 ]
  %676 = load i32, ptr %40, align 4
  store i32 %676, ptr %675, align 4
  %677 = add i32 %676, 1
  %678 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %677, ptr %40, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1159.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1159.i: ; preds = %.cont.cont.i1124.i, %674
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i910.i

._crit_edge.i910.i:                               ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1159.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892.i
  %679 = add nuw nsw i32 %.060.i908.i, 1
  %680 = icmp slt i32 %679, %496
  br i1 %680, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit892.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i: ; preds = %._crit_edge.i910.i, %492
  %681 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %hash_coef.i.i99.i533.i = load i64, ptr %hash_coef_ptr.i.i143.i.i, align 4, !noalias !22
  %tbl_size.i.i100.i534.i = load i64, ptr %tbl_size_ptr.i.i144.i.i, align 4, !noalias !22
  %offset_tbl.i.i101.i535.i = load ptr, ptr %offset_tbl_ptr.i.i145.i.i, align 8, !noalias !22
  %product.i.i.i102.i536.i = mul i64 %hash_coef.i.i99.i533.i, 4015701072841558310
  %shifted.i.i.i103.i537.i = lshr i64 %product.i.i.i102.i536.i, 32
  %xored.i.i.i104.i538.i = xor i64 %shifted.i.i.i103.i537.i, %product.i.i.i102.i536.i
  %hash.i.i.i105.i539.i = and i64 %xored.i.i.i104.i538.i, %tbl_size.i.i100.i534.i
  %offset_ptr.i.i106.i540.i = getelementptr i32, ptr %offset_tbl.i.i101.i535.i, i64 %hash.i.i.i105.i539.i
  %offset.i.i121.i541.i = load i32, ptr %offset_ptr.i.i106.i540.i, align 4, !noalias !431
  %682 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %683 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %684 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %685

685:                                              ; preds = %.cont.cont.i563.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i
  %.0566.i543.i = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i ], [ %689, %.cont.cont.i563.i ]
  %.070565.i544.i = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i ], [ %751, %.cont.cont.i563.i ]
  %.sroa.0.0564.i545.i = phi ptr [ %vptr.i142.sroa.speculated.i.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i ], [ %vptr.i142.sroa.speculated.i566.i, %.cont.cont.i563.i ]
  %.sroa.17.0561.i548.i = phi i32 [ %offset.i.i121.i541.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i ], [ %offset.i.i154.i580.i, %.cont.cont.i563.i ]
  %686 = phi <2 x i64> [ %480, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit928.i ], [ %750, %.cont.cont.i563.i ]
  %687 = extractelement <2 x i64> %686, i64 1
  %.sroa.12.0562.i547.i = inttoptr i64 %687 to ptr
  %688 = extractelement <2 x i64> %686, i64 0
  %.sroa.6.0563.i546.i = inttoptr i64 %688 to ptr
  %689 = add nuw nsw i32 %.0566.i543.i, 1
  %690 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i545.i, 0
  %691 = insertvalue { ptr, ptr, ptr, i32 } %690, ptr %.sroa.6.0563.i546.i, 1
  %692 = insertvalue { ptr, ptr, ptr, i32 } %691, ptr %.sroa.12.0562.i547.i, 2
  %693 = insertvalue { ptr, ptr, ptr, i32 } %692, i32 %.sroa.17.0561.i548.i, 3
  %694 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i545.i)
  %695 = sext i32 %.sroa.17.0561.i548.i to i64
  %696 = getelementptr ptr, ptr %.sroa.0.0564.i545.i, i64 %695
  %697 = getelementptr i8, ptr %696, i64 64
  %698 = load ptr, ptr %697, align 8
  %result.i125.i549.i = call ptr %698({ ptr, ptr, ptr, i32 } %693, ptr nocapture nofree noundef nonnull readonly %0) #15
  %699 = call i32 %result.i125.i549.i({ ptr, ptr, ptr, i32 } %693, { ptr, ptr, ptr, i32 } %693, ptr nonnull align 8 %0) #7
  br i1 %.070565.i544.i, label %700, label %716

700:                                              ; preds = %685
  %701 = load i32, ptr %35, align 8
  %702 = add i32 %701, -1
  %703 = and i32 %702, %699
  %704 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %705 = load ptr, ptr %36, align 8
  %706 = sext i32 %703 to i64
  %707 = shl nsw i64 %706, 5
  %708 = getelementptr i8, ptr %705, i64 %707
  %709 = load ptr, ptr %708, align 8
  %710 = getelementptr i8, ptr %708, i64 8
  %711 = load i160, ptr %710, align 4
  store ptr %.sroa.0.0564.i545.i, ptr %708, align 8
  store i64 %688, ptr %710, align 4
  %.sroa_idx157.i592.i = getelementptr i8, ptr %708, i64 16
  store i64 %687, ptr %.sroa_idx157.i592.i, align 4
  %.sroa_idx158.i593.i = getelementptr i8, ptr %708, i64 24
  store i32 %.sroa.17.0561.i548.i, ptr %.sroa_idx158.i593.i, align 4
  %712 = icmp ne ptr %709, @nil_typ
  %713 = icmp ne ptr %709, null
  %.not92.i594.i = and i1 %712, %713
  %extract.i596.i = lshr i160 %711, 64
  %714 = insertelement <2 x i160> poison, i160 %711, i64 0
  %715 = insertelement <2 x i160> %714, i160 %extract.i596.i, i64 1
  br i1 %.not92.i594.i, label %.cont.cont.i563.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.thread.i

716:                                              ; preds = %685
  %717 = add i32 %699, 2127912214
  %718 = shl i32 %699, 12
  %719 = add i32 %717, %718
  %720 = ashr i32 %719, 19
  %721 = xor i32 %719, %720
  %722 = xor i32 %721, -949894596
  %723 = add i32 %722, 374761393
  %724 = shl i32 %722, 5
  %725 = add i32 %723, %724
  %726 = add i32 %725, -744332180
  %727 = shl i32 %725, 9
  %728 = xor i32 %726, %727
  %729 = add i32 %728, -42973499
  %730 = shl i32 %728, 3
  %731 = add i32 %729, %730
  %732 = ashr i32 %731, 16
  %733 = xor i32 %731, %732
  %734 = xor i32 %733, -1252372727
  %735 = load i32, ptr %35, align 8
  %736 = add i32 %735, -1
  %737 = and i32 %736, %734
  %738 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %739 = load ptr, ptr %37, align 8
  %740 = sext i32 %737 to i64
  %741 = shl nsw i64 %740, 5
  %742 = getelementptr i8, ptr %739, i64 %741
  %743 = load ptr, ptr %742, align 8
  %744 = getelementptr i8, ptr %742, i64 8
  %745 = load i160, ptr %744, align 4
  store ptr %.sroa.0.0564.i545.i, ptr %742, align 8
  store i64 %688, ptr %744, align 4
  %.sroa_idx161.i553.i = getelementptr i8, ptr %742, i64 16
  store i64 %687, ptr %.sroa_idx161.i553.i, align 4
  %.sroa_idx162.i554.i = getelementptr i8, ptr %742, i64 24
  store i32 %.sroa.17.0561.i548.i, ptr %.sroa_idx162.i554.i, align 4
  %746 = icmp ne ptr %743, @nil_typ
  %747 = icmp ne ptr %743, null
  %.not90.i555.i = and i1 %746, %747
  %extract607.i557.i = lshr i160 %745, 64
  %748 = insertelement <2 x i160> poison, i160 %745, i64 0
  %749 = insertelement <2 x i160> %748, i160 %extract607.i557.i, i64 1
  br i1 %.not90.i555.i, label %.cont.cont.i563.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.thread.i

.cont.cont.i563.i:                                ; preds = %716, %700
  %vptr.i142.sroa.speculated.i566.i = phi ptr [ %709, %700 ], [ %743, %716 ]
  %.in315 = phi <2 x i160> [ %715, %700 ], [ %749, %716 ]
  %750 = trunc <2 x i160> %.in315 to <2 x i64>
  %751 = xor i1 %.070565.i544.i, true
  %hash_coef_ptr.i.i143.i569.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i566.i, i64 8
  %tbl_size_ptr.i.i144.i570.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i566.i, i64 16
  %offset_tbl_ptr.i.i145.i571.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i566.i, i64 40
  %hash_coef.i.i146.i572.i = load i64, ptr %hash_coef_ptr.i.i143.i569.i, align 4
  %tbl_size.i.i147.i573.i = load i64, ptr %tbl_size_ptr.i.i144.i570.i, align 4
  %offset_tbl.i.i148.i574.i = load ptr, ptr %offset_tbl_ptr.i.i145.i571.i, align 8
  %product.i.i.i149.i575.i = mul i64 %hash_coef.i.i146.i572.i, 4015701072841558310
  %shifted.i.i.i150.i576.i = lshr i64 %product.i.i.i149.i575.i, 32
  %xored.i.i.i151.i577.i = xor i64 %shifted.i.i.i150.i576.i, %product.i.i.i149.i575.i
  %hash.i.i.i152.i578.i = and i64 %xored.i.i.i151.i577.i, %tbl_size.i.i147.i573.i
  %offset_ptr.i.i153.i579.i = getelementptr i32, ptr %offset_tbl.i.i148.i574.i, i64 %hash.i.i.i152.i578.i
  %offset.i.i154.i580.i = load i32, ptr %offset_ptr.i.i153.i579.i, align 4
  %752 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %753 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %754 = icmp ult i32 %.0566.i543.i, 99
  br i1 %754, label %685, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.thread.i: ; preds = %716, %700
  %755 = phi ptr [ %22, %716 ], [ %21, %700 ]
  %756 = load i32, ptr %40, align 4
  store i32 %756, ptr %755, align 4
  %757 = add i32 %756, 1
  %758 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %757, ptr %40, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %HashMap_insert_keyK_valueV.exit.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.i: ; preds = %.cont.cont.i563.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  %759 = icmp eq ptr %vptr.i142.sroa.speculated.i566.i, null
  br i1 %759, label %HashMap_insert_keyK_valueV.exit.i, label %760

760:                                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.i
  %761 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %762 = load ptr, ptr %36, align 8
  %763 = load ptr, ptr %37, align 8
  %764 = load i32, ptr %35, align 8
  %765 = shl i32 %764, 1
  %spec.select.i614.i = call i32 @llvm.smax.i32(i32 %765, i32 16)
  store i32 %spec.select.i614.i, ptr %35, align 8
  %766 = zext nneg i32 %spec.select.i614.i to i64
  %767 = shl nuw nsw i64 %766, 5
  %result.i.i615.i = call noalias ptr @bump_malloc_inner(i64 noundef %767, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i615.i, ptr %36, align 8
  %result.i20.i616.i = call noalias ptr @bump_malloc_inner(i64 noundef %767, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i616.i, ptr %37, align 8
  store i32 0, ptr %40, align 4
  %768 = icmp sgt i32 %764, 0
  br i1 %768, label %.lr.ph.i958.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.thread.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.thread.i: ; preds = %760
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit.i

.lr.ph.i958.i:                                    ; preds = %760, %._crit_edge.i973.i
  %.060.i971.i = phi i32 [ %858, %._crit_edge.i973.i ], [ 0, %760 ]
  %770 = zext nneg i32 %.060.i971.i to i64
  %771 = shl nuw nsw i64 %770, 5
  %772 = getelementptr i8, ptr %762, i64 %771
  %773 = load ptr, ptr %772, align 8
  %774 = icmp ne ptr %773, @nil_typ
  %775 = icmp ne ptr %773, null
  %.not16.i972.i = and i1 %774, %775
  br i1 %.not16.i972.i, label %776, label %._crit_edge.i973.i

776:                                              ; preds = %.lr.ph.i958.i
  %777 = getelementptr i8, ptr %772, i64 8
  %778 = load <2 x i64>, ptr %777, align 4
  %hash_coef_ptr.i.i18.i975.i = getelementptr i8, ptr %773, i64 8
  %tbl_size_ptr.i.i19.i976.i = getelementptr i8, ptr %773, i64 16
  %offset_tbl_ptr.i.i20.i977.i = getelementptr i8, ptr %773, i64 40
  %779 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i1177.i = load i64, ptr %hash_coef_ptr.i.i18.i975.i, align 4, !noalias !22
  %tbl_size.i.i100.i1178.i = load i64, ptr %tbl_size_ptr.i.i19.i976.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1179.i = load ptr, ptr %offset_tbl_ptr.i.i20.i977.i, align 8, !noalias !22
  %product.i.i.i102.i1180.i = mul i64 %hash_coef.i.i99.i1177.i, 4015701072841558310
  %shifted.i.i.i103.i1181.i = lshr i64 %product.i.i.i102.i1180.i, 32
  %xored.i.i.i104.i1182.i = xor i64 %shifted.i.i.i103.i1181.i, %product.i.i.i102.i1180.i
  %hash.i.i.i105.i1183.i = and i64 %xored.i.i.i104.i1182.i, %tbl_size.i.i100.i1178.i
  %offset_ptr.i.i106.i1184.i = getelementptr i32, ptr %offset_tbl.i.i101.i1179.i, i64 %hash.i.i.i105.i1183.i
  %offset.i.i121.i1185.i = load i32, ptr %offset_ptr.i.i106.i1184.i, align 4, !noalias !434
  %780 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %781 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %782 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %783

783:                                              ; preds = %.cont.cont.i1206.i, %776
  %.0566.i1186.i = phi i32 [ 0, %776 ], [ %787, %.cont.cont.i1206.i ]
  %.070565.i1187.i = phi i1 [ true, %776 ], [ %849, %.cont.cont.i1206.i ]
  %.sroa.0.0564.i1188.i = phi ptr [ %773, %776 ], [ %vptr.i142.sroa.speculated.i1209.i, %.cont.cont.i1206.i ]
  %.sroa.17.0561.i1191.i = phi i32 [ %offset.i.i121.i1185.i, %776 ], [ %offset.i.i154.i1223.i, %.cont.cont.i1206.i ]
  %784 = phi <2 x i64> [ %778, %776 ], [ %848, %.cont.cont.i1206.i ]
  %785 = extractelement <2 x i64> %784, i64 1
  %.sroa.12.0562.i1190.i = inttoptr i64 %785 to ptr
  %786 = extractelement <2 x i64> %784, i64 0
  %.sroa.6.0563.i1189.i = inttoptr i64 %786 to ptr
  %787 = add nuw nsw i32 %.0566.i1186.i, 1
  %788 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1188.i, 0
  %789 = insertvalue { ptr, ptr, ptr, i32 } %788, ptr %.sroa.6.0563.i1189.i, 1
  %790 = insertvalue { ptr, ptr, ptr, i32 } %789, ptr %.sroa.12.0562.i1190.i, 2
  %791 = insertvalue { ptr, ptr, ptr, i32 } %790, i32 %.sroa.17.0561.i1191.i, 3
  %792 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1188.i)
  %793 = sext i32 %.sroa.17.0561.i1191.i to i64
  %794 = getelementptr ptr, ptr %.sroa.0.0564.i1188.i, i64 %793
  %795 = getelementptr i8, ptr %794, i64 64
  %796 = load ptr, ptr %795, align 8
  %result.i125.i1192.i = call ptr %796({ ptr, ptr, ptr, i32 } %791, ptr nocapture nofree noundef nonnull readonly %0) #15
  %797 = call i32 %result.i125.i1192.i({ ptr, ptr, ptr, i32 } %791, { ptr, ptr, ptr, i32 } %791, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1187.i, label %798, label %814

798:                                              ; preds = %783
  %799 = load i32, ptr %35, align 8
  %800 = add i32 %799, -1
  %801 = and i32 %800, %797
  %802 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %803 = load ptr, ptr %36, align 8
  %804 = sext i32 %801 to i64
  %805 = shl nsw i64 %804, 5
  %806 = getelementptr i8, ptr %803, i64 %805
  %807 = load ptr, ptr %806, align 8
  %808 = getelementptr i8, ptr %806, i64 8
  %809 = load i160, ptr %808, align 4
  store ptr %.sroa.0.0564.i1188.i, ptr %806, align 8
  store i64 %786, ptr %808, align 4
  %.sroa_idx157.i1235.i = getelementptr i8, ptr %806, i64 16
  store i64 %785, ptr %.sroa_idx157.i1235.i, align 4
  %.sroa_idx158.i1236.i = getelementptr i8, ptr %806, i64 24
  store i32 %.sroa.17.0561.i1191.i, ptr %.sroa_idx158.i1236.i, align 4
  %810 = icmp ne ptr %807, @nil_typ
  %811 = icmp ne ptr %807, null
  %.not92.i1237.i = and i1 %810, %811
  %extract.i1239.i = lshr i160 %809, 64
  %812 = insertelement <2 x i160> poison, i160 %809, i64 0
  %813 = insertelement <2 x i160> %812, i160 %extract.i1239.i, i64 1
  br i1 %.not92.i1237.i, label %.cont.cont.i1206.i, label %853

814:                                              ; preds = %783
  %815 = add i32 %797, 2127912214
  %816 = shl i32 %797, 12
  %817 = add i32 %815, %816
  %818 = ashr i32 %817, 19
  %819 = xor i32 %817, %818
  %820 = xor i32 %819, -949894596
  %821 = add i32 %820, 374761393
  %822 = shl i32 %820, 5
  %823 = add i32 %821, %822
  %824 = add i32 %823, -744332180
  %825 = shl i32 %823, 9
  %826 = xor i32 %824, %825
  %827 = add i32 %826, -42973499
  %828 = shl i32 %826, 3
  %829 = add i32 %827, %828
  %830 = ashr i32 %829, 16
  %831 = xor i32 %829, %830
  %832 = xor i32 %831, -1252372727
  %833 = load i32, ptr %35, align 8
  %834 = add i32 %833, -1
  %835 = and i32 %834, %832
  %836 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %837 = load ptr, ptr %37, align 8
  %838 = sext i32 %835 to i64
  %839 = shl nsw i64 %838, 5
  %840 = getelementptr i8, ptr %837, i64 %839
  %841 = load ptr, ptr %840, align 8
  %842 = getelementptr i8, ptr %840, i64 8
  %843 = load i160, ptr %842, align 4
  store ptr %.sroa.0.0564.i1188.i, ptr %840, align 8
  store i64 %786, ptr %842, align 4
  %.sroa_idx161.i1196.i = getelementptr i8, ptr %840, i64 16
  store i64 %785, ptr %.sroa_idx161.i1196.i, align 4
  %.sroa_idx162.i1197.i = getelementptr i8, ptr %840, i64 24
  store i32 %.sroa.17.0561.i1191.i, ptr %.sroa_idx162.i1197.i, align 4
  %844 = icmp ne ptr %841, @nil_typ
  %845 = icmp ne ptr %841, null
  %.not90.i1198.i = and i1 %844, %845
  %extract607.i1200.i = lshr i160 %843, 64
  %846 = insertelement <2 x i160> poison, i160 %843, i64 0
  %847 = insertelement <2 x i160> %846, i160 %extract607.i1200.i, i64 1
  br i1 %.not90.i1198.i, label %.cont.cont.i1206.i, label %853

.cont.cont.i1206.i:                               ; preds = %814, %798
  %vptr.i142.sroa.speculated.i1209.i = phi ptr [ %807, %798 ], [ %841, %814 ]
  %.in316 = phi <2 x i160> [ %813, %798 ], [ %847, %814 ]
  %848 = trunc <2 x i160> %.in316 to <2 x i64>
  %849 = xor i1 %.070565.i1187.i, true
  %hash_coef_ptr.i.i143.i1212.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1209.i, i64 8
  %tbl_size_ptr.i.i144.i1213.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1209.i, i64 16
  %offset_tbl_ptr.i.i145.i1214.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1209.i, i64 40
  %hash_coef.i.i146.i1215.i = load i64, ptr %hash_coef_ptr.i.i143.i1212.i, align 4
  %tbl_size.i.i147.i1216.i = load i64, ptr %tbl_size_ptr.i.i144.i1213.i, align 4
  %offset_tbl.i.i148.i1217.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1214.i, align 8
  %product.i.i.i149.i1218.i = mul i64 %hash_coef.i.i146.i1215.i, 4015701072841558310
  %shifted.i.i.i150.i1219.i = lshr i64 %product.i.i.i149.i1218.i, 32
  %xored.i.i.i151.i1220.i = xor i64 %shifted.i.i.i150.i1219.i, %product.i.i.i149.i1218.i
  %hash.i.i.i152.i1221.i = and i64 %xored.i.i.i151.i1220.i, %tbl_size.i.i147.i1216.i
  %offset_ptr.i.i153.i1222.i = getelementptr i32, ptr %offset_tbl.i.i148.i1217.i, i64 %hash.i.i.i152.i1221.i
  %offset.i.i154.i1223.i = load i32, ptr %offset_ptr.i.i153.i1222.i, align 4
  %850 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %851 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %852 = icmp ult i32 %.0566.i1186.i, 99
  br i1 %852, label %783, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1241.i

853:                                              ; preds = %814, %798
  %854 = phi ptr [ %16, %814 ], [ %15, %798 ]
  %855 = load i32, ptr %40, align 4
  store i32 %855, ptr %854, align 4
  %856 = add i32 %855, 1
  %857 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %856, ptr %40, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1241.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1241.i: ; preds = %.cont.cont.i1206.i, %853
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i973.i

._crit_edge.i973.i:                               ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1241.i, %.lr.ph.i958.i
  %858 = add nuw nsw i32 %.060.i971.i, 1
  %859 = icmp slt i32 %858, %764
  br i1 %859, label %.lr.ph.i958.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.i: ; preds = %._crit_edge.i973.i
  %860 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %861

861:                                              ; preds = %._crit_edge.i1009.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.i
  %.060.i1007.i = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.i ], [ %950, %._crit_edge.i1009.i ]
  %862 = zext nneg i32 %.060.i1007.i to i64
  %863 = shl nuw nsw i64 %862, 5
  %864 = getelementptr i8, ptr %763, i64 %863
  %865 = load ptr, ptr %864, align 8
  %866 = icmp ne ptr %865, @nil_typ
  %867 = icmp ne ptr %865, null
  %.not16.i1008.i = and i1 %866, %867
  br i1 %.not16.i1008.i, label %868, label %._crit_edge.i1009.i

868:                                              ; preds = %861
  %869 = getelementptr i8, ptr %864, i64 8
  %870 = load <2 x i64>, ptr %869, align 4
  %hash_coef_ptr.i.i18.i1011.i = getelementptr i8, ptr %865, i64 8
  %tbl_size_ptr.i.i19.i1012.i = getelementptr i8, ptr %865, i64 16
  %offset_tbl_ptr.i.i20.i1013.i = getelementptr i8, ptr %865, i64 40
  %871 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i1259.i = load i64, ptr %hash_coef_ptr.i.i18.i1011.i, align 4, !noalias !22
  %tbl_size.i.i100.i1260.i = load i64, ptr %tbl_size_ptr.i.i19.i1012.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1261.i = load ptr, ptr %offset_tbl_ptr.i.i20.i1013.i, align 8, !noalias !22
  %product.i.i.i102.i1262.i = mul i64 %hash_coef.i.i99.i1259.i, 4015701072841558310
  %shifted.i.i.i103.i1263.i = lshr i64 %product.i.i.i102.i1262.i, 32
  %xored.i.i.i104.i1264.i = xor i64 %shifted.i.i.i103.i1263.i, %product.i.i.i102.i1262.i
  %hash.i.i.i105.i1265.i = and i64 %xored.i.i.i104.i1264.i, %tbl_size.i.i100.i1260.i
  %offset_ptr.i.i106.i1266.i = getelementptr i32, ptr %offset_tbl.i.i101.i1261.i, i64 %hash.i.i.i105.i1265.i
  %offset.i.i121.i1267.i = load i32, ptr %offset_ptr.i.i106.i1266.i, align 4, !noalias !437
  %872 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %873 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %874 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %875

875:                                              ; preds = %.cont.cont.i1288.i, %868
  %.0566.i1268.i = phi i32 [ 0, %868 ], [ %879, %.cont.cont.i1288.i ]
  %.070565.i1269.i = phi i1 [ true, %868 ], [ %941, %.cont.cont.i1288.i ]
  %.sroa.0.0564.i1270.i = phi ptr [ %865, %868 ], [ %vptr.i142.sroa.speculated.i1291.i, %.cont.cont.i1288.i ]
  %.sroa.17.0561.i1273.i = phi i32 [ %offset.i.i121.i1267.i, %868 ], [ %offset.i.i154.i1305.i, %.cont.cont.i1288.i ]
  %876 = phi <2 x i64> [ %870, %868 ], [ %940, %.cont.cont.i1288.i ]
  %877 = extractelement <2 x i64> %876, i64 1
  %.sroa.12.0562.i1272.i = inttoptr i64 %877 to ptr
  %878 = extractelement <2 x i64> %876, i64 0
  %.sroa.6.0563.i1271.i = inttoptr i64 %878 to ptr
  %879 = add nuw nsw i32 %.0566.i1268.i, 1
  %880 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1270.i, 0
  %881 = insertvalue { ptr, ptr, ptr, i32 } %880, ptr %.sroa.6.0563.i1271.i, 1
  %882 = insertvalue { ptr, ptr, ptr, i32 } %881, ptr %.sroa.12.0562.i1272.i, 2
  %883 = insertvalue { ptr, ptr, ptr, i32 } %882, i32 %.sroa.17.0561.i1273.i, 3
  %884 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1270.i)
  %885 = sext i32 %.sroa.17.0561.i1273.i to i64
  %886 = getelementptr ptr, ptr %.sroa.0.0564.i1270.i, i64 %885
  %887 = getelementptr i8, ptr %886, i64 64
  %888 = load ptr, ptr %887, align 8
  %result.i125.i1274.i = call ptr %888({ ptr, ptr, ptr, i32 } %883, ptr nocapture nofree noundef nonnull readonly %0) #15
  %889 = call i32 %result.i125.i1274.i({ ptr, ptr, ptr, i32 } %883, { ptr, ptr, ptr, i32 } %883, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1269.i, label %890, label %906

890:                                              ; preds = %875
  %891 = load i32, ptr %35, align 8
  %892 = add i32 %891, -1
  %893 = and i32 %892, %889
  %894 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %895 = load ptr, ptr %36, align 8
  %896 = sext i32 %893 to i64
  %897 = shl nsw i64 %896, 5
  %898 = getelementptr i8, ptr %895, i64 %897
  %899 = load ptr, ptr %898, align 8
  %900 = getelementptr i8, ptr %898, i64 8
  %901 = load i160, ptr %900, align 4
  store ptr %.sroa.0.0564.i1270.i, ptr %898, align 8
  store i64 %878, ptr %900, align 4
  %.sroa_idx157.i1317.i = getelementptr i8, ptr %898, i64 16
  store i64 %877, ptr %.sroa_idx157.i1317.i, align 4
  %.sroa_idx158.i1318.i = getelementptr i8, ptr %898, i64 24
  store i32 %.sroa.17.0561.i1273.i, ptr %.sroa_idx158.i1318.i, align 4
  %902 = icmp ne ptr %899, @nil_typ
  %903 = icmp ne ptr %899, null
  %.not92.i1319.i = and i1 %902, %903
  %extract.i1321.i = lshr i160 %901, 64
  %904 = insertelement <2 x i160> poison, i160 %901, i64 0
  %905 = insertelement <2 x i160> %904, i160 %extract.i1321.i, i64 1
  br i1 %.not92.i1319.i, label %.cont.cont.i1288.i, label %945

906:                                              ; preds = %875
  %907 = add i32 %889, 2127912214
  %908 = shl i32 %889, 12
  %909 = add i32 %907, %908
  %910 = ashr i32 %909, 19
  %911 = xor i32 %909, %910
  %912 = xor i32 %911, -949894596
  %913 = add i32 %912, 374761393
  %914 = shl i32 %912, 5
  %915 = add i32 %913, %914
  %916 = add i32 %915, -744332180
  %917 = shl i32 %915, 9
  %918 = xor i32 %916, %917
  %919 = add i32 %918, -42973499
  %920 = shl i32 %918, 3
  %921 = add i32 %919, %920
  %922 = ashr i32 %921, 16
  %923 = xor i32 %921, %922
  %924 = xor i32 %923, -1252372727
  %925 = load i32, ptr %35, align 8
  %926 = add i32 %925, -1
  %927 = and i32 %926, %924
  %928 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %929 = load ptr, ptr %37, align 8
  %930 = sext i32 %927 to i64
  %931 = shl nsw i64 %930, 5
  %932 = getelementptr i8, ptr %929, i64 %931
  %933 = load ptr, ptr %932, align 8
  %934 = getelementptr i8, ptr %932, i64 8
  %935 = load i160, ptr %934, align 4
  store ptr %.sroa.0.0564.i1270.i, ptr %932, align 8
  store i64 %878, ptr %934, align 4
  %.sroa_idx161.i1278.i = getelementptr i8, ptr %932, i64 16
  store i64 %877, ptr %.sroa_idx161.i1278.i, align 4
  %.sroa_idx162.i1279.i = getelementptr i8, ptr %932, i64 24
  store i32 %.sroa.17.0561.i1273.i, ptr %.sroa_idx162.i1279.i, align 4
  %936 = icmp ne ptr %933, @nil_typ
  %937 = icmp ne ptr %933, null
  %.not90.i1280.i = and i1 %936, %937
  %extract607.i1282.i = lshr i160 %935, 64
  %938 = insertelement <2 x i160> poison, i160 %935, i64 0
  %939 = insertelement <2 x i160> %938, i160 %extract607.i1282.i, i64 1
  br i1 %.not90.i1280.i, label %.cont.cont.i1288.i, label %945

.cont.cont.i1288.i:                               ; preds = %906, %890
  %vptr.i142.sroa.speculated.i1291.i = phi ptr [ %899, %890 ], [ %933, %906 ]
  %.in317 = phi <2 x i160> [ %905, %890 ], [ %939, %906 ]
  %940 = trunc <2 x i160> %.in317 to <2 x i64>
  %941 = xor i1 %.070565.i1269.i, true
  %hash_coef_ptr.i.i143.i1294.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1291.i, i64 8
  %tbl_size_ptr.i.i144.i1295.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1291.i, i64 16
  %offset_tbl_ptr.i.i145.i1296.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1291.i, i64 40
  %hash_coef.i.i146.i1297.i = load i64, ptr %hash_coef_ptr.i.i143.i1294.i, align 4
  %tbl_size.i.i147.i1298.i = load i64, ptr %tbl_size_ptr.i.i144.i1295.i, align 4
  %offset_tbl.i.i148.i1299.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1296.i, align 8
  %product.i.i.i149.i1300.i = mul i64 %hash_coef.i.i146.i1297.i, 4015701072841558310
  %shifted.i.i.i150.i1301.i = lshr i64 %product.i.i.i149.i1300.i, 32
  %xored.i.i.i151.i1302.i = xor i64 %shifted.i.i.i150.i1301.i, %product.i.i.i149.i1300.i
  %hash.i.i.i152.i1303.i = and i64 %xored.i.i.i151.i1302.i, %tbl_size.i.i147.i1298.i
  %offset_ptr.i.i153.i1304.i = getelementptr i32, ptr %offset_tbl.i.i148.i1299.i, i64 %hash.i.i.i152.i1303.i
  %offset.i.i154.i1305.i = load i32, ptr %offset_ptr.i.i153.i1304.i, align 4
  %942 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %943 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %944 = icmp ult i32 %.0566.i1268.i, 99
  br i1 %944, label %875, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1323.i

945:                                              ; preds = %906, %890
  %946 = phi ptr [ %14, %906 ], [ %13, %890 ]
  %947 = load i32, ptr %40, align 4
  store i32 %947, ptr %946, align 4
  %948 = add i32 %947, 1
  %949 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %948, ptr %40, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1323.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1323.i: ; preds = %.cont.cont.i1288.i, %945
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i1009.i

._crit_edge.i1009.i:                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1323.i, %861
  %950 = add nuw nsw i32 %.060.i1007.i, 1
  %951 = icmp slt i32 %950, %764
  br i1 %951, label %861, label %HashMap_insert_keyK_valueV.exit.i

HashMap_insert_keyK_valueV.exit.i:                ; preds = %._crit_edge.i1009.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit991.thread.i, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.i, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit598.thread.i, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit461.i, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %952 = icmp ult i32 %.0216.i, 999999
  br i1 %952, label %._crit_edge.i, label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %HashMap_insert_keyK_valueV.exit.i
  %953 = call i64 @clock()
  %954 = load ptr, ptr %33, align 8
  %955 = call i32 %954({ ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  %956 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %957 = load i32, ptr %35, align 8
  %958 = add i32 %957, -1
  %959 = and i32 %958, %955
  %960 = load ptr, ptr %36, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %961 = sext i32 %959 to i64
  %962 = shl nsw i64 %961, 5
  %963 = getelementptr i8, ptr %960, i64 %962
  %964 = load ptr, ptr %963, align 8
  %965 = icmp ne ptr %964, @nil_typ
  %966 = icmp ne ptr %964, null
  %.not44.i.i = and i1 %965, %966
  br i1 %.not44.i.i, label %967, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i

967:                                              ; preds = %._crit_edge2.i
  %968 = getelementptr i8, ptr %963, i64 8
  %969 = load i64, ptr %968, align 4
  %.sroa_idx.i659.i = getelementptr i8, ptr %963, i64 16
  %970 = load i64, ptr %.sroa_idx.i659.i, align 4
  %971 = inttoptr i64 %969 to ptr
  %972 = inttoptr i64 %970 to ptr
  %hash_coef_ptr.i.i46.i.i = getelementptr i8, ptr %964, i64 8
  %tbl_size_ptr.i.i47.i.i = getelementptr i8, ptr %964, i64 16
  %offset_tbl_ptr.i.i48.i.i = getelementptr i8, ptr %964, i64 40
  %hash_coef.i.i49.i.i = load i64, ptr %hash_coef_ptr.i.i46.i.i, align 4, !noalias !440
  %tbl_size.i.i50.i.i = load i64, ptr %tbl_size_ptr.i.i47.i.i, align 4, !noalias !440
  %offset_tbl.i.i51.i.i = load ptr, ptr %offset_tbl_ptr.i.i48.i.i, align 8, !noalias !440
  %product.i.i.i52.i.i = mul i64 %hash_coef.i.i49.i.i, 4015701072841558310
  %shifted.i.i.i53.i.i = lshr i64 %product.i.i.i52.i.i, 32
  %xored.i.i.i54.i.i = xor i64 %shifted.i.i.i53.i.i, %product.i.i.i52.i.i
  %hash.i.i.i55.i.i = and i64 %xored.i.i.i54.i.i, %tbl_size.i.i50.i.i
  %offset_ptr.i.i56.i.i = getelementptr i32, ptr %offset_tbl.i.i51.i.i, i64 %hash.i.i.i55.i.i
  %offset.i.i57.i.i = load i32, ptr %offset_ptr.i.i56.i.i, align 4, !noalias !440
  %973 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %964, 0
  %974 = insertvalue { ptr, ptr, ptr, i32 } %973, ptr %971, 1
  %975 = insertvalue { ptr, ptr, ptr, i32 } %974, ptr %972, 2
  %976 = insertvalue { ptr, ptr, ptr, i32 } %975, i32 %offset.i.i57.i.i, 3
  %977 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %964) #34
  %979 = sext i32 %offset.i.i57.i.i to i64
  %980 = getelementptr ptr, ptr %964, i64 %979
  %981 = getelementptr i8, ptr %980, i64 64
  %982 = load ptr, ptr %981, align 8
  %result.i.i660.i = call ptr %982({ ptr, ptr, ptr, i32 } %976, ptr nocapture nofree noundef nonnull readonly %0) #15
  %983 = call i32 %result.i.i660.i({ ptr, ptr, ptr, i32 } %976, { ptr, ptr, ptr, i32 } %976, ptr nonnull align 8 %0) #7
  %984 = icmp eq i32 %983, %955
  br i1 %984, label %._crit_edge.i661.i, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i

._crit_edge.i661.i:                               ; preds = %967
  %985 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %986 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %964)
  %987 = getelementptr i8, ptr %980, i64 48
  %988 = load ptr, ptr %987, align 8
  %result.i59.i.i = call ptr %988({ ptr, ptr, ptr, i32 } %976, ptr nocapture nofree noundef nonnull readonly %0) #15
  %989 = call { ptr, i160 } %result.i59.i.i({ ptr, ptr, ptr, i32 } %976, { ptr, ptr, ptr, i32 } %976, ptr nonnull align 8 %0) #7
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %991 = load ptr, ptr %34, align 8
  %992 = call i1 %991({ ptr, i160 } %989, { ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  br i1 %992, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i: ; preds = %._crit_edge.i661.i, %967, %._crit_edge2.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %1000

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i: ; preds = %._crit_edge.i661.i
  %993 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %994 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %964)
  %995 = getelementptr i8, ptr %980, i64 56
  %996 = load ptr, ptr %995, align 8
  %result.i60.i.i = call ptr %996({ ptr, ptr, ptr, i32 } %976, ptr nocapture nofree noundef nonnull readonly %0) #15
  %997 = call { ptr, i160 } %result.i60.i.i({ ptr, ptr, ptr, i32 } %976, { ptr, ptr, ptr, i32 } %976, ptr nonnull align 8 %0) #7
  %.fca.0.extract21.i.i = extractvalue { ptr, i160 } %997, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %998 = icmp ne ptr %.fca.0.extract21.i.i, @nil_typ
  %999 = icmp ne ptr %.fca.0.extract21.i.i, null
  %.not63.i.i = and i1 %998, %999
  br i1 %.not63.i.i, label %HashMap_get_keyK.exit.i, label %1000

1000:                                             ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i
  %1001 = add i32 %955, 2127912214
  %1002 = shl i32 %955, 12
  %1003 = add i32 %1001, %1002
  %1004 = ashr i32 %1003, 19
  %1005 = xor i32 %1003, %1004
  %1006 = xor i32 %1005, -949894596
  %1007 = add i32 %1006, 374761393
  %1008 = shl i32 %1006, 5
  %1009 = add i32 %1007, %1008
  %1010 = add i32 %1009, -744332180
  %1011 = shl i32 %1009, 9
  %1012 = xor i32 %1010, %1011
  %1013 = add i32 %1012, -42973499
  %1014 = shl i32 %1012, 3
  %1015 = add i32 %1013, %1014
  %1016 = ashr i32 %1015, 16
  %1017 = xor i32 %1015, %1016
  %1018 = xor i32 %1017, -1252372727
  %1019 = load i32, ptr %35, align 8
  %1020 = add i32 %1019, -1
  %1021 = and i32 %1020, %1018
  %1022 = load ptr, ptr %37, align 8
  %1023 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1024 = sext i32 %1021 to i64
  %1025 = shl nsw i64 %1024, 5
  %1026 = getelementptr i8, ptr %1022, i64 %1025
  %1027 = load ptr, ptr %1026, align 8
  %1028 = icmp ne ptr %1027, @nil_typ
  %1029 = icmp ne ptr %1027, null
  %.not44.i691.i = and i1 %1028, %1029
  br i1 %.not44.i691.i, label %1030, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715.i

1030:                                             ; preds = %1000
  %1031 = getelementptr i8, ptr %1026, i64 8
  %1032 = load i64, ptr %1031, align 4
  %.sroa_idx.i695.i = getelementptr i8, ptr %1026, i64 16
  %1033 = load i64, ptr %.sroa_idx.i695.i, align 4
  %1034 = inttoptr i64 %1032 to ptr
  %1035 = inttoptr i64 %1033 to ptr
  %hash_coef_ptr.i.i46.i696.i = getelementptr i8, ptr %1027, i64 8
  %tbl_size_ptr.i.i47.i697.i = getelementptr i8, ptr %1027, i64 16
  %offset_tbl_ptr.i.i48.i698.i = getelementptr i8, ptr %1027, i64 40
  %hash_coef.i.i49.i699.i = load i64, ptr %hash_coef_ptr.i.i46.i696.i, align 4, !noalias !443
  %tbl_size.i.i50.i700.i = load i64, ptr %tbl_size_ptr.i.i47.i697.i, align 4, !noalias !443
  %offset_tbl.i.i51.i701.i = load ptr, ptr %offset_tbl_ptr.i.i48.i698.i, align 8, !noalias !443
  %product.i.i.i52.i702.i = mul i64 %hash_coef.i.i49.i699.i, 4015701072841558310
  %shifted.i.i.i53.i703.i = lshr i64 %product.i.i.i52.i702.i, 32
  %xored.i.i.i54.i704.i = xor i64 %shifted.i.i.i53.i703.i, %product.i.i.i52.i702.i
  %hash.i.i.i55.i705.i = and i64 %xored.i.i.i54.i704.i, %tbl_size.i.i50.i700.i
  %offset_ptr.i.i56.i706.i = getelementptr i32, ptr %offset_tbl.i.i51.i701.i, i64 %hash.i.i.i55.i705.i
  %offset.i.i57.i707.i = load i32, ptr %offset_ptr.i.i56.i706.i, align 4, !noalias !443
  %1036 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1027, 0
  %1037 = insertvalue { ptr, ptr, ptr, i32 } %1036, ptr %1034, 1
  %1038 = insertvalue { ptr, ptr, ptr, i32 } %1037, ptr %1035, 2
  %1039 = insertvalue { ptr, ptr, ptr, i32 } %1038, i32 %offset.i.i57.i707.i, 3
  %1040 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1041 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1027) #34
  %1042 = sext i32 %offset.i.i57.i707.i to i64
  %1043 = getelementptr ptr, ptr %1027, i64 %1042
  %1044 = getelementptr i8, ptr %1043, i64 64
  %1045 = load ptr, ptr %1044, align 8
  %result.i.i708.i = call ptr %1045({ ptr, ptr, ptr, i32 } %1039, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1046 = call i32 %result.i.i708.i({ ptr, ptr, ptr, i32 } %1039, { ptr, ptr, ptr, i32 } %1039, ptr nonnull align 8 %0) #7
  %1047 = icmp eq i32 %1046, %955
  br i1 %1047, label %._crit_edge.i709.i, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715.i

._crit_edge.i709.i:                               ; preds = %1030
  %1048 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1049 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1027)
  %1050 = getelementptr i8, ptr %1043, i64 48
  %1051 = load ptr, ptr %1050, align 8
  %result.i59.i710.i = call ptr %1051({ ptr, ptr, ptr, i32 } %1039, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1052 = call { ptr, i160 } %result.i59.i710.i({ ptr, ptr, ptr, i32 } %1039, { ptr, ptr, ptr, i32 } %1039, ptr nonnull align 8 %0) #7
  %1053 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1054 = load ptr, ptr %34, align 8
  %1055 = call i1 %1054({ ptr, i160 } %1052, { ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  br i1 %1055, label %1056, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715.i

1056:                                             ; preds = %._crit_edge.i709.i
  %1057 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1058 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1027)
  %1059 = getelementptr i8, ptr %1043, i64 56
  %1060 = load ptr, ptr %1059, align 8
  %result.i60.i712.i = call ptr %1060({ ptr, ptr, ptr, i32 } %1039, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1061 = call { ptr, i160 } %result.i60.i712.i({ ptr, ptr, ptr, i32 } %1039, { ptr, ptr, ptr, i32 } %1039, ptr nonnull align 8 %0) #7
  %.fca.0.extract21.i713.i = extractvalue { ptr, i160 } %1061, 0
  %.fca.1.extract22.i714.i = extractvalue { ptr, i160 } %1061, 1
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715.i

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715.i: ; preds = %1056, %._crit_edge.i709.i, %1030, %1000
  %.reg2mem43.sroa.3.077.i692.i = phi i160 [ %.fca.1.extract22.i714.i, %1056 ], [ poison, %._crit_edge.i709.i ], [ poison, %1000 ], [ poison, %1030 ]
  %1062 = phi ptr [ %.fca.0.extract21.i713.i, %1056 ], [ @nil_typ, %._crit_edge.i709.i ], [ @nil_typ, %1000 ], [ @nil_typ, %1030 ]
  %.reload40.fca.0.insert.i693.i = insertvalue { ptr, i160 } poison, ptr %1062, 0
  %.reload40.fca.1.insert.i694.i = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i693.i, i160 %.reg2mem43.sroa.3.077.i692.i, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1063 = icmp ne ptr %1062, @nil_typ
  %1064 = icmp ne ptr %1062, null
  %.not65.not.not.i.i = and i1 %1063, %1064
  %cond.fr.i.i = freeze i1 %.not65.not.not.i.i
  %spec.select.i.i = select i1 %cond.fr.i.i, ptr %1062, ptr @nil_typ
  br label %HashMap_get_keyK.exit.i

HashMap_get_keyK.exit.i:                          ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i
  %.pn.i.i = phi { ptr, i160 } [ %997, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i ], [ %.reload40.fca.1.insert.i694.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715.i ]
  %1065 = phi ptr [ %.fca.0.extract21.i.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i ], [ %spec.select.i.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit715.i ]
  %1066 = icmp ne ptr %1065, @nil_typ
  %1067 = icmp ne ptr %1065, null
  %.not143.i = and i1 %1066, %1067
  br i1 %.not143.i, label %._crit_edge3.i, label %._crit_edge4.i

._crit_edge3.i:                                   ; preds = %HashMap_get_keyK.exit.i
  %.fca.1.extract..sroa.354.0101.i.i = extractvalue { ptr, i160 } %.pn.i.i, 1
  %.sroa.2.8.extract.trunc.i = trunc i160 %.fca.1.extract..sroa.354.0101.i.i to i32
  %.not147.i = icmp eq i32 %.sroa.2.8.extract.trunc.i, 1000000
  br label %._crit_edge4.i

._crit_edge4.i:                                   ; preds = %._crit_edge3.i, %HashMap_get_keyK.exit.i
  %.2.i = phi i1 [ %.not147.i, %._crit_edge3.i ], [ false, %HashMap_get_keyK.exit.i ]
  %1068 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %1070 = load i32, ptr %40, align 4
  %.not148.i = icmp eq i32 %1070, 1000000
  %1071 = select i1 %.not148.i, i1 %.2.i, i1 false
  %1072 = select i1 %1071, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %result.i162.i = call noalias align 32 dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i162.i, align 32
  %1073 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1074 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1075 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i729.i = call noalias dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(17) %result.i.i729.i, ptr noundef nonnull align 32 dereferenceable(17) %result.i162.i, i64 17, i1 false)
  %1076 = sub i64 %953, %39
  %1077 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1078 = getelementptr i8, ptr %result.i.i729.i, i64 17
  store i8 0, ptr %1078, align 1
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i729.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i97.i.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i.i, align 16
  %result.i.i376.i.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376.i.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i.i, i64 14, i1 false)
  %puts.i.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376.i.i)
  %1079 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 1000000) #16
  %result.i103.i.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i.i, align 16
  %result.i.i390.i.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390.i.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i.i, i64 14, i1 false)
  %puts.i314.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390.i.i)
  %1080 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1076) #16
  %result.i109.i.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i.i, align 4
  %result.i.i409.i.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i.i, i64 3, i1 false)
  %puts.i334.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409.i.i)
  %1081 = icmp sgt i64 %1076, 0
  br i1 %1081, label %1082, label %benchmark_insert_sequential.exit

1082:                                             ; preds = %._crit_edge4.i
  %1083 = mul i64 %1076, 1000000
  %1084 = sdiv i64 %1083, 1000000
  br label %benchmark_insert_sequential.exit

benchmark_insert_sequential.exit:                 ; preds = %._crit_edge4.i, %1082
  %.0.i.i = phi i64 [ %1084, %1082 ], [ 0, %._crit_edge4.i ]
  %result.i114.i.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i.i, align 16
  %result.i.i428.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428.i.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i.i, i64 15, i1 false)
  %puts.i354.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i.i)
  %1085 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i.i) #16
  %result.i120.i.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i.i, align 4
  %result.i.i447.i.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i.i, i64 3, i1 false)
  %puts.i374.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447.i.i)
  %result.i166.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i166.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1086 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1087 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i744.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i744.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i166.i, i64 18, i1 false)
  %1088 = getelementptr i8, ptr %result.i.i744.i, i64 18
  store i8 0, ptr %1088, align 1
  %puts.i350.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i744.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1089 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1091 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i763.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %1072, ptr %result.i.i763.i, align 1
  %1092 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1093 = getelementptr i8, ptr %result.i.i763.i, i64 4
  store i8 0, ptr %1093, align 1
  %puts.i370.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i763.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @benchmark_insert_random(i32 noundef 1000000)
  %result.i151.i32 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i151.i32, align 8
  %1094 = getelementptr inbounds i8, ptr %result.i151.i32, i64 8
  store ptr @_parameterization_Ptri32, ptr %1094, align 8
  %1095 = getelementptr inbounds i8, ptr %result.i151.i32, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %1095, align 8
  %1096 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i151.i32) #38
  %result.i152.i33 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i.i31)
  %result.i153.i34 = call i32 @VirtualProtect(ptr nofree %result.i152.i33, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i31) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i.i31)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i152.i33, ptr noalias nofree noundef nonnull readnone @mcvhackynz, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i.i35 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i152.i33) #39
  %1097 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i152.i33) #38
  %result.i154.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i155.i)
  %result.i156.i = call i32 @VirtualProtect(ptr nofree %result.i154.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i155.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i155.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i154.i, ptr noalias nofree noundef nonnull readnone @ozgljpgafu, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i157.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i154.i) #39
  %1098 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i154.i) #38
  %1099 = getelementptr inbounds i8, ptr %result.i151.i32, i64 48
  store ptr %ret.i.i35, ptr %1099, align 8
  %1100 = getelementptr inbounds i8, ptr %result.i151.i32, i64 56
  store ptr %ret.i157.i, ptr %1100, align 8
  %1101 = getelementptr inbounds i8, ptr %result.i151.i32, i64 40
  store i32 8, ptr %1101, align 8
  %result.i.i271.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %1102 = getelementptr inbounds i8, ptr %result.i151.i32, i64 24
  store ptr %result.i.i271.i, ptr %1102, align 8
  %result.i9.i.i36 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %1103 = getelementptr inbounds i8, ptr %result.i151.i32, i64 32
  store ptr %result.i9.i.i36, ptr %1103, align 8
  %1104 = getelementptr inbounds i8, ptr %result.i151.i32, i64 44
  %1105 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i151.i32, 1
  %1106 = insertvalue { ptr, ptr, ptr, i32 } %1105, ptr undef, 2
  %1107 = insertvalue { ptr, ptr, ptr, i32 } %1106, i32 10, 3
  br label %._crit_edge.i37

._crit_edge.i37:                                  ; preds = %HashMap_insert_keyK_valueV.exit.i64, %benchmark_insert_sequential.exit
  %.0258.i = phi i32 [ %1108, %HashMap_insert_keyK_valueV.exit.i64 ], [ 0, %benchmark_insert_sequential.exit ]
  %1108 = add nuw nsw i32 %.0258.i, 1
  %.sroa.0132.0.insert.ext.i = zext nneg i32 %.0258.i to i160
  %1109 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0132.0.insert.ext.i, 1
  %.sroa.0129.0.insert.ext.i = zext nneg i32 %1108 to i160
  %1110 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0129.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1111 = load ptr, ptr %result.i151.i32, align 8
  %1112 = load ptr, ptr %1099, align 8
  %1113 = call i32 %1112({ ptr, i160 } %1109) #7
  %1114 = load i32, ptr %1101, align 8
  %1115 = add i32 %1114, -1
  %1116 = and i32 %1115, %1113
  %1117 = load ptr, ptr %1102, align 8
  %1118 = load ptr, ptr %1094, align 8
  %1119 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1120 = sext i32 %1116 to i64
  %1121 = shl nsw i64 %1120, 5
  %1122 = getelementptr i8, ptr %1117, i64 %1121
  %1123 = load ptr, ptr %1122, align 8
  %1124 = getelementptr i8, ptr %1122, i64 8
  %1125 = icmp ne ptr %1123, @nil_typ
  %1126 = icmp ne ptr %1123, null
  %.not64.i.i38 = and i1 %1125, %1126
  br i1 %.not64.i.i38, label %1127, label %1224

1127:                                             ; preds = %._crit_edge.i37
  %1128 = load i64, ptr %1124, align 4
  %.sroa_idx.i.i159 = getelementptr i8, ptr %1122, i64 16
  %1129 = load i64, ptr %.sroa_idx.i.i159, align 4
  %1130 = inttoptr i64 %1128 to ptr
  %1131 = inttoptr i64 %1129 to ptr
  %hash_coef_ptr.i.i66.i.i160 = getelementptr i8, ptr %1123, i64 8
  %tbl_size_ptr.i.i67.i.i161 = getelementptr i8, ptr %1123, i64 16
  %offset_tbl_ptr.i.i68.i.i162 = getelementptr i8, ptr %1123, i64 40
  %hash_coef.i.i69.i.i163 = load i64, ptr %hash_coef_ptr.i.i66.i.i160, align 4, !noalias !446
  %tbl_size.i.i70.i.i164 = load i64, ptr %tbl_size_ptr.i.i67.i.i161, align 4, !noalias !446
  %offset_tbl.i.i71.i.i165 = load ptr, ptr %offset_tbl_ptr.i.i68.i.i162, align 8, !noalias !446
  %product.i.i.i72.i.i166 = mul i64 %hash_coef.i.i69.i.i163, 4015701072841558310
  %shifted.i.i.i73.i.i167 = lshr i64 %product.i.i.i72.i.i166, 32
  %xored.i.i.i74.i.i168 = xor i64 %shifted.i.i.i73.i.i167, %product.i.i.i72.i.i166
  %hash.i.i.i75.i.i169 = and i64 %xored.i.i.i74.i.i168, %tbl_size.i.i70.i.i164
  %offset_ptr.i.i76.i.i170 = getelementptr i32, ptr %offset_tbl.i.i71.i.i165, i64 %hash.i.i.i75.i.i169
  %offset.i.i77.i.i171 = load i32, ptr %offset_ptr.i.i76.i.i170, align 4, !noalias !446
  %1132 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1123, 0
  %1133 = insertvalue { ptr, ptr, ptr, i32 } %1132, ptr %1130, 1
  %1134 = insertvalue { ptr, ptr, ptr, i32 } %1133, ptr %1131, 2
  %1135 = insertvalue { ptr, ptr, ptr, i32 } %1134, i32 %offset.i.i77.i.i171, 3
  %1136 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1137 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1123) #34
  %1138 = sext i32 %offset.i.i77.i.i171 to i64
  %1139 = getelementptr ptr, ptr %1123, i64 %1138
  %1140 = getelementptr i8, ptr %1139, i64 64
  %1141 = load ptr, ptr %1140, align 8
  %result.i.i.i172 = call ptr %1141({ ptr, ptr, ptr, i32 } %1135, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1142 = call i32 %result.i.i.i172({ ptr, ptr, ptr, i32 } %1135, { ptr, ptr, ptr, i32 } %1135, ptr nonnull align 8 %0) #7
  %1143 = icmp eq i32 %1142, %1113
  br i1 %1143, label %._crit_edge.i461.i, label %1224

._crit_edge.i461.i:                               ; preds = %1127
  %1144 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1145 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1123)
  %1146 = getelementptr i8, ptr %1139, i64 48
  %1147 = load ptr, ptr %1146, align 8
  %result.i79.i.i173 = call ptr %1147({ ptr, ptr, ptr, i32 } %1135, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1148 = call { ptr, i160 } %result.i79.i.i173({ ptr, ptr, ptr, i32 } %1135, { ptr, ptr, ptr, i32 } %1135, ptr nonnull align 8 %0) #7
  %1149 = load ptr, ptr %1100, align 8
  %1150 = call i1 %1149({ ptr, i160 } %1148, { ptr, i160 } %1109) #7
  br i1 %1150, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i174, label %1224

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i174: ; preds = %._crit_edge.i461.i
  %1151 = load ptr, ptr %result.i151.i32, align 8
  %1152 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1153 = load ptr, ptr %1094, align 8
  %1154 = load ptr, ptr %1151, align 8, !alias.scope !449
  %1155 = getelementptr i8, ptr %1154, i64 72
  %1156 = load ptr, ptr %1155, align 8, !alias.scope !449
  %result.i.i.i462.i = call { i64, i64 } %1156(ptr nocapture nofree nonnull readonly %1151) #5, !alias.scope !449
  %1157 = extractvalue { i64, i64 } %result.i.i.i462.i, 0
  %1158 = extractvalue { i64, i64 } %result.i.i.i462.i, 1
  %1159 = urem i64 20, %1158
  %1160 = icmp eq i64 %1159, 0
  %1161 = sub i64 %1158, %1159
  %1162 = select i1 %1160, i64 0, i64 %1161
  %1163 = add i64 %1157, 20
  %1164 = add i64 %1163, %1162
  %1165 = load ptr, ptr %1153, align 8, !alias.scope !449
  %1166 = getelementptr i8, ptr %1165, i64 72
  %1167 = load ptr, ptr %1166, align 8, !alias.scope !449
  %result.i1.i.i463.i = call { i64, i64 } %1167(ptr nocapture nofree nonnull readonly %1153) #5, !alias.scope !449
  %1168 = extractvalue { i64, i64 } %result.i1.i.i463.i, 0
  %1169 = extractvalue { i64, i64 } %result.i1.i.i463.i, 1
  %1170 = call i64 @llvm.umax.i64(i64 %1158, i64 %1169)
  %1171 = call i64 @llvm.umax.i64(i64 %1170, i64 8)
  %1172 = urem i64 %1164, %1169
  %1173 = icmp eq i64 %1172, 0
  %1174 = sub i64 %1169, %1172
  %1175 = select i1 %1173, i64 0, i64 %1174
  %1176 = add i64 %1168, %1164
  %1177 = add i64 %1176, %1175
  %1178 = urem i64 %1177, %1171
  %1179 = icmp eq i64 %1178, 0
  %1180 = sub i64 %1171, %1178
  %1181 = select i1 %1179, i64 0, i64 %1180
  %1182 = add i64 %1181, %1177
  %result.i83.i464.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1182, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1151, ptr %result.i83.i464.i, align 8
  %1183 = getelementptr inbounds i8, ptr %result.i83.i464.i, i64 8
  store ptr %1153, ptr %1183, align 8
  %1184 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i464.i)
  %1185 = load ptr, ptr %1151, align 8
  %1186 = getelementptr i8, ptr %1185, i64 72
  %1187 = load ptr, ptr %1186, align 8
  %result.i.i114.i.i175 = call { i64, i64 } %1187(ptr nocapture nofree nonnull readonly %1151) #5
  %1188 = extractvalue { i64, i64 } %result.i.i114.i.i175, 1
  %1189 = urem i64 20, %1188
  %1190 = icmp eq i64 %1189, 0
  %reass.sub = sub i64 %1188, %1189
  %1191 = add i64 %reass.sub, 20
  %1192 = select i1 %1190, i64 20, i64 %1191
  %1193 = getelementptr i8, ptr %result.i83.i464.i, i64 %1192
  %1194 = getelementptr i8, ptr %1185, i64 64
  %1195 = load ptr, ptr %1194, align 8
  call void %1195({ ptr, i160 } %1109, ptr nocapture nofree nonnull readonly %1151, ptr nocapture nofree writeonly %1193) #12
  %1196 = load ptr, ptr %result.i83.i464.i, align 8
  %1197 = load ptr, ptr %1196, align 8
  %1198 = getelementptr i8, ptr %1197, i64 72
  %1199 = load ptr, ptr %1198, align 8
  %result.i.i115.i.i176 = call { i64, i64 } %1199(ptr nocapture nofree nonnull readonly %1196) #5
  %1200 = extractvalue { i64, i64 } %result.i.i115.i.i176, 0
  %1201 = extractvalue { i64, i64 } %result.i.i115.i.i176, 1
  %1202 = urem i64 20, %1201
  %1203 = icmp eq i64 %1202, 0
  %1204 = sub i64 %1201, %1202
  %1205 = select i1 %1203, i64 0, i64 %1204
  %1206 = add i64 %1200, 20
  %1207 = add i64 %1206, %1205
  %1208 = load ptr, ptr %1183, align 8
  %1209 = load ptr, ptr %1208, align 8
  %1210 = getelementptr i8, ptr %1209, i64 72
  %1211 = load ptr, ptr %1210, align 8
  %result.i1.i116.i.i177 = call { i64, i64 } %1211(ptr nocapture nofree nonnull readonly %1208) #5
  %1212 = extractvalue { i64, i64 } %result.i1.i116.i.i177, 1
  %1213 = urem i64 %1207, %1212
  %1214 = icmp eq i64 %1213, 0
  %1215 = sub i64 %1212, %1213
  %1216 = select i1 %1214, i64 0, i64 %1215
  %1217 = getelementptr i8, ptr %result.i83.i464.i, i64 %1207
  %1218 = getelementptr i8, ptr %1217, i64 %1216
  %1219 = getelementptr i8, ptr %1209, i64 64
  %1220 = load ptr, ptr %1219, align 8
  call void %1220({ ptr, i160 } %1110, ptr nocapture nofree nonnull readonly %1208, ptr nocapture nofree writeonly %1218) #12
  %1221 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1222 = getelementptr inbounds i8, ptr %result.i83.i464.i, i64 16
  store i32 %1113, ptr %1222, align 8
  store ptr @Entry, ptr %1122, align 8
  %1223 = ptrtoint ptr %result.i83.i464.i to i64
  store i64 %1223, ptr %1124, align 4
  %.sroa_idx28.i.i178 = getelementptr i8, ptr %1122, i64 24
  store i32 10, ptr %.sroa_idx28.i.i178, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_insert_keyK_valueV.exit.i64

1224:                                             ; preds = %._crit_edge.i461.i, %1127, %._crit_edge.i37
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1225 = add i32 %1113, 2127912214
  %1226 = shl i32 %1113, 12
  %1227 = add i32 %1225, %1226
  %1228 = ashr i32 %1227, 19
  %1229 = xor i32 %1227, %1228
  %1230 = xor i32 %1229, -949894596
  %1231 = add i32 %1230, 374761393
  %1232 = shl i32 %1230, 5
  %1233 = add i32 %1231, %1232
  %1234 = add i32 %1233, -744332180
  %1235 = shl i32 %1233, 9
  %1236 = xor i32 %1234, %1235
  %1237 = add i32 %1236, -42973499
  %1238 = shl i32 %1236, 3
  %1239 = add i32 %1237, %1238
  %1240 = ashr i32 %1239, 16
  %1241 = xor i32 %1239, %1240
  %1242 = xor i32 %1241, -1252372727
  %1243 = load i32, ptr %1101, align 8
  %1244 = add i32 %1243, -1
  %1245 = and i32 %1244, %1242
  %1246 = load ptr, ptr %1103, align 8
  %1247 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1248 = sext i32 %1245 to i64
  %1249 = shl nsw i64 %1248, 5
  %1250 = getelementptr i8, ptr %1246, i64 %1249
  %1251 = load ptr, ptr %1250, align 8
  %1252 = getelementptr i8, ptr %1250, i64 8
  %1253 = icmp ne ptr %1251, @nil_typ
  %1254 = icmp ne ptr %1251, null
  %.not64.i493.i = and i1 %1253, %1254
  br i1 %.not64.i493.i, label %1255, label %1352

1255:                                             ; preds = %1224
  %1256 = load i64, ptr %1252, align 4
  %.sroa_idx.i495.i = getelementptr i8, ptr %1250, i64 16
  %1257 = load i64, ptr %.sroa_idx.i495.i, align 4
  %1258 = inttoptr i64 %1256 to ptr
  %1259 = inttoptr i64 %1257 to ptr
  %hash_coef_ptr.i.i66.i496.i = getelementptr i8, ptr %1251, i64 8
  %tbl_size_ptr.i.i67.i497.i = getelementptr i8, ptr %1251, i64 16
  %offset_tbl_ptr.i.i68.i498.i = getelementptr i8, ptr %1251, i64 40
  %hash_coef.i.i69.i499.i = load i64, ptr %hash_coef_ptr.i.i66.i496.i, align 4, !noalias !452
  %tbl_size.i.i70.i500.i = load i64, ptr %tbl_size_ptr.i.i67.i497.i, align 4, !noalias !452
  %offset_tbl.i.i71.i501.i = load ptr, ptr %offset_tbl_ptr.i.i68.i498.i, align 8, !noalias !452
  %product.i.i.i72.i502.i = mul i64 %hash_coef.i.i69.i499.i, 4015701072841558310
  %shifted.i.i.i73.i503.i = lshr i64 %product.i.i.i72.i502.i, 32
  %xored.i.i.i74.i504.i = xor i64 %shifted.i.i.i73.i503.i, %product.i.i.i72.i502.i
  %hash.i.i.i75.i505.i = and i64 %xored.i.i.i74.i504.i, %tbl_size.i.i70.i500.i
  %offset_ptr.i.i76.i506.i = getelementptr i32, ptr %offset_tbl.i.i71.i501.i, i64 %hash.i.i.i75.i505.i
  %offset.i.i77.i507.i = load i32, ptr %offset_ptr.i.i76.i506.i, align 4, !noalias !452
  %1260 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1251, 0
  %1261 = insertvalue { ptr, ptr, ptr, i32 } %1260, ptr %1258, 1
  %1262 = insertvalue { ptr, ptr, ptr, i32 } %1261, ptr %1259, 2
  %1263 = insertvalue { ptr, ptr, ptr, i32 } %1262, i32 %offset.i.i77.i507.i, 3
  %1264 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1265 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1251) #34
  %1266 = sext i32 %offset.i.i77.i507.i to i64
  %1267 = getelementptr ptr, ptr %1251, i64 %1266
  %1268 = getelementptr i8, ptr %1267, i64 64
  %1269 = load ptr, ptr %1268, align 8
  %result.i.i508.i = call ptr %1269({ ptr, ptr, ptr, i32 } %1263, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1270 = call i32 %result.i.i508.i({ ptr, ptr, ptr, i32 } %1263, { ptr, ptr, ptr, i32 } %1263, ptr nonnull align 8 %0) #7
  %1271 = icmp eq i32 %1270, %1113
  br i1 %1271, label %._crit_edge.i509.i, label %1352

._crit_edge.i509.i:                               ; preds = %1255
  %1272 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1273 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1251)
  %1274 = getelementptr i8, ptr %1267, i64 48
  %1275 = load ptr, ptr %1274, align 8
  %result.i79.i510.i = call ptr %1275({ ptr, ptr, ptr, i32 } %1263, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1276 = call { ptr, i160 } %result.i79.i510.i({ ptr, ptr, ptr, i32 } %1263, { ptr, ptr, ptr, i32 } %1263, ptr nonnull align 8 %0) #7
  %1277 = load ptr, ptr %1100, align 8
  %1278 = call i1 %1277({ ptr, i160 } %1276, { ptr, i160 } %1109) #7
  br i1 %1278, label %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit522.i, label %1352

HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit522.i: ; preds = %._crit_edge.i509.i
  %1279 = load ptr, ptr %result.i151.i32, align 8
  %1280 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1281 = load ptr, ptr %1094, align 8
  %1282 = load ptr, ptr %1279, align 8, !alias.scope !455
  %1283 = getelementptr i8, ptr %1282, i64 72
  %1284 = load ptr, ptr %1283, align 8, !alias.scope !455
  %result.i.i.i514.i = call { i64, i64 } %1284(ptr nocapture nofree nonnull readonly %1279) #5, !alias.scope !455
  %1285 = extractvalue { i64, i64 } %result.i.i.i514.i, 0
  %1286 = extractvalue { i64, i64 } %result.i.i.i514.i, 1
  %1287 = urem i64 20, %1286
  %1288 = icmp eq i64 %1287, 0
  %1289 = sub i64 %1286, %1287
  %1290 = select i1 %1288, i64 0, i64 %1289
  %1291 = add i64 %1285, 20
  %1292 = add i64 %1291, %1290
  %1293 = load ptr, ptr %1281, align 8, !alias.scope !455
  %1294 = getelementptr i8, ptr %1293, i64 72
  %1295 = load ptr, ptr %1294, align 8, !alias.scope !455
  %result.i1.i.i515.i = call { i64, i64 } %1295(ptr nocapture nofree nonnull readonly %1281) #5, !alias.scope !455
  %1296 = extractvalue { i64, i64 } %result.i1.i.i515.i, 0
  %1297 = extractvalue { i64, i64 } %result.i1.i.i515.i, 1
  %1298 = call i64 @llvm.umax.i64(i64 %1286, i64 %1297)
  %1299 = call i64 @llvm.umax.i64(i64 %1298, i64 8)
  %1300 = urem i64 %1292, %1297
  %1301 = icmp eq i64 %1300, 0
  %1302 = sub i64 %1297, %1300
  %1303 = select i1 %1301, i64 0, i64 %1302
  %1304 = add i64 %1296, %1292
  %1305 = add i64 %1304, %1303
  %1306 = urem i64 %1305, %1299
  %1307 = icmp eq i64 %1306, 0
  %1308 = sub i64 %1299, %1306
  %1309 = select i1 %1307, i64 0, i64 %1308
  %1310 = add i64 %1309, %1305
  %result.i83.i516.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1310, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1279, ptr %result.i83.i516.i, align 8
  %1311 = getelementptr inbounds i8, ptr %result.i83.i516.i, i64 8
  store ptr %1281, ptr %1311, align 8
  %1312 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i516.i)
  %1313 = load ptr, ptr %1279, align 8
  %1314 = getelementptr i8, ptr %1313, i64 72
  %1315 = load ptr, ptr %1314, align 8
  %result.i.i114.i517.i = call { i64, i64 } %1315(ptr nocapture nofree nonnull readonly %1279) #5
  %1316 = extractvalue { i64, i64 } %result.i.i114.i517.i, 1
  %1317 = urem i64 20, %1316
  %1318 = icmp eq i64 %1317, 0
  %reass.sub312 = sub i64 %1316, %1317
  %1319 = add i64 %reass.sub312, 20
  %1320 = select i1 %1318, i64 20, i64 %1319
  %1321 = getelementptr i8, ptr %result.i83.i516.i, i64 %1320
  %1322 = getelementptr i8, ptr %1313, i64 64
  %1323 = load ptr, ptr %1322, align 8
  call void %1323({ ptr, i160 } %1109, ptr nocapture nofree nonnull readonly %1279, ptr nocapture nofree writeonly %1321) #12
  %1324 = load ptr, ptr %result.i83.i516.i, align 8
  %1325 = load ptr, ptr %1324, align 8
  %1326 = getelementptr i8, ptr %1325, i64 72
  %1327 = load ptr, ptr %1326, align 8
  %result.i.i115.i519.i = call { i64, i64 } %1327(ptr nocapture nofree nonnull readonly %1324) #5
  %1328 = extractvalue { i64, i64 } %result.i.i115.i519.i, 0
  %1329 = extractvalue { i64, i64 } %result.i.i115.i519.i, 1
  %1330 = urem i64 20, %1329
  %1331 = icmp eq i64 %1330, 0
  %1332 = sub i64 %1329, %1330
  %1333 = select i1 %1331, i64 0, i64 %1332
  %1334 = add i64 %1328, 20
  %1335 = add i64 %1334, %1333
  %1336 = load ptr, ptr %1311, align 8
  %1337 = load ptr, ptr %1336, align 8
  %1338 = getelementptr i8, ptr %1337, i64 72
  %1339 = load ptr, ptr %1338, align 8
  %result.i1.i116.i520.i = call { i64, i64 } %1339(ptr nocapture nofree nonnull readonly %1336) #5
  %1340 = extractvalue { i64, i64 } %result.i1.i116.i520.i, 1
  %1341 = urem i64 %1335, %1340
  %1342 = icmp eq i64 %1341, 0
  %1343 = sub i64 %1340, %1341
  %1344 = select i1 %1342, i64 0, i64 %1343
  %1345 = getelementptr i8, ptr %result.i83.i516.i, i64 %1335
  %1346 = getelementptr i8, ptr %1345, i64 %1344
  %1347 = getelementptr i8, ptr %1337, i64 64
  %1348 = load ptr, ptr %1347, align 8
  call void %1348({ ptr, i160 } %1110, ptr nocapture nofree nonnull readonly %1336, ptr nocapture nofree writeonly %1346) #12
  %1349 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1350 = getelementptr inbounds i8, ptr %result.i83.i516.i, i64 16
  store i32 %1113, ptr %1350, align 8
  store ptr @Entry, ptr %1250, align 8
  %1351 = ptrtoint ptr %result.i83.i516.i to i64
  store i64 %1351, ptr %1252, align 4
  %.sroa_idx28.i521.i = getelementptr i8, ptr %1250, i64 24
  store i32 10, ptr %.sroa_idx28.i521.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_insert_keyK_valueV.exit.i64

1352:                                             ; preds = %._crit_edge.i509.i, %1255, %1224
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1353 = load i32, ptr %1104, align 4
  %1354 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1355 = load i32, ptr %1101, align 8
  %.not.i.i39 = icmp slt i32 %1353, %1355
  br i1 %.not.i.i39, label %._crit_edge.i.i42, label %1356

1356:                                             ; preds = %1352
  %1357 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1358 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1359 = load ptr, ptr %1102, align 8
  %1360 = load ptr, ptr %1103, align 8
  %1361 = shl i32 %1355, 1
  %spec.select.i537.i = call i32 @llvm.smax.i32(i32 %1361, i32 16)
  store i32 %spec.select.i537.i, ptr %1101, align 8
  %1362 = zext nneg i32 %spec.select.i537.i to i64
  %1363 = shl nuw nsw i64 %1362, 5
  %result.i.i538.i = call noalias ptr @bump_malloc_inner(i64 noundef %1363, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i538.i, ptr %1102, align 8
  %result.i20.i.i40 = call noalias ptr @bump_malloc_inner(i64 noundef %1363, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i.i40, ptr %1103, align 8
  store i32 0, ptr %1104, align 4
  %1364 = icmp sgt i32 %1355, 0
  br i1 %1364, label %.lr.ph.i.i142, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread.i41

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread.i41: ; preds = %1356
  %1365 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %._crit_edge.i.i42

.lr.ph.i.i142:                                    ; preds = %1356, %._crit_edge.i873.i
  %.060.i.i143 = phi i32 [ %1384, %._crit_edge.i873.i ], [ 0, %1356 ]
  %1366 = zext nneg i32 %.060.i.i143 to i64
  %1367 = shl nuw nsw i64 %1366, 5
  %1368 = getelementptr i8, ptr %1359, i64 %1367
  %1369 = load ptr, ptr %1368, align 8
  %1370 = icmp ne ptr %1369, @nil_typ
  %1371 = icmp ne ptr %1369, null
  %.not16.i.i144 = and i1 %1370, %1371
  br i1 %.not16.i.i144, label %1372, label %._crit_edge.i873.i

1372:                                             ; preds = %.lr.ph.i.i142
  %1373 = getelementptr i8, ptr %1368, i64 8
  %1374 = load i64, ptr %1373, align 4
  %.sroa_idx.i874.i = getelementptr i8, ptr %1368, i64 16
  %1375 = load i64, ptr %.sroa_idx.i874.i, align 4
  %1376 = inttoptr i64 %1374 to ptr
  %1377 = inttoptr i64 %1375 to ptr
  %hash_coef_ptr.i.i18.i.i146 = getelementptr i8, ptr %1369, i64 8
  %tbl_size_ptr.i.i19.i.i147 = getelementptr i8, ptr %1369, i64 16
  %offset_tbl_ptr.i.i20.i.i148 = getelementptr i8, ptr %1369, i64 40
  %hash_coef.i.i21.i.i149 = load i64, ptr %hash_coef_ptr.i.i18.i.i146, align 4, !noalias !22
  %tbl_size.i.i22.i.i150 = load i64, ptr %tbl_size_ptr.i.i19.i.i147, align 4, !noalias !22
  %offset_tbl.i.i23.i.i151 = load ptr, ptr %offset_tbl_ptr.i.i20.i.i148, align 8, !noalias !22
  %product.i.i.i24.i.i152 = mul i64 %hash_coef.i.i21.i.i149, 4015701072841558310
  %shifted.i.i.i25.i.i153 = lshr i64 %product.i.i.i24.i.i152, 32
  %xored.i.i.i26.i.i154 = xor i64 %shifted.i.i.i25.i.i153, %product.i.i.i24.i.i152
  %hash.i.i.i27.i.i155 = and i64 %xored.i.i.i26.i.i154, %tbl_size.i.i22.i.i150
  %offset_ptr.i.i28.i.i156 = getelementptr i32, ptr %offset_tbl.i.i23.i.i151, i64 %hash.i.i.i27.i.i155
  %offset.i.i43.i.i157 = load i32, ptr %offset_ptr.i.i28.i.i156, align 4, !noalias !458
  %1378 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1369, 0
  %1379 = insertvalue { ptr, ptr, ptr, i32 } %1378, ptr %1376, 1
  %1380 = insertvalue { ptr, ptr, ptr, i32 } %1379, ptr %1377, 2
  %1381 = insertvalue { ptr, ptr, ptr, i32 } %1380, i32 %offset.i.i43.i.i157, 3
  %1382 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %1383 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %1107, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %1381) #7
  br label %._crit_edge.i873.i

._crit_edge.i873.i:                               ; preds = %1372, %.lr.ph.i.i142
  %1384 = add nuw nsw i32 %.060.i.i143, 1
  %1385 = icmp slt i32 %1384, %1355
  br i1 %1385, label %.lr.ph.i.i142, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145: ; preds = %._crit_edge.i873.i
  %1386 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1387

1387:                                             ; preds = %._crit_edge.i892.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145
  %.060.i890.i = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145 ], [ %1406, %._crit_edge.i892.i ]
  %1388 = zext nneg i32 %.060.i890.i to i64
  %1389 = shl nuw nsw i64 %1388, 5
  %1390 = getelementptr i8, ptr %1360, i64 %1389
  %1391 = load ptr, ptr %1390, align 8
  %1392 = icmp ne ptr %1391, @nil_typ
  %1393 = icmp ne ptr %1391, null
  %.not16.i891.i = and i1 %1392, %1393
  br i1 %.not16.i891.i, label %1394, label %._crit_edge.i892.i

1394:                                             ; preds = %1387
  %1395 = getelementptr i8, ptr %1390, i64 8
  %1396 = load i64, ptr %1395, align 4
  %.sroa_idx.i893.i = getelementptr i8, ptr %1390, i64 16
  %1397 = load i64, ptr %.sroa_idx.i893.i, align 4
  %1398 = inttoptr i64 %1396 to ptr
  %1399 = inttoptr i64 %1397 to ptr
  %hash_coef_ptr.i.i18.i894.i = getelementptr i8, ptr %1391, i64 8
  %tbl_size_ptr.i.i19.i895.i = getelementptr i8, ptr %1391, i64 16
  %offset_tbl_ptr.i.i20.i896.i = getelementptr i8, ptr %1391, i64 40
  %hash_coef.i.i21.i897.i = load i64, ptr %hash_coef_ptr.i.i18.i894.i, align 4, !noalias !22
  %tbl_size.i.i22.i898.i = load i64, ptr %tbl_size_ptr.i.i19.i895.i, align 4, !noalias !22
  %offset_tbl.i.i23.i899.i = load ptr, ptr %offset_tbl_ptr.i.i20.i896.i, align 8, !noalias !22
  %product.i.i.i24.i900.i = mul i64 %hash_coef.i.i21.i897.i, 4015701072841558310
  %shifted.i.i.i25.i901.i = lshr i64 %product.i.i.i24.i900.i, 32
  %xored.i.i.i26.i902.i = xor i64 %shifted.i.i.i25.i901.i, %product.i.i.i24.i900.i
  %hash.i.i.i27.i903.i = and i64 %xored.i.i.i26.i902.i, %tbl_size.i.i22.i898.i
  %offset_ptr.i.i28.i904.i = getelementptr i32, ptr %offset_tbl.i.i23.i899.i, i64 %hash.i.i.i27.i903.i
  %offset.i.i43.i905.i = load i32, ptr %offset_ptr.i.i28.i904.i, align 4, !noalias !461
  %1400 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1391, 0
  %1401 = insertvalue { ptr, ptr, ptr, i32 } %1400, ptr %1398, 1
  %1402 = insertvalue { ptr, ptr, ptr, i32 } %1401, ptr %1399, 2
  %1403 = insertvalue { ptr, ptr, ptr, i32 } %1402, i32 %offset.i.i43.i905.i, 3
  %1404 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  %1405 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %1107, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %1403) #7
  br label %._crit_edge.i892.i

._crit_edge.i892.i:                               ; preds = %1394, %1387
  %1406 = add nuw nsw i32 %.060.i890.i, 1
  %1407 = icmp slt i32 %1406, %1355
  br i1 %1407, label %1387, label %._crit_edge.i.i42

._crit_edge.i.i42:                                ; preds = %._crit_edge.i892.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.thread.i41, %1352
  %1408 = load ptr, ptr %1111, align 8
  %1409 = getelementptr i8, ptr %1408, i64 72
  %1410 = load ptr, ptr %1409, align 8
  %result.i.i.i.i43 = call { i64, i64 } %1410(ptr nocapture nofree nonnull readonly %1111) #5
  %1411 = extractvalue { i64, i64 } %result.i.i.i.i43, 0
  %1412 = extractvalue { i64, i64 } %result.i.i.i.i43, 1
  %1413 = urem i64 20, %1412
  %1414 = icmp eq i64 %1413, 0
  %1415 = sub i64 %1412, %1413
  %1416 = select i1 %1414, i64 0, i64 %1415
  %1417 = add i64 %1411, 20
  %1418 = add i64 %1417, %1416
  %1419 = load ptr, ptr %1118, align 8
  %1420 = getelementptr i8, ptr %1419, i64 72
  %1421 = load ptr, ptr %1420, align 8
  %result.i1.i.i.i44 = call { i64, i64 } %1421(ptr nocapture nofree nonnull readonly %1118) #5
  %1422 = extractvalue { i64, i64 } %result.i1.i.i.i44, 0
  %1423 = extractvalue { i64, i64 } %result.i1.i.i.i44, 1
  %1424 = call i64 @llvm.umax.i64(i64 %1412, i64 %1423)
  %1425 = call i64 @llvm.umax.i64(i64 %1424, i64 8)
  %1426 = urem i64 %1418, %1423
  %1427 = icmp eq i64 %1426, 0
  %1428 = sub i64 %1423, %1426
  %1429 = select i1 %1427, i64 0, i64 %1428
  %1430 = add i64 %1422, %1418
  %1431 = add i64 %1430, %1429
  %1432 = urem i64 %1431, %1425
  %1433 = icmp eq i64 %1432, 0
  %1434 = sub i64 %1425, %1432
  %1435 = select i1 %1433, i64 0, i64 %1434
  %1436 = add i64 %1435, %1431
  %result.i83.i.i45 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1436, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1111, ptr %result.i83.i.i45, align 8
  %1437 = getelementptr inbounds i8, ptr %result.i83.i.i45, i64 8
  store ptr %1118, ptr %1437, align 8
  %1438 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i.i45)
  %1439 = load ptr, ptr %1111, align 8
  %1440 = getelementptr i8, ptr %1439, i64 72
  %1441 = load ptr, ptr %1440, align 8
  %result.i.i179.i.i46 = call { i64, i64 } %1441(ptr nocapture nofree nonnull readonly %1111) #5
  %1442 = extractvalue { i64, i64 } %result.i.i179.i.i46, 1
  %1443 = urem i64 20, %1442
  %1444 = icmp eq i64 %1443, 0
  %reass.sub311 = sub i64 %1442, %1443
  %1445 = add i64 %reass.sub311, 20
  %1446 = select i1 %1444, i64 20, i64 %1445
  %1447 = getelementptr i8, ptr %result.i83.i.i45, i64 %1446
  %1448 = getelementptr i8, ptr %1439, i64 64
  %1449 = load ptr, ptr %1448, align 8
  call void %1449({ ptr, i160 } %1109, ptr nocapture nofree nonnull readonly %1111, ptr nocapture nofree writeonly %1447) #12
  %1450 = load ptr, ptr %result.i83.i.i45, align 8
  %1451 = load ptr, ptr %1450, align 8
  %1452 = getelementptr i8, ptr %1451, i64 72
  %1453 = load ptr, ptr %1452, align 8
  %result.i.i180.i.i48 = call { i64, i64 } %1453(ptr nocapture nofree nonnull readonly %1450) #5
  %1454 = extractvalue { i64, i64 } %result.i.i180.i.i48, 0
  %1455 = extractvalue { i64, i64 } %result.i.i180.i.i48, 1
  %1456 = urem i64 20, %1455
  %1457 = icmp eq i64 %1456, 0
  %1458 = sub i64 %1455, %1456
  %1459 = select i1 %1457, i64 0, i64 %1458
  %1460 = add i64 %1454, 20
  %1461 = add i64 %1460, %1459
  %1462 = load ptr, ptr %1437, align 8
  %1463 = load ptr, ptr %1462, align 8
  %1464 = getelementptr i8, ptr %1463, i64 72
  %1465 = load ptr, ptr %1464, align 8
  %result.i1.i181.i.i49 = call { i64, i64 } %1465(ptr nocapture nofree nonnull readonly %1462) #5
  %1466 = extractvalue { i64, i64 } %result.i1.i181.i.i49, 1
  %1467 = urem i64 %1461, %1466
  %1468 = icmp eq i64 %1467, 0
  %1469 = sub i64 %1466, %1467
  %1470 = select i1 %1468, i64 0, i64 %1469
  %1471 = getelementptr i8, ptr %result.i83.i.i45, i64 %1461
  %1472 = getelementptr i8, ptr %1471, i64 %1470
  %1473 = getelementptr i8, ptr %1463, i64 64
  %1474 = load ptr, ptr %1473, align 8
  call void %1474({ ptr, i160 } %1110, ptr nocapture nofree nonnull readonly %1462, ptr nocapture nofree writeonly %1472) #12
  %1475 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %1476 = getelementptr inbounds i8, ptr %result.i83.i.i45, i64 16
  store i32 %1113, ptr %1476, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %1477 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1478 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1479 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1480

1480:                                             ; preds = %.cont.cont.i.i109, %._crit_edge.i.i42
  %.0566.i.i50 = phi i32 [ 0, %._crit_edge.i.i42 ], [ %1481, %.cont.cont.i.i109 ]
  %.070565.i.i51 = phi i1 [ true, %._crit_edge.i.i42 ], [ %1547, %.cont.cont.i.i109 ]
  %.sroa.0.0564.i.i52 = phi ptr [ @Entry, %._crit_edge.i.i42 ], [ %vptr.i142.sroa.speculated.i.i112, %.cont.cont.i.i109 ]
  %.sroa.6.0563.i.i53 = phi ptr [ %result.i83.i.i45, %._crit_edge.i.i42 ], [ %spec.select539.i.i113, %.cont.cont.i.i109 ]
  %.sroa.12.0562.i.i54 = phi ptr [ undef, %._crit_edge.i.i42 ], [ %spec.select.i554.i, %.cont.cont.i.i109 ]
  %.sroa.17.0561.i.i55 = phi i32 [ 10, %._crit_edge.i.i42 ], [ %offset.i.i154.i.i125, %.cont.cont.i.i109 ]
  %1481 = add nuw nsw i32 %.0566.i.i50, 1
  %1482 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i.i52, 0
  %1483 = insertvalue { ptr, ptr, ptr, i32 } %1482, ptr %.sroa.6.0563.i.i53, 1
  %1484 = insertvalue { ptr, ptr, ptr, i32 } %1483, ptr %.sroa.12.0562.i.i54, 2
  %1485 = insertvalue { ptr, ptr, ptr, i32 } %1484, i32 %.sroa.17.0561.i.i55, 3
  %1486 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i.i52)
  %1487 = sext i32 %.sroa.17.0561.i.i55 to i64
  %1488 = getelementptr ptr, ptr %.sroa.0.0564.i.i52, i64 %1487
  %1489 = getelementptr i8, ptr %1488, i64 64
  %1490 = load ptr, ptr %1489, align 8
  %result.i125.i.i56 = call ptr %1490({ ptr, ptr, ptr, i32 } %1485, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1491 = call i32 %result.i125.i.i56({ ptr, ptr, ptr, i32 } %1485, { ptr, ptr, ptr, i32 } %1485, ptr nonnull align 8 %0) #7
  %1492 = ptrtoint ptr %.sroa.6.0563.i.i53 to i64
  %1493 = ptrtoint ptr %.sroa.12.0562.i.i54 to i64
  br i1 %.070565.i.i51, label %1494, label %1510

1494:                                             ; preds = %1480
  %1495 = load i32, ptr %1101, align 8
  %1496 = add i32 %1495, -1
  %1497 = and i32 %1496, %1491
  %1498 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1499 = load ptr, ptr %1102, align 8
  %1500 = sext i32 %1497 to i64
  %1501 = shl nsw i64 %1500, 5
  %1502 = getelementptr i8, ptr %1499, i64 %1501
  %1503 = load ptr, ptr %1502, align 8
  %1504 = getelementptr i8, ptr %1502, i64 8
  %1505 = load i160, ptr %1504, align 4
  store ptr %.sroa.0.0564.i.i52, ptr %1502, align 8
  store i64 %1492, ptr %1504, align 4
  %.sroa_idx157.i.i136 = getelementptr i8, ptr %1502, i64 16
  store i64 %1493, ptr %.sroa_idx157.i.i136, align 4
  %.sroa_idx158.i.i137 = getelementptr i8, ptr %1502, i64 24
  store i32 %.sroa.17.0561.i.i55, ptr %.sroa_idx158.i.i137, align 4
  %1506 = icmp ne ptr %1503, @nil_typ
  %1507 = icmp ne ptr %1503, null
  %.not92.i.i138 = and i1 %1506, %1507
  %extract.i.i140 = lshr i160 %1505, 64
  %1508 = insertelement <2 x i160> poison, i160 %1505, i64 0
  %1509 = insertelement <2 x i160> %1508, i160 %extract.i.i140, i64 1
  br i1 %.not92.i.i138, label %.cont.cont.i.i109, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i63

1510:                                             ; preds = %1480
  %1511 = add i32 %1491, 2127912214
  %1512 = shl i32 %1491, 12
  %1513 = add i32 %1511, %1512
  %1514 = ashr i32 %1513, 19
  %1515 = xor i32 %1513, %1514
  %1516 = xor i32 %1515, -949894596
  %1517 = add i32 %1516, 374761393
  %1518 = shl i32 %1516, 5
  %1519 = add i32 %1517, %1518
  %1520 = add i32 %1519, -744332180
  %1521 = shl i32 %1519, 9
  %1522 = xor i32 %1520, %1521
  %1523 = add i32 %1522, -42973499
  %1524 = shl i32 %1522, 3
  %1525 = add i32 %1523, %1524
  %1526 = ashr i32 %1525, 16
  %1527 = xor i32 %1525, %1526
  %1528 = xor i32 %1527, -1252372727
  %1529 = load i32, ptr %1101, align 8
  %1530 = add i32 %1529, -1
  %1531 = and i32 %1530, %1528
  %1532 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1533 = load ptr, ptr %1103, align 8
  %1534 = sext i32 %1531 to i64
  %1535 = shl nsw i64 %1534, 5
  %1536 = getelementptr i8, ptr %1533, i64 %1535
  %1537 = load ptr, ptr %1536, align 8
  %1538 = getelementptr i8, ptr %1536, i64 8
  %1539 = load i160, ptr %1538, align 4
  store ptr %.sroa.0.0564.i.i52, ptr %1536, align 8
  store i64 %1492, ptr %1538, align 4
  %.sroa_idx161.i.i57 = getelementptr i8, ptr %1536, i64 16
  store i64 %1493, ptr %.sroa_idx161.i.i57, align 4
  %.sroa_idx162.i.i58 = getelementptr i8, ptr %1536, i64 24
  store i32 %.sroa.17.0561.i.i55, ptr %.sroa_idx162.i.i58, align 4
  %1540 = icmp ne ptr %1537, @nil_typ
  %1541 = icmp ne ptr %1537, null
  %.not90.i.i59 = and i1 %1540, %1541
  %extract607.i.i61 = lshr i160 %1539, 64
  %1542 = insertelement <2 x i160> poison, i160 %1539, i64 0
  %1543 = insertelement <2 x i160> %1542, i160 %extract607.i.i61, i64 1
  br i1 %.not90.i.i59, label %.cont.cont.i.i109, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i63

.cont.cont.i.i109:                                ; preds = %1510, %1494
  %vptr.i142.sroa.speculated.i.i112 = phi ptr [ %1503, %1494 ], [ %1537, %1510 ]
  %.in318 = phi <2 x i160> [ %1509, %1494 ], [ %1543, %1510 ]
  %1544 = trunc <2 x i160> %.in318 to <2 x i64>
  %1545 = extractelement <2 x i64> %1544, i64 1
  %spec.select.i554.i = inttoptr i64 %1545 to ptr
  %1546 = extractelement <2 x i64> %1544, i64 0
  %spec.select539.i.i113 = inttoptr i64 %1546 to ptr
  %1547 = xor i1 %.070565.i.i51, true
  %hash_coef_ptr.i.i143.i.i114 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i112, i64 8
  %tbl_size_ptr.i.i144.i.i115 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i112, i64 16
  %offset_tbl_ptr.i.i145.i.i116 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i112, i64 40
  %hash_coef.i.i146.i.i117 = load i64, ptr %hash_coef_ptr.i.i143.i.i114, align 4
  %tbl_size.i.i147.i.i118 = load i64, ptr %tbl_size_ptr.i.i144.i.i115, align 4
  %offset_tbl.i.i148.i.i119 = load ptr, ptr %offset_tbl_ptr.i.i145.i.i116, align 8
  %product.i.i.i149.i.i120 = mul i64 %hash_coef.i.i146.i.i117, 4015701072841558310
  %shifted.i.i.i150.i.i121 = lshr i64 %product.i.i.i149.i.i120, 32
  %xored.i.i.i151.i.i122 = xor i64 %shifted.i.i.i150.i.i121, %product.i.i.i149.i.i120
  %hash.i.i.i152.i.i123 = and i64 %xored.i.i.i151.i.i122, %tbl_size.i.i147.i.i118
  %offset_ptr.i.i153.i.i124 = getelementptr i32, ptr %offset_tbl.i.i148.i.i119, i64 %hash.i.i.i152.i.i123
  %offset.i.i154.i.i125 = load i32, ptr %offset_ptr.i.i153.i.i124, align 4
  %1548 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1550 = icmp ult i32 %.0566.i.i50, 99
  br i1 %1550, label %1480, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i126

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i63: ; preds = %1510, %1494
  %1551 = phi ptr [ %12, %1510 ], [ %11, %1494 ]
  %1552 = load i32, ptr %1104, align 4
  store i32 %1552, ptr %1551, align 4
  %1553 = add i32 %1552, 1
  %1554 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1553, ptr %1104, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %HashMap_insert_keyK_valueV.exit.i64

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i126: ; preds = %.cont.cont.i.i109
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  %1555 = icmp eq ptr %vptr.i142.sroa.speculated.i.i112, null
  br i1 %1555, label %HashMap_insert_keyK_valueV.exit.i64, label %1556

1556:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i126
  %1557 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1558 = load ptr, ptr %1102, align 8
  %1559 = load ptr, ptr %1103, align 8
  %1560 = load i32, ptr %1101, align 8
  %1561 = shl i32 %1560, 1
  %spec.select.i571.i = call i32 @llvm.smax.i32(i32 %1561, i32 16)
  store i32 %spec.select.i571.i, ptr %1101, align 8
  %1562 = zext nneg i32 %spec.select.i571.i to i64
  %1563 = shl nuw nsw i64 %1562, 5
  %result.i.i572.i = call noalias ptr @bump_malloc_inner(i64 noundef %1563, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i572.i, ptr %1102, align 8
  %result.i20.i573.i = call noalias ptr @bump_malloc_inner(i64 noundef %1563, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i573.i, ptr %1103, align 8
  store i32 0, ptr %1104, align 4
  %1564 = icmp sgt i32 %1560, 0
  br i1 %1564, label %.lr.ph.i939.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i

.lr.ph.i939.i:                                    ; preds = %1556, %._crit_edge.i954.i
  %.060.i952.i = phi i32 [ %1653, %._crit_edge.i954.i ], [ 0, %1556 ]
  %1565 = zext nneg i32 %.060.i952.i to i64
  %1566 = shl nuw nsw i64 %1565, 5
  %1567 = getelementptr i8, ptr %1558, i64 %1566
  %1568 = load ptr, ptr %1567, align 8
  %1569 = icmp ne ptr %1568, @nil_typ
  %1570 = icmp ne ptr %1568, null
  %.not16.i953.i = and i1 %1569, %1570
  br i1 %.not16.i953.i, label %1571, label %._crit_edge.i954.i

1571:                                             ; preds = %.lr.ph.i939.i
  %1572 = getelementptr i8, ptr %1567, i64 8
  %1573 = load <2 x i64>, ptr %1572, align 4
  %hash_coef_ptr.i.i18.i956.i = getelementptr i8, ptr %1568, i64 8
  %tbl_size_ptr.i.i19.i957.i = getelementptr i8, ptr %1568, i64 16
  %offset_tbl_ptr.i.i20.i958.i = getelementptr i8, ptr %1568, i64 40
  %1574 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i.i127 = load i64, ptr %hash_coef_ptr.i.i18.i956.i, align 4, !noalias !22
  %tbl_size.i.i100.i.i128 = load i64, ptr %tbl_size_ptr.i.i19.i957.i, align 4, !noalias !22
  %offset_tbl.i.i101.i.i129 = load ptr, ptr %offset_tbl_ptr.i.i20.i958.i, align 8, !noalias !22
  %product.i.i.i102.i.i130 = mul i64 %hash_coef.i.i99.i.i127, 4015701072841558310
  %shifted.i.i.i103.i.i131 = lshr i64 %product.i.i.i102.i.i130, 32
  %xored.i.i.i104.i.i132 = xor i64 %shifted.i.i.i103.i.i131, %product.i.i.i102.i.i130
  %hash.i.i.i105.i.i133 = and i64 %xored.i.i.i104.i.i132, %tbl_size.i.i100.i.i128
  %offset_ptr.i.i106.i.i134 = getelementptr i32, ptr %offset_tbl.i.i101.i.i129, i64 %hash.i.i.i105.i.i133
  %offset.i.i121.i.i135 = load i32, ptr %offset_ptr.i.i106.i.i134, align 4, !noalias !464
  %1575 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1576 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1577 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1578

1578:                                             ; preds = %.cont.cont.i1132.i, %1571
  %.0566.i1119.i = phi i32 [ 0, %1571 ], [ %1582, %.cont.cont.i1132.i ]
  %.070565.i1120.i = phi i1 [ true, %1571 ], [ %1644, %.cont.cont.i1132.i ]
  %.sroa.0.0564.i1121.i = phi ptr [ %1568, %1571 ], [ %vptr.i142.sroa.speculated.i1135.i, %.cont.cont.i1132.i ]
  %.sroa.17.0561.i1124.i = phi i32 [ %offset.i.i121.i.i135, %1571 ], [ %offset.i.i154.i1149.i, %.cont.cont.i1132.i ]
  %1579 = phi <2 x i64> [ %1573, %1571 ], [ %1643, %.cont.cont.i1132.i ]
  %1580 = extractelement <2 x i64> %1579, i64 1
  %.sroa.12.0562.i1123.i = inttoptr i64 %1580 to ptr
  %1581 = extractelement <2 x i64> %1579, i64 0
  %.sroa.6.0563.i1122.i = inttoptr i64 %1581 to ptr
  %1582 = add nuw nsw i32 %.0566.i1119.i, 1
  %1583 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1121.i, 0
  %1584 = insertvalue { ptr, ptr, ptr, i32 } %1583, ptr %.sroa.6.0563.i1122.i, 1
  %1585 = insertvalue { ptr, ptr, ptr, i32 } %1584, ptr %.sroa.12.0562.i1123.i, 2
  %1586 = insertvalue { ptr, ptr, ptr, i32 } %1585, i32 %.sroa.17.0561.i1124.i, 3
  %1587 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1121.i)
  %1588 = sext i32 %.sroa.17.0561.i1124.i to i64
  %1589 = getelementptr ptr, ptr %.sroa.0.0564.i1121.i, i64 %1588
  %1590 = getelementptr i8, ptr %1589, i64 64
  %1591 = load ptr, ptr %1590, align 8
  %result.i125.i1125.i = call ptr %1591({ ptr, ptr, ptr, i32 } %1586, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1592 = call i32 %result.i125.i1125.i({ ptr, ptr, ptr, i32 } %1586, { ptr, ptr, ptr, i32 } %1586, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1120.i, label %1593, label %1609

1593:                                             ; preds = %1578
  %1594 = load i32, ptr %1101, align 8
  %1595 = add i32 %1594, -1
  %1596 = and i32 %1595, %1592
  %1597 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1598 = load ptr, ptr %1102, align 8
  %1599 = sext i32 %1596 to i64
  %1600 = shl nsw i64 %1599, 5
  %1601 = getelementptr i8, ptr %1598, i64 %1600
  %1602 = load ptr, ptr %1601, align 8
  %1603 = getelementptr i8, ptr %1601, i64 8
  %1604 = load i160, ptr %1603, align 4
  store ptr %.sroa.0.0564.i1121.i, ptr %1601, align 8
  store i64 %1581, ptr %1603, align 4
  %.sroa_idx157.i1151.i = getelementptr i8, ptr %1601, i64 16
  store i64 %1580, ptr %.sroa_idx157.i1151.i, align 4
  %.sroa_idx158.i1152.i = getelementptr i8, ptr %1601, i64 24
  store i32 %.sroa.17.0561.i1124.i, ptr %.sroa_idx158.i1152.i, align 4
  %1605 = icmp ne ptr %1602, @nil_typ
  %1606 = icmp ne ptr %1602, null
  %.not92.i1153.i = and i1 %1605, %1606
  %extract.i1155.i = lshr i160 %1604, 64
  %1607 = insertelement <2 x i160> poison, i160 %1604, i64 0
  %1608 = insertelement <2 x i160> %1607, i160 %extract.i1155.i, i64 1
  br i1 %.not92.i1153.i, label %.cont.cont.i1132.i, label %1648

1609:                                             ; preds = %1578
  %1610 = add i32 %1592, 2127912214
  %1611 = shl i32 %1592, 12
  %1612 = add i32 %1610, %1611
  %1613 = ashr i32 %1612, 19
  %1614 = xor i32 %1612, %1613
  %1615 = xor i32 %1614, -949894596
  %1616 = add i32 %1615, 374761393
  %1617 = shl i32 %1615, 5
  %1618 = add i32 %1616, %1617
  %1619 = add i32 %1618, -744332180
  %1620 = shl i32 %1618, 9
  %1621 = xor i32 %1619, %1620
  %1622 = add i32 %1621, -42973499
  %1623 = shl i32 %1621, 3
  %1624 = add i32 %1622, %1623
  %1625 = ashr i32 %1624, 16
  %1626 = xor i32 %1624, %1625
  %1627 = xor i32 %1626, -1252372727
  %1628 = load i32, ptr %1101, align 8
  %1629 = add i32 %1628, -1
  %1630 = and i32 %1629, %1627
  %1631 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1632 = load ptr, ptr %1103, align 8
  %1633 = sext i32 %1630 to i64
  %1634 = shl nsw i64 %1633, 5
  %1635 = getelementptr i8, ptr %1632, i64 %1634
  %1636 = load ptr, ptr %1635, align 8
  %1637 = getelementptr i8, ptr %1635, i64 8
  %1638 = load i160, ptr %1637, align 4
  store ptr %.sroa.0.0564.i1121.i, ptr %1635, align 8
  store i64 %1581, ptr %1637, align 4
  %.sroa_idx161.i1126.i = getelementptr i8, ptr %1635, i64 16
  store i64 %1580, ptr %.sroa_idx161.i1126.i, align 4
  %.sroa_idx162.i1127.i = getelementptr i8, ptr %1635, i64 24
  store i32 %.sroa.17.0561.i1124.i, ptr %.sroa_idx162.i1127.i, align 4
  %1639 = icmp ne ptr %1636, @nil_typ
  %1640 = icmp ne ptr %1636, null
  %.not90.i1128.i = and i1 %1639, %1640
  %extract607.i1130.i = lshr i160 %1638, 64
  %1641 = insertelement <2 x i160> poison, i160 %1638, i64 0
  %1642 = insertelement <2 x i160> %1641, i160 %extract607.i1130.i, i64 1
  br i1 %.not90.i1128.i, label %.cont.cont.i1132.i, label %1648

.cont.cont.i1132.i:                               ; preds = %1609, %1593
  %vptr.i142.sroa.speculated.i1135.i = phi ptr [ %1602, %1593 ], [ %1636, %1609 ]
  %.in319 = phi <2 x i160> [ %1608, %1593 ], [ %1642, %1609 ]
  %1643 = trunc <2 x i160> %.in319 to <2 x i64>
  %1644 = xor i1 %.070565.i1120.i, true
  %hash_coef_ptr.i.i143.i1138.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1135.i, i64 8
  %tbl_size_ptr.i.i144.i1139.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1135.i, i64 16
  %offset_tbl_ptr.i.i145.i1140.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1135.i, i64 40
  %hash_coef.i.i146.i1141.i = load i64, ptr %hash_coef_ptr.i.i143.i1138.i, align 4
  %tbl_size.i.i147.i1142.i = load i64, ptr %tbl_size_ptr.i.i144.i1139.i, align 4
  %offset_tbl.i.i148.i1143.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1140.i, align 8
  %product.i.i.i149.i1144.i = mul i64 %hash_coef.i.i146.i1141.i, 4015701072841558310
  %shifted.i.i.i150.i1145.i = lshr i64 %product.i.i.i149.i1144.i, 32
  %xored.i.i.i151.i1146.i = xor i64 %shifted.i.i.i150.i1145.i, %product.i.i.i149.i1144.i
  %hash.i.i.i152.i1147.i = and i64 %xored.i.i.i151.i1146.i, %tbl_size.i.i147.i1142.i
  %offset_ptr.i.i153.i1148.i = getelementptr i32, ptr %offset_tbl.i.i148.i1143.i, i64 %hash.i.i.i152.i1147.i
  %offset.i.i154.i1149.i = load i32, ptr %offset_ptr.i.i153.i1148.i, align 4
  %1645 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1646 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1647 = icmp ult i32 %.0566.i1119.i, 99
  br i1 %1647, label %1578, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1157.i

1648:                                             ; preds = %1609, %1593
  %1649 = phi ptr [ %8, %1609 ], [ %7, %1593 ]
  %1650 = load i32, ptr %1104, align 4
  store i32 %1650, ptr %1649, align 4
  %1651 = add i32 %1650, 1
  %1652 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1651, ptr %1104, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1157.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1157.i: ; preds = %.cont.cont.i1132.i, %1648
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i954.i

._crit_edge.i954.i:                               ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1157.i, %.lr.ph.i939.i
  %1653 = add nuw nsw i32 %.060.i952.i, 1
  %1654 = icmp slt i32 %1653, %1560
  br i1 %1654, label %.lr.ph.i939.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972.i: ; preds = %._crit_edge.i954.i, %._crit_edge.i990.i
  %.060.i988.i = phi i32 [ %1743, %._crit_edge.i990.i ], [ 0, %._crit_edge.i954.i ]
  %1655 = zext nneg i32 %.060.i988.i to i64
  %1656 = shl nuw nsw i64 %1655, 5
  %1657 = getelementptr i8, ptr %1559, i64 %1656
  %1658 = load ptr, ptr %1657, align 8
  %1659 = icmp ne ptr %1658, @nil_typ
  %1660 = icmp ne ptr %1658, null
  %.not16.i989.i = and i1 %1659, %1660
  br i1 %.not16.i989.i, label %1661, label %._crit_edge.i990.i

1661:                                             ; preds = %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972.i
  %1662 = getelementptr i8, ptr %1657, i64 8
  %1663 = load <2 x i64>, ptr %1662, align 4
  %hash_coef_ptr.i.i18.i992.i = getelementptr i8, ptr %1658, i64 8
  %tbl_size_ptr.i.i19.i993.i = getelementptr i8, ptr %1658, i64 16
  %offset_tbl_ptr.i.i20.i994.i = getelementptr i8, ptr %1658, i64 40
  %1664 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i1175.i = load i64, ptr %hash_coef_ptr.i.i18.i992.i, align 4, !noalias !22
  %tbl_size.i.i100.i1176.i = load i64, ptr %tbl_size_ptr.i.i19.i993.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1177.i = load ptr, ptr %offset_tbl_ptr.i.i20.i994.i, align 8, !noalias !22
  %product.i.i.i102.i1178.i = mul i64 %hash_coef.i.i99.i1175.i, 4015701072841558310
  %shifted.i.i.i103.i1179.i = lshr i64 %product.i.i.i102.i1178.i, 32
  %xored.i.i.i104.i1180.i = xor i64 %shifted.i.i.i103.i1179.i, %product.i.i.i102.i1178.i
  %hash.i.i.i105.i1181.i = and i64 %xored.i.i.i104.i1180.i, %tbl_size.i.i100.i1176.i
  %offset_ptr.i.i106.i1182.i = getelementptr i32, ptr %offset_tbl.i.i101.i1177.i, i64 %hash.i.i.i105.i1181.i
  %offset.i.i121.i1183.i = load i32, ptr %offset_ptr.i.i106.i1182.i, align 4, !noalias !467
  %1665 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1666 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1667 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1668

1668:                                             ; preds = %.cont.cont.i1204.i, %1661
  %.0566.i1184.i = phi i32 [ 0, %1661 ], [ %1672, %.cont.cont.i1204.i ]
  %.070565.i1185.i = phi i1 [ true, %1661 ], [ %1734, %.cont.cont.i1204.i ]
  %.sroa.0.0564.i1186.i = phi ptr [ %1658, %1661 ], [ %vptr.i142.sroa.speculated.i1207.i, %.cont.cont.i1204.i ]
  %.sroa.17.0561.i1189.i = phi i32 [ %offset.i.i121.i1183.i, %1661 ], [ %offset.i.i154.i1221.i, %.cont.cont.i1204.i ]
  %1669 = phi <2 x i64> [ %1663, %1661 ], [ %1733, %.cont.cont.i1204.i ]
  %1670 = extractelement <2 x i64> %1669, i64 1
  %.sroa.12.0562.i1188.i = inttoptr i64 %1670 to ptr
  %1671 = extractelement <2 x i64> %1669, i64 0
  %.sroa.6.0563.i1187.i = inttoptr i64 %1671 to ptr
  %1672 = add nuw nsw i32 %.0566.i1184.i, 1
  %1673 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1186.i, 0
  %1674 = insertvalue { ptr, ptr, ptr, i32 } %1673, ptr %.sroa.6.0563.i1187.i, 1
  %1675 = insertvalue { ptr, ptr, ptr, i32 } %1674, ptr %.sroa.12.0562.i1188.i, 2
  %1676 = insertvalue { ptr, ptr, ptr, i32 } %1675, i32 %.sroa.17.0561.i1189.i, 3
  %1677 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1186.i)
  %1678 = sext i32 %.sroa.17.0561.i1189.i to i64
  %1679 = getelementptr ptr, ptr %.sroa.0.0564.i1186.i, i64 %1678
  %1680 = getelementptr i8, ptr %1679, i64 64
  %1681 = load ptr, ptr %1680, align 8
  %result.i125.i1190.i = call ptr %1681({ ptr, ptr, ptr, i32 } %1676, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1682 = call i32 %result.i125.i1190.i({ ptr, ptr, ptr, i32 } %1676, { ptr, ptr, ptr, i32 } %1676, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1185.i, label %1683, label %1699

1683:                                             ; preds = %1668
  %1684 = load i32, ptr %1101, align 8
  %1685 = add i32 %1684, -1
  %1686 = and i32 %1685, %1682
  %1687 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1688 = load ptr, ptr %1102, align 8
  %1689 = sext i32 %1686 to i64
  %1690 = shl nsw i64 %1689, 5
  %1691 = getelementptr i8, ptr %1688, i64 %1690
  %1692 = load ptr, ptr %1691, align 8
  %1693 = getelementptr i8, ptr %1691, i64 8
  %1694 = load i160, ptr %1693, align 4
  store ptr %.sroa.0.0564.i1186.i, ptr %1691, align 8
  store i64 %1671, ptr %1693, align 4
  %.sroa_idx157.i1233.i = getelementptr i8, ptr %1691, i64 16
  store i64 %1670, ptr %.sroa_idx157.i1233.i, align 4
  %.sroa_idx158.i1234.i = getelementptr i8, ptr %1691, i64 24
  store i32 %.sroa.17.0561.i1189.i, ptr %.sroa_idx158.i1234.i, align 4
  %1695 = icmp ne ptr %1692, @nil_typ
  %1696 = icmp ne ptr %1692, null
  %.not92.i1235.i = and i1 %1695, %1696
  %extract.i1237.i = lshr i160 %1694, 64
  %1697 = insertelement <2 x i160> poison, i160 %1694, i64 0
  %1698 = insertelement <2 x i160> %1697, i160 %extract.i1237.i, i64 1
  br i1 %.not92.i1235.i, label %.cont.cont.i1204.i, label %1738

1699:                                             ; preds = %1668
  %1700 = add i32 %1682, 2127912214
  %1701 = shl i32 %1682, 12
  %1702 = add i32 %1700, %1701
  %1703 = ashr i32 %1702, 19
  %1704 = xor i32 %1702, %1703
  %1705 = xor i32 %1704, -949894596
  %1706 = add i32 %1705, 374761393
  %1707 = shl i32 %1705, 5
  %1708 = add i32 %1706, %1707
  %1709 = add i32 %1708, -744332180
  %1710 = shl i32 %1708, 9
  %1711 = xor i32 %1709, %1710
  %1712 = add i32 %1711, -42973499
  %1713 = shl i32 %1711, 3
  %1714 = add i32 %1712, %1713
  %1715 = ashr i32 %1714, 16
  %1716 = xor i32 %1714, %1715
  %1717 = xor i32 %1716, -1252372727
  %1718 = load i32, ptr %1101, align 8
  %1719 = add i32 %1718, -1
  %1720 = and i32 %1719, %1717
  %1721 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1722 = load ptr, ptr %1103, align 8
  %1723 = sext i32 %1720 to i64
  %1724 = shl nsw i64 %1723, 5
  %1725 = getelementptr i8, ptr %1722, i64 %1724
  %1726 = load ptr, ptr %1725, align 8
  %1727 = getelementptr i8, ptr %1725, i64 8
  %1728 = load i160, ptr %1727, align 4
  store ptr %.sroa.0.0564.i1186.i, ptr %1725, align 8
  store i64 %1671, ptr %1727, align 4
  %.sroa_idx161.i1194.i = getelementptr i8, ptr %1725, i64 16
  store i64 %1670, ptr %.sroa_idx161.i1194.i, align 4
  %.sroa_idx162.i1195.i = getelementptr i8, ptr %1725, i64 24
  store i32 %.sroa.17.0561.i1189.i, ptr %.sroa_idx162.i1195.i, align 4
  %1729 = icmp ne ptr %1726, @nil_typ
  %1730 = icmp ne ptr %1726, null
  %.not90.i1196.i = and i1 %1729, %1730
  %extract607.i1198.i = lshr i160 %1728, 64
  %1731 = insertelement <2 x i160> poison, i160 %1728, i64 0
  %1732 = insertelement <2 x i160> %1731, i160 %extract607.i1198.i, i64 1
  br i1 %.not90.i1196.i, label %.cont.cont.i1204.i, label %1738

.cont.cont.i1204.i:                               ; preds = %1699, %1683
  %vptr.i142.sroa.speculated.i1207.i = phi ptr [ %1692, %1683 ], [ %1726, %1699 ]
  %.in320 = phi <2 x i160> [ %1698, %1683 ], [ %1732, %1699 ]
  %1733 = trunc <2 x i160> %.in320 to <2 x i64>
  %1734 = xor i1 %.070565.i1185.i, true
  %hash_coef_ptr.i.i143.i1210.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1207.i, i64 8
  %tbl_size_ptr.i.i144.i1211.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1207.i, i64 16
  %offset_tbl_ptr.i.i145.i1212.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1207.i, i64 40
  %hash_coef.i.i146.i1213.i = load i64, ptr %hash_coef_ptr.i.i143.i1210.i, align 4
  %tbl_size.i.i147.i1214.i = load i64, ptr %tbl_size_ptr.i.i144.i1211.i, align 4
  %offset_tbl.i.i148.i1215.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1212.i, align 8
  %product.i.i.i149.i1216.i = mul i64 %hash_coef.i.i146.i1213.i, 4015701072841558310
  %shifted.i.i.i150.i1217.i = lshr i64 %product.i.i.i149.i1216.i, 32
  %xored.i.i.i151.i1218.i = xor i64 %shifted.i.i.i150.i1217.i, %product.i.i.i149.i1216.i
  %hash.i.i.i152.i1219.i = and i64 %xored.i.i.i151.i1218.i, %tbl_size.i.i147.i1214.i
  %offset_ptr.i.i153.i1220.i = getelementptr i32, ptr %offset_tbl.i.i148.i1215.i, i64 %hash.i.i.i152.i1219.i
  %offset.i.i154.i1221.i = load i32, ptr %offset_ptr.i.i153.i1220.i, align 4
  %1735 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1736 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1737 = icmp ult i32 %.0566.i1184.i, 99
  br i1 %1737, label %1668, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1239.i

1738:                                             ; preds = %1699, %1683
  %1739 = phi ptr [ %6, %1699 ], [ %5, %1683 ]
  %1740 = load i32, ptr %1104, align 4
  store i32 %1740, ptr %1739, align 4
  %1741 = add i32 %1740, 1
  %1742 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1741, ptr %1104, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1239.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1239.i: ; preds = %.cont.cont.i1204.i, %1738
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i990.i

._crit_edge.i990.i:                               ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1239.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972.i
  %1743 = add nuw nsw i32 %.060.i988.i, 1
  %1744 = icmp slt i32 %1743, %1560
  br i1 %1744, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit972.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i: ; preds = %._crit_edge.i990.i, %1556
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i594.i = load i64, ptr %hash_coef_ptr.i.i143.i.i114, align 4, !noalias !22
  %tbl_size.i.i100.i595.i = load i64, ptr %tbl_size_ptr.i.i144.i.i115, align 4, !noalias !22
  %offset_tbl.i.i101.i596.i = load ptr, ptr %offset_tbl_ptr.i.i145.i.i116, align 8, !noalias !22
  %product.i.i.i102.i597.i = mul i64 %hash_coef.i.i99.i594.i, 4015701072841558310
  %shifted.i.i.i103.i598.i = lshr i64 %product.i.i.i102.i597.i, 32
  %xored.i.i.i104.i599.i = xor i64 %shifted.i.i.i103.i598.i, %product.i.i.i102.i597.i
  %hash.i.i.i105.i600.i = and i64 %xored.i.i.i104.i599.i, %tbl_size.i.i100.i595.i
  %offset_ptr.i.i106.i601.i = getelementptr i32, ptr %offset_tbl.i.i101.i596.i, i64 %hash.i.i.i105.i600.i
  %offset.i.i121.i602.i = load i32, ptr %offset_ptr.i.i106.i601.i, align 4, !noalias !470
  %1746 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1747 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1748 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1749

1749:                                             ; preds = %.cont.cont.i624.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i
  %.0566.i604.i = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i ], [ %1753, %.cont.cont.i624.i ]
  %.070565.i605.i = phi i1 [ true, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i ], [ %1815, %.cont.cont.i624.i ]
  %.sroa.0.0564.i606.i = phi ptr [ %vptr.i142.sroa.speculated.i.i112, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i ], [ %vptr.i142.sroa.speculated.i627.i, %.cont.cont.i624.i ]
  %.sroa.17.0561.i609.i = phi i32 [ %offset.i.i121.i602.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i ], [ %offset.i.i154.i641.i, %.cont.cont.i624.i ]
  %1750 = phi <2 x i64> [ %1544, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1008.i ], [ %1814, %.cont.cont.i624.i ]
  %1751 = extractelement <2 x i64> %1750, i64 1
  %.sroa.12.0562.i608.i = inttoptr i64 %1751 to ptr
  %1752 = extractelement <2 x i64> %1750, i64 0
  %.sroa.6.0563.i607.i = inttoptr i64 %1752 to ptr
  %1753 = add nuw nsw i32 %.0566.i604.i, 1
  %1754 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i606.i, 0
  %1755 = insertvalue { ptr, ptr, ptr, i32 } %1754, ptr %.sroa.6.0563.i607.i, 1
  %1756 = insertvalue { ptr, ptr, ptr, i32 } %1755, ptr %.sroa.12.0562.i608.i, 2
  %1757 = insertvalue { ptr, ptr, ptr, i32 } %1756, i32 %.sroa.17.0561.i609.i, 3
  %1758 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i606.i)
  %1759 = sext i32 %.sroa.17.0561.i609.i to i64
  %1760 = getelementptr ptr, ptr %.sroa.0.0564.i606.i, i64 %1759
  %1761 = getelementptr i8, ptr %1760, i64 64
  %1762 = load ptr, ptr %1761, align 8
  %result.i125.i610.i = call ptr %1762({ ptr, ptr, ptr, i32 } %1757, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1763 = call i32 %result.i125.i610.i({ ptr, ptr, ptr, i32 } %1757, { ptr, ptr, ptr, i32 } %1757, ptr nonnull align 8 %0) #7
  br i1 %.070565.i605.i, label %1764, label %1780

1764:                                             ; preds = %1749
  %1765 = load i32, ptr %1101, align 8
  %1766 = add i32 %1765, -1
  %1767 = and i32 %1766, %1763
  %1768 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1769 = load ptr, ptr %1102, align 8
  %1770 = sext i32 %1767 to i64
  %1771 = shl nsw i64 %1770, 5
  %1772 = getelementptr i8, ptr %1769, i64 %1771
  %1773 = load ptr, ptr %1772, align 8
  %1774 = getelementptr i8, ptr %1772, i64 8
  %1775 = load i160, ptr %1774, align 4
  store ptr %.sroa.0.0564.i606.i, ptr %1772, align 8
  store i64 %1752, ptr %1774, align 4
  %.sroa_idx157.i653.i = getelementptr i8, ptr %1772, i64 16
  store i64 %1751, ptr %.sroa_idx157.i653.i, align 4
  %.sroa_idx158.i654.i = getelementptr i8, ptr %1772, i64 24
  store i32 %.sroa.17.0561.i609.i, ptr %.sroa_idx158.i654.i, align 4
  %1776 = icmp ne ptr %1773, @nil_typ
  %1777 = icmp ne ptr %1773, null
  %.not92.i655.i = and i1 %1776, %1777
  %extract.i657.i = lshr i160 %1775, 64
  %1778 = insertelement <2 x i160> poison, i160 %1775, i64 0
  %1779 = insertelement <2 x i160> %1778, i160 %extract.i657.i, i64 1
  br i1 %.not92.i655.i, label %.cont.cont.i624.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.thread.i

1780:                                             ; preds = %1749
  %1781 = add i32 %1763, 2127912214
  %1782 = shl i32 %1763, 12
  %1783 = add i32 %1781, %1782
  %1784 = ashr i32 %1783, 19
  %1785 = xor i32 %1783, %1784
  %1786 = xor i32 %1785, -949894596
  %1787 = add i32 %1786, 374761393
  %1788 = shl i32 %1786, 5
  %1789 = add i32 %1787, %1788
  %1790 = add i32 %1789, -744332180
  %1791 = shl i32 %1789, 9
  %1792 = xor i32 %1790, %1791
  %1793 = add i32 %1792, -42973499
  %1794 = shl i32 %1792, 3
  %1795 = add i32 %1793, %1794
  %1796 = ashr i32 %1795, 16
  %1797 = xor i32 %1795, %1796
  %1798 = xor i32 %1797, -1252372727
  %1799 = load i32, ptr %1101, align 8
  %1800 = add i32 %1799, -1
  %1801 = and i32 %1800, %1798
  %1802 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1803 = load ptr, ptr %1103, align 8
  %1804 = sext i32 %1801 to i64
  %1805 = shl nsw i64 %1804, 5
  %1806 = getelementptr i8, ptr %1803, i64 %1805
  %1807 = load ptr, ptr %1806, align 8
  %1808 = getelementptr i8, ptr %1806, i64 8
  %1809 = load i160, ptr %1808, align 4
  store ptr %.sroa.0.0564.i606.i, ptr %1806, align 8
  store i64 %1752, ptr %1808, align 4
  %.sroa_idx161.i614.i = getelementptr i8, ptr %1806, i64 16
  store i64 %1751, ptr %.sroa_idx161.i614.i, align 4
  %.sroa_idx162.i615.i = getelementptr i8, ptr %1806, i64 24
  store i32 %.sroa.17.0561.i609.i, ptr %.sroa_idx162.i615.i, align 4
  %1810 = icmp ne ptr %1807, @nil_typ
  %1811 = icmp ne ptr %1807, null
  %.not90.i616.i = and i1 %1810, %1811
  %extract607.i618.i = lshr i160 %1809, 64
  %1812 = insertelement <2 x i160> poison, i160 %1809, i64 0
  %1813 = insertelement <2 x i160> %1812, i160 %extract607.i618.i, i64 1
  br i1 %.not90.i616.i, label %.cont.cont.i624.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.thread.i

.cont.cont.i624.i:                                ; preds = %1780, %1764
  %vptr.i142.sroa.speculated.i627.i = phi ptr [ %1773, %1764 ], [ %1807, %1780 ]
  %.in321 = phi <2 x i160> [ %1779, %1764 ], [ %1813, %1780 ]
  %1814 = trunc <2 x i160> %.in321 to <2 x i64>
  %1815 = xor i1 %.070565.i605.i, true
  %hash_coef_ptr.i.i143.i630.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i627.i, i64 8
  %tbl_size_ptr.i.i144.i631.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i627.i, i64 16
  %offset_tbl_ptr.i.i145.i632.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i627.i, i64 40
  %hash_coef.i.i146.i633.i = load i64, ptr %hash_coef_ptr.i.i143.i630.i, align 4
  %tbl_size.i.i147.i634.i = load i64, ptr %tbl_size_ptr.i.i144.i631.i, align 4
  %offset_tbl.i.i148.i635.i = load ptr, ptr %offset_tbl_ptr.i.i145.i632.i, align 8
  %product.i.i.i149.i636.i = mul i64 %hash_coef.i.i146.i633.i, 4015701072841558310
  %shifted.i.i.i150.i637.i = lshr i64 %product.i.i.i149.i636.i, 32
  %xored.i.i.i151.i638.i = xor i64 %shifted.i.i.i150.i637.i, %product.i.i.i149.i636.i
  %hash.i.i.i152.i639.i = and i64 %xored.i.i.i151.i638.i, %tbl_size.i.i147.i634.i
  %offset_ptr.i.i153.i640.i = getelementptr i32, ptr %offset_tbl.i.i148.i635.i, i64 %hash.i.i.i152.i639.i
  %offset.i.i154.i641.i = load i32, ptr %offset_ptr.i.i153.i640.i, align 4
  %1816 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1817 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1818 = icmp ult i32 %.0566.i604.i, 99
  br i1 %1818, label %1749, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.thread.i: ; preds = %1780, %1764
  %1819 = phi ptr [ %10, %1780 ], [ %9, %1764 ]
  %1820 = load i32, ptr %1104, align 4
  store i32 %1820, ptr %1819, align 4
  %1821 = add i32 %1820, 1
  %1822 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1821, ptr %1104, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %HashMap_insert_keyK_valueV.exit.i64

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.i: ; preds = %.cont.cont.i624.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  %1823 = icmp eq ptr %vptr.i142.sroa.speculated.i627.i, null
  br i1 %1823, label %HashMap_insert_keyK_valueV.exit.i64, label %1824

1824:                                             ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.i
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1826 = load ptr, ptr %1102, align 8
  %1827 = load ptr, ptr %1103, align 8
  %1828 = load i32, ptr %1101, align 8
  %1829 = shl i32 %1828, 1
  %spec.select.i675.i = call i32 @llvm.smax.i32(i32 %1829, i32 16)
  store i32 %spec.select.i675.i, ptr %1101, align 8
  %1830 = zext nneg i32 %spec.select.i675.i to i64
  %1831 = shl nuw nsw i64 %1830, 5
  %result.i.i676.i = call noalias ptr @bump_malloc_inner(i64 noundef %1831, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i676.i, ptr %1102, align 8
  %result.i20.i677.i = call noalias ptr @bump_malloc_inner(i64 noundef %1831, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i20.i677.i, ptr %1103, align 8
  store i32 0, ptr %1104, align 4
  %1832 = icmp sgt i32 %1828, 0
  br i1 %1832, label %.lr.ph.i1038.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.thread.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.thread.i: ; preds = %1824
  %1833 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %HashMap_insert_keyK_valueV.exit.i64

.lr.ph.i1038.i:                                   ; preds = %1824, %._crit_edge.i1053.i
  %.060.i1051.i = phi i32 [ %1922, %._crit_edge.i1053.i ], [ 0, %1824 ]
  %1834 = zext nneg i32 %.060.i1051.i to i64
  %1835 = shl nuw nsw i64 %1834, 5
  %1836 = getelementptr i8, ptr %1826, i64 %1835
  %1837 = load ptr, ptr %1836, align 8
  %1838 = icmp ne ptr %1837, @nil_typ
  %1839 = icmp ne ptr %1837, null
  %.not16.i1052.i = and i1 %1838, %1839
  br i1 %.not16.i1052.i, label %1840, label %._crit_edge.i1053.i

1840:                                             ; preds = %.lr.ph.i1038.i
  %1841 = getelementptr i8, ptr %1836, i64 8
  %1842 = load <2 x i64>, ptr %1841, align 4
  %hash_coef_ptr.i.i18.i1055.i = getelementptr i8, ptr %1837, i64 8
  %tbl_size_ptr.i.i19.i1056.i = getelementptr i8, ptr %1837, i64 16
  %offset_tbl_ptr.i.i20.i1057.i = getelementptr i8, ptr %1837, i64 40
  %1843 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i1257.i = load i64, ptr %hash_coef_ptr.i.i18.i1055.i, align 4, !noalias !22
  %tbl_size.i.i100.i1258.i = load i64, ptr %tbl_size_ptr.i.i19.i1056.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1259.i = load ptr, ptr %offset_tbl_ptr.i.i20.i1057.i, align 8, !noalias !22
  %product.i.i.i102.i1260.i = mul i64 %hash_coef.i.i99.i1257.i, 4015701072841558310
  %shifted.i.i.i103.i1261.i = lshr i64 %product.i.i.i102.i1260.i, 32
  %xored.i.i.i104.i1262.i = xor i64 %shifted.i.i.i103.i1261.i, %product.i.i.i102.i1260.i
  %hash.i.i.i105.i1263.i = and i64 %xored.i.i.i104.i1262.i, %tbl_size.i.i100.i1258.i
  %offset_ptr.i.i106.i1264.i = getelementptr i32, ptr %offset_tbl.i.i101.i1259.i, i64 %hash.i.i.i105.i1263.i
  %offset.i.i121.i1265.i = load i32, ptr %offset_ptr.i.i106.i1264.i, align 4, !noalias !473
  %1844 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1845 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1846 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1847

1847:                                             ; preds = %.cont.cont.i1286.i, %1840
  %.0566.i1266.i = phi i32 [ 0, %1840 ], [ %1851, %.cont.cont.i1286.i ]
  %.070565.i1267.i = phi i1 [ true, %1840 ], [ %1913, %.cont.cont.i1286.i ]
  %.sroa.0.0564.i1268.i = phi ptr [ %1837, %1840 ], [ %vptr.i142.sroa.speculated.i1289.i, %.cont.cont.i1286.i ]
  %.sroa.17.0561.i1271.i = phi i32 [ %offset.i.i121.i1265.i, %1840 ], [ %offset.i.i154.i1303.i, %.cont.cont.i1286.i ]
  %1848 = phi <2 x i64> [ %1842, %1840 ], [ %1912, %.cont.cont.i1286.i ]
  %1849 = extractelement <2 x i64> %1848, i64 1
  %.sroa.12.0562.i1270.i = inttoptr i64 %1849 to ptr
  %1850 = extractelement <2 x i64> %1848, i64 0
  %.sroa.6.0563.i1269.i = inttoptr i64 %1850 to ptr
  %1851 = add nuw nsw i32 %.0566.i1266.i, 1
  %1852 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1268.i, 0
  %1853 = insertvalue { ptr, ptr, ptr, i32 } %1852, ptr %.sroa.6.0563.i1269.i, 1
  %1854 = insertvalue { ptr, ptr, ptr, i32 } %1853, ptr %.sroa.12.0562.i1270.i, 2
  %1855 = insertvalue { ptr, ptr, ptr, i32 } %1854, i32 %.sroa.17.0561.i1271.i, 3
  %1856 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1268.i)
  %1857 = sext i32 %.sroa.17.0561.i1271.i to i64
  %1858 = getelementptr ptr, ptr %.sroa.0.0564.i1268.i, i64 %1857
  %1859 = getelementptr i8, ptr %1858, i64 64
  %1860 = load ptr, ptr %1859, align 8
  %result.i125.i1272.i = call ptr %1860({ ptr, ptr, ptr, i32 } %1855, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1861 = call i32 %result.i125.i1272.i({ ptr, ptr, ptr, i32 } %1855, { ptr, ptr, ptr, i32 } %1855, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1267.i, label %1862, label %1878

1862:                                             ; preds = %1847
  %1863 = load i32, ptr %1101, align 8
  %1864 = add i32 %1863, -1
  %1865 = and i32 %1864, %1861
  %1866 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1867 = load ptr, ptr %1102, align 8
  %1868 = sext i32 %1865 to i64
  %1869 = shl nsw i64 %1868, 5
  %1870 = getelementptr i8, ptr %1867, i64 %1869
  %1871 = load ptr, ptr %1870, align 8
  %1872 = getelementptr i8, ptr %1870, i64 8
  %1873 = load i160, ptr %1872, align 4
  store ptr %.sroa.0.0564.i1268.i, ptr %1870, align 8
  store i64 %1850, ptr %1872, align 4
  %.sroa_idx157.i1315.i = getelementptr i8, ptr %1870, i64 16
  store i64 %1849, ptr %.sroa_idx157.i1315.i, align 4
  %.sroa_idx158.i1316.i = getelementptr i8, ptr %1870, i64 24
  store i32 %.sroa.17.0561.i1271.i, ptr %.sroa_idx158.i1316.i, align 4
  %1874 = icmp ne ptr %1871, @nil_typ
  %1875 = icmp ne ptr %1871, null
  %.not92.i1317.i = and i1 %1874, %1875
  %extract.i1319.i = lshr i160 %1873, 64
  %1876 = insertelement <2 x i160> poison, i160 %1873, i64 0
  %1877 = insertelement <2 x i160> %1876, i160 %extract.i1319.i, i64 1
  br i1 %.not92.i1317.i, label %.cont.cont.i1286.i, label %1917

1878:                                             ; preds = %1847
  %1879 = add i32 %1861, 2127912214
  %1880 = shl i32 %1861, 12
  %1881 = add i32 %1879, %1880
  %1882 = ashr i32 %1881, 19
  %1883 = xor i32 %1881, %1882
  %1884 = xor i32 %1883, -949894596
  %1885 = add i32 %1884, 374761393
  %1886 = shl i32 %1884, 5
  %1887 = add i32 %1885, %1886
  %1888 = add i32 %1887, -744332180
  %1889 = shl i32 %1887, 9
  %1890 = xor i32 %1888, %1889
  %1891 = add i32 %1890, -42973499
  %1892 = shl i32 %1890, 3
  %1893 = add i32 %1891, %1892
  %1894 = ashr i32 %1893, 16
  %1895 = xor i32 %1893, %1894
  %1896 = xor i32 %1895, -1252372727
  %1897 = load i32, ptr %1101, align 8
  %1898 = add i32 %1897, -1
  %1899 = and i32 %1898, %1896
  %1900 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1901 = load ptr, ptr %1103, align 8
  %1902 = sext i32 %1899 to i64
  %1903 = shl nsw i64 %1902, 5
  %1904 = getelementptr i8, ptr %1901, i64 %1903
  %1905 = load ptr, ptr %1904, align 8
  %1906 = getelementptr i8, ptr %1904, i64 8
  %1907 = load i160, ptr %1906, align 4
  store ptr %.sroa.0.0564.i1268.i, ptr %1904, align 8
  store i64 %1850, ptr %1906, align 4
  %.sroa_idx161.i1276.i = getelementptr i8, ptr %1904, i64 16
  store i64 %1849, ptr %.sroa_idx161.i1276.i, align 4
  %.sroa_idx162.i1277.i = getelementptr i8, ptr %1904, i64 24
  store i32 %.sroa.17.0561.i1271.i, ptr %.sroa_idx162.i1277.i, align 4
  %1908 = icmp ne ptr %1905, @nil_typ
  %1909 = icmp ne ptr %1905, null
  %.not90.i1278.i = and i1 %1908, %1909
  %extract607.i1280.i = lshr i160 %1907, 64
  %1910 = insertelement <2 x i160> poison, i160 %1907, i64 0
  %1911 = insertelement <2 x i160> %1910, i160 %extract607.i1280.i, i64 1
  br i1 %.not90.i1278.i, label %.cont.cont.i1286.i, label %1917

.cont.cont.i1286.i:                               ; preds = %1878, %1862
  %vptr.i142.sroa.speculated.i1289.i = phi ptr [ %1871, %1862 ], [ %1905, %1878 ]
  %.in322 = phi <2 x i160> [ %1877, %1862 ], [ %1911, %1878 ]
  %1912 = trunc <2 x i160> %.in322 to <2 x i64>
  %1913 = xor i1 %.070565.i1267.i, true
  %hash_coef_ptr.i.i143.i1292.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1289.i, i64 8
  %tbl_size_ptr.i.i144.i1293.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1289.i, i64 16
  %offset_tbl_ptr.i.i145.i1294.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1289.i, i64 40
  %hash_coef.i.i146.i1295.i = load i64, ptr %hash_coef_ptr.i.i143.i1292.i, align 4
  %tbl_size.i.i147.i1296.i = load i64, ptr %tbl_size_ptr.i.i144.i1293.i, align 4
  %offset_tbl.i.i148.i1297.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1294.i, align 8
  %product.i.i.i149.i1298.i = mul i64 %hash_coef.i.i146.i1295.i, 4015701072841558310
  %shifted.i.i.i150.i1299.i = lshr i64 %product.i.i.i149.i1298.i, 32
  %xored.i.i.i151.i1300.i = xor i64 %shifted.i.i.i150.i1299.i, %product.i.i.i149.i1298.i
  %hash.i.i.i152.i1301.i = and i64 %xored.i.i.i151.i1300.i, %tbl_size.i.i147.i1296.i
  %offset_ptr.i.i153.i1302.i = getelementptr i32, ptr %offset_tbl.i.i148.i1297.i, i64 %hash.i.i.i152.i1301.i
  %offset.i.i154.i1303.i = load i32, ptr %offset_ptr.i.i153.i1302.i, align 4
  %1914 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1915 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1916 = icmp ult i32 %.0566.i1266.i, 99
  br i1 %1916, label %1847, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1321.i

1917:                                             ; preds = %1878, %1862
  %1918 = phi ptr [ %4, %1878 ], [ %3, %1862 ]
  %1919 = load i32, ptr %1104, align 4
  store i32 %1919, ptr %1918, align 4
  %1920 = add i32 %1919, 1
  %1921 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1920, ptr %1104, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1321.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1321.i: ; preds = %.cont.cont.i1286.i, %1917
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i1053.i

._crit_edge.i1053.i:                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1321.i, %.lr.ph.i1038.i
  %1922 = add nuw nsw i32 %.060.i1051.i, 1
  %1923 = icmp slt i32 %1922, %1828
  br i1 %1923, label %.lr.ph.i1038.i, label %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.i

HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.i: ; preds = %._crit_edge.i1053.i
  %1924 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #40
  br label %1925

1925:                                             ; preds = %._crit_edge.i1089.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.i
  %.060.i1087.i = phi i32 [ 0, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.i ], [ %2014, %._crit_edge.i1089.i ]
  %1926 = zext nneg i32 %.060.i1087.i to i64
  %1927 = shl nuw nsw i64 %1926, 5
  %1928 = getelementptr i8, ptr %1827, i64 %1927
  %1929 = load ptr, ptr %1928, align 8
  %1930 = icmp ne ptr %1929, @nil_typ
  %1931 = icmp ne ptr %1929, null
  %.not16.i1088.i = and i1 %1930, %1931
  br i1 %.not16.i1088.i, label %1932, label %._crit_edge.i1089.i

1932:                                             ; preds = %1925
  %1933 = getelementptr i8, ptr %1928, i64 8
  %1934 = load <2 x i64>, ptr %1933, align 4
  %hash_coef_ptr.i.i18.i1091.i = getelementptr i8, ptr %1929, i64 8
  %tbl_size_ptr.i.i19.i1092.i = getelementptr i8, ptr %1929, i64 16
  %offset_tbl_ptr.i.i20.i1093.i = getelementptr i8, ptr %1929, i64 40
  %1935 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #38
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  %hash_coef.i.i99.i1339.i = load i64, ptr %hash_coef_ptr.i.i18.i1091.i, align 4, !noalias !22
  %tbl_size.i.i100.i1340.i = load i64, ptr %tbl_size_ptr.i.i19.i1092.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1341.i = load ptr, ptr %offset_tbl_ptr.i.i20.i1093.i, align 8, !noalias !22
  %product.i.i.i102.i1342.i = mul i64 %hash_coef.i.i99.i1339.i, 4015701072841558310
  %shifted.i.i.i103.i1343.i = lshr i64 %product.i.i.i102.i1342.i, 32
  %xored.i.i.i104.i1344.i = xor i64 %shifted.i.i.i103.i1343.i, %product.i.i.i102.i1342.i
  %hash.i.i.i105.i1345.i = and i64 %xored.i.i.i104.i1344.i, %tbl_size.i.i100.i1340.i
  %offset_ptr.i.i106.i1346.i = getelementptr i32, ptr %offset_tbl.i.i101.i1341.i, i64 %hash.i.i.i105.i1345.i
  %offset.i.i121.i1347.i = load i32, ptr %offset_ptr.i.i106.i1346.i, align 4, !noalias !476
  %1936 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %1937 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1938 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1939

1939:                                             ; preds = %.cont.cont.i1368.i, %1932
  %.0566.i1348.i = phi i32 [ 0, %1932 ], [ %1943, %.cont.cont.i1368.i ]
  %.070565.i1349.i = phi i1 [ true, %1932 ], [ %2005, %.cont.cont.i1368.i ]
  %.sroa.0.0564.i1350.i = phi ptr [ %1929, %1932 ], [ %vptr.i142.sroa.speculated.i1371.i, %.cont.cont.i1368.i ]
  %.sroa.17.0561.i1353.i = phi i32 [ %offset.i.i121.i1347.i, %1932 ], [ %offset.i.i154.i1385.i, %.cont.cont.i1368.i ]
  %1940 = phi <2 x i64> [ %1934, %1932 ], [ %2004, %.cont.cont.i1368.i ]
  %1941 = extractelement <2 x i64> %1940, i64 1
  %.sroa.12.0562.i1352.i = inttoptr i64 %1941 to ptr
  %1942 = extractelement <2 x i64> %1940, i64 0
  %.sroa.6.0563.i1351.i = inttoptr i64 %1942 to ptr
  %1943 = add nuw nsw i32 %.0566.i1348.i, 1
  %1944 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1350.i, 0
  %1945 = insertvalue { ptr, ptr, ptr, i32 } %1944, ptr %.sroa.6.0563.i1351.i, 1
  %1946 = insertvalue { ptr, ptr, ptr, i32 } %1945, ptr %.sroa.12.0562.i1352.i, 2
  %1947 = insertvalue { ptr, ptr, ptr, i32 } %1946, i32 %.sroa.17.0561.i1353.i, 3
  %1948 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1350.i)
  %1949 = sext i32 %.sroa.17.0561.i1353.i to i64
  %1950 = getelementptr ptr, ptr %.sroa.0.0564.i1350.i, i64 %1949
  %1951 = getelementptr i8, ptr %1950, i64 64
  %1952 = load ptr, ptr %1951, align 8
  %result.i125.i1354.i = call ptr %1952({ ptr, ptr, ptr, i32 } %1947, ptr nocapture nofree noundef nonnull readonly %0) #15
  %1953 = call i32 %result.i125.i1354.i({ ptr, ptr, ptr, i32 } %1947, { ptr, ptr, ptr, i32 } %1947, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1349.i, label %1954, label %1970

1954:                                             ; preds = %1939
  %1955 = load i32, ptr %1101, align 8
  %1956 = add i32 %1955, -1
  %1957 = and i32 %1956, %1953
  %1958 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1959 = load ptr, ptr %1102, align 8
  %1960 = sext i32 %1957 to i64
  %1961 = shl nsw i64 %1960, 5
  %1962 = getelementptr i8, ptr %1959, i64 %1961
  %1963 = load ptr, ptr %1962, align 8
  %1964 = getelementptr i8, ptr %1962, i64 8
  %1965 = load i160, ptr %1964, align 4
  store ptr %.sroa.0.0564.i1350.i, ptr %1962, align 8
  store i64 %1942, ptr %1964, align 4
  %.sroa_idx157.i1397.i = getelementptr i8, ptr %1962, i64 16
  store i64 %1941, ptr %.sroa_idx157.i1397.i, align 4
  %.sroa_idx158.i1398.i = getelementptr i8, ptr %1962, i64 24
  store i32 %.sroa.17.0561.i1353.i, ptr %.sroa_idx158.i1398.i, align 4
  %1966 = icmp ne ptr %1963, @nil_typ
  %1967 = icmp ne ptr %1963, null
  %.not92.i1399.i = and i1 %1966, %1967
  %extract.i1401.i = lshr i160 %1965, 64
  %1968 = insertelement <2 x i160> poison, i160 %1965, i64 0
  %1969 = insertelement <2 x i160> %1968, i160 %extract.i1401.i, i64 1
  br i1 %.not92.i1399.i, label %.cont.cont.i1368.i, label %2009

1970:                                             ; preds = %1939
  %1971 = add i32 %1953, 2127912214
  %1972 = shl i32 %1953, 12
  %1973 = add i32 %1971, %1972
  %1974 = ashr i32 %1973, 19
  %1975 = xor i32 %1973, %1974
  %1976 = xor i32 %1975, -949894596
  %1977 = add i32 %1976, 374761393
  %1978 = shl i32 %1976, 5
  %1979 = add i32 %1977, %1978
  %1980 = add i32 %1979, -744332180
  %1981 = shl i32 %1979, 9
  %1982 = xor i32 %1980, %1981
  %1983 = add i32 %1982, -42973499
  %1984 = shl i32 %1982, 3
  %1985 = add i32 %1983, %1984
  %1986 = ashr i32 %1985, 16
  %1987 = xor i32 %1985, %1986
  %1988 = xor i32 %1987, -1252372727
  %1989 = load i32, ptr %1101, align 8
  %1990 = add i32 %1989, -1
  %1991 = and i32 %1990, %1988
  %1992 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %1993 = load ptr, ptr %1103, align 8
  %1994 = sext i32 %1991 to i64
  %1995 = shl nsw i64 %1994, 5
  %1996 = getelementptr i8, ptr %1993, i64 %1995
  %1997 = load ptr, ptr %1996, align 8
  %1998 = getelementptr i8, ptr %1996, i64 8
  %1999 = load i160, ptr %1998, align 4
  store ptr %.sroa.0.0564.i1350.i, ptr %1996, align 8
  store i64 %1942, ptr %1998, align 4
  %.sroa_idx161.i1358.i = getelementptr i8, ptr %1996, i64 16
  store i64 %1941, ptr %.sroa_idx161.i1358.i, align 4
  %.sroa_idx162.i1359.i = getelementptr i8, ptr %1996, i64 24
  store i32 %.sroa.17.0561.i1353.i, ptr %.sroa_idx162.i1359.i, align 4
  %2000 = icmp ne ptr %1997, @nil_typ
  %2001 = icmp ne ptr %1997, null
  %.not90.i1360.i = and i1 %2000, %2001
  %extract607.i1362.i = lshr i160 %1999, 64
  %2002 = insertelement <2 x i160> poison, i160 %1999, i64 0
  %2003 = insertelement <2 x i160> %2002, i160 %extract607.i1362.i, i64 1
  br i1 %.not90.i1360.i, label %.cont.cont.i1368.i, label %2009

.cont.cont.i1368.i:                               ; preds = %1970, %1954
  %vptr.i142.sroa.speculated.i1371.i = phi ptr [ %1963, %1954 ], [ %1997, %1970 ]
  %.in323 = phi <2 x i160> [ %1969, %1954 ], [ %2003, %1970 ]
  %2004 = trunc <2 x i160> %.in323 to <2 x i64>
  %2005 = xor i1 %.070565.i1349.i, true
  %hash_coef_ptr.i.i143.i1374.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1371.i, i64 8
  %tbl_size_ptr.i.i144.i1375.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1371.i, i64 16
  %offset_tbl_ptr.i.i145.i1376.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1371.i, i64 40
  %hash_coef.i.i146.i1377.i = load i64, ptr %hash_coef_ptr.i.i143.i1374.i, align 4
  %tbl_size.i.i147.i1378.i = load i64, ptr %tbl_size_ptr.i.i144.i1375.i, align 4
  %offset_tbl.i.i148.i1379.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1376.i, align 8
  %product.i.i.i149.i1380.i = mul i64 %hash_coef.i.i146.i1377.i, 4015701072841558310
  %shifted.i.i.i150.i1381.i = lshr i64 %product.i.i.i149.i1380.i, 32
  %xored.i.i.i151.i1382.i = xor i64 %shifted.i.i.i150.i1381.i, %product.i.i.i149.i1380.i
  %hash.i.i.i152.i1383.i = and i64 %xored.i.i.i151.i1382.i, %tbl_size.i.i147.i1378.i
  %offset_ptr.i.i153.i1384.i = getelementptr i32, ptr %offset_tbl.i.i148.i1379.i, i64 %hash.i.i.i152.i1383.i
  %offset.i.i154.i1385.i = load i32, ptr %offset_ptr.i.i153.i1384.i, align 4
  %2006 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %2007 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %2008 = icmp ult i32 %.0566.i1348.i, 99
  br i1 %2008, label %1939, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1403.i

2009:                                             ; preds = %1970, %1954
  %2010 = phi ptr [ %2, %1970 ], [ %1, %1954 ]
  %2011 = load i32, ptr %1104, align 4
  store i32 %2011, ptr %2010, align 4
  %2012 = add i32 %2011, 1
  %2013 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %2012, ptr %1104, align 4
  br label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1403.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1403.i: ; preds = %.cont.cont.i1368.i, %2009
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %._crit_edge.i1089.i

._crit_edge.i1089.i:                              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1403.i, %1925
  %2014 = add nuw nsw i32 %.060.i1087.i, 1
  %2015 = icmp slt i32 %2014, %1828
  br i1 %2015, label %1925, label %HashMap_insert_keyK_valueV.exit.i64

HashMap_insert_keyK_valueV.exit.i64:              ; preds = %._crit_edge.i1089.i, %HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1071.thread.i, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.i, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit659.thread.i, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i126, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i63, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit522.i, %HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i174
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2016 = icmp ult i32 %.0258.i, 999999
  br i1 %2016, label %._crit_edge.i37, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %HashMap_insert_keyK_valueV.exit.i64
  %2017 = call i64 @clock()
  br label %2018

2018:                                             ; preds = %._crit_edge2.i73, %.lr.ph.i
  %.2262.i = phi i32 [ 0, %.lr.ph.i ], [ %2145, %._crit_edge2.i73 ]
  %.0141261.i = phi i64 [ 0, %.lr.ph.i ], [ %.2143.i, %._crit_edge2.i73 ]
  %.0144260.i = phi i1 [ true, %.lr.ph.i ], [ %.2146.i, %._crit_edge2.i73 ]
  %.sroa.0117.0.insert.ext.i = zext nneg i32 %.2262.i to i160
  %2019 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext.i, 1
  %2020 = load ptr, ptr %1099, align 8
  %2021 = call i32 %2020({ ptr, i160 } %2019) #7
  %2022 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap) #34
  %2023 = load i32, ptr %1101, align 8
  %2024 = add i32 %2023, -1
  %2025 = and i32 %2024, %2021
  %2026 = load ptr, ptr %1102, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2027 = sext i32 %2025 to i64
  %2028 = shl nsw i64 %2027, 5
  %2029 = getelementptr i8, ptr %2026, i64 %2028
  %2030 = load ptr, ptr %2029, align 8
  %2031 = icmp ne ptr %2030, @nil_typ
  %2032 = icmp ne ptr %2030, null
  %.not44.i.i65 = and i1 %2031, %2032
  br i1 %.not44.i.i65, label %2033, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i66

2033:                                             ; preds = %2018
  %2034 = getelementptr i8, ptr %2029, i64 8
  %2035 = load i64, ptr %2034, align 4
  %.sroa_idx.i720.i = getelementptr i8, ptr %2029, i64 16
  %2036 = load i64, ptr %.sroa_idx.i720.i, align 4
  %2037 = inttoptr i64 %2035 to ptr
  %2038 = inttoptr i64 %2036 to ptr
  %hash_coef_ptr.i.i46.i.i92 = getelementptr i8, ptr %2030, i64 8
  %tbl_size_ptr.i.i47.i.i93 = getelementptr i8, ptr %2030, i64 16
  %offset_tbl_ptr.i.i48.i.i94 = getelementptr i8, ptr %2030, i64 40
  %hash_coef.i.i49.i.i95 = load i64, ptr %hash_coef_ptr.i.i46.i.i92, align 4, !noalias !479
  %tbl_size.i.i50.i.i96 = load i64, ptr %tbl_size_ptr.i.i47.i.i93, align 4, !noalias !479
  %offset_tbl.i.i51.i.i97 = load ptr, ptr %offset_tbl_ptr.i.i48.i.i94, align 8, !noalias !479
  %product.i.i.i52.i.i98 = mul i64 %hash_coef.i.i49.i.i95, 4015701072841558310
  %shifted.i.i.i53.i.i99 = lshr i64 %product.i.i.i52.i.i98, 32
  %xored.i.i.i54.i.i100 = xor i64 %shifted.i.i.i53.i.i99, %product.i.i.i52.i.i98
  %hash.i.i.i55.i.i101 = and i64 %xored.i.i.i54.i.i100, %tbl_size.i.i50.i.i96
  %offset_ptr.i.i56.i.i102 = getelementptr i32, ptr %offset_tbl.i.i51.i.i97, i64 %hash.i.i.i55.i.i101
  %offset.i.i57.i.i103 = load i32, ptr %offset_ptr.i.i56.i.i102, align 4, !noalias !479
  %2039 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2030, 0
  %2040 = insertvalue { ptr, ptr, ptr, i32 } %2039, ptr %2037, 1
  %2041 = insertvalue { ptr, ptr, ptr, i32 } %2040, ptr %2038, 2
  %2042 = insertvalue { ptr, ptr, ptr, i32 } %2041, i32 %offset.i.i57.i.i103, 3
  %2043 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2044 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2030) #34
  %2045 = sext i32 %offset.i.i57.i.i103 to i64
  %2046 = getelementptr ptr, ptr %2030, i64 %2045
  %2047 = getelementptr i8, ptr %2046, i64 64
  %2048 = load ptr, ptr %2047, align 8
  %result.i.i721.i = call ptr %2048({ ptr, ptr, ptr, i32 } %2042, ptr nocapture nofree noundef nonnull readonly %0) #15
  %2049 = call i32 %result.i.i721.i({ ptr, ptr, ptr, i32 } %2042, { ptr, ptr, ptr, i32 } %2042, ptr nonnull align 8 %0) #7
  %2050 = icmp eq i32 %2049, %2021
  br i1 %2050, label %._crit_edge.i722.i, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i66

._crit_edge.i722.i:                               ; preds = %2033
  %2051 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2052 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2030)
  %2053 = getelementptr i8, ptr %2046, i64 48
  %2054 = load ptr, ptr %2053, align 8
  %result.i59.i.i104 = call ptr %2054({ ptr, ptr, ptr, i32 } %2042, ptr nocapture nofree noundef nonnull readonly %0) #15
  %2055 = call { ptr, i160 } %result.i59.i.i104({ ptr, ptr, ptr, i32 } %2042, { ptr, ptr, ptr, i32 } %2042, ptr nonnull align 8 %0) #7
  %2056 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2057 = load ptr, ptr %1100, align 8
  %2058 = call i1 %2057({ ptr, i160 } %2055, { ptr, i160 } %2019) #7
  br i1 %2058, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i105, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i66

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i66: ; preds = %._crit_edge.i722.i, %2033, %2018
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %2067

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i105: ; preds = %._crit_edge.i722.i
  %2059 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2060 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2030)
  %2061 = getelementptr i8, ptr %2046, i64 56
  %2062 = load ptr, ptr %2061, align 8
  %result.i60.i.i106 = call ptr %2062({ ptr, ptr, ptr, i32 } %2042, ptr nocapture nofree noundef nonnull readonly %0) #15
  %2063 = call { ptr, i160 } %result.i60.i.i106({ ptr, ptr, ptr, i32 } %2042, { ptr, ptr, ptr, i32 } %2042, ptr nonnull align 8 %0) #7
  %.fca.0.extract21.i.i107 = extractvalue { ptr, i160 } %2063, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2064 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2065 = icmp ne ptr %.fca.0.extract21.i.i107, @nil_typ
  %2066 = icmp ne ptr %.fca.0.extract21.i.i107, null
  %.not63.i.i108 = and i1 %2065, %2066
  br i1 %.not63.i.i108, label %HashMap_get_keyK.exit.i70, label %2067

2067:                                             ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i105, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i66
  %2068 = add i32 %2021, 2127912214
  %2069 = shl i32 %2021, 12
  %2070 = add i32 %2068, %2069
  %2071 = ashr i32 %2070, 19
  %2072 = xor i32 %2070, %2071
  %2073 = xor i32 %2072, -949894596
  %2074 = add i32 %2073, 374761393
  %2075 = shl i32 %2073, 5
  %2076 = add i32 %2074, %2075
  %2077 = add i32 %2076, -744332180
  %2078 = shl i32 %2076, 9
  %2079 = xor i32 %2077, %2078
  %2080 = add i32 %2079, -42973499
  %2081 = shl i32 %2079, 3
  %2082 = add i32 %2080, %2081
  %2083 = ashr i32 %2082, 16
  %2084 = xor i32 %2082, %2083
  %2085 = xor i32 %2084, -1252372727
  %2086 = load i32, ptr %1101, align 8
  %2087 = add i32 %2086, -1
  %2088 = and i32 %2087, %2085
  %2089 = load ptr, ptr %1103, align 8
  %2090 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2091 = sext i32 %2088 to i64
  %2092 = shl nsw i64 %2091, 5
  %2093 = getelementptr i8, ptr %2089, i64 %2092
  %2094 = load ptr, ptr %2093, align 8
  %2095 = icmp ne ptr %2094, @nil_typ
  %2096 = icmp ne ptr %2094, null
  %.not44.i752.i = and i1 %2095, %2096
  br i1 %.not44.i752.i, label %2097, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776.i

2097:                                             ; preds = %2067
  %2098 = getelementptr i8, ptr %2093, i64 8
  %2099 = load i64, ptr %2098, align 4
  %.sroa_idx.i756.i = getelementptr i8, ptr %2093, i64 16
  %2100 = load i64, ptr %.sroa_idx.i756.i, align 4
  %2101 = inttoptr i64 %2099 to ptr
  %2102 = inttoptr i64 %2100 to ptr
  %hash_coef_ptr.i.i46.i757.i = getelementptr i8, ptr %2094, i64 8
  %tbl_size_ptr.i.i47.i758.i = getelementptr i8, ptr %2094, i64 16
  %offset_tbl_ptr.i.i48.i759.i = getelementptr i8, ptr %2094, i64 40
  %hash_coef.i.i49.i760.i = load i64, ptr %hash_coef_ptr.i.i46.i757.i, align 4, !noalias !482
  %tbl_size.i.i50.i761.i = load i64, ptr %tbl_size_ptr.i.i47.i758.i, align 4, !noalias !482
  %offset_tbl.i.i51.i762.i = load ptr, ptr %offset_tbl_ptr.i.i48.i759.i, align 8, !noalias !482
  %product.i.i.i52.i763.i = mul i64 %hash_coef.i.i49.i760.i, 4015701072841558310
  %shifted.i.i.i53.i764.i = lshr i64 %product.i.i.i52.i763.i, 32
  %xored.i.i.i54.i765.i = xor i64 %shifted.i.i.i53.i764.i, %product.i.i.i52.i763.i
  %hash.i.i.i55.i766.i = and i64 %xored.i.i.i54.i765.i, %tbl_size.i.i50.i761.i
  %offset_ptr.i.i56.i767.i = getelementptr i32, ptr %offset_tbl.i.i51.i762.i, i64 %hash.i.i.i55.i766.i
  %offset.i.i57.i768.i = load i32, ptr %offset_ptr.i.i56.i767.i, align 4, !noalias !482
  %2103 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2094, 0
  %2104 = insertvalue { ptr, ptr, ptr, i32 } %2103, ptr %2101, 1
  %2105 = insertvalue { ptr, ptr, ptr, i32 } %2104, ptr %2102, 2
  %2106 = insertvalue { ptr, ptr, ptr, i32 } %2105, i32 %offset.i.i57.i768.i, 3
  %2107 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2108 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2094) #34
  %2109 = sext i32 %offset.i.i57.i768.i to i64
  %2110 = getelementptr ptr, ptr %2094, i64 %2109
  %2111 = getelementptr i8, ptr %2110, i64 64
  %2112 = load ptr, ptr %2111, align 8
  %result.i.i769.i = call ptr %2112({ ptr, ptr, ptr, i32 } %2106, ptr nocapture nofree noundef nonnull readonly %0) #15
  %2113 = call i32 %result.i.i769.i({ ptr, ptr, ptr, i32 } %2106, { ptr, ptr, ptr, i32 } %2106, ptr nonnull align 8 %0) #7
  %2114 = icmp eq i32 %2113, %2021
  br i1 %2114, label %._crit_edge.i770.i, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776.i

._crit_edge.i770.i:                               ; preds = %2097
  %2115 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2116 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2094)
  %2117 = getelementptr i8, ptr %2110, i64 48
  %2118 = load ptr, ptr %2117, align 8
  %result.i59.i771.i = call ptr %2118({ ptr, ptr, ptr, i32 } %2106, ptr nocapture nofree noundef nonnull readonly %0) #15
  %2119 = call { ptr, i160 } %result.i59.i771.i({ ptr, ptr, ptr, i32 } %2106, { ptr, ptr, ptr, i32 } %2106, ptr nonnull align 8 %0) #7
  %2120 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull @HashMap)
  %2121 = load ptr, ptr %1100, align 8
  %2122 = call i1 %2121({ ptr, i160 } %2119, { ptr, i160 } %2019) #7
  br i1 %2122, label %2123, label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776.i

2123:                                             ; preds = %._crit_edge.i770.i
  %2124 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2125 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2094)
  %2126 = getelementptr i8, ptr %2110, i64 56
  %2127 = load ptr, ptr %2126, align 8
  %result.i60.i773.i = call ptr %2127({ ptr, ptr, ptr, i32 } %2106, ptr nocapture nofree noundef nonnull readonly %0) #15
  %2128 = call { ptr, i160 } %result.i60.i773.i({ ptr, ptr, ptr, i32 } %2106, { ptr, ptr, ptr, i32 } %2106, ptr nonnull align 8 %0) #7
  %.fca.0.extract21.i774.i = extractvalue { ptr, i160 } %2128, 0
  %.fca.1.extract22.i775.i = extractvalue { ptr, i160 } %2128, 1
  br label %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776.i

HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776.i: ; preds = %2123, %._crit_edge.i770.i, %2097, %2067
  %.reg2mem43.sroa.3.077.i753.i = phi i160 [ %.fca.1.extract22.i775.i, %2123 ], [ poison, %._crit_edge.i770.i ], [ poison, %2067 ], [ poison, %2097 ]
  %2129 = phi ptr [ %.fca.0.extract21.i774.i, %2123 ], [ @nil_typ, %._crit_edge.i770.i ], [ @nil_typ, %2067 ], [ @nil_typ, %2097 ]
  %.reload40.fca.0.insert.i754.i = insertvalue { ptr, i160 } poison, ptr %2129, 0
  %.reload40.fca.1.insert.i755.i = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i754.i, i160 %.reg2mem43.sroa.3.077.i753.i, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2130 = icmp ne ptr %2129, @nil_typ
  %2131 = icmp ne ptr %2129, null
  %.not65.not.not.i.i67 = and i1 %2130, %2131
  %cond.fr.i.i68 = freeze i1 %.not65.not.not.i.i67
  %spec.select.i.i69 = select i1 %cond.fr.i.i68, ptr %2129, ptr @nil_typ
  br label %HashMap_get_keyK.exit.i70

HashMap_get_keyK.exit.i70:                        ; preds = %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i105
  %.pn.i.i71 = phi { ptr, i160 } [ %2063, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i105 ], [ %.reload40.fca.1.insert.i755.i, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776.i ]
  %2132 = phi ptr [ %.fca.0.extract21.i.i107, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i105 ], [ %spec.select.i.i69, %HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit776.i ]
  %2133 = icmp ne ptr %2132, @nil_typ
  %2134 = icmp ne ptr %2132, null
  %.not150.i = and i1 %2133, %2134
  br i1 %.not150.i, label %2135, label %._crit_edge.lr.ph.i.i

2135:                                             ; preds = %HashMap_get_keyK.exit.i70
  %.fca.1.extract..sroa.354.0101.i.i90 = extractvalue { ptr, i160 } %.pn.i.i71, 1
  %.sroa.2.8.extract.trunc.i91 = trunc i160 %.fca.1.extract..sroa.354.0101.i.i90 to i32
  %2136 = sext i32 %.sroa.2.8.extract.trunc.i91 to i64
  %2137 = add i64 %.0141261.i, %2136
  br label %._crit_edge2.i73

._crit_edge.lr.ph.i.i:                            ; preds = %HashMap_get_keyK.exit.i70
  %result.i161.i = call noalias align 64 dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2138 = load <55 x i8>, ptr @tvsrx_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  store <55 x i8> %2138, ptr %result.i161.i, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2139 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2140 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i790.i = call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(55) %result.i.i790.i, ptr noundef nonnull align 64 dereferenceable(55) %result.i161.i, i64 55, i1 false)
  %2141 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2142 = getelementptr i8, ptr %result.i.i790.i, i64 55
  store i8 0, ptr %2142, align 1
  %puts.i.i72 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i790.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2143 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2144 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2262.i) #16
  br label %._crit_edge2.i73

._crit_edge2.i73:                                 ; preds = %._crit_edge.lr.ph.i.i, %2135
  %.2146.i = phi i1 [ %.0144260.i, %2135 ], [ false, %._crit_edge.lr.ph.i.i ]
  %.2143.i = phi i64 [ %2137, %2135 ], [ %.0141261.i, %._crit_edge.lr.ph.i.i ]
  %2145 = add nuw nsw i32 %.2262.i, 1
  %2146 = icmp ult i32 %.2262.i, 999999
  br i1 %2146, label %2018, label %._crit_edge.lr.ph.i806.i

._crit_edge.lr.ph.i806.i:                         ; preds = %._crit_edge2.i73
  %2147 = call i64 @clock()
  %result.i167.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i167.i, align 32
  %2148 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2149 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2150 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i805.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i805.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i167.i, i64 18, i1 false)
  %2151 = sub i64 %2147, %2017
  %2152 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2153 = getelementptr i8, ptr %result.i.i805.i, i64 18
  store i8 0, ptr %2153, align 1
  %puts.i391.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i805.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i97.i.i74 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i.i74, align 16
  %result.i.i376.i.i75 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i376.i.i75, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i.i74, i64 14, i1 false)
  %puts.i.i.i76 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i376.i.i75)
  %2154 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 1000000) #16
  %result.i103.i.i77 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i.i77, align 16
  %result.i.i390.i.i78 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i390.i.i78, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i.i77, i64 14, i1 false)
  %puts.i314.i.i79 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i390.i.i78)
  %2155 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2151) #16
  %result.i109.i.i80 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i.i80, align 4
  %result.i.i409.i.i81 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i409.i.i81, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i.i80, i64 3, i1 false)
  %puts.i334.i.i82 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i409.i.i81)
  %2156 = icmp sgt i64 %2151, 0
  br i1 %2156, label %2157, label %._crit_edge.lr.ph.i288

2157:                                             ; preds = %._crit_edge.lr.ph.i806.i
  %2158 = mul i64 %2151, 1000000
  %2159 = sdiv i64 %2158, 1000000
  br label %._crit_edge.lr.ph.i288

._crit_edge.lr.ph.i288:                           ; preds = %._crit_edge.lr.ph.i806.i, %2157
  %.0.i.i83 = phi i64 [ %2159, %2157 ], [ 0, %._crit_edge.lr.ph.i806.i ]
  %result.i114.i.i84 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i.i84, align 16
  %result.i.i428.i.i85 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i428.i.i85, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i.i84, i64 15, i1 false)
  %puts.i354.i.i86 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i.i85)
  %2160 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i.i83) #16
  %result.i120.i.i87 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i.i87, align 4
  %result.i.i447.i.i88 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i447.i.i88, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i.i87, i64 3, i1 false)
  %puts.i374.i.i89 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i447.i.i88)
  %.not.i = icmp eq i64 %.2143.i, 500000500000
  %result.i171.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i171.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2162 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i824.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i824.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i171.i, i64 18, i1 false)
  %spec.select.i = select i1 %.not.i, i1 %.2146.i, i1 false
  %2163 = getelementptr i8, ptr %result.i.i824.i, i64 18
  store i8 0, ptr %2163, align 1
  %puts.i411.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i824.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %..i = select i1 %spec.select.i, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %2164 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2165 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2166 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i843.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %..i, ptr %result.i.i843.i, align 1
  %2167 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2168 = getelementptr i8, ptr %result.i.i843.i, i64 4
  store i8 0, ptr %2168, align 1
  %puts.i431.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i843.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @benchmark_get_random_hit(i32 noundef 1000000)
  call void @benchmark_get_random_miss(i32 noundef 1000000)
  call void @benchmark_remove_random(i32 noundef 1000000)
  %result.i179 = call noalias align 32 dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <27 x i8> <i8 45, i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %result.i179, align 32
  %2169 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2170 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2171 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i287 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(27) %result.i.i287, ptr noundef nonnull align 32 dereferenceable(27) %result.i179, i64 27, i1 false)
  %2172 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2173 = getelementptr i8, ptr %result.i.i287, i64 27
  store i8 0, ptr %2173, align 1
  %puts.i251 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i287)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_bool_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_bool_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_bool_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #8

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_any_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Object(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i8_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i8_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i8_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i32_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i32_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i32, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i32 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i32_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  store i32 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i64_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i64_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i64_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i128_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 16, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i128_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %.sroa.2.sroa.0.0.copyload = load i128, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i128 %.sroa.2.sroa.0.0.copyload to i160
  %3 = insertvalue { ptr, i160 } { ptr @i128_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i128_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i128
  store i128 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_f64_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_f64_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_f64_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nil_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nil_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #0 {
  ret { ptr, i160 } { ptr @nil_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nil_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nothing_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nothing_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #0 {
  ret { ptr, i160 } { ptr @nothing_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nothing_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_coroutine_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_coroutine_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @coroutine_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_coroutine_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_function_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_function_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_function_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_buffer_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_buffer_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @buffer_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define { ptr, i160 } @_box_tuple_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #9 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = getelementptr i8, ptr %1, i64 8
  %4 = load i64, ptr %3, align 4
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %13, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %19, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem14.0.i = phi i64 [ %20, %.lr.ph.i ], [ 1, %2 ]
  %.in.reg2mem.0.i = phi i64 [ %22, %.lr.ph.i ], [ %4, %2 ]
  %6 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { i64, i64 } %9(ptr nonnull align 8 %6) #7
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = tail call i64 @llvm.umax.i64(i64 %12, i64 %.reg2mem20.010.reg2mem.0.i)
  %14 = urem i64 %.reg2mem22.011.reg2mem.0.i, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %11, %.reg2mem22.011.reg2mem.0.i
  %19 = add i64 %18, %17
  %20 = add i64 %.reg2mem14.0.i, 1
  %21 = getelementptr ptr, ptr %1, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %2
  %.reg2mem22.0.lcssa.reg2mem.0.i = phi i64 [ 0, %2 ], [ %19, %.lr.ph.i ]
  %.reg2mem20.0.lcssa.reg2mem.0.i = phi i64 [ 1, %2 ], [ %13, %.lr.ph.i ]
  %24 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0.i, %.reg2mem20.0.lcssa.reg2mem.0.i
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0.i, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %27, %.reg2mem22.0.lcssa.reg2mem.0.i
  %29 = icmp slt i64 %28, 17
  br i1 %29, label %31, label %30

30:                                               ; preds = %_data_size_tuple_typ.exit
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %result.i4, ptr nocapture nofree readonly align 1 %0, i64 %28, i1 noundef false) #34
  store ptr %result.i4, ptr %.sroa.2, align 8
  br label %32

31:                                               ; preds = %_data_size_tuple_typ.exit
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %28, i1 noundef false) #34
  br label %32

32:                                               ; preds = %31, %30
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %33 = insertvalue { ptr, i160 } { ptr @tuple_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %33
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define void @_unbox_tuple_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #9 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %3, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %3 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %3 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8) #7
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = add i64 %20, %19
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %3
  %.reg2mem22.0.lcssa.reg2mem.0.i = phi i64 [ 0, %3 ], [ %21, %.lr.ph.i ]
  %.reg2mem20.0.lcssa.reg2mem.0.i = phi i64 [ 1, %3 ], [ %15, %.lr.ph.i ]
  %26 = trunc i160 %.fca.1.extract to i64
  %27 = inttoptr i64 %26 to ptr
  %28 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0.i, %.reg2mem20.0.lcssa.reg2mem.0.i
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0.i, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %31, %.reg2mem22.0.lcssa.reg2mem.0.i
  %33 = icmp slt i64 %32, 17
  %34 = select i1 %33, ptr %.fca.1.gep, ptr %27
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %34, i64 %32, i1 noundef false) #34
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define { ptr, i160 } @_box_union_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #9 {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @union_typ, ptr %3, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %.fr.i, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %2 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %2 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8) #7
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = tail call i64 @llvm.umax.i64(i64 %20, i64 %19)
  %.fr.i = freeze i64 %21
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %.fr.i, 32
  %spec.select.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select.i, %.fr.i
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %2, %._crit_edge.i
  %.reg2mem20.0.lcssa.reg2mem.012.i = phi i64 [ 1, %2 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %2 ], [ %26, %._crit_edge.i ]
  %27 = urem i64 %final_size.i, %.reg2mem20.0.lcssa.reg2mem.012.i
  %28 = icmp eq i64 %27, 0
  %29 = sub i64 %.reg2mem20.0.lcssa.reg2mem.012.i, %27
  %30 = select i1 %28, i64 0, i64 %29
  %31 = add i64 %30, %final_size.i
  %32 = icmp eq i64 %31, 32
  br i1 %32, label %._crit_edge, label %33

._crit_edge:                                      ; preds = %33, %_data_size_union_typ.exit
  %.reg2mem10.0 = phi ptr [ %3, %_data_size_union_typ.exit ], [ %4, %33 ]
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.reg2mem10.0, ptr nocapture nofree readonly align 1 %0, i64 %31, i1 noundef false) #34
  %.pre = load ptr, ptr %3, align 8
  br label %36

33:                                               ; preds = %_data_size_union_typ.exit
  %34 = icmp slt i64 %31, 17
  br i1 %34, label %._crit_edge, label %35

35:                                               ; preds = %33
  %result.i5 = tail call noalias ptr @bump_malloc_inner(i64 noundef %31, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %result.i5, ptr nocapture nofree readonly align 1 %0, i64 %31, i1 noundef false) #34
  store ptr %result.i5, ptr %4, align 8
  br label %36

36:                                               ; preds = %35, %._crit_edge
  %37 = phi ptr [ @union_typ, %35 ], [ %.pre, %._crit_edge ]
  %38 = insertvalue { ptr, i160 } undef, ptr %37, 0
  %39 = load i160, ptr %4, align 8
  %40 = insertvalue { ptr, i160 } %38, i160 %39, 1
  ret { ptr, i160 } %40
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Entry(ptr nocapture nofree readonly align 8 %0) #10 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 0
  %21 = extractvalue { i64, i64 } %result.i1, 1
  %22 = tail call i64 @llvm.umax.i64(i64 %8, i64 %21)
  %23 = tail call i64 @llvm.umax.i64(i64 %22, i64 8)
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %29, %33
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_init_keyK_valueV_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_primary_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_to_pair_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_init_keyK_valueV_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #2 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !485
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !485
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !485
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !485
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract12) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract12, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  tail call void %13(ptr %.fca.1.extract13, { ptr, i160 } %3) #35
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract12) #34
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract13, { ptr, i160 } %4) #35
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract12) #34
  %20 = getelementptr i8, ptr %9, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  tail call void %23(ptr %.fca.1.extract13, i32 %5) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !488
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !488
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !488
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !488
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #36
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !491
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !491
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !491
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !491
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 32
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #36
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Entry_primary_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !494
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !494
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !494
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !494
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Entry_to_pair_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !497
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !497
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !497
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !497
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract27, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract28) #36
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #34
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call { ptr, i160 } %14(ptr %.fca.1.extract28) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #34
  %17 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract28) #5
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #34
  %19 = getelementptr i8, ptr %6, i64 8
  %20 = load ptr, ptr %19, align 8
  %result.i31 = tail call ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract28) #5
  %21 = load ptr, ptr %result.i, align 8, !alias.scope !500
  %22 = getelementptr i8, ptr %21, i64 72
  %23 = load ptr, ptr %22, align 8, !alias.scope !500
  %result.i.i = tail call { i64, i64 } %23(ptr nocapture nofree nonnull readonly %result.i) #5, !alias.scope !500
  %24 = extractvalue { i64, i64 } %result.i.i, 0
  %25 = extractvalue { i64, i64 } %result.i.i, 1
  %26 = urem i64 16, %25
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %25, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %24, 16
  %31 = add i64 %30, %29
  %32 = load ptr, ptr %result.i31, align 8, !alias.scope !500
  %33 = getelementptr i8, ptr %32, i64 72
  %34 = load ptr, ptr %33, align 8, !alias.scope !500
  %result.i1.i = tail call { i64, i64 } %34(ptr nocapture nofree nonnull readonly %result.i31) #5, !alias.scope !500
  %35 = extractvalue { i64, i64 } %result.i1.i, 0
  %36 = extractvalue { i64, i64 } %result.i1.i, 1
  %37 = tail call i64 @llvm.umax.i64(i64 %25, i64 %36)
  %38 = tail call i64 @llvm.umax.i64(i64 %37, i64 8)
  %39 = urem i64 %31, %36
  %40 = icmp eq i64 %39, 0
  %41 = sub i64 %36, %39
  %42 = select i1 %40, i64 0, i64 %41
  %43 = add i64 %35, %31
  %44 = add i64 %43, %42
  %45 = urem i64 %44, %38
  %46 = icmp eq i64 %45, 0
  %47 = sub i64 %38, %45
  %48 = select i1 %46, i64 0, i64 %47
  %49 = add i64 %48, %44
  %result.i33 = tail call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %49, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i33, align 8
  %50 = getelementptr inbounds i8, ptr %result.i33, i64 8
  store ptr %result.i31, ptr %50, align 8
  %51 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i33) #34
  %52 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #34
  %53 = load ptr, ptr %7, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = tail call { ptr, i160 } %54(ptr %.fca.1.extract28) #36
  %56 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #34
  %57 = load ptr, ptr %12, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = tail call { ptr, i160 } %58(ptr %.fca.1.extract28) #36
  %60 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %result.i33, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr undef, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 10, 3
  %63 = load ptr, ptr %result.i, align 8
  %64 = getelementptr i8, ptr %63, i64 72
  %65 = load ptr, ptr %64, align 8
  %result.i.i60 = tail call { i64, i64 } %65(ptr nocapture nofree nonnull readonly %result.i) #5
  %66 = extractvalue { i64, i64 } %result.i.i60, 1
  %67 = urem i64 16, %66
  %68 = icmp eq i64 %67, 0
  %reass.sub = sub i64 %66, %67
  %69 = add i64 %reass.sub, 16
  %70 = select i1 %68, i64 16, i64 %69
  %71 = getelementptr i8, ptr %result.i33, i64 %70
  %72 = getelementptr i8, ptr %63, i64 64
  %73 = load ptr, ptr %72, align 8
  tail call void %73({ ptr, i160 } %55, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %71) #12
  %74 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #34
  %75 = load ptr, ptr %result.i33, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = getelementptr i8, ptr %76, i64 72
  %78 = load ptr, ptr %77, align 8
  %result.i.i61 = tail call { i64, i64 } %78(ptr nocapture nofree nonnull readonly %75) #5
  %79 = extractvalue { i64, i64 } %result.i.i61, 0
  %80 = extractvalue { i64, i64 } %result.i.i61, 1
  %81 = urem i64 16, %80
  %82 = icmp eq i64 %81, 0
  %83 = sub i64 %80, %81
  %84 = select i1 %82, i64 0, i64 %83
  %85 = add i64 %79, 16
  %86 = add i64 %85, %84
  %87 = load ptr, ptr %50, align 8
  %88 = load ptr, ptr %87, align 8
  %89 = getelementptr i8, ptr %88, i64 72
  %90 = load ptr, ptr %89, align 8
  %result.i1.i62 = tail call { i64, i64 } %90(ptr nocapture nofree nonnull readonly %87) #5
  %91 = extractvalue { i64, i64 } %result.i1.i62, 1
  %92 = urem i64 %86, %91
  %93 = icmp eq i64 %92, 0
  %94 = sub i64 %91, %92
  %95 = select i1 %93, i64 0, i64 %94
  %96 = getelementptr i8, ptr %result.i33, i64 %86
  %97 = getelementptr i8, ptr %96, i64 %95
  %98 = getelementptr i8, ptr %88, i64 64
  %99 = load ptr, ptr %98, align 8
  tail call void %99({ ptr, i160 } %59, ptr nocapture nofree nonnull readonly %87, ptr nocapture nofree writeonly %97) #12
  ret { ptr, ptr, ptr, i32 } %62
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_value(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 0
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 20
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i1 = tail call { i64, i64 } %18(ptr nocapture nofree nonnull readonly %15) #5
  %19 = extractvalue { i64, i64 } %result.i1, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = tail call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly %15) #5
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_value(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  tail call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %16, ptr nocapture nofree writeonly %26) #12
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_key(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 20, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 20
  %10 = select i1 %8, i64 20, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = tail call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly %2) #5
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_key(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  tail call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %3, ptr nocapture nofree writeonly %12) #12
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_primary_hash(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_primary_hash(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMap(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 64, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @HashMap_B__Self_max_displacements_(ptr nocapture nofree %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #34
  ret ptr @HashMap__Self_max_displacements_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_hash1_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_hash2_from_primary_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_index1_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_index2_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_resize_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 528
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 576
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @HashMap__Self_max_displacements_(ptr nocapture nofree readnone %0) #0 {
  ret i32 100
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @HashMap_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !503
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !503
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !503
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !503
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract8, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %14 = getelementptr i8, ptr %8, i64 64
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, { ptr } %4) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %19 = getelementptr i8, ptr %8, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 8) #35
  %result.i = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %24 = getelementptr i8, ptr %8, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %27(ptr %.fca.1.extract, { ptr } %28) #35
  %result.i9 = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %30 = getelementptr i8, ptr %8, i64 32
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr } undef, ptr %result.i9, 0
  tail call void %33(ptr %.fca.1.extract, { ptr } %34) #35
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %36 = getelementptr i8, ptr %8, i64 48
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  tail call void %39(ptr %.fca.1.extract, i32 0) #35
  ret void
}

define i32 @HashMap_hash1_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) {
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !506
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !506
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !506
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !506
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract6) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract6, i64 %6
  %8 = getelementptr i8, ptr %7, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr } %10(ptr %.fca.1.extract7) #36
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = tail call i32 %.fca.0.extract({ ptr, i160 } %3)
  ret i32 %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @HashMap_hash2_from_primary_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #0 {
  %5 = add i32 %3, 2127912214
  %6 = shl i32 %3, 12
  %7 = add i32 %5, %6
  %8 = ashr i32 %7, 19
  %9 = xor i32 %7, %8
  %10 = xor i32 %9, -949894596
  %11 = add i32 %10, 374761393
  %12 = shl i32 %10, 5
  %13 = add i32 %11, %12
  %14 = add i32 %13, -744332180
  %15 = shl i32 %13, 9
  %16 = xor i32 %14, %15
  %17 = add i32 %16, -42973499
  %18 = shl i32 %16, 3
  %19 = add i32 %17, %18
  %20 = ashr i32 %19, 16
  %21 = xor i32 %19, %20
  %22 = xor i32 %21, -1252372727
  ret i32 %22
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @HashMap_index1_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !509
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !509
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !509
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !509
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract) #36
  %12 = add i32 %11, -1
  %13 = and i32 %12, %3
  ret i32 %13
}

; Function Attrs: nounwind
define i32 @HashMap_index2_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !512
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !512
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !512
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !512
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i.i, 3
  %9 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9) #34
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract) #34
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 96
  %15 = load ptr, ptr %14, align 8
  %16 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %16, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly %16) #15
  %17 = call i32 %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 dereferenceable(8) %9, i32 %3) #7
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = getelementptr i8, ptr %13, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i32 %21(ptr %.fca.1.extract) #36
  %23 = add i32 %22, -1
  %24 = and i32 %23, %17
  ret i32 %24
}

; Function Attrs: nounwind
define { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
.lr.ph:
  %4 = alloca {}, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca i32, align 4
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca i32, align 4
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !515
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !515
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !515
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !515
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i96 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i97 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i98 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i99 = load i64, ptr %hash_coef_ptr.i.i96, align 4, !noalias !22
  %tbl_size.i.i100 = load i64, ptr %tbl_size_ptr.i.i97, align 4, !noalias !22
  %offset_tbl.i.i101 = load ptr, ptr %offset_tbl_ptr.i.i98, align 8, !noalias !22
  %product.i.i.i102 = mul i64 %hash_coef.i.i99, 4015701072841558310
  %shifted.i.i.i103 = lshr i64 %product.i.i.i102, 32
  %xored.i.i.i104 = xor i64 %shifted.i.i.i103, %product.i.i.i102
  %hash.i.i.i105 = and i64 %xored.i.i.i104, %tbl_size.i.i100
  %offset_ptr.i.i106 = getelementptr i32, ptr %offset_tbl.i.i101, i64 %hash.i.i.i105
  %offset.i.i121 = load i32, ptr %offset_ptr.i.i106, align 4, !noalias !518
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8) #38
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract8, i64 %12
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8) #38
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %4) #34
  %.fca.2.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract9, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract10, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i, 3
  %22 = getelementptr i8, ptr %13, i64 112
  %23 = getelementptr i8, ptr %13, i64 32
  %24 = getelementptr i8, ptr %13, i64 104
  %25 = getelementptr i8, ptr %13, i64 24
  %26 = insertelement <2 x ptr> poison, ptr %.fca.1.extract, i64 0
  %27 = insertelement <2 x ptr> %26, ptr %.fca.2.extract, i64 1
  br label %28

28:                                               ; preds = %.lr.ph, %.cont.cont
  %.0566 = phi i32 [ 0, %.lr.ph ], [ %30, %.cont.cont ]
  %.070565 = phi i1 [ true, %.lr.ph ], [ %95, %.cont.cont ]
  %.sroa.0.0564 = phi ptr [ %.fca.0.extract, %.lr.ph ], [ %vptr.i142.sroa.speculated, %.cont.cont ]
  %.sroa.17.0561 = phi i32 [ %offset.i.i121, %.lr.ph ], [ %offset.i.i154, %.cont.cont ]
  %29 = phi <2 x ptr> [ %27, %.lr.ph ], [ %94, %.cont.cont ]
  %30 = add nuw nsw i32 %.0566, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564, 0
  %32 = extractelement <2 x ptr> %29, i64 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %32, 1
  %34 = extractelement <2 x ptr> %29, i64 1
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 2
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, i32 %.sroa.17.0561, 3
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564)
  %38 = sext i32 %.sroa.17.0561 to i64
  %39 = getelementptr ptr, ptr %.sroa.0.0564, i64 %38
  %40 = getelementptr i8, ptr %39, i64 64
  %41 = load ptr, ptr %40, align 8
  %result.i125 = call ptr %41({ ptr, ptr, ptr, i32 } %36, ptr nocapture nofree noundef nonnull readonly %4) #15
  %42 = call i32 %result.i125({ ptr, ptr, ptr, i32 } %36, { ptr, ptr, ptr, i32 } %36, ptr nonnull align 8 %4) #7
  br i1 %.070565, label %43, label %68

43:                                               ; preds = %28
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %46 = load ptr, ptr %24, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i126 = call ptr %46({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #15
  %47 = call i32 %result.i126({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 dereferenceable(8) %5, i32 %42) #7
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %49 = load ptr, ptr %25, align 8
  %50 = load ptr, ptr %49, align 8
  %51 = call { ptr } %50(ptr %.fca.1.extract9) #36
  %.fca.0.extract60 = extractvalue { ptr } %51, 0
  %52 = sext i32 %47 to i64
  %53 = shl nsw i64 %52, 5
  %54 = getelementptr i8, ptr %.fca.0.extract60, i64 %53
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr i8, ptr %54, i64 8
  %57 = load i160, ptr %56, align 4
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %59 = call { ptr } %50(ptr %.fca.1.extract9) #36
  %.fca.0.extract58 = extractvalue { ptr } %59, 0
  %60 = getelementptr i8, ptr %.fca.0.extract58, i64 %53
  store ptr %.sroa.0.0564, ptr %60, align 8
  %61 = getelementptr i8, ptr %60, i64 8
  %62 = ptrtoint ptr %32 to i64
  %63 = ptrtoint ptr %34 to i64
  store i64 %62, ptr %61, align 4
  %.sroa_idx157 = getelementptr i8, ptr %60, i64 16
  store i64 %63, ptr %.sroa_idx157, align 4
  %.sroa_idx158 = getelementptr i8, ptr %60, i64 24
  store i32 %.sroa.17.0561, ptr %.sroa_idx158, align 4
  %64 = icmp ne ptr %55, @nil_typ
  %65 = icmp ne ptr %55, null
  %.not92 = and i1 %64, %65
  %extract = lshr i160 %57, 64
  %66 = insertelement <2 x i160> poison, i160 %57, i64 0
  %67 = insertelement <2 x i160> %66, i160 %extract, i64 1
  br i1 %.not92, label %.cont.cont, label %99

68:                                               ; preds = %28
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %71 = load ptr, ptr %22, align 8
  store ptr @i32_typ, ptr %9, align 8
  %result.i127 = call ptr %71({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %9) #15
  %72 = call i32 %result.i127({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 dereferenceable(8) %8, i32 %42) #7
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %74 = load ptr, ptr %23, align 8
  %75 = load ptr, ptr %74, align 8
  %76 = call { ptr } %75(ptr %.fca.1.extract9) #36
  %.fca.0.extract53 = extractvalue { ptr } %76, 0
  %77 = sext i32 %72 to i64
  %78 = shl nsw i64 %77, 5
  %79 = getelementptr i8, ptr %.fca.0.extract53, i64 %78
  %80 = load ptr, ptr %79, align 8
  %81 = getelementptr i8, ptr %79, i64 8
  %82 = load i160, ptr %81, align 4
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %84 = call { ptr } %75(ptr %.fca.1.extract9) #36
  %.fca.0.extract51 = extractvalue { ptr } %84, 0
  %85 = getelementptr i8, ptr %.fca.0.extract51, i64 %78
  store ptr %.sroa.0.0564, ptr %85, align 8
  %86 = getelementptr i8, ptr %85, i64 8
  %87 = ptrtoint ptr %32 to i64
  %88 = ptrtoint ptr %34 to i64
  store i64 %87, ptr %86, align 4
  %.sroa_idx161 = getelementptr i8, ptr %85, i64 16
  store i64 %88, ptr %.sroa_idx161, align 4
  %.sroa_idx162 = getelementptr i8, ptr %85, i64 24
  store i32 %.sroa.17.0561, ptr %.sroa_idx162, align 4
  %89 = icmp ne ptr %80, @nil_typ
  %90 = icmp ne ptr %80, null
  %.not90 = and i1 %89, %90
  %extract607 = lshr i160 %82, 64
  %91 = insertelement <2 x i160> poison, i160 %82, i64 0
  %92 = insertelement <2 x i160> %91, i160 %extract607, i64 1
  br i1 %.not90, label %.cont.cont, label %99

.cont.cont:                                       ; preds = %68, %43
  %vptr.i142.sroa.speculated = phi ptr [ %55, %43 ], [ %80, %68 ]
  %.in = phi <2 x i160> [ %67, %43 ], [ %92, %68 ]
  %93 = trunc <2 x i160> %.in to <2 x i64>
  %94 = inttoptr <2 x i64> %93 to <2 x ptr>
  %95 = xor i1 %.070565, true
  %hash_coef_ptr.i.i143 = getelementptr i8, ptr %vptr.i142.sroa.speculated, i64 8
  %tbl_size_ptr.i.i144 = getelementptr i8, ptr %vptr.i142.sroa.speculated, i64 16
  %offset_tbl_ptr.i.i145 = getelementptr i8, ptr %vptr.i142.sroa.speculated, i64 40
  %hash_coef.i.i146 = load i64, ptr %hash_coef_ptr.i.i143, align 4
  %tbl_size.i.i147 = load i64, ptr %tbl_size_ptr.i.i144, align 4
  %offset_tbl.i.i148 = load ptr, ptr %offset_tbl_ptr.i.i145, align 8
  %product.i.i.i149 = mul i64 %hash_coef.i.i146, 4015701072841558310
  %shifted.i.i.i150 = lshr i64 %product.i.i.i149, 32
  %xored.i.i.i151 = xor i64 %shifted.i.i.i150, %product.i.i.i149
  %hash.i.i.i152 = and i64 %xored.i.i.i151, %tbl_size.i.i147
  %offset_ptr.i.i153 = getelementptr i32, ptr %offset_tbl.i.i148, i64 %hash.i.i.i152
  %offset.i.i154 = load i32, ptr %offset_ptr.i.i153, align 4
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull align 16 dereferenceable(784) @HashMap) #38
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %4) #34
  %98 = icmp ult i32 %.0566, 99
  br i1 %98, label %28, label %._crit_edge

99:                                               ; preds = %68, %43
  %100 = phi ptr [ %10, %68 ], [ %7, %43 ]
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %102 = getelementptr i8, ptr %13, i64 48
  %103 = load ptr, ptr %102, align 8
  %104 = load ptr, ptr %103, align 8
  %105 = call i32 %104(ptr %.fca.1.extract9) #36
  store i32 %105, ptr %100, align 4
  %106 = add i32 %105, 1
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %108 = getelementptr i8, ptr %103, i64 8
  %109 = load ptr, ptr %108, align 8
  call void %109(ptr %.fca.1.extract9, i32 %106) #35
  br label %112

._crit_edge:                                      ; preds = %.cont.cont
  %.sroa.17.8.insert.ext = zext i32 %offset.i.i154 to i160
  %.sroa.17.8.insert.shift = shl nuw i160 %.sroa.17.8.insert.ext, 128
  %110 = extractelement <2 x i64> %93, i64 1
  %.sroa.12.8.insert.ext = zext i64 %110 to i160
  %.sroa.12.8.insert.shift = shl nuw nsw i160 %.sroa.12.8.insert.ext, 64
  %.sroa.12.8.insert.insert = or disjoint i160 %.sroa.17.8.insert.shift, %.sroa.12.8.insert.shift
  %111 = extractelement <2 x i64> %93, i64 0
  %.sroa.6.8.insert.ext = zext i64 %111 to i160
  %.sroa.6.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.insert, %.sroa.6.8.insert.ext
  br label %112

112:                                              ; preds = %._crit_edge, %99
  %.reg2mem141.sroa.3.0 = phi i160 [ undef, %99 ], [ %.sroa.6.8.insert.insert, %._crit_edge ]
  %.reg2mem141.sroa.0.0 = phi ptr [ @nil_typ, %99 ], [ %vptr.i142.sroa.speculated, %._crit_edge ]
  %.reload142.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem141.sroa.0.0, 0
  %.reload142.fca.1.insert = insertvalue { ptr, i160 } %.reload142.fca.0.insert, i160 %.reg2mem141.sroa.3.0, 1
  ret { ptr, i160 } %.reload142.fca.1.insert
}

; Function Attrs: nounwind
define void @HashMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4) #7 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %8 = icmp sgt i32 %4, 0
  br i1 %8, label %.lr.ph, label %._crit_edge2._crit_edge

.lr.ph:                                           ; preds = %5
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !521
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !521
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !521
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !521
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = sext i32 %offset.i.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract4, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = getelementptr i8, ptr %14, i64 120
  br label %17

17:                                               ; preds = %.lr.ph, %._crit_edge
  %.060 = phi i32 [ 0, %.lr.ph ], [ %46, %._crit_edge ]
  %18 = zext nneg i32 %.060 to i64
  %19 = shl nuw nsw i64 %18, 5
  %20 = getelementptr i8, ptr %.fca.0.extract, i64 %19
  %21 = load ptr, ptr %20, align 8
  %22 = icmp ne ptr %21, @nil_typ
  %23 = icmp ne ptr %21, null
  %.not16 = and i1 %22, %23
  br i1 %.not16, label %24, label %._crit_edge

24:                                               ; preds = %17
  %25 = getelementptr i8, ptr %20, i64 8
  %26 = load i64, ptr %25, align 4
  %.sroa_idx = getelementptr i8, ptr %20, i64 16
  %27 = load i64, ptr %.sroa_idx, align 4
  %28 = inttoptr i64 %26 to ptr
  %29 = inttoptr i64 %27 to ptr
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %21, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %21, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %21, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4015701072841558310
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !524
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %28, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %29, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %offset.i.i43, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract4) #38
  %35 = load ptr, ptr %14, align 8
  %result.i = call ptr %35(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract4) #38
  %37 = load ptr, ptr %15, align 8
  %result.i45 = call ptr %37(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i46 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %38 = getelementptr inbounds i8, ptr %result.i46, i64 16
  store ptr %result.i45, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %result.i46, i64 8
  store ptr %result.i, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i46, i64 24
  store ptr null, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i46) #38
  store ptr @Entry, ptr %result.i46, align 8
  store ptr %result.i46, ptr %6, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #38
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract4) #38
  %44 = load ptr, ptr %16, align 8
  store ptr %21, ptr %7, align 8
  %result.i47 = call ptr %44({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %7) #15
  %45 = call { ptr, i160 } %result.i47({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %6, { ptr, ptr, ptr, i32 } %33) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %24, %17
  %46 = add nuw nsw i32 %.060, 1
  %47 = icmp slt i32 %46, %4
  br i1 %47, label %17, label %._crit_edge2._crit_edge

._crit_edge2._crit_edge:                          ; preds = %._crit_edge, %5
  ret void
}

; Function Attrs: nounwind
define void @HashMap_resize_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
._crit_edge:
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !527
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !527
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !527
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !527
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract14, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call { ptr } %12(ptr %.fca.1.extract) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #34
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call { ptr } %17(ptr %.fca.1.extract) #36
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #34
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = tail call i32 %22(ptr %.fca.1.extract) #36
  %24 = shl i32 %23, 1
  %spec.select = tail call i32 @llvm.smax.i32(i32 %24, i32 16)
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #40
  %26 = getelementptr i8, ptr %21, i64 8
  %27 = load ptr, ptr %26, align 8
  tail call void %27(ptr %.fca.1.extract, i32 %spec.select) #35
  %28 = zext nneg i32 %spec.select to i64
  %29 = shl nuw nsw i64 %28, 5
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %29, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #40
  %31 = load ptr, ptr %10, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %33(ptr %.fca.1.extract, { ptr } %34) #35
  %result.i20 = tail call noalias ptr @bump_malloc_inner(i64 noundef %29, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #40
  %36 = load ptr, ptr %15, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %39 = insertvalue { ptr } undef, ptr %result.i20, 0
  tail call void %38(ptr %.fca.1.extract, { ptr } %39) #35
  %40 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #40
  %41 = getelementptr i8, ptr %9, i64 48
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  tail call void %44(ptr %.fca.1.extract, i32 0) #35
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.1.extract, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.2.extract, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %offset.i.i, 3
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %3, align 8
  %49 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_Ptri32, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3) #40
  %51 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #40
  %52 = getelementptr i8, ptr %9, i64 128
  %53 = load ptr, ptr %52, align 8
  store ptr @buffer_typ, ptr %4, align 8
  %54 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %54, align 8
  %result.i21 = call ptr %53({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %4) #15
  call void %result.i21({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %3, { ptr } %13, i32 %23) #7
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %5, align 8
  %55 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_Ptri32, ptr %55, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5) #40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract14) #40
  %58 = load ptr, ptr %52, align 8
  store ptr @buffer_typ, ptr %6, align 8
  %59 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %59, align 8
  %result.i22 = call ptr %58({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %6) #15
  call void %result.i22({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %5, { ptr } %18, i32 %23) #7
  ret void
}

define noundef i1 @HashMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5, i32 %6, { ptr } %7) {
  %9 = alloca [0 x ptr], align 8
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !530
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !530
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !530
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !530
  %.fca.0.extract = extractvalue { ptr } %7, 0
  %10 = sext i32 %6 to i64
  %11 = shl nsw i64 %10, 5
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %12, i64 8
  %15 = icmp ne ptr %13, @nil_typ
  %16 = icmp ne ptr %13, null
  %.not64 = and i1 %15, %16
  br i1 %.not64, label %17, label %._crit_edge.thread

17:                                               ; preds = %8
  %18 = load i64, ptr %14, align 4
  %.sroa_idx = getelementptr i8, ptr %12, i64 16
  %19 = load i64, ptr %.sroa_idx, align 4
  %20 = inttoptr i64 %18 to ptr
  %21 = inttoptr i64 %19 to ptr
  %hash_coef_ptr.i.i66 = getelementptr i8, ptr %13, i64 8
  %tbl_size_ptr.i.i67 = getelementptr i8, ptr %13, i64 16
  %offset_tbl_ptr.i.i68 = getelementptr i8, ptr %13, i64 40
  %hash_coef.i.i69 = load i64, ptr %hash_coef_ptr.i.i66, align 4, !noalias !533
  %tbl_size.i.i70 = load i64, ptr %tbl_size_ptr.i.i67, align 4, !noalias !533
  %offset_tbl.i.i71 = load ptr, ptr %offset_tbl_ptr.i.i68, align 8, !noalias !533
  %product.i.i.i72 = mul i64 %hash_coef.i.i69, 4015701072841558310
  %shifted.i.i.i73 = lshr i64 %product.i.i.i72, 32
  %xored.i.i.i74 = xor i64 %shifted.i.i.i73, %product.i.i.i72
  %hash.i.i.i75 = and i64 %xored.i.i.i74, %tbl_size.i.i70
  %offset_ptr.i.i76 = getelementptr i32, ptr %offset_tbl.i.i71, i64 %hash.i.i.i75
  %offset.i.i77 = load i32, ptr %offset_ptr.i.i76, align 4, !noalias !533
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %21, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i77, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9) #34
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13) #34
  %28 = sext i32 %offset.i.i77 to i64
  %29 = getelementptr ptr, ptr %13, i64 %28
  %30 = getelementptr i8, ptr %29, i64 64
  %31 = load ptr, ptr %30, align 8
  %result.i = call ptr %31({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly %9) #15
  %32 = call i32 %result.i({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %9) #7
  %33 = icmp eq i32 %32, %5
  br i1 %33, label %._crit_edge, label %._crit_edge.thread

._crit_edge:                                      ; preds = %17
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13)
  %36 = getelementptr i8, ptr %29, i64 48
  %37 = load ptr, ptr %36, align 8
  %result.i79 = call ptr %37({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly %9) #15
  %38 = call { ptr, i160 } %result.i79({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %9) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract20)
  %40 = sext i32 %offset.i.i to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract20, i64 %40
  %42 = getelementptr i8, ptr %41, i64 64
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr } %44(ptr %.fca.1.extract21) #36
  %.fca.0.extract47 = extractvalue { ptr } %45, 0
  %46 = call i1 %.fca.0.extract47({ ptr, i160 } %38, { ptr, i160 } %3)
  br i1 %46, label %47, label %._crit_edge.thread

47:                                               ; preds = %._crit_edge
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract20)
  %49 = load ptr, ptr %41, align 8
  %result.i80 = call ptr %49(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract21) #5
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract20)
  %51 = getelementptr i8, ptr %41, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i81 = call ptr %52(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract21) #5
  %53 = load ptr, ptr %result.i80, align 8, !alias.scope !536
  %54 = getelementptr i8, ptr %53, i64 72
  %55 = load ptr, ptr %54, align 8, !alias.scope !536
  %result.i.i = call { i64, i64 } %55(ptr nocapture nofree nonnull readonly %result.i80) #5, !alias.scope !536
  %56 = extractvalue { i64, i64 } %result.i.i, 0
  %57 = extractvalue { i64, i64 } %result.i.i, 1
  %58 = urem i64 20, %57
  %59 = icmp eq i64 %58, 0
  %60 = sub i64 %57, %58
  %61 = select i1 %59, i64 0, i64 %60
  %62 = add i64 %56, 20
  %63 = add i64 %62, %61
  %64 = load ptr, ptr %result.i81, align 8, !alias.scope !536
  %65 = getelementptr i8, ptr %64, i64 72
  %66 = load ptr, ptr %65, align 8, !alias.scope !536
  %result.i1.i = call { i64, i64 } %66(ptr nocapture nofree nonnull readonly %result.i81) #5, !alias.scope !536
  %67 = extractvalue { i64, i64 } %result.i1.i, 0
  %68 = extractvalue { i64, i64 } %result.i1.i, 1
  %69 = call i64 @llvm.umax.i64(i64 %57, i64 %68)
  %70 = call i64 @llvm.umax.i64(i64 %69, i64 8)
  %71 = urem i64 %63, %68
  %72 = icmp eq i64 %71, 0
  %73 = sub i64 %68, %71
  %74 = select i1 %72, i64 0, i64 %73
  %75 = add i64 %67, %63
  %76 = add i64 %75, %74
  %77 = urem i64 %76, %70
  %78 = icmp eq i64 %77, 0
  %79 = sub i64 %70, %77
  %80 = select i1 %78, i64 0, i64 %79
  %81 = add i64 %80, %76
  %result.i83 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %81, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i80, ptr %result.i83, align 8
  %82 = getelementptr inbounds i8, ptr %result.i83, i64 8
  store ptr %result.i81, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83)
  %84 = load ptr, ptr %result.i80, align 8
  %85 = getelementptr i8, ptr %84, i64 72
  %86 = load ptr, ptr %85, align 8
  %result.i.i114 = call { i64, i64 } %86(ptr nocapture nofree nonnull readonly %result.i80) #5
  %87 = extractvalue { i64, i64 } %result.i.i114, 1
  %88 = urem i64 20, %87
  %89 = icmp eq i64 %88, 0
  %reass.sub = sub i64 %87, %88
  %90 = add i64 %reass.sub, 20
  %91 = select i1 %89, i64 20, i64 %90
  %92 = getelementptr i8, ptr %result.i83, i64 %91
  %93 = getelementptr i8, ptr %84, i64 64
  %94 = load ptr, ptr %93, align 8
  call void %94({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly %result.i80, ptr nocapture nofree writeonly %92) #12
  %95 = load ptr, ptr %result.i83, align 8
  %96 = load ptr, ptr %95, align 8
  %97 = getelementptr i8, ptr %96, i64 72
  %98 = load ptr, ptr %97, align 8
  %result.i.i115 = call { i64, i64 } %98(ptr nocapture nofree nonnull readonly %95) #5
  %99 = extractvalue { i64, i64 } %result.i.i115, 0
  %100 = extractvalue { i64, i64 } %result.i.i115, 1
  %101 = urem i64 20, %100
  %102 = icmp eq i64 %101, 0
  %103 = sub i64 %100, %101
  %104 = select i1 %102, i64 0, i64 %103
  %105 = add i64 %99, 20
  %106 = add i64 %105, %104
  %107 = load ptr, ptr %82, align 8
  %108 = load ptr, ptr %107, align 8
  %109 = getelementptr i8, ptr %108, i64 72
  %110 = load ptr, ptr %109, align 8
  %result.i1.i116 = call { i64, i64 } %110(ptr nocapture nofree nonnull readonly %107) #5
  %111 = extractvalue { i64, i64 } %result.i1.i116, 1
  %112 = urem i64 %106, %111
  %113 = icmp eq i64 %112, 0
  %114 = sub i64 %111, %112
  %115 = select i1 %113, i64 0, i64 %114
  %116 = getelementptr i8, ptr %result.i83, i64 %106
  %117 = getelementptr i8, ptr %116, i64 %115
  %118 = getelementptr i8, ptr %108, i64 64
  %119 = load ptr, ptr %118, align 8
  call void %119({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly %107, ptr nocapture nofree writeonly %117) #12
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %121 = getelementptr inbounds i8, ptr %result.i83, i64 16
  store i32 %5, ptr %121, align 8
  store ptr @Entry, ptr %12, align 8
  %122 = ptrtoint ptr %result.i83 to i64
  store i64 %122, ptr %14, align 4
  %.sroa_idx28 = getelementptr i8, ptr %12, i64 24
  store i32 10, ptr %.sroa_idx28, align 4
  br label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %17, %8, %47, %._crit_edge
  %.reg2mem41.0 = phi i1 [ false, %._crit_edge ], [ true, %47 ], [ false, %8 ], [ false, %17 ]
  ret i1 %.reg2mem41.0
}

define { ptr, i160 } @HashMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !539
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !539
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !539
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !539
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 5
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = icmp ne ptr %12, @nil_typ
  %14 = icmp ne ptr %12, null
  %.not44 = and i1 %13, %14
  br i1 %.not44, label %15, label %.thread

15:                                               ; preds = %7
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load i64, ptr %16, align 4
  %.sroa_idx = getelementptr i8, ptr %11, i64 16
  %18 = load i64, ptr %.sroa_idx, align 4
  %19 = inttoptr i64 %17 to ptr
  %20 = inttoptr i64 %18 to ptr
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %12, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %12, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %12, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !542
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !542
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !542
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4015701072841558310
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !542
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %12, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %19, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i57, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8) #34
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12) #34
  %27 = sext i32 %offset.i.i57 to i64
  %28 = getelementptr ptr, ptr %12, i64 %27
  %29 = getelementptr i8, ptr %28, i64 64
  %30 = load ptr, ptr %29, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #15
  %31 = call i32 %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %32 = icmp eq i32 %31, %4
  br i1 %32, label %._crit_edge, label %.thread

._crit_edge:                                      ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12)
  %35 = getelementptr i8, ptr %28, i64 48
  %36 = load ptr, ptr %35, align 8
  %result.i59 = call ptr %36({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #15
  %37 = call { ptr, i160 } %result.i59({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract13)
  %39 = sext i32 %offset.i.i to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract13, i64 %39
  %41 = getelementptr i8, ptr %40, i64 64
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract14) #36
  %.fca.0.extract27 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract27({ ptr, i160 } %37, { ptr, i160 } %3)
  br i1 %45, label %46, label %.thread

46:                                               ; preds = %._crit_edge
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12)
  %49 = getelementptr i8, ptr %28, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i60 = call ptr %50({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #15
  %51 = call { ptr, i160 } %result.i60({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %.fca.0.extract21 = extractvalue { ptr, i160 } %51, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %51, 1
  br label %.thread

.thread:                                          ; preds = %15, %7, %._crit_edge, %46
  %.reg2mem43.sroa.3.077 = phi i160 [ %.fca.1.extract22, %46 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %15 ]
  %52 = phi ptr [ %.fca.0.extract21, %46 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %15 ]
  %.reload40.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %52, 0
  %.reload40.fca.1.insert = insertvalue { ptr, i160 } %.reload40.fca.0.insert, i160 %.reg2mem43.sroa.3.077, 1
  ret { ptr, i160 } %.reload40.fca.1.insert
}

define { ptr, i160 } @HashMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !545
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !545
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !545
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !545
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 5
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = icmp ne ptr %12, @nil_typ
  %14 = icmp ne ptr %12, null
  %.not51 = and i1 %13, %14
  br i1 %.not51, label %15, label %.thread

15:                                               ; preds = %7
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load i64, ptr %16, align 4
  %.sroa_idx = getelementptr i8, ptr %11, i64 16
  %18 = load i64, ptr %.sroa_idx, align 4
  %19 = inttoptr i64 %17 to ptr
  %20 = inttoptr i64 %18 to ptr
  %hash_coef_ptr.i.i53 = getelementptr i8, ptr %12, i64 8
  %tbl_size_ptr.i.i54 = getelementptr i8, ptr %12, i64 16
  %offset_tbl_ptr.i.i55 = getelementptr i8, ptr %12, i64 40
  %hash_coef.i.i56 = load i64, ptr %hash_coef_ptr.i.i53, align 4, !noalias !548
  %tbl_size.i.i57 = load i64, ptr %tbl_size_ptr.i.i54, align 4, !noalias !548
  %offset_tbl.i.i58 = load ptr, ptr %offset_tbl_ptr.i.i55, align 8, !noalias !548
  %product.i.i.i59 = mul i64 %hash_coef.i.i56, 4015701072841558310
  %shifted.i.i.i60 = lshr i64 %product.i.i.i59, 32
  %xored.i.i.i61 = xor i64 %shifted.i.i.i60, %product.i.i.i59
  %hash.i.i.i62 = and i64 %xored.i.i.i61, %tbl_size.i.i57
  %offset_ptr.i.i63 = getelementptr i32, ptr %offset_tbl.i.i58, i64 %hash.i.i.i62
  %offset.i.i64 = load i32, ptr %offset_ptr.i.i63, align 4, !noalias !548
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %12, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %19, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i64, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8) #34
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12) #34
  %27 = sext i32 %offset.i.i64 to i64
  %28 = getelementptr ptr, ptr %12, i64 %27
  %29 = getelementptr i8, ptr %28, i64 64
  %30 = load ptr, ptr %29, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #15
  %31 = call i32 %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %32 = icmp eq i32 %31, %4
  br i1 %32, label %._crit_edge, label %.thread

._crit_edge:                                      ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12)
  %35 = getelementptr i8, ptr %28, i64 48
  %36 = load ptr, ptr %35, align 8
  %result.i66 = call ptr %36({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #15
  %37 = call { ptr, i160 } %result.i66({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract15)
  %39 = sext i32 %offset.i.i to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract15, i64 %39
  %41 = getelementptr i8, ptr %40, i64 64
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract16) #36
  %.fca.0.extract34 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract34({ ptr, i160 } %37, { ptr, i160 } %3)
  br i1 %45, label %46, label %.thread

46:                                               ; preds = %._crit_edge
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12)
  %49 = getelementptr i8, ptr %28, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i67 = call ptr %50({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #15
  %51 = call { ptr, i160 } %result.i67({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %.fca.0.extract28 = extractvalue { ptr, i160 } %51, 0
  %.fca.1.extract29 = extractvalue { ptr, i160 } %51, 1
  store ptr @nil_typ, ptr %11, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract15)
  %53 = getelementptr i8, ptr %40, i64 48
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call i32 %55(ptr %.fca.1.extract16) #36
  %57 = add i32 %56, -1
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract15)
  %59 = getelementptr i8, ptr %54, i64 8
  %60 = load ptr, ptr %59, align 8
  call void %60(ptr %.fca.1.extract16, i32 %57) #35
  br label %.thread

.thread:                                          ; preds = %15, %7, %._crit_edge, %46
  %.reg2mem47.sroa.3.088 = phi i160 [ %.fca.1.extract29, %46 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %15 ]
  %61 = phi ptr [ %.fca.0.extract28, %46 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %15 ]
  %.reload44.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %61, 0
  %.reload44.fca.1.insert = insertvalue { ptr, i160 } %.reload44.fca.0.insert, i160 %.reg2mem47.sroa.3.088, 1
  ret { ptr, i160 } %.reload44.fca.1.insert
}

define void @HashMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) {
  %6 = alloca [0 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [5 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract29 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract20 = extractvalue { ptr, i160 } %4, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract34, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract35, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i, 3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract34) #38
  %18 = sext i32 %offset.i.i to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract34, i64 %18
  %20 = load ptr, ptr %19, align 8
  %result.i = tail call ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %21 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21) #38
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract34) #38
  %24 = getelementptr i8, ptr %19, i64 88
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr }, align 8
  store ptr %.fca.0.extract29, ptr %26, align 8
  %result.i75 = call ptr %25({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %26) #15
  %27 = call i32 %result.i75({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %21, { ptr, i160 } %3) #7
  %28 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract34)
  %31 = getelementptr i8, ptr %19, i64 104
  %32 = load ptr, ptr %31, align 8
  %33 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %33, align 8
  %result.i76 = call ptr %32({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %33) #15
  %34 = call i32 %result.i76({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %28, i32 %27) #7
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract34)
  %36 = getelementptr i8, ptr %19, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr %.fca.1.extract35) #36
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract34)
  %41 = getelementptr i8, ptr %19, i64 8
  %42 = load ptr, ptr %41, align 8
  %result.i77 = call ptr %42(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %43 = alloca [5 x ptr], align 8
  store ptr %result.i, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %43, i64 8
  store ptr %result.i77, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %43, i64 16
  store ptr @_parameterization_Ptri32, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %43, i64 24
  store ptr @_parameterization_Ptri32, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %43, i64 32
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %43)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract34)
  %50 = getelementptr i8, ptr %19, i64 144
  %51 = load ptr, ptr %50, align 8
  %52 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract29, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %52, i64 8
  store ptr %.fca.0.extract20, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %52, i64 16
  store ptr @i32_typ, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %52, i64 24
  store ptr @i32_typ, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %52, i64 32
  store ptr @buffer_typ, ptr %56, align 8
  %result.i78 = call ptr %51({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %52) #15
  %57 = call i1 %result.i78({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(40) %43, { ptr, i160 } %3, { ptr, i160 } %4, i32 %27, i32 %34, { ptr } %39) #7
  br i1 %57, label %.thread, label %58

58:                                               ; preds = %5
  store ptr @_parameterization_Ptri32, ptr %7, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %61 = getelementptr i8, ptr %19, i64 112
  %62 = load ptr, ptr %61, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i79 = call ptr %62({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %8) #15
  %63 = call i32 %result.i79({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %7, i32 %27) #7
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %65 = getelementptr i8, ptr %19, i64 32
  %66 = load ptr, ptr %65, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr } %67(ptr %.fca.1.extract35) #36
  store ptr %result.i, ptr %9, align 8
  %69 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %result.i77, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @_parameterization_Ptri32, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @_parameterization_Ptri32, ptr %71, align 8
  %72 = getelementptr inbounds i8, ptr %9, i64 32
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %9)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %75 = load ptr, ptr %50, align 8
  store ptr %.fca.0.extract29, ptr %10, align 8
  %76 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.0.extract20, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @i32_typ, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %10, i64 24
  store ptr @i32_typ, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %10, i64 32
  store ptr @buffer_typ, ptr %79, align 8
  %result.i80 = call ptr %75({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %10) #15
  %80 = call i1 %result.i80({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(40) %9, { ptr, i160 } %3, { ptr, i160 } %4, i32 %27, i32 %63, { ptr } %68) #7
  br i1 %80, label %.thread, label %81

81:                                               ; preds = %58
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %83 = getelementptr i8, ptr %19, i64 48
  %84 = load ptr, ptr %83, align 8
  %85 = load ptr, ptr %84, align 8
  %86 = call i32 %85(ptr %.fca.1.extract35) #36
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %88 = getelementptr i8, ptr %19, i64 40
  %89 = load ptr, ptr %88, align 8
  %90 = load ptr, ptr %89, align 8
  %91 = call i32 %90(ptr %.fca.1.extract35) #36
  %.not = icmp slt i32 %86, %91
  br i1 %.not, label %._crit_edge, label %92

92:                                               ; preds = %81
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %95 = getelementptr i8, ptr %19, i64 136
  %96 = load ptr, ptr %95, align 8
  %result.i81 = call ptr %96({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %6) #15
  call void %result.i81({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %81, %92
  %97 = load ptr, ptr %result.i, align 8
  %98 = getelementptr i8, ptr %97, i64 72
  %99 = load ptr, ptr %98, align 8
  %result.i.i = call { i64, i64 } %99(ptr nocapture nofree nonnull readonly %result.i) #5
  %100 = extractvalue { i64, i64 } %result.i.i, 0
  %101 = extractvalue { i64, i64 } %result.i.i, 1
  %102 = urem i64 20, %101
  %103 = icmp eq i64 %102, 0
  %104 = sub i64 %101, %102
  %105 = select i1 %103, i64 0, i64 %104
  %106 = add i64 %100, 20
  %107 = add i64 %106, %105
  %108 = load ptr, ptr %result.i77, align 8
  %109 = getelementptr i8, ptr %108, i64 72
  %110 = load ptr, ptr %109, align 8
  %result.i1.i = call { i64, i64 } %110(ptr nocapture nofree nonnull readonly %result.i77) #5
  %111 = extractvalue { i64, i64 } %result.i1.i, 0
  %112 = extractvalue { i64, i64 } %result.i1.i, 1
  %113 = call i64 @llvm.umax.i64(i64 %101, i64 %112)
  %114 = call i64 @llvm.umax.i64(i64 %113, i64 8)
  %115 = urem i64 %107, %112
  %116 = icmp eq i64 %115, 0
  %117 = sub i64 %112, %115
  %118 = select i1 %116, i64 0, i64 %117
  %119 = add i64 %111, %107
  %120 = add i64 %119, %118
  %121 = urem i64 %120, %114
  %122 = icmp eq i64 %121, 0
  %123 = sub i64 %114, %121
  %124 = select i1 %122, i64 0, i64 %123
  %125 = add i64 %124, %120
  %result.i83 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %125, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i83, align 8
  %126 = getelementptr inbounds i8, ptr %result.i83, i64 8
  store ptr %result.i77, ptr %126, align 8
  %127 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83)
  %128 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i83, 1
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr undef, 2
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, i32 10, 3
  %131 = load ptr, ptr %result.i, align 8
  %132 = getelementptr i8, ptr %131, i64 72
  %133 = load ptr, ptr %132, align 8
  %result.i.i179 = call { i64, i64 } %133(ptr nocapture nofree nonnull readonly %result.i) #5
  %134 = extractvalue { i64, i64 } %result.i.i179, 1
  %135 = urem i64 20, %134
  %136 = icmp eq i64 %135, 0
  %reass.sub = sub i64 %134, %135
  %137 = add i64 %reass.sub, 20
  %138 = select i1 %136, i64 20, i64 %137
  %139 = getelementptr i8, ptr %result.i83, i64 %138
  %140 = getelementptr i8, ptr %131, i64 64
  %141 = load ptr, ptr %140, align 8
  call void %141({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %139) #12
  %142 = load ptr, ptr %result.i83, align 8
  %143 = load ptr, ptr %142, align 8
  %144 = getelementptr i8, ptr %143, i64 72
  %145 = load ptr, ptr %144, align 8
  %result.i.i180 = call { i64, i64 } %145(ptr nocapture nofree nonnull readonly %142) #5
  %146 = extractvalue { i64, i64 } %result.i.i180, 0
  %147 = extractvalue { i64, i64 } %result.i.i180, 1
  %148 = urem i64 20, %147
  %149 = icmp eq i64 %148, 0
  %150 = sub i64 %147, %148
  %151 = select i1 %149, i64 0, i64 %150
  %152 = add i64 %146, 20
  %153 = add i64 %152, %151
  %154 = load ptr, ptr %126, align 8
  %155 = load ptr, ptr %154, align 8
  %156 = getelementptr i8, ptr %155, i64 72
  %157 = load ptr, ptr %156, align 8
  %result.i1.i181 = call { i64, i64 } %157(ptr nocapture nofree nonnull readonly %154) #5
  %158 = extractvalue { i64, i64 } %result.i1.i181, 1
  %159 = urem i64 %153, %158
  %160 = icmp eq i64 %159, 0
  %161 = sub i64 %158, %159
  %162 = select i1 %160, i64 0, i64 %161
  %163 = getelementptr i8, ptr %result.i83, i64 %153
  %164 = getelementptr i8, ptr %163, i64 %162
  %165 = getelementptr i8, ptr %155, i64 64
  %166 = load ptr, ptr %165, align 8
  call void %166({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly %154, ptr nocapture nofree writeonly %164) #12
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #34
  %168 = getelementptr inbounds i8, ptr %result.i83, i64 16
  store i32 %27, ptr %168, align 8
  %169 = getelementptr i8, ptr %19, i64 120
  %170 = getelementptr i8, ptr %19, i64 136
  %result.i113 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i114 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %171 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %result.i77, ptr %171, align 8
  %172 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %result.i, ptr %172, align 8
  %173 = getelementptr inbounds i8, ptr %result.i114, i64 24
  store ptr null, ptr %173, align 8
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i114)
  store ptr @Entry, ptr %result.i114, align 8
  %175 = getelementptr inbounds i8, ptr %result.i113, i64 16
  store ptr %result.i114, ptr %175, align 8
  %176 = getelementptr inbounds i8, ptr %result.i113, i64 8
  store ptr @_parameterization_Nil, ptr %176, align 8
  %177 = getelementptr inbounds i8, ptr %result.i113, i64 24
  store ptr null, ptr %177, align 8
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i113)
  store ptr @union_typ, ptr %result.i113, align 8
  store ptr %result.i113, ptr %11, align 8
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %181 = load ptr, ptr %169, align 8
  store ptr @union_typ, ptr %12, align 8
  %result.i115 = call ptr %181({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %12) #15
  %182 = call { ptr, i160 } %result.i115({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %130) #7
  %.fca.0.extract41 = extractvalue { ptr, i160 } %182, 0
  %183 = icmp eq ptr %.fca.0.extract41, @nil_typ
  %184 = icmp eq ptr %.fca.0.extract41, null
  %185 = or i1 %183, %184
  br i1 %185, label %.thread, label %186

186:                                              ; preds = %._crit_edge
  %.fca.1.extract42 = extractvalue { ptr, i160 } %182, 1
  %187 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %189 = load ptr, ptr %170, align 8
  %result.i116 = call ptr %189({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %6) #15
  call void %result.i116({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #7
  %.sroa.3162.8.extract.trunc = trunc i160 %.fca.1.extract42 to i64
  %190 = inttoptr i64 %.sroa.3162.8.extract.trunc to ptr
  %.sroa.6.8.extract.shift = lshr i160 %.fca.1.extract42, 64
  %.sroa.6.8.extract.trunc = trunc i160 %.sroa.6.8.extract.shift to i64
  %191 = inttoptr i64 %.sroa.6.8.extract.trunc to ptr
  %hash_coef_ptr.i.i100.1 = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i.i101.1 = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i.i102.1 = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i.i103.1 = load i64, ptr %hash_coef_ptr.i.i100.1, align 4
  %tbl_size.i.i104.1 = load i64, ptr %tbl_size_ptr.i.i101.1, align 4
  %offset_tbl.i.i105.1 = load ptr, ptr %offset_tbl_ptr.i.i102.1, align 8
  %product.i.i.i106.1 = mul i64 %hash_coef.i.i103.1, 4015701072841558310
  %shifted.i.i.i107.1 = lshr i64 %product.i.i.i106.1, 32
  %xored.i.i.i108.1 = xor i64 %shifted.i.i.i107.1, %product.i.i.i106.1
  %hash.i.i.i109.1 = and i64 %xored.i.i.i108.1, %tbl_size.i.i104.1
  %offset_ptr.i.i110.1 = getelementptr i32, ptr %offset_tbl.i.i105.1, i64 %hash.i.i.i109.1
  %offset.i.i111.1 = load i32, ptr %offset_ptr.i.i110.1, align 4
  %192 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %193 = insertvalue { ptr, ptr, ptr, i32 } %192, ptr %190, 1
  %194 = insertvalue { ptr, ptr, ptr, i32 } %193, ptr %191, 2
  %195 = insertvalue { ptr, ptr, ptr, i32 } %194, i32 %offset.i.i111.1, 3
  %result.i113.1 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i114.1 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %196 = getelementptr inbounds i8, ptr %result.i114.1, i64 16
  store ptr %result.i77, ptr %196, align 8
  %197 = getelementptr inbounds i8, ptr %result.i114.1, i64 8
  store ptr %result.i, ptr %197, align 8
  %198 = getelementptr inbounds i8, ptr %result.i114.1, i64 24
  store ptr null, ptr %198, align 8
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i114.1)
  store ptr @Entry, ptr %result.i114.1, align 8
  %200 = getelementptr inbounds i8, ptr %result.i113.1, i64 16
  store ptr %result.i114.1, ptr %200, align 8
  %201 = getelementptr inbounds i8, ptr %result.i113.1, i64 8
  store ptr @_parameterization_Nil, ptr %201, align 8
  %202 = getelementptr inbounds i8, ptr %result.i113.1, i64 24
  store ptr null, ptr %202, align 8
  %203 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i113.1)
  store ptr @union_typ, ptr %result.i113.1, align 8
  store ptr %result.i113.1, ptr %11, align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %206 = load ptr, ptr %169, align 8
  store ptr @union_typ, ptr %12, align 8
  %result.i115.1 = call ptr %206({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %12) #15
  %207 = call { ptr, i160 } %result.i115.1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %195) #7
  %.fca.0.extract41.1 = extractvalue { ptr, i160 } %207, 0
  %208 = icmp eq ptr %.fca.0.extract41.1, @nil_typ
  %209 = icmp eq ptr %.fca.0.extract41.1, null
  %210 = or i1 %208, %209
  br i1 %210, label %.thread, label %211

211:                                              ; preds = %186
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %213 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %214 = load ptr, ptr %170, align 8
  %result.i116.1 = call ptr %214({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %6) #15
  call void %result.i116.1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #7
  br label %.thread

.thread:                                          ; preds = %._crit_edge, %186, %211, %58, %5
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @HashMap_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !551
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !551
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !551
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !551
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract31, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract32, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31) #34
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract31, i64 %14
  %16 = load ptr, ptr %15, align 8
  %result.i = tail call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #5
  %17 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17) #34
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31) #34
  %20 = getelementptr i8, ptr %15, i64 88
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %22, align 8
  %result.i68 = call ptr %21({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %22) #15
  %23 = call i32 %result.i68({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %17, { ptr, i160 } %3) #7
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31)
  %27 = getelementptr i8, ptr %15, i64 104
  %28 = load ptr, ptr %27, align 8
  %29 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %29, align 8
  %result.i69 = call ptr %28({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %29) #15
  %30 = call i32 %result.i69({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %24, i32 %23) #7
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31)
  %32 = getelementptr i8, ptr %15, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr %.fca.1.extract32) #36
  %36 = alloca [4 x ptr], align 8
  store ptr %result.i, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr @_parameterization_Ptri32, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr @_parameterization_Ptri32, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %36)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31)
  %42 = getelementptr i8, ptr %15, i64 152
  %43 = load ptr, ptr %42, align 8
  %44 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %44, i64 8
  store ptr @i32_typ, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 16
  store ptr @i32_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %44, i64 24
  store ptr @buffer_typ, ptr %47, align 8
  %result.i70 = call ptr %43({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %44) #15
  %48 = call { ptr, i160 } %result.i70({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %36, { ptr, i160 } %3, i32 %23, i32 %30, { ptr } %35) #7
  %.fca.0.extract = extractvalue { ptr, i160 } %48, 0
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31)
  %50 = icmp ne ptr %.fca.0.extract, @nil_typ
  %51 = icmp ne ptr %.fca.0.extract, null
  %.not63 = and i1 %50, %51
  br i1 %.not63, label %.thread, label %52

52:                                               ; preds = %4
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %55 = getelementptr i8, ptr %15, i64 112
  %56 = load ptr, ptr %55, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i71 = call ptr %56({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %6) #15
  %57 = call i32 %result.i71({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %5, i32 %23) #7
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %59 = getelementptr i8, ptr %15, i64 32
  %60 = load ptr, ptr %59, align 8
  %61 = load ptr, ptr %60, align 8
  %62 = call { ptr } %61(ptr %.fca.1.extract32) #36
  store ptr %result.i, ptr %7, align 8
  %63 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_Ptri32, ptr %63, align 8
  %64 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_Ptri32, ptr %64, align 8
  %65 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %65, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %68 = load ptr, ptr %42, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %69 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %71, align 8
  %result.i72 = call ptr %68({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %8) #15
  %72 = call { ptr, i160 } %result.i72({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %7, { ptr, i160 } %3, i32 %23, i32 %57, { ptr } %62) #7
  %.fca.0.extract51 = extractvalue { ptr, i160 } %72, 0
  %73 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %74 = icmp ne ptr %.fca.0.extract51, null
  %.not65.not.not = and i1 %73, %74
  %cond.fr = freeze i1 %.not65.not.not
  %spec.select = select i1 %cond.fr, ptr %.fca.0.extract51, ptr @nil_typ
  br label %.thread

.thread:                                          ; preds = %52, %4
  %.pn = phi { ptr, i160 } [ %48, %4 ], [ %72, %52 ]
  %75 = phi ptr [ %.fca.0.extract, %4 ], [ %spec.select, %52 ]
  %.fca.1.extract..sroa.354.0101 = extractvalue { ptr, i160 } %.pn, 1
  %.reload55.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %75, 0
  %.reload55.fca.1.insert = insertvalue { ptr, i160 } %.reload55.fca.0.insert, i160 %.fca.1.extract..sroa.354.0101, 1
  ret { ptr, i160 } %.reload55.fca.1.insert
}

; Function Attrs: nounwind
define { ptr, i160 } @HashMap_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !554
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !554
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !554
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !554
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract31, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract32, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31) #34
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract31, i64 %14
  %16 = load ptr, ptr %15, align 8
  %result.i = tail call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #5
  %17 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17) #34
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31) #34
  %20 = getelementptr i8, ptr %15, i64 88
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %22, align 8
  %result.i68 = call ptr %21({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %22) #15
  %23 = call i32 %result.i68({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %17, { ptr, i160 } %3) #7
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31)
  %27 = getelementptr i8, ptr %15, i64 104
  %28 = load ptr, ptr %27, align 8
  %29 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %29, align 8
  %result.i69 = call ptr %28({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %29) #15
  %30 = call i32 %result.i69({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %24, i32 %23) #7
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31)
  %32 = getelementptr i8, ptr %15, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr %.fca.1.extract32) #36
  %36 = alloca [4 x ptr], align 8
  store ptr %result.i, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  store ptr @_parameterization_Ptri32, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  store ptr @_parameterization_Ptri32, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %36, i64 24
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %36)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31)
  %42 = getelementptr i8, ptr %15, i64 160
  %43 = load ptr, ptr %42, align 8
  %44 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %44, i64 8
  store ptr @i32_typ, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %44, i64 16
  store ptr @i32_typ, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %44, i64 24
  store ptr @buffer_typ, ptr %47, align 8
  %result.i70 = call ptr %43({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %44) #15
  %48 = call { ptr, i160 } %result.i70({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %36, { ptr, i160 } %3, i32 %23, i32 %30, { ptr } %35) #7
  %.fca.0.extract = extractvalue { ptr, i160 } %48, 0
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract31)
  %50 = icmp ne ptr %.fca.0.extract, @nil_typ
  %51 = icmp ne ptr %.fca.0.extract, null
  %.not63 = and i1 %50, %51
  br i1 %.not63, label %.thread, label %52

52:                                               ; preds = %4
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %55 = getelementptr i8, ptr %15, i64 112
  %56 = load ptr, ptr %55, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i71 = call ptr %56({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %6) #15
  %57 = call i32 %result.i71({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %5, i32 %23) #7
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %59 = getelementptr i8, ptr %15, i64 32
  %60 = load ptr, ptr %59, align 8
  %61 = load ptr, ptr %60, align 8
  %62 = call { ptr } %61(ptr %.fca.1.extract32) #36
  store ptr %result.i, ptr %7, align 8
  %63 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_Ptri32, ptr %63, align 8
  %64 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_Ptri32, ptr %64, align 8
  %65 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %65, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %68 = load ptr, ptr %42, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %69 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %71, align 8
  %result.i72 = call ptr %68({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %8) #15
  %72 = call { ptr, i160 } %result.i72({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %7, { ptr, i160 } %3, i32 %23, i32 %57, { ptr } %62) #7
  %.fca.0.extract51 = extractvalue { ptr, i160 } %72, 0
  %73 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %74 = icmp ne ptr %.fca.0.extract51, null
  %.not65.not.not = and i1 %73, %74
  %cond.fr = freeze i1 %.not65.not.not
  %spec.select = select i1 %cond.fr, ptr %.fca.0.extract51, ptr @nil_typ
  br label %.thread

.thread:                                          ; preds = %52, %4
  %.pn = phi { ptr, i160 } [ %48, %4 ], [ %72, %52 ]
  %75 = phi ptr [ %.fca.0.extract, %4 ], [ %spec.select, %52 ]
  %.fca.1.extract..sroa.354.0101 = extractvalue { ptr, i160 } %.pn, 1
  %.reload55.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %75, 0
  %.reload55.fca.1.insert = insertvalue { ptr, i160 } %.reload55.fca.0.insert, i160 %.fca.1.extract..sroa.354.0101, 1
  ret { ptr, i160 } %.reload55.fca.1.insert
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @HashMap_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !557
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !557
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !557
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !557
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 40
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  tail call void %10(ptr %.fca.1.extract, i32 8) #35
  %result.i = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract) #34
  %12 = getelementptr i8, ptr %6, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %15(ptr %.fca.1.extract, { ptr } %16) #35
  %result.i5 = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract) #34
  %18 = getelementptr i8, ptr %6, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr } undef, ptr %result.i5, 0
  tail call void %21(ptr %.fca.1.extract, { ptr } %22) #35
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract) #34
  %24 = getelementptr i8, ptr %6, i64 48
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  tail call void %27(ptr %.fca.1.extract, i32 0) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @HashMap_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !560
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !560
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !560
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !560
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 48
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @HashMap_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !563
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !563
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !563
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !563
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract13, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr } %9(ptr %.fca.1.extract) #36
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call { ptr } %14(ptr %.fca.1.extract) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %17 = getelementptr i8, ptr %6, i64 40
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call i32 %19(ptr %.fca.1.extract) #36
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %22 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %22(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %24 = getelementptr i8, ptr %6, i64 8
  %25 = load ptr, ptr %24, align 8
  %result.i14 = tail call ptr %25(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i15 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %26 = getelementptr inbounds i8, ptr %result.i15, i64 16
  store ptr %result.i14, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i15, i64 8
  store ptr %result.i, ptr %27, align 8
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i15) #34
  store ptr @Pair, ptr %result.i15, align 8
  %result.i17 = tail call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i17, align 8
  %29 = getelementptr inbounds i8, ptr %result.i17, i64 8
  store ptr %result.i14, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i17, i64 16
  store ptr %result.i15, ptr %30, align 8
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i17) #34
  %32 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %33 = load ptr, ptr %7, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = tail call { ptr } %34(ptr %.fca.1.extract) #36
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %37 = load ptr, ptr %12, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = tail call { ptr } %38(ptr %.fca.1.extract) #36
  %40 = tail call ptr @llvm.invariant.start.p0(i64 noundef 704, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %41 = load ptr, ptr %17, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = tail call i32 %42(ptr %.fca.1.extract) #36
  %44 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i17, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr undef, 2
  %46 = getelementptr inbounds i8, ptr %result.i17, i64 24
  %.fca.0.extract.i = extractvalue { ptr } %35, 0
  store ptr %.fca.0.extract.i, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i17, i64 32
  %.fca.0.extract.i49 = extractvalue { ptr } %39, 0
  store ptr %.fca.0.extract.i49, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i17, i64 40
  store i32 %43, ptr %48, align 8
  %49 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull @HashMapIterator) #34
  %50 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 24, 3
  ret { ptr, ptr, ptr, i32 } %50
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMapIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_lenPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @HashMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_lenPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4, i32 %5) #2 {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !566
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !566
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !566
  %product.i.i.i = mul i64 %hash_coef.i.i, -704669437586349537
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !566
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract5, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  tail call void %13(ptr %.fca.1.extract, { ptr } %3) #35
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #34
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract, { ptr } %4) #35
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #34
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  tail call void %23(ptr %.fca.1.extract, i32 %5) #35
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #34
  %25 = getelementptr i8, ptr %9, i64 48
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  tail call void %28(ptr %.fca.1.extract, i32 0) #35
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #34
  %30 = getelementptr i8, ptr %9, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  tail call void %33(ptr %.fca.1.extract, i1 false) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @HashMapIterator_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -704669437586349537
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #38
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract5, i64 %7
  %9 = getelementptr i8, ptr %8, i64 48
  %10 = getelementptr i8, ptr %8, i64 40
  br label %11

11:                                               ; preds = %20, %4
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = tail call i32 %13(ptr %.fca.1.extract6) #36
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #38
  %16 = load ptr, ptr %10, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract6) #36
  %19 = icmp slt i32 %14, %18
  br i1 %19, label %20, label %.thread83

20:                                               ; preds = %11
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %22 = tail call i32 %13(ptr %.fca.1.extract6) #36
  %23 = sext i32 %22 to i64
  %24 = shl nsw i64 %23, 5
  %25 = getelementptr i8, ptr %.fca.0.extract, i64 %24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %25, i64 8
  %28 = load i160, ptr %27, align 4
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %30 = tail call i32 %13(ptr %.fca.1.extract6) #36
  %31 = add i32 %30, 1
  %32 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %33 = getelementptr i8, ptr %12, i64 8
  %34 = load ptr, ptr %33, align 8
  tail call void %34(ptr %.fca.1.extract6, i32 %31) #35
  %35 = icmp eq ptr %26, @nil_typ
  %36 = icmp eq ptr %26, null
  %.not30.not = or i1 %35, %36
  br i1 %.not30.not, label %11, label %37

37:                                               ; preds = %20
  %.sroa.373.8.extract.trunc = trunc i160 %28 to i64
  %38 = inttoptr i64 %.sroa.373.8.extract.trunc to ptr
  %.sroa.574.8.extract.shift = lshr i160 %28, 64
  %.sroa.574.8.extract.trunc = trunc i160 %.sroa.574.8.extract.shift to i64
  %39 = inttoptr i64 %.sroa.574.8.extract.trunc to ptr
  %hash_coef_ptr.i.i32 = getelementptr i8, ptr %26, i64 8
  %tbl_size_ptr.i.i33 = getelementptr i8, ptr %26, i64 16
  %offset_tbl_ptr.i.i34 = getelementptr i8, ptr %26, i64 40
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i32, align 4
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i33, align 4
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i34, align 8
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 4015701072841558310
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %26, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %38, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %39, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %offset.i.i43, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %45 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %26)
  %46 = sext i32 %offset.i.i43 to i64
  %47 = getelementptr ptr, ptr %26, i64 %46
  %48 = getelementptr i8, ptr %47, i64 72
  %49 = load ptr, ptr %48, align 8
  %result.i = call ptr %49({ ptr, ptr, ptr, i32 } %43, ptr nocapture nofree noundef nonnull readonly %5) #15
  %50 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %5) #7
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %50, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %50, 1
  %.fca.2.extract10 = extractvalue { ptr, ptr, ptr, i32 } %50, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 9197944775169318296
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i56, align 4
  %51 = ptrtoint ptr %.fca.1.extract9 to i64
  %52 = ptrtoint ptr %.fca.2.extract10 to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i.i57 to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %52 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext = zext i64 %51 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext
  br label %.thread83

.thread83:                                        ; preds = %11, %37
  %.reg2mem26.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %37 ], [ undef, %11 ]
  %.reg2mem26.sroa.0.0 = phi ptr [ %.fca.0.extract8, %37 ], [ @nil_typ, %11 ]
  %.reload27.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem26.sroa.0.0, 0
  %.reload27.fca.1.insert = insertvalue { ptr, i160 } %.reload27.fca.0.insert, i160 %.reg2mem26.sroa.3.0, 1
  ret { ptr, i160 } %.reload27.fca.1.insert
}

define { ptr, i160 } @HashMapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -704669437586349537
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #34
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract5, i64 %9
  %11 = getelementptr i8, ptr %10, i64 56
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = tail call i1 %13(ptr %.fca.1.extract6) #36
  br i1 %14, label %._crit_edge, label %15

._crit_edge:                                      ; preds = %3
  %.pre = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %.pre63 = insertvalue { ptr, ptr, ptr, i32 } %.pre, ptr %.fca.1.extract6, 1
  %.pre65 = insertvalue { ptr, ptr, ptr, i32 } %.pre63, ptr %.fca.2.extract, 2
  %.pre67 = insertvalue { ptr, ptr, ptr, i32 } %.pre65, i32 %offset.i.i, 3
  br label %43

15:                                               ; preds = %3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #40
  %17 = getelementptr i8, ptr %10, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract6) #36
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract6, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i, 3
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %4, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4) #40
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #40
  %27 = getelementptr i8, ptr %10, i64 72
  %28 = load ptr, ptr %27, align 8
  store ptr @buffer_typ, ptr %5, align 8
  %result.i = call ptr %28({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %5) #15
  %29 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 dereferenceable(8) %4, { ptr } %20) #7
  %.fca.0.extract15 = extractvalue { ptr, i160 } %29, 0
  %30 = icmp ne ptr %.fca.0.extract15, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract15, null
  %.not22.not.not = and i1 %30, %31
  br i1 %.not22.not.not, label %42, label %32

32:                                               ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %34 = getelementptr i8, ptr %10, i64 48
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  call void %37(ptr %.fca.1.extract6, i32 0) #35
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %39 = load ptr, ptr %11, align 8
  %40 = getelementptr i8, ptr %39, i64 8
  %41 = load ptr, ptr %40, align 8
  call void %41(ptr %.fca.1.extract6, i1 true) #35
  br label %43

42:                                               ; preds = %15
  %.fca.1.extract16 = extractvalue { ptr, i160 } %29, 1
  %hash_coef_ptr.i.i26 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i.i29 = load i64, ptr %hash_coef_ptr.i.i26, align 4
  %tbl_size.i.i30 = load i64, ptr %tbl_size_ptr.i.i27, align 4
  %offset_tbl.i.i31 = load ptr, ptr %offset_tbl_ptr.i.i28, align 8
  %product.i.i.i32 = mul i64 %hash_coef.i.i29, 9197944775169318296
  %shifted.i.i.i33 = lshr i64 %product.i.i.i32, 32
  %xored.i.i.i34 = xor i64 %shifted.i.i.i33, %product.i.i.i32
  %hash.i.i.i35 = and i64 %xored.i.i.i34, %tbl_size.i.i30
  %offset_ptr.i.i36 = getelementptr i32, ptr %offset_tbl.i.i31, i64 %hash.i.i.i35
  %offset.i.i37 = load i32, ptr %offset_ptr.i.i36, align 4
  %.sroa.5.8.insert.ext = zext i32 %offset.i.i37 to i160
  %.sroa.5.8.insert.shift = shl nuw i160 %.sroa.5.8.insert.ext, 128
  %.sroa.3.8.insert.ext = and i160 %.fca.1.extract16, 340282366920938463463374607431768211455
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.shift, %.sroa.3.8.insert.ext
  br label %54

43:                                               ; preds = %._crit_edge, %32
  %.pre-phi68 = phi { ptr, ptr, ptr, i32 } [ %.pre67, %._crit_edge ], [ %24, %32 ]
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #40
  %45 = getelementptr i8, ptr %10, i64 32
  %46 = load ptr, ptr %45, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr } %47(ptr %.fca.1.extract6) #36
  store ptr @_parameterization_BufferEntryK._V_or_Nil, ptr %6, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #40
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #40
  %51 = getelementptr i8, ptr %10, i64 72
  %52 = load ptr, ptr %51, align 8
  store ptr @buffer_typ, ptr %7, align 8
  %result.i39 = call ptr %52({ ptr, ptr, ptr, i32 } %.pre-phi68, ptr nocapture nofree noundef nonnull readonly %7) #15
  %53 = call { ptr, i160 } %result.i39({ ptr, ptr, ptr, i32 } %.pre-phi68, { ptr, ptr, ptr, i32 } %.pre-phi68, ptr nonnull align 8 dereferenceable(8) %6, { ptr } %48) #7
  %.fca.0.extract7 = extractvalue { ptr, i160 } %53, 0
  %.fca.1.extract8 = extractvalue { ptr, i160 } %53, 1
  br label %54

54:                                               ; preds = %42, %43
  %.reg2mem37.sroa.0.0 = phi ptr [ %.fca.0.extract7, %43 ], [ %.fca.0.extract15, %42 ]
  %.reg2mem37.sroa.3.0 = phi i160 [ %.fca.1.extract8, %43 ], [ %.sroa.3.8.insert.insert, %42 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem37.sroa.0.0, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem37.sroa.3.0, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @HashMapIterator_getter_on_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_on_second(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMapIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMapIterator_getter_table_len(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_table_len(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMapIterator_getter_map_table2(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_map_table2(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMapIterator_getter_map_table1(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_map_table1(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #0 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_eq(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_eq(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_hasher(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_hasher(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMap_getter_size(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_size(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMap_getter_table_len(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_table_len(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_table2(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_table2(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_table1(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_table1(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #0 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

; Function Attrs: nounwind
define range(i32 0, -2147483648) i32 @string_hasher({ ptr, ptr, ptr, i32 } %0) local_unnamed_addr #7 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !569
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !569
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !569
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !569
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract6, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract7, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract8, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i, 3
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #38
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract6) #38
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract6, i64 %9
  %11 = getelementptr i8, ptr %10, i64 120
  %12 = load ptr, ptr %11, align 8
  %result.i = call ptr %12({ ptr, ptr, ptr, i32 } %6, ptr nocapture nofree noundef nonnull readonly %2) #15
  %13 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %6, { ptr, ptr, ptr, i32 } %6, ptr nonnull align 8 %2) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 2
  %hash_coef_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i34 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i32, align 4, !noalias !22
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i33, align 4, !noalias !22
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i34, align 8, !noalias !22
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, -7260570988945952630
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !572
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i57, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %20 = sext i32 %offset.i.i57 to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %21, i64 24
  %23 = load ptr, ptr %22, align 8
  %result.i59102 = call ptr %23({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %2) #15
  %24 = call { ptr, i160 } %result.i59102({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %2) #7
  %.fca.0.extract21103 = extractvalue { ptr, i160 } %24, 0
  %25 = icmp ne ptr %.fca.0.extract21103, @nil_typ
  %26 = icmp ne ptr %.fca.0.extract21103, null
  %.not30104 = and i1 %25, %26
  br i1 %.not30104, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %1
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.fca.0.extract21106 = phi ptr [ %.fca.0.extract21103, %._crit_edge.lr.ph ], [ %.fca.0.extract21, %._crit_edge ]
  %28 = phi { ptr, i160 } [ %24, %._crit_edge.lr.ph ], [ %46, %._crit_edge ]
  %.0105 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %44, %._crit_edge ]
  %.fca.1.extract22 = extractvalue { ptr, i160 } %28, 1
  %.sroa.7.8.extract.shift = lshr i160 %.fca.1.extract22, 64
  %.sroa.7.8.extract.trunc = trunc i160 %.sroa.7.8.extract.shift to i64
  %.sroa.428.8.extract.trunc = trunc i160 %.fca.1.extract22 to i64
  %29 = inttoptr i64 %.sroa.428.8.extract.trunc to ptr
  %30 = inttoptr i64 %.sroa.7.8.extract.trunc to ptr
  %hash_coef_ptr.i.i61 = getelementptr i8, ptr %.fca.0.extract21106, i64 8
  %tbl_size_ptr.i.i62 = getelementptr i8, ptr %.fca.0.extract21106, i64 16
  %offset_tbl_ptr.i.i63 = getelementptr i8, ptr %.fca.0.extract21106, i64 40
  %hash_coef.i.i64 = load i64, ptr %hash_coef_ptr.i.i61, align 4, !noalias !575
  %tbl_size.i.i65 = load i64, ptr %tbl_size_ptr.i.i62, align 4, !noalias !575
  %offset_tbl.i.i66 = load ptr, ptr %offset_tbl_ptr.i.i63, align 8, !noalias !575
  %product.i.i.i67 = mul i64 %hash_coef.i.i64, 6681222582356018452
  %shifted.i.i.i68 = lshr i64 %product.i.i.i67, 32
  %xored.i.i.i69 = xor i64 %shifted.i.i.i68, %product.i.i.i67
  %hash.i.i.i70 = and i64 %xored.i.i.i69, %tbl_size.i.i65
  %offset_ptr.i.i71 = getelementptr i32, ptr %offset_tbl.i.i66, i64 %hash.i.i.i70
  %offset.i.i72 = load i32, ptr %offset_ptr.i.i71, align 4, !noalias !575
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21106, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %29, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %30, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %offset.i.i72, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull %.fca.0.extract21106)
  %36 = sext i32 %offset.i.i72 to i64
  %37 = getelementptr ptr, ptr %.fca.0.extract21106, i64 %36
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %result.i74 = call ptr %39({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly %2) #15
  %40 = call i8 %result.i74({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %2) #7
  %41 = sext i8 %40 to i32
  %42 = mul i32 %.0105, 31
  %43 = add i32 %42, %41
  %44 = and i32 %43, 2147483647
  %45 = load ptr, ptr %22, align 8
  %result.i59 = call ptr %45({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %2) #15
  %46 = call { ptr, i160 } %result.i59({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %2) #7
  %.fca.0.extract21 = extractvalue { ptr, i160 } %46, 0
  %47 = icmp ne ptr %.fca.0.extract21, @nil_typ
  %48 = icmp ne ptr %.fca.0.extract21, null
  %.not30 = and i1 %47, %48
  br i1 %.not30, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %1
  %.0.lcssa = phi i32 [ 0, %1 ], [ %44, %._crit_edge ]
  ret i32 %.0.lcssa
}

; Function Attrs: nounwind
define i1 @string_eq({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1) local_unnamed_addr #7 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !578
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !578
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !578
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !578
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !581
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i35, 3
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract2, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract3, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11) #34
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract1, i64 %14
  %16 = getelementptr i8, ptr %15, i64 88
  %17 = load ptr, ptr %16, align 8
  %18 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %18, align 8
  %result.i = call ptr %17({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %18) #15
  %19 = call i1 %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %6) #7
  ret i1 %19
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Pair(ptr nocapture nofree readonly align 8 %0) #10 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 0
  %21 = extractvalue { i64, i64 } %result.i1, 1
  %22 = tail call i64 @llvm.umax.i64(i64 %8, i64 %21)
  %23 = tail call i64 @llvm.umax.i64(i64 %22, i64 8)
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %29, %33
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #2 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !584
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !584
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !584
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !584
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract11) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract11, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract12, { ptr, i160 } %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract11) #34
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract12, { ptr, i160 } %4) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !587
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !587
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !587
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !587
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #36
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !590
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !590
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !590
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !590
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #36
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_second(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 0
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 16
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i1 = tail call { i64, i64 } %18(ptr nocapture nofree nonnull readonly %15) #5
  %19 = extractvalue { i64, i64 } %result.i1, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = tail call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly %15) #5
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_second(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  tail call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %16, ptr nocapture nofree writeonly %26) #12
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_first(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 16, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 16
  %10 = select i1 %8, i64 16, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = tail call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly %2) #5
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_first(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  tail call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %3, ptr nocapture nofree writeonly %12) #12
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Container(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Array(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterable2T(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #34
  ret ptr @Array__Self_from_iterable_iterableIterable2T
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__set_index_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_throw_oob_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_insert_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterable2T(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !593
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !593
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !593
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !593
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract26) #38
  %5 = sext i32 %.fca.3.extract29 to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract26, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract27) #5
  %result.i73 = tail call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i73, align 8
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i73) #38
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %11 = load ptr, ptr %result.i, align 8
  %12 = getelementptr i8, ptr %11, i64 72
  %13 = load ptr, ptr %12, align 8
  %result.i3.i = tail call { i64, i64 } %13(ptr nocapture nofree nonnull readonly %result.i) #5
  %14 = extractvalue { i64, i64 } %result.i3.i, 0
  %result.i4.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %15 = getelementptr inbounds i8, ptr %result.i73, i64 8
  store ptr %result.i4.i, ptr %15, align 8
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %17 = getelementptr inbounds i8, ptr %result.i73, i64 20
  store i32 1, ptr %17, align 4
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract27, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract28, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract26)
  %24 = sext i32 %offset.i.i to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract26, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i89 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %3) #15
  %28 = call { ptr, ptr, ptr, i32 } %result.i89({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 2
  %hash_coef_ptr.i.i91 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i92 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i93 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i94 = load i64, ptr %hash_coef_ptr.i.i91, align 4, !noalias !22
  %tbl_size.i.i95 = load i64, ptr %tbl_size_ptr.i.i92, align 4, !noalias !22
  %offset_tbl.i.i96 = load ptr, ptr %offset_tbl_ptr.i.i93, align 8, !noalias !22
  %product.i.i.i97 = mul i64 %hash_coef.i.i94, 4189192806087951739
  %shifted.i.i.i98 = lshr i64 %product.i.i.i97, 32
  %xored.i.i.i99 = xor i64 %shifted.i.i.i98, %product.i.i.i97
  %hash.i.i.i100 = and i64 %xored.i.i.i99, %tbl_size.i.i95
  %offset_ptr.i.i101 = getelementptr i32, ptr %offset_tbl.i.i96, i64 %hash.i.i.i100
  %offset.i.i116 = load i32, ptr %offset_ptr.i.i101, align 4, !noalias !596
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.1.extract, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.2.extract, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i116, 3
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %35 = sext i32 %offset.i.i116 to i64
  %36 = getelementptr ptr, ptr %.fca.0.extract, i64 %35
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %result.i118164 = call ptr %38({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %3) #15
  %39 = call { ptr, i160 } %result.i118164({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 %3) #7
  %.fca.0.extract63165 = extractvalue { ptr, i160 } %39, 0
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %41 = icmp ne ptr %.fca.0.extract63165, @nil_typ
  %42 = icmp ne ptr %.fca.0.extract63165, null
  %.not71166 = and i1 %41, %42
  br i1 %.not71166, label %._crit_edge.lr.ph, label %.critedge

._crit_edge.lr.ph:                                ; preds = %2
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %44 = getelementptr inbounds i8, ptr %result.i73, i64 16
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %Array_append_xT.exit
  %45 = phi ptr [ %result.i4.i, %._crit_edge.lr.ph ], [ %74, %Array_append_xT.exit ]
  %.pre168 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %86, %Array_append_xT.exit ]
  %46 = phi { ptr, i160 } [ %39, %._crit_edge.lr.ph ], [ %89, %Array_append_xT.exit ]
  %47 = load i32, ptr %17, align 4
  %.not.i = icmp slt i32 %.pre168, %47
  br i1 %.not.i, label %Array_append_xT.exit, label %48

48:                                               ; preds = %._crit_edge
  %49 = shl i32 %47, 1
  %.not.i169 = icmp sgt i32 %49, %47
  %.pre.pre = load ptr, ptr %15, align 8
  br i1 %.not.i169, label %50, label %Array_append_xT.exit

50:                                               ; preds = %48
  store i32 %49, ptr %17, align 4
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array)
  %52 = load ptr, ptr %result.i, align 8
  %53 = getelementptr i8, ptr %52, i64 72
  %54 = load ptr, ptr %53, align 8
  %result.i25.i = call { i64, i64 } %54(ptr nocapture nofree nonnull readonly %result.i) #5
  %55 = extractvalue { i64, i64 } %result.i25.i, 0
  %56 = sext i32 %49 to i64
  %57 = mul i64 %55, %56
  %result.i26.i = call noalias ptr @bump_malloc_inner(i64 noundef %57, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i26.i, ptr %15, align 8
  %58 = icmp sgt i32 %.pre168, 0
  br i1 %58, label %._crit_edge.lr.ph.i, label %Array_append_xT.exit

._crit_edge.lr.ph.i:                              ; preds = %50
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i, %._crit_edge.lr.ph.i
  %.052.i = phi i32 [ 0, %._crit_edge.lr.ph.i ], [ %72, %._crit_edge.i ]
  %60 = load ptr, ptr %result.i, align 8
  %61 = getelementptr i8, ptr %60, i64 72
  %62 = load ptr, ptr %61, align 8
  %result.i27.i = call { i64, i64 } %62(ptr nocapture nofree nonnull readonly %result.i) #5
  %63 = extractvalue { i64, i64 } %result.i27.i, 0
  %64 = zext nneg i32 %.052.i to i64
  %65 = mul i64 %63, %64
  %66 = getelementptr i8, ptr %.pre.pre, i64 %65
  %67 = getelementptr i8, ptr %60, i64 56
  %68 = load ptr, ptr %67, align 8
  %result.i28.i = call { ptr, i160 } %68(ptr nocapture nofree readonly %66, ptr nocapture nofree nonnull readonly %result.i) #5
  %69 = getelementptr i8, ptr %result.i26.i, i64 %65
  %70 = getelementptr i8, ptr %60, i64 64
  %71 = load ptr, ptr %70, align 8
  call void %71({ ptr, i160 } %result.i28.i, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %69) #12
  %72 = add nuw nsw i32 %.052.i, 1
  %73 = icmp slt i32 %72, %.pre168
  br i1 %73, label %._crit_edge.i, label %Array_append_xT.exit

Array_append_xT.exit:                             ; preds = %._crit_edge.i, %50, %48, %._crit_edge
  %74 = phi ptr [ %45, %._crit_edge ], [ %.pre.pre, %48 ], [ %result.i26.i, %50 ], [ %result.i26.i, %._crit_edge.i ]
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %76 = load ptr, ptr %result.i, align 8
  %77 = getelementptr i8, ptr %76, i64 72
  %78 = load ptr, ptr %77, align 8
  %result.i20.i = call { i64, i64 } %78(ptr nocapture nofree nonnull readonly %result.i) #5
  %79 = extractvalue { i64, i64 } %result.i20.i, 0
  %80 = sext i32 %.pre168 to i64
  %81 = mul i64 %79, %80
  %82 = getelementptr i8, ptr %74, i64 %81
  %83 = getelementptr i8, ptr %76, i64 64
  %84 = load ptr, ptr %83, align 8
  call void %84({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %82) #12
  %85 = load i32, ptr %44, align 8
  %86 = add i32 %85, 1
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  store i32 %86, ptr %44, align 8
  %88 = load ptr, ptr %37, align 8
  %result.i118 = call ptr %88({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %3) #15
  %89 = call { ptr, i160 } %result.i118({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 %3) #7
  %.fca.0.extract63 = extractvalue { ptr, i160 } %89, 0
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %91 = icmp ne ptr %.fca.0.extract63, @nil_typ
  %92 = icmp ne ptr %.fca.0.extract63, null
  %.not71 = and i1 %91, %92
  br i1 %.not71, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %Array_append_xT.exit, %2
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i73, 1
  %93 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %94
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !599
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !599
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !599
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !599
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %8 = load ptr, ptr %result.i, align 8
  %9 = getelementptr i8, ptr %8, i64 72
  %10 = load ptr, ptr %9, align 8
  %result.i3 = tail call { i64, i64 } %10(ptr nocapture nofree nonnull readonly %result.i) #5
  %11 = extractvalue { i64, i64 } %result.i3, 0
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %13 = getelementptr i8, ptr %6, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %16(ptr %.fca.1.extract, { ptr } %17) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %19 = getelementptr i8, ptr %6, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 0) #35
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #40
  %24 = getelementptr i8, ptr %6, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  tail call void %27(ptr %.fca.1.extract, i32 1) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !602
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !602
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !602
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !602
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract, i32 %3) #35
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %17 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %18 = load ptr, ptr %result.i, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %result.i3 = tail call { i64, i64 } %20(ptr nocapture nofree nonnull readonly %result.i) #5
  %21 = extractvalue { i64, i64 } %result.i3, 0
  %22 = sext i32 %15 to i64
  %23 = mul i64 %21, %22
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %25 = getelementptr i8, ptr %7, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %28(ptr %.fca.1.extract, { ptr } %29) #35
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %31 = getelementptr i8, ptr %7, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  tail call void %34(ptr %.fca.1.extract, i32 0) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !605
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !605
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !605
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !605
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, i32 %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %19 = load ptr, ptr %14, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call i32 %20(ptr %.fca.1.extract) #36
  %22 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %23 = load ptr, ptr %8, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %23(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %24 = load ptr, ptr %result.i, align 8
  %25 = getelementptr i8, ptr %24, i64 72
  %26 = load ptr, ptr %25, align 8
  %result.i3 = tail call { i64, i64 } %26(ptr nocapture nofree nonnull readonly %result.i) #5
  %27 = extractvalue { i64, i64 } %result.i3, 0
  %28 = sext i32 %21 to i64
  %29 = mul i64 %27, %28
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %29, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %31 = getelementptr i8, ptr %8, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %34(ptr %.fca.1.extract, { ptr } %35) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !608
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !608
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !608
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !608
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !611
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !611
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !611
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !611
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !614
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !614
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !614
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !614
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract4) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract4, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract5) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract4) #34
  %15 = getelementptr i8, ptr %9, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract5) #36
  %.not = icmp slt i32 %13, %18
  br i1 %.not, label %.._crit_edge_crit_edge, label %19

.._crit_edge_crit_edge:                           ; preds = %4
  %.pre65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %.pre66 = insertvalue { ptr, ptr, ptr, i32 } %.pre65, ptr %.fca.1.extract5, 1
  %.pre68 = insertvalue { ptr, ptr, ptr, i32 } %.pre66, ptr %.fca.2.extract, 2
  br label %._crit_edge

19:                                               ; preds = %4
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %21 = tail call i32 %17(ptr %.fca.1.extract5) #36
  %22 = shl i32 %21, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract5, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #40
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %29 = getelementptr i8, ptr %9, i64 88
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %6) #15
  call void %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %22) #7
  %.pre = load ptr, ptr %10, align 8
  %.pre64 = load ptr, ptr %.pre, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %.._crit_edge_crit_edge, %19
  %.pre-phi69 = phi { ptr, ptr, ptr, i32 } [ %.pre68, %.._crit_edge_crit_edge ], [ %25, %19 ]
  %31 = phi ptr [ %12, %.._crit_edge_crit_edge ], [ %.pre64, %19 ]
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %33 = getelementptr i8, ptr %9, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract5) #36
  %.fca.0.extract14 = extractvalue { ptr } %36, 0
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %38 = call i32 %31(ptr %.fca.1.extract5) #36
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %40 = load ptr, ptr %9, align 8
  %result.i19 = call nonnull align 8 dereferenceable(8) ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #5
  %41 = load ptr, ptr %result.i19, align 8
  %42 = getelementptr i8, ptr %41, i64 72
  %43 = load ptr, ptr %42, align 8
  %result.i20 = call { i64, i64 } %43(ptr nocapture nofree nonnull readonly %result.i19) #5
  %44 = extractvalue { i64, i64 } %result.i20, 0
  %45 = sext i32 %38 to i64
  %46 = mul i64 %44, %45
  %47 = getelementptr i8, ptr %.fca.0.extract14, i64 %46
  %48 = getelementptr i8, ptr %41, i64 64
  %49 = load ptr, ptr %48, align 8
  call void %49({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly %result.i19, ptr nocapture nofree writeonly %47) #12
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %51 = load ptr, ptr %10, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr %.fca.1.extract5) #36
  %54 = add i32 %53, 1
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %56 = getelementptr i8, ptr %51, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr %.fca.1.extract5, i32 %54) #35
  %hash_coef.i.i25 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !617
  %tbl_size.i.i26 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !617
  %offset_tbl.i.i27 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !617
  %product.i.i.i28 = mul i64 %hash_coef.i.i25, -5261542750394134544
  %shifted.i.i.i29 = lshr i64 %product.i.i.i28, 32
  %xored.i.i.i30 = xor i64 %shifted.i.i.i29, %product.i.i.i28
  %hash.i.i.i31 = and i64 %xored.i.i.i30, %tbl_size.i.i26
  %offset_ptr.i.i32 = getelementptr i32, ptr %offset_tbl.i.i27, i64 %hash.i.i.i31
  %offset.i.i33 = load i32, ptr %offset_ptr.i.i32, align 4, !noalias !617
  %58 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi69, i32 %offset.i.i33, 3
  ret { ptr, ptr, ptr, i32 } %58
}

define void @Array_reserve_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract) #36
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %._crit_edge.thread

12:                                               ; preds = %4
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 %3) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #36
  %.fca.0.extract22 = extractvalue { ptr } %20, 0
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %22 = load ptr, ptr %8, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = tail call i32 %23(ptr %.fca.1.extract) #36
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %26 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %26(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %27 = load ptr, ptr %result.i, align 8
  %28 = getelementptr i8, ptr %27, i64 72
  %29 = load ptr, ptr %28, align 8
  %result.i25 = tail call { i64, i64 } %29(ptr nocapture nofree nonnull readonly %result.i) #5
  %30 = extractvalue { i64, i64 } %result.i25, 0
  %31 = sext i32 %24 to i64
  %32 = mul i64 %30, %31
  %result.i26 = tail call noalias ptr @bump_malloc_inner(i64 noundef %32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %33 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %34 = load ptr, ptr %17, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %result.i26, 0
  tail call void %36(ptr %.fca.1.extract, { ptr } %37) #35
  %38 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = tail call i32 %41(ptr %.fca.1.extract) #36
  %43 = icmp sgt i32 %42, 0
  br i1 %43, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %12
  %44 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.052 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %60, %._crit_edge ]
  %45 = load ptr, ptr %result.i, align 8
  %46 = getelementptr i8, ptr %45, i64 72
  %47 = load ptr, ptr %46, align 8
  %result.i27 = tail call { i64, i64 } %47(ptr nocapture nofree nonnull readonly %result.i) #5
  %48 = extractvalue { i64, i64 } %result.i27, 0
  %49 = zext nneg i32 %.052 to i64
  %50 = mul i64 %48, %49
  %51 = getelementptr i8, ptr %.fca.0.extract22, i64 %50
  %52 = getelementptr i8, ptr %45, i64 56
  %53 = load ptr, ptr %52, align 8
  %result.i28 = tail call { ptr, i160 } %53(ptr nocapture nofree readonly %51, ptr nocapture nofree nonnull readonly %result.i) #5
  %54 = load ptr, ptr %17, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = tail call { ptr } %55(ptr %.fca.1.extract) #36
  %.fca.0.extract7 = extractvalue { ptr } %56, 0
  %57 = getelementptr i8, ptr %.fca.0.extract7, i64 %50
  %58 = getelementptr i8, ptr %45, i64 64
  %59 = load ptr, ptr %58, align 8
  tail call void %59({ ptr, i160 } %result.i28, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %57) #12
  %60 = add nuw nsw i32 %.052, 1
  %61 = load ptr, ptr %39, align 8
  %62 = load ptr, ptr %61, align 8
  %63 = tail call i32 %62(ptr %.fca.1.extract) #36
  %64 = icmp slt i32 %60, %63
  br i1 %64, label %._crit_edge, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %12, %4
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @Array__index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !620
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !620
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !620
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !620
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #36
  %16 = add i32 %15, -1
  %17 = icmp sgt i32 %3, %16
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %19 = tail call i32 %14(ptr %.fca.1.extract) #36
  %20 = add i32 %19, %3
  %21 = icmp slt i32 %20, 0
  %.0 = select i1 %17, i1 true, i1 %21
  br i1 %.0, label %22, label %._crit_edge

22:                                               ; preds = %4
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #40
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  %29 = getelementptr i8, ptr %11, i64 112
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %6) #15
  call void %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %3) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %22
  %31 = icmp slt i32 %3, 0
  br i1 %31, label %32, label %._crit_edge1

32:                                               ; preds = %._crit_edge
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  %34 = load ptr, ptr %12, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %.fca.1.extract) #36
  %37 = add i32 %36, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %32
  %.027 = phi i32 [ %37, %32 ], [ %3, %._crit_edge ]
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %.fca.1.extract, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.2.extract, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %7, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7) #40
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  %44 = getelementptr i8, ptr %11, i64 120
  %45 = load ptr, ptr %44, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i30 = call ptr %45({ ptr, ptr, ptr, i32 } %41, ptr nocapture nofree noundef nonnull readonly %8) #15
  %46 = call { ptr, i160 } %result.i30({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull align 8 dereferenceable(8) %7, i32 %.027) #7
  ret { ptr, i160 } %46
}

; Function Attrs: nounwind
define void @Array__set_index_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #7 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !623
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !623
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !623
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !623
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract16) #34
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract16, i64 %11
  %13 = getelementptr i8, ptr %12, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract17) #36
  %17 = add i32 %16, -1
  %18 = icmp sgt i32 %3, %17
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract16) #34
  %20 = tail call i32 %15(ptr %.fca.1.extract17) #36
  %21 = add i32 %20, %3
  %22 = icmp slt i32 %21, 0
  %.0 = select i1 %18, i1 true, i1 %22
  br i1 %.0, label %23, label %._crit_edge

23:                                               ; preds = %5
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract17, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %6, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #40
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #40
  %30 = getelementptr i8, ptr %12, i64 112
  %31 = load ptr, ptr %30, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i = call ptr %31({ ptr, ptr, ptr, i32 } %27, ptr nocapture nofree noundef nonnull readonly %7) #15
  call void %result.i({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 dereferenceable(8) %6, i32 %3) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %5, %23
  %32 = icmp slt i32 %3, 0
  br i1 %32, label %33, label %._crit_edge1

33:                                               ; preds = %._crit_edge
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #40
  %35 = load ptr, ptr %13, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call i32 %36(ptr %.fca.1.extract17) #36
  %38 = add i32 %37, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %33
  %.027 = phi i32 [ %38, %33 ], [ %3, %._crit_edge ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract17, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %offset.i.i, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #40
  %44 = load ptr, ptr %12, align 8
  %result.i30 = call ptr %44(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract17) #5
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %45 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %result.i30, ptr %45, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8) #40
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #40
  %48 = getelementptr i8, ptr %12, i64 128
  %49 = load ptr, ptr %48, align 8
  store ptr @i32_typ, ptr %9, align 8
  %50 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.0.extract, ptr %50, align 8
  %result.i31 = call ptr %49({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly %9) #15
  call void %result.i31({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 dereferenceable(16) %8, i32 %.027, { ptr, i160 } %4) #7
  ret void
}

; Function Attrs: nounwind
define void @Array_throw_oob_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %result.i26 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %5 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %5, align 4
  %6 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %6, align 4
  %7 = getelementptr i8, ptr %result.i26, i64 40
  store ptr @String, ptr %7, align 8
  %8 = getelementptr i8, ptr %result.i26, i64 48
  store ptr %result.i29.i, ptr %8, align 8
  %9 = getelementptr i8, ptr %result.i26, i64 64
  store i32 10, ptr %9, align 4
  %10 = getelementptr i8, ptr %result.i26, i64 8
  %11 = getelementptr i8, ptr %result.i26, i64 16
  %12 = getelementptr i8, ptr %result.i26, i64 32
  %result.i28 = tail call noalias align 16 dereferenceable_or_null(17) ptr @bump_malloc_inner(i64 noundef 17, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <16 x i8> <i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i28, align 16
  %result.i30 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i28, ptr %result.i30, align 8
  %13 = getelementptr i8, ptr %result.i30, i64 8
  store i32 16, ptr %13, align 4
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %15 = getelementptr i8, ptr %result.i30, i64 12
  store i32 17, ptr %15, align 4
  store i32 152, ptr %result.i26, align 4
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @Exception) #34
  store ptr @String, ptr %10, align 8
  store ptr %result.i30, ptr %11, align 8
  store i32 10, ptr %12, align 4
  %17 = ptrtoint ptr %result.i26 to i64
  %.sroa.4.8.insert.ext = zext i64 %17 to i160
  %.sroa.4.8.insert.insert = or disjoint i160 %.sroa.4.8.insert.ext, 3402823669209384634633746074317682114560
  %18 = insertvalue { ptr, i160 } { ptr @Exception, i160 undef }, i160 %.sroa.4.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %19 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %18, ptr %19, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #41
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Array_unchecked_index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !626
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !626
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !626
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !626
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract4) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr } %10(ptr %.fca.1.extract5) #36
  %.fca.0.extract1 = extractvalue { ptr } %11, 0
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract4) #40
  %13 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #5
  %14 = load ptr, ptr %result.i, align 8
  %15 = getelementptr i8, ptr %14, i64 72
  %16 = load ptr, ptr %15, align 8
  %result.i8 = tail call { i64, i64 } %16(ptr nocapture nofree nonnull readonly %result.i) #5
  %17 = extractvalue { i64, i64 } %result.i8, 0
  %18 = sext i32 %3 to i64
  %19 = mul i64 %17, %18
  %20 = getelementptr i8, ptr %.fca.0.extract1, i64 %19
  %21 = getelementptr i8, ptr %14, i64 56
  %22 = load ptr, ptr %21, align 8
  %result.i9 = tail call { ptr, i160 } %22(ptr nocapture nofree readonly %20, ptr nocapture nofree nonnull readonly %result.i) #5
  ret { ptr, i160 } %result.i9
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_unchecked_insert_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !629
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !629
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !629
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !629
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract6) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract6, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr } %11(ptr %.fca.1.extract7) #36
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract6) #40
  %14 = load ptr, ptr %8, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %14(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract7) #5
  %15 = load ptr, ptr %result.i, align 8
  %16 = getelementptr i8, ptr %15, i64 72
  %17 = load ptr, ptr %16, align 8
  %result.i10 = tail call { i64, i64 } %17(ptr nocapture nofree nonnull readonly %result.i) #5
  %18 = extractvalue { i64, i64 } %result.i10, 0
  %19 = sext i32 %3 to i64
  %20 = mul i64 %18, %19
  %21 = getelementptr i8, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %15, i64 64
  %23 = load ptr, ptr %22, align 8
  tail call void %23({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %21) #12
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !632
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !632
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !632
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !632
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i8 = tail call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i8, align 8
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i8) #34
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i21 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !22
  %9 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr undef, 2
  %11 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %.fca.0.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %.fca.1.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.2.extract, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store i32 %offset.i.i21, ptr %14, align 8
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @ArrayIterator) #34
  %16 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %16
}

define void @Iterable2_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !635
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !635
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !635
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !635
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #38
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #15
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !22
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !22
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !22
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 4189192806087951739
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !638
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i55, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i55 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %result.i5764 = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #15
  %27 = call { ptr, i160 } %result.i5764({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract2265 = extractvalue { ptr, i160 } %27, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %29 = icmp ne ptr %.fca.0.extract2265, @nil_typ
  %30 = icmp ne ptr %.fca.0.extract2265, null
  %.not2866 = and i1 %29, %30
  br i1 %.not2866, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %4, %._crit_edge
  %31 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %27, %4 ]
  call void %.fca.0.extract3({ ptr, i160 } %31)
  %32 = load ptr, ptr %25, align 8
  %result.i57 = call ptr %32({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #15
  %33 = call { ptr, i160 } %result.i57({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract22 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %35 = icmp ne ptr %.fca.0.extract22, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract22, null
  %.not28 = and i1 %35, %36
  br i1 %.not28, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %._crit_edge, %4
  ret void
}

define { ptr, i160 } @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !641
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !641
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !641
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !641
  %.fca.0.extract3 = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract14, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract15, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #38
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13) #38
  %13 = sext i32 %offset.i.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract13, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i = call ptr %16({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %6) #15
  %17 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %hash_coef_ptr.i.i50 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i51 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i52 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i53 = load i64, ptr %hash_coef_ptr.i.i50, align 4, !noalias !22
  %tbl_size.i.i54 = load i64, ptr %tbl_size_ptr.i.i51, align 4, !noalias !22
  %offset_tbl.i.i55 = load ptr, ptr %offset_tbl_ptr.i.i52, align 8, !noalias !22
  %product.i.i.i56 = mul i64 %hash_coef.i.i53, 4189192806087951739
  %shifted.i.i.i57 = lshr i64 %product.i.i.i56, 32
  %xored.i.i.i58 = xor i64 %shifted.i.i.i57, %product.i.i.i56
  %hash.i.i.i59 = and i64 %xored.i.i.i58, %tbl_size.i.i54
  %offset_ptr.i.i60 = getelementptr i32, ptr %offset_tbl.i.i55, i64 %hash.i.i.i59
  %offset.i.i75 = load i32, ptr %offset_ptr.i.i60, align 4, !noalias !644
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i75, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %24 = sext i32 %offset.i.i75 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i7789 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #15
  %28 = call { ptr, i160 } %result.i7789({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6) #7
  %.fca.0.extract4090 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13)
  %30 = icmp ne ptr %.fca.0.extract4090, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract4090, null
  %.not4891 = and i1 %30, %31
  br i1 %.not4891, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge:                                      ; preds = %5, %._crit_edge
  %32 = phi { ptr, i160 } [ %35, %._crit_edge ], [ %28, %5 ]
  %.pn92 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %3, %5 ]
  %33 = call { ptr, i160 } %.fca.0.extract3({ ptr, i160 } %.pn92, { ptr, i160 } %32)
  %34 = load ptr, ptr %26, align 8
  %result.i77 = call ptr %34({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #15
  %35 = call { ptr, i160 } %result.i77({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6) #7
  %.fca.0.extract40 = extractvalue { ptr, i160 } %35, 0
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13)
  %37 = icmp ne ptr %.fca.0.extract40, @nil_typ
  %38 = icmp ne ptr %.fca.0.extract40, null
  %.not48 = and i1 %37, %38
  br i1 %.not48, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %5
  %.pn.lcssa = phi { ptr, i160 } [ %3, %5 ], [ %33, %._crit_edge ]
  ret { ptr, i160 } %.pn.lcssa
}

define noundef i1 @Iterable2_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !647
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !647
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !647
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !647
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #38
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #15
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i34 = load i64, ptr %hash_coef_ptr.i.i31, align 4, !noalias !22
  %tbl_size.i.i35 = load i64, ptr %tbl_size_ptr.i.i32, align 4, !noalias !22
  %offset_tbl.i.i36 = load ptr, ptr %offset_tbl_ptr.i.i33, align 8, !noalias !22
  %product.i.i.i37 = mul i64 %hash_coef.i.i34, 4189192806087951739
  %shifted.i.i.i38 = lshr i64 %product.i.i.i37, 32
  %xored.i.i.i39 = xor i64 %shifted.i.i.i38, %product.i.i.i37
  %hash.i.i.i40 = and i64 %xored.i.i.i39, %tbl_size.i.i35
  %offset_ptr.i.i41 = getelementptr i32, ptr %offset_tbl.i.i36, i64 %hash.i.i.i40
  %offset.i.i56 = load i32, ptr %offset_ptr.i.i41, align 4, !noalias !650
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i56, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i56 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i58 = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #15
  %28 = call { ptr, i160 } %result.i58({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract25 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %30 = icmp eq ptr %.fca.0.extract25, @nil_typ
  %31 = icmp eq ptr %.fca.0.extract25, null
  %.not28.not = or i1 %30, %31
  br i1 %.not28.not, label %.critedge, label %32

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract3({ ptr, i160 } %28)
  br i1 %33, label %26, label %.critedge

.critedge:                                        ; preds = %26, %32
  ret i1 %.not28.not
}

define noundef i1 @Iterable2_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !653
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !653
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !653
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !653
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #38
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #15
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i31 = load i64, ptr %hash_coef_ptr.i.i28, align 4, !noalias !22
  %tbl_size.i.i32 = load i64, ptr %tbl_size_ptr.i.i29, align 4, !noalias !22
  %offset_tbl.i.i33 = load ptr, ptr %offset_tbl_ptr.i.i30, align 8, !noalias !22
  %product.i.i.i34 = mul i64 %hash_coef.i.i31, 4189192806087951739
  %shifted.i.i.i35 = lshr i64 %product.i.i.i34, 32
  %xored.i.i.i36 = xor i64 %shifted.i.i.i35, %product.i.i.i34
  %hash.i.i.i37 = and i64 %xored.i.i.i36, %tbl_size.i.i32
  %offset_ptr.i.i38 = getelementptr i32, ptr %offset_tbl.i.i33, i64 %hash.i.i.i37
  %offset.i.i53 = load i32, ptr %offset_ptr.i.i38, align 4, !noalias !656
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i53, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i53 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i55 = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #15
  %28 = call { ptr, i160 } %result.i55({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract23 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %30 = icmp ne ptr %.fca.0.extract23, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract23, null
  %.not26 = and i1 %30, %31
  br i1 %.not26, label %32, label %.critedge

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract3({ ptr, i160 } %28)
  br i1 %33, label %.critedge, label %26

.critedge:                                        ; preds = %26, %32
  ret i1 %.not26
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readonly %2, { ptr } %3) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !659
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !659
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !659
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !659
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i10 = tail call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i10, align 8
  %12 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %11, ptr %12, align 8
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i10) #34
  %hash_coef.i.i15 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i16 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i17 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i18 = mul i64 %hash_coef.i.i15, 5693646204635713916
  %shifted.i.i.i19 = lshr i64 %product.i.i.i18, 32
  %xored.i.i.i20 = xor i64 %shifted.i.i.i19, %product.i.i.i18
  %hash.i.i.i21 = and i64 %xored.i.i.i20, %tbl_size.i.i16
  %offset_ptr.i.i22 = getelementptr i32, ptr %offset_tbl.i.i17, i64 %hash.i.i.i21
  %offset.i.i23 = load i32, ptr %offset_ptr.i.i22, align 4, !noalias !22
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 10, 3
  %17 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.0.extract8, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.1.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.2.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store i32 %offset.i.i23, ptr %20, align 8
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef nonnull @MapIterable2) #34
  %22 = getelementptr inbounds i8, ptr %result.i10, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %22, align 8
  ret { ptr, ptr, ptr, i32 } %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !662
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !662
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !662
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !662
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i10 = tail call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i10, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i10) #34
  %hash_coef.i.i15 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i16 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i17 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i18 = mul i64 %hash_coef.i.i15, 5693646204635713916
  %shifted.i.i.i19 = lshr i64 %product.i.i.i18, 32
  %xored.i.i.i20 = xor i64 %shifted.i.i.i19, %product.i.i.i18
  %hash.i.i.i21 = and i64 %xored.i.i.i20, %tbl_size.i.i16
  %offset_ptr.i.i22 = getelementptr i32, ptr %offset_tbl.i.i17, i64 %hash.i.i.i21
  %offset.i.i23 = load i32, ptr %offset_ptr.i.i22, align 4, !noalias !22
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %.fca.0.extract8, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.1.extract, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.2.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store i32 %offset.i.i23, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @FilterIterable2) #34
  %18 = getelementptr inbounds i8, ptr %result.i10, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %18, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !665
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !665
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !665
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !665
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i16 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i17 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #5
  %result.i30 = tail call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i30, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i30) #34
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 5693646204635713916
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !22
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i30, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @ChainIterable2) #34
  %14 = getelementptr inbounds i8, ptr %result.i30, i64 8
  store ptr %.fca.0.extract7, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i30, i64 16
  store ptr %.fca.1.extract8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i30, i64 24
  store ptr %.fca.2.extract9, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i30, i64 32
  store i32 %offset.i.i43, ptr %17, align 8
  %hash_coef.i.i107 = load i64, ptr %hash_coef_ptr.i.i16, align 4, !noalias !22
  %tbl_size.i.i108 = load i64, ptr %tbl_size_ptr.i.i17, align 4, !noalias !22
  %offset_tbl.i.i109 = load ptr, ptr %offset_tbl_ptr.i.i18, align 8, !noalias !22
  %product.i.i.i110 = mul i64 %hash_coef.i.i107, 5693646204635713916
  %shifted.i.i.i111 = lshr i64 %product.i.i.i110, 32
  %xored.i.i.i112 = xor i64 %shifted.i.i.i111, %product.i.i.i110
  %hash.i.i.i113 = and i64 %xored.i.i.i112, %tbl_size.i.i108
  %offset_ptr.i.i114 = getelementptr i32, ptr %offset_tbl.i.i109, i64 %hash.i.i.i113
  %offset.i.i102 = load i32, ptr %offset_ptr.i.i114, align 4, !noalias !668
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @ChainIterable2) #34
  %19 = getelementptr inbounds i8, ptr %result.i30, i64 40
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i30, i64 48
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i30, i64 56
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i30, i64 64
  store i32 %offset.i.i102, ptr %22, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !671
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !671
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !671
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !671
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i16 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i17 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #5
  %result.i30 = tail call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i30, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i30) #34
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 5693646204635713916
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !22
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i30, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @InterleaveIterable2) #34
  %14 = getelementptr inbounds i8, ptr %result.i30, i64 8
  store ptr %.fca.0.extract7, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i30, i64 16
  store ptr %.fca.1.extract8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i30, i64 24
  store ptr %.fca.2.extract9, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i30, i64 32
  store i32 %offset.i.i43, ptr %17, align 8
  %hash_coef.i.i107 = load i64, ptr %hash_coef_ptr.i.i16, align 4, !noalias !22
  %tbl_size.i.i108 = load i64, ptr %tbl_size_ptr.i.i17, align 4, !noalias !22
  %offset_tbl.i.i109 = load ptr, ptr %offset_tbl_ptr.i.i18, align 8, !noalias !22
  %product.i.i.i110 = mul i64 %hash_coef.i.i107, 5693646204635713916
  %shifted.i.i.i111 = lshr i64 %product.i.i.i110, 32
  %xored.i.i.i112 = xor i64 %shifted.i.i.i111, %product.i.i.i110
  %hash.i.i.i113 = and i64 %xored.i.i.i112, %tbl_size.i.i108
  %offset_ptr.i.i114 = getelementptr i32, ptr %offset_tbl.i.i109, i64 %hash.i.i.i113
  %offset.i.i102 = load i32, ptr %offset_ptr.i.i114, align 4, !noalias !674
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @InterleaveIterable2) #34
  %19 = getelementptr inbounds i8, ptr %result.i30, i64 40
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i30, i64 48
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i30, i64 56
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i30, i64 64
  store i32 %offset.i.i102, ptr %22, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !677
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !677
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !677
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !677
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i40 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #5
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i52 = tail call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #5
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %result.i53 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %14 = getelementptr inbounds i8, ptr %result.i53, i64 16
  store ptr %result.i52, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i53, i64 8
  store ptr %result.i, ptr %15, align 8
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i53) #34
  store ptr @Pair, ptr %result.i53, align 8
  %result.i55 = tail call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i55, align 8
  %17 = getelementptr inbounds i8, ptr %result.i55, i64 8
  store ptr %result.i52, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i55, i64 16
  store ptr %result.i53, ptr %18, align 8
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i55) #34
  %hash_coef.i.i60 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i61 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i62 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i63 = mul i64 %hash_coef.i.i60, 5693646204635713916
  %shifted.i.i.i64 = lshr i64 %product.i.i.i63, 32
  %xored.i.i.i65 = xor i64 %shifted.i.i.i64, %product.i.i.i63
  %hash.i.i.i66 = and i64 %xored.i.i.i65, %tbl_size.i.i61
  %offset_ptr.i.i67 = getelementptr i32, ptr %offset_tbl.i.i62, i64 %hash.i.i.i66
  %offset.i.i68 = load i32, ptr %offset_ptr.i.i67, align 4, !noalias !22
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i55, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ZipIterable2) #34
  %25 = getelementptr inbounds i8, ptr %result.i55, i64 24
  store ptr %.fca.0.extract30, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %result.i55, i64 32
  store ptr %.fca.1.extract31, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i55, i64 40
  store ptr %.fca.2.extract32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i55, i64 48
  store i32 %offset.i.i68, ptr %28, align 8
  %hash_coef.i.i136 = load i64, ptr %hash_coef_ptr.i.i39, align 4, !noalias !22
  %tbl_size.i.i137 = load i64, ptr %tbl_size_ptr.i.i40, align 4, !noalias !22
  %offset_tbl.i.i138 = load ptr, ptr %offset_tbl_ptr.i.i41, align 8, !noalias !22
  %product.i.i.i139 = mul i64 %hash_coef.i.i136, 5693646204635713916
  %shifted.i.i.i140 = lshr i64 %product.i.i.i139, 32
  %xored.i.i.i141 = xor i64 %shifted.i.i.i140, %product.i.i.i139
  %hash.i.i.i142 = and i64 %xored.i.i.i141, %tbl_size.i.i137
  %offset_ptr.i.i143 = getelementptr i32, ptr %offset_tbl.i.i138, i64 %hash.i.i.i142
  %offset.i.i131 = load i32, ptr %offset_ptr.i.i143, align 4, !noalias !680
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ZipIterable2) #34
  %30 = getelementptr inbounds i8, ptr %result.i55, i64 56
  store ptr %.fca.0.extract23, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %result.i55, i64 64
  store ptr %.fca.1.extract24, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %result.i55, i64 72
  store ptr %.fca.2.extract25, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i55, i64 80
  store i32 %offset.i.i131, ptr %33, align 8
  ret { ptr, ptr, ptr, i32 } %22
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !683
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !683
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !683
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !683
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i40 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #5
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i52 = tail call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #5
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %result.i53 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %14 = getelementptr inbounds i8, ptr %result.i53, i64 16
  store ptr %result.i52, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i53, i64 8
  store ptr %result.i, ptr %15, align 8
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i53) #34
  store ptr @Pair, ptr %result.i53, align 8
  %result.i55 = tail call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i55, align 8
  %17 = getelementptr inbounds i8, ptr %result.i55, i64 8
  store ptr %result.i52, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i55, i64 16
  store ptr %result.i53, ptr %18, align 8
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i55) #34
  %hash_coef.i.i60 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i61 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i62 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i63 = mul i64 %hash_coef.i.i60, 5693646204635713916
  %shifted.i.i.i64 = lshr i64 %product.i.i.i63, 32
  %xored.i.i.i65 = xor i64 %shifted.i.i.i64, %product.i.i.i63
  %hash.i.i.i66 = and i64 %xored.i.i.i65, %tbl_size.i.i61
  %offset_ptr.i.i67 = getelementptr i32, ptr %offset_tbl.i.i62, i64 %hash.i.i.i66
  %offset.i.i68 = load i32, ptr %offset_ptr.i.i67, align 4, !noalias !22
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i55, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ProductIterable2) #34
  %25 = getelementptr inbounds i8, ptr %result.i55, i64 24
  store ptr %.fca.0.extract30, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %result.i55, i64 32
  store ptr %.fca.1.extract31, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i55, i64 40
  store ptr %.fca.2.extract32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i55, i64 48
  store i32 %offset.i.i68, ptr %28, align 8
  %hash_coef.i.i136 = load i64, ptr %hash_coef_ptr.i.i39, align 4, !noalias !22
  %tbl_size.i.i137 = load i64, ptr %tbl_size_ptr.i.i40, align 4, !noalias !22
  %offset_tbl.i.i138 = load ptr, ptr %offset_tbl_ptr.i.i41, align 8, !noalias !22
  %product.i.i.i139 = mul i64 %hash_coef.i.i136, 5693646204635713916
  %shifted.i.i.i140 = lshr i64 %product.i.i.i139, 32
  %xored.i.i.i141 = xor i64 %shifted.i.i.i140, %product.i.i.i139
  %hash.i.i.i142 = and i64 %xored.i.i.i141, %tbl_size.i.i137
  %offset_ptr.i.i143 = getelementptr i32, ptr %offset_tbl.i.i138, i64 %hash.i.i.i142
  %offset.i.i131 = load i32, ptr %offset_ptr.i.i143, align 4, !noalias !686
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ProductIterable2) #34
  %30 = getelementptr inbounds i8, ptr %result.i55, i64 56
  store ptr %.fca.0.extract23, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %result.i55, i64 64
  store ptr %.fca.1.extract24, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %result.i55, i64 72
  store ptr %.fca.2.extract25, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i55, i64 80
  store i32 %offset.i.i131, ptr %33, align 8
  ret { ptr, ptr, ptr, i32 } %22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ProductIterable2_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !689
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !689
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !689
  %product.i.i.i = mul i64 %hash_coef.i.i, 7827074759551300494
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !689
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !692
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !695
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ProductIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !698
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !698
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !698
  %product.i.i.i = mul i64 %hash_coef.i.i, 7827074759551300494
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !698
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract51, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract53) #36
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43) #40
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract53) #36
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %29 = load ptr, ptr %7, align 8
  %result.i77 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #5
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i78 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #5
  %result.i79 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %33 = getelementptr inbounds i8, ptr %result.i79, i64 16
  store ptr %result.i78, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i79, i64 8
  store ptr %result.i77, ptr %34, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i79)
  store ptr @Pair, ptr %result.i79, align 8
  %result.i81 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_inner(i64 noundef 152, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i77, ptr %result.i81, align 8
  %36 = getelementptr inbounds i8, ptr %result.i81, i64 8
  store ptr %result.i78, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i81, i64 16
  store ptr %result.i79, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i81)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %40 = load ptr, ptr %8, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr, ptr, ptr, i32 } %41(ptr %.fca.1.extract53) #36
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %42, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %42, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %42, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %42, 3
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract11, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract13, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.fca.3.extract15, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract9)
  %49 = sext i32 %.fca.3.extract15 to i64
  %50 = getelementptr ptr, ptr %.fca.0.extract9, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i82 = call ptr %52({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly %4) #15
  %53 = call { ptr, ptr, ptr, i32 } %result.i82({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %53, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %53, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %53, 2
  %hash_coef_ptr.i.i84 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i85 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i86 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i87 = load i64, ptr %hash_coef_ptr.i.i84, align 4, !noalias !22
  %tbl_size.i.i88 = load i64, ptr %tbl_size_ptr.i.i85, align 4, !noalias !22
  %offset_tbl.i.i89 = load ptr, ptr %offset_tbl_ptr.i.i86, align 8, !noalias !22
  %product.i.i.i90 = mul i64 %hash_coef.i.i87, 4189192806087951739
  %shifted.i.i.i91 = lshr i64 %product.i.i.i90, 32
  %xored.i.i.i92 = xor i64 %shifted.i.i.i91, %product.i.i.i90
  %hash.i.i.i93 = and i64 %xored.i.i.i92, %tbl_size.i.i88
  %offset_ptr.i.i94 = getelementptr i32, ptr %offset_tbl.i.i89, i64 %hash.i.i.i93
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %55 = load ptr, ptr %24, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = call { ptr, ptr, ptr, i32 } %56(ptr %.fca.1.extract53) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %57, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %57, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %57, 2
  %offset.i.i109 = load i32, ptr %offset_ptr.i.i94, align 4, !noalias !22
  %hash_coef_ptr.i.i112 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i113 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i114 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %58 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.1.extract, 1
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %.fca.2.extract, 2
  %61 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i81, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr undef, 2
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %4)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator2) #34
  %64 = getelementptr inbounds i8, ptr %result.i81, i64 24
  store ptr %.fca.0.extract1, ptr %64, align 8
  %65 = getelementptr inbounds i8, ptr %result.i81, i64 32
  store ptr %.fca.1.extract3, ptr %65, align 8
  %66 = getelementptr inbounds i8, ptr %result.i81, i64 40
  store ptr %.fca.2.extract5, ptr %66, align 8
  %67 = getelementptr inbounds i8, ptr %result.i81, i64 48
  store i32 %offset.i.i109, ptr %67, align 8
  %hash_coef.i.i89.i = load i64, ptr %hash_coef_ptr.i.i112, align 4, !noalias !22
  %tbl_size.i.i90.i = load i64, ptr %tbl_size_ptr.i.i113, align 4, !noalias !22
  %offset_tbl.i.i91.i = load ptr, ptr %offset_tbl_ptr.i.i114, align 8, !noalias !22
  %product.i.i.i92.i = mul i64 %hash_coef.i.i89.i, 5693646204635713916
  %shifted.i.i.i93.i = lshr i64 %product.i.i.i92.i, 32
  %xored.i.i.i94.i = xor i64 %shifted.i.i.i93.i, %product.i.i.i92.i
  %hash.i.i.i95.i = and i64 %xored.i.i.i94.i, %tbl_size.i.i90.i
  %offset_ptr.i.i96.i = getelementptr i32, ptr %offset_tbl.i.i91.i, i64 %hash.i.i.i95.i
  %offset.i.i111.i = load i32, ptr %offset_ptr.i.i96.i, align 4, !noalias !701
  %68 = getelementptr inbounds i8, ptr %result.i81, i64 88
  store ptr %.fca.0.extract, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %result.i81, i64 96
  store ptr %.fca.1.extract, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i81, i64 104
  store ptr %.fca.2.extract, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i81, i64 112
  store i32 %offset.i.i111.i, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator2) #34
  %73 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %offset.i.i111.i, 3
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #34
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract) #34
  %76 = sext i32 %offset.i.i111.i to i64
  %77 = getelementptr ptr, ptr %.fca.0.extract, i64 %76
  %78 = getelementptr i8, ptr %77, i64 8
  %79 = load ptr, ptr %78, align 8
  %result.i.i = call ptr %79({ ptr, ptr, ptr, i32 } %73, ptr nocapture nofree noundef nonnull readonly %4) #15
  %80 = call { ptr, ptr, ptr, i32 } %result.i.i({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull align 8 %4) #7
  %.fca.0.extract3.i = extractvalue { ptr, ptr, ptr, i32 } %80, 0
  %.fca.1.extract5.i = extractvalue { ptr, ptr, ptr, i32 } %80, 1
  %.fca.2.extract7.i = extractvalue { ptr, ptr, ptr, i32 } %80, 2
  %hash_coef_ptr.i.i114.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 8
  %tbl_size_ptr.i.i115.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 16
  %offset_tbl_ptr.i.i116.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 40
  %hash_coef.i.i117.i = load i64, ptr %hash_coef_ptr.i.i114.i, align 4, !noalias !22
  %tbl_size.i.i118.i = load i64, ptr %tbl_size_ptr.i.i115.i, align 4, !noalias !22
  %offset_tbl.i.i119.i = load ptr, ptr %offset_tbl_ptr.i.i116.i, align 8, !noalias !22
  %product.i.i.i120.i = mul i64 %hash_coef.i.i117.i, 4189192806087951739
  %shifted.i.i.i121.i = lshr i64 %product.i.i.i120.i, 32
  %xored.i.i.i122.i = xor i64 %shifted.i.i.i121.i, %product.i.i.i120.i
  %hash.i.i.i123.i = and i64 %xored.i.i.i122.i, %tbl_size.i.i118.i
  %offset_ptr.i.i124.i = getelementptr i32, ptr %offset_tbl.i.i119.i, i64 %hash.i.i.i123.i
  %offset.i.i139.i = load i32, ptr %offset_ptr.i.i124.i, align 4, !noalias !704
  %81 = getelementptr inbounds i8, ptr %result.i81, i64 56
  store ptr %.fca.0.extract3.i, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i81, i64 64
  store ptr %.fca.1.extract5.i, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i81, i64 72
  store ptr %.fca.2.extract7.i, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i81, i64 80
  store i32 %offset.i.i139.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator2)
  %86 = load ptr, ptr %64, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %86, 0
  %88 = load ptr, ptr %65, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %88, 1
  %90 = load ptr, ptr %66, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } %89, ptr %90, 2
  %92 = load i32, ptr %67, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, i32 %92, 3
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %86)
  %96 = sext i32 %92 to i64
  %97 = getelementptr ptr, ptr %86, i64 %96
  %98 = getelementptr i8, ptr %97, i64 8
  %99 = load ptr, ptr %98, align 8
  %result.i141.i = call ptr %99({ ptr, ptr, ptr, i32 } %93, ptr nocapture nofree noundef nonnull readonly %4) #15
  %100 = call { ptr, i160 } %result.i141.i({ ptr, ptr, ptr, i32 } %93, { ptr, ptr, ptr, i32 } %93, ptr nonnull align 8 %4) #7
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator2)
  %102 = getelementptr inbounds i8, ptr %result.i81, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %100, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %100, 1
  store ptr %.fca.0.extract.i, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %result.i81, i64 128
  store i160 %.fca.1.extract.i, ptr %103, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %4)
  %104 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %104
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 152, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator2_B_init_first_iteratorIterator2T_second_iterableIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define void @ProductIterator2_init_first_iteratorIterator2T_second_iterableIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #7 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !707
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !707
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !707
  %product.i.i.i = mul i64 %hash_coef.i.i, 4440657219728359865
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !707
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i58 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i59 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i60 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i61 = load i64, ptr %hash_coef_ptr.i.i58, align 4, !noalias !22
  %tbl_size.i.i62 = load i64, ptr %tbl_size_ptr.i.i59, align 4, !noalias !22
  %offset_tbl.i.i63 = load ptr, ptr %offset_tbl_ptr.i.i60, align 8, !noalias !22
  %product.i.i.i64 = mul i64 %hash_coef.i.i61, 4189192806087951739
  %shifted.i.i.i65 = lshr i64 %product.i.i.i64, 32
  %xored.i.i.i66 = xor i64 %shifted.i.i.i65, %product.i.i.i64
  %hash.i.i.i67 = and i64 %xored.i.i.i66, %tbl_size.i.i62
  %offset_ptr.i.i68 = getelementptr i32, ptr %offset_tbl.i.i63, i64 %hash.i.i.i67
  %offset.i.i83 = load i32, ptr %offset_ptr.i.i68, align 4, !noalias !710
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract45, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract35, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract37, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i83, 3
  tail call void %13(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %17) #35
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i86 = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i87 = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i88 = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i89 = load i64, ptr %hash_coef_ptr.i.i86, align 4, !noalias !22
  %tbl_size.i.i90 = load i64, ptr %tbl_size_ptr.i.i87, align 4, !noalias !22
  %offset_tbl.i.i91 = load ptr, ptr %offset_tbl_ptr.i.i88, align 8, !noalias !22
  %product.i.i.i92 = mul i64 %hash_coef.i.i89, 5693646204635713916
  %shifted.i.i.i93 = lshr i64 %product.i.i.i92, 32
  %xored.i.i.i94 = xor i64 %shifted.i.i.i93, %product.i.i.i92
  %hash.i.i.i95 = and i64 %xored.i.i.i94, %tbl_size.i.i90
  %offset_ptr.i.i96 = getelementptr i32, ptr %offset_tbl.i.i91, i64 %hash.i.i.i95
  %offset.i.i111 = load i32, ptr %offset_ptr.i.i96, align 4, !noalias !713
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #34
  %19 = getelementptr i8, ptr %9, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract23, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract25, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i111, 3
  tail call void %22(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %26) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #34
  %28 = load ptr, ptr %19, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call { ptr, ptr, ptr, i32 } %29(ptr %.fca.1.extract47) #36
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %30, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %30, 1
  %.fca.2.extract17 = extractvalue { ptr, ptr, ptr, i32 } %30, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %30, 3
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract15, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract17, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %.fca.3.extract19, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #34
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %37 = sext i32 %.fca.3.extract19 to i64
  %38 = getelementptr ptr, ptr %.fca.0.extract13, i64 %37
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %result.i = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly %6) #15
  %41 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %6) #7
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %hash_coef_ptr.i.i114 = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i115 = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i116 = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i117 = load i64, ptr %hash_coef_ptr.i.i114, align 4, !noalias !22
  %tbl_size.i.i118 = load i64, ptr %tbl_size_ptr.i.i115, align 4, !noalias !22
  %offset_tbl.i.i119 = load ptr, ptr %offset_tbl_ptr.i.i116, align 8, !noalias !22
  %product.i.i.i120 = mul i64 %hash_coef.i.i117, 4189192806087951739
  %shifted.i.i.i121 = lshr i64 %product.i.i.i120, 32
  %xored.i.i.i122 = xor i64 %shifted.i.i.i121, %product.i.i.i120
  %hash.i.i.i123 = and i64 %xored.i.i.i122, %tbl_size.i.i118
  %offset_ptr.i.i124 = getelementptr i32, ptr %offset_tbl.i.i119, i64 %hash.i.i.i123
  %offset.i.i139 = load i32, ptr %offset_ptr.i.i124, align 4, !noalias !716
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %43 = getelementptr i8, ptr %9, i64 32
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %44, i64 8
  %46 = load ptr, ptr %45, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract5, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract7, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i.i139, 3
  call void %46(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %50) #35
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %52 = load ptr, ptr %10, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %.fca.1.extract47) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.1.extract2, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.2.extract, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %.fca.3.extract, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %61 = sext i32 %.fca.3.extract to i64
  %62 = getelementptr ptr, ptr %.fca.0.extract1, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %result.i141 = call ptr %64({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly %6) #15
  %65 = call { ptr, i160 } %result.i141({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %6) #7
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %67 = getelementptr i8, ptr %9, i64 48
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  call void %70(ptr %.fca.1.extract47, { ptr, i160 } %65) #35
  ret void
}

define { ptr, i160 } @ProductIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 4440657219728359865
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract10) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = getelementptr i8, ptr %7, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, i160 } %10(ptr %.fca.1.extract12) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %.sroa.0.0188 = extractvalue { ptr, i160 } %11, 0
  %13 = icmp ne ptr %.sroa.0.0188, @nil_typ
  %14 = icmp ne ptr %.sroa.0.0188, null
  %.not82189 = and i1 %13, %14
  br i1 %.not82189, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %3
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %16 = getelementptr i8, ptr %7, i64 32
  %17 = getelementptr i8, ptr %7, i64 24
  %18 = getelementptr i8, ptr %7, i64 40
  br label %19

19:                                               ; preds = %.lr.ph, %37
  %.pn190 = phi { ptr, i160 } [ %11, %.lr.ph ], [ %83, %37 ]
  %20 = load ptr, ptr %16, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call { ptr, ptr, ptr, i32 } %21(ptr %.fca.1.extract12) #36
  %.fca.0.extract68 = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract70 = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract72 = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %.fca.3.extract74 = extractvalue { ptr, ptr, ptr, i32 } %22, 3
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract68, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract70, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract72, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %.fca.3.extract74, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract68)
  %29 = sext i32 %.fca.3.extract74 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract68, i64 %29
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i = call ptr %32({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %4) #15
  %33 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %4) #7
  %.fca.0.extract61 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %35 = icmp ne ptr %.fca.0.extract61, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract61, null
  %.not84 = and i1 %35, %36
  br i1 %.not84, label %86, label %37

37:                                               ; preds = %19
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %39 = load ptr, ptr %17, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call { ptr, ptr, ptr, i32 } %40(ptr nonnull %.fca.1.extract12) #36
  %.fca.0.extract42 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract46 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %.fca.3.extract48 = extractvalue { ptr, ptr, ptr, i32 } %41, 3
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract42, 0
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.1.extract44, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.2.extract46, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %.fca.3.extract48, 3
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract42)
  %48 = sext i32 %.fca.3.extract48 to i64
  %49 = getelementptr ptr, ptr %.fca.0.extract42, i64 %48
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  %result.i86 = call ptr %51({ ptr, ptr, ptr, i32 } %45, ptr nocapture nofree noundef nonnull readonly %4) #15
  %52 = call { ptr, i160 } %result.i86({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull align 8 %4) #7
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %54 = load ptr, ptr %8, align 8
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  call void %56(ptr %.fca.1.extract12, { ptr, i160 } %52) #35
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %58 = load ptr, ptr %18, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract12) #36
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract35 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract30, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract32, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract34, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract35, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30)
  %67 = sext i32 %.fca.3.extract35 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract30, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i87 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #15
  %71 = call { ptr, ptr, ptr, i32 } %result.i87({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract24 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i89 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i.i90 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i.i91 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i.i92 = load i64, ptr %hash_coef_ptr.i.i89, align 4
  %tbl_size.i.i93 = load i64, ptr %tbl_size_ptr.i.i90, align 4
  %offset_tbl.i.i94 = load ptr, ptr %offset_tbl_ptr.i.i91, align 8
  %product.i.i.i95 = mul i64 %hash_coef.i.i92, 4189192806087951739
  %shifted.i.i.i96 = lshr i64 %product.i.i.i95, 32
  %xored.i.i.i97 = xor i64 %shifted.i.i.i96, %product.i.i.i95
  %hash.i.i.i98 = and i64 %xored.i.i.i97, %tbl_size.i.i93
  %offset_ptr.i.i99 = getelementptr i32, ptr %offset_tbl.i.i94, i64 %hash.i.i.i98
  %offset.i.i114 = load i32, ptr %offset_ptr.i.i99, align 4
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %73 = load ptr, ptr %16, align 8
  %74 = getelementptr i8, ptr %73, i64 8
  %75 = load ptr, ptr %74, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.fca.1.extract22, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.fca.2.extract24, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %offset.i.i114, 3
  call void %75(ptr %.fca.1.extract12, { ptr, ptr, ptr, i32 } %79) #35
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %81 = load ptr, ptr %8, align 8
  %82 = load ptr, ptr %81, align 8
  %83 = call { ptr, i160 } %82(ptr %.fca.1.extract12) #36
  %.sroa.0.0 = extractvalue { ptr, i160 } %83, 0
  %84 = icmp ne ptr %.sroa.0.0, @nil_typ
  %85 = icmp ne ptr %.sroa.0.0, null
  %.not82 = and i1 %84, %85
  br i1 %.not82, label %19, label %.loopexit

86:                                               ; preds = %19
  %87 = getelementptr i8, ptr %7, i64 8
  %88 = load ptr, ptr %87, align 8
  %result.i85 = call ptr %88(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %90 = load ptr, ptr %7, align 8
  %result.i116 = call ptr %90(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %91 = load ptr, ptr %result.i116, align 8
  %92 = getelementptr i8, ptr %91, i64 72
  %93 = load ptr, ptr %92, align 8
  %result.i.i = call { i64, i64 } %93(ptr nocapture nofree nonnull readonly %result.i116) #5
  %94 = extractvalue { i64, i64 } %result.i.i, 0
  %95 = extractvalue { i64, i64 } %result.i.i, 1
  %96 = urem i64 16, %95
  %97 = icmp eq i64 %96, 0
  %98 = sub i64 %95, %96
  %99 = select i1 %97, i64 0, i64 %98
  %100 = add i64 %94, 16
  %101 = add i64 %100, %99
  %102 = load ptr, ptr %result.i85, align 8
  %103 = getelementptr i8, ptr %102, i64 72
  %104 = load ptr, ptr %103, align 8
  %result.i1.i = call { i64, i64 } %104(ptr nocapture nofree nonnull readonly %result.i85) #5
  %105 = extractvalue { i64, i64 } %result.i1.i, 0
  %106 = extractvalue { i64, i64 } %result.i1.i, 1
  %107 = call i64 @llvm.umax.i64(i64 %95, i64 %106)
  %108 = call i64 @llvm.umax.i64(i64 %107, i64 8)
  %109 = urem i64 %101, %106
  %110 = icmp eq i64 %109, 0
  %111 = sub i64 %106, %109
  %112 = select i1 %110, i64 0, i64 %111
  %113 = add i64 %105, %101
  %114 = add i64 %113, %112
  %115 = urem i64 %114, %108
  %116 = icmp eq i64 %115, 0
  %117 = sub i64 %108, %115
  %118 = select i1 %116, i64 0, i64 %117
  %119 = add i64 %118, %114
  %result.i118 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %119, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i116, ptr %result.i118, align 8
  %120 = getelementptr inbounds i8, ptr %result.i118, i64 8
  store ptr %result.i85, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i118)
  %122 = load ptr, ptr %result.i116, align 8
  %123 = getelementptr i8, ptr %122, i64 72
  %124 = load ptr, ptr %123, align 8
  %result.i.i201 = call { i64, i64 } %124(ptr nocapture nofree nonnull readonly %result.i116) #5
  %125 = extractvalue { i64, i64 } %result.i.i201, 1
  %126 = urem i64 16, %125
  %127 = icmp eq i64 %126, 0
  %reass.sub = sub i64 %125, %126
  %128 = add i64 %reass.sub, 16
  %129 = select i1 %127, i64 16, i64 %128
  %130 = getelementptr i8, ptr %result.i118, i64 %129
  %131 = getelementptr i8, ptr %122, i64 64
  %132 = load ptr, ptr %131, align 8
  call void %132({ ptr, i160 } %.pn190, ptr nocapture nofree nonnull readonly %result.i116, ptr nocapture nofree writeonly %130) #12
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #34
  %134 = load ptr, ptr %result.i118, align 8
  %135 = load ptr, ptr %134, align 8
  %136 = getelementptr i8, ptr %135, i64 72
  %137 = load ptr, ptr %136, align 8
  %result.i.i202 = call { i64, i64 } %137(ptr nocapture nofree nonnull readonly %134) #5
  %138 = extractvalue { i64, i64 } %result.i.i202, 0
  %139 = extractvalue { i64, i64 } %result.i.i202, 1
  %140 = urem i64 16, %139
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %139, %140
  %143 = select i1 %141, i64 0, i64 %142
  %144 = add i64 %138, 16
  %145 = add i64 %144, %143
  %146 = load ptr, ptr %120, align 8
  %147 = load ptr, ptr %146, align 8
  %148 = getelementptr i8, ptr %147, i64 72
  %149 = load ptr, ptr %148, align 8
  %result.i1.i203 = call { i64, i64 } %149(ptr nocapture nofree nonnull readonly %146) #5
  %150 = extractvalue { i64, i64 } %result.i1.i203, 1
  %151 = urem i64 %145, %150
  %152 = icmp eq i64 %151, 0
  %153 = sub i64 %150, %151
  %154 = select i1 %152, i64 0, i64 %153
  %155 = getelementptr i8, ptr %result.i118, i64 %145
  %156 = getelementptr i8, ptr %155, i64 %154
  %157 = getelementptr i8, ptr %147, i64 64
  %158 = load ptr, ptr %157, align 8
  call void %158({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %146, ptr nocapture nofree writeonly %156) #12
  %159 = ptrtoint ptr %result.i118 to i64
  %.sroa.3.8.insert.ext = zext i64 %159 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.loopexit

.loopexit:                                        ; preds = %37, %3, %86
  %.reg2mem49.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %86 ], [ undef, %3 ], [ undef, %37 ]
  %.reg2mem49.sroa.0.0 = phi ptr [ @Pair, %86 ], [ @nil_typ, %3 ], [ @nil_typ, %37 ]
  %.reload50.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem49.sroa.0.0, 0
  %.reload50.fca.1.insert = insertvalue { ptr, i160 } %.reload50.fca.0.insert, i160 %.reg2mem49.sroa.3.0, 1
  ret { ptr, i160 } %.reload50.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @ProductIterator2_getter_current_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 4
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_current_first(ptr nocapture nofree writeonly %0, { ptr, i160 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_second_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_second_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_second_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_second_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_first_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_first_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterable2_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !719
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !719
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !719
  %product.i.i.i = mul i64 %hash_coef.i.i, -3218950579047519815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !719
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !722
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !725
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ZipIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !728
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !728
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !728
  %product.i.i.i = mul i64 %hash_coef.i.i, -3218950579047519815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !728
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #36
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #40
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #36
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #15
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i113 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %result.i114 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %44 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %result.i113, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %result.i112, ptr %45, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i114)
  store ptr @Pair, ptr %result.i114, align 8
  %result.i116 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i112, ptr %result.i116, align 8
  %47 = getelementptr inbounds i8, ptr %result.i116, i64 8
  store ptr %result.i113, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i116, i64 16
  store ptr %result.i114, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i116)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %51 = load ptr, ptr %8, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr, ptr, ptr, i32 } %52(ptr %.fca.1.extract73) #36
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %53, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %53, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %53, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %53, 3
  %54 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %.fca.1.extract19, 1
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.2.extract21, 2
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %.fca.3.extract23, 3
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %60 = sext i32 %.fca.3.extract23 to i64
  %61 = getelementptr ptr, ptr %.fca.0.extract17, i64 %60
  %62 = getelementptr i8, ptr %61, i64 8
  %63 = load ptr, ptr %62, align 8
  %result.i117 = call ptr %63({ ptr, ptr, ptr, i32 } %57, ptr nocapture nofree noundef nonnull readonly %4) #15
  %64 = call { ptr, ptr, ptr, i32 } %result.i117({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %64, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %64, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %64, 2
  %hash_coef_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i120 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i121 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %66 = load ptr, ptr %24, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr, ptr, ptr, i32 } %67(ptr %.fca.1.extract73) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %68, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %68, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %68, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %68, 3
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %.fca.1.extract2, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %.fca.2.extract3, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %.fca.3.extract4, 3
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %75 = sext i32 %.fca.3.extract4 to i64
  %76 = getelementptr ptr, ptr %.fca.0.extract1, i64 %75
  %77 = getelementptr i8, ptr %76, i64 8
  %78 = load ptr, ptr %77, align 8
  %result.i132 = call ptr %78({ ptr, ptr, ptr, i32 } %72, ptr nocapture nofree noundef nonnull readonly %4) #15
  %79 = call { ptr, ptr, ptr, i32 } %result.i132({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %79, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %79, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %79, 2
  %hash_coef_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i135 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i136 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i151 = load i64, ptr %hash_coef_ptr.i.i119, align 4, !noalias !22
  %tbl_size.i.i152 = load i64, ptr %tbl_size_ptr.i.i120, align 4, !noalias !22
  %offset_tbl.i.i153 = load ptr, ptr %offset_tbl_ptr.i.i121, align 8, !noalias !22
  %product.i.i.i154 = mul i64 %hash_coef.i.i151, 4189192806087951739
  %shifted.i.i.i155 = lshr i64 %product.i.i.i154, 32
  %xored.i.i.i156 = xor i64 %shifted.i.i.i155, %product.i.i.i154
  %hash.i.i.i157 = and i64 %xored.i.i.i156, %tbl_size.i.i152
  %offset_ptr.i.i158 = getelementptr i32, ptr %offset_tbl.i.i153, i64 %hash.i.i.i157
  %offset.i.i159 = load i32, ptr %offset_ptr.i.i158, align 4, !noalias !22
  %80 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i116, 1
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr undef, 2
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull @ZipIterator2) #34
  %83 = getelementptr inbounds i8, ptr %result.i116, i64 24
  store ptr %.fca.0.extract5, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i116, i64 32
  store ptr %.fca.1.extract7, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %result.i116, i64 40
  store ptr %.fca.2.extract9, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %result.i116, i64 48
  store i32 %offset.i.i159, ptr %86, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i134, align 4, !noalias !22
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i135, align 4, !noalias !22
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i136, align 8, !noalias !22
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4189192806087951739
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !731
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull @ZipIterator2) #34
  %88 = getelementptr inbounds i8, ptr %result.i116, i64 56
  store ptr %.fca.0.extract, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i116, i64 64
  store ptr %.fca.1.extract, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i116, i64 72
  store ptr %.fca.2.extract, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i116, i64 80
  store i32 %offset.i.i71.i, ptr %91, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %92
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator2_B_init_firstIterator2T_secondIterator2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterator2_init_firstIterator2T_secondIterator2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !734
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !734
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !734
  %product.i.i.i = mul i64 %hash_coef.i.i, 5502728639611621286
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !734
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !737
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !740
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ZipIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !743
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !743
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !743
  %product.i.i.i = mul i64 %hash_coef.i.i, 5502728639611621286
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !743
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract28, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract30) #36
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract12 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract14 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract10, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract12, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract14, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract8) #40
  %18 = sext i32 %.fca.3.extract14 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract8, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract4 = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract30) #36
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract3, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract2, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i60 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #15
  %38 = call { ptr, i160 } %result.i60({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28)
  %40 = load ptr, ptr %7, align 8
  %result.i61 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract30) #5
  %41 = icmp ne ptr %.fca.0.extract4, @nil_typ
  %42 = icmp ne ptr %.fca.0.extract4, null
  %.not55 = and i1 %41, %42
  br i1 %.not55, label %43, label %.thread

43:                                               ; preds = %3
  %.fca.0.extract = extractvalue { ptr, i160 } %38, 0
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull %.fca.0.extract28)
  %45 = icmp ne ptr %.fca.0.extract, @nil_typ
  %46 = icmp ne ptr %.fca.0.extract, null
  %.not57.not.not = and i1 %45, %46
  br i1 %.not57.not.not, label %47, label %.thread

47:                                               ; preds = %43
  %48 = getelementptr i8, ptr %7, i64 8
  %49 = load ptr, ptr %48, align 8
  %result.i62 = call ptr %49(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract30) #5
  %50 = load ptr, ptr %result.i61, align 8, !alias.scope !746
  %51 = getelementptr i8, ptr %50, i64 72
  %52 = load ptr, ptr %51, align 8, !alias.scope !746
  %result.i.i = call { i64, i64 } %52(ptr nocapture nofree nonnull readonly %result.i61) #5, !alias.scope !746
  %53 = extractvalue { i64, i64 } %result.i.i, 0
  %54 = extractvalue { i64, i64 } %result.i.i, 1
  %55 = urem i64 16, %54
  %56 = icmp eq i64 %55, 0
  %57 = sub i64 %54, %55
  %58 = select i1 %56, i64 0, i64 %57
  %59 = add i64 %53, 16
  %60 = add i64 %59, %58
  %61 = load ptr, ptr %result.i62, align 8, !alias.scope !746
  %62 = getelementptr i8, ptr %61, i64 72
  %63 = load ptr, ptr %62, align 8, !alias.scope !746
  %result.i1.i = call { i64, i64 } %63(ptr nocapture nofree nonnull readonly %result.i62) #5, !alias.scope !746
  %64 = extractvalue { i64, i64 } %result.i1.i, 0
  %65 = extractvalue { i64, i64 } %result.i1.i, 1
  %66 = call i64 @llvm.umax.i64(i64 %54, i64 %65)
  %67 = call i64 @llvm.umax.i64(i64 %66, i64 8)
  %68 = urem i64 %60, %65
  %69 = icmp eq i64 %68, 0
  %70 = sub i64 %65, %68
  %71 = select i1 %69, i64 0, i64 %70
  %72 = add i64 %64, %60
  %73 = add i64 %72, %71
  %74 = urem i64 %73, %67
  %75 = icmp eq i64 %74, 0
  %76 = sub i64 %67, %74
  %77 = select i1 %75, i64 0, i64 %76
  %78 = add i64 %77, %73
  %result.i64 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %78, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i61, ptr %result.i64, align 8
  %79 = getelementptr inbounds i8, ptr %result.i64, i64 8
  store ptr %result.i62, ptr %79, align 8
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i64)
  %81 = load ptr, ptr %result.i61, align 8
  %82 = getelementptr i8, ptr %81, i64 72
  %83 = load ptr, ptr %82, align 8
  %result.i.i83 = call { i64, i64 } %83(ptr nocapture nofree nonnull readonly %result.i61) #5
  %84 = extractvalue { i64, i64 } %result.i.i83, 1
  %85 = urem i64 16, %84
  %86 = icmp eq i64 %85, 0
  %reass.sub = sub i64 %84, %85
  %87 = add i64 %reass.sub, 16
  %88 = select i1 %86, i64 16, i64 %87
  %89 = getelementptr i8, ptr %result.i64, i64 %88
  %90 = getelementptr i8, ptr %81, i64 64
  %91 = load ptr, ptr %90, align 8
  call void %91({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly %result.i61, ptr nocapture nofree writeonly %89) #12
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #34
  %93 = load ptr, ptr %result.i64, align 8
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr i8, ptr %94, i64 72
  %96 = load ptr, ptr %95, align 8
  %result.i.i84 = call { i64, i64 } %96(ptr nocapture nofree nonnull readonly %93) #5
  %97 = extractvalue { i64, i64 } %result.i.i84, 0
  %98 = extractvalue { i64, i64 } %result.i.i84, 1
  %99 = urem i64 16, %98
  %100 = icmp eq i64 %99, 0
  %101 = sub i64 %98, %99
  %102 = select i1 %100, i64 0, i64 %101
  %103 = add i64 %97, 16
  %104 = add i64 %103, %102
  %105 = load ptr, ptr %79, align 8
  %106 = load ptr, ptr %105, align 8
  %107 = getelementptr i8, ptr %106, i64 72
  %108 = load ptr, ptr %107, align 8
  %result.i1.i85 = call { i64, i64 } %108(ptr nocapture nofree nonnull readonly %105) #5
  %109 = extractvalue { i64, i64 } %result.i1.i85, 1
  %110 = urem i64 %104, %109
  %111 = icmp eq i64 %110, 0
  %112 = sub i64 %109, %110
  %113 = select i1 %111, i64 0, i64 %112
  %114 = getelementptr i8, ptr %result.i64, i64 %104
  %115 = getelementptr i8, ptr %114, i64 %113
  %116 = getelementptr i8, ptr %106, i64 64
  %117 = load ptr, ptr %116, align 8
  call void %117({ ptr, i160 } %38, ptr nocapture nofree nonnull readonly %105, ptr nocapture nofree writeonly %115) #12
  %118 = ptrtoint ptr %result.i64 to i64
  %.sroa.344.8.insert.ext = zext i64 %118 to i160
  %.sroa.344.8.insert.insert = or disjoint i160 %.sroa.344.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.thread

.thread:                                          ; preds = %3, %43, %47
  %.reg2mem41.sroa.3.082 = phi i160 [ %.sroa.344.8.insert.insert, %47 ], [ poison, %43 ], [ poison, %3 ]
  %119 = phi ptr [ @Pair, %47 ], [ @nil_typ, %43 ], [ @nil_typ, %3 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %119, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem41.sroa.3.082, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterable2_field_InterleaveIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterable2_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !749
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !749
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !749
  %product.i.i.i = mul i64 %hash_coef.i.i, -6258231685215461775
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !749
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !752
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !755
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @InterleaveIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !758
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !758
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !758
  %product.i.i.i = mul i64 %hash_coef.i.i, -6258231685215461775
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !758
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #36
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #40
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #36
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #15
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %result.i114 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i112, ptr %result.i114, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i114)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #36
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i115 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %4) #15
  %56 = call { ptr, ptr, ptr, i32 } %result.i115({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i117 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i118 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i130 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #15
  %71 = call { ptr, ptr, ptr, i32 } %result.i130({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i132 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i133 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i149 = load i64, ptr %hash_coef_ptr.i.i117, align 4, !noalias !22
  %tbl_size.i.i150 = load i64, ptr %tbl_size_ptr.i.i118, align 4, !noalias !22
  %offset_tbl.i.i151 = load ptr, ptr %offset_tbl_ptr.i.i119, align 8, !noalias !22
  %product.i.i.i152 = mul i64 %hash_coef.i.i149, 4189192806087951739
  %shifted.i.i.i153 = lshr i64 %product.i.i.i152, 32
  %xored.i.i.i154 = xor i64 %shifted.i.i.i153, %product.i.i.i152
  %hash.i.i.i155 = and i64 %xored.i.i.i154, %tbl_size.i.i150
  %offset_ptr.i.i156 = getelementptr i32, ptr %offset_tbl.i.i151, i64 %hash.i.i.i155
  %offset.i.i157 = load i32, ptr %offset_ptr.i.i156, align 4, !noalias !22
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i114, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @InterleaveIterator2) #34
  %75 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %.fca.0.extract5, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %.fca.1.extract7, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %result.i114, i64 24
  store ptr %.fca.2.extract9, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i114, i64 32
  store i32 %offset.i.i157, ptr %78, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i132, align 4, !noalias !22
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i133, align 4, !noalias !22
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i134, align 8, !noalias !22
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4189192806087951739
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !761
  %79 = getelementptr inbounds i8, ptr %result.i114, i64 40
  store ptr %.fca.0.extract, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i114, i64 48
  store ptr %.fca.1.extract, ptr %80, align 8
  %81 = getelementptr inbounds i8, ptr %result.i114, i64 56
  store ptr %.fca.2.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i114, i64 64
  store i32 %offset.i.i71.i, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @InterleaveIterator2) #34
  %84 = getelementptr inbounds i8, ptr %result.i114, i64 72
  store i1 true, ptr %84, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %85
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterator2_field_InterleaveIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator2_B_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterator2_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !764
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !764
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !764
  %product.i.i.i = mul i64 %hash_coef.i.i, 6709847746581360093
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !764
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !767
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !770
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract10, i1 true) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @InterleaveIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !773
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !773
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !773
  %product.i.i.i = mul i64 %hash_coef.i.i, 6709847746581360093
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !773
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract3, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract4) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract3) #40
  %13 = getelementptr i8, ptr %9, i64 8
  %14 = load ptr, ptr %13, align 8
  %not. = xor i1 %11, true
  %.62 = select i1 %11, i64 8, i64 16
  tail call void %14(ptr %.fca.1.extract4, i1 %not.) #35
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract3) #40
  %16 = getelementptr i8, ptr %7, i64 %.62
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call { ptr, ptr, ptr, i32 } %18(ptr %.fca.1.extract4) #36
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %19, 3
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract10, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract11, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %.fca.3.extract12, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract9) #40
  %26 = sext i32 %.fca.3.extract12 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract9, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %result.i30 = call ptr %29({ ptr, ptr, ptr, i32 } %23, ptr nocapture nofree noundef nonnull readonly %4) #15
  %30 = call { ptr, i160 } %result.i30({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull align 8 %4) #7
  ret { ptr, i160 } %30
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @InterleaveIterator2_getter_on_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterable2_field_ChainIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterable2_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !776
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !776
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !776
  %product.i.i.i = mul i64 %hash_coef.i.i, -5233298072945030060
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !776
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !779
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !782
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ChainIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !785
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !785
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !785
  %product.i.i.i = mul i64 %hash_coef.i.i, -5233298072945030060
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !785
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #36
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #40
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #36
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #15
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %result.i114 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i112, ptr %result.i114, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i114)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #36
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i115 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %4) #15
  %56 = call { ptr, ptr, ptr, i32 } %result.i115({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i117 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i118 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i130 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #15
  %71 = call { ptr, ptr, ptr, i32 } %result.i130({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i132 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i133 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i149 = load i64, ptr %hash_coef_ptr.i.i117, align 4, !noalias !22
  %tbl_size.i.i150 = load i64, ptr %tbl_size_ptr.i.i118, align 4, !noalias !22
  %offset_tbl.i.i151 = load ptr, ptr %offset_tbl_ptr.i.i119, align 8, !noalias !22
  %product.i.i.i152 = mul i64 %hash_coef.i.i149, 4189192806087951739
  %shifted.i.i.i153 = lshr i64 %product.i.i.i152, 32
  %xored.i.i.i154 = xor i64 %shifted.i.i.i153, %product.i.i.i152
  %hash.i.i.i155 = and i64 %xored.i.i.i154, %tbl_size.i.i150
  %offset_ptr.i.i156 = getelementptr i32, ptr %offset_tbl.i.i151, i64 %hash.i.i.i155
  %offset.i.i157 = load i32, ptr %offset_ptr.i.i156, align 4, !noalias !22
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i114, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @ChainIterator2) #34
  %75 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %.fca.0.extract5, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %.fca.1.extract7, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %result.i114, i64 24
  store ptr %.fca.2.extract9, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i114, i64 32
  store i32 %offset.i.i157, ptr %78, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i132, align 4, !noalias !22
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i133, align 4, !noalias !22
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i134, align 8, !noalias !22
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4189192806087951739
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !788
  %79 = getelementptr inbounds i8, ptr %result.i114, i64 40
  store ptr %.fca.0.extract, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i114, i64 48
  store ptr %.fca.1.extract, ptr %80, align 8
  %81 = getelementptr inbounds i8, ptr %result.i114, i64 56
  store ptr %.fca.2.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i114, i64 64
  store i32 %offset.i.i71.i, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @ChainIterator2) #34
  %84 = getelementptr inbounds i8, ptr %result.i114, i64 72
  store i1 true, ptr %84, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %85
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterator2_field_ChainIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator2_B_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterator2_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !791
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !791
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !791
  %product.i.i.i = mul i64 %hash_coef.i.i, -228267985060461774
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !791
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !794
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !797
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract10, i1 true) #35
  ret void
}

define { ptr, i160 } @ChainIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -228267985060461774
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract5) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract5, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract6) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  br i1 %11, label %29, label %13

13:                                               ; preds = %3
  %14 = getelementptr i8, ptr %7, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = tail call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract6) #36
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract30 = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract24, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract26, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract28, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract30, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract24)
  %24 = sext i32 %.fca.3.extract30 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract24, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %4) #15
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4) #7
  %.fca.0.extract18 = extractvalue { ptr, i160 } %28, 0
  br label %52

29:                                               ; preds = %3
  %30 = getelementptr i8, ptr %7, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = tail call { ptr, ptr, ptr, i32 } %32(ptr %.fca.1.extract6) #36
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract15, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract16, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %.fca.3.extract17, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %39 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract14)
  %40 = sext i32 %.fca.3.extract17 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract14, i64 %40
  %42 = getelementptr i8, ptr %41, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i35 = call ptr %43({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly %4) #15
  %44 = call { ptr, i160 } %result.i35({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %4) #7
  %.fca.0.extract10 = extractvalue { ptr, i160 } %44, 0
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %46 = icmp eq ptr %.fca.0.extract10, @nil_typ
  %47 = icmp eq ptr %.fca.0.extract10, null
  %.not33.not = or i1 %46, %47
  br i1 %.not33.not, label %._crit_edge.preheader, label %52

._crit_edge.preheader:                            ; preds = %29
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %._crit_edge
  %49 = load ptr, ptr %8, align 8
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  call void %51(ptr %.fca.1.extract6, i1 false) #35
  br label %._crit_edge

52:                                               ; preds = %29, %13
  %.reg2mem29.sroa.0.0 = phi ptr [ %.fca.0.extract18, %13 ], [ %.fca.0.extract10, %29 ]
  %.pn = phi { ptr, i160 } [ %28, %13 ], [ %44, %29 ]
  %.reload30.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem29.sroa.0.0, 0
  %.reg2mem29.sroa.3.0 = extractvalue { ptr, i160 } %.pn, 1
  %.reload30.fca.1.insert = insertvalue { ptr, i160 } %.reload30.fca.0.insert, i160 %.reg2mem29.sroa.3.0, 1
  ret { ptr, i160 } %.reload30.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @ChainIterator2_getter_on_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterable2_field_FilterIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_init_iterableIterable2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterable2_init_iterableIterable2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !800
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !800
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !800
  %product.i.i.i = mul i64 %hash_coef.i.i, 1178467452958968374
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !800
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !22
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !22
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !22
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 5693646204635713916
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !803
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @FilterIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !806
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !806
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !806
  %product.i.i.i = mul i64 %hash_coef.i.i, 1178467452958968374
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !806
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #36
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract27) #40
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr %.fca.1.extract37) #36
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i61 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %result.i63 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i61, ptr %result.i63, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i63)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract37) #36
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract3, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract4, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %.fca.3.extract5, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract2)
  %41 = sext i32 %.fca.3.extract5 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract2, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i64 = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly %4) #15
  %45 = call { ptr, ptr, ptr, i32 } %result.i64({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %hash_coef_ptr.i.i66 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i69 = load i64, ptr %hash_coef_ptr.i.i66, align 4, !noalias !22
  %tbl_size.i.i70 = load i64, ptr %tbl_size_ptr.i.i67, align 4, !noalias !22
  %offset_tbl.i.i71 = load ptr, ptr %offset_tbl_ptr.i.i68, align 8, !noalias !22
  %product.i.i.i72 = mul i64 %hash_coef.i.i69, 4189192806087951739
  %shifted.i.i.i73 = lshr i64 %product.i.i.i72, 32
  %xored.i.i.i74 = xor i64 %shifted.i.i.i73, %product.i.i.i72
  %hash.i.i.i75 = and i64 %xored.i.i.i74, %tbl_size.i.i70
  %offset_ptr.i.i76 = getelementptr i32, ptr %offset_tbl.i.i71, i64 %hash.i.i.i75
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract37) #36
  %offset.i.i91 = load i32, ptr %offset_ptr.i.i76, align 4, !noalias !22
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i63, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = getelementptr inbounds i8, ptr %result.i63, i64 8
  store ptr %.fca.0.extract1, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i63, i64 16
  store ptr %.fca.1.extract, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %result.i63, i64 24
  store ptr %.fca.2.extract, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i63, i64 32
  store i32 %offset.i.i91, ptr %55, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @FilterIterator2) #34
  %57 = getelementptr inbounds i8, ptr %result.i63, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %49, 0
  store ptr %.fca.0.extract.i, ptr %57, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %58
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterator2_field_FilterIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator2_B_init_iteratorIterator2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterator2_init_iteratorIterator2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !809
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !809
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !809
  %product.i.i.i = mul i64 %hash_coef.i.i, 8213847504843366470
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !809
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !22
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !22
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !22
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 4189192806087951739
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !812
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #35
  ret void
}

define { ptr, i160 } @FilterIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !815
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !815
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !815
  %product.i.i.i = mul i64 %hash_coef.i.i, 8213847504843366470
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !815
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract14) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract16) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  %.sroa.0.081 = extractvalue { ptr, i160 } %22, 0
  %24 = icmp ne ptr %.sroa.0.081, @nil_typ
  %25 = icmp ne ptr %.sroa.0.081, null
  %.not5083 = and i1 %24, %25
  br i1 %.not5083, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  %27 = getelementptr i8, ptr %7, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr } %29(ptr %.fca.1.extract16) #36
  %.fca.0.extract3791 = extractvalue { ptr } %30, 0
  %31 = call i1 %.fca.0.extract3791({ ptr, i160 } %22)
  br i1 %31, label %._crit_edge.loopexit, label %.lr.ph93.preheader

.lr.ph93.preheader:                               ; preds = %.lr.ph
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  br label %.lr.ph93

33:                                               ; preds = %.lr.ph93
  %34 = load ptr, ptr %27, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract16) #36
  %.fca.0.extract37 = extractvalue { ptr } %36, 0
  %37 = call i1 %.fca.0.extract37({ ptr, i160 } %51)
  br i1 %37, label %._crit_edge.loopexit, label %.lr.ph93

.lr.ph93:                                         ; preds = %.lr.ph93.preheader, %33
  %.pn8492 = phi { ptr, i160 } [ %51, %33 ], [ %22, %.lr.ph93.preheader ]
  %38 = load ptr, ptr %8, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract16) #36
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract34 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract30, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract32, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract34, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract28)
  %47 = sext i32 %.fca.3.extract34 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract28, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %result.i51 = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %4) #15
  %51 = call { ptr, i160 } %result.i51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4) #7
  %.sroa.0.0 = extractvalue { ptr, i160 } %51, 0
  %52 = icmp ne ptr %.sroa.0.0, @nil_typ
  %53 = icmp ne ptr %.sroa.0.0, null
  %.not50 = and i1 %52, %53
  br i1 %.not50, label %33, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph93, %33, %.lr.ph
  %.pn84.lcssa = phi { ptr, i160 } [ %22, %.lr.ph ], [ %.pn8492, %.lr.ph93 ], [ %51, %33 ]
  %.ph = phi ptr [ %.sroa.0.081, %.lr.ph ], [ @nil_typ, %.lr.ph93 ], [ %.sroa.0.0, %33 ]
  %.sroa.3.086.le = extractvalue { ptr, i160 } %.pn84.lcssa, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.1.ph78 = phi i160 [ undef, %3 ], [ %.sroa.3.086.le, %._crit_edge.loopexit ]
  %54 = phi ptr [ @nil_typ, %3 ], [ %.ph, %._crit_edge.loopexit ]
  %.reload31.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %54, 0
  %.reload31.fca.1.insert = insertvalue { ptr, i160 } %.reload31.fca.0.insert, i160 %.1.ph78, 1
  ret { ptr, i160 } %.reload31.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterator2_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator2_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterator2_getter_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator2_setter_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterable2_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable2_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterable2_getter_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable2_setter_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable2_field_MapIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable2_field_MapIterable2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_init_iterableIterable2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterable2_init_iterableIterable2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !818
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !818
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !818
  %product.i.i.i = mul i64 %hash_coef.i.i, -1724859134596891929
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !818
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !22
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !22
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !22
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 5693646204635713916
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !821
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @MapIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !824
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !824
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !824
  %product.i.i.i = mul i64 %hash_coef.i.i, -1724859134596891929
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !824
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #36
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract27) #40
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr %.fca.1.extract37) #36
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i61 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i62 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %result.i64 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i61, ptr %result.i64, align 8
  %33 = getelementptr inbounds i8, ptr %result.i64, i64 8
  store ptr %result.i62, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i64)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr %.fca.1.extract37) #36
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract3, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract4, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract5, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract2)
  %45 = sext i32 %.fca.3.extract5 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract2, i64 %45
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %result.i65 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly %4) #15
  %49 = call { ptr, ptr, ptr, i32 } %result.i65({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %hash_coef_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i69 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i70 = load i64, ptr %hash_coef_ptr.i.i67, align 4, !noalias !22
  %tbl_size.i.i71 = load i64, ptr %tbl_size_ptr.i.i68, align 4, !noalias !22
  %offset_tbl.i.i72 = load ptr, ptr %offset_tbl_ptr.i.i69, align 8, !noalias !22
  %product.i.i.i73 = mul i64 %hash_coef.i.i70, 4189192806087951739
  %shifted.i.i.i74 = lshr i64 %product.i.i.i73, 32
  %xored.i.i.i75 = xor i64 %shifted.i.i.i74, %product.i.i.i73
  %hash.i.i.i76 = and i64 %xored.i.i.i75, %tbl_size.i.i71
  %offset_ptr.i.i77 = getelementptr i32, ptr %offset_tbl.i.i72, i64 %hash.i.i.i76
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr %.fca.1.extract37) #36
  %offset.i.i92 = load i32, ptr %offset_ptr.i.i77, align 4, !noalias !22
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i64, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = getelementptr inbounds i8, ptr %result.i64, i64 16
  store ptr %.fca.0.extract1, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %result.i64, i64 24
  store ptr %.fca.1.extract, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %result.i64, i64 32
  store ptr %.fca.2.extract, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %result.i64, i64 40
  store i32 %offset.i.i92, ptr %59, align 8
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @MapIterator2) #34
  %61 = getelementptr inbounds i8, ptr %result.i64, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %61, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %62
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator2_field_MapIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator2_field_MapIterator2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator2_B_init_iteratorIterator2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterator2_init_iteratorIterator2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !827
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !827
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !827
  %product.i.i.i = mul i64 %hash_coef.i.i, -10255947709272500
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !827
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !22
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !22
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !22
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 4189192806087951739
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !830
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #35
  ret void
}

define { ptr, i160 } @MapIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !833
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !833
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !833
  %product.i.i.i = mul i64 %hash_coef.i.i, -10255947709272500
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !833
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract12) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract12, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract14) #36
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #40
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract12)
  %24 = icmp ne ptr %.fca.0.extract, @nil_typ
  %25 = icmp ne ptr %.fca.0.extract, null
  %.not36 = and i1 %24, %25
  br i1 %.not36, label %26, label %33

26:                                               ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %.fca.1.extract14) #36
  %.fca.0.extract28 = extractvalue { ptr } %31, 0
  %32 = call { ptr, i160 } %.fca.0.extract28({ ptr, i160 } %22)
  %.fca.0.extract22 = extractvalue { ptr, i160 } %32, 0
  %.fca.1.extract24 = extractvalue { ptr, i160 } %32, 1
  br label %33

33:                                               ; preds = %3, %26
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract22, %26 ], [ @nil_typ, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract24, %26 ], [ undef, %3 ]
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem15.sroa.0.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.reg2mem15.sroa.3.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterator2_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator2_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterator2_getter_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator2_setter_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterable2_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable2_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterable2_getter_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable2_setter_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ArrayIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !836
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !836
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !836
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !836
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !839
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i35, 3
  tail call void %11(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %15) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract2, i32 0) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !842
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !842
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !842
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !842
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract10, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract12) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %15 = getelementptr i8, ptr %9, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract12) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #34
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %25 = sext i32 %.fca.3.extract to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 64
  %28 = load ptr, ptr %27, align 8
  %result.i = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly %4) #15
  %29 = call i32 %result.i({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4) #7
  %.not = icmp slt i32 %13, %29
  br i1 %.not, label %30, label %59

30:                                               ; preds = %3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %32 = load ptr, ptr %10, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract12) #36
  %35 = add i32 %34, 1
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %37 = getelementptr i8, ptr %32, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %.fca.1.extract12, i32 %35) #35
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %40 = load ptr, ptr %10, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr %.fca.1.extract12) #36
  %43 = add i32 %42, -1
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %45 = load ptr, ptr %15, align 8
  %46 = load ptr, ptr %45, align 8
  %47 = call { ptr, ptr, ptr, i32 } %46(ptr %.fca.1.extract12) #36
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %47, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %47, 1
  %.fca.2.extract30 = extractvalue { ptr, ptr, ptr, i32 } %47, 2
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %47, 3
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.1.extract28, 1
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.2.extract30, 2
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %.fca.3.extract32, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract26)
  %54 = sext i32 %.fca.3.extract32 to i64
  %55 = getelementptr ptr, ptr %.fca.0.extract26, i64 %54
  %56 = getelementptr i8, ptr %55, i64 120
  %57 = load ptr, ptr %56, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i42 = call ptr %57({ ptr, ptr, ptr, i32 } %51, ptr nocapture nofree noundef nonnull readonly %6) #15
  %58 = call { ptr, i160 } %result.i42({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull align 8 dereferenceable(8) %5, i32 %43) #7
  %.fca.0.extract20 = extractvalue { ptr, i160 } %58, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %58, 1
  br label %59

59:                                               ; preds = %3, %30
  %.reg2mem21.sroa.0.0 = phi ptr [ %.fca.0.extract20, %30 ], [ @nil_typ, %3 ]
  %.reg2mem21.sroa.3.0 = phi i160 [ %.fca.1.extract22, %30 ], [ undef, %3 ]
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem21.sroa.0.0, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %.reg2mem21.sroa.3.0, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Iterator2_field_Iterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 96
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Iterable2_field_Iterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Representable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #13 {
  %result.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %result.i, align 8
  %result.i15 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i15, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i, ptr %result.i15, align 8
  %7 = getelementptr i8, ptr %result.i15, i64 8
  store i32 6, ptr %7, align 4
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %9 = getelementptr i8, ptr %result.i15, i64 12
  store i32 7, ptr %9, align 4
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_String(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferPtri8_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_bytes_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_xPtri8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_extend_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_pop_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !845
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !845
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !845
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !845
  %result.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %9(ptr %.fca.1.extract, { ptr } %10) #35
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %12 = getelementptr i8, ptr %6, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 1) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, i32 0) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_bytesBufferPtri8_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !848
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !848
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !848
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !848
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract2, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 %5) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !851
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !851
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !851
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !851
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !854
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !854
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !854
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !854
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr } @String_bytes_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !857
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !857
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !857
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !857
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract1, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { ptr } %8(ptr %.fca.1.extract) #36
  ret { ptr } %9
}

define { ptr, ptr, ptr, i32 } @String_append_xPtri8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) {
  %.sroa.091 = alloca ptr, align 8
  %5 = alloca i32, align 4
  %.sroa.087 = alloca ptr, align 8
  %.sroa.188 = alloca ptr, align 8
  %.sroa.289 = alloca ptr, align 8
  %.sroa.390 = alloca i32, align 8
  %.sroa.086 = alloca ptr, align 8
  %6 = alloca i32, align 4
  %.sroa.085 = alloca ptr, align 8
  %.sroa.1 = alloca ptr, align 8
  %.sroa.2 = alloca ptr, align 8
  %.sroa.3 = alloca i32, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #38
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #38
  %15 = getelementptr i8, ptr %9, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract) #36
  %19 = icmp slt i32 %13, %18
  br i1 %19, label %._crit_edge.thread, label %20

20:                                               ; preds = %4
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %22 = tail call i32 %17(ptr %.fca.1.extract) #36
  %23 = shl i32 %22, 1
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %25 = getelementptr i8, ptr %16, i64 8
  %26 = load ptr, ptr %25, align 8
  tail call void %26(ptr %.fca.1.extract, i32 %23) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %28 = load ptr, ptr %9, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call { ptr } %29(ptr %.fca.1.extract) #36
  %.fca.0.extract17 = extractvalue { ptr } %30, 0
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = load ptr, ptr %15, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call i32 %33(ptr %.fca.1.extract) #36
  %35 = sext i32 %34 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %35, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %37 = load ptr, ptr %9, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %39(ptr %.fca.1.extract, { ptr } %40) #35
  %41 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %42 = load ptr, ptr %10, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = tail call i32 %43(ptr %.fca.1.extract) #36
  %45 = icmp sgt i32 %44, 0
  br i1 %45, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %20
  %46 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.093 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %54, %._crit_edge ]
  %47 = zext nneg i32 %.093 to i64
  %48 = getelementptr i8, ptr %.fca.0.extract17, i64 %47
  %49 = load i8, ptr %48, align 1
  %50 = load ptr, ptr %9, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = tail call { ptr } %51(ptr %.fca.1.extract) #36
  %.fca.0.extract5 = extractvalue { ptr } %52, 0
  %53 = getelementptr i8, ptr %.fca.0.extract5, i64 %47
  store i8 %49, ptr %53, align 1
  %54 = add nuw nsw i32 %.093, 1
  %55 = load ptr, ptr %10, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = tail call i32 %56(ptr %.fca.1.extract) #36
  %58 = icmp slt i32 %54, %57
  br i1 %58, label %._crit_edge, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %20, %4
  %.sroa.phi = phi ptr [ %.sroa.188, %4 ], [ %.sroa.1, %20 ], [ %.sroa.1, %._crit_edge ]
  %.sroa.phi76 = phi ptr [ %.sroa.289, %4 ], [ %.sroa.2, %20 ], [ %.sroa.2, %._crit_edge ]
  %.sroa.phi79 = phi ptr [ %.sroa.390, %4 ], [ %.sroa.3, %20 ], [ %.sroa.3, %._crit_edge ]
  %59 = phi ptr [ %.sroa.087, %4 ], [ %.sroa.085, %20 ], [ %.sroa.085, %._crit_edge ]
  %60 = phi ptr [ %5, %4 ], [ %6, %20 ], [ %6, %._crit_edge ]
  %61 = phi ptr [ %.sroa.091, %4 ], [ %.sroa.086, %20 ], [ %.sroa.086, %._crit_edge ]
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %62 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %63 = load ptr, ptr %9, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = tail call { ptr } %64(ptr %.fca.1.extract) #36
  %66 = extractvalue { ptr } %65, 0
  store ptr %66, ptr %61, align 8
  %67 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %68 = load ptr, ptr %10, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = tail call i32 %69(ptr %.fca.1.extract) #36
  %71 = sext i32 %70 to i64
  %72 = getelementptr i8, ptr %66, i64 %71
  store i8 %3, ptr %72, align 1
  %73 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %74 = load ptr, ptr %10, align 8
  %75 = load ptr, ptr %74, align 8
  %76 = tail call i32 %75(ptr %.fca.1.extract) #36
  store i32 %76, ptr %60, align 4
  %77 = add i32 %76, 1
  %78 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %79 = getelementptr i8, ptr %74, i64 8
  %80 = load ptr, ptr %79, align 8
  tail call void %80(ptr %.fca.1.extract, i32 %77) #35
  store ptr %.fca.0.extract, ptr %59, align 8
  store ptr %.fca.1.extract, ptr %.sroa.phi, align 8
  store ptr %.fca.2.extract, ptr %.sroa.phi76, align 8
  store i32 %offset.i.i, ptr %.sroa.phi79, align 8
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, 6499063144389013426
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i34 = load i32, ptr %offset_ptr.i.i33, align 4
  store i32 %offset.i.i34, ptr %.sroa.phi79, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %82 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %.fca.1.extract, 1
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %.fca.2.extract, 2
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %offset.i.i34, 3
  ret { ptr, ptr, ptr, i32 } %84
}

define { ptr, ptr, ptr, i32 } @String_extend_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca [0 x ptr], align 8
  %.sroa.0168 = alloca ptr, align 8
  %.sroa.1169 = alloca ptr, align 8
  %.sroa.2170 = alloca ptr, align 8
  %.sroa.3171 = alloca i32, align 8
  %.sroa.0167 = alloca ptr, align 8
  %.sroa.1 = alloca ptr, align 8
  %.sroa.2 = alloca ptr, align 8
  %.sroa.3 = alloca i32, align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i75 = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i76 = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i77 = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i78 = load i64, ptr %hash_coef_ptr.i.i75, align 4
  %tbl_size.i.i79 = load i64, ptr %tbl_size_ptr.i.i76, align 4
  %offset_tbl.i.i80 = load ptr, ptr %offset_tbl_ptr.i.i77, align 8
  %product.i.i.i81 = mul i64 %hash_coef.i.i78, 6499063144389013426
  %shifted.i.i.i82 = lshr i64 %product.i.i.i81, 32
  %xored.i.i.i83 = xor i64 %shifted.i.i.i82, %product.i.i.i81
  %hash.i.i.i84 = and i64 %xored.i.i.i83, %tbl_size.i.i79
  %offset_ptr.i.i85 = getelementptr i32, ptr %offset_tbl.i.i80, i64 %hash.i.i.i84
  %offset.i.i86 = load i32, ptr %offset_ptr.i.i85, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i86, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract11) #38
  %12 = sext i32 %offset.i.i86 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract11, i64 %12
  %14 = getelementptr i8, ptr %13, i64 56
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #15
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract11)
  %19 = getelementptr i8, ptr %13, i64 40
  %20 = load ptr, ptr %19, align 8
  %result.i88 = call ptr %20({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #15
  %21 = call i32 %result.i88({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract12)
  %23 = sext i32 %offset.i.i to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract12, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %.fca.1.extract13) #36
  %29 = add i32 %28, %21
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract12)
  %31 = getelementptr i8, ptr %24, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract13) #36
  %35 = icmp slt i32 %29, %34
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %37 = call i32 %27(ptr %.fca.1.extract13) #36
  br i1 %35, label %38, label %59

38:                                               ; preds = %4
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %40 = call i32 %27(ptr %.fca.1.extract13) #36
  %41 = add i32 %40, %21
  %42 = icmp slt i32 %37, %41
  br i1 %42, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %38
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.0181 = phi i32 [ %37, %._crit_edge.lr.ph ], [ %52, %._crit_edge ]
  %.068180 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %53, %._crit_edge ]
  %44 = sext i32 %.068180 to i64
  %45 = getelementptr i8, ptr %.fca.0.extract, i64 %44
  %46 = load i8, ptr %45, align 1
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract13) #36
  %.fca.0.extract57 = extractvalue { ptr } %49, 0
  %50 = sext i32 %.0181 to i64
  %51 = getelementptr i8, ptr %.fca.0.extract57, i64 %50
  store i8 %46, ptr %51, align 1
  %52 = add nsw i32 %.0181, 1
  %53 = add i32 %.068180, 1
  %54 = load ptr, ptr %25, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call i32 %55(ptr %.fca.1.extract13) #36
  %57 = add i32 %56, %21
  %58 = icmp slt i32 %52, %57
  br i1 %58, label %._crit_edge, label %._crit_edge.thread

59:                                               ; preds = %4
  %60 = add i32 %37, %21
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %62 = getelementptr i8, ptr %32, i64 8
  %63 = load ptr, ptr %62, align 8
  call void %63(ptr %.fca.1.extract13, i32 %60) #35
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %65 = load ptr, ptr %24, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr } %66(ptr %.fca.1.extract13) #36
  %.fca.0.extract49 = extractvalue { ptr } %67, 0
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %69 = load ptr, ptr %31, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call i32 %70(ptr %.fca.1.extract13) #36
  %72 = sext i32 %71 to i64
  %result.i89 = call noalias ptr @bump_malloc_inner(i64 noundef %72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %74 = load ptr, ptr %24, align 8
  %75 = getelementptr i8, ptr %74, i64 8
  %76 = load ptr, ptr %75, align 8
  %77 = insertvalue { ptr } undef, ptr %result.i89, 0
  call void %76(ptr %.fca.1.extract13, { ptr } %77) #35
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %79 = load ptr, ptr %25, align 8
  %80 = load ptr, ptr %79, align 8
  %81 = call i32 %80(ptr %.fca.1.extract13) #36
  %82 = add i32 %81, %21
  %83 = icmp sgt i32 %82, 0
  br i1 %83, label %.lr.ph, label %._crit_edge.thread

.lr.ph:                                           ; preds = %59
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  br label %85

85:                                               ; preds = %.lr.ph, %._crit_edge2
  %86 = phi ptr [ %80, %.lr.ph ], [ %110, %._crit_edge2 ]
  %.070178 = phi i32 [ 0, %.lr.ph ], [ %.171, %._crit_edge2 ]
  %.072177 = phi i32 [ 0, %.lr.ph ], [ %.173, %._crit_edge2 ]
  %87 = call i32 %86(ptr %.fca.1.extract13) #36
  %88 = icmp slt i32 %.070178, %87
  br i1 %88, label %89, label %98

89:                                               ; preds = %85
  %90 = zext nneg i32 %.070178 to i64
  %91 = getelementptr i8, ptr %.fca.0.extract49, i64 %90
  %92 = load i8, ptr %91, align 1
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %94 = load ptr, ptr %24, align 8
  %95 = load ptr, ptr %94, align 8
  %96 = call { ptr } %95(ptr %.fca.1.extract13) #36
  %.fca.0.extract29 = extractvalue { ptr } %96, 0
  %97 = getelementptr i8, ptr %.fca.0.extract29, i64 %90
  store i8 %92, ptr %97, align 1
  br label %._crit_edge2

98:                                               ; preds = %85
  %99 = sext i32 %.072177 to i64
  %100 = getelementptr i8, ptr %.fca.0.extract, i64 %99
  %101 = load i8, ptr %100, align 1
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %103 = load ptr, ptr %24, align 8
  %104 = load ptr, ptr %103, align 8
  %105 = call { ptr } %104(ptr %.fca.1.extract13) #36
  %.fca.0.extract24 = extractvalue { ptr } %105, 0
  %106 = zext nneg i32 %.070178 to i64
  %107 = getelementptr i8, ptr %.fca.0.extract24, i64 %106
  store i8 %101, ptr %107, align 1
  %108 = add i32 %.072177, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %89, %98
  %.173 = phi i32 [ %.072177, %89 ], [ %108, %98 ]
  %.171 = add nuw nsw i32 %.070178, 1
  %109 = load ptr, ptr %25, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = call i32 %110(ptr %.fca.1.extract13) #36
  %112 = add i32 %111, %21
  %113 = icmp slt i32 %.171, %112
  br i1 %113, label %85, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge2, %._crit_edge, %59, %38
  %114 = phi ptr [ %27, %38 ], [ %80, %59 ], [ %55, %._crit_edge ], [ %110, %._crit_edge2 ]
  %115 = phi ptr [ %26, %38 ], [ %79, %59 ], [ %54, %._crit_edge ], [ %109, %._crit_edge2 ]
  %.sroa.phi = phi ptr [ %.sroa.1169, %38 ], [ %.sroa.1, %59 ], [ %.sroa.1169, %._crit_edge ], [ %.sroa.1, %._crit_edge2 ]
  %.sroa.phi158 = phi ptr [ %.sroa.2170, %38 ], [ %.sroa.2, %59 ], [ %.sroa.2170, %._crit_edge ], [ %.sroa.2, %._crit_edge2 ]
  %.sroa.phi161 = phi ptr [ %.sroa.3171, %38 ], [ %.sroa.3, %59 ], [ %.sroa.3171, %._crit_edge ], [ %.sroa.3, %._crit_edge2 ]
  %116 = phi ptr [ %.sroa.0168, %38 ], [ %.sroa.0167, %59 ], [ %.sroa.0168, %._crit_edge ], [ %.sroa.0167, %._crit_edge2 ]
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %118 = call i32 %114(ptr %.fca.1.extract13) #36
  %119 = add i32 %118, %21
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %121 = getelementptr i8, ptr %115, i64 8
  %122 = load ptr, ptr %121, align 8
  call void %122(ptr %.fca.1.extract13, i32 %119) #35
  store ptr %.fca.0.extract12, ptr %116, align 8
  store ptr %.fca.1.extract13, ptr %.sroa.phi, align 8
  store ptr %.fca.2.extract14, ptr %.sroa.phi158, align 8
  store i32 %offset.i.i, ptr %.sroa.phi161, align 8
  %hash_coef.i.i94 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i95 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i96 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i97 = mul i64 %hash_coef.i.i94, 6499063144389013426
  %shifted.i.i.i98 = lshr i64 %product.i.i.i97, 32
  %xored.i.i.i99 = xor i64 %shifted.i.i.i98, %product.i.i.i97
  %hash.i.i.i100 = and i64 %xored.i.i.i99, %tbl_size.i.i95
  %offset_ptr.i.i101 = getelementptr i32, ptr %offset_tbl.i.i96, i64 %hash.i.i.i100
  %offset.i.i102 = load i32, ptr %offset_ptr.i.i101, align 4
  store i32 %offset.i.i102, ptr %.sroa.phi161, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract12, 0
  %124 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %.fca.1.extract13, 1
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, ptr %.fca.2.extract14, 2
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, i32 %offset.i.i102, 3
  ret { ptr, ptr, ptr, i32 } %126
}

define i8 @String__index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract) #36
  %12 = add i32 %11, -1
  %13 = icmp sgt i32 %3, %12
  br i1 %13, label %14, label %._crit_edge

14:                                               ; preds = %4
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #41
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %14
  %15 = icmp sgt i32 %3, -1
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  br i1 %15, label %17, label %23

17:                                               ; preds = %._crit_edge
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #36
  %.fca.0.extract18 = extractvalue { ptr } %20, 0
  %21 = zext nneg i32 %3 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract18, i64 %21
  br label %40

23:                                               ; preds = %._crit_edge
  %24 = load ptr, ptr %8, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = tail call i32 %25(ptr %.fca.1.extract) #36
  %27 = add i32 %26, %3
  %28 = icmp slt i32 %27, 0
  br i1 %28, label %29, label %._crit_edge1

29:                                               ; preds = %23
  %current_coroutine.i22 = load ptr, ptr @current_coroutine, align 8
  %into_callee_buf.i23 = getelementptr i8, ptr %current_coroutine.i22, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i23, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #41
  %.pre = load ptr, ptr %8, align 8
  %.pre36 = load ptr, ptr %.pre, align 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %23, %29
  %30 = phi ptr [ %25, %23 ], [ %.pre36, %29 ]
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = load ptr, ptr %7, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call { ptr } %33(ptr %.fca.1.extract) #36
  %.fca.0.extract11 = extractvalue { ptr } %34, 0
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %36 = tail call i32 %30(ptr %.fca.1.extract) #36
  %37 = add i32 %36, %3
  %38 = sext i32 %37 to i64
  %39 = getelementptr i8, ptr %.fca.0.extract11, i64 %38
  br label %40

40:                                               ; preds = %._crit_edge1, %17
  %.reg2mem20.0.in = phi ptr [ %22, %17 ], [ %39, %._crit_edge1 ]
  %.reg2mem20.0 = load i8, ptr %.reg2mem20.0.in, align 1
  ret i8 %.reg2mem20.0
}

; Function Attrs: nounwind
define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !860
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !860
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !860
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !860
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i30 = load i64, ptr %hash_coef_ptr.i.i27, align 4, !noalias !863
  %tbl_size.i.i31 = load i64, ptr %tbl_size_ptr.i.i28, align 4, !noalias !863
  %offset_tbl.i.i32 = load ptr, ptr %offset_tbl_ptr.i.i29, align 8, !noalias !863
  %product.i.i.i33 = mul i64 %hash_coef.i.i30, 6499063144389013426
  %shifted.i.i.i34 = lshr i64 %product.i.i.i33, 32
  %xored.i.i.i35 = xor i64 %shifted.i.i.i34, %product.i.i.i33
  %hash.i.i.i36 = and i64 %xored.i.i.i35, %tbl_size.i.i31
  %offset_ptr.i.i37 = getelementptr i32, ptr %offset_tbl.i.i32, i64 %hash.i.i.i36
  %offset.i.i38 = load i32, ptr %offset_ptr.i.i37, align 4, !noalias !863
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract2) #38
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call i32 %11(ptr %.fca.1.extract3) #36
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i38, 3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = sext i32 %offset.i.i38 to i64
  %20 = getelementptr ptr, ptr %.fca.0.extract, i64 %19
  %21 = getelementptr i8, ptr %20, i64 40
  %22 = load ptr, ptr %21, align 8
  %result.i = call ptr %22({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %5) #15
  %23 = call i32 %result.i({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %5) #7
  %.not = icmp eq i32 %12, %23
  br i1 %.not, label %.preheader, label %.thread

.preheader:                                       ; preds = %4
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract2)
  %25 = getelementptr i8, ptr %20, i64 56
  br label %26

26:                                               ; preds = %.preheader, %30
  %.0 = phi i32 [ %44, %30 ], [ 0, %.preheader ]
  %27 = load ptr, ptr %9, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = call i32 %28(ptr %.fca.1.extract3) #36
  %.not52.not.not = icmp sge i32 %.0, %29
  br i1 %.not52.not.not, label %.thread, label %30

30:                                               ; preds = %26
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract2)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr } %33(ptr %.fca.1.extract3) #36
  %.fca.0.extract17 = extractvalue { ptr } %34, 0
  %35 = zext nneg i32 %.0 to i64
  %36 = getelementptr i8, ptr %.fca.0.extract17, i64 %35
  %37 = load i8, ptr %36, align 1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %40 = load ptr, ptr %25, align 8
  %result.i40 = call ptr %40({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %5) #15
  %41 = call { ptr } %result.i40({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %5) #7
  %.fca.0.extract14 = extractvalue { ptr } %41, 0
  %42 = getelementptr i8, ptr %.fca.0.extract14, i64 %35
  %43 = load i8, ptr %42, align 1
  %.not25 = icmp eq i8 %37, %43
  %44 = add nuw nsw i32 %.0, 1
  br i1 %.not25, label %26, label %.thread

.thread:                                          ; preds = %26, %30, %4
  %.reg2mem42.0 = phi i1 [ false, %4 ], [ %.not52.not.not, %30 ], [ %.not52.not.not, %26 ]
  ret i1 %.reg2mem42.0
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i8 } @String_pop_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !866
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !866
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !866
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !866
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract4) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract4, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract5) #36
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %30, label %12

12:                                               ; preds = %3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %14 = tail call i32 %9(ptr %.fca.1.extract5) #36
  %15 = add i32 %14, -1
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %17 = getelementptr i8, ptr %8, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract5, i32 %15) #35
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %20 = load ptr, ptr %6, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call { ptr } %21(ptr %.fca.1.extract5) #36
  %.fca.0.extract10 = extractvalue { ptr } %22, 0
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = tail call i32 %25(ptr %.fca.1.extract5) #36
  %27 = sext i32 %26 to i64
  %28 = getelementptr i8, ptr %.fca.0.extract10, i64 %27
  %29 = load i8, ptr %28, align 1
  br label %30

30:                                               ; preds = %3, %12
  %.reg2mem19.sroa.0.0 = phi ptr [ @i8_typ, %12 ], [ @nil_typ, %3 ]
  %.reg2mem19.sroa.3.0 = phi i8 [ %29, %12 ], [ undef, %3 ]
  %.reload20.fca.0.insert = insertvalue { ptr, i8 } poison, ptr %.reg2mem19.sroa.0.0, 0
  %.reload20.fca.1.insert = insertvalue { ptr, i8 } %.reload20.fca.0.insert, i8 %.reg2mem19.sroa.3.0, 1
  ret { ptr, i8 } %.reload20.fca.1.insert
}

define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #38
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  %11 = sext i32 %10 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #36
  %16 = icmp sgt i32 %15, 0
  br i1 %16, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.083 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %25, %._crit_edge ]
  %18 = load ptr, ptr %6, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #36
  %.fca.0.extract24 = extractvalue { ptr } %20, 0
  %21 = zext nneg i32 %.083 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract24, i64 %21
  %23 = load i8, ptr %22, align 1
  %24 = getelementptr i8, ptr %result.i, i64 %21
  store i8 %23, ptr %24, align 1
  %25 = add nuw nsw i32 %.083, 1
  %26 = load ptr, ptr %7, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = tail call i32 %27(ptr %.fca.1.extract) #36
  %29 = icmp slt i32 %25, %28
  br i1 %29, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %30 = phi ptr [ %14, %3 ], [ %27, %._crit_edge ]
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = tail call i32 %30(ptr %.fca.1.extract) #36
  %33 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %34 = tail call i32 %30(ptr %.fca.1.extract) #36
  %result.i29 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %36 = load ptr, ptr %7, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = tail call i32 %37(ptr %.fca.1.extract) #36
  %39 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %40 = tail call i32 %37(ptr %.fca.1.extract) #36
  %41 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i29, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr undef, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 10, 3
  store ptr %result.i, ptr %result.i29, align 8
  %44 = getelementptr i8, ptr %result.i29, i64 8
  store i32 %38, ptr %44, align 4
  %45 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %46 = getelementptr i8, ptr %result.i29, i64 12
  store i32 %40, ptr %46, align 4
  ret { ptr, ptr, ptr, i32 } %43
}

; Function Attrs: nounwind
define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !869
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !869
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !869
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !869
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #38
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  %11 = add i32 %10, 1
  %12 = sext i32 %11 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %14 = load ptr, ptr %7, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract) #36
  %17 = icmp sgt i32 %16, 0
  br i1 %17, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %3
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.029 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %26, %._crit_edge ]
  %19 = load ptr, ptr %6, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { ptr } %20(ptr %.fca.1.extract) #36
  %.fca.0.extract15 = extractvalue { ptr } %21, 0
  %22 = zext nneg i32 %.029 to i64
  %23 = getelementptr i8, ptr %.fca.0.extract15, i64 %22
  %24 = load i8, ptr %23, align 1
  %25 = getelementptr i8, ptr %result.i, i64 %22
  store i8 %24, ptr %25, align 1
  %26 = add nuw nsw i32 %.029, 1
  %27 = load ptr, ptr %7, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = tail call i32 %28(ptr %.fca.1.extract) #36
  %30 = icmp slt i32 %26, %29
  br i1 %30, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %31 = phi ptr [ %15, %3 ], [ %28, %._crit_edge ]
  %32 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %33 = tail call i32 %31(ptr %.fca.1.extract) #36
  %34 = sext i32 %33 to i64
  %35 = getelementptr i8, ptr %result.i, i64 %34
  store i8 0, ptr %35, align 1
  %36 = insertvalue { ptr } undef, ptr %result.i, 0
  ret { ptr } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #14 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %result.i7 = tail call noalias dereferenceable_or_null(40) ptr @bump_malloc_inner(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %hash_coef.i.i12 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i13 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i14 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i15 = mul i64 %hash_coef.i.i12, 6499063144389013426
  %shifted.i.i.i16 = lshr i64 %product.i.i.i15, 32
  %xored.i.i.i17 = xor i64 %shifted.i.i.i16, %product.i.i.i15
  %hash.i.i.i18 = and i64 %xored.i.i.i17, %tbl_size.i.i13
  %offset_ptr.i.i19 = getelementptr i32, ptr %offset_tbl.i.i14, i64 %hash.i.i.i18
  %offset.i.i20 = load i32, ptr %offset_ptr.i.i19, align 4, !noalias !22
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  store ptr %.fca.0.extract, ptr %result.i7, align 8
  %6 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store i32 %offset.i.i20, ptr %8, align 4
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull @StringIterator) #34
  %10 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 16, 3
  ret { ptr, ptr, ptr, i32 } %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #15 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i13 = load i32, ptr %offset_ptr.i.i, align 4, !noalias !872
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i.i13, 3
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_StringIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !875
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !875
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !875
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !875
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !878
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i.i35, 3
  tail call void %10(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %14) #35
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %16 = getelementptr i8, ptr %7, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  tail call void %19(ptr %.fca.1.extract2, i32 0) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !881
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !881
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !881
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !881
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract12) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call { ptr, ptr, ptr, i32 } %14(ptr %.fca.1.extract12) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 3
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %.fca.3.extract, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #34
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %22 = sext i32 %.fca.3.extract to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract, i64 %22
  %24 = getelementptr i8, ptr %23, i64 40
  %25 = load ptr, ptr %24, align 8
  %result.i = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly %4) #15
  %26 = call i32 %result.i({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %4) #7
  %27 = icmp slt i32 %11, %26
  br i1 %27, label %28, label %81

28:                                               ; preds = %3
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %30 = load ptr, ptr %8, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = call i32 %31(ptr %.fca.1.extract12) #36
  %33 = add i32 %32, 1
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %35 = getelementptr i8, ptr %30, i64 8
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr %.fca.1.extract12, i32 %33) #35
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %38 = load ptr, ptr %7, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract12) #36
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract51 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract47, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract49, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract51, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract45)
  %47 = sext i32 %.fca.3.extract51 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract45, i64 %47
  %49 = getelementptr i8, ptr %48, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i56 = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %4) #15
  %51 = call { ptr } %result.i56({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4) #7
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %53 = load ptr, ptr %8, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call i32 %54(ptr %.fca.1.extract12) #36
  %result.i58 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %57 = load ptr, ptr %7, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, ptr, ptr, i32 } %58(ptr %.fca.1.extract12) #36
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %59, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %59, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %59, 3
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.1.extract29, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.2.extract31, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %.fca.3.extract33, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract27)
  %66 = sext i32 %.fca.3.extract33 to i64
  %67 = getelementptr ptr, ptr %.fca.0.extract27, i64 %66
  %68 = getelementptr i8, ptr %67, i64 56
  %69 = load ptr, ptr %68, align 8
  %result.i59 = call ptr %69({ ptr, ptr, ptr, i32 } %63, ptr nocapture nofree noundef nonnull readonly %4) #15
  %70 = call { ptr } %result.i59({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull align 8 %4) #7
  %.fca.0.extract24 = extractvalue { ptr } %70, 0
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %72 = load ptr, ptr %8, align 8
  %73 = load ptr, ptr %72, align 8
  %74 = call i32 %73(ptr %.fca.1.extract12) #36
  %75 = add i32 %74, -1
  %76 = sext i32 %75 to i64
  %77 = getelementptr i8, ptr %.fca.0.extract24, i64 %76
  %78 = load i8, ptr %77, align 1
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @Character) #34
  store i8 %78, ptr %result.i58, align 1
  %80 = ptrtoint ptr %result.i58 to i64
  %.sroa.3.8.insert.ext = zext i64 %80 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %81

81:                                               ; preds = %3, %28
  %.reg2mem25.sroa.0.0 = phi ptr [ @Character, %28 ], [ @nil_typ, %3 ]
  %.reg2mem25.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %28 ], [ undef, %3 ]
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Character(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_byte_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_bytePtri8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define i8 @Character_byte_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !884
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !884
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !884
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !884
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i8 %8(ptr %.fca.1.extract) #36
  ret i8 %9
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Character_init_bytePtri8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !887
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !887
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !887
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !887
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  tail call void %10(ptr %.fca.1.extract, i8 %3) #35
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i8 @Character_getter_byte(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0) #5 {
  %2 = load i8, ptr %0, align 1
  ret i8 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_byte(ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %0, i8 %1) #6 {
  store i8 %1, ptr %0, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_length(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_length(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #6 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Exception(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !890
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !890
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !890
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !890
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i22 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i23 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i24 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i25 = load i64, ptr %hash_coef_ptr.i.i22, align 4, !noalias !22
  %tbl_size.i.i26 = load i64, ptr %tbl_size_ptr.i.i23, align 4, !noalias !22
  %offset_tbl.i.i27 = load ptr, ptr %offset_tbl_ptr.i.i24, align 8, !noalias !22
  %product.i.i.i28 = mul i64 %hash_coef.i.i25, 6499063144389013426
  %shifted.i.i.i29 = lshr i64 %product.i.i.i28, 32
  %xored.i.i.i30 = xor i64 %shifted.i.i.i29, %product.i.i.i28
  %hash.i.i.i31 = and i64 %xored.i.i.i30, %tbl_size.i.i26
  %offset_ptr.i.i32 = getelementptr i32, ptr %offset_tbl.i.i27, i64 %hash.i.i.i31
  %offset.i.i47 = load i32, ptr %offset_ptr.i.i32, align 4, !noalias !893
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i47, 3
  tail call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %17 = load ptr, ptr %7, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  tail call void %19(ptr %.fca.1.extract14, i32 0) #35
  %result.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i50 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i50, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  store ptr %result.i, ptr %result.i50, align 8
  %23 = getelementptr i8, ptr %result.i50, i64 8
  store i32 0, ptr %23, align 4
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %25 = getelementptr i8, ptr %result.i50, i64 12
  store i32 1, ptr %25, align 4
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13)
  %27 = getelementptr i8, ptr %7, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %22) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !896
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !896
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !896
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !896
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  tail call void %9(ptr %.fca.1.extract, i32 0) #35
  %result.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i, align 8
  %result.i29 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i29, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  store ptr %result.i, ptr %result.i29, align 8
  %13 = getelementptr i8, ptr %result.i29, i64 8
  store i32 6, ptr %13, align 4
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %15 = getelementptr i8, ptr %result.i29, i64 12
  store i32 7, ptr %15, align 4
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract)
  %17 = getelementptr i8, ptr %6, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %12) #35
  %result.i45 = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i47 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i47, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i45, ptr %result.i47, align 8
  %24 = getelementptr i8, ptr %result.i47, i64 8
  store i32 0, ptr %24, align 4
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %26 = getelementptr i8, ptr %result.i47, i64 12
  store i32 1, ptr %26, align 4
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract)
  %28 = getelementptr i8, ptr %6, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  tail call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !899
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !899
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !899
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !899
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract1, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract2, i32 %3) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !902
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i35, 3
  tail call void %16(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %20) #35
  ret void
}

; Function Attrs: nounwind
define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
._crit_edge.lr.ph.i:
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract89 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract91 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !905
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !905
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !905
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !905
  %result.i = tail call noalias align 16 dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i, align 16
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i = tail call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i.i, ptr noundef nonnull align 16 dereferenceable(9) %result.i, i64 9, i1 false)
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  %result.i106 = tail call noalias align 32 dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <26 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110, i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105, i8 108, i8 101>, ptr %result.i106, align 32
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i178 = tail call noalias dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i.i178, ptr noundef nonnull align 32 dereferenceable(26) %result.i106, i64 26, i1 false)
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts97 = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i178)
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract89, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call { ptr, ptr, ptr, i32 } %12(ptr %.fca.1.extract91) #36
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %13, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 3
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract52, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %.fca.3.extract, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract52)
  %20 = sext i32 %.fca.3.extract to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract52, i64 %20
  %22 = getelementptr i8, ptr %21, i64 112
  %23 = load ptr, ptr %22, align 8
  %result.i111 = call ptr %23({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %3) #15
  %24 = call { ptr } %result.i111({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %3) #7
  %.fca.0.extract50 = extractvalue { ptr } %24, 0
  %puts98 = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract50)
  %result.i112 = call noalias align 8 dereferenceable_or_null(8) ptr @bump_malloc_inner(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <7 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101>, ptr %result.i112, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i210 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_inner(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(7) %result.i.i210, ptr noundef nonnull align 8 dereferenceable(7) %result.i112, i64 7, i1 false)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts99 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i210)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %29 = load ptr, ptr %9, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call i32 %30(ptr %.fca.1.extract91) #36
  %32 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %31) #7
  %result.i117 = call noalias align 16 dereferenceable_or_null(13) ptr @bump_malloc_inner(i64 noundef 13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <12 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115, i8 115, i8 97, i8 103, i8 101>, ptr %result.i117, align 16
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i242 = call noalias dereferenceable_or_null(13) ptr @bump_malloc_inner(i64 noundef 13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(12) %result.i.i242, ptr noundef nonnull align 16 dereferenceable(12) %result.i117, i64 12, i1 false)
  %.fca.2.extract93 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts100 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i242)
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract89, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract91, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract93, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %offset.i.i, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %42 = getelementptr i8, ptr %9, i64 56
  %43 = load ptr, ptr %42, align 8
  %result.i122 = call ptr %43({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly %3) #15
  call void %result.i122({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %3) #7
  %result.i123 = call noalias align 16 dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i123, align 16
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i274 = call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i.i274, ptr noundef nonnull align 16 dereferenceable(9) %result.i123, i64 9, i1 false)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts101 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i274)
  ret void
}

; Function Attrs: nounwind
define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !908
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !908
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !908
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !908
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract2, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract4) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1) #40
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 112
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #15
  %22 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #16

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define void @report_exception({ ptr } %0) local_unnamed_addr #7 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %3 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %4 = load { ptr, i160 }, ptr %3, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %5 = icmp ne ptr %.fca.0.extract, @nil_typ
  %6 = icmp ne ptr %.fca.0.extract, null
  %.not5 = and i1 %5, %6
  br i1 %.not5, label %7, label %._crit_edge

7:                                                ; preds = %1
  %.fca.1.extract = extractvalue { ptr, i160 } %4, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %8 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %9 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !911
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !911
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !911
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !911
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %8, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %9, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %offset.i.i, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract) #34
  %16 = sext i32 %offset.i.i to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract, i64 %16
  %18 = getelementptr i8, ptr %17, i64 48
  %19 = load ptr, ptr %18, align 8
  %result.i = call ptr %19({ ptr, ptr, ptr, i32 } %13, ptr nocapture nofree noundef nonnull readonly %2) #15
  call void %result.i({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 %2) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %1, %7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IO(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @IO_B__Self_print_xNil__Self_print_xPtrf64__Self_print_xRepresentable__Self_print_xString__Self_print_xPtri32__Self_print_xPtri1__Self_print_xPtri64__Self_print_xCharacter__Self_print_xPtri8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #17 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #34
  %3 = load ptr, ptr %0, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = tail call i1 %10(i64 %9, i64 %8, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %11) #5
  %result.i14 = tail call i1 %10(i64 %9, i64 %8, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %11) #5
  %not.result.i = xor i1 %result.i, true
  %.reg2mem47.0 = select i1 %not.result.i, i1 true, i1 %result.i14
  br i1 %.reg2mem47.0, label %12, label %25

12:                                               ; preds = %1
  %13 = icmp eq ptr %3, @i64_typ
  br i1 %13, label %25, label %14

14:                                               ; preds = %12
  %15 = icmp eq ptr %3, @i8_typ
  br i1 %15, label %25, label %16

16:                                               ; preds = %14
  %17 = icmp eq ptr %3, @nil_typ
  %18 = icmp eq ptr %3, null
  %19 = or i1 %17, %18
  br i1 %19, label %25, label %20

20:                                               ; preds = %16
  %result.i15 = tail call i1 %10(i64 %9, i64 %8, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %11) #5
  %result.i15.not = xor i1 %result.i15, true
  %.reg2mem45.0 = or i1 %result.i, %result.i14
  %or.cond = select i1 %result.i15.not, i1 true, i1 %.reg2mem45.0
  br i1 %or.cond, label %.critedge, label %25

.critedge:                                        ; preds = %20
  %21 = icmp eq ptr %3, @bool_typ
  br i1 %21, label %25, label %22

22:                                               ; preds = %.critedge
  %not.result.i14 = xor i1 %result.i14, true
  %.reg2mem41.0 = or i1 %result.i, %not.result.i14
  %23 = icmp eq ptr %3, @i32_typ
  %24 = select i1 %23, i32 5, i32 2
  %.reg2mem39.0 = select i1 %.reg2mem41.0, i32 %24, i32 4
  br label %25

25:                                               ; preds = %20, %1, %12, %16, %22, %.critedge, %14
  %.reg2mem27.0 = phi i32 [ 7, %12 ], [ 9, %14 ], [ 1, %16 ], [ %.reg2mem39.0, %22 ], [ 6, %.critedge ], [ 8, %1 ], [ 3, %20 ]
  %26 = zext nneg i32 %.reg2mem27.0 to i64
  %27 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %26
  %28 = getelementptr i8, ptr %27, i64 80
  %29 = load ptr, ptr %28, align 8
  ret ptr %29
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xNil(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #16 {
._crit_edge.lr.ph.i:
  %result.i = tail call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 110, i8 105, i8 108>, ptr %result.i, align 4
  %result.i.i = tail call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i, i64 3, i1 false)
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtrf64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #16 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @float_string, double %3) #16
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xRepresentable(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.322.8.extract.trunc = trunc i160 %.fca.1.extract3 to i64
  %4 = inttoptr i64 %.sroa.322.8.extract.trunc to ptr
  %.sroa.523.8.extract.shift = lshr i160 %.fca.1.extract3, 64
  %.sroa.523.8.extract.trunc = trunc i160 %.sroa.523.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.523.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !914
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !914
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !914
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260840641129990118
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !914
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #34
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract2, i64 %12
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #15
  %15 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %hash_coef_ptr.i.i7 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i8 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i10 = load i64, ptr %hash_coef_ptr.i.i7, align 4, !noalias !917
  %tbl_size.i.i11 = load i64, ptr %tbl_size_ptr.i.i8, align 4, !noalias !917
  %offset_tbl.i.i12 = load ptr, ptr %offset_tbl_ptr.i.i9, align 8, !noalias !917
  %product.i.i.i13 = mul i64 %hash_coef.i.i10, 6499063144389013426
  %shifted.i.i.i14 = lshr i64 %product.i.i.i13, 32
  %xored.i.i.i15 = xor i64 %shifted.i.i.i14, %product.i.i.i13
  %hash.i.i.i16 = and i64 %xored.i.i.i15, %tbl_size.i.i11
  %offset_ptr.i.i17 = getelementptr i32, ptr %offset_tbl.i.i12, i64 %hash.i.i.i16
  %offset.i.i18 = load i32, ptr %offset_ptr.i.i17, align 4, !noalias !917
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i.i18, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1)
  %22 = sext i32 %offset.i.i18 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract1, i64 %22
  %24 = getelementptr i8, ptr %23, i64 112
  %25 = load ptr, ptr %24, align 8
  %result.i20 = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly %3) #15
  %26 = call { ptr } %result.i20({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr } %26, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xString(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !920
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !920
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !920
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !920
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #34
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract1, i64 %12
  %14 = getelementptr i8, ptr %13, i64 112
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #15
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri32(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #16 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.sroa.1.8.extract.trunc) #16
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri1(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #16 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %3 = trunc i160 %.fca.1.extract to i1
  br i1 %3, label %._crit_edge.lr.ph.i, label %._crit_edge.lr.ph.i84

._crit_edge.lr.ph.i:                              ; preds = %2
  %result.i.i = tail call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i32 1702195828, ptr %result.i.i, align 1
  br label %String_c_string_.exit

._crit_edge.lr.ph.i84:                            ; preds = %2
  %result.i39 = tail call noalias align 8 dereferenceable_or_null(6) ptr @bump_malloc_inner(i64 noundef 6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <5 x i8> <i8 102, i8 97, i8 108, i8 115, i8 101>, ptr %result.i39, align 8
  %result.i.i83 = tail call noalias dereferenceable_or_null(6) ptr @bump_malloc_inner(i64 noundef 6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i.i83, ptr noundef nonnull align 8 dereferenceable(5) %result.i39, i64 5, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %._crit_edge.lr.ph.i84, %._crit_edge.lr.ph.i
  %4 = phi i32 [ 4, %._crit_edge.lr.ph.i ], [ 5, %._crit_edge.lr.ph.i84 ]
  %result.i.i83.sink = phi ptr [ %result.i.i, %._crit_edge.lr.ph.i ], [ %result.i.i83, %._crit_edge.lr.ph.i84 ]
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %6 = zext nneg i32 %4 to i64
  %7 = getelementptr i8, ptr %result.i.i83.sink, i64 %6
  store i8 0, ptr %7, align 1
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i83.sink)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #16 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.sroa.1.8.extract.trunc) #16
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xCharacter(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !923
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !923
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !923
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !923
  %result.i = tail call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #34
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i8 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #15
  %16 = call i8 %result.i8({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  store i8 %16, ptr %result.i, align 1
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %result.i)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri8(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #16 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  %3 = sext i8 %.sroa.1.8.extract.trunc to i32
  %4 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3) #16
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define ptr @typegetter_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #18 {
  %result = tail call ptr %f(ptr nocapture nofree noundef nonnull readonly %0) #5
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { i64, i64 } @size_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0) local_unnamed_addr #18 {
  %result = tail call { i64, i64 } %f(ptr nocapture nofree readonly %0) #5
  ret { i64, i64 } %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { ptr, i160 } @box_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) local_unnamed_addr #18 {
  %result = tail call { ptr, i160 } %f(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5
  ret { ptr, i160 } %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: readwrite)
define void @unbox_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) local_unnamed_addr #19 {
  tail call void %f({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #12
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull readonly %1) local_unnamed_addr #20 {
  %result = tail call ptr %f({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #15
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @class_behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #20 {
  %result = tail call ptr %f(ptr nocapture nofree noundef nonnull %0) #15
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @adjust_trampoline(ptr nofree readonly %tramp) local_unnamed_addr #5 {
  %ret = tail call ptr @llvm.adjust.trampoline(ptr nofree readonly %tramp) #39
  ret ptr %ret
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #21

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none)
define noalias ptr @bump_malloc(i64 noundef %size) local_unnamed_addr #22 {
  %result = tail call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %current_ptr) local_unnamed_addr #23 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  ret ptr %current
}

define { i64, i64 } @_data_size_tuple_typ(ptr nocapture nofree readonly align 4 %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %1, %.lr.ph
  %.reg2mem20.010.reg2mem.0 = phi i64 [ %12, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011.reg2mem.0 = phi i64 [ %18, %.lr.ph ], [ 0, %1 ]
  %.reg2mem14.0 = phi i64 [ %19, %.lr.ph ], [ 1, %1 ]
  %.in.reg2mem.0 = phi i64 [ %21, %.lr.ph ], [ %3, %1 ]
  %5 = inttoptr i64 %.in.reg2mem.0 to ptr
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr i8, ptr %6, i64 72
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { i64, i64 } %8(ptr nonnull align 8 %5)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = extractvalue { i64, i64 } %9, 1
  %12 = tail call i64 @llvm.umax.i64(i64 %11, i64 %.reg2mem20.010.reg2mem.0)
  %13 = urem i64 %.reg2mem22.011.reg2mem.0, %11
  %14 = icmp eq i64 %13, 0
  %15 = sub i64 %11, %13
  %16 = select i1 %14, i64 0, i64 %15
  %17 = add i64 %10, %.reg2mem22.011.reg2mem.0
  %18 = add i64 %17, %16
  %19 = add i64 %.reg2mem14.0, 1
  %20 = getelementptr ptr, ptr %0, i64 %19
  %21 = load i64, ptr %20, align 4
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem22.0.lcssa.reg2mem.0 = phi i64 [ 0, %1 ], [ %18, %.lr.ph ]
  %.reg2mem20.0.lcssa.reg2mem.0 = phi i64 [ 1, %1 ], [ %12, %.lr.ph ]
  %23 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0, %.reg2mem20.0.lcssa.reg2mem.0
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = add i64 %26, %.reg2mem22.0.lcssa.reg2mem.0
  %28 = insertvalue { i64, i64 } undef, i64 %27, 0
  %29 = insertvalue { i64, i64 } %28, i64 %.reg2mem20.0.lcssa.reg2mem.0, 1
  ret { i64, i64 } %29
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #24

define { i64, i64 } @_data_size_union_typ(ptr nocapture nofree readonly align 4 %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge.thread, label %.lr.ph

.lr.ph:                                           ; preds = %1, %.lr.ph
  %.reg2mem20.010.reg2mem.0 = phi i64 [ %12, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011.reg2mem.0 = phi i64 [ %.fr, %.lr.ph ], [ 0, %1 ]
  %.reg2mem14.0 = phi i64 [ %19, %.lr.ph ], [ 1, %1 ]
  %.in.reg2mem.0 = phi i64 [ %21, %.lr.ph ], [ %3, %1 ]
  %5 = inttoptr i64 %.in.reg2mem.0 to ptr
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr i8, ptr %6, i64 72
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { i64, i64 } %8(ptr nonnull align 8 %5)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = extractvalue { i64, i64 } %9, 1
  %12 = tail call i64 @llvm.umax.i64(i64 %11, i64 %.reg2mem20.010.reg2mem.0)
  %13 = urem i64 %.reg2mem22.011.reg2mem.0, %11
  %14 = icmp eq i64 %13, 0
  %15 = sub i64 %11, %13
  %16 = select i1 %14, i64 0, i64 %15
  %17 = add i64 %10, %.reg2mem22.011.reg2mem.0
  %18 = tail call i64 @llvm.umax.i64(i64 %17, i64 %16)
  %.fr = freeze i64 %18
  %19 = add i64 %.reg2mem14.0, 1
  %20 = getelementptr ptr, ptr %0, i64 %19
  %21 = load i64, ptr %20, align 4
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph
  %right_size = icmp eq i64 %.fr, 32
  %spec.select = select i1 %right_size, i64 0, i64 8
  %23 = add i64 %spec.select, %.fr
  br label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %1
  %.reg2mem20.0.lcssa.reg2mem.012 = phi i64 [ 1, %1 ], [ %12, %._crit_edge ]
  %final_size = phi i64 [ 8, %1 ], [ %23, %._crit_edge ]
  %24 = urem i64 %final_size, %.reg2mem20.0.lcssa.reg2mem.012
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %.reg2mem20.0.lcssa.reg2mem.012, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %27, %final_size
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa.reg2mem.012, 1
  ret { i64, i64 } %30
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr nocapture nofree readonly align 4 %1, ptr nocapture nofree writeonly %2) {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %3, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %.fr.i, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %3 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %3 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = tail call i64 @llvm.umax.i64(i64 %20, i64 %19)
  %.fr.i = freeze i64 %21
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %.fr.i, 32
  %spec.select.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select.i, %.fr.i
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %3, %._crit_edge.i
  %.reg2mem20.0.lcssa.reg2mem.012.i = phi i64 [ 1, %3 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %3 ], [ %26, %._crit_edge.i ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %final_size.i, %.reg2mem20.0.lcssa.reg2mem.012.i
  %30 = icmp eq i64 %29, 0
  %31 = sub i64 %.reg2mem20.0.lcssa.reg2mem.012.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add i64 %32, %final_size.i
  %34 = icmp slt i64 %33, 17
  %35 = icmp eq i64 %33, 32
  %36 = select i1 %34, ptr %.fca.1.gep, ptr %28
  %37 = select i1 %35, ptr %4, ptr %36
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %37, i64 %33, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Default(ptr nocapture nofree readnone %parameterization) #0 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_Default(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %fat_ptr, ptr nocapture nofree readnone %parameterization) #5 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr inbounds i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr nocapture nofree readnone %parameterization, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %destination) #6 {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr inbounds i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 8
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr nofree %tramp) local_unnamed_addr #25 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr nofree %tramp, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect) #25
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) local_unnamed_addr #25

define noundef nonnull align 8 dereferenceable(16) ptr @coroutine_create(ptr nofree %func, ptr nofree %arg_passer) local_unnamed_addr {
  %stack = tail call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #42
  store ptr %func, ptr %stack, align 8
  %stack_top = getelementptr inbounds i8, ptr %stack, i64 8388608
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr inbounds i8, ptr %stack, i64 8
  %arg_passer_slot = getelementptr inbounds i8, ptr %stack, i64 32
  %into_callee_second_word = getelementptr inbounds i8, ptr %stack, i64 16
  %into_callee_third_word = getelementptr inbounds i8, ptr %stack, i64 24
  store i64 %stack_top_aligned, ptr %into_callee_buf, align 8
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 8
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr inbounds i8, ptr %stack, i64 40
  store i1 false, ptr %is_finished, align 8
  tail call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word)
  ret ptr %stack
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare noalias ptr @VirtualAlloc(ptr, i64, i32, i32) local_unnamed_addr #26

declare void @coroutine_trampoline(ptr) local_unnamed_addr

define void @setup_landing_pad() {
  %region = tail call noalias dereferenceable_or_null(21474836480) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 21474836480, i32 noundef 12288, i32 noundef 4) #42
  store ptr %region, ptr @current_ptr, align 8
  %sp = tail call ptr @llvm.stacksave.p0() #9
  store ptr %sp, ptr @into_caller_buf, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %sp, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %stack.i = tail call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #42
  store ptr @setup_landing_pad, ptr %stack.i, align 8
  %stack_top.i = getelementptr inbounds i8, ptr %stack.i, i64 8388608
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr inbounds i8, ptr %stack.i, i64 8
  %arg_passer_slot.i = getelementptr inbounds i8, ptr %stack.i, i64 32
  %into_callee_second_word.i = getelementptr inbounds i8, ptr %stack.i, i64 16
  %into_callee_third_word.i = getelementptr inbounds i8, ptr %stack.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 8
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 8
  store ptr @arg_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr inbounds i8, ptr %stack.i, i64 40
  store i1 false, ptr %is_finished.i, align 8
  tail call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word.i)
  store ptr %stack.i, ptr @current_coroutine, align 8
  %retval.i = load i1, ptr @always_one, align 1
  br i1 %retval.i, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = tail call i32 @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @string_string.95, ptr nofree noundef nonnull align 16 dereferenceable(45) @exception_message) #7
  %cc.unpack = load ptr, ptr @current_coroutine, align 8
  %cc1 = insertvalue { ptr } poison, ptr %cc.unpack, 0
  tail call void @report_exception({ ptr } %cc1) #7
  tail call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #27

define void @arg_passer(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %current_coroutine) {
  %func = load ptr, ptr %current_coroutine, align 8
  tail call void %func()
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define i1 @returns_one() local_unnamed_addr #28 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

declare void @exit() local_unnamed_addr

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define i32 @get_offset(ptr nocapture nofree readonly align 8 %vptr, ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(8) %id_ptr) local_unnamed_addr #15 {
  %id = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr = getelementptr i8, ptr %vptr, i64 40
  %hash_coef = load i64, ptr %hash_coef_ptr, align 8
  %tbl_size = load i64, ptr %tbl_size_ptr, align 8
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %product.i = mul i64 %hash_coef, %id
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %hash.i
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) local_unnamed_addr #0 {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %shifted, %product
  %hash = and i64 %xored, %tbl_size
  ret i64 %hash
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @assume_offset(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readonly align 4 %id_ptr) local_unnamed_addr #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @set_offset(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readonly align 4 %id_ptr) local_unnamed_addr #1 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id.i = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr.i = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %vptr, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, %id.i
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %destination = getelementptr i8, ptr %fat_ptr, i64 24
  store i32 %offset.i, ptr %destination, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nocapture nofree readonly %supertype_tbl) #18 {
  %product.i = mul i64 %cand_id, %hash_coef
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash.i
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr nocapture nofree noundef nonnull readonly %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nofree readonly %supertype_tbl) local_unnamed_addr #18 {
  %result = tail call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #5
  ret i1 %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @arg_buffer_filler(ptr nocapture nofree readnone %coroutine) local_unnamed_addr #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define ptr @get_current_coroutine() local_unnamed_addr #28 {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %from_buf, ptr %to_buf) #29 {
  %from_buf_second_word = getelementptr inbounds i8, ptr %from_buf, i64 8
  %from_buf_third_word = getelementptr inbounds i8, ptr %from_buf, i64 16
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = tail call ptr @llvm.stacksave.p0() #9
  store ptr %sp, ptr %from_buf, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %retval.i = load i1, ptr @always_one, align 1
  br i1 %retval.i, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  tail call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #30
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #30

; Function Attrs: nounwind
define void @coroutine_yield(ptr nocapture nofree writeonly align 8 %current_coroutine) local_unnamed_addr #7 {
  %into_callee_buf = getelementptr i8, ptr %current_coroutine, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #41
  ret void
}

; Function Attrs: nounwind
define void @coroutine_call(ptr %coroutine) local_unnamed_addr #7 {
  %old_into_caller.unpack = load ptr, ptr @into_caller_buf, align 8
  %old_into_caller.unpack1 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  %old_into_caller.unpack2 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr i8, ptr %coroutine, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr %into_callee_buf) #41
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store ptr %old_into_caller.unpack, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack1, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %old_into_caller.unpack2, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #16

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #31

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #32

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #32

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #33

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #2 = { mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none) }
attributes #3 = { mustprogress nounwind willreturn }
attributes #4 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
attributes #7 = { nounwind }
attributes #8 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #9 = { mustprogress nofree nosync nounwind willreturn }
attributes #10 = { mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #11 = { mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) }
attributes #12 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) }
attributes #13 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) }
attributes #14 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: read, inaccessiblemem: none) }
attributes #15 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #16 = { nofree nounwind }
attributes #17 = { mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #18 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) }
attributes #19 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: readwrite) }
attributes #20 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none) }
attributes #21 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #22 = { mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none) "alloc-family"="malloc" }
attributes #23 = { mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite) "alloc-family"="malloc" }
attributes #24 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #25 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #26 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #27 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #28 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) }
attributes #29 = { noinline nounwind memory(readwrite) }
attributes #30 = { noreturn nounwind }
attributes #31 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #32 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #33 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #34 = { nofree willreturn }
attributes #35 = { nounwind willreturn memory(argmem: readwrite) }
attributes #36 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #37 = { mustprogress nofree nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #38 = { nofree }
attributes #39 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #40 = { willreturn }
attributes #41 = { nounwind memory(readwrite) }
attributes #42 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(1) "alloc-family"="malloc" }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{!2}
!2 = distinct !{!2, !3, !"set_offset: %fat_ptr"}
!3 = distinct !{!3, !"set_offset"}
!4 = !{!5}
!5 = distinct !{!5, !6, !"set_offset: %fat_ptr"}
!6 = distinct !{!6, !"set_offset"}
!7 = !{!8}
!8 = distinct !{!8, !9, !"set_offset: %fat_ptr"}
!9 = distinct !{!9, !"set_offset"}
!10 = !{!11}
!11 = distinct !{!11, !12, !"set_offset: %fat_ptr"}
!12 = distinct !{!12, !"set_offset"}
!13 = !{!14}
!14 = distinct !{!14, !15, !"size_wrapper: argument 0"}
!15 = distinct !{!15, !"size_wrapper"}
!16 = !{!17}
!17 = distinct !{!17, !18, !"set_offset: %fat_ptr"}
!18 = distinct !{!18, !"set_offset"}
!19 = !{!20}
!20 = distinct !{!20, !21, !"size_wrapper: argument 0"}
!21 = distinct !{!21, !"size_wrapper"}
!22 = !{}
!23 = !{!24}
!24 = distinct !{!24, !25, !"set_offset: %fat_ptr"}
!25 = distinct !{!25, !"set_offset"}
!26 = !{!27}
!27 = distinct !{!27, !28, !"set_offset: %fat_ptr"}
!28 = distinct !{!28, !"set_offset"}
!29 = !{!30}
!30 = distinct !{!30, !31, !"set_offset: %fat_ptr"}
!31 = distinct !{!31, !"set_offset"}
!32 = !{!33}
!33 = distinct !{!33, !34, !"set_offset: %fat_ptr"}
!34 = distinct !{!34, !"set_offset"}
!35 = !{!36}
!36 = distinct !{!36, !37, !"set_offset: %fat_ptr"}
!37 = distinct !{!37, !"set_offset"}
!38 = !{!39}
!39 = distinct !{!39, !40, !"set_offset: %fat_ptr"}
!40 = distinct !{!40, !"set_offset"}
!41 = !{!42}
!42 = distinct !{!42, !43, !"set_offset: %fat_ptr"}
!43 = distinct !{!43, !"set_offset"}
!44 = !{!45}
!45 = distinct !{!45, !46, !"set_offset: %fat_ptr"}
!46 = distinct !{!46, !"set_offset"}
!47 = !{!48}
!48 = distinct !{!48, !49, !"set_offset: %fat_ptr"}
!49 = distinct !{!49, !"set_offset"}
!50 = !{!51}
!51 = distinct !{!51, !52, !"set_offset: %fat_ptr"}
!52 = distinct !{!52, !"set_offset"}
!53 = !{!54}
!54 = distinct !{!54, !55, !"size_wrapper: argument 0"}
!55 = distinct !{!55, !"size_wrapper"}
!56 = !{!57}
!57 = distinct !{!57, !58, !"set_offset: %fat_ptr"}
!58 = distinct !{!58, !"set_offset"}
!59 = !{!60}
!60 = distinct !{!60, !61, !"size_wrapper: argument 0"}
!61 = distinct !{!61, !"size_wrapper"}
!62 = !{!63}
!63 = distinct !{!63, !64, !"set_offset: %fat_ptr"}
!64 = distinct !{!64, !"set_offset"}
!65 = !{!66}
!66 = distinct !{!66, !67, !"set_offset: %fat_ptr"}
!67 = distinct !{!67, !"set_offset"}
!68 = !{!69}
!69 = distinct !{!69, !70, !"set_offset: %fat_ptr"}
!70 = distinct !{!70, !"set_offset"}
!71 = !{!72}
!72 = distinct !{!72, !73, !"set_offset: %fat_ptr"}
!73 = distinct !{!73, !"set_offset"}
!74 = !{!75}
!75 = distinct !{!75, !76, !"set_offset: %fat_ptr"}
!76 = distinct !{!76, !"set_offset"}
!77 = !{!78}
!78 = distinct !{!78, !79, !"set_offset: %fat_ptr"}
!79 = distinct !{!79, !"set_offset"}
!80 = !{!81}
!81 = distinct !{!81, !82, !"set_offset: %fat_ptr"}
!82 = distinct !{!82, !"set_offset"}
!83 = !{!84}
!84 = distinct !{!84, !85, !"set_offset: %fat_ptr"}
!85 = distinct !{!85, !"set_offset"}
!86 = !{!87}
!87 = distinct !{!87, !88, !"size_wrapper: argument 0"}
!88 = distinct !{!88, !"size_wrapper"}
!89 = !{!90}
!90 = distinct !{!90, !91, !"set_offset: %fat_ptr"}
!91 = distinct !{!91, !"set_offset"}
!92 = !{!93}
!93 = distinct !{!93, !94, !"size_wrapper: argument 0"}
!94 = distinct !{!94, !"size_wrapper"}
!95 = !{!96}
!96 = distinct !{!96, !97, !"set_offset: %fat_ptr"}
!97 = distinct !{!97, !"set_offset"}
!98 = !{!99}
!99 = distinct !{!99, !100, !"set_offset: %fat_ptr"}
!100 = distinct !{!100, !"set_offset"}
!101 = !{!102}
!102 = distinct !{!102, !103, !"set_offset: %fat_ptr"}
!103 = distinct !{!103, !"set_offset"}
!104 = !{!105}
!105 = distinct !{!105, !106, !"set_offset: %fat_ptr"}
!106 = distinct !{!106, !"set_offset"}
!107 = !{!108}
!108 = distinct !{!108, !109, !"set_offset: %fat_ptr"}
!109 = distinct !{!109, !"set_offset"}
!110 = !{!111}
!111 = distinct !{!111, !112, !"set_offset: %fat_ptr"}
!112 = distinct !{!112, !"set_offset"}
!113 = !{!114}
!114 = distinct !{!114, !115, !"set_offset: %fat_ptr"}
!115 = distinct !{!115, !"set_offset"}
!116 = !{!117}
!117 = distinct !{!117, !118, !"set_offset: %fat_ptr"}
!118 = distinct !{!118, !"set_offset"}
!119 = !{!120}
!120 = distinct !{!120, !121, !"set_offset: %fat_ptr"}
!121 = distinct !{!121, !"set_offset"}
!122 = !{!123}
!123 = distinct !{!123, !124, !"set_offset: %fat_ptr"}
!124 = distinct !{!124, !"set_offset"}
!125 = !{!126}
!126 = distinct !{!126, !127, !"size_wrapper: argument 0"}
!127 = distinct !{!127, !"size_wrapper"}
!128 = !{!129}
!129 = distinct !{!129, !130, !"set_offset: %fat_ptr"}
!130 = distinct !{!130, !"set_offset"}
!131 = !{!132}
!132 = distinct !{!132, !133, !"size_wrapper: argument 0"}
!133 = distinct !{!133, !"size_wrapper"}
!134 = !{!135}
!135 = distinct !{!135, !136, !"set_offset: %fat_ptr"}
!136 = distinct !{!136, !"set_offset"}
!137 = !{!138}
!138 = distinct !{!138, !139, !"set_offset: %fat_ptr"}
!139 = distinct !{!139, !"set_offset"}
!140 = !{!141}
!141 = distinct !{!141, !142, !"set_offset: %fat_ptr"}
!142 = distinct !{!142, !"set_offset"}
!143 = !{!144}
!144 = distinct !{!144, !145, !"set_offset: %fat_ptr"}
!145 = distinct !{!145, !"set_offset"}
!146 = !{!147}
!147 = distinct !{!147, !148, !"set_offset: %fat_ptr"}
!148 = distinct !{!148, !"set_offset"}
!149 = !{!150}
!150 = distinct !{!150, !151, !"set_offset: %fat_ptr"}
!151 = distinct !{!151, !"set_offset"}
!152 = !{!153}
!153 = distinct !{!153, !154, !"set_offset: %fat_ptr"}
!154 = distinct !{!154, !"set_offset"}
!155 = !{!156}
!156 = distinct !{!156, !157, !"set_offset: %fat_ptr"}
!157 = distinct !{!157, !"set_offset"}
!158 = !{!159}
!159 = distinct !{!159, !160, !"set_offset: %fat_ptr"}
!160 = distinct !{!160, !"set_offset"}
!161 = !{!162}
!162 = distinct !{!162, !163, !"set_offset: %fat_ptr"}
!163 = distinct !{!163, !"set_offset"}
!164 = !{!165}
!165 = distinct !{!165, !166, !"set_offset: %fat_ptr"}
!166 = distinct !{!166, !"set_offset"}
!167 = !{!168}
!168 = distinct !{!168, !169, !"set_offset: %fat_ptr"}
!169 = distinct !{!169, !"set_offset"}
!170 = !{!171}
!171 = distinct !{!171, !172, !"size_wrapper: argument 0"}
!172 = distinct !{!172, !"size_wrapper"}
!173 = !{!174}
!174 = distinct !{!174, !175, !"set_offset: %fat_ptr"}
!175 = distinct !{!175, !"set_offset"}
!176 = !{!177}
!177 = distinct !{!177, !178, !"size_wrapper: argument 0"}
!178 = distinct !{!178, !"size_wrapper"}
!179 = !{!180}
!180 = distinct !{!180, !181, !"set_offset: %fat_ptr"}
!181 = distinct !{!181, !"set_offset"}
!182 = !{!183}
!183 = distinct !{!183, !184, !"set_offset: %fat_ptr"}
!184 = distinct !{!184, !"set_offset"}
!185 = !{!186}
!186 = distinct !{!186, !187, !"set_offset: %fat_ptr"}
!187 = distinct !{!187, !"set_offset"}
!188 = !{!189}
!189 = distinct !{!189, !190, !"set_offset: %fat_ptr"}
!190 = distinct !{!190, !"set_offset"}
!191 = !{!192}
!192 = distinct !{!192, !193, !"set_offset: %fat_ptr"}
!193 = distinct !{!193, !"set_offset"}
!194 = !{!195}
!195 = distinct !{!195, !196, !"set_offset: %fat_ptr"}
!196 = distinct !{!196, !"set_offset"}
!197 = !{!198}
!198 = distinct !{!198, !199, !"set_offset: %fat_ptr"}
!199 = distinct !{!199, !"set_offset"}
!200 = !{!201}
!201 = distinct !{!201, !202, !"set_offset: %fat_ptr"}
!202 = distinct !{!202, !"set_offset"}
!203 = !{!204}
!204 = distinct !{!204, !205, !"size_wrapper: argument 0"}
!205 = distinct !{!205, !"size_wrapper"}
!206 = !{!207}
!207 = distinct !{!207, !208, !"set_offset: %fat_ptr"}
!208 = distinct !{!208, !"set_offset"}
!209 = !{!210}
!210 = distinct !{!210, !211, !"size_wrapper: argument 0"}
!211 = distinct !{!211, !"size_wrapper"}
!212 = !{!213}
!213 = distinct !{!213, !214, !"set_offset: %fat_ptr"}
!214 = distinct !{!214, !"set_offset"}
!215 = !{!216}
!216 = distinct !{!216, !217, !"set_offset: %fat_ptr"}
!217 = distinct !{!217, !"set_offset"}
!218 = !{!219}
!219 = distinct !{!219, !220, !"set_offset: %fat_ptr"}
!220 = distinct !{!220, !"set_offset"}
!221 = !{!222}
!222 = distinct !{!222, !223, !"set_offset: %fat_ptr"}
!223 = distinct !{!223, !"set_offset"}
!224 = !{!225}
!225 = distinct !{!225, !226, !"set_offset: %fat_ptr"}
!226 = distinct !{!226, !"set_offset"}
!227 = !{!228}
!228 = distinct !{!228, !229, !"set_offset: %fat_ptr"}
!229 = distinct !{!229, !"set_offset"}
!230 = !{!231}
!231 = distinct !{!231, !232, !"set_offset: %fat_ptr"}
!232 = distinct !{!232, !"set_offset"}
!233 = !{!234}
!234 = distinct !{!234, !235, !"set_offset: %fat_ptr"}
!235 = distinct !{!235, !"set_offset"}
!236 = !{!237}
!237 = distinct !{!237, !238, !"set_offset: %fat_ptr"}
!238 = distinct !{!238, !"set_offset"}
!239 = !{!240}
!240 = distinct !{!240, !241, !"set_offset: %fat_ptr"}
!241 = distinct !{!241, !"set_offset"}
!242 = !{!243}
!243 = distinct !{!243, !244, !"set_offset: %fat_ptr"}
!244 = distinct !{!244, !"set_offset"}
!245 = !{!246}
!246 = distinct !{!246, !247, !"set_offset: %fat_ptr"}
!247 = distinct !{!247, !"set_offset"}
!248 = !{!249}
!249 = distinct !{!249, !250, !"size_wrapper: argument 0"}
!250 = distinct !{!250, !"size_wrapper"}
!251 = !{!252}
!252 = distinct !{!252, !253, !"set_offset: %fat_ptr"}
!253 = distinct !{!253, !"set_offset"}
!254 = !{!255}
!255 = distinct !{!255, !256, !"size_wrapper: argument 0"}
!256 = distinct !{!256, !"size_wrapper"}
!257 = !{!258}
!258 = distinct !{!258, !259, !"set_offset: %fat_ptr"}
!259 = distinct !{!259, !"set_offset"}
!260 = !{!261}
!261 = distinct !{!261, !262, !"set_offset: %fat_ptr"}
!262 = distinct !{!262, !"set_offset"}
!263 = !{!264}
!264 = distinct !{!264, !265, !"set_offset: %fat_ptr"}
!265 = distinct !{!265, !"set_offset"}
!266 = !{!267}
!267 = distinct !{!267, !268, !"set_offset: %fat_ptr"}
!268 = distinct !{!268, !"set_offset"}
!269 = !{!270}
!270 = distinct !{!270, !271, !"set_offset: %fat_ptr"}
!271 = distinct !{!271, !"set_offset"}
!272 = !{!273}
!273 = distinct !{!273, !274, !"set_offset: %fat_ptr"}
!274 = distinct !{!274, !"set_offset"}
!275 = !{!276}
!276 = distinct !{!276, !277, !"set_offset: %fat_ptr"}
!277 = distinct !{!277, !"set_offset"}
!278 = !{!279}
!279 = distinct !{!279, !280, !"set_offset: %fat_ptr"}
!280 = distinct !{!280, !"set_offset"}
!281 = !{!282}
!282 = distinct !{!282, !283, !"size_wrapper: argument 0"}
!283 = distinct !{!283, !"size_wrapper"}
!284 = !{!285}
!285 = distinct !{!285, !286, !"set_offset: %fat_ptr"}
!286 = distinct !{!286, !"set_offset"}
!287 = !{!288}
!288 = distinct !{!288, !289, !"size_wrapper: argument 0"}
!289 = distinct !{!289, !"size_wrapper"}
!290 = !{!291}
!291 = distinct !{!291, !292, !"set_offset: %fat_ptr"}
!292 = distinct !{!292, !"set_offset"}
!293 = !{!294}
!294 = distinct !{!294, !295, !"set_offset: %fat_ptr"}
!295 = distinct !{!295, !"set_offset"}
!296 = !{!297}
!297 = distinct !{!297, !298, !"set_offset: %fat_ptr"}
!298 = distinct !{!298, !"set_offset"}
!299 = !{!300}
!300 = distinct !{!300, !301, !"set_offset: %fat_ptr"}
!301 = distinct !{!301, !"set_offset"}
!302 = !{!303}
!303 = distinct !{!303, !304, !"set_offset: %fat_ptr"}
!304 = distinct !{!304, !"set_offset"}
!305 = !{!306}
!306 = distinct !{!306, !307, !"set_offset: %fat_ptr"}
!307 = distinct !{!307, !"set_offset"}
!308 = !{!309}
!309 = distinct !{!309, !310, !"set_offset: %fat_ptr"}
!310 = distinct !{!310, !"set_offset"}
!311 = !{!312}
!312 = distinct !{!312, !313, !"set_offset: %fat_ptr"}
!313 = distinct !{!313, !"set_offset"}
!314 = !{!315}
!315 = distinct !{!315, !316, !"set_offset: %fat_ptr"}
!316 = distinct !{!316, !"set_offset"}
!317 = !{!318}
!318 = distinct !{!318, !319, !"set_offset: %fat_ptr"}
!319 = distinct !{!319, !"set_offset"}
!320 = !{!321}
!321 = distinct !{!321, !322, !"set_offset: %fat_ptr"}
!322 = distinct !{!322, !"set_offset"}
!323 = !{!324}
!324 = distinct !{!324, !325, !"set_offset: %fat_ptr"}
!325 = distinct !{!325, !"set_offset"}
!326 = !{!327}
!327 = distinct !{!327, !328, !"set_offset: %fat_ptr"}
!328 = distinct !{!328, !"set_offset"}
!329 = !{!330}
!330 = distinct !{!330, !331, !"set_offset: %fat_ptr"}
!331 = distinct !{!331, !"set_offset"}
!332 = !{!333}
!333 = distinct !{!333, !334, !"size_wrapper: argument 0"}
!334 = distinct !{!334, !"size_wrapper"}
!335 = !{!336}
!336 = distinct !{!336, !337, !"set_offset: %fat_ptr"}
!337 = distinct !{!337, !"set_offset"}
!338 = !{!339}
!339 = distinct !{!339, !340, !"size_wrapper: argument 0"}
!340 = distinct !{!340, !"size_wrapper"}
!341 = !{!342}
!342 = distinct !{!342, !343, !"set_offset: %fat_ptr"}
!343 = distinct !{!343, !"set_offset"}
!344 = !{!345}
!345 = distinct !{!345, !346, !"set_offset: %fat_ptr"}
!346 = distinct !{!346, !"set_offset"}
!347 = !{!348}
!348 = distinct !{!348, !349, !"set_offset: %fat_ptr"}
!349 = distinct !{!349, !"set_offset"}
!350 = !{!351}
!351 = distinct !{!351, !352, !"set_offset: %fat_ptr"}
!352 = distinct !{!352, !"set_offset"}
!353 = !{!354}
!354 = distinct !{!354, !355, !"set_offset: %fat_ptr"}
!355 = distinct !{!355, !"set_offset"}
!356 = !{!357}
!357 = distinct !{!357, !358, !"set_offset: %fat_ptr"}
!358 = distinct !{!358, !"set_offset"}
!359 = !{!360}
!360 = distinct !{!360, !361, !"set_offset: %fat_ptr"}
!361 = distinct !{!361, !"set_offset"}
!362 = !{!363}
!363 = distinct !{!363, !364, !"set_offset: %fat_ptr"}
!364 = distinct !{!364, !"set_offset"}
!365 = !{!366}
!366 = distinct !{!366, !367, !"size_wrapper: argument 0"}
!367 = distinct !{!367, !"size_wrapper"}
!368 = !{!369}
!369 = distinct !{!369, !370, !"set_offset: %fat_ptr"}
!370 = distinct !{!370, !"set_offset"}
!371 = !{!372}
!372 = distinct !{!372, !373, !"size_wrapper: argument 0"}
!373 = distinct !{!373, !"size_wrapper"}
!374 = !{!375}
!375 = distinct !{!375, !376, !"set_offset: %fat_ptr"}
!376 = distinct !{!376, !"set_offset"}
!377 = !{!378}
!378 = distinct !{!378, !379, !"set_offset: %fat_ptr"}
!379 = distinct !{!379, !"set_offset"}
!380 = !{!381}
!381 = distinct !{!381, !382, !"set_offset: %fat_ptr"}
!382 = distinct !{!382, !"set_offset"}
!383 = !{!384}
!384 = distinct !{!384, !385, !"set_offset: %fat_ptr"}
!385 = distinct !{!385, !"set_offset"}
!386 = !{!387}
!387 = distinct !{!387, !388, !"set_offset: %fat_ptr"}
!388 = distinct !{!388, !"set_offset"}
!389 = !{!390}
!390 = distinct !{!390, !391, !"set_offset: %fat_ptr"}
!391 = distinct !{!391, !"set_offset"}
!392 = !{!393}
!393 = distinct !{!393, !394, !"set_offset: %fat_ptr"}
!394 = distinct !{!394, !"set_offset"}
!395 = !{!396}
!396 = distinct !{!396, !397, !"set_offset: %fat_ptr"}
!397 = distinct !{!397, !"set_offset"}
!398 = !{!399}
!399 = distinct !{!399, !400, !"set_offset: %fat_ptr"}
!400 = distinct !{!400, !"set_offset"}
!401 = !{!402}
!402 = distinct !{!402, !403, !"set_offset: %fat_ptr"}
!403 = distinct !{!403, !"set_offset"}
!404 = !{!405}
!405 = distinct !{!405, !406, !"set_offset: %fat_ptr"}
!406 = distinct !{!406, !"set_offset"}
!407 = !{!408}
!408 = distinct !{!408, !409, !"set_offset: %fat_ptr"}
!409 = distinct !{!409, !"set_offset"}
!410 = !{!411}
!411 = distinct !{!411, !412, !"size_wrapper: argument 0"}
!412 = distinct !{!412, !"size_wrapper"}
!413 = !{!414}
!414 = distinct !{!414, !415, !"set_offset: %fat_ptr"}
!415 = distinct !{!415, !"set_offset"}
!416 = !{!417}
!417 = distinct !{!417, !418, !"size_wrapper: argument 0"}
!418 = distinct !{!418, !"size_wrapper"}
!419 = !{!420}
!420 = distinct !{!420, !421, !"set_offset: %fat_ptr"}
!421 = distinct !{!421, !"set_offset"}
!422 = !{!423}
!423 = distinct !{!423, !424, !"set_offset: %fat_ptr"}
!424 = distinct !{!424, !"set_offset"}
!425 = !{!426}
!426 = distinct !{!426, !427, !"set_offset: %fat_ptr"}
!427 = distinct !{!427, !"set_offset"}
!428 = !{!429}
!429 = distinct !{!429, !430, !"set_offset: %fat_ptr"}
!430 = distinct !{!430, !"set_offset"}
!431 = !{!432}
!432 = distinct !{!432, !433, !"set_offset: %fat_ptr"}
!433 = distinct !{!433, !"set_offset"}
!434 = !{!435}
!435 = distinct !{!435, !436, !"set_offset: %fat_ptr"}
!436 = distinct !{!436, !"set_offset"}
!437 = !{!438}
!438 = distinct !{!438, !439, !"set_offset: %fat_ptr"}
!439 = distinct !{!439, !"set_offset"}
!440 = !{!441}
!441 = distinct !{!441, !442, !"set_offset: %fat_ptr"}
!442 = distinct !{!442, !"set_offset"}
!443 = !{!444}
!444 = distinct !{!444, !445, !"set_offset: %fat_ptr"}
!445 = distinct !{!445, !"set_offset"}
!446 = !{!447}
!447 = distinct !{!447, !448, !"set_offset: %fat_ptr"}
!448 = distinct !{!448, !"set_offset"}
!449 = !{!450}
!450 = distinct !{!450, !451, !"size_wrapper: argument 0"}
!451 = distinct !{!451, !"size_wrapper"}
!452 = !{!453}
!453 = distinct !{!453, !454, !"set_offset: %fat_ptr"}
!454 = distinct !{!454, !"set_offset"}
!455 = !{!456}
!456 = distinct !{!456, !457, !"size_wrapper: argument 0"}
!457 = distinct !{!457, !"size_wrapper"}
!458 = !{!459}
!459 = distinct !{!459, !460, !"set_offset: %fat_ptr"}
!460 = distinct !{!460, !"set_offset"}
!461 = !{!462}
!462 = distinct !{!462, !463, !"set_offset: %fat_ptr"}
!463 = distinct !{!463, !"set_offset"}
!464 = !{!465}
!465 = distinct !{!465, !466, !"set_offset: %fat_ptr"}
!466 = distinct !{!466, !"set_offset"}
!467 = !{!468}
!468 = distinct !{!468, !469, !"set_offset: %fat_ptr"}
!469 = distinct !{!469, !"set_offset"}
!470 = !{!471}
!471 = distinct !{!471, !472, !"set_offset: %fat_ptr"}
!472 = distinct !{!472, !"set_offset"}
!473 = !{!474}
!474 = distinct !{!474, !475, !"set_offset: %fat_ptr"}
!475 = distinct !{!475, !"set_offset"}
!476 = !{!477}
!477 = distinct !{!477, !478, !"set_offset: %fat_ptr"}
!478 = distinct !{!478, !"set_offset"}
!479 = !{!480}
!480 = distinct !{!480, !481, !"set_offset: %fat_ptr"}
!481 = distinct !{!481, !"set_offset"}
!482 = !{!483}
!483 = distinct !{!483, !484, !"set_offset: %fat_ptr"}
!484 = distinct !{!484, !"set_offset"}
!485 = !{!486}
!486 = distinct !{!486, !487, !"set_offset: %fat_ptr"}
!487 = distinct !{!487, !"set_offset"}
!488 = !{!489}
!489 = distinct !{!489, !490, !"set_offset: %fat_ptr"}
!490 = distinct !{!490, !"set_offset"}
!491 = !{!492}
!492 = distinct !{!492, !493, !"set_offset: %fat_ptr"}
!493 = distinct !{!493, !"set_offset"}
!494 = !{!495}
!495 = distinct !{!495, !496, !"set_offset: %fat_ptr"}
!496 = distinct !{!496, !"set_offset"}
!497 = !{!498}
!498 = distinct !{!498, !499, !"set_offset: %fat_ptr"}
!499 = distinct !{!499, !"set_offset"}
!500 = !{!501}
!501 = distinct !{!501, !502, !"size_wrapper: argument 0"}
!502 = distinct !{!502, !"size_wrapper"}
!503 = !{!504}
!504 = distinct !{!504, !505, !"set_offset: %fat_ptr"}
!505 = distinct !{!505, !"set_offset"}
!506 = !{!507}
!507 = distinct !{!507, !508, !"set_offset: %fat_ptr"}
!508 = distinct !{!508, !"set_offset"}
!509 = !{!510}
!510 = distinct !{!510, !511, !"set_offset: %fat_ptr"}
!511 = distinct !{!511, !"set_offset"}
!512 = !{!513}
!513 = distinct !{!513, !514, !"set_offset: %fat_ptr"}
!514 = distinct !{!514, !"set_offset"}
!515 = !{!516}
!516 = distinct !{!516, !517, !"set_offset: %fat_ptr"}
!517 = distinct !{!517, !"set_offset"}
!518 = !{!519}
!519 = distinct !{!519, !520, !"set_offset: %fat_ptr"}
!520 = distinct !{!520, !"set_offset"}
!521 = !{!522}
!522 = distinct !{!522, !523, !"set_offset: %fat_ptr"}
!523 = distinct !{!523, !"set_offset"}
!524 = !{!525}
!525 = distinct !{!525, !526, !"set_offset: %fat_ptr"}
!526 = distinct !{!526, !"set_offset"}
!527 = !{!528}
!528 = distinct !{!528, !529, !"set_offset: %fat_ptr"}
!529 = distinct !{!529, !"set_offset"}
!530 = !{!531}
!531 = distinct !{!531, !532, !"set_offset: %fat_ptr"}
!532 = distinct !{!532, !"set_offset"}
!533 = !{!534}
!534 = distinct !{!534, !535, !"set_offset: %fat_ptr"}
!535 = distinct !{!535, !"set_offset"}
!536 = !{!537}
!537 = distinct !{!537, !538, !"size_wrapper: argument 0"}
!538 = distinct !{!538, !"size_wrapper"}
!539 = !{!540}
!540 = distinct !{!540, !541, !"set_offset: %fat_ptr"}
!541 = distinct !{!541, !"set_offset"}
!542 = !{!543}
!543 = distinct !{!543, !544, !"set_offset: %fat_ptr"}
!544 = distinct !{!544, !"set_offset"}
!545 = !{!546}
!546 = distinct !{!546, !547, !"set_offset: %fat_ptr"}
!547 = distinct !{!547, !"set_offset"}
!548 = !{!549}
!549 = distinct !{!549, !550, !"set_offset: %fat_ptr"}
!550 = distinct !{!550, !"set_offset"}
!551 = !{!552}
!552 = distinct !{!552, !553, !"set_offset: %fat_ptr"}
!553 = distinct !{!553, !"set_offset"}
!554 = !{!555}
!555 = distinct !{!555, !556, !"set_offset: %fat_ptr"}
!556 = distinct !{!556, !"set_offset"}
!557 = !{!558}
!558 = distinct !{!558, !559, !"set_offset: %fat_ptr"}
!559 = distinct !{!559, !"set_offset"}
!560 = !{!561}
!561 = distinct !{!561, !562, !"set_offset: %fat_ptr"}
!562 = distinct !{!562, !"set_offset"}
!563 = !{!564}
!564 = distinct !{!564, !565, !"set_offset: %fat_ptr"}
!565 = distinct !{!565, !"set_offset"}
!566 = !{!567}
!567 = distinct !{!567, !568, !"set_offset: %fat_ptr"}
!568 = distinct !{!568, !"set_offset"}
!569 = !{!570}
!570 = distinct !{!570, !571, !"set_offset: %fat_ptr"}
!571 = distinct !{!571, !"set_offset"}
!572 = !{!573}
!573 = distinct !{!573, !574, !"set_offset: %fat_ptr"}
!574 = distinct !{!574, !"set_offset"}
!575 = !{!576}
!576 = distinct !{!576, !577, !"set_offset: %fat_ptr"}
!577 = distinct !{!577, !"set_offset"}
!578 = !{!579}
!579 = distinct !{!579, !580, !"set_offset: %fat_ptr"}
!580 = distinct !{!580, !"set_offset"}
!581 = !{!582}
!582 = distinct !{!582, !583, !"set_offset: %fat_ptr"}
!583 = distinct !{!583, !"set_offset"}
!584 = !{!585}
!585 = distinct !{!585, !586, !"set_offset: %fat_ptr"}
!586 = distinct !{!586, !"set_offset"}
!587 = !{!588}
!588 = distinct !{!588, !589, !"set_offset: %fat_ptr"}
!589 = distinct !{!589, !"set_offset"}
!590 = !{!591}
!591 = distinct !{!591, !592, !"set_offset: %fat_ptr"}
!592 = distinct !{!592, !"set_offset"}
!593 = !{!594}
!594 = distinct !{!594, !595, !"set_offset: %fat_ptr"}
!595 = distinct !{!595, !"set_offset"}
!596 = !{!597}
!597 = distinct !{!597, !598, !"set_offset: %fat_ptr"}
!598 = distinct !{!598, !"set_offset"}
!599 = !{!600}
!600 = distinct !{!600, !601, !"set_offset: %fat_ptr"}
!601 = distinct !{!601, !"set_offset"}
!602 = !{!603}
!603 = distinct !{!603, !604, !"set_offset: %fat_ptr"}
!604 = distinct !{!604, !"set_offset"}
!605 = !{!606}
!606 = distinct !{!606, !607, !"set_offset: %fat_ptr"}
!607 = distinct !{!607, !"set_offset"}
!608 = !{!609}
!609 = distinct !{!609, !610, !"set_offset: %fat_ptr"}
!610 = distinct !{!610, !"set_offset"}
!611 = !{!612}
!612 = distinct !{!612, !613, !"set_offset: %fat_ptr"}
!613 = distinct !{!613, !"set_offset"}
!614 = !{!615}
!615 = distinct !{!615, !616, !"set_offset: %fat_ptr"}
!616 = distinct !{!616, !"set_offset"}
!617 = !{!618}
!618 = distinct !{!618, !619, !"set_offset: %fat_ptr"}
!619 = distinct !{!619, !"set_offset"}
!620 = !{!621}
!621 = distinct !{!621, !622, !"set_offset: %fat_ptr"}
!622 = distinct !{!622, !"set_offset"}
!623 = !{!624}
!624 = distinct !{!624, !625, !"set_offset: %fat_ptr"}
!625 = distinct !{!625, !"set_offset"}
!626 = !{!627}
!627 = distinct !{!627, !628, !"set_offset: %fat_ptr"}
!628 = distinct !{!628, !"set_offset"}
!629 = !{!630}
!630 = distinct !{!630, !631, !"set_offset: %fat_ptr"}
!631 = distinct !{!631, !"set_offset"}
!632 = !{!633}
!633 = distinct !{!633, !634, !"set_offset: %fat_ptr"}
!634 = distinct !{!634, !"set_offset"}
!635 = !{!636}
!636 = distinct !{!636, !637, !"set_offset: %fat_ptr"}
!637 = distinct !{!637, !"set_offset"}
!638 = !{!639}
!639 = distinct !{!639, !640, !"set_offset: %fat_ptr"}
!640 = distinct !{!640, !"set_offset"}
!641 = !{!642}
!642 = distinct !{!642, !643, !"set_offset: %fat_ptr"}
!643 = distinct !{!643, !"set_offset"}
!644 = !{!645}
!645 = distinct !{!645, !646, !"set_offset: %fat_ptr"}
!646 = distinct !{!646, !"set_offset"}
!647 = !{!648}
!648 = distinct !{!648, !649, !"set_offset: %fat_ptr"}
!649 = distinct !{!649, !"set_offset"}
!650 = !{!651}
!651 = distinct !{!651, !652, !"set_offset: %fat_ptr"}
!652 = distinct !{!652, !"set_offset"}
!653 = !{!654}
!654 = distinct !{!654, !655, !"set_offset: %fat_ptr"}
!655 = distinct !{!655, !"set_offset"}
!656 = !{!657}
!657 = distinct !{!657, !658, !"set_offset: %fat_ptr"}
!658 = distinct !{!658, !"set_offset"}
!659 = !{!660}
!660 = distinct !{!660, !661, !"set_offset: %fat_ptr"}
!661 = distinct !{!661, !"set_offset"}
!662 = !{!663}
!663 = distinct !{!663, !664, !"set_offset: %fat_ptr"}
!664 = distinct !{!664, !"set_offset"}
!665 = !{!666}
!666 = distinct !{!666, !667, !"set_offset: %fat_ptr"}
!667 = distinct !{!667, !"set_offset"}
!668 = !{!669}
!669 = distinct !{!669, !670, !"set_offset: %fat_ptr"}
!670 = distinct !{!670, !"set_offset"}
!671 = !{!672}
!672 = distinct !{!672, !673, !"set_offset: %fat_ptr"}
!673 = distinct !{!673, !"set_offset"}
!674 = !{!675}
!675 = distinct !{!675, !676, !"set_offset: %fat_ptr"}
!676 = distinct !{!676, !"set_offset"}
!677 = !{!678}
!678 = distinct !{!678, !679, !"set_offset: %fat_ptr"}
!679 = distinct !{!679, !"set_offset"}
!680 = !{!681}
!681 = distinct !{!681, !682, !"set_offset: %fat_ptr"}
!682 = distinct !{!682, !"set_offset"}
!683 = !{!684}
!684 = distinct !{!684, !685, !"set_offset: %fat_ptr"}
!685 = distinct !{!685, !"set_offset"}
!686 = !{!687}
!687 = distinct !{!687, !688, !"set_offset: %fat_ptr"}
!688 = distinct !{!688, !"set_offset"}
!689 = !{!690}
!690 = distinct !{!690, !691, !"set_offset: %fat_ptr"}
!691 = distinct !{!691, !"set_offset"}
!692 = !{!693}
!693 = distinct !{!693, !694, !"set_offset: %fat_ptr"}
!694 = distinct !{!694, !"set_offset"}
!695 = !{!696}
!696 = distinct !{!696, !697, !"set_offset: %fat_ptr"}
!697 = distinct !{!697, !"set_offset"}
!698 = !{!699}
!699 = distinct !{!699, !700, !"set_offset: %fat_ptr"}
!700 = distinct !{!700, !"set_offset"}
!701 = !{!702}
!702 = distinct !{!702, !703, !"set_offset: %fat_ptr"}
!703 = distinct !{!703, !"set_offset"}
!704 = !{!705}
!705 = distinct !{!705, !706, !"set_offset: %fat_ptr"}
!706 = distinct !{!706, !"set_offset"}
!707 = !{!708}
!708 = distinct !{!708, !709, !"set_offset: %fat_ptr"}
!709 = distinct !{!709, !"set_offset"}
!710 = !{!711}
!711 = distinct !{!711, !712, !"set_offset: %fat_ptr"}
!712 = distinct !{!712, !"set_offset"}
!713 = !{!714}
!714 = distinct !{!714, !715, !"set_offset: %fat_ptr"}
!715 = distinct !{!715, !"set_offset"}
!716 = !{!717}
!717 = distinct !{!717, !718, !"set_offset: %fat_ptr"}
!718 = distinct !{!718, !"set_offset"}
!719 = !{!720}
!720 = distinct !{!720, !721, !"set_offset: %fat_ptr"}
!721 = distinct !{!721, !"set_offset"}
!722 = !{!723}
!723 = distinct !{!723, !724, !"set_offset: %fat_ptr"}
!724 = distinct !{!724, !"set_offset"}
!725 = !{!726}
!726 = distinct !{!726, !727, !"set_offset: %fat_ptr"}
!727 = distinct !{!727, !"set_offset"}
!728 = !{!729}
!729 = distinct !{!729, !730, !"set_offset: %fat_ptr"}
!730 = distinct !{!730, !"set_offset"}
!731 = !{!732}
!732 = distinct !{!732, !733, !"set_offset: %fat_ptr"}
!733 = distinct !{!733, !"set_offset"}
!734 = !{!735}
!735 = distinct !{!735, !736, !"set_offset: %fat_ptr"}
!736 = distinct !{!736, !"set_offset"}
!737 = !{!738}
!738 = distinct !{!738, !739, !"set_offset: %fat_ptr"}
!739 = distinct !{!739, !"set_offset"}
!740 = !{!741}
!741 = distinct !{!741, !742, !"set_offset: %fat_ptr"}
!742 = distinct !{!742, !"set_offset"}
!743 = !{!744}
!744 = distinct !{!744, !745, !"set_offset: %fat_ptr"}
!745 = distinct !{!745, !"set_offset"}
!746 = !{!747}
!747 = distinct !{!747, !748, !"size_wrapper: argument 0"}
!748 = distinct !{!748, !"size_wrapper"}
!749 = !{!750}
!750 = distinct !{!750, !751, !"set_offset: %fat_ptr"}
!751 = distinct !{!751, !"set_offset"}
!752 = !{!753}
!753 = distinct !{!753, !754, !"set_offset: %fat_ptr"}
!754 = distinct !{!754, !"set_offset"}
!755 = !{!756}
!756 = distinct !{!756, !757, !"set_offset: %fat_ptr"}
!757 = distinct !{!757, !"set_offset"}
!758 = !{!759}
!759 = distinct !{!759, !760, !"set_offset: %fat_ptr"}
!760 = distinct !{!760, !"set_offset"}
!761 = !{!762}
!762 = distinct !{!762, !763, !"set_offset: %fat_ptr"}
!763 = distinct !{!763, !"set_offset"}
!764 = !{!765}
!765 = distinct !{!765, !766, !"set_offset: %fat_ptr"}
!766 = distinct !{!766, !"set_offset"}
!767 = !{!768}
!768 = distinct !{!768, !769, !"set_offset: %fat_ptr"}
!769 = distinct !{!769, !"set_offset"}
!770 = !{!771}
!771 = distinct !{!771, !772, !"set_offset: %fat_ptr"}
!772 = distinct !{!772, !"set_offset"}
!773 = !{!774}
!774 = distinct !{!774, !775, !"set_offset: %fat_ptr"}
!775 = distinct !{!775, !"set_offset"}
!776 = !{!777}
!777 = distinct !{!777, !778, !"set_offset: %fat_ptr"}
!778 = distinct !{!778, !"set_offset"}
!779 = !{!780}
!780 = distinct !{!780, !781, !"set_offset: %fat_ptr"}
!781 = distinct !{!781, !"set_offset"}
!782 = !{!783}
!783 = distinct !{!783, !784, !"set_offset: %fat_ptr"}
!784 = distinct !{!784, !"set_offset"}
!785 = !{!786}
!786 = distinct !{!786, !787, !"set_offset: %fat_ptr"}
!787 = distinct !{!787, !"set_offset"}
!788 = !{!789}
!789 = distinct !{!789, !790, !"set_offset: %fat_ptr"}
!790 = distinct !{!790, !"set_offset"}
!791 = !{!792}
!792 = distinct !{!792, !793, !"set_offset: %fat_ptr"}
!793 = distinct !{!793, !"set_offset"}
!794 = !{!795}
!795 = distinct !{!795, !796, !"set_offset: %fat_ptr"}
!796 = distinct !{!796, !"set_offset"}
!797 = !{!798}
!798 = distinct !{!798, !799, !"set_offset: %fat_ptr"}
!799 = distinct !{!799, !"set_offset"}
!800 = !{!801}
!801 = distinct !{!801, !802, !"set_offset: %fat_ptr"}
!802 = distinct !{!802, !"set_offset"}
!803 = !{!804}
!804 = distinct !{!804, !805, !"set_offset: %fat_ptr"}
!805 = distinct !{!805, !"set_offset"}
!806 = !{!807}
!807 = distinct !{!807, !808, !"set_offset: %fat_ptr"}
!808 = distinct !{!808, !"set_offset"}
!809 = !{!810}
!810 = distinct !{!810, !811, !"set_offset: %fat_ptr"}
!811 = distinct !{!811, !"set_offset"}
!812 = !{!813}
!813 = distinct !{!813, !814, !"set_offset: %fat_ptr"}
!814 = distinct !{!814, !"set_offset"}
!815 = !{!816}
!816 = distinct !{!816, !817, !"set_offset: %fat_ptr"}
!817 = distinct !{!817, !"set_offset"}
!818 = !{!819}
!819 = distinct !{!819, !820, !"set_offset: %fat_ptr"}
!820 = distinct !{!820, !"set_offset"}
!821 = !{!822}
!822 = distinct !{!822, !823, !"set_offset: %fat_ptr"}
!823 = distinct !{!823, !"set_offset"}
!824 = !{!825}
!825 = distinct !{!825, !826, !"set_offset: %fat_ptr"}
!826 = distinct !{!826, !"set_offset"}
!827 = !{!828}
!828 = distinct !{!828, !829, !"set_offset: %fat_ptr"}
!829 = distinct !{!829, !"set_offset"}
!830 = !{!831}
!831 = distinct !{!831, !832, !"set_offset: %fat_ptr"}
!832 = distinct !{!832, !"set_offset"}
!833 = !{!834}
!834 = distinct !{!834, !835, !"set_offset: %fat_ptr"}
!835 = distinct !{!835, !"set_offset"}
!836 = !{!837}
!837 = distinct !{!837, !838, !"set_offset: %fat_ptr"}
!838 = distinct !{!838, !"set_offset"}
!839 = !{!840}
!840 = distinct !{!840, !841, !"set_offset: %fat_ptr"}
!841 = distinct !{!841, !"set_offset"}
!842 = !{!843}
!843 = distinct !{!843, !844, !"set_offset: %fat_ptr"}
!844 = distinct !{!844, !"set_offset"}
!845 = !{!846}
!846 = distinct !{!846, !847, !"set_offset: %fat_ptr"}
!847 = distinct !{!847, !"set_offset"}
!848 = !{!849}
!849 = distinct !{!849, !850, !"set_offset: %fat_ptr"}
!850 = distinct !{!850, !"set_offset"}
!851 = !{!852}
!852 = distinct !{!852, !853, !"set_offset: %fat_ptr"}
!853 = distinct !{!853, !"set_offset"}
!854 = !{!855}
!855 = distinct !{!855, !856, !"set_offset: %fat_ptr"}
!856 = distinct !{!856, !"set_offset"}
!857 = !{!858}
!858 = distinct !{!858, !859, !"set_offset: %fat_ptr"}
!859 = distinct !{!859, !"set_offset"}
!860 = !{!861}
!861 = distinct !{!861, !862, !"set_offset: %fat_ptr"}
!862 = distinct !{!862, !"set_offset"}
!863 = !{!864}
!864 = distinct !{!864, !865, !"set_offset: %fat_ptr"}
!865 = distinct !{!865, !"set_offset"}
!866 = !{!867}
!867 = distinct !{!867, !868, !"set_offset: %fat_ptr"}
!868 = distinct !{!868, !"set_offset"}
!869 = !{!870}
!870 = distinct !{!870, !871, !"set_offset: %fat_ptr"}
!871 = distinct !{!871, !"set_offset"}
!872 = !{!873}
!873 = distinct !{!873, !874, !"set_offset: %fat_ptr"}
!874 = distinct !{!874, !"set_offset"}
!875 = !{!876}
!876 = distinct !{!876, !877, !"set_offset: %fat_ptr"}
!877 = distinct !{!877, !"set_offset"}
!878 = !{!879}
!879 = distinct !{!879, !880, !"set_offset: %fat_ptr"}
!880 = distinct !{!880, !"set_offset"}
!881 = !{!882}
!882 = distinct !{!882, !883, !"set_offset: %fat_ptr"}
!883 = distinct !{!883, !"set_offset"}
!884 = !{!885}
!885 = distinct !{!885, !886, !"set_offset: %fat_ptr"}
!886 = distinct !{!886, !"set_offset"}
!887 = !{!888}
!888 = distinct !{!888, !889, !"set_offset: %fat_ptr"}
!889 = distinct !{!889, !"set_offset"}
!890 = !{!891}
!891 = distinct !{!891, !892, !"set_offset: %fat_ptr"}
!892 = distinct !{!892, !"set_offset"}
!893 = !{!894}
!894 = distinct !{!894, !895, !"set_offset: %fat_ptr"}
!895 = distinct !{!895, !"set_offset"}
!896 = !{!897}
!897 = distinct !{!897, !898, !"set_offset: %fat_ptr"}
!898 = distinct !{!898, !"set_offset"}
!899 = !{!900}
!900 = distinct !{!900, !901, !"set_offset: %fat_ptr"}
!901 = distinct !{!901, !"set_offset"}
!902 = !{!903}
!903 = distinct !{!903, !904, !"set_offset: %fat_ptr"}
!904 = distinct !{!904, !"set_offset"}
!905 = !{!906}
!906 = distinct !{!906, !907, !"set_offset: %fat_ptr"}
!907 = distinct !{!907, !"set_offset"}
!908 = !{!909}
!909 = distinct !{!909, !910, !"set_offset: %fat_ptr"}
!910 = distinct !{!910, !"set_offset"}
!911 = !{!912}
!912 = distinct !{!912, !913, !"set_offset: %fat_ptr"}
!913 = distinct !{!913, !"set_offset"}
!914 = !{!915}
!915 = distinct !{!915, !916, !"set_offset: %fat_ptr"}
!916 = distinct !{!916, !"set_offset"}
!917 = !{!918}
!918 = distinct !{!918, !919, !"set_offset: %fat_ptr"}
!919 = distinct !{!919, !"set_offset"}
!920 = !{!921}
!921 = distinct !{!921, !922, !"set_offset: %fat_ptr"}
!922 = distinct !{!922, !"set_offset"}
!923 = !{!924}
!924 = distinct !{!924, !925, !"set_offset: %fat_ptr"}
!925 = distinct !{!925, !"set_offset"}
