; ModuleID = 'out_reg2mem.ll'
source_filename = "llvm-link"

@cxrss__HashMap_Benchmarks_Cuckoo_Hashing__Rev__Cleaned_ = internal unnamed_addr constant [59 x i8] c"--- HashMap Benchmarks (Cuckoo Hashing - Rev 3 Cleaned) ---"
@rcqkf_Error_Nil_returned_during_random_hit_test_for_key_ = internal unnamed_addr constant [51 x i8] c"Error: Nil returned during random hit test for key "
@vucqs_Error_Nil_returned_during_sequential_hit_test_for_key_ = internal unnamed_addr constant [55 x i8] c"Error: Nil returned during sequential hit test for key "
@_parameterization_PairPtri32._Ptri1 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_Ptri32, ptr @_parameterization_Ptri1, ptr null]
@_parameterization_PairPtri32._Ptri32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_Ptri32, ptr @_parameterization_Ptri32, ptr null]
@ayamz_Iterator_Error_Invalid_table_state = internal unnamed_addr constant [35 x i8] c"Iterator Error: Invalid table state"
@_parameterization_Nil = linkonce_odr constant [2 x ptr] [ptr @nil_typ, ptr null]
@Entry_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 22, i32 9, i32 0]
@Entry = constant { [3 x i64], [6 x ptr], [13 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_size_Entry, ptr @_box_Default, ptr @_unbox_Default], [13 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_primary_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_init_keyK_valueV_primary_hashPtri32, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_primary_hash_, ptr @Entry_init_keyK_valueV_primary_hashPtri32, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_primary_hash_] }
@HashMap_hashtbl = linkonce_odr constant [8 x ptr] [ptr null, ptr @HashMap, ptr @Container, ptr null, ptr @Object, ptr null, ptr @any_typ, ptr @Iterable2]
@HashMap_offset_tbl = linkonce_odr constant [8 x i32] [i32 0, i32 9, i32 87, i32 0, i32 87, i32 0, i32 9, i32 64]
@HashMap = constant { [3 x i64], [6 x ptr], [78 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427388091, i64 7], [6 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_size_HashMap, ptr @_box_Default, ptr @_unbox_Default], [78 x ptr] [ptr @HashMap_field_HashMap_0, ptr @HashMap_field_HashMap_1, ptr @HashMap_field_HashMap_2, ptr @HashMap_field_table1, ptr @HashMap_field_table2, ptr @HashMap_field_size, ptr @HashMap_field_hasher1_fn, ptr @HashMap_field_eq, ptr @HashMap_field_max_displacements, ptr @HashMap_B_init_hasher1_fnFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1, ptr @HashMap_B_hash1_keyK, ptr @HashMap_B_hash2_from_primary_primary_hashPtri32, ptr @HashMap_B_index1_primary_hashPtri32, ptr @HashMap_B_index2_secondary_hashPtri32, ptr @HashMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @HashMap_B_resize_, ptr @HashMap_B_insert_keyK_valueV, ptr @HashMap_B_get_keyK, ptr @HashMap_B_remove_keyK, ptr @HashMap_B_clear_, ptr @HashMap_B_size_, ptr @HashMap_B_iterator_, ptr @HashMap_B_each_fFunctionT_to_Nothing, ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @HashMap_B_all_fFunctionT_to_Ptri1, ptr @HashMap_B_any_fFunctionT_to_Ptri1, ptr @HashMap_B_map_fFunctionT_to_U, ptr @HashMap_B_filter_fFunctionT_to_Ptri1, ptr @HashMap_B_chain_otherIterable2T, ptr @HashMap_B_interleave_otherIterable2T, ptr @HashMap_B_zip_otherIterable2U, ptr @HashMap_B_product_otherIterable2U, ptr @HashMap_init_hasher1_fnFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1, ptr @HashMap_hash1_keyK, ptr @HashMap_hash2_from_primary_primary_hashPtri32, ptr @HashMap_index1_primary_hashPtri32, ptr @HashMap_index2_secondary_hashPtri32, ptr @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @HashMap_resize_, ptr @HashMap_insert_keyK_valueV, ptr @HashMap_get_keyK, ptr @HashMap_remove_keyK, ptr @HashMap_clear_, ptr @HashMap_size_, ptr @HashMap_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @HashMap_field_HashMap_2, ptr @HashMap_B_iterator_, ptr @HashMap_B_each_fFunctionT_to_Nothing, ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @HashMap_B_all_fFunctionT_to_Ptri1, ptr @HashMap_B_any_fFunctionT_to_Ptri1, ptr @HashMap_B_map_fFunctionT_to_U, ptr @HashMap_B_filter_fFunctionT_to_Ptri1, ptr @HashMap_B_chain_otherIterable2T, ptr @HashMap_B_interleave_otherIterable2T, ptr @HashMap_B_zip_otherIterable2U, ptr @HashMap_B_product_otherIterable2U, ptr @HashMap_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@HashMapIterator_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @HashMapIterator, ptr null, ptr @Iterator2, ptr null]
@HashMapIterator_offset_tbl = linkonce_odr constant [8 x i32] [i32 25, i32 9, i32 0, i32 25, i32 9, i32 0, i32 22, i32 0]
@HashMapIterator = constant { [3 x i64], [6 x ptr], [16 x ptr] } { [3 x i64] [i64 -704669437586349537, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @HashMapIterator_hashtbl, ptr @HashMapIterator_offset_tbl, ptr @_size_HashMapIterator, ptr @_box_Default, ptr @_unbox_Default], [16 x ptr] [ptr @HashMapIterator_field_HashMapIterator_0, ptr @HashMapIterator_field_HashMapIterator_1, ptr @HashMapIterator_field_HashMapIterator_2, ptr @HashMapIterator_field_map_table1, ptr @HashMapIterator_field_map_table2, ptr @HashMapIterator_field_current_table, ptr @HashMapIterator_field_index, ptr @HashMapIterator_field_len1, ptr @HashMapIterator_field_len2, ptr @HashMapIterator_B_init_map_table1ArrayEntryK._V_or_Nil_map_table2ArrayEntryK._V_or_Nil, ptr @HashMapIterator_B_next_, ptr @HashMapIterator_init_map_table1ArrayEntryK._V_or_Nil_map_table2ArrayEntryK._V_or_Nil, ptr @HashMapIterator_next_, ptr @HashMapIterator_field_HashMapIterator_2, ptr @HashMapIterator_B_next_, ptr @HashMapIterator_next_] }
@PRNG_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = linkonce_odr constant [4 x i32] [i32 14, i32 9, i32 9, i32 0]
@PRNG = constant { [3 x i64], [6 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_size_PRNG, ptr @_box_Default, ptr @_unbox_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedPtri32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedPtri32, ptr @PRNG_next_] }
@Entry_field_primary_hash = internal constant { ptr, ptr } { ptr @Entry_getter_primary_hash, ptr @Entry_setter_primary_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@HashMap_field_table1 = internal constant { ptr, ptr } { ptr @HashMap_getter_table1, ptr @HashMap_setter_table1 }
@HashMap_field_table2 = internal constant { ptr, ptr } { ptr @HashMap_getter_table2, ptr @HashMap_setter_table2 }
@HashMap_field_size = internal constant { ptr, ptr } { ptr @HashMap_getter_size, ptr @HashMap_setter_size }
@HashMap_field_hasher1_fn = internal constant { ptr, ptr } { ptr @HashMap_getter_hasher1_fn, ptr @HashMap_setter_hasher1_fn }
@HashMap_field_eq = internal constant { ptr, ptr } { ptr @HashMap_getter_eq, ptr @HashMap_setter_eq }
@HashMap_field_max_displacements = internal constant { ptr, ptr } { ptr @HashMap_getter_max_displacements, ptr @HashMap_setter_max_displacements }
@HashMapIterator_field_map_table1 = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_map_table1, ptr @HashMapIterator_setter_map_table1 }
@HashMapIterator_field_map_table2 = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_map_table2, ptr @HashMapIterator_setter_map_table2 }
@HashMapIterator_field_current_table = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_current_table, ptr @HashMapIterator_setter_current_table }
@HashMapIterator_field_index = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_index, ptr @HashMapIterator_setter_index }
@HashMapIterator_field_len1 = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_len1, ptr @HashMapIterator_setter_len1 }
@HashMapIterator_field_len2 = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_len2, ptr @HashMapIterator_setter_len2 }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@_parameterization_Ptri1 = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = linkonce_odr constant [4 x i32] [i32 19, i32 9, i32 9, i32 0]
@Pair = constant { [3 x i64], [6 x ptr], [10 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_size_Pair, ptr @_box_Default, ptr @_unbox_Default], [10 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_init_firstT_secondU, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_] }
@Container_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container]
@Container_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 9, i32 0, i32 9]
@Container = constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 9056556090793359372, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Container_hashtbl, ptr @Container_offset_tbl, ptr @_size_Container, ptr @_box_Default, ptr @_unbox_Default], [0 x ptr] undef }
@Iterator2_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Iterator2, ptr @Container]
@Iterator2_offset_tbl = linkonce_odr constant [4 x i32] [i32 12, i32 9, i32 9, i32 12]
@Iterator2 = constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 4189192806087951739, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Iterator2_hashtbl, ptr @Iterator2_offset_tbl, ptr @_size_Iterator2, ptr @_box_Default, ptr @_unbox_Default], [0 x ptr] undef }
@Iterable2_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Iterable2, ptr @any_typ, ptr @Container, ptr @Object]
@Iterable2_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 9, i32 32, i32 32]
@Iterable2 = constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 5693646204635713916, i64 4611686018427388349, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Iterable2_hashtbl, ptr @Iterable2_offset_tbl, ptr @_size_Iterable2, ptr @_box_Default, ptr @_unbox_Default], [0 x ptr] undef }
@Array_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Container, ptr null, ptr @Iterable2, ptr @Object, ptr @any_typ, ptr null, ptr null, ptr @Array]
@Array_offset_tbl = linkonce_odr constant [8 x i32] [i32 84, i32 0, i32 61, i32 84, i32 9, i32 0, i32 0, i32 9]
@Array = constant { [3 x i64], [6 x ptr], [75 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427388289, i64 7], [6 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_size_Array, ptr @_box_Default, ptr @_unbox_Default], [75 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_B__Self_from_iterable_iterableIterable2T, ptr @Array_B_init_, ptr @Array_B_init_capacityPtri32, ptr @Array_B_init_lengthPtri32_capacityPtri32, ptr @Array_B_length_, ptr @Array_B_capacity_, ptr @Array_B_append_xT, ptr @Array_B_reserve_new_capacityPtri32, ptr @Array_B__index_xPtri32, ptr @Array_B__set_index_xPtri32_valueT, ptr @Array_B_throw_oob_xPtri32, ptr @Array_B_unchecked_index_xPtri32, ptr @Array_B_unchecked_insert_xPtri32_valueT, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Ptri1, ptr @Array_B_any_fFunctionT_to_Ptri1, ptr @Array_B_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Ptri1, ptr @Array_B_chain_otherIterable2T, ptr @Array_B_interleave_otherIterable2T, ptr @Array_B_zip_otherIterable2U, ptr @Array_B_product_otherIterable2U, ptr @Array__Self_from_iterable_iterableIterable2T, ptr @Array_init_, ptr @Array_init_capacityPtri32, ptr @Array_init_lengthPtri32_capacityPtri32, ptr @Array_length_, ptr @Array_capacity_, ptr @Array_append_xT, ptr @Array_reserve_new_capacityPtri32, ptr @Array__index_xPtri32, ptr @Array__set_index_xPtri32_valueT, ptr @Array_throw_oob_xPtri32, ptr @Array_unchecked_index_xPtri32, ptr @Array_unchecked_insert_xPtri32_valueT, ptr @Array_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Ptri1, ptr @Array_B_any_fFunctionT_to_Ptri1, ptr @Array_B_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Ptri1, ptr @Array_B_chain_otherIterable2T, ptr @Array_B_interleave_otherIterable2T, ptr @Array_B_zip_otherIterable2U, ptr @Array_B_product_otherIterable2U, ptr @Array_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ArrayIterator_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @ArrayIterator, ptr null, ptr @Iterator2, ptr null]
@ArrayIterator_offset_tbl = linkonce_odr constant [8 x i32] [i32 19, i32 9, i32 0, i32 19, i32 9, i32 0, i32 16, i32 0]
@ArrayIterator = constant { [3 x i64], [6 x ptr], [10 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default], [10 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@MapIterable2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @MapIterable2, ptr @Container, ptr null, ptr @Iterable2, ptr null, ptr null]
@MapIterable2_offset_tbl = linkonce_odr constant [8 x i32] [i32 60, i32 9, i32 9, i32 60, i32 0, i32 37, i32 0, i32 0]
@MapIterable2 = constant { [3 x i64], [6 x ptr], [51 x ptr] } { [3 x i64] [i64 -1724859134596891929, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @MapIterable2_hashtbl, ptr @MapIterable2_offset_tbl, ptr @_size_MapIterable2, ptr @_box_Default, ptr @_unbox_Default], [51 x ptr] [ptr @MapIterable2_field_MapIterable2_0, ptr @MapIterable2_field_MapIterable2_1, ptr @MapIterable2_field_iterable, ptr @MapIterable2_field_f, ptr @MapIterable2_B_init_iterableIterable2T_fFunctionT_to_U, ptr @MapIterable2_B_iterator_, ptr @MapIterable2_B_each_fFunctionT_to_Nothing, ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable2_B_all_fFunctionT_to_Ptri1, ptr @MapIterable2_B_any_fFunctionT_to_Ptri1, ptr @MapIterable2_B_map_fFunctionT_to_U, ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1, ptr @MapIterable2_B_chain_otherIterable2T, ptr @MapIterable2_B_interleave_otherIterable2T, ptr @MapIterable2_B_zip_otherIterable2U, ptr @MapIterable2_B_product_otherIterable2U, ptr @MapIterable2_init_iterableIterable2T_fFunctionT_to_U, ptr @MapIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @MapIterable2_field_MapIterable2_1, ptr @MapIterable2_B_iterator_, ptr @MapIterable2_B_each_fFunctionT_to_Nothing, ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable2_B_all_fFunctionT_to_Ptri1, ptr @MapIterable2_B_any_fFunctionT_to_Ptri1, ptr @MapIterable2_B_map_fFunctionT_to_U, ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1, ptr @MapIterable2_B_chain_otherIterable2T, ptr @MapIterable2_B_interleave_otherIterable2T, ptr @MapIterable2_B_zip_otherIterable2U, ptr @MapIterable2_B_product_otherIterable2U, ptr @MapIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@MapIterator2_hashtbl = linkonce_odr constant [8 x ptr] [ptr null, ptr @Container, ptr @MapIterator2, ptr null, ptr @Object, ptr @Iterator2, ptr null, ptr @any_typ]
@MapIterator2_offset_tbl = linkonce_odr constant [8 x i32] [i32 0, i32 20, i32 9, i32 0, i32 20, i32 17, i32 0, i32 9]
@MapIterator2 = constant { [3 x i64], [6 x ptr], [11 x ptr] } { [3 x i64] [i64 -10255947709272500, i64 4611686018427388279, i64 7], [6 x ptr] [ptr @subtype_test, ptr @MapIterator2_hashtbl, ptr @MapIterator2_offset_tbl, ptr @_size_MapIterator2, ptr @_box_Default, ptr @_unbox_Default], [11 x ptr] [ptr @MapIterator2_field_MapIterator2_0, ptr @MapIterator2_field_MapIterator2_1, ptr @MapIterator2_field_iterator, ptr @MapIterator2_field_f, ptr @MapIterator2_B_init_iteratorIterator2T_fFunctionT_to_U, ptr @MapIterator2_B_next_, ptr @MapIterator2_init_iteratorIterator2T_fFunctionT_to_U, ptr @MapIterator2_next_, ptr @MapIterator2_field_MapIterator2_1, ptr @MapIterator2_B_next_, ptr @MapIterator2_next_] }
@FilterIterable2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable2, ptr @FilterIterable2, ptr null]
@FilterIterable2_offset_tbl = linkonce_odr constant [8 x i32] [i32 59, i32 9, i32 0, i32 59, i32 0, i32 36, i32 9, i32 0]
@FilterIterable2 = constant { [3 x i64], [6 x ptr], [50 x ptr] } { [3 x i64] [i64 1178467452958968374, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @FilterIterable2_hashtbl, ptr @FilterIterable2_offset_tbl, ptr @_size_FilterIterable2, ptr @_box_Default, ptr @_unbox_Default], [50 x ptr] [ptr @FilterIterable2_field_FilterIterable2_0, ptr @FilterIterable2_field_iterable, ptr @FilterIterable2_field_f, ptr @FilterIterable2_B_init_iterableIterable2T_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_iterator_, ptr @FilterIterable2_B_each_fFunctionT_to_Nothing, ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_map_fFunctionT_to_U, ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_chain_otherIterable2T, ptr @FilterIterable2_B_interleave_otherIterable2T, ptr @FilterIterable2_B_zip_otherIterable2U, ptr @FilterIterable2_B_product_otherIterable2U, ptr @FilterIterable2_init_iterableIterable2T_fFunctionT_to_Ptri1, ptr @FilterIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @FilterIterable2_field_FilterIterable2_0, ptr @FilterIterable2_B_iterator_, ptr @FilterIterable2_B_each_fFunctionT_to_Nothing, ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_map_fFunctionT_to_U, ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_chain_otherIterable2T, ptr @FilterIterable2_B_interleave_otherIterable2T, ptr @FilterIterable2_B_zip_otherIterable2U, ptr @FilterIterable2_B_product_otherIterable2U, ptr @FilterIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@FilterIterator2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @FilterIterator2, ptr @Container, ptr null, ptr null, ptr @Iterator2, ptr null]
@FilterIterator2_offset_tbl = linkonce_odr constant [8 x i32] [i32 19, i32 9, i32 9, i32 19, i32 0, i32 0, i32 16, i32 0]
@FilterIterator2 = constant { [3 x i64], [6 x ptr], [10 x ptr] } { [3 x i64] [i64 8213847504843366470, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @FilterIterator2_hashtbl, ptr @FilterIterator2_offset_tbl, ptr @_size_FilterIterator2, ptr @_box_Default, ptr @_unbox_Default], [10 x ptr] [ptr @FilterIterator2_field_FilterIterator2_0, ptr @FilterIterator2_field_iterator, ptr @FilterIterator2_field_f, ptr @FilterIterator2_B_init_iteratorIterator2T_fFunctionT_to_Ptri1, ptr @FilterIterator2_B_next_, ptr @FilterIterator2_init_iteratorIterator2T_fFunctionT_to_Ptri1, ptr @FilterIterator2_next_, ptr @FilterIterator2_field_FilterIterator2_0, ptr @FilterIterator2_B_next_, ptr @FilterIterator2_next_] }
@ChainIterable2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @ChainIterable2, ptr @Object, ptr @any_typ, ptr null, ptr null, ptr @Container, ptr null, ptr @Iterable2]
@ChainIterable2_offset_tbl = linkonce_odr constant [8 x i32] [i32 9, i32 59, i32 9, i32 0, i32 0, i32 59, i32 0, i32 36]
@ChainIterable2 = constant { [3 x i64], [6 x ptr], [50 x ptr] } { [3 x i64] [i64 -5233298072945030060, i64 4611686018427388319, i64 7], [6 x ptr] [ptr @subtype_test, ptr @ChainIterable2_hashtbl, ptr @ChainIterable2_offset_tbl, ptr @_size_ChainIterable2, ptr @_box_Default, ptr @_unbox_Default], [50 x ptr] [ptr @ChainIterable2_field_ChainIterable2_0, ptr @ChainIterable2_field_first, ptr @ChainIterable2_field_second, ptr @ChainIterable2_B_init_firstIterable2T_secondIterable2T, ptr @ChainIterable2_B_iterator_, ptr @ChainIterable2_B_each_fFunctionT_to_Nothing, ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_map_fFunctionT_to_U, ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_chain_otherIterable2T, ptr @ChainIterable2_B_interleave_otherIterable2T, ptr @ChainIterable2_B_zip_otherIterable2U, ptr @ChainIterable2_B_product_otherIterable2U, ptr @ChainIterable2_init_firstIterable2T_secondIterable2T, ptr @ChainIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ChainIterable2_field_ChainIterable2_0, ptr @ChainIterable2_B_iterator_, ptr @ChainIterable2_B_each_fFunctionT_to_Nothing, ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_map_fFunctionT_to_U, ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_chain_otherIterable2T, ptr @ChainIterable2_B_interleave_otherIterable2T, ptr @ChainIterable2_B_zip_otherIterable2U, ptr @ChainIterable2_B_product_otherIterable2U, ptr @ChainIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ChainIterator2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr null, ptr @Iterator2, ptr @ChainIterator2]
@ChainIterator2_offset_tbl = linkonce_odr constant [8 x i32] [i32 20, i32 9, i32 0, i32 20, i32 0, i32 0, i32 17, i32 9]
@ChainIterator2 = constant { [3 x i64], [6 x ptr], [11 x ptr] } { [3 x i64] [i64 -228267985060461774, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @ChainIterator2_hashtbl, ptr @ChainIterator2_offset_tbl, ptr @_size_ChainIterator2, ptr @_box_Default, ptr @_unbox_Default], [11 x ptr] [ptr @ChainIterator2_field_ChainIterator2_0, ptr @ChainIterator2_field_first, ptr @ChainIterator2_field_second, ptr @ChainIterator2_field_on_first, ptr @ChainIterator2_B_init_firstIterator2T_secondIterator2T, ptr @ChainIterator2_B_next_, ptr @ChainIterator2_init_firstIterator2T_secondIterator2T, ptr @ChainIterator2_next_, ptr @ChainIterator2_field_ChainIterator2_0, ptr @ChainIterator2_B_next_, ptr @ChainIterator2_next_] }
@InterleaveIterable2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Iterable2, ptr null, ptr null, ptr @InterleaveIterable2, ptr @any_typ, ptr @Object, ptr null, ptr @Container]
@InterleaveIterable2_offset_tbl = linkonce_odr constant [8 x i32] [i32 36, i32 0, i32 0, i32 9, i32 9, i32 59, i32 0, i32 59]
@InterleaveIterable2 = constant { [3 x i64], [6 x ptr], [50 x ptr] } { [3 x i64] [i64 -6258231685215461775, i64 4611686018427388207, i64 7], [6 x ptr] [ptr @subtype_test, ptr @InterleaveIterable2_hashtbl, ptr @InterleaveIterable2_offset_tbl, ptr @_size_InterleaveIterable2, ptr @_box_Default, ptr @_unbox_Default], [50 x ptr] [ptr @InterleaveIterable2_field_InterleaveIterable2_0, ptr @InterleaveIterable2_field_first, ptr @InterleaveIterable2_field_second, ptr @InterleaveIterable2_B_init_firstIterable2T_secondIterable2T, ptr @InterleaveIterable2_B_iterator_, ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_map_fFunctionT_to_U, ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_chain_otherIterable2T, ptr @InterleaveIterable2_B_interleave_otherIterable2T, ptr @InterleaveIterable2_B_zip_otherIterable2U, ptr @InterleaveIterable2_B_product_otherIterable2U, ptr @InterleaveIterable2_init_firstIterable2T_secondIterable2T, ptr @InterleaveIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @InterleaveIterable2_field_InterleaveIterable2_0, ptr @InterleaveIterable2_B_iterator_, ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_map_fFunctionT_to_U, ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_chain_otherIterable2T, ptr @InterleaveIterable2_B_interleave_otherIterable2T, ptr @InterleaveIterable2_B_zip_otherIterable2U, ptr @InterleaveIterable2_B_product_otherIterable2U, ptr @InterleaveIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@InterleaveIterator2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @any_typ, ptr null, ptr null, ptr @InterleaveIterator2, ptr @Container, ptr null, ptr @Iterator2, ptr @Object]
@InterleaveIterator2_offset_tbl = linkonce_odr constant [8 x i32] [i32 9, i32 0, i32 0, i32 9, i32 20, i32 0, i32 17, i32 20]
@InterleaveIterator2 = constant { [3 x i64], [6 x ptr], [11 x ptr] } { [3 x i64] [i64 6709847746581360093, i64 4611686018427388247, i64 7], [6 x ptr] [ptr @subtype_test, ptr @InterleaveIterator2_hashtbl, ptr @InterleaveIterator2_offset_tbl, ptr @_size_InterleaveIterator2, ptr @_box_Default, ptr @_unbox_Default], [11 x ptr] [ptr @InterleaveIterator2_field_InterleaveIterator2_0, ptr @InterleaveIterator2_field_first, ptr @InterleaveIterator2_field_second, ptr @InterleaveIterator2_field_on_first, ptr @InterleaveIterator2_B_init_firstIterator2T_secondIterator2T, ptr @InterleaveIterator2_B_next_, ptr @InterleaveIterator2_init_firstIterator2T_secondIterator2T, ptr @InterleaveIterator2_next_, ptr @InterleaveIterator2_field_InterleaveIterator2_0, ptr @InterleaveIterator2_B_next_, ptr @InterleaveIterator2_next_] }
@ZipIterable2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @ZipIterable2, ptr @Container, ptr null, ptr @Iterable2, ptr null, ptr null]
@ZipIterable2_offset_tbl = linkonce_odr constant [8 x i32] [i32 61, i32 9, i32 9, i32 61, i32 0, i32 38, i32 0, i32 0]
@ZipIterable2 = constant { [3 x i64], [6 x ptr], [52 x ptr] } { [3 x i64] [i64 -3218950579047519815, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @ZipIterable2_hashtbl, ptr @ZipIterable2_offset_tbl, ptr @_size_ZipIterable2, ptr @_box_Default, ptr @_unbox_Default], [52 x ptr] [ptr @ZipIterable2_field_ZipIterable2_0, ptr @ZipIterable2_field_ZipIterable2_1, ptr @ZipIterable2_field_ZipIterable2_2, ptr @ZipIterable2_field_first, ptr @ZipIterable2_field_second, ptr @ZipIterable2_B_init_firstIterable2T_secondIterable2U, ptr @ZipIterable2_B_iterator_, ptr @ZipIterable2_B_each_fFunctionT_to_Nothing, ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_map_fFunctionT_to_U, ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_chain_otherIterable2T, ptr @ZipIterable2_B_interleave_otherIterable2T, ptr @ZipIterable2_B_zip_otherIterable2U, ptr @ZipIterable2_B_product_otherIterable2U, ptr @ZipIterable2_init_firstIterable2T_secondIterable2U, ptr @ZipIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ZipIterable2_field_ZipIterable2_2, ptr @ZipIterable2_B_iterator_, ptr @ZipIterable2_B_each_fFunctionT_to_Nothing, ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_map_fFunctionT_to_U, ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_chain_otherIterable2T, ptr @ZipIterable2_B_interleave_otherIterable2T, ptr @ZipIterable2_B_zip_otherIterable2U, ptr @ZipIterable2_B_product_otherIterable2U, ptr @ZipIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ZipIterator2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @any_typ, ptr null, ptr null, ptr @ZipIterator2, ptr @Container, ptr null, ptr @Iterator2, ptr @Object]
@ZipIterator2_offset_tbl = linkonce_odr constant [8 x i32] [i32 9, i32 0, i32 0, i32 9, i32 21, i32 0, i32 18, i32 21]
@ZipIterator2 = constant { [3 x i64], [6 x ptr], [12 x ptr] } { [3 x i64] [i64 5502728639611621286, i64 4611686018427388247, i64 7], [6 x ptr] [ptr @subtype_test, ptr @ZipIterator2_hashtbl, ptr @ZipIterator2_offset_tbl, ptr @_size_ZipIterator2, ptr @_box_Default, ptr @_unbox_Default], [12 x ptr] [ptr @ZipIterator2_field_ZipIterator2_0, ptr @ZipIterator2_field_ZipIterator2_1, ptr @ZipIterator2_field_ZipIterator2_2, ptr @ZipIterator2_field_first, ptr @ZipIterator2_field_second, ptr @ZipIterator2_B_init_firstIterator2T_secondIterator2U, ptr @ZipIterator2_B_next_, ptr @ZipIterator2_init_firstIterator2T_secondIterator2U, ptr @ZipIterator2_next_, ptr @ZipIterator2_field_ZipIterator2_2, ptr @ZipIterator2_B_next_, ptr @ZipIterator2_next_] }
@ProductIterable2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable2, ptr @ProductIterable2, ptr null]
@ProductIterable2_offset_tbl = linkonce_odr constant [8 x i32] [i32 61, i32 9, i32 0, i32 61, i32 0, i32 38, i32 9, i32 0]
@ProductIterable2 = constant { [3 x i64], [6 x ptr], [52 x ptr] } { [3 x i64] [i64 7827074759551300494, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @ProductIterable2_hashtbl, ptr @ProductIterable2_offset_tbl, ptr @_size_ProductIterable2, ptr @_box_Default, ptr @_unbox_Default], [52 x ptr] [ptr @ProductIterable2_field_ProductIterable2_0, ptr @ProductIterable2_field_ProductIterable2_1, ptr @ProductIterable2_field_ProductIterable2_2, ptr @ProductIterable2_field_first, ptr @ProductIterable2_field_second, ptr @ProductIterable2_B_init_firstIterable2T_secondIterable2U, ptr @ProductIterable2_B_iterator_, ptr @ProductIterable2_B_each_fFunctionT_to_Nothing, ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_map_fFunctionT_to_U, ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_chain_otherIterable2T, ptr @ProductIterable2_B_interleave_otherIterable2T, ptr @ProductIterable2_B_zip_otherIterable2U, ptr @ProductIterable2_B_product_otherIterable2U, ptr @ProductIterable2_init_firstIterable2T_secondIterable2U, ptr @ProductIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ProductIterable2_field_ProductIterable2_2, ptr @ProductIterable2_B_iterator_, ptr @ProductIterable2_B_each_fFunctionT_to_Nothing, ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_map_fFunctionT_to_U, ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_chain_otherIterable2T, ptr @ProductIterable2_B_interleave_otherIterable2T, ptr @ProductIterable2_B_zip_otherIterable2U, ptr @ProductIterable2_B_product_otherIterable2U, ptr @ProductIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ProductIterator2_hashtbl = linkonce_odr constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @ProductIterator2, ptr @Iterator2, ptr null]
@ProductIterator2_offset_tbl = linkonce_odr constant [8 x i32] [i32 23, i32 9, i32 0, i32 23, i32 0, i32 9, i32 20, i32 0]
@ProductIterator2 = constant { [3 x i64], [6 x ptr], [14 x ptr] } { [3 x i64] [i64 4440657219728359865, i64 4611686018427388081, i64 7], [6 x ptr] [ptr @subtype_test, ptr @ProductIterator2_hashtbl, ptr @ProductIterator2_offset_tbl, ptr @_size_ProductIterator2, ptr @_box_Default, ptr @_unbox_Default], [14 x ptr] [ptr @ProductIterator2_field_ProductIterator2_0, ptr @ProductIterator2_field_ProductIterator2_1, ptr @ProductIterator2_field_ProductIterator2_2, ptr @ProductIterator2_field_first_iterator, ptr @ProductIterator2_field_second_iterator, ptr @ProductIterator2_field_second_iterable, ptr @ProductIterator2_field_current_first, ptr @ProductIterator2_B_init_first_iteratorIterator2T_second_iterableIterable2U, ptr @ProductIterator2_B_next_, ptr @ProductIterator2_init_first_iteratorIterator2T_second_iterableIterable2U, ptr @ProductIterator2_next_, ptr @ProductIterator2_field_ProductIterator2_2, ptr @ProductIterator2_B_next_, ptr @ProductIterator2_next_] }
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@MapIterable2_field_iterable = internal constant { ptr, ptr } { ptr @MapIterable2_getter_iterable, ptr @MapIterable2_setter_iterable }
@MapIterable2_field_f = internal constant { ptr, ptr } { ptr @MapIterable2_getter_f, ptr @MapIterable2_setter_f }
@MapIterator2_field_iterator = internal constant { ptr, ptr } { ptr @MapIterator2_getter_iterator, ptr @MapIterator2_setter_iterator }
@MapIterator2_field_f = internal constant { ptr, ptr } { ptr @MapIterator2_getter_f, ptr @MapIterator2_setter_f }
@FilterIterable2_field_iterable = internal constant { ptr, ptr } { ptr @FilterIterable2_getter_iterable, ptr @FilterIterable2_setter_iterable }
@FilterIterable2_field_f = internal constant { ptr, ptr } { ptr @FilterIterable2_getter_f, ptr @FilterIterable2_setter_f }
@FilterIterator2_field_iterator = internal constant { ptr, ptr } { ptr @FilterIterator2_getter_iterator, ptr @FilterIterator2_setter_iterator }
@FilterIterator2_field_f = internal constant { ptr, ptr } { ptr @FilterIterator2_getter_f, ptr @FilterIterator2_setter_f }
@ChainIterable2_field_first = internal constant { ptr, ptr } { ptr @ChainIterable2_getter_first, ptr @ChainIterable2_setter_first }
@ChainIterable2_field_second = internal constant { ptr, ptr } { ptr @ChainIterable2_getter_second, ptr @ChainIterable2_setter_second }
@ChainIterator2_field_first = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_first, ptr @ChainIterator2_setter_first }
@ChainIterator2_field_second = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_second, ptr @ChainIterator2_setter_second }
@ChainIterator2_field_on_first = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_on_first, ptr @ChainIterator2_setter_on_first }
@InterleaveIterable2_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterable2_getter_first, ptr @InterleaveIterable2_setter_first }
@InterleaveIterable2_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterable2_getter_second, ptr @InterleaveIterable2_setter_second }
@InterleaveIterator2_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_first, ptr @InterleaveIterator2_setter_first }
@InterleaveIterator2_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_second, ptr @InterleaveIterator2_setter_second }
@InterleaveIterator2_field_on_first = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_on_first, ptr @InterleaveIterator2_setter_on_first }
@ZipIterable2_field_first = internal constant { ptr, ptr } { ptr @ZipIterable2_getter_first, ptr @ZipIterable2_setter_first }
@ZipIterable2_field_second = internal constant { ptr, ptr } { ptr @ZipIterable2_getter_second, ptr @ZipIterable2_setter_second }
@ZipIterator2_field_first = internal constant { ptr, ptr } { ptr @ZipIterator2_getter_first, ptr @ZipIterator2_setter_first }
@ZipIterator2_field_second = internal constant { ptr, ptr } { ptr @ZipIterator2_getter_second, ptr @ZipIterator2_setter_second }
@ProductIterable2_field_first = internal constant { ptr, ptr } { ptr @ProductIterable2_getter_first, ptr @ProductIterable2_setter_first }
@ProductIterable2_field_second = internal constant { ptr, ptr } { ptr @ProductIterable2_getter_second, ptr @ProductIterable2_setter_second }
@ProductIterator2_field_first_iterator = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_first_iterator, ptr @ProductIterator2_setter_first_iterator }
@ProductIterator2_field_second_iterator = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_second_iterator, ptr @ProductIterator2_setter_second_iterator }
@ProductIterator2_field_second_iterable = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_second_iterable, ptr @ProductIterator2_setter_second_iterable }
@ProductIterator2_field_current_first = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_current_first, ptr @ProductIterator2_setter_current_first }
@_parameterization_Ptri8 = linkonce_odr constant [2 x ptr] [ptr @i8_typ, ptr null]
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@Object_hashtbl = linkonce_odr constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = linkonce_odr constant [2 x i32] [i32 9, i32 9]
@Iterator_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Iterator]
@Iterator_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 0, i32 9, i32 9]
@Iterable_hashtbl = linkonce_odr constant [4 x ptr] [ptr null, ptr @Iterable, ptr @any_typ, ptr @Object]
@Iterable_offset_tbl = linkonce_odr constant [4 x i32] [i32 0, i32 9, i32 9, i32 11]
@Representable_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 0, i32 9, i32 11]
@String_hashtbl = linkonce_odr constant [8 x ptr] [ptr @any_typ, ptr null, ptr @String, ptr @Representable, ptr @Object, ptr null, ptr null, ptr @Iterable]
@String_offset_tbl = linkonce_odr constant [8 x i32] [i32 9, i32 0, i32 9, i32 42, i32 42, i32 0, i32 0, i32 40]
@Character_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = linkonce_odr constant [4 x i32] [i32 14, i32 0, i32 9, i32 9]
@StringIterator_hashtbl = linkonce_odr constant [4 x ptr] [ptr @StringIterator, ptr @Object, ptr @any_typ, ptr @Iterator]
@StringIterator_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 15, i32 9, i32 15]
@Exception_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = linkonce_odr constant [4 x i32] [i32 22, i32 0, i32 9, i32 9]
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_length = internal constant { ptr, ptr } { ptr @String_getter_length, ptr @String_setter_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_byte = internal constant { ptr, ptr } { ptr @Character_getter_byte, ptr @Character_setter_byte }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_index, ptr @StringIterator_setter_index }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@_parameterization_Ptri32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@bool_typ_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 9, i32 0, i32 9]
@bool_typ = linkonce_odr constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ], [0 x ptr] undef }
@i8_typ_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 9, i32 0, i32 9]
@i8_typ = linkonce_odr constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ], [0 x ptr] undef }
@i32_typ_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 9, i32 9, i32 0]
@i32_typ = linkonce_odr constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ], [0 x ptr] undef }
@f64_typ_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 9, i32 0, i32 9]
@f64_typ = linkonce_odr constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ], [0 x ptr] undef }
@nil_typ_hashtbl = linkonce_odr constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = linkonce_odr constant [2 x i32] [i32 9, i32 9]
@nil_typ = linkonce_odr constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [6 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ], [0 x ptr] undef }
@any_typ_hashtbl = linkonce_odr constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = linkonce_odr constant [1 x i32] [i32 9]
@any_typ = linkonce_odr constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [6 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_size_any_typ, ptr @_box_Default, ptr @_unbox_Default], [0 x ptr] undef }
@function_typ_hashtbl = linkonce_odr constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 9, i32 9, i32 0]
@function_typ = linkonce_odr constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [6 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ], [0 x ptr] undef }
@union_typ_hashtbl = linkonce_odr constant [4 x ptr] [ptr @union_typ, ptr null, ptr @any_typ, ptr @Object]
@union_typ_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 0, i32 9, i32 9]
@union_typ = linkonce_odr constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 -7543233778997666740, i64 4611686018427388093, i64 3], [6 x ptr] [ptr @subtype_test, ptr @union_typ_hashtbl, ptr @union_typ_offset_tbl, ptr @_size_union_typ, ptr @_box_union_typ, ptr @_unbox_union_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [6 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_size_Object, ptr @_box_Default, ptr @_unbox_Default], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388091, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_size_Iterator, ptr @_box_Default, ptr @_unbox_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [6 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388093, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_size_Iterable, ptr @_box_Default, ptr @_unbox_Default], [0 x ptr] undef }
@Representable = constant { [3 x i64], [6 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_size_Representable, ptr @_box_Default, ptr @_unbox_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@String = constant { [3 x i64], [6 x ptr], [35 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427388073, i64 7], [6 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_size_String, ptr @_box_Default, ptr @_unbox_Default], [35 x ptr] [ptr @String_field_bytes, ptr @String_field_length, ptr @String_field_capacity, ptr @String_B_init_, ptr @String_B_init_bytesBufferPtri8_lengthPtri32_capacityPtri32, ptr @String_B_length_, ptr @String_B_capacity_, ptr @String_B_bytes_, ptr @String_B_append_xPtri8, ptr @String_B_extend_strString, ptr @String_B__index_xPtri32, ptr @String_B__EQ_otherString, ptr @String_B_pop_, ptr @String_B_copy_, ptr @String_B_c_string_, ptr @String_B_iterator_, ptr @String_B_repr_, ptr @String_init_, ptr @String_init_bytesBufferPtri8_lengthPtri32_capacityPtri32, ptr @String_length_, ptr @String_capacity_, ptr @String_bytes_, ptr @String_append_xPtri8, ptr @String_extend_strString, ptr @String__index_xPtri32, ptr @String__EQ_otherString, ptr @String_pop_, ptr @String_copy_, ptr @String_c_string_, ptr @String_iterator_, ptr @String_repr_, ptr @String_B_iterator_, ptr @String_iterator_, ptr @String_B_repr_, ptr @String_repr_] }
@Character = constant { [3 x i64], [6 x ptr], [5 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_size_Character, ptr @_box_Default, ptr @_unbox_Default], [5 x ptr] [ptr @Character_field_byte, ptr @Character_B_byte_, ptr @Character_B_init_bytePtri8, ptr @Character_byte_, ptr @Character_init_bytePtri8] }
@StringIterator = constant { [3 x i64], [6 x ptr], [6 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388097, i64 3], [6 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default], [6 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_index, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_] }
@Exception = constant { [3 x i64], [6 x ptr], [13 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [6 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_size_Exception, ptr @_box_Default, ptr @_unbox_Default], [13 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberPtri32_file_nameString, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberPtri32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@IO_hashtbl = linkonce_odr constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = linkonce_odr constant [4 x i32] [i32 9, i32 9, i32 0, i32 19]
@IO = constant { [3 x i64], [6 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [6 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_size_IO, ptr @_box_Default, ptr @_unbox_Default], [10 x ptr] [ptr @IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil, ptr @IO__Self_print_xPtri64, ptr @IO__Self_print_xPtri8, ptr @IO__Self_print_xPtrf64, ptr @IO__Self_print_xString, ptr @IO__Self_print_xPtri1, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xPtri32, ptr @IO__Self_print_xCharacter, ptr @IO__Self_print_xNil] }
@string_string.59 = internal constant [4 x i8] c"%s\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local local_unnamed_addr global ptr null
@always_one = linkonce thread_local local_unnamed_addr global i1 true
@current_ptr = internal thread_local global ptr null

define { i64, i64 } @_size_Entry(ptr nocapture readonly %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = tail call { i64, i64 } %6(ptr nonnull %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 20, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 20
  %15 = add i64 %14, %13
  %16 = getelementptr i8, ptr %0, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 48
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { i64, i64 } %20(ptr nonnull %17)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = extractvalue { i64, i64 } %21, 1
  %24 = tail call i64 @llvm.umax.i64(i64 %9, i64 %23)
  %25 = tail call i64 @llvm.umax.i64(i64 %24, i64 8)
  %26 = urem i64 %15, %23
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %23, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %22, %15
  %31 = add i64 %30, %29
  %32 = urem i64 %31, %25
  %33 = icmp eq i64 %32, 0
  %34 = sub i64 %25, %32
  %35 = select i1 %33, i64 0, i64 %34
  %36 = add i64 %31, %35
  %37 = insertvalue { i64, i64 } undef, i64 %36, 0
  %38 = insertvalue { i64, i64 } %37, i64 %25, 1
  ret { i64, i64 } %38
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_init_keyK_valueV_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_primary_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Entry_init_keyK_valueV_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract11)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract11, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  tail call void %13(ptr %.fca.1.extract12, { ptr, i160 } %3)
  %14 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract11)
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract12, { ptr, i160 } %4)
  %19 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract11)
  %20 = getelementptr i8, ptr %9, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  tail call void %23(ptr %.fca.1.extract12, i32 %5)
  ret void
}

define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract3)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4)
  ret { ptr, i160 } %10
}

define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract3)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 32
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4)
  ret { ptr, i160 } %10
}

define i32 @Entry_primary_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract)
  ret i32 %10
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #2

define linkonce_odr { i64, i64 } @_size_i32_typ(ptr %0) {
  ret { i64, i64 } { i64 4, i64 4 }
}

define linkonce_odr { ptr, i160 } @_box_i32_typ(ptr %0, ptr %1) {
  %3 = load i32, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i32 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

define linkonce_odr void @_unbox_i32_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  store i32 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #3

define linkonce_odr { i64, i64 } @_size_any_typ(ptr %0) {
  ret { i64, i64 } { i64 32, i64 8 }
}

define { ptr, i160 } @Entry_getter_value(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 48
  %5 = load ptr, ptr %4, align 8
  %6 = tail call { i64, i64 } %5(ptr nonnull %2)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = extractvalue { i64, i64 } %6, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 48
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { i64, i64 } %19(ptr nonnull %16)
  %21 = extractvalue { i64, i64 } %20, 1
  %22 = urem i64 %14, %21
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 %21, %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = getelementptr i8, ptr %0, i64 %14
  %27 = getelementptr i8, ptr %26, i64 %25
  %28 = load ptr, ptr %15, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = tail call { ptr, i160 } %31(ptr %27, ptr nonnull %28)
  ret { ptr, i160 } %32
}

define void @Entry_setter_value(ptr %0, { ptr, i160 } %1) {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = tail call { i64, i64 } %6(ptr nonnull %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 20, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 20
  %15 = add i64 %14, %13
  %16 = getelementptr i8, ptr %0, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 48
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { i64, i64 } %20(ptr nonnull %17)
  %22 = extractvalue { i64, i64 } %21, 1
  %23 = urem i64 %15, %22
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %22, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = getelementptr i8, ptr %0, i64 %15
  %28 = getelementptr i8, ptr %27, i64 %26
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  tail call void %32({ ptr, i160 } %1, ptr nonnull %29, ptr %28)
  ret void
}

define { ptr, i160 } @Entry_getter_key(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 48
  %5 = load ptr, ptr %4, align 8
  %6 = tail call { i64, i64 } %5(ptr nonnull %2)
  %7 = extractvalue { i64, i64 } %6, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = load ptr, ptr %0, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 56
  %16 = load ptr, ptr %15, align 8
  %17 = tail call { ptr, i160 } %16(ptr %12, ptr nonnull %13)
  ret { ptr, i160 } %17
}

define void @Entry_setter_key(ptr %0, { ptr, i160 } %1) {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = tail call { i64, i64 } %6(ptr nonnull %3)
  %8 = extractvalue { i64, i64 } %7, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %reass.sub = sub i64 %8, %9
  %11 = add i64 %reass.sub, 20
  %12 = select i1 %10, i64 20, i64 %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load ptr, ptr %0, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 64
  %17 = load ptr, ptr %16, align 8
  tail call void %17({ ptr, i160 } %1, ptr nonnull %14, ptr %13)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_primary_hash(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_primary_hash(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_HashMap(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 120, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_init_hasher1_fnFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_hash1_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_hash2_from_primary_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_index1_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_index2_secondary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_resize_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @HashMap_init_hasher1_fnFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr } %3, { ptr } %4) {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract3, i64 %7
  %9 = getelementptr i8, ptr %8, i64 48
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3)
  %13 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %14 = getelementptr i8, ptr %8, i64 56
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, { ptr } %4)
  %18 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %19 = load ptr, ptr %8, align 8
  %20 = tail call ptr %19(ptr %.fca.1.extract)
  %21 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %22 = getelementptr i8, ptr %8, i64 8
  %23 = load ptr, ptr %22, align 8
  %24 = tail call ptr %23(ptr %.fca.1.extract)
  %result.i = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %25 = getelementptr i8, ptr %result.i, i64 16
  store ptr @_parameterization_Nil, ptr %25, align 8
  %result.i4 = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %26 = getelementptr i8, ptr %result.i4, i64 16
  store ptr %24, ptr %26, align 8
  %27 = getelementptr i8, ptr %result.i4, i64 8
  store ptr %20, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i4, i64 24
  store ptr null, ptr %28, align 8
  %29 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4)
  store ptr @Entry, ptr %result.i4, align 8
  %30 = getelementptr i8, ptr %result.i, i64 8
  store ptr %result.i4, ptr %30, align 8
  %31 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %31, align 8
  %32 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @union_typ, ptr %result.i, align 8
  %result.i5 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i, ptr %result.i5, align 8
  %33 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5)
  %34 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i5, 1
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr undef, 2
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, i32 9, 3
  %37 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %38 = load ptr, ptr %8, align 8
  %39 = tail call ptr %38(ptr %.fca.1.extract)
  %40 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %41 = load ptr, ptr %22, align 8
  %42 = tail call ptr %41(ptr %.fca.1.extract)
  %43 = getelementptr i8, ptr %result.i5, i64 16
  store i32 8, ptr %43, align 4
  %44 = getelementptr i8, ptr %result.i5, i64 20
  store i32 8, ptr %44, align 4
  %result.i.i = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %45 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %46 = getelementptr i8, ptr %result.i5, i64 8
  store ptr %result.i.i, ptr %46, align 8
  %47 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %48 = getelementptr i8, ptr %8, i64 24
  %49 = load ptr, ptr %48, align 8
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  tail call void %51(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %36)
  %52 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %53 = load ptr, ptr %8, align 8
  %54 = tail call ptr %53(ptr %.fca.1.extract)
  %55 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %56 = load ptr, ptr %22, align 8
  %57 = tail call ptr %56(ptr %.fca.1.extract)
  %result.i20 = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %58 = getelementptr i8, ptr %result.i20, i64 16
  store ptr @_parameterization_Nil, ptr %58, align 8
  %result.i21 = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %59 = getelementptr i8, ptr %result.i21, i64 16
  store ptr %57, ptr %59, align 8
  %60 = getelementptr i8, ptr %result.i21, i64 8
  store ptr %54, ptr %60, align 8
  %61 = getelementptr i8, ptr %result.i21, i64 24
  store ptr null, ptr %61, align 8
  %62 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21)
  store ptr @Entry, ptr %result.i21, align 8
  %63 = getelementptr i8, ptr %result.i20, i64 8
  store ptr %result.i21, ptr %63, align 8
  %64 = getelementptr i8, ptr %result.i20, i64 24
  store ptr null, ptr %64, align 8
  %65 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20)
  store ptr @union_typ, ptr %result.i20, align 8
  %result.i22 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20, ptr %result.i22, align 8
  %66 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22)
  %67 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i22, 1
  %68 = insertvalue { ptr, ptr, ptr, i32 } %67, ptr undef, 2
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 9, 3
  %70 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %71 = load ptr, ptr %8, align 8
  %72 = tail call ptr %71(ptr %.fca.1.extract)
  %73 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %74 = load ptr, ptr %22, align 8
  %75 = tail call ptr %74(ptr %.fca.1.extract)
  %76 = getelementptr i8, ptr %result.i22, i64 16
  store i32 8, ptr %76, align 4
  %77 = getelementptr i8, ptr %result.i22, i64 20
  store i32 8, ptr %77, align 4
  %result.i.i97 = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %78 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %79 = getelementptr i8, ptr %result.i22, i64 8
  store ptr %result.i.i97, ptr %79, align 8
  %80 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %81 = getelementptr i8, ptr %8, i64 32
  %82 = load ptr, ptr %81, align 8
  %83 = getelementptr i8, ptr %82, i64 8
  %84 = load ptr, ptr %83, align 8
  tail call void %84(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %69)
  %85 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %86 = getelementptr i8, ptr %8, i64 40
  %87 = load ptr, ptr %86, align 8
  %88 = getelementptr i8, ptr %87, i64 8
  %89 = load ptr, ptr %88, align 8
  tail call void %89(ptr %.fca.1.extract, i32 0)
  %90 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract3)
  %91 = getelementptr i8, ptr %8, i64 64
  %92 = load ptr, ptr %91, align 8
  %93 = getelementptr i8, ptr %92, i64 8
  %94 = load ptr, ptr %93, align 8
  tail call void %94(ptr %.fca.1.extract, i32 100)
  ret void
}

define i32 @HashMap_hash1_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, i160 } %3) {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract5)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract5, i64 %6
  %8 = getelementptr i8, ptr %7, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr } %10(ptr %.fca.1.extract6)
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = tail call i32 %.fca.0.extract({ ptr, i160 } %3)
  ret i32 %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @HashMap_hash2_from_primary_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) #5 {
  %5 = add i32 %3, 2127912214
  %6 = shl i32 %3, 12
  %7 = add i32 %5, %6
  %8 = ashr i32 %7, 19
  %9 = xor i32 %7, %8
  %10 = xor i32 %9, -949894596
  %11 = add i32 %10, 374761393
  %12 = shl i32 %10, 5
  %13 = add i32 %11, %12
  %14 = add i32 %13, -744332180
  %15 = shl i32 %13, 9
  %16 = xor i32 %14, %15
  %17 = add i32 %16, -42973499
  %18 = shl i32 %16, 3
  %19 = add i32 %17, %18
  %20 = ashr i32 %19, 16
  %21 = xor i32 %19, %20
  %22 = xor i32 %21, -1252372727
  ret i32 %22
}

define i32 @HashMap_index1_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract1)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract1, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract3)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i21 = load i32, ptr %offset_ptr.i.i20, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i21
  tail call void @llvm.assume(i1 %eq.i) #30
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %.fca.3.extract, 3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract1)
  %18 = load ptr, ptr %8, align 8
  %19 = tail call ptr %18(ptr %.fca.1.extract3)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract1)
  %21 = getelementptr i8, ptr %8, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = tail call ptr %22(ptr %.fca.1.extract3)
  %24 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %25 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %26 = sext i32 %.fca.3.extract to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract, i64 %26
  %28 = getelementptr i8, ptr %27, i64 64
  %29 = load ptr, ptr %28, align 8
  %30 = call ptr %29({ ptr, ptr, ptr, i32 } %16, ptr nonnull %5)
  %31 = call i32 %30({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %5)
  %32 = add i32 %31, -1
  %33 = and i32 %32, %3
  ret i32 %33
}

define i32 @HashMap_index2_secondary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract1)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract1, i64 %7
  %9 = getelementptr i8, ptr %8, i64 32
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract3)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i21 = load i32, ptr %offset_ptr.i.i20, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i21
  tail call void @llvm.assume(i1 %eq.i) #30
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %.fca.3.extract, 3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract1)
  %18 = load ptr, ptr %8, align 8
  %19 = tail call ptr %18(ptr %.fca.1.extract3)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract1)
  %21 = getelementptr i8, ptr %8, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = tail call ptr %22(ptr %.fca.1.extract3)
  %24 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %25 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %26 = sext i32 %.fca.3.extract to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract, i64 %26
  %28 = getelementptr i8, ptr %27, i64 64
  %29 = load ptr, ptr %28, align 8
  %30 = call ptr %29({ ptr, ptr, ptr, i32 } %16, ptr nonnull %5)
  %31 = call i32 %30({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %5)
  %32 = add i32 %31, -1
  %33 = and i32 %32, %3
  ret i32 %33
}

define { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [2 x ptr], align 8
  %11 = alloca { ptr, ptr }, align 8
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %.sroa.0680 = alloca ptr, align 8
  %.sroa.1681 = alloca i160, align 8
  %15 = alloca i64, align 8
  %16 = alloca [1 x ptr], align 8
  %17 = alloca { ptr }, align 8
  %18 = alloca [1 x ptr], align 8
  %19 = alloca { ptr }, align 8
  %20 = alloca [1 x ptr], align 8
  %21 = alloca { ptr }, align 8
  %22 = alloca [2 x ptr], align 8
  %23 = alloca { ptr, ptr }, align 8
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %.sroa.0 = alloca ptr, align 8
  %.sroa.1 = alloca i160, align 8
  %27 = alloca i64, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i144 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i145 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i146 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i147 = load i64, ptr %hash_coef_ptr.i.i144, align 4
  %tbl_size.i.i148 = load i64, ptr %tbl_size_ptr.i.i145, align 4
  %offset_tbl.i.i149 = load ptr, ptr %offset_tbl_ptr.i.i146, align 8
  %product.i.i.i150 = mul i64 %hash_coef.i.i147, 4015701072841558310
  %shifted.i.i.i151 = lshr i64 %product.i.i.i150, 32
  %xored.i.i.i152 = xor i64 %shifted.i.i.i151, %product.i.i.i150
  %hash.i.i.i153 = and i64 %xored.i.i.i152, %tbl_size.i.i148
  %offset_ptr.i.i154 = getelementptr i32, ptr %offset_tbl.i.i149, i64 %hash.i.i.i153
  %offset.i.i169 = load i32, ptr %offset_ptr.i.i154, align 4
  %28 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %28, i64 8
  store ptr %.fca.1.extract, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 16
  store ptr %.fca.2.extract, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %28, i64 24
  store i32 %offset.i.i169, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %28)
  %33 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %34 = sext i32 %offset.i.i to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract14, i64 %34
  %36 = getelementptr i8, ptr %35, i64 64
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = tail call i32 %38(ptr %.fca.1.extract16)
  %40 = icmp sgt i32 %39, 0
  br i1 %40, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %4
  %.fca.2.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %41 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %42 = getelementptr i8, ptr %35, i64 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract16, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract18, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %offset.i.i, 3
  %47 = getelementptr i8, ptr %35, i64 88
  %48 = getelementptr i8, ptr %35, i64 104
  %49 = getelementptr i8, ptr %35, i64 32
  %50 = getelementptr inbounds i8, ptr %22, i64 8
  %51 = getelementptr inbounds i8, ptr %23, i64 8
  %52 = getelementptr i8, ptr %35, i64 96
  %53 = getelementptr i8, ptr %35, i64 24
  %54 = getelementptr inbounds i8, ptr %10, i64 8
  %55 = getelementptr inbounds i8, ptr %11, i64 8
  br label %56

56:                                               ; preds = %.lr.ph, %.cont.cont
  %.reg2mem195.0678 = phi i32 [ 1, %.lr.ph ], [ %222, %.cont.cont ]
  %.reg2mem193.0677 = phi i32 [ 0, %.lr.ph ], [ %223, %.cont.cont ]
  %57 = load ptr, ptr %28, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %57, 0
  %59 = load ptr, ptr %29, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 1
  %61 = load ptr, ptr %30, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %61, 2
  %63 = load i32, ptr %31, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %63, 3
  %65 = load ptr, ptr %35, align 8
  %66 = call ptr %65(ptr %.fca.1.extract16)
  %67 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %68 = load ptr, ptr %42, align 8
  %69 = call ptr %68(ptr %.fca.1.extract16)
  %70 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %71 = call ptr @llvm.invariant.start.p0(i64 104, ptr %57)
  %72 = sext i32 %63 to i64
  %73 = getelementptr ptr, ptr %57, i64 %72
  %74 = getelementptr i8, ptr %73, i64 64
  %75 = load ptr, ptr %74, align 8
  %76 = call ptr %75({ ptr, ptr, ptr, i32 } %64, ptr nonnull %5)
  %77 = call i32 %76({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull %5)
  %78 = icmp eq i32 %.reg2mem195.0678, 1
  %79 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %80 = load ptr, ptr %35, align 8
  %81 = call ptr %80(ptr %.fca.1.extract16)
  %82 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %83 = load ptr, ptr %42, align 8
  %84 = call ptr %83(ptr %.fca.1.extract16)
  br i1 %78, label %85, label %148

85:                                               ; preds = %56
  store ptr @_parameterization_Ptri32, ptr %6, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %6)
  %87 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %88 = load ptr, ptr %52, align 8
  store ptr @i32_typ, ptr %7, align 8
  %89 = call ptr %88({ ptr, ptr, ptr, i32 } %46, ptr nonnull %7)
  %90 = call i32 %89({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %6, i32 %77)
  %91 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %92 = load ptr, ptr %53, align 8
  %93 = load ptr, ptr %92, align 8
  %94 = call { ptr, ptr, ptr, i32 } %93(ptr %.fca.1.extract16)
  %.fca.0.extract116 = extractvalue { ptr, ptr, ptr, i32 } %94, 0
  %.fca.1.extract118 = extractvalue { ptr, ptr, ptr, i32 } %94, 1
  %.fca.2.extract120 = extractvalue { ptr, ptr, ptr, i32 } %94, 2
  %.fca.3.extract122 = extractvalue { ptr, ptr, ptr, i32 } %94, 3
  %hash_coef_ptr.i.i172 = getelementptr i8, ptr %.fca.0.extract116, i64 8
  %tbl_size_ptr.i.i173 = getelementptr i8, ptr %.fca.0.extract116, i64 16
  %offset_tbl_ptr.i.i174 = getelementptr i8, ptr %.fca.0.extract116, i64 40
  %hash_coef.i.i175 = load i64, ptr %hash_coef_ptr.i.i172, align 4
  %tbl_size.i.i176 = load i64, ptr %tbl_size_ptr.i.i173, align 4
  %offset_tbl.i.i177 = load ptr, ptr %offset_tbl_ptr.i.i174, align 8
  %product.i.i.i178 = mul i64 %hash_coef.i.i175, -5261542750394134544
  %shifted.i.i.i179 = lshr i64 %product.i.i.i178, 32
  %xored.i.i.i180 = xor i64 %shifted.i.i.i179, %product.i.i.i178
  %hash.i.i.i181 = and i64 %xored.i.i.i180, %tbl_size.i.i176
  %offset_ptr.i.i182 = getelementptr i32, ptr %offset_tbl.i.i177, i64 %hash.i.i.i181
  %offset.i.i183 = load i32, ptr %offset_ptr.i.i182, align 4
  %eq.i = icmp eq i32 %.fca.3.extract122, %offset.i.i183
  call void @llvm.assume(i1 %eq.i) #30
  %95 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract116, 0
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, ptr %.fca.1.extract118, 1
  %97 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %.fca.2.extract120, 2
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, i32 %.fca.3.extract122, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %100 = load ptr, ptr %35, align 8
  %101 = call ptr %100(ptr %.fca.1.extract16)
  %102 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %103 = load ptr, ptr %42, align 8
  %104 = call ptr %103(ptr %.fca.1.extract16)
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %8)
  %106 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract116)
  %107 = sext i32 %.fca.3.extract122 to i64
  %108 = getelementptr ptr, ptr %.fca.0.extract116, i64 %107
  %109 = getelementptr i8, ptr %108, i64 120
  %110 = load ptr, ptr %109, align 8
  store ptr @i32_typ, ptr %9, align 8
  %111 = call ptr %110({ ptr, ptr, ptr, i32 } %98, ptr nonnull %9)
  %112 = call { ptr, i160 } %111({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull %8, i32 %90)
  %.fca.0.extract112 = extractvalue { ptr, i160 } %112, 0
  %113 = load ptr, ptr %28, align 8
  %114 = load ptr, ptr %29, align 8
  %115 = load ptr, ptr %30, align 8
  %116 = load i32, ptr %31, align 8
  %117 = insertvalue { ptr, i160 } undef, ptr %113, 0
  %118 = ptrtoint ptr %114 to i64
  %119 = ptrtoint ptr %115 to i64
  %.sroa.3111.0.insert.ext = zext i32 %116 to i160
  %.sroa.3111.0.insert.shift = shl nuw i160 %.sroa.3111.0.insert.ext, 128
  %.sroa.2110.0.insert.ext = zext i64 %119 to i160
  %.sroa.2110.0.insert.shift = shl nuw nsw i160 %.sroa.2110.0.insert.ext, 64
  %.sroa.2110.0.insert.insert = or disjoint i160 %.sroa.3111.0.insert.shift, %.sroa.2110.0.insert.shift
  %.sroa.0109.0.insert.ext = zext i64 %118 to i160
  %.sroa.0109.0.insert.insert = or disjoint i160 %.sroa.2110.0.insert.insert, %.sroa.0109.0.insert.ext
  %120 = insertvalue { ptr, i160 } %117, i160 %.sroa.0109.0.insert.insert, 1
  %121 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %122 = load ptr, ptr %53, align 8
  %123 = load ptr, ptr %122, align 8
  %124 = call { ptr, ptr, ptr, i32 } %123(ptr %.fca.1.extract16)
  %.fca.0.extract100 = extractvalue { ptr, ptr, ptr, i32 } %124, 0
  %.fca.1.extract102 = extractvalue { ptr, ptr, ptr, i32 } %124, 1
  %.fca.2.extract104 = extractvalue { ptr, ptr, ptr, i32 } %124, 2
  %.fca.3.extract106 = extractvalue { ptr, ptr, ptr, i32 } %124, 3
  %hash_coef_ptr.i.i186 = getelementptr i8, ptr %.fca.0.extract100, i64 8
  %tbl_size_ptr.i.i187 = getelementptr i8, ptr %.fca.0.extract100, i64 16
  %offset_tbl_ptr.i.i188 = getelementptr i8, ptr %.fca.0.extract100, i64 40
  %hash_coef.i.i189 = load i64, ptr %hash_coef_ptr.i.i186, align 4
  %tbl_size.i.i190 = load i64, ptr %tbl_size_ptr.i.i187, align 4
  %offset_tbl.i.i191 = load ptr, ptr %offset_tbl_ptr.i.i188, align 8
  %product.i.i.i192 = mul i64 %hash_coef.i.i189, -5261542750394134544
  %shifted.i.i.i193 = lshr i64 %product.i.i.i192, 32
  %xored.i.i.i194 = xor i64 %shifted.i.i.i193, %product.i.i.i192
  %hash.i.i.i195 = and i64 %xored.i.i.i194, %tbl_size.i.i190
  %offset_ptr.i.i196 = getelementptr i32, ptr %offset_tbl.i.i191, i64 %hash.i.i.i195
  %offset.i.i197 = load i32, ptr %offset_ptr.i.i196, align 4
  %eq.i200 = icmp eq i32 %.fca.3.extract106, %offset.i.i197
  call void @llvm.assume(i1 %eq.i200) #30
  %125 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract100, 0
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, ptr %.fca.1.extract102, 1
  %127 = insertvalue { ptr, ptr, ptr, i32 } %126, ptr %.fca.2.extract104, 2
  %128 = insertvalue { ptr, ptr, ptr, i32 } %127, i32 %.fca.3.extract106, 3
  %129 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %130 = load ptr, ptr %35, align 8
  %131 = call ptr %130(ptr %.fca.1.extract16)
  %132 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %133 = load ptr, ptr %42, align 8
  %134 = call ptr %133(ptr %.fca.1.extract16)
  %result.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %135 = getelementptr i8, ptr %result.i, i64 16
  store ptr %134, ptr %135, align 8
  %136 = getelementptr i8, ptr %result.i, i64 8
  store ptr %131, ptr %136, align 8
  %137 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %137, align 8
  %138 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @Entry, ptr %result.i, align 8
  store ptr @_parameterization_Ptri32, ptr %10, align 8
  store ptr %result.i, ptr %54, align 8
  %139 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %10)
  %140 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract100)
  %141 = sext i32 %.fca.3.extract106 to i64
  %142 = getelementptr ptr, ptr %.fca.0.extract100, i64 %141
  %143 = getelementptr i8, ptr %142, i64 128
  %144 = load ptr, ptr %143, align 8
  store ptr @i32_typ, ptr %11, align 8
  store ptr %113, ptr %55, align 8
  %145 = call ptr %144({ ptr, ptr, ptr, i32 } %128, ptr nonnull %11)
  call void %145({ ptr, ptr, ptr, i32 } %128, { ptr, ptr, ptr, i32 } %128, ptr nonnull %10, i32 %90, { ptr, i160 } %120)
  %146 = icmp ne ptr %.fca.0.extract112, @nil_typ
  %147 = icmp ne ptr %.fca.0.extract112, null
  %.not140 = and i1 %146, %147
  br i1 %.not140, label %.cont.cont, label %228

148:                                              ; preds = %56
  store ptr @_parameterization_Ptri32, ptr %16, align 8
  %149 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %16)
  %150 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %151 = load ptr, ptr %47, align 8
  store ptr @i32_typ, ptr %17, align 8
  %152 = call ptr %151({ ptr, ptr, ptr, i32 } %46, ptr nonnull %17)
  %153 = call i32 %152({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %16, i32 %77)
  %154 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %155 = load ptr, ptr %35, align 8
  %156 = call ptr %155(ptr %.fca.1.extract16)
  %157 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %158 = load ptr, ptr %42, align 8
  %159 = call ptr %158(ptr %.fca.1.extract16)
  store ptr @_parameterization_Ptri32, ptr %18, align 8
  %160 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %18)
  %161 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %162 = load ptr, ptr %48, align 8
  store ptr @i32_typ, ptr %19, align 8
  %163 = call ptr %162({ ptr, ptr, ptr, i32 } %46, ptr nonnull %19)
  %164 = call i32 %163({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %18, i32 %153)
  %165 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %166 = load ptr, ptr %49, align 8
  %167 = load ptr, ptr %166, align 8
  %168 = call { ptr, ptr, ptr, i32 } %167(ptr %.fca.1.extract16)
  %.fca.0.extract91 = extractvalue { ptr, ptr, ptr, i32 } %168, 0
  %.fca.1.extract93 = extractvalue { ptr, ptr, ptr, i32 } %168, 1
  %.fca.2.extract95 = extractvalue { ptr, ptr, ptr, i32 } %168, 2
  %.fca.3.extract97 = extractvalue { ptr, ptr, ptr, i32 } %168, 3
  %hash_coef_ptr.i.i202 = getelementptr i8, ptr %.fca.0.extract91, i64 8
  %tbl_size_ptr.i.i203 = getelementptr i8, ptr %.fca.0.extract91, i64 16
  %offset_tbl_ptr.i.i204 = getelementptr i8, ptr %.fca.0.extract91, i64 40
  %hash_coef.i.i205 = load i64, ptr %hash_coef_ptr.i.i202, align 4
  %tbl_size.i.i206 = load i64, ptr %tbl_size_ptr.i.i203, align 4
  %offset_tbl.i.i207 = load ptr, ptr %offset_tbl_ptr.i.i204, align 8
  %product.i.i.i208 = mul i64 %hash_coef.i.i205, -5261542750394134544
  %shifted.i.i.i209 = lshr i64 %product.i.i.i208, 32
  %xored.i.i.i210 = xor i64 %shifted.i.i.i209, %product.i.i.i208
  %hash.i.i.i211 = and i64 %xored.i.i.i210, %tbl_size.i.i206
  %offset_ptr.i.i212 = getelementptr i32, ptr %offset_tbl.i.i207, i64 %hash.i.i.i211
  %offset.i.i213 = load i32, ptr %offset_ptr.i.i212, align 4
  %eq.i216 = icmp eq i32 %.fca.3.extract97, %offset.i.i213
  call void @llvm.assume(i1 %eq.i216) #30
  %169 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract91, 0
  %170 = insertvalue { ptr, ptr, ptr, i32 } %169, ptr %.fca.1.extract93, 1
  %171 = insertvalue { ptr, ptr, ptr, i32 } %170, ptr %.fca.2.extract95, 2
  %172 = insertvalue { ptr, ptr, ptr, i32 } %171, i32 %.fca.3.extract97, 3
  %173 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %174 = load ptr, ptr %35, align 8
  %175 = call ptr %174(ptr %.fca.1.extract16)
  %176 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %177 = load ptr, ptr %42, align 8
  %178 = call ptr %177(ptr %.fca.1.extract16)
  store ptr @_parameterization_Ptri32, ptr %20, align 8
  %179 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %20)
  %180 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract91)
  %181 = sext i32 %.fca.3.extract97 to i64
  %182 = getelementptr ptr, ptr %.fca.0.extract91, i64 %181
  %183 = getelementptr i8, ptr %182, i64 120
  %184 = load ptr, ptr %183, align 8
  store ptr @i32_typ, ptr %21, align 8
  %185 = call ptr %184({ ptr, ptr, ptr, i32 } %172, ptr nonnull %21)
  %186 = call { ptr, i160 } %185({ ptr, ptr, ptr, i32 } %172, { ptr, ptr, ptr, i32 } %172, ptr nonnull %20, i32 %164)
  %.fca.0.extract87 = extractvalue { ptr, i160 } %186, 0
  %187 = load ptr, ptr %28, align 8
  %188 = load ptr, ptr %29, align 8
  %189 = load ptr, ptr %30, align 8
  %190 = load i32, ptr %31, align 8
  %191 = insertvalue { ptr, i160 } undef, ptr %187, 0
  %192 = ptrtoint ptr %188 to i64
  %193 = ptrtoint ptr %189 to i64
  %.sroa.3.0.insert.ext = zext i32 %190 to i160
  %.sroa.3.0.insert.shift = shl nuw i160 %.sroa.3.0.insert.ext, 128
  %.sroa.2.0.insert.ext = zext i64 %193 to i160
  %.sroa.2.0.insert.shift = shl nuw nsw i160 %.sroa.2.0.insert.ext, 64
  %.sroa.2.0.insert.insert = or disjoint i160 %.sroa.3.0.insert.shift, %.sroa.2.0.insert.shift
  %.sroa.0.0.insert.ext = zext i64 %192 to i160
  %.sroa.0.0.insert.insert = or disjoint i160 %.sroa.2.0.insert.insert, %.sroa.0.0.insert.ext
  %194 = insertvalue { ptr, i160 } %191, i160 %.sroa.0.0.insert.insert, 1
  %195 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %196 = load ptr, ptr %49, align 8
  %197 = load ptr, ptr %196, align 8
  %198 = call { ptr, ptr, ptr, i32 } %197(ptr %.fca.1.extract16)
  %.fca.0.extract79 = extractvalue { ptr, ptr, ptr, i32 } %198, 0
  %.fca.1.extract81 = extractvalue { ptr, ptr, ptr, i32 } %198, 1
  %.fca.2.extract83 = extractvalue { ptr, ptr, ptr, i32 } %198, 2
  %.fca.3.extract85 = extractvalue { ptr, ptr, ptr, i32 } %198, 3
  %hash_coef_ptr.i.i218 = getelementptr i8, ptr %.fca.0.extract79, i64 8
  %tbl_size_ptr.i.i219 = getelementptr i8, ptr %.fca.0.extract79, i64 16
  %offset_tbl_ptr.i.i220 = getelementptr i8, ptr %.fca.0.extract79, i64 40
  %hash_coef.i.i221 = load i64, ptr %hash_coef_ptr.i.i218, align 4
  %tbl_size.i.i222 = load i64, ptr %tbl_size_ptr.i.i219, align 4
  %offset_tbl.i.i223 = load ptr, ptr %offset_tbl_ptr.i.i220, align 8
  %product.i.i.i224 = mul i64 %hash_coef.i.i221, -5261542750394134544
  %shifted.i.i.i225 = lshr i64 %product.i.i.i224, 32
  %xored.i.i.i226 = xor i64 %shifted.i.i.i225, %product.i.i.i224
  %hash.i.i.i227 = and i64 %xored.i.i.i226, %tbl_size.i.i222
  %offset_ptr.i.i228 = getelementptr i32, ptr %offset_tbl.i.i223, i64 %hash.i.i.i227
  %offset.i.i229 = load i32, ptr %offset_ptr.i.i228, align 4
  %eq.i232 = icmp eq i32 %.fca.3.extract85, %offset.i.i229
  call void @llvm.assume(i1 %eq.i232) #30
  %199 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract79, 0
  %200 = insertvalue { ptr, ptr, ptr, i32 } %199, ptr %.fca.1.extract81, 1
  %201 = insertvalue { ptr, ptr, ptr, i32 } %200, ptr %.fca.2.extract83, 2
  %202 = insertvalue { ptr, ptr, ptr, i32 } %201, i32 %.fca.3.extract85, 3
  %203 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %204 = load ptr, ptr %35, align 8
  %205 = call ptr %204(ptr %.fca.1.extract16)
  %206 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %207 = load ptr, ptr %42, align 8
  %208 = call ptr %207(ptr %.fca.1.extract16)
  %result.i233 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %209 = getelementptr i8, ptr %result.i233, i64 16
  store ptr %208, ptr %209, align 8
  %210 = getelementptr i8, ptr %result.i233, i64 8
  store ptr %205, ptr %210, align 8
  %211 = getelementptr i8, ptr %result.i233, i64 24
  store ptr null, ptr %211, align 8
  %212 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233)
  store ptr @Entry, ptr %result.i233, align 8
  store ptr @_parameterization_Ptri32, ptr %22, align 8
  store ptr %result.i233, ptr %50, align 8
  %213 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %22)
  %214 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract79)
  %215 = sext i32 %.fca.3.extract85 to i64
  %216 = getelementptr ptr, ptr %.fca.0.extract79, i64 %215
  %217 = getelementptr i8, ptr %216, i64 128
  %218 = load ptr, ptr %217, align 8
  store ptr @i32_typ, ptr %23, align 8
  store ptr %187, ptr %51, align 8
  %219 = call ptr %218({ ptr, ptr, ptr, i32 } %202, ptr nonnull %23)
  call void %219({ ptr, ptr, ptr, i32 } %202, { ptr, ptr, ptr, i32 } %202, ptr nonnull %22, i32 %164, { ptr, i160 } %194)
  %220 = icmp ne ptr %.fca.0.extract87, @nil_typ
  %221 = icmp ne ptr %.fca.0.extract87, null
  %.not138 = and i1 %220, %221
  br i1 %.not138, label %.cont.cont, label %228

.cont.cont:                                       ; preds = %148, %85
  %.sink = phi { ptr, i160 } [ %112, %85 ], [ %186, %148 ]
  %222 = phi i32 [ 2, %85 ], [ 1, %148 ]
  %vptr.i248.sroa.speculated = phi ptr [ %.fca.0.extract112, %85 ], [ %.fca.0.extract87, %148 ]
  %.fca.1.extract114 = extractvalue { ptr, i160 } %.sink, 1
  %.sroa.9.8.extract.shift = lshr i160 %.fca.1.extract114, 64
  %.sroa.9.8.extract.trunc = trunc i160 %.sroa.9.8.extract.shift to i64
  %.sroa.5440.8.extract.trunc = trunc i160 %.fca.1.extract114 to i64
  %.sroa.speculated352 = inttoptr i64 %.sroa.5440.8.extract.trunc to ptr
  %.sroa.speculated346 = inttoptr i64 %.sroa.9.8.extract.trunc to ptr
  %hash_coef_ptr.i.i249 = getelementptr i8, ptr %vptr.i248.sroa.speculated, i64 8
  %tbl_size_ptr.i.i250 = getelementptr i8, ptr %vptr.i248.sroa.speculated, i64 16
  %offset_tbl_ptr.i.i251 = getelementptr i8, ptr %vptr.i248.sroa.speculated, i64 40
  %hash_coef.i.i252 = load i64, ptr %hash_coef_ptr.i.i249, align 4
  %tbl_size.i.i253 = load i64, ptr %tbl_size_ptr.i.i250, align 4
  %offset_tbl.i.i254 = load ptr, ptr %offset_tbl_ptr.i.i251, align 8
  %product.i.i.i255 = mul i64 %hash_coef.i.i252, 4015701072841558310
  %shifted.i.i.i256 = lshr i64 %product.i.i.i255, 32
  %xored.i.i.i257 = xor i64 %shifted.i.i.i256, %product.i.i.i255
  %hash.i.i.i258 = and i64 %xored.i.i.i257, %tbl_size.i.i253
  %offset_ptr.i.i259 = getelementptr i32, ptr %offset_tbl.i.i254, i64 %hash.i.i.i258
  %offset.i.i260 = load i32, ptr %offset_ptr.i.i259, align 4
  store ptr %vptr.i248.sroa.speculated, ptr %28, align 8
  store ptr %.sroa.speculated352, ptr %29, align 8
  store ptr %.sroa.speculated346, ptr %30, align 8
  store i32 %offset.i.i260, ptr %31, align 8
  %223 = add nuw nsw i32 %.reg2mem193.0677, 1
  %224 = load ptr, ptr %36, align 8
  %225 = load ptr, ptr %224, align 8
  %226 = call i32 %225(ptr %.fca.1.extract16)
  %227 = icmp slt i32 %223, %226
  br i1 %227, label %56, label %._crit_edge

228:                                              ; preds = %148, %85
  %229 = phi ptr [ %24, %148 ], [ %12, %85 ]
  %230 = phi ptr [ %25, %148 ], [ %13, %85 ]
  %231 = phi ptr [ %26, %148 ], [ %14, %85 ]
  %.sroa.phi = phi ptr [ %.sroa.1, %148 ], [ %.sroa.1681, %85 ]
  %232 = phi ptr [ %.sroa.0, %148 ], [ %.sroa.0680, %85 ]
  %233 = phi ptr [ %27, %148 ], [ %15, %85 ]
  %234 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %235 = getelementptr i8, ptr %35, i64 40
  %236 = load ptr, ptr %235, align 8
  %237 = load ptr, ptr %236, align 8
  %238 = call i32 %237(ptr %.fca.1.extract16)
  store i32 %238, ptr %229, align 4
  store i32 1, ptr %230, align 4
  %239 = add i32 %238, 1
  store i32 %239, ptr %231, align 4
  %240 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract14)
  %241 = load ptr, ptr %235, align 8
  %242 = getelementptr i8, ptr %241, i64 8
  %243 = load ptr, ptr %242, align 8
  call void %243(ptr %.fca.1.extract16, i32 %239)
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %233, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %232, align 8
  %244 = load i160, ptr %.sroa.phi, align 8
  br label %247

._crit_edge:                                      ; preds = %.cont.cont, %4
  %245 = load ptr, ptr %28, align 8
  %246 = load i160, ptr %29, align 8
  br label %247

247:                                              ; preds = %._crit_edge, %228
  %.reg2mem135.sroa.3.0 = phi i160 [ %244, %228 ], [ %246, %._crit_edge ]
  %.reg2mem135.sroa.0.0 = phi ptr [ @nil_typ, %228 ], [ %245, %._crit_edge ]
  %.reload136.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem135.sroa.0.0, 0
  %.reload136.fca.1.insert = insertvalue { ptr, i160 } %.reload136.fca.0.insert, i160 %.reg2mem135.sroa.3.0, 1
  ret { ptr, i160 } %.reload136.fca.1.insert
}

define void @HashMap_resize_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %13 = alloca [2 x ptr], align 8
  %14 = alloca { ptr, ptr }, align 8
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  %16 = alloca { ptr, ptr, ptr, i32 }, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr }, align 8
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %21 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %22 = sext i32 %offset.i.i to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract28, i64 %22
  %24 = getelementptr i8, ptr %23, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = tail call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract30)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %hash_coef_ptr.i.i64 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i65 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i66 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i67 = load i64, ptr %hash_coef_ptr.i.i64, align 4
  %tbl_size.i.i68 = load i64, ptr %tbl_size_ptr.i.i65, align 4
  %offset_tbl.i.i69 = load ptr, ptr %offset_tbl_ptr.i.i66, align 8
  %product.i.i.i70 = mul i64 %hash_coef.i.i67, -5261542750394134544
  %shifted.i.i.i71 = lshr i64 %product.i.i.i70, 32
  %xored.i.i.i72 = xor i64 %shifted.i.i.i71, %product.i.i.i70
  %hash.i.i.i73 = and i64 %xored.i.i.i72, %tbl_size.i.i68
  %offset_ptr.i.i74 = getelementptr i32, ptr %offset_tbl.i.i69, i64 %hash.i.i.i73
  %offset.i.i75 = load i32, ptr %offset_ptr.i.i74, align 4
  %eq.i = icmp eq i32 %.fca.3.extract7, %offset.i.i75
  tail call void @llvm.assume(i1 %eq.i) #30
  %28 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract1, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %28, i64 8
  store ptr %.fca.1.extract3, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %28, i64 16
  store ptr %.fca.2.extract5, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %28, i64 24
  store i32 %.fca.3.extract7, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %28)
  %33 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %34 = getelementptr i8, ptr %23, i64 32
  %35 = load ptr, ptr %34, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = tail call { ptr, ptr, ptr, i32 } %36(ptr %.fca.1.extract30)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %37, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %37, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %37, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %37, 3
  %hash_coef_ptr.i.i92 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i93 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i94 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i95 = load i64, ptr %hash_coef_ptr.i.i92, align 4
  %tbl_size.i.i96 = load i64, ptr %tbl_size_ptr.i.i93, align 4
  %offset_tbl.i.i97 = load ptr, ptr %offset_tbl_ptr.i.i94, align 8
  %product.i.i.i98 = mul i64 %hash_coef.i.i95, -5261542750394134544
  %shifted.i.i.i99 = lshr i64 %product.i.i.i98, 32
  %xored.i.i.i100 = xor i64 %shifted.i.i.i99, %product.i.i.i98
  %hash.i.i.i101 = and i64 %xored.i.i.i100, %tbl_size.i.i96
  %offset_ptr.i.i102 = getelementptr i32, ptr %offset_tbl.i.i97, i64 %hash.i.i.i101
  %offset.i.i103 = load i32, ptr %offset_ptr.i.i102, align 4
  %eq.i106 = icmp eq i32 %.fca.3.extract, %offset.i.i103
  tail call void @llvm.assume(i1 %eq.i106) #30
  %38 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr %.fca.1.extract, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %38, i64 16
  store ptr %.fca.2.extract, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %38, i64 24
  store i32 %.fca.3.extract, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %38)
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract3, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract5, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.fca.3.extract7, 3
  %47 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %48 = load ptr, ptr %23, align 8
  %49 = tail call ptr %48(ptr %.fca.1.extract30)
  %50 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %51 = getelementptr i8, ptr %23, i64 8
  %52 = load ptr, ptr %51, align 8
  %53 = tail call ptr %52(ptr %.fca.1.extract30)
  %54 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %55 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract1)
  %56 = sext i32 %.fca.3.extract7 to i64
  %57 = getelementptr ptr, ptr %.fca.0.extract1, i64 %56
  %58 = getelementptr i8, ptr %57, i64 64
  %59 = load ptr, ptr %58, align 8
  %60 = call ptr %59({ ptr, ptr, ptr, i32 } %46, ptr nonnull %4)
  %61 = call i32 %60({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull %4)
  %62 = shl i32 %61, 1
  %63 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %64 = getelementptr i8, ptr %23, i64 40
  %65 = load ptr, ptr %64, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call i32 %66(ptr %.fca.1.extract30)
  %68 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %69 = load ptr, ptr %23, align 8
  %70 = call ptr %69(ptr %.fca.1.extract30)
  %71 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %72 = load ptr, ptr %51, align 8
  %73 = call ptr %72(ptr %.fca.1.extract30)
  %result.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %74 = getelementptr i8, ptr %result.i, i64 16
  store ptr %73, ptr %74, align 8
  %75 = getelementptr i8, ptr %result.i, i64 8
  store ptr %70, ptr %75, align 8
  %76 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %76, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @Entry, ptr %result.i, align 8
  %result.i121 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i, ptr %result.i121, align 8
  %78 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i121)
  %79 = getelementptr inbounds i8, ptr %5, i64 8
  %80 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @Array, ptr %5, align 8
  store ptr %result.i121, ptr %79, align 8
  store i32 9, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %5)
  %82 = getelementptr inbounds i8, ptr %5, i64 16
  %83 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %84 = load ptr, ptr %23, align 8
  %85 = call ptr %84(ptr %.fca.1.extract30)
  %86 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract28)
  %87 = load ptr, ptr %51, align 8
  %88 = call ptr %87(ptr %.fca.1.extract30)
  %89 = getelementptr i8, ptr %result.i121, i64 16
  store i32 %67, ptr %89, align 4
  %90 = getelementptr i8, ptr %result.i121, i64 20
  store i32 %67, ptr %90, align 4
  %91 = sext i32 %67 to i64
  %92 = shl nsw i64 %91, 5
  %result.i.i = call noalias ptr @bump_malloc_inner(i64 noundef %92, ptr nonnull @current_ptr) #29
  %93 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %94 = getelementptr i8, ptr %result.i121, i64 8
  store ptr %result.i.i, ptr %94, align 8
  %95 = load ptr, ptr %5, align 8
  %96 = load ptr, ptr %79, align 8
  %97 = load ptr, ptr %82, align 8
  %hash_coef_ptr.i.i123 = getelementptr i8, ptr %95, i64 8
  %tbl_size_ptr.i.i124 = getelementptr i8, ptr %95, i64 16
  %offset_tbl_ptr.i.i125 = getelementptr i8, ptr %95, i64 40
  %hash_coef.i.i126 = load i64, ptr %hash_coef_ptr.i.i123, align 4
  %tbl_size.i.i127 = load i64, ptr %tbl_size_ptr.i.i124, align 4
  %offset_tbl.i.i128 = load ptr, ptr %offset_tbl_ptr.i.i125, align 8
  %product.i.i.i129 = mul i64 %hash_coef.i.i126, -5261542750394134544
  %shifted.i.i.i130 = lshr i64 %product.i.i.i129, 32
  %xored.i.i.i131 = xor i64 %shifted.i.i.i130, %product.i.i.i129
  %hash.i.i.i132 = and i64 %xored.i.i.i131, %tbl_size.i.i127
  %offset_ptr.i.i133 = getelementptr i32, ptr %offset_tbl.i.i128, i64 %hash.i.i.i132
  %offset.i.i134 = load i32, ptr %offset_ptr.i.i133, align 4
  store ptr %95, ptr %6, align 8
  %98 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr %96, ptr %98, align 8
  %99 = getelementptr inbounds i8, ptr %6, i64 16
  store ptr %97, ptr %99, align 8
  %100 = getelementptr inbounds i8, ptr %6, i64 24
  store i32 %offset.i.i134, ptr %100, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %6)
  %102 = load ptr, ptr %28, align 8
  %103 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %102, 0
  %invariant.gep = getelementptr i8, ptr %102, i64 120
  %104 = getelementptr inbounds i8, ptr %9, i64 8
  %105 = getelementptr inbounds i8, ptr %10, i64 8
  %106 = icmp sgt i32 %61, 0
  br i1 %106, label %.lr.ph434, label %._crit_edge395

.lr.ph434:                                        ; preds = %3
  %107 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  br label %108

108:                                              ; preds = %.lr.ph434, %182
  %.reg2mem105.0432 = phi i32 [ 0, %.lr.ph434 ], [ %.reg2mem101.0, %182 ]
  %.reg2mem103.0431 = phi i32 [ 0, %.lr.ph434 ], [ %183, %182 ]
  %109 = load ptr, ptr %29, align 8
  %110 = insertvalue { ptr, ptr, ptr, i32 } %103, ptr %109, 1
  %111 = load ptr, ptr %30, align 8
  %112 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %111, 2
  %113 = load i32, ptr %31, align 8
  %114 = insertvalue { ptr, ptr, ptr, i32 } %112, i32 %113, 3
  %115 = load ptr, ptr %23, align 8
  %116 = call ptr %115(ptr %.fca.1.extract30)
  %117 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %118 = load ptr, ptr %51, align 8
  %119 = call ptr %118(ptr %.fca.1.extract30)
  store ptr @_parameterization_Ptri32, ptr %7, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %7)
  %121 = call ptr @llvm.invariant.start.p0(i64 600, ptr %102)
  %122 = sext i32 %113 to i64
  %gep = getelementptr ptr, ptr %invariant.gep, i64 %122
  %123 = load ptr, ptr %gep, align 8
  store ptr @i32_typ, ptr %8, align 8
  %124 = call ptr %123({ ptr, ptr, ptr, i32 } %114, ptr nonnull %8)
  %125 = call { ptr, i160 } %124({ ptr, ptr, ptr, i32 } %114, { ptr, ptr, ptr, i32 } %114, ptr nonnull %7, i32 %.reg2mem103.0431)
  %.fca.0.extract52 = extractvalue { ptr, i160 } %125, 0
  %126 = icmp ne ptr %.fca.0.extract52, @nil_typ
  %127 = icmp ne ptr %.fca.0.extract52, null
  %.not60 = and i1 %126, %127
  br i1 %.not60, label %128, label %182

128:                                              ; preds = %108
  %hash_coef_ptr.i.i137 = getelementptr i8, ptr %.fca.0.extract52, i64 8
  %tbl_size_ptr.i.i138 = getelementptr i8, ptr %.fca.0.extract52, i64 16
  %offset_tbl_ptr.i.i139 = getelementptr i8, ptr %.fca.0.extract52, i64 40
  %hash_coef.i.i140 = load i64, ptr %hash_coef_ptr.i.i137, align 4
  %tbl_size.i.i141 = load i64, ptr %tbl_size_ptr.i.i138, align 4
  %offset_tbl.i.i142 = load ptr, ptr %offset_tbl_ptr.i.i139, align 8
  %product.i.i.i143 = mul i64 %hash_coef.i.i140, 4015701072841558310
  %shifted.i.i.i144 = lshr i64 %product.i.i.i143, 32
  %xored.i.i.i145 = xor i64 %shifted.i.i.i144, %product.i.i.i143
  %hash.i.i.i146 = and i64 %xored.i.i.i145, %tbl_size.i.i141
  %offset_ptr.i.i147 = getelementptr i32, ptr %offset_tbl.i.i142, i64 %hash.i.i.i146
  %offset.i.i148 = load i32, ptr %offset_ptr.i.i147, align 4
  %129 = load ptr, ptr %6, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %129, 0
  %131 = load ptr, ptr %98, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 1
  %133 = load ptr, ptr %99, align 8
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr %133, 2
  %135 = load i32, ptr %100, align 8
  %136 = insertvalue { ptr, ptr, ptr, i32 } %134, i32 %135, 3
  %137 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %138 = load ptr, ptr %23, align 8
  %139 = call ptr %138(ptr %.fca.1.extract30)
  %140 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %141 = load ptr, ptr %51, align 8
  %142 = call ptr %141(ptr %.fca.1.extract30)
  %143 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %144 = call ptr @llvm.invariant.start.p0(i64 600, ptr %129)
  %145 = sext i32 %135 to i64
  %146 = getelementptr ptr, ptr %129, i64 %145
  %147 = getelementptr i8, ptr %146, i64 64
  %148 = load ptr, ptr %147, align 8
  %149 = call ptr %148({ ptr, ptr, ptr, i32 } %136, ptr nonnull %4)
  %150 = call i32 %149({ ptr, ptr, ptr, i32 } %136, { ptr, ptr, ptr, i32 } %136, ptr nonnull %4)
  %151 = icmp slt i32 %.reg2mem105.0432, %150
  br i1 %151, label %152, label %._crit_edge

152:                                              ; preds = %128
  %.fca.1.extract54 = extractvalue { ptr, i160 } %125, 1
  %153 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract52, 0
  %.sroa.351.0.insert.ext = zext i32 %offset.i.i148 to i160
  %.sroa.351.0.insert.shift = shl nuw i160 %.sroa.351.0.insert.ext, 128
  %154 = and i160 %.fca.1.extract54, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert = or disjoint i160 %.sroa.351.0.insert.shift, %154
  %155 = insertvalue { ptr, i160 } %153, i160 %.sroa.049.0.insert.insert, 1
  %156 = load ptr, ptr %6, align 8
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %156, 0
  %158 = load ptr, ptr %98, align 8
  %159 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %158, 1
  %160 = load ptr, ptr %99, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %160, 2
  %162 = load i32, ptr %100, align 8
  %163 = insertvalue { ptr, ptr, ptr, i32 } %161, i32 %162, 3
  %164 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %165 = load ptr, ptr %23, align 8
  %166 = call ptr %165(ptr %.fca.1.extract30)
  %167 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %168 = load ptr, ptr %51, align 8
  %169 = call ptr %168(ptr %.fca.1.extract30)
  %result.i150 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %170 = getelementptr i8, ptr %result.i150, i64 16
  store ptr %169, ptr %170, align 8
  %171 = getelementptr i8, ptr %result.i150, i64 8
  store ptr %166, ptr %171, align 8
  %172 = getelementptr i8, ptr %result.i150, i64 24
  store ptr null, ptr %172, align 8
  %173 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i150)
  store ptr @Entry, ptr %result.i150, align 8
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  store ptr %result.i150, ptr %104, align 8
  %174 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %9)
  %175 = call ptr @llvm.invariant.start.p0(i64 600, ptr %156)
  %176 = sext i32 %162 to i64
  %177 = getelementptr ptr, ptr %156, i64 %176
  %178 = getelementptr i8, ptr %177, i64 128
  %179 = load ptr, ptr %178, align 8
  store ptr @i32_typ, ptr %10, align 8
  store ptr %.fca.0.extract52, ptr %105, align 8
  %180 = call ptr %179({ ptr, ptr, ptr, i32 } %163, ptr nonnull %10)
  call void %180({ ptr, ptr, ptr, i32 } %163, { ptr, ptr, ptr, i32 } %163, ptr nonnull %9, i32 %.reg2mem105.0432, { ptr, i160 } %155)
  br label %._crit_edge

._crit_edge:                                      ; preds = %128, %152
  %181 = add i32 %.reg2mem105.0432, 1
  br label %182

182:                                              ; preds = %._crit_edge, %108
  %.reg2mem101.0 = phi i32 [ %181, %._crit_edge ], [ %.reg2mem105.0432, %108 ]
  %183 = add nuw nsw i32 %.reg2mem103.0431, 1
  %184 = icmp slt i32 %183, %61
  br i1 %184, label %108, label %.lr.ph

.lr.ph:                                           ; preds = %182
  %185 = load ptr, ptr %38, align 8
  %186 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %185, 0
  %187 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %invariant.gep396 = getelementptr i8, ptr %185, i64 120
  %188 = getelementptr inbounds i8, ptr %13, i64 8
  %189 = getelementptr inbounds i8, ptr %14, i64 8
  br label %190

190:                                              ; preds = %.lr.ph, %264
  %.reg2mem91.0394 = phi i32 [ %.reg2mem101.0, %.lr.ph ], [ %.reg2mem87.0, %264 ]
  %.reg2mem89.0393 = phi i32 [ 0, %.lr.ph ], [ %265, %264 ]
  %191 = load ptr, ptr %39, align 8
  %192 = insertvalue { ptr, ptr, ptr, i32 } %186, ptr %191, 1
  %193 = load ptr, ptr %40, align 8
  %194 = insertvalue { ptr, ptr, ptr, i32 } %192, ptr %193, 2
  %195 = load i32, ptr %41, align 8
  %196 = insertvalue { ptr, ptr, ptr, i32 } %194, i32 %195, 3
  %197 = load ptr, ptr %23, align 8
  %198 = call ptr %197(ptr %.fca.1.extract30)
  %199 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %200 = load ptr, ptr %51, align 8
  %201 = call ptr %200(ptr %.fca.1.extract30)
  store ptr @_parameterization_Ptri32, ptr %11, align 8
  %202 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %11)
  %203 = call ptr @llvm.invariant.start.p0(i64 600, ptr %185)
  %204 = sext i32 %195 to i64
  %gep397 = getelementptr ptr, ptr %invariant.gep396, i64 %204
  %205 = load ptr, ptr %gep397, align 8
  store ptr @i32_typ, ptr %12, align 8
  %206 = call ptr %205({ ptr, ptr, ptr, i32 } %196, ptr nonnull %12)
  %207 = call { ptr, i160 } %206({ ptr, ptr, ptr, i32 } %196, { ptr, ptr, ptr, i32 } %196, ptr nonnull %11, i32 %.reg2mem89.0393)
  %.fca.0.extract42 = extractvalue { ptr, i160 } %207, 0
  %208 = icmp ne ptr %.fca.0.extract42, @nil_typ
  %209 = icmp ne ptr %.fca.0.extract42, null
  %.not62 = and i1 %208, %209
  br i1 %.not62, label %210, label %264

210:                                              ; preds = %190
  %hash_coef_ptr.i.i152 = getelementptr i8, ptr %.fca.0.extract42, i64 8
  %tbl_size_ptr.i.i153 = getelementptr i8, ptr %.fca.0.extract42, i64 16
  %offset_tbl_ptr.i.i154 = getelementptr i8, ptr %.fca.0.extract42, i64 40
  %hash_coef.i.i155 = load i64, ptr %hash_coef_ptr.i.i152, align 4
  %tbl_size.i.i156 = load i64, ptr %tbl_size_ptr.i.i153, align 4
  %offset_tbl.i.i157 = load ptr, ptr %offset_tbl_ptr.i.i154, align 8
  %product.i.i.i158 = mul i64 %hash_coef.i.i155, 4015701072841558310
  %shifted.i.i.i159 = lshr i64 %product.i.i.i158, 32
  %xored.i.i.i160 = xor i64 %shifted.i.i.i159, %product.i.i.i158
  %hash.i.i.i161 = and i64 %xored.i.i.i160, %tbl_size.i.i156
  %offset_ptr.i.i162 = getelementptr i32, ptr %offset_tbl.i.i157, i64 %hash.i.i.i161
  %offset.i.i163 = load i32, ptr %offset_ptr.i.i162, align 4
  %211 = load ptr, ptr %6, align 8
  %212 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %211, 0
  %213 = load ptr, ptr %98, align 8
  %214 = insertvalue { ptr, ptr, ptr, i32 } %212, ptr %213, 1
  %215 = load ptr, ptr %99, align 8
  %216 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %215, 2
  %217 = load i32, ptr %100, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } %216, i32 %217, 3
  %219 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %220 = load ptr, ptr %23, align 8
  %221 = call ptr %220(ptr %.fca.1.extract30)
  %222 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %223 = load ptr, ptr %51, align 8
  %224 = call ptr %223(ptr %.fca.1.extract30)
  %225 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %226 = call ptr @llvm.invariant.start.p0(i64 600, ptr %211)
  %227 = sext i32 %217 to i64
  %228 = getelementptr ptr, ptr %211, i64 %227
  %229 = getelementptr i8, ptr %228, i64 64
  %230 = load ptr, ptr %229, align 8
  %231 = call ptr %230({ ptr, ptr, ptr, i32 } %218, ptr nonnull %4)
  %232 = call i32 %231({ ptr, ptr, ptr, i32 } %218, { ptr, ptr, ptr, i32 } %218, ptr nonnull %4)
  %233 = icmp slt i32 %.reg2mem91.0394, %232
  br i1 %233, label %234, label %._crit_edge1

234:                                              ; preds = %210
  %.fca.1.extract44 = extractvalue { ptr, i160 } %207, 1
  %235 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract42, 0
  %.sroa.3.0.insert.ext = zext i32 %offset.i.i163 to i160
  %.sroa.3.0.insert.shift = shl nuw i160 %.sroa.3.0.insert.ext, 128
  %236 = and i160 %.fca.1.extract44, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert = or disjoint i160 %.sroa.3.0.insert.shift, %236
  %237 = insertvalue { ptr, i160 } %235, i160 %.sroa.040.0.insert.insert, 1
  %238 = load ptr, ptr %6, align 8
  %239 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %238, 0
  %240 = load ptr, ptr %98, align 8
  %241 = insertvalue { ptr, ptr, ptr, i32 } %239, ptr %240, 1
  %242 = load ptr, ptr %99, align 8
  %243 = insertvalue { ptr, ptr, ptr, i32 } %241, ptr %242, 2
  %244 = load i32, ptr %100, align 8
  %245 = insertvalue { ptr, ptr, ptr, i32 } %243, i32 %244, 3
  %246 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %247 = load ptr, ptr %23, align 8
  %248 = call ptr %247(ptr %.fca.1.extract30)
  %249 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %250 = load ptr, ptr %51, align 8
  %251 = call ptr %250(ptr %.fca.1.extract30)
  %result.i165 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %252 = getelementptr i8, ptr %result.i165, i64 16
  store ptr %251, ptr %252, align 8
  %253 = getelementptr i8, ptr %result.i165, i64 8
  store ptr %248, ptr %253, align 8
  %254 = getelementptr i8, ptr %result.i165, i64 24
  store ptr null, ptr %254, align 8
  %255 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i165)
  store ptr @Entry, ptr %result.i165, align 8
  store ptr @_parameterization_Ptri32, ptr %13, align 8
  store ptr %result.i165, ptr %188, align 8
  %256 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %13)
  %257 = call ptr @llvm.invariant.start.p0(i64 600, ptr %238)
  %258 = sext i32 %244 to i64
  %259 = getelementptr ptr, ptr %238, i64 %258
  %260 = getelementptr i8, ptr %259, i64 128
  %261 = load ptr, ptr %260, align 8
  store ptr @i32_typ, ptr %14, align 8
  store ptr %.fca.0.extract42, ptr %189, align 8
  %262 = call ptr %261({ ptr, ptr, ptr, i32 } %245, ptr nonnull %14)
  call void %262({ ptr, ptr, ptr, i32 } %245, { ptr, ptr, ptr, i32 } %245, ptr nonnull %13, i32 %.reg2mem91.0394, { ptr, i160 } %237)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %210, %234
  %263 = add i32 %.reg2mem91.0394, 1
  br label %264

264:                                              ; preds = %._crit_edge1, %190
  %.reg2mem87.0 = phi i32 [ %263, %._crit_edge1 ], [ %.reg2mem91.0394, %190 ]
  %265 = add nuw nsw i32 %.reg2mem89.0393, 1
  %266 = icmp slt i32 %265, %61
  br i1 %266, label %190, label %._crit_edge395

._crit_edge395:                                   ; preds = %264, %3
  %.reg2mem91.0.lcssa = phi i32 [ 0, %3 ], [ %.reg2mem87.0, %264 ]
  %267 = call i32 @llvm.smax.i32(i32 %62, i32 16)
  %268 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %269 = load ptr, ptr %23, align 8
  %270 = call ptr %269(ptr %.fca.1.extract30)
  %271 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %272 = load ptr, ptr %51, align 8
  %273 = call ptr %272(ptr %.fca.1.extract30)
  %result.i166 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %274 = getelementptr i8, ptr %result.i166, i64 16
  store ptr @_parameterization_Nil, ptr %274, align 8
  %result.i167 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %275 = getelementptr i8, ptr %result.i167, i64 16
  store ptr %273, ptr %275, align 8
  %276 = getelementptr i8, ptr %result.i167, i64 8
  store ptr %270, ptr %276, align 8
  %277 = getelementptr i8, ptr %result.i167, i64 24
  store ptr null, ptr %277, align 8
  %278 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167)
  store ptr @Entry, ptr %result.i167, align 8
  %279 = getelementptr i8, ptr %result.i166, i64 8
  store ptr %result.i167, ptr %279, align 8
  %280 = getelementptr i8, ptr %result.i166, i64 24
  store ptr null, ptr %280, align 8
  %281 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166)
  store ptr @union_typ, ptr %result.i166, align 8
  %result.i168 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166, ptr %result.i168, align 8
  %282 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168)
  %283 = getelementptr inbounds i8, ptr %15, i64 8
  %284 = getelementptr inbounds i8, ptr %15, i64 24
  store ptr @Array, ptr %15, align 8
  store ptr %result.i168, ptr %283, align 8
  store i32 9, ptr %284, align 8
  %285 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %15)
  %286 = getelementptr inbounds i8, ptr %15, i64 16
  %287 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %288 = load ptr, ptr %23, align 8
  %289 = call ptr %288(ptr %.fca.1.extract30)
  %290 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %291 = load ptr, ptr %51, align 8
  %292 = call ptr %291(ptr %.fca.1.extract30)
  %293 = getelementptr i8, ptr %result.i168, i64 16
  store i32 %267, ptr %293, align 4
  %294 = getelementptr i8, ptr %result.i168, i64 20
  store i32 %267, ptr %294, align 4
  %295 = zext nneg i32 %267 to i64
  %296 = shl nuw nsw i64 %295, 5
  %result.i.i416 = call noalias ptr @bump_malloc_inner(i64 noundef %296, ptr nonnull @current_ptr) #29
  %297 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %298 = getelementptr i8, ptr %result.i168, i64 8
  store ptr %result.i.i416, ptr %298, align 8
  %299 = load ptr, ptr %15, align 8
  %300 = load ptr, ptr %283, align 8
  %301 = load ptr, ptr %286, align 8
  %hash_coef_ptr.i.i170 = getelementptr i8, ptr %299, i64 8
  %tbl_size_ptr.i.i171 = getelementptr i8, ptr %299, i64 16
  %offset_tbl_ptr.i.i172 = getelementptr i8, ptr %299, i64 40
  %hash_coef.i.i173 = load i64, ptr %hash_coef_ptr.i.i170, align 4
  %tbl_size.i.i174 = load i64, ptr %tbl_size_ptr.i.i171, align 4
  %offset_tbl.i.i175 = load ptr, ptr %offset_tbl_ptr.i.i172, align 8
  %product.i.i.i176 = mul i64 %hash_coef.i.i173, -5261542750394134544
  %shifted.i.i.i177 = lshr i64 %product.i.i.i176, 32
  %xored.i.i.i178 = xor i64 %shifted.i.i.i177, %product.i.i.i176
  %hash.i.i.i179 = and i64 %xored.i.i.i178, %tbl_size.i.i174
  %offset_ptr.i.i180 = getelementptr i32, ptr %offset_tbl.i.i175, i64 %hash.i.i.i179
  %offset.i.i181 = load i32, ptr %offset_ptr.i.i180, align 4
  %302 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %303 = load ptr, ptr %24, align 8
  %304 = getelementptr i8, ptr %303, i64 8
  %305 = load ptr, ptr %304, align 8
  %306 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %299, 0
  %307 = insertvalue { ptr, ptr, ptr, i32 } %306, ptr %300, 1
  %308 = insertvalue { ptr, ptr, ptr, i32 } %307, ptr %301, 2
  %309 = insertvalue { ptr, ptr, ptr, i32 } %308, i32 %offset.i.i181, 3
  call void %305(ptr %.fca.1.extract30, { ptr, ptr, ptr, i32 } %309)
  %310 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %311 = load ptr, ptr %23, align 8
  %312 = call ptr %311(ptr %.fca.1.extract30)
  %313 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %314 = load ptr, ptr %51, align 8
  %315 = call ptr %314(ptr %.fca.1.extract30)
  %result.i183 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %316 = getelementptr i8, ptr %result.i183, i64 16
  store ptr @_parameterization_Nil, ptr %316, align 8
  %result.i184 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %317 = getelementptr i8, ptr %result.i184, i64 16
  store ptr %315, ptr %317, align 8
  %318 = getelementptr i8, ptr %result.i184, i64 8
  store ptr %312, ptr %318, align 8
  %319 = getelementptr i8, ptr %result.i184, i64 24
  store ptr null, ptr %319, align 8
  %320 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184)
  store ptr @Entry, ptr %result.i184, align 8
  %321 = getelementptr i8, ptr %result.i183, i64 8
  store ptr %result.i184, ptr %321, align 8
  %322 = getelementptr i8, ptr %result.i183, i64 24
  store ptr null, ptr %322, align 8
  %323 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183)
  store ptr @union_typ, ptr %result.i183, align 8
  %result.i185 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183, ptr %result.i185, align 8
  %324 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185)
  %325 = getelementptr inbounds i8, ptr %16, i64 8
  %326 = getelementptr inbounds i8, ptr %16, i64 24
  store ptr @Array, ptr %16, align 8
  store ptr %result.i185, ptr %325, align 8
  store i32 9, ptr %326, align 8
  %327 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %16)
  %328 = getelementptr inbounds i8, ptr %16, i64 16
  %329 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %330 = load ptr, ptr %23, align 8
  %331 = call ptr %330(ptr %.fca.1.extract30)
  %332 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %333 = load ptr, ptr %51, align 8
  %334 = call ptr %333(ptr %.fca.1.extract30)
  %335 = getelementptr i8, ptr %result.i185, i64 16
  store i32 %267, ptr %335, align 4
  %336 = getelementptr i8, ptr %result.i185, i64 20
  store i32 %267, ptr %336, align 4
  %result.i.i430 = call noalias ptr @bump_malloc_inner(i64 noundef %296, ptr nonnull @current_ptr) #29
  %337 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %338 = getelementptr i8, ptr %result.i185, i64 8
  store ptr %result.i.i430, ptr %338, align 8
  %339 = load ptr, ptr %16, align 8
  %340 = load ptr, ptr %325, align 8
  %341 = load ptr, ptr %328, align 8
  %hash_coef_ptr.i.i187 = getelementptr i8, ptr %339, i64 8
  %tbl_size_ptr.i.i188 = getelementptr i8, ptr %339, i64 16
  %offset_tbl_ptr.i.i189 = getelementptr i8, ptr %339, i64 40
  %hash_coef.i.i190 = load i64, ptr %hash_coef_ptr.i.i187, align 4
  %tbl_size.i.i191 = load i64, ptr %tbl_size_ptr.i.i188, align 4
  %offset_tbl.i.i192 = load ptr, ptr %offset_tbl_ptr.i.i189, align 8
  %product.i.i.i193 = mul i64 %hash_coef.i.i190, -5261542750394134544
  %shifted.i.i.i194 = lshr i64 %product.i.i.i193, 32
  %xored.i.i.i195 = xor i64 %shifted.i.i.i194, %product.i.i.i193
  %hash.i.i.i196 = and i64 %xored.i.i.i195, %tbl_size.i.i191
  %offset_ptr.i.i197 = getelementptr i32, ptr %offset_tbl.i.i192, i64 %hash.i.i.i196
  %offset.i.i198 = load i32, ptr %offset_ptr.i.i197, align 4
  %342 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %343 = load ptr, ptr %34, align 8
  %344 = getelementptr i8, ptr %343, i64 8
  %345 = load ptr, ptr %344, align 8
  %346 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %339, 0
  %347 = insertvalue { ptr, ptr, ptr, i32 } %346, ptr %340, 1
  %348 = insertvalue { ptr, ptr, ptr, i32 } %347, ptr %341, 2
  %349 = insertvalue { ptr, ptr, ptr, i32 } %348, i32 %offset.i.i198, 3
  call void %345(ptr %.fca.1.extract30, { ptr, ptr, ptr, i32 } %349)
  %350 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %351 = load ptr, ptr %64, align 8
  %352 = getelementptr i8, ptr %351, i64 8
  %353 = load ptr, ptr %352, align 8
  call void %353(ptr %.fca.1.extract30, i32 0)
  %354 = icmp sgt i32 %.reg2mem91.0.lcssa, 0
  br i1 %354, label %.lr.ph400, label %._crit_edge2._crit_edge

.lr.ph400:                                        ; preds = %._crit_edge395
  %.fca.2.extract32437 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %355 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %356 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %357 = insertvalue { ptr, ptr, ptr, i32 } %356, ptr %.fca.1.extract30, 1
  %358 = insertvalue { ptr, ptr, ptr, i32 } %357, ptr %.fca.2.extract32437, 2
  %359 = insertvalue { ptr, ptr, ptr, i32 } %358, i32 %offset.i.i, 3
  %360 = getelementptr i8, ptr %23, i64 112
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %.lr.ph400, %._crit_edge2
  %.reg2mem77.0398 = phi i32 [ 0, %.lr.ph400 ], [ %403, %._crit_edge2 ]
  %361 = load ptr, ptr %6, align 8
  %362 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %361, 0
  %363 = load ptr, ptr %98, align 8
  %364 = insertvalue { ptr, ptr, ptr, i32 } %362, ptr %363, 1
  %365 = load ptr, ptr %99, align 8
  %366 = insertvalue { ptr, ptr, ptr, i32 } %364, ptr %365, 2
  %367 = load i32, ptr %100, align 8
  %368 = insertvalue { ptr, ptr, ptr, i32 } %366, i32 %367, 3
  %369 = load ptr, ptr %23, align 8
  %370 = call ptr %369(ptr %.fca.1.extract30)
  %371 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %372 = load ptr, ptr %51, align 8
  %373 = call ptr %372(ptr %.fca.1.extract30)
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %374 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %17)
  %375 = call ptr @llvm.invariant.start.p0(i64 600, ptr %361)
  %376 = sext i32 %367 to i64
  %377 = getelementptr ptr, ptr %361, i64 %376
  %378 = getelementptr i8, ptr %377, i64 120
  %379 = load ptr, ptr %378, align 8
  store ptr @i32_typ, ptr %18, align 8
  %380 = call ptr %379({ ptr, ptr, ptr, i32 } %368, ptr nonnull %18)
  %381 = call { ptr, i160 } %380({ ptr, ptr, ptr, i32 } %368, { ptr, ptr, ptr, i32 } %368, ptr nonnull %17, i32 %.reg2mem77.0398)
  %.fca.0.extract36 = extractvalue { ptr, i160 } %381, 0
  %.fca.1.extract38 = extractvalue { ptr, i160 } %381, 1
  %.sroa.3362.8.extract.trunc = trunc i160 %.fca.1.extract38 to i64
  %382 = inttoptr i64 %.sroa.3362.8.extract.trunc to ptr
  %.sroa.5363.8.extract.shift = lshr i160 %.fca.1.extract38, 64
  %.sroa.5363.8.extract.trunc = trunc i160 %.sroa.5363.8.extract.shift to i64
  %383 = inttoptr i64 %.sroa.5363.8.extract.trunc to ptr
  %hash_coef_ptr.i.i201 = getelementptr i8, ptr %.fca.0.extract36, i64 8
  %tbl_size_ptr.i.i202 = getelementptr i8, ptr %.fca.0.extract36, i64 16
  %offset_tbl_ptr.i.i203 = getelementptr i8, ptr %.fca.0.extract36, i64 40
  %hash_coef.i.i232 = load i64, ptr %hash_coef_ptr.i.i201, align 4
  %tbl_size.i.i233 = load i64, ptr %tbl_size_ptr.i.i202, align 4
  %offset_tbl.i.i234 = load ptr, ptr %offset_tbl_ptr.i.i203, align 8
  %product.i.i.i235 = mul i64 %hash_coef.i.i232, 4015701072841558310
  %shifted.i.i.i236 = lshr i64 %product.i.i.i235, 32
  %xored.i.i.i237 = xor i64 %shifted.i.i.i236, %product.i.i.i235
  %hash.i.i.i238 = and i64 %xored.i.i.i237, %tbl_size.i.i233
  %offset_ptr.i.i239 = getelementptr i32, ptr %offset_tbl.i.i234, i64 %hash.i.i.i238
  %offset.i.i240 = load i32, ptr %offset_ptr.i.i239, align 4
  %384 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract36, 0
  %385 = insertvalue { ptr, ptr, ptr, i32 } %384, ptr %382, 1
  %386 = insertvalue { ptr, ptr, ptr, i32 } %385, ptr %383, 2
  %387 = insertvalue { ptr, ptr, ptr, i32 } %386, i32 %offset.i.i240, 3
  %388 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %389 = load ptr, ptr %23, align 8
  %390 = call ptr %389(ptr %.fca.1.extract30)
  %391 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %392 = load ptr, ptr %51, align 8
  %393 = call ptr %392(ptr %.fca.1.extract30)
  %result.i242 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %394 = getelementptr i8, ptr %result.i242, i64 16
  store ptr %393, ptr %394, align 8
  %395 = getelementptr i8, ptr %result.i242, i64 8
  store ptr %390, ptr %395, align 8
  %396 = getelementptr i8, ptr %result.i242, i64 24
  store ptr null, ptr %396, align 8
  %397 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i242)
  store ptr @Entry, ptr %result.i242, align 8
  store ptr %result.i242, ptr %19, align 8
  %398 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %19)
  %399 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract28)
  %400 = load ptr, ptr %360, align 8
  store ptr %.fca.0.extract36, ptr %20, align 8
  %401 = call ptr %400({ ptr, ptr, ptr, i32 } %359, ptr nonnull %20)
  %402 = call { ptr, i160 } %401({ ptr, ptr, ptr, i32 } %359, { ptr, ptr, ptr, i32 } %359, ptr nonnull %19, { ptr, ptr, ptr, i32 } %387)
  %403 = add nuw nsw i32 %.reg2mem77.0398, 1
  %404 = icmp slt i32 %403, %.reg2mem91.0.lcssa
  br i1 %404, label %._crit_edge2, label %._crit_edge2._crit_edge

._crit_edge2._crit_edge:                          ; preds = %._crit_edge2, %._crit_edge395
  ret void
}

define void @HashMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) {
  %6 = alloca [0 x ptr], align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %14 = alloca [1 x ptr], align 8
  %15 = alloca { ptr }, align 8
  %16 = alloca { ptr, ptr, ptr, i32 }, align 8
  %17 = alloca [2 x ptr], align 8
  %18 = alloca { ptr, ptr }, align 8
  %19 = alloca { ptr, ptr, ptr, i32 }, align 8
  %20 = alloca [1 x ptr], align 8
  %21 = alloca { ptr }, align 8
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract43, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract43, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract43, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract28 = extractvalue { ptr, i160 } %3, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract45, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract47, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i, 3
  %26 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %27 = sext i32 %offset.i.i to i64
  %28 = getelementptr ptr, ptr %.fca.0.extract43, i64 %27
  %29 = load ptr, ptr %28, align 8
  %30 = tail call ptr %29(ptr %.fca.1.extract45)
  %31 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %32 = getelementptr i8, ptr %28, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call ptr %33(ptr %.fca.1.extract45)
  %35 = alloca [1 x ptr], align 8
  store ptr %30, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %35)
  %37 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %38 = getelementptr i8, ptr %28, i64 80
  %39 = load ptr, ptr %38, align 8
  %40 = alloca { ptr }, align 8
  store ptr %.fca.0.extract28, ptr %40, align 8
  %41 = call ptr %39({ ptr, ptr, ptr, i32 } %25, ptr nonnull %40)
  %42 = call i32 %41({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %35, { ptr, i160 } %3)
  %43 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %44 = load ptr, ptr %28, align 8
  %45 = call ptr %44(ptr %.fca.1.extract45)
  %46 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %47 = load ptr, ptr %32, align 8
  %48 = call ptr %47(ptr %.fca.1.extract45)
  %49 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %49)
  %51 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %52 = getelementptr i8, ptr %28, i64 96
  %53 = load ptr, ptr %52, align 8
  %54 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %54, align 8
  %55 = call ptr %53({ ptr, ptr, ptr, i32 } %25, ptr nonnull %54)
  %56 = call i32 %55({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %49, i32 %42)
  %57 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %58 = getelementptr i8, ptr %28, i64 24
  %59 = load ptr, ptr %58, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr, ptr, ptr, i32 } %60(ptr %.fca.1.extract45)
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %61, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %61, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %61, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %61, 3
  %hash_coef_ptr.i.i162 = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i163 = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i164 = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i165 = load i64, ptr %hash_coef_ptr.i.i162, align 4
  %tbl_size.i.i166 = load i64, ptr %tbl_size_ptr.i.i163, align 4
  %offset_tbl.i.i167 = load ptr, ptr %offset_tbl_ptr.i.i164, align 8
  %product.i.i.i168 = mul i64 %hash_coef.i.i165, -5261542750394134544
  %shifted.i.i.i169 = lshr i64 %product.i.i.i168, 32
  %xored.i.i.i170 = xor i64 %shifted.i.i.i169, %product.i.i.i168
  %hash.i.i.i171 = and i64 %xored.i.i.i170, %tbl_size.i.i166
  %offset_ptr.i.i172 = getelementptr i32, ptr %offset_tbl.i.i167, i64 %hash.i.i.i171
  %offset.i.i173 = load i32, ptr %offset_ptr.i.i172, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i173
  call void @llvm.assume(i1 %eq.i) #30
  %62 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.1.extract4, 1
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %.fca.2.extract, 2
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 %.fca.3.extract, 3
  %66 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %67 = load ptr, ptr %28, align 8
  %68 = call ptr %67(ptr %.fca.1.extract45)
  %69 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract43)
  %70 = load ptr, ptr %32, align 8
  %71 = call ptr %70(ptr %.fca.1.extract45)
  %72 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %72)
  %74 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract3)
  %75 = sext i32 %.fca.3.extract to i64
  %76 = getelementptr ptr, ptr %.fca.0.extract3, i64 %75
  %77 = getelementptr i8, ptr %76, i64 120
  %78 = load ptr, ptr %77, align 8
  %79 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %79, align 8
  %80 = call ptr %78({ ptr, ptr, ptr, i32 } %65, ptr nonnull %79)
  %81 = call { ptr, i160 } %80({ ptr, ptr, ptr, i32 } %65, { ptr, ptr, ptr, i32 } %65, ptr nonnull %72, i32 %56)
  %.fca.0.extract = extractvalue { ptr, i160 } %81, 0
  %82 = icmp ne ptr %.fca.0.extract, @nil_typ
  %83 = icmp ne ptr %.fca.0.extract, null
  %.not149 = and i1 %82, %83
  br i1 %.not149, label %84, label %.critedge

84:                                               ; preds = %5
  %.fca.1.extract = extractvalue { ptr, i160 } %81, 1
  %.sroa.4520.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %85 = inttoptr i64 %.sroa.4520.8.extract.trunc to ptr
  %.sroa.7522.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.7522.8.extract.trunc = trunc i160 %.sroa.7522.8.extract.shift to i64
  %86 = inttoptr i64 %.sroa.7522.8.extract.trunc to ptr
  %hash_coef_ptr.i.i176 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i177 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i178 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i179 = load i64, ptr %hash_coef_ptr.i.i176, align 4
  %tbl_size.i.i180 = load i64, ptr %tbl_size_ptr.i.i177, align 4
  %offset_tbl.i.i181 = load ptr, ptr %offset_tbl_ptr.i.i178, align 8
  %product.i.i.i182 = mul i64 %hash_coef.i.i179, 4015701072841558310
  %shifted.i.i.i183 = lshr i64 %product.i.i.i182, 32
  %xored.i.i.i184 = xor i64 %shifted.i.i.i183, %product.i.i.i182
  %hash.i.i.i185 = and i64 %xored.i.i.i184, %tbl_size.i.i180
  %offset_ptr.i.i186 = getelementptr i32, ptr %offset_tbl.i.i181, i64 %hash.i.i.i185
  %offset.i.i187 = load i32, ptr %offset_ptr.i.i186, align 4
  %87 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %88 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %85, 1
  %89 = insertvalue { ptr, ptr, ptr, i32 } %88, ptr %86, 2
  %90 = insertvalue { ptr, ptr, ptr, i32 } %89, i32 %offset.i.i187, 3
  %91 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %92 = load ptr, ptr %28, align 8
  %93 = call ptr %92(ptr %.fca.1.extract45)
  %94 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %95 = load ptr, ptr %32, align 8
  %96 = call ptr %95(ptr %.fca.1.extract45)
  %97 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %98 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract)
  %99 = sext i32 %offset.i.i187 to i64
  %100 = getelementptr ptr, ptr %.fca.0.extract, i64 %99
  %101 = getelementptr i8, ptr %100, i64 64
  %102 = load ptr, ptr %101, align 8
  %103 = call ptr %102({ ptr, ptr, ptr, i32 } %90, ptr nonnull %6)
  %104 = call i32 %103({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr nonnull %6)
  %105 = icmp eq i32 %104, %42
  %106 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %107 = load ptr, ptr %28, align 8
  %108 = call ptr %107(ptr %.fca.1.extract45)
  %109 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %110 = load ptr, ptr %32, align 8
  %111 = call ptr %110(ptr %.fca.1.extract45)
  %112 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %113 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract)
  %114 = getelementptr i8, ptr %100, i64 48
  %115 = load ptr, ptr %114, align 8
  %116 = call ptr %115({ ptr, ptr, ptr, i32 } %90, ptr nonnull %6)
  %117 = call { ptr, i160 } %116({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr nonnull %6)
  %118 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %119 = getelementptr i8, ptr %28, i64 56
  %120 = load ptr, ptr %119, align 8
  %121 = load ptr, ptr %120, align 8
  %122 = call { ptr } %121(ptr %.fca.1.extract45)
  %.fca.0.extract133 = extractvalue { ptr } %122, 0
  %123 = call i1 %.fca.0.extract133({ ptr, i160 } %117, { ptr, i160 } %3)
  %124 = and i1 %105, %123
  br i1 %124, label %125, label %.critedge

125:                                              ; preds = %84
  %126 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %127 = load ptr, ptr %28, align 8
  %128 = call ptr %127(ptr %.fca.1.extract45)
  %129 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %130 = load ptr, ptr %32, align 8
  %131 = call ptr %130(ptr %.fca.1.extract45)
  %132 = load ptr, ptr %128, align 8
  %133 = getelementptr i8, ptr %132, i64 48
  %134 = load ptr, ptr %133, align 8
  %135 = call { i64, i64 } %134(ptr nonnull %128)
  %136 = extractvalue { i64, i64 } %135, 0
  %137 = extractvalue { i64, i64 } %135, 1
  %138 = urem i64 20, %137
  %139 = icmp eq i64 %138, 0
  %140 = sub i64 %137, %138
  %141 = select i1 %139, i64 0, i64 %140
  %142 = add i64 %136, 20
  %143 = add i64 %142, %141
  %144 = load ptr, ptr %131, align 8
  %145 = getelementptr i8, ptr %144, i64 48
  %146 = load ptr, ptr %145, align 8
  %147 = call { i64, i64 } %146(ptr nonnull %131)
  %148 = extractvalue { i64, i64 } %147, 0
  %149 = extractvalue { i64, i64 } %147, 1
  %150 = call i64 @llvm.umax.i64(i64 %137, i64 %149)
  %151 = call i64 @llvm.umax.i64(i64 %150, i64 8)
  %152 = urem i64 %143, %149
  %153 = icmp eq i64 %152, 0
  %154 = sub i64 %149, %152
  %155 = select i1 %153, i64 0, i64 %154
  %156 = add i64 %148, %143
  %157 = add i64 %156, %155
  %158 = urem i64 %157, %151
  %159 = icmp eq i64 %158, 0
  %160 = sub i64 %151, %158
  %161 = select i1 %159, i64 0, i64 %160
  %162 = add i64 %161, %157
  %result.i = call noalias ptr @bump_malloc_inner(i64 noundef %162, ptr nonnull @current_ptr) #29
  store ptr %128, ptr %result.i, align 8
  %163 = getelementptr i8, ptr %result.i, i64 8
  store ptr %131, ptr %163, align 8
  %164 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i)
  %165 = getelementptr inbounds i8, ptr %7, i64 8
  %166 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr @Entry, ptr %7, align 8
  store ptr %result.i, ptr %165, align 8
  store i32 9, ptr %166, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %7)
  %168 = getelementptr inbounds i8, ptr %7, i64 16
  %169 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %170 = load ptr, ptr %28, align 8
  %171 = call ptr %170(ptr %.fca.1.extract45)
  %172 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %173 = load ptr, ptr %32, align 8
  %174 = call ptr %173(ptr %.fca.1.extract45)
  %175 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %176 = load ptr, ptr %result.i, align 8
  %177 = load ptr, ptr %176, align 8
  %178 = getelementptr i8, ptr %177, i64 48
  %179 = load ptr, ptr %178, align 8
  %180 = call { i64, i64 } %179(ptr nonnull %176)
  %181 = extractvalue { i64, i64 } %180, 1
  %182 = urem i64 20, %181
  %183 = icmp eq i64 %182, 0
  %reass.sub560 = sub i64 %181, %182
  %184 = add i64 %reass.sub560, 20
  %185 = select i1 %183, i64 20, i64 %184
  %186 = getelementptr i8, ptr %result.i, i64 %185
  %187 = load ptr, ptr %result.i, align 8
  %188 = load ptr, ptr %187, align 8
  %189 = getelementptr i8, ptr %188, i64 64
  %190 = load ptr, ptr %189, align 8
  call void %190({ ptr, i160 } %3, ptr nonnull %187, ptr %186)
  %191 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %192 = load ptr, ptr %result.i, align 8
  %193 = load ptr, ptr %192, align 8
  %194 = getelementptr i8, ptr %193, i64 48
  %195 = load ptr, ptr %194, align 8
  %196 = call { i64, i64 } %195(ptr nonnull %192)
  %197 = extractvalue { i64, i64 } %196, 0
  %198 = extractvalue { i64, i64 } %196, 1
  %199 = urem i64 20, %198
  %200 = icmp eq i64 %199, 0
  %201 = sub i64 %198, %199
  %202 = select i1 %200, i64 0, i64 %201
  %203 = add i64 %197, 20
  %204 = add i64 %203, %202
  %205 = load ptr, ptr %163, align 8
  %206 = load ptr, ptr %205, align 8
  %207 = getelementptr i8, ptr %206, i64 48
  %208 = load ptr, ptr %207, align 8
  %209 = call { i64, i64 } %208(ptr nonnull %205)
  %210 = extractvalue { i64, i64 } %209, 1
  %211 = urem i64 %204, %210
  %212 = icmp eq i64 %211, 0
  %213 = sub i64 %210, %211
  %214 = select i1 %212, i64 0, i64 %213
  %215 = getelementptr i8, ptr %result.i, i64 %204
  %216 = getelementptr i8, ptr %215, i64 %214
  %217 = load ptr, ptr %163, align 8
  %218 = load ptr, ptr %217, align 8
  %219 = getelementptr i8, ptr %218, i64 64
  %220 = load ptr, ptr %219, align 8
  call void %220({ ptr, i160 } %4, ptr nonnull %217, ptr %216)
  %221 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %222 = getelementptr i8, ptr %result.i, i64 16
  store i32 %42, ptr %222, align 4
  %223 = load ptr, ptr %7, align 8
  %224 = load ptr, ptr %165, align 8
  %225 = load ptr, ptr %168, align 8
  %hash_coef_ptr.i.i190 = getelementptr i8, ptr %223, i64 8
  %tbl_size_ptr.i.i191 = getelementptr i8, ptr %223, i64 16
  %offset_tbl_ptr.i.i192 = getelementptr i8, ptr %223, i64 40
  %hash_coef.i.i193 = load i64, ptr %hash_coef_ptr.i.i190, align 4
  %tbl_size.i.i194 = load i64, ptr %tbl_size_ptr.i.i191, align 4
  %offset_tbl.i.i195 = load ptr, ptr %offset_tbl_ptr.i.i192, align 8
  %product.i.i.i196 = mul i64 %hash_coef.i.i193, 4015701072841558310
  %shifted.i.i.i197 = lshr i64 %product.i.i.i196, 32
  %xored.i.i.i198 = xor i64 %shifted.i.i.i197, %product.i.i.i196
  %hash.i.i.i199 = and i64 %xored.i.i.i198, %tbl_size.i.i194
  %offset_ptr.i.i200 = getelementptr i32, ptr %offset_tbl.i.i195, i64 %hash.i.i.i199
  %offset.i.i201 = load i32, ptr %offset_ptr.i.i200, align 4
  %226 = insertvalue { ptr, i160 } undef, ptr %223, 0
  %227 = ptrtoint ptr %224 to i64
  %228 = ptrtoint ptr %225 to i64
  %.sroa.3128.0.insert.ext = zext i32 %offset.i.i201 to i160
  %.sroa.3128.0.insert.shift = shl nuw i160 %.sroa.3128.0.insert.ext, 128
  %.sroa.2127.0.insert.ext = zext i64 %228 to i160
  %.sroa.2127.0.insert.shift = shl nuw nsw i160 %.sroa.2127.0.insert.ext, 64
  %.sroa.2127.0.insert.insert = or disjoint i160 %.sroa.3128.0.insert.shift, %.sroa.2127.0.insert.shift
  %.sroa.0126.0.insert.ext = zext i64 %227 to i160
  %.sroa.0126.0.insert.insert = or disjoint i160 %.sroa.2127.0.insert.insert, %.sroa.0126.0.insert.ext
  %229 = insertvalue { ptr, i160 } %226, i160 %.sroa.0126.0.insert.insert, 1
  %230 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %231 = load ptr, ptr %58, align 8
  %232 = load ptr, ptr %231, align 8
  %233 = call { ptr, ptr, ptr, i32 } %232(ptr %.fca.1.extract45)
  %.fca.0.extract117 = extractvalue { ptr, ptr, ptr, i32 } %233, 0
  %.fca.1.extract119 = extractvalue { ptr, ptr, ptr, i32 } %233, 1
  %.fca.2.extract121 = extractvalue { ptr, ptr, ptr, i32 } %233, 2
  %.fca.3.extract123 = extractvalue { ptr, ptr, ptr, i32 } %233, 3
  %hash_coef_ptr.i.i204 = getelementptr i8, ptr %.fca.0.extract117, i64 8
  %tbl_size_ptr.i.i205 = getelementptr i8, ptr %.fca.0.extract117, i64 16
  %offset_tbl_ptr.i.i206 = getelementptr i8, ptr %.fca.0.extract117, i64 40
  %hash_coef.i.i207 = load i64, ptr %hash_coef_ptr.i.i204, align 4
  %tbl_size.i.i208 = load i64, ptr %tbl_size_ptr.i.i205, align 4
  %offset_tbl.i.i209 = load ptr, ptr %offset_tbl_ptr.i.i206, align 8
  %product.i.i.i210 = mul i64 %hash_coef.i.i207, -5261542750394134544
  %shifted.i.i.i211 = lshr i64 %product.i.i.i210, 32
  %xored.i.i.i212 = xor i64 %shifted.i.i.i211, %product.i.i.i210
  %hash.i.i.i213 = and i64 %xored.i.i.i212, %tbl_size.i.i208
  %offset_ptr.i.i214 = getelementptr i32, ptr %offset_tbl.i.i209, i64 %hash.i.i.i213
  %offset.i.i215 = load i32, ptr %offset_ptr.i.i214, align 4
  %eq.i218 = icmp eq i32 %.fca.3.extract123, %offset.i.i215
  call void @llvm.assume(i1 %eq.i218) #30
  %234 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract117, 0
  %235 = insertvalue { ptr, ptr, ptr, i32 } %234, ptr %.fca.1.extract119, 1
  %236 = insertvalue { ptr, ptr, ptr, i32 } %235, ptr %.fca.2.extract121, 2
  %237 = insertvalue { ptr, ptr, ptr, i32 } %236, i32 %.fca.3.extract123, 3
  %238 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %239 = load ptr, ptr %28, align 8
  %240 = call ptr %239(ptr %.fca.1.extract45)
  %241 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %242 = load ptr, ptr %32, align 8
  %243 = call ptr %242(ptr %.fca.1.extract45)
  %result.i219 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %244 = getelementptr i8, ptr %result.i219, i64 16
  store ptr %243, ptr %244, align 8
  %245 = getelementptr i8, ptr %result.i219, i64 8
  store ptr %240, ptr %245, align 8
  %246 = getelementptr i8, ptr %result.i219, i64 24
  store ptr null, ptr %246, align 8
  %247 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219)
  store ptr @Entry, ptr %result.i219, align 8
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %248 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %result.i219, ptr %248, align 8
  %249 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %8)
  %250 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract117)
  %251 = sext i32 %.fca.3.extract123 to i64
  %252 = getelementptr ptr, ptr %.fca.0.extract117, i64 %251
  %253 = getelementptr i8, ptr %252, i64 128
  %254 = load ptr, ptr %253, align 8
  store ptr @i32_typ, ptr %9, align 8
  %255 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %223, ptr %255, align 8
  %256 = call ptr %254({ ptr, ptr, ptr, i32 } %237, ptr nonnull %9)
  call void %256({ ptr, ptr, ptr, i32 } %237, { ptr, ptr, ptr, i32 } %237, ptr nonnull %8, i32 %56, { ptr, i160 } %229)
  br label %.thread

.critedge:                                        ; preds = %84, %5
  %257 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %258 = load ptr, ptr %28, align 8
  %259 = call ptr %258(ptr %.fca.1.extract45)
  %260 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %261 = load ptr, ptr %32, align 8
  %262 = call ptr %261(ptr %.fca.1.extract45)
  store ptr @_parameterization_Ptri32, ptr %10, align 8
  %263 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %10)
  %264 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %265 = getelementptr i8, ptr %28, i64 88
  %266 = load ptr, ptr %265, align 8
  store ptr @i32_typ, ptr %11, align 8
  %267 = call ptr %266({ ptr, ptr, ptr, i32 } %25, ptr nonnull %11)
  %268 = call i32 %267({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %10, i32 %42)
  %269 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %270 = load ptr, ptr %28, align 8
  %271 = call ptr %270(ptr %.fca.1.extract45)
  %272 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %273 = load ptr, ptr %32, align 8
  %274 = call ptr %273(ptr %.fca.1.extract45)
  store ptr @_parameterization_Ptri32, ptr %12, align 8
  %275 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %12)
  %276 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %277 = getelementptr i8, ptr %28, i64 104
  %278 = load ptr, ptr %277, align 8
  store ptr @i32_typ, ptr %13, align 8
  %279 = call ptr %278({ ptr, ptr, ptr, i32 } %25, ptr nonnull %13)
  %280 = call i32 %279({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %12, i32 %268)
  %281 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %282 = getelementptr i8, ptr %28, i64 32
  %283 = load ptr, ptr %282, align 8
  %284 = load ptr, ptr %283, align 8
  %285 = call { ptr, ptr, ptr, i32 } %284(ptr %.fca.1.extract45)
  %.fca.0.extract109 = extractvalue { ptr, ptr, ptr, i32 } %285, 0
  %.fca.1.extract111 = extractvalue { ptr, ptr, ptr, i32 } %285, 1
  %.fca.2.extract113 = extractvalue { ptr, ptr, ptr, i32 } %285, 2
  %.fca.3.extract115 = extractvalue { ptr, ptr, ptr, i32 } %285, 3
  %hash_coef_ptr.i.i221 = getelementptr i8, ptr %.fca.0.extract109, i64 8
  %tbl_size_ptr.i.i222 = getelementptr i8, ptr %.fca.0.extract109, i64 16
  %offset_tbl_ptr.i.i223 = getelementptr i8, ptr %.fca.0.extract109, i64 40
  %hash_coef.i.i224 = load i64, ptr %hash_coef_ptr.i.i221, align 4
  %tbl_size.i.i225 = load i64, ptr %tbl_size_ptr.i.i222, align 4
  %offset_tbl.i.i226 = load ptr, ptr %offset_tbl_ptr.i.i223, align 8
  %product.i.i.i227 = mul i64 %hash_coef.i.i224, -5261542750394134544
  %shifted.i.i.i228 = lshr i64 %product.i.i.i227, 32
  %xored.i.i.i229 = xor i64 %shifted.i.i.i228, %product.i.i.i227
  %hash.i.i.i230 = and i64 %xored.i.i.i229, %tbl_size.i.i225
  %offset_ptr.i.i231 = getelementptr i32, ptr %offset_tbl.i.i226, i64 %hash.i.i.i230
  %offset.i.i232 = load i32, ptr %offset_ptr.i.i231, align 4
  %eq.i235 = icmp eq i32 %.fca.3.extract115, %offset.i.i232
  call void @llvm.assume(i1 %eq.i235) #30
  %286 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract109, 0
  %287 = insertvalue { ptr, ptr, ptr, i32 } %286, ptr %.fca.1.extract111, 1
  %288 = insertvalue { ptr, ptr, ptr, i32 } %287, ptr %.fca.2.extract113, 2
  %289 = insertvalue { ptr, ptr, ptr, i32 } %288, i32 %.fca.3.extract115, 3
  %290 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %291 = load ptr, ptr %28, align 8
  %292 = call ptr %291(ptr %.fca.1.extract45)
  %293 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %294 = load ptr, ptr %32, align 8
  %295 = call ptr %294(ptr %.fca.1.extract45)
  store ptr @_parameterization_Ptri32, ptr %14, align 8
  %296 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %14)
  %297 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract109)
  %298 = sext i32 %.fca.3.extract115 to i64
  %299 = getelementptr ptr, ptr %.fca.0.extract109, i64 %298
  %300 = getelementptr i8, ptr %299, i64 120
  %301 = load ptr, ptr %300, align 8
  store ptr @i32_typ, ptr %15, align 8
  %302 = call ptr %301({ ptr, ptr, ptr, i32 } %289, ptr nonnull %15)
  %303 = call { ptr, i160 } %302({ ptr, ptr, ptr, i32 } %289, { ptr, ptr, ptr, i32 } %289, ptr nonnull %14, i32 %280)
  %.fca.0.extract102 = extractvalue { ptr, i160 } %303, 0
  %304 = icmp ne ptr %.fca.0.extract102, @nil_typ
  %305 = icmp ne ptr %.fca.0.extract102, null
  %.not151 = and i1 %304, %305
  br i1 %.not151, label %306, label %.critedge158

306:                                              ; preds = %.critedge
  %.fca.1.extract104 = extractvalue { ptr, i160 } %303, 1
  %.sroa.4.8.extract.trunc = trunc i160 %.fca.1.extract104 to i64
  %307 = inttoptr i64 %.sroa.4.8.extract.trunc to ptr
  %.sroa.7508.8.extract.shift = lshr i160 %.fca.1.extract104, 64
  %.sroa.7508.8.extract.trunc = trunc i160 %.sroa.7508.8.extract.shift to i64
  %308 = inttoptr i64 %.sroa.7508.8.extract.trunc to ptr
  %hash_coef_ptr.i.i237 = getelementptr i8, ptr %.fca.0.extract102, i64 8
  %tbl_size_ptr.i.i238 = getelementptr i8, ptr %.fca.0.extract102, i64 16
  %offset_tbl_ptr.i.i239 = getelementptr i8, ptr %.fca.0.extract102, i64 40
  %hash_coef.i.i240 = load i64, ptr %hash_coef_ptr.i.i237, align 4
  %tbl_size.i.i241 = load i64, ptr %tbl_size_ptr.i.i238, align 4
  %offset_tbl.i.i242 = load ptr, ptr %offset_tbl_ptr.i.i239, align 8
  %product.i.i.i243 = mul i64 %hash_coef.i.i240, 4015701072841558310
  %shifted.i.i.i244 = lshr i64 %product.i.i.i243, 32
  %xored.i.i.i245 = xor i64 %shifted.i.i.i244, %product.i.i.i243
  %hash.i.i.i246 = and i64 %xored.i.i.i245, %tbl_size.i.i241
  %offset_ptr.i.i247 = getelementptr i32, ptr %offset_tbl.i.i242, i64 %hash.i.i.i246
  %offset.i.i248 = load i32, ptr %offset_ptr.i.i247, align 4
  %309 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102, 0
  %310 = insertvalue { ptr, ptr, ptr, i32 } %309, ptr %307, 1
  %311 = insertvalue { ptr, ptr, ptr, i32 } %310, ptr %308, 2
  %312 = insertvalue { ptr, ptr, ptr, i32 } %311, i32 %offset.i.i248, 3
  %313 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %314 = load ptr, ptr %28, align 8
  %315 = call ptr %314(ptr %.fca.1.extract45)
  %316 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %317 = load ptr, ptr %32, align 8
  %318 = call ptr %317(ptr %.fca.1.extract45)
  %319 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %320 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102)
  %321 = sext i32 %offset.i.i248 to i64
  %322 = getelementptr ptr, ptr %.fca.0.extract102, i64 %321
  %323 = getelementptr i8, ptr %322, i64 64
  %324 = load ptr, ptr %323, align 8
  %325 = call ptr %324({ ptr, ptr, ptr, i32 } %312, ptr nonnull %6)
  %326 = call i32 %325({ ptr, ptr, ptr, i32 } %312, { ptr, ptr, ptr, i32 } %312, ptr nonnull %6)
  %327 = icmp eq i32 %326, %42
  %328 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %329 = load ptr, ptr %28, align 8
  %330 = call ptr %329(ptr %.fca.1.extract45)
  %331 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %332 = load ptr, ptr %32, align 8
  %333 = call ptr %332(ptr %.fca.1.extract45)
  %334 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %335 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102)
  %336 = getelementptr i8, ptr %322, i64 48
  %337 = load ptr, ptr %336, align 8
  %338 = call ptr %337({ ptr, ptr, ptr, i32 } %312, ptr nonnull %6)
  %339 = call { ptr, i160 } %338({ ptr, ptr, ptr, i32 } %312, { ptr, ptr, ptr, i32 } %312, ptr nonnull %6)
  %340 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %341 = getelementptr i8, ptr %28, i64 56
  %342 = load ptr, ptr %341, align 8
  %343 = load ptr, ptr %342, align 8
  %344 = call { ptr } %343(ptr %.fca.1.extract45)
  %.fca.0.extract87 = extractvalue { ptr } %344, 0
  %345 = call i1 %.fca.0.extract87({ ptr, i160 } %339, { ptr, i160 } %3)
  %346 = and i1 %327, %345
  br i1 %346, label %347, label %.critedge158

347:                                              ; preds = %306
  %348 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %349 = load ptr, ptr %28, align 8
  %350 = call ptr %349(ptr %.fca.1.extract45)
  %351 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %352 = load ptr, ptr %32, align 8
  %353 = call ptr %352(ptr %.fca.1.extract45)
  %354 = load ptr, ptr %350, align 8
  %355 = getelementptr i8, ptr %354, i64 48
  %356 = load ptr, ptr %355, align 8
  %357 = call { i64, i64 } %356(ptr nonnull %350)
  %358 = extractvalue { i64, i64 } %357, 0
  %359 = extractvalue { i64, i64 } %357, 1
  %360 = urem i64 20, %359
  %361 = icmp eq i64 %360, 0
  %362 = sub i64 %359, %360
  %363 = select i1 %361, i64 0, i64 %362
  %364 = add i64 %358, 20
  %365 = add i64 %364, %363
  %366 = load ptr, ptr %353, align 8
  %367 = getelementptr i8, ptr %366, i64 48
  %368 = load ptr, ptr %367, align 8
  %369 = call { i64, i64 } %368(ptr nonnull %353)
  %370 = extractvalue { i64, i64 } %369, 0
  %371 = extractvalue { i64, i64 } %369, 1
  %372 = call i64 @llvm.umax.i64(i64 %359, i64 %371)
  %373 = call i64 @llvm.umax.i64(i64 %372, i64 8)
  %374 = urem i64 %365, %371
  %375 = icmp eq i64 %374, 0
  %376 = sub i64 %371, %374
  %377 = select i1 %375, i64 0, i64 %376
  %378 = add i64 %370, %365
  %379 = add i64 %378, %377
  %380 = urem i64 %379, %373
  %381 = icmp eq i64 %380, 0
  %382 = sub i64 %373, %380
  %383 = select i1 %381, i64 0, i64 %382
  %384 = add i64 %383, %379
  %result.i250 = call noalias ptr @bump_malloc_inner(i64 noundef %384, ptr nonnull @current_ptr) #29
  store ptr %350, ptr %result.i250, align 8
  %385 = getelementptr i8, ptr %result.i250, i64 8
  store ptr %353, ptr %385, align 8
  %386 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250)
  %387 = getelementptr inbounds i8, ptr %16, i64 8
  %388 = getelementptr inbounds i8, ptr %16, i64 24
  store ptr @Entry, ptr %16, align 8
  store ptr %result.i250, ptr %387, align 8
  store i32 9, ptr %388, align 8
  %389 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %16)
  %390 = getelementptr inbounds i8, ptr %16, i64 16
  %391 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %392 = load ptr, ptr %28, align 8
  %393 = call ptr %392(ptr %.fca.1.extract45)
  %394 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %395 = load ptr, ptr %32, align 8
  %396 = call ptr %395(ptr %.fca.1.extract45)
  %397 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %398 = load ptr, ptr %result.i250, align 8
  %399 = load ptr, ptr %398, align 8
  %400 = getelementptr i8, ptr %399, i64 48
  %401 = load ptr, ptr %400, align 8
  %402 = call { i64, i64 } %401(ptr nonnull %398)
  %403 = extractvalue { i64, i64 } %402, 1
  %404 = urem i64 20, %403
  %405 = icmp eq i64 %404, 0
  %reass.sub559 = sub i64 %403, %404
  %406 = add i64 %reass.sub559, 20
  %407 = select i1 %405, i64 20, i64 %406
  %408 = getelementptr i8, ptr %result.i250, i64 %407
  %409 = load ptr, ptr %result.i250, align 8
  %410 = load ptr, ptr %409, align 8
  %411 = getelementptr i8, ptr %410, i64 64
  %412 = load ptr, ptr %411, align 8
  call void %412({ ptr, i160 } %3, ptr nonnull %409, ptr %408)
  %413 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %414 = load ptr, ptr %result.i250, align 8
  %415 = load ptr, ptr %414, align 8
  %416 = getelementptr i8, ptr %415, i64 48
  %417 = load ptr, ptr %416, align 8
  %418 = call { i64, i64 } %417(ptr nonnull %414)
  %419 = extractvalue { i64, i64 } %418, 0
  %420 = extractvalue { i64, i64 } %418, 1
  %421 = urem i64 20, %420
  %422 = icmp eq i64 %421, 0
  %423 = sub i64 %420, %421
  %424 = select i1 %422, i64 0, i64 %423
  %425 = add i64 %419, 20
  %426 = add i64 %425, %424
  %427 = load ptr, ptr %385, align 8
  %428 = load ptr, ptr %427, align 8
  %429 = getelementptr i8, ptr %428, i64 48
  %430 = load ptr, ptr %429, align 8
  %431 = call { i64, i64 } %430(ptr nonnull %427)
  %432 = extractvalue { i64, i64 } %431, 1
  %433 = urem i64 %426, %432
  %434 = icmp eq i64 %433, 0
  %435 = sub i64 %432, %433
  %436 = select i1 %434, i64 0, i64 %435
  %437 = getelementptr i8, ptr %result.i250, i64 %426
  %438 = getelementptr i8, ptr %437, i64 %436
  %439 = load ptr, ptr %385, align 8
  %440 = load ptr, ptr %439, align 8
  %441 = getelementptr i8, ptr %440, i64 64
  %442 = load ptr, ptr %441, align 8
  call void %442({ ptr, i160 } %4, ptr nonnull %439, ptr %438)
  %443 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %444 = getelementptr i8, ptr %result.i250, i64 16
  store i32 %42, ptr %444, align 4
  %445 = load ptr, ptr %16, align 8
  %446 = load ptr, ptr %387, align 8
  %447 = load ptr, ptr %390, align 8
  %hash_coef_ptr.i.i252 = getelementptr i8, ptr %445, i64 8
  %tbl_size_ptr.i.i253 = getelementptr i8, ptr %445, i64 16
  %offset_tbl_ptr.i.i254 = getelementptr i8, ptr %445, i64 40
  %hash_coef.i.i255 = load i64, ptr %hash_coef_ptr.i.i252, align 4
  %tbl_size.i.i256 = load i64, ptr %tbl_size_ptr.i.i253, align 4
  %offset_tbl.i.i257 = load ptr, ptr %offset_tbl_ptr.i.i254, align 8
  %product.i.i.i258 = mul i64 %hash_coef.i.i255, 4015701072841558310
  %shifted.i.i.i259 = lshr i64 %product.i.i.i258, 32
  %xored.i.i.i260 = xor i64 %shifted.i.i.i259, %product.i.i.i258
  %hash.i.i.i261 = and i64 %xored.i.i.i260, %tbl_size.i.i256
  %offset_ptr.i.i262 = getelementptr i32, ptr %offset_tbl.i.i257, i64 %hash.i.i.i261
  %offset.i.i263 = load i32, ptr %offset_ptr.i.i262, align 4
  %448 = insertvalue { ptr, i160 } undef, ptr %445, 0
  %449 = ptrtoint ptr %446 to i64
  %450 = ptrtoint ptr %447 to i64
  %.sroa.3.0.insert.ext = zext i32 %offset.i.i263 to i160
  %.sroa.3.0.insert.shift = shl nuw i160 %.sroa.3.0.insert.ext, 128
  %.sroa.282.0.insert.ext = zext i64 %450 to i160
  %.sroa.282.0.insert.shift = shl nuw nsw i160 %.sroa.282.0.insert.ext, 64
  %.sroa.282.0.insert.insert = or disjoint i160 %.sroa.3.0.insert.shift, %.sroa.282.0.insert.shift
  %.sroa.081.0.insert.ext = zext i64 %449 to i160
  %.sroa.081.0.insert.insert = or disjoint i160 %.sroa.282.0.insert.insert, %.sroa.081.0.insert.ext
  %451 = insertvalue { ptr, i160 } %448, i160 %.sroa.081.0.insert.insert, 1
  %452 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %453 = load ptr, ptr %282, align 8
  %454 = load ptr, ptr %453, align 8
  %455 = call { ptr, ptr, ptr, i32 } %454(ptr %.fca.1.extract45)
  %.fca.0.extract72 = extractvalue { ptr, ptr, ptr, i32 } %455, 0
  %.fca.1.extract74 = extractvalue { ptr, ptr, ptr, i32 } %455, 1
  %.fca.2.extract76 = extractvalue { ptr, ptr, ptr, i32 } %455, 2
  %.fca.3.extract78 = extractvalue { ptr, ptr, ptr, i32 } %455, 3
  %hash_coef_ptr.i.i266 = getelementptr i8, ptr %.fca.0.extract72, i64 8
  %tbl_size_ptr.i.i267 = getelementptr i8, ptr %.fca.0.extract72, i64 16
  %offset_tbl_ptr.i.i268 = getelementptr i8, ptr %.fca.0.extract72, i64 40
  %hash_coef.i.i269 = load i64, ptr %hash_coef_ptr.i.i266, align 4
  %tbl_size.i.i270 = load i64, ptr %tbl_size_ptr.i.i267, align 4
  %offset_tbl.i.i271 = load ptr, ptr %offset_tbl_ptr.i.i268, align 8
  %product.i.i.i272 = mul i64 %hash_coef.i.i269, -5261542750394134544
  %shifted.i.i.i273 = lshr i64 %product.i.i.i272, 32
  %xored.i.i.i274 = xor i64 %shifted.i.i.i273, %product.i.i.i272
  %hash.i.i.i275 = and i64 %xored.i.i.i274, %tbl_size.i.i270
  %offset_ptr.i.i276 = getelementptr i32, ptr %offset_tbl.i.i271, i64 %hash.i.i.i275
  %offset.i.i277 = load i32, ptr %offset_ptr.i.i276, align 4
  %eq.i280 = icmp eq i32 %.fca.3.extract78, %offset.i.i277
  call void @llvm.assume(i1 %eq.i280) #30
  %456 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract72, 0
  %457 = insertvalue { ptr, ptr, ptr, i32 } %456, ptr %.fca.1.extract74, 1
  %458 = insertvalue { ptr, ptr, ptr, i32 } %457, ptr %.fca.2.extract76, 2
  %459 = insertvalue { ptr, ptr, ptr, i32 } %458, i32 %.fca.3.extract78, 3
  %460 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %461 = load ptr, ptr %28, align 8
  %462 = call ptr %461(ptr %.fca.1.extract45)
  %463 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %464 = load ptr, ptr %32, align 8
  %465 = call ptr %464(ptr %.fca.1.extract45)
  %result.i281 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %466 = getelementptr i8, ptr %result.i281, i64 16
  store ptr %465, ptr %466, align 8
  %467 = getelementptr i8, ptr %result.i281, i64 8
  store ptr %462, ptr %467, align 8
  %468 = getelementptr i8, ptr %result.i281, i64 24
  store ptr null, ptr %468, align 8
  %469 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281)
  store ptr @Entry, ptr %result.i281, align 8
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %470 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %result.i281, ptr %470, align 8
  %471 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %17)
  %472 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract72)
  %473 = sext i32 %.fca.3.extract78 to i64
  %474 = getelementptr ptr, ptr %.fca.0.extract72, i64 %473
  %475 = getelementptr i8, ptr %474, i64 128
  %476 = load ptr, ptr %475, align 8
  store ptr @i32_typ, ptr %18, align 8
  %477 = getelementptr inbounds i8, ptr %18, i64 8
  store ptr %445, ptr %477, align 8
  %478 = call ptr %476({ ptr, ptr, ptr, i32 } %459, ptr nonnull %18)
  call void %478({ ptr, ptr, ptr, i32 } %459, { ptr, ptr, ptr, i32 } %459, ptr nonnull %17, i32 %280, { ptr, i160 } %451)
  br label %.thread

.critedge158:                                     ; preds = %306, %.critedge
  %479 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %480 = load ptr, ptr %58, align 8
  %481 = load ptr, ptr %480, align 8
  %482 = call { ptr, ptr, ptr, i32 } %481(ptr %.fca.1.extract45)
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %482, 0
  %.fca.1.extract66 = extractvalue { ptr, ptr, ptr, i32 } %482, 1
  %.fca.2.extract68 = extractvalue { ptr, ptr, ptr, i32 } %482, 2
  %.fca.3.extract70 = extractvalue { ptr, ptr, ptr, i32 } %482, 3
  %hash_coef_ptr.i.i283 = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i.i284 = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i.i285 = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i.i286 = load i64, ptr %hash_coef_ptr.i.i283, align 4
  %tbl_size.i.i287 = load i64, ptr %tbl_size_ptr.i.i284, align 4
  %offset_tbl.i.i288 = load ptr, ptr %offset_tbl_ptr.i.i285, align 8
  %product.i.i.i289 = mul i64 %hash_coef.i.i286, -5261542750394134544
  %shifted.i.i.i290 = lshr i64 %product.i.i.i289, 32
  %xored.i.i.i291 = xor i64 %shifted.i.i.i290, %product.i.i.i289
  %hash.i.i.i292 = and i64 %xored.i.i.i291, %tbl_size.i.i287
  %offset_ptr.i.i293 = getelementptr i32, ptr %offset_tbl.i.i288, i64 %hash.i.i.i292
  %offset.i.i294 = load i32, ptr %offset_ptr.i.i293, align 4
  %eq.i297 = icmp eq i32 %.fca.3.extract70, %offset.i.i294
  call void @llvm.assume(i1 %eq.i297) #30
  %483 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %484 = insertvalue { ptr, ptr, ptr, i32 } %483, ptr %.fca.1.extract66, 1
  %485 = insertvalue { ptr, ptr, ptr, i32 } %484, ptr %.fca.2.extract68, 2
  %486 = insertvalue { ptr, ptr, ptr, i32 } %485, i32 %.fca.3.extract70, 3
  %487 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %488 = load ptr, ptr %28, align 8
  %489 = call ptr %488(ptr %.fca.1.extract45)
  %490 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %491 = load ptr, ptr %32, align 8
  %492 = call ptr %491(ptr %.fca.1.extract45)
  %493 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %494 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract64)
  %495 = sext i32 %.fca.3.extract70 to i64
  %496 = getelementptr ptr, ptr %.fca.0.extract64, i64 %495
  %497 = getelementptr i8, ptr %496, i64 64
  %498 = load ptr, ptr %497, align 8
  %499 = call ptr %498({ ptr, ptr, ptr, i32 } %486, ptr nonnull %6)
  %500 = call i32 %499({ ptr, ptr, ptr, i32 } %486, { ptr, ptr, ptr, i32 } %486, ptr nonnull %6)
  %501 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %502 = getelementptr i8, ptr %28, i64 40
  %503 = load ptr, ptr %502, align 8
  %504 = load ptr, ptr %503, align 8
  %505 = call i32 %504(ptr %.fca.1.extract45)
  %.not = icmp slt i32 %505, %500
  br i1 %.not, label %._crit_edge, label %506

506:                                              ; preds = %.critedge158
  %507 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %508 = load ptr, ptr %28, align 8
  %509 = call ptr %508(ptr %.fca.1.extract45)
  %510 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %511 = load ptr, ptr %32, align 8
  %512 = call ptr %511(ptr %.fca.1.extract45)
  %513 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %514 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %515 = getelementptr i8, ptr %28, i64 120
  %516 = load ptr, ptr %515, align 8
  %517 = call ptr %516({ ptr, ptr, ptr, i32 } %25, ptr nonnull %6)
  call void %517({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %6)
  br label %._crit_edge

._crit_edge:                                      ; preds = %.critedge158, %506
  %518 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %519 = load ptr, ptr %28, align 8
  %520 = call ptr %519(ptr %.fca.1.extract45)
  %521 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %522 = load ptr, ptr %32, align 8
  %523 = call ptr %522(ptr %.fca.1.extract45)
  %524 = load ptr, ptr %520, align 8
  %525 = getelementptr i8, ptr %524, i64 48
  %526 = load ptr, ptr %525, align 8
  %527 = call { i64, i64 } %526(ptr nonnull %520)
  %528 = extractvalue { i64, i64 } %527, 0
  %529 = extractvalue { i64, i64 } %527, 1
  %530 = urem i64 20, %529
  %531 = icmp eq i64 %530, 0
  %532 = sub i64 %529, %530
  %533 = select i1 %531, i64 0, i64 %532
  %534 = add i64 %528, 20
  %535 = add i64 %534, %533
  %536 = load ptr, ptr %523, align 8
  %537 = getelementptr i8, ptr %536, i64 48
  %538 = load ptr, ptr %537, align 8
  %539 = call { i64, i64 } %538(ptr nonnull %523)
  %540 = extractvalue { i64, i64 } %539, 0
  %541 = extractvalue { i64, i64 } %539, 1
  %542 = call i64 @llvm.umax.i64(i64 %529, i64 %541)
  %543 = call i64 @llvm.umax.i64(i64 %542, i64 8)
  %544 = urem i64 %535, %541
  %545 = icmp eq i64 %544, 0
  %546 = sub i64 %541, %544
  %547 = select i1 %545, i64 0, i64 %546
  %548 = add i64 %540, %535
  %549 = add i64 %548, %547
  %550 = urem i64 %549, %543
  %551 = icmp eq i64 %550, 0
  %552 = sub i64 %543, %550
  %553 = select i1 %551, i64 0, i64 %552
  %554 = add i64 %553, %549
  %result.i298 = call noalias ptr @bump_malloc_inner(i64 noundef %554, ptr nonnull @current_ptr) #29
  store ptr %520, ptr %result.i298, align 8
  %555 = getelementptr i8, ptr %result.i298, i64 8
  store ptr %523, ptr %555, align 8
  %556 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298)
  %557 = getelementptr inbounds i8, ptr %19, i64 8
  %558 = getelementptr inbounds i8, ptr %19, i64 24
  store ptr @Entry, ptr %19, align 8
  store ptr %result.i298, ptr %557, align 8
  store i32 9, ptr %558, align 8
  %559 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %19)
  %560 = getelementptr inbounds i8, ptr %19, i64 16
  %561 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %562 = load ptr, ptr %28, align 8
  %563 = call ptr %562(ptr %.fca.1.extract45)
  %564 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %565 = load ptr, ptr %32, align 8
  %566 = call ptr %565(ptr %.fca.1.extract45)
  %567 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %568 = load ptr, ptr %result.i298, align 8
  %569 = load ptr, ptr %568, align 8
  %570 = getelementptr i8, ptr %569, i64 48
  %571 = load ptr, ptr %570, align 8
  %572 = call { i64, i64 } %571(ptr nonnull %568)
  %573 = extractvalue { i64, i64 } %572, 1
  %574 = urem i64 20, %573
  %575 = icmp eq i64 %574, 0
  %reass.sub = sub i64 %573, %574
  %576 = add i64 %reass.sub, 20
  %577 = select i1 %575, i64 20, i64 %576
  %578 = getelementptr i8, ptr %result.i298, i64 %577
  %579 = load ptr, ptr %result.i298, align 8
  %580 = load ptr, ptr %579, align 8
  %581 = getelementptr i8, ptr %580, i64 64
  %582 = load ptr, ptr %581, align 8
  call void %582({ ptr, i160 } %3, ptr nonnull %579, ptr %578)
  %583 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %584 = load ptr, ptr %result.i298, align 8
  %585 = load ptr, ptr %584, align 8
  %586 = getelementptr i8, ptr %585, i64 48
  %587 = load ptr, ptr %586, align 8
  %588 = call { i64, i64 } %587(ptr nonnull %584)
  %589 = extractvalue { i64, i64 } %588, 0
  %590 = extractvalue { i64, i64 } %588, 1
  %591 = urem i64 20, %590
  %592 = icmp eq i64 %591, 0
  %593 = sub i64 %590, %591
  %594 = select i1 %592, i64 0, i64 %593
  %595 = add i64 %589, 20
  %596 = add i64 %595, %594
  %597 = load ptr, ptr %555, align 8
  %598 = load ptr, ptr %597, align 8
  %599 = getelementptr i8, ptr %598, i64 48
  %600 = load ptr, ptr %599, align 8
  %601 = call { i64, i64 } %600(ptr nonnull %597)
  %602 = extractvalue { i64, i64 } %601, 1
  %603 = urem i64 %596, %602
  %604 = icmp eq i64 %603, 0
  %605 = sub i64 %602, %603
  %606 = select i1 %604, i64 0, i64 %605
  %607 = getelementptr i8, ptr %result.i298, i64 %596
  %608 = getelementptr i8, ptr %607, i64 %606
  %609 = load ptr, ptr %555, align 8
  %610 = load ptr, ptr %609, align 8
  %611 = getelementptr i8, ptr %610, i64 64
  %612 = load ptr, ptr %611, align 8
  call void %612({ ptr, i160 } %4, ptr nonnull %609, ptr %608)
  %613 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %614 = getelementptr i8, ptr %result.i298, i64 16
  store i32 %42, ptr %614, align 4
  %615 = load ptr, ptr %19, align 8
  %616 = load ptr, ptr %557, align 8
  %617 = load ptr, ptr %560, align 8
  %hash_coef_ptr.i.i300 = getelementptr i8, ptr %615, i64 8
  %tbl_size_ptr.i.i301 = getelementptr i8, ptr %615, i64 16
  %offset_tbl_ptr.i.i302 = getelementptr i8, ptr %615, i64 40
  %hash_coef.i.i303 = load i64, ptr %hash_coef_ptr.i.i300, align 4
  %tbl_size.i.i304 = load i64, ptr %tbl_size_ptr.i.i301, align 4
  %offset_tbl.i.i305 = load ptr, ptr %offset_tbl_ptr.i.i302, align 8
  %product.i.i.i306 = mul i64 %hash_coef.i.i303, 4015701072841558310
  %shifted.i.i.i307 = lshr i64 %product.i.i.i306, 32
  %xored.i.i.i308 = xor i64 %shifted.i.i.i307, %product.i.i.i306
  %hash.i.i.i309 = and i64 %xored.i.i.i308, %tbl_size.i.i304
  %offset_ptr.i.i310 = getelementptr i32, ptr %offset_tbl.i.i305, i64 %hash.i.i.i309
  %offset.i.i311 = load i32, ptr %offset_ptr.i.i310, align 4
  %618 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %615, 0
  %619 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %620 = getelementptr i8, ptr %28, i64 112
  %621 = getelementptr i8, ptr %28, i64 120
  %622 = insertvalue { ptr, ptr, ptr, i32 } %618, ptr %616, 1
  %623 = insertvalue { ptr, ptr, ptr, i32 } %622, ptr %617, 2
  %624 = insertvalue { ptr, ptr, ptr, i32 } %623, i32 %offset.i.i311, 3
  %625 = load ptr, ptr %28, align 8
  %626 = call ptr %625(ptr %.fca.1.extract45)
  %627 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %628 = load ptr, ptr %32, align 8
  %629 = call ptr %628(ptr %.fca.1.extract45)
  %result.i327 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %630 = getelementptr i8, ptr %result.i327, i64 16
  store ptr @_parameterization_Nil, ptr %630, align 8
  %result.i328 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %631 = getelementptr i8, ptr %result.i328, i64 16
  store ptr %629, ptr %631, align 8
  %632 = getelementptr i8, ptr %result.i328, i64 8
  store ptr %626, ptr %632, align 8
  %633 = getelementptr i8, ptr %result.i328, i64 24
  store ptr null, ptr %633, align 8
  %634 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i328)
  store ptr @Entry, ptr %result.i328, align 8
  %635 = getelementptr i8, ptr %result.i327, i64 8
  store ptr %result.i328, ptr %635, align 8
  %636 = getelementptr i8, ptr %result.i327, i64 24
  store ptr null, ptr %636, align 8
  %637 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i327)
  store ptr @union_typ, ptr %result.i327, align 8
  store ptr %result.i327, ptr %20, align 8
  %638 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %20)
  %639 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %640 = load ptr, ptr %620, align 8
  store ptr @union_typ, ptr %21, align 8
  %641 = call ptr %640({ ptr, ptr, ptr, i32 } %25, ptr nonnull %21)
  %642 = call { ptr, i160 } %641({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %20, { ptr, ptr, ptr, i32 } %624)
  %.fca.0.extract51 = extractvalue { ptr, i160 } %642, 0
  %643 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %644 = icmp ne ptr %.fca.0.extract51, null
  %.not154 = and i1 %643, %644
  br i1 %.not154, label %._crit_edge1, label %.thread

._crit_edge1:                                     ; preds = %._crit_edge
  %.fca.1.extract53 = extractvalue { ptr, i160 } %642, 1
  %645 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %646 = load ptr, ptr %28, align 8
  %647 = call ptr %646(ptr %.fca.1.extract45)
  %648 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %649 = load ptr, ptr %32, align 8
  %650 = call ptr %649(ptr %.fca.1.extract45)
  %651 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %652 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %653 = load ptr, ptr %621, align 8
  %654 = call ptr %653({ ptr, ptr, ptr, i32 } %25, ptr nonnull %6)
  call void %654({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %6)
  %655 = trunc i160 %.fca.1.extract53 to i64
  %656 = lshr i160 %.fca.1.extract53, 64
  %657 = trunc i160 %656 to i64
  %658 = inttoptr i64 %655 to ptr
  %659 = inttoptr i64 %657 to ptr
  %hash_coef.i.i317.1 = load i64, ptr %hash_coef_ptr.i.i300, align 4
  %tbl_size.i.i318.1 = load i64, ptr %tbl_size_ptr.i.i301, align 4
  %offset_tbl.i.i319.1 = load ptr, ptr %offset_tbl_ptr.i.i302, align 8
  %product.i.i.i320.1 = mul i64 %hash_coef.i.i317.1, 4015701072841558310
  %shifted.i.i.i321.1 = lshr i64 %product.i.i.i320.1, 32
  %xored.i.i.i322.1 = xor i64 %shifted.i.i.i321.1, %product.i.i.i320.1
  %hash.i.i.i323.1 = and i64 %xored.i.i.i322.1, %tbl_size.i.i318.1
  %offset_ptr.i.i324.1 = getelementptr i32, ptr %offset_tbl.i.i319.1, i64 %hash.i.i.i323.1
  %offset.i.i325.1 = load i32, ptr %offset_ptr.i.i324.1, align 4
  %660 = insertvalue { ptr, ptr, ptr, i32 } %618, ptr %658, 1
  %661 = insertvalue { ptr, ptr, ptr, i32 } %660, ptr %659, 2
  %662 = insertvalue { ptr, ptr, ptr, i32 } %661, i32 %offset.i.i325.1, 3
  %663 = load ptr, ptr %28, align 8
  %664 = call ptr %663(ptr %.fca.1.extract45)
  %665 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %666 = load ptr, ptr %32, align 8
  %667 = call ptr %666(ptr %.fca.1.extract45)
  %result.i327.1 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %668 = getelementptr i8, ptr %result.i327.1, i64 16
  store ptr @_parameterization_Nil, ptr %668, align 8
  %result.i328.1 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %669 = getelementptr i8, ptr %result.i328.1, i64 16
  store ptr %667, ptr %669, align 8
  %670 = getelementptr i8, ptr %result.i328.1, i64 8
  store ptr %664, ptr %670, align 8
  %671 = getelementptr i8, ptr %result.i328.1, i64 24
  store ptr null, ptr %671, align 8
  %672 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i328.1)
  store ptr @Entry, ptr %result.i328.1, align 8
  %673 = getelementptr i8, ptr %result.i327.1, i64 8
  store ptr %result.i328.1, ptr %673, align 8
  %674 = getelementptr i8, ptr %result.i327.1, i64 24
  store ptr null, ptr %674, align 8
  %675 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i327.1)
  store ptr @union_typ, ptr %result.i327.1, align 8
  store ptr %result.i327.1, ptr %20, align 8
  %676 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %20)
  %677 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %678 = load ptr, ptr %620, align 8
  store ptr @union_typ, ptr %21, align 8
  %679 = call ptr %678({ ptr, ptr, ptr, i32 } %25, ptr nonnull %21)
  %680 = call { ptr, i160 } %679({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %20, { ptr, ptr, ptr, i32 } %662)
  %.fca.0.extract51.1 = extractvalue { ptr, i160 } %680, 0
  %681 = icmp ne ptr %.fca.0.extract51.1, @nil_typ
  %682 = icmp ne ptr %.fca.0.extract51.1, null
  %.not154.1 = and i1 %681, %682
  br i1 %.not154.1, label %._crit_edge1.1, label %.thread

._crit_edge1.1:                                   ; preds = %._crit_edge1
  %683 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %684 = load ptr, ptr %28, align 8
  %685 = call ptr %684(ptr %.fca.1.extract45)
  %686 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %687 = load ptr, ptr %32, align 8
  %688 = call ptr %687(ptr %.fca.1.extract45)
  %689 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %690 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract43)
  %691 = load ptr, ptr %621, align 8
  %692 = call ptr %691({ ptr, ptr, ptr, i32 } %25, ptr nonnull %6)
  call void %692({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull %6)
  br label %.thread

.thread:                                          ; preds = %._crit_edge, %._crit_edge1, %._crit_edge1.1, %347, %125
  ret void
}

define { ptr, i160 } @HashMap_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, i160 } %3) {
  %5 = alloca [0 x ptr], align 8
  %.sroa.0271 = alloca ptr, align 8
  %.sroa.1 = alloca i160, align 8
  %.sroa.0 = alloca ptr, align 8
  %.sroa.2 = alloca i160, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %.sroa.0123 = alloca ptr, align 8
  %.sroa.2124 = alloca i160, align 8
  %.sroa.0115 = alloca ptr, align 8
  %.sroa.2116 = alloca i160, align 8
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract36 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract12 = extractvalue { ptr, i160 } %3, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract34, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract36, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %17 = sext i32 %offset.i.i to i64
  %18 = getelementptr ptr, ptr %.fca.0.extract32, i64 %17
  %19 = load ptr, ptr %18, align 8
  %20 = tail call ptr %19(ptr %.fca.1.extract34)
  %21 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %22 = getelementptr i8, ptr %18, i64 8
  %23 = load ptr, ptr %22, align 8
  %24 = tail call ptr %23(ptr %.fca.1.extract34)
  %25 = alloca [1 x ptr], align 8
  store ptr %20, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %25)
  %27 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %28 = getelementptr i8, ptr %18, i64 80
  %29 = load ptr, ptr %28, align 8
  %30 = alloca { ptr }, align 8
  store ptr %.fca.0.extract12, ptr %30, align 8
  %31 = call ptr %29({ ptr, ptr, ptr, i32 } %15, ptr nonnull %30)
  %32 = call i32 %31({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %25, { ptr, i160 } %3)
  %33 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %34 = load ptr, ptr %18, align 8
  %35 = call ptr %34(ptr %.fca.1.extract34)
  %36 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %37 = load ptr, ptr %22, align 8
  %38 = call ptr %37(ptr %.fca.1.extract34)
  %39 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %39)
  %41 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %42 = getelementptr i8, ptr %18, i64 96
  %43 = load ptr, ptr %42, align 8
  %44 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %44, align 8
  %45 = call ptr %43({ ptr, ptr, ptr, i32 } %15, ptr nonnull %44)
  %46 = call i32 %45({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %39, i32 %32)
  %47 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %48 = getelementptr i8, ptr %18, i64 24
  %49 = load ptr, ptr %48, align 8
  %50 = load ptr, ptr %49, align 8
  %51 = call { ptr, ptr, ptr, i32 } %50(ptr %.fca.1.extract34)
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %51, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %51, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %51, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %51, 3
  %hash_coef_ptr.i.i130 = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i131 = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i132 = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i133 = load i64, ptr %hash_coef_ptr.i.i130, align 4
  %tbl_size.i.i134 = load i64, ptr %tbl_size_ptr.i.i131, align 4
  %offset_tbl.i.i135 = load ptr, ptr %offset_tbl_ptr.i.i132, align 8
  %product.i.i.i136 = mul i64 %hash_coef.i.i133, -5261542750394134544
  %shifted.i.i.i137 = lshr i64 %product.i.i.i136, 32
  %xored.i.i.i138 = xor i64 %shifted.i.i.i137, %product.i.i.i136
  %hash.i.i.i139 = and i64 %xored.i.i.i138, %tbl_size.i.i134
  %offset_ptr.i.i140 = getelementptr i32, ptr %offset_tbl.i.i135, i64 %hash.i.i.i139
  %offset.i.i141 = load i32, ptr %offset_ptr.i.i140, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i141
  call void @llvm.assume(i1 %eq.i) #30
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %.fca.1.extract5, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %.fca.2.extract, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %.fca.3.extract, 3
  %56 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %57 = load ptr, ptr %18, align 8
  %58 = call ptr %57(ptr %.fca.1.extract34)
  %59 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract32)
  %60 = load ptr, ptr %22, align 8
  %61 = call ptr %60(ptr %.fca.1.extract34)
  %62 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %62)
  %64 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract4)
  %65 = sext i32 %.fca.3.extract to i64
  %66 = getelementptr ptr, ptr %.fca.0.extract4, i64 %65
  %67 = getelementptr i8, ptr %66, i64 120
  %68 = load ptr, ptr %67, align 8
  %69 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %69, align 8
  %70 = call ptr %68({ ptr, ptr, ptr, i32 } %55, ptr nonnull %69)
  %71 = call { ptr, i160 } %70({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull %62, i32 %46)
  %.fca.0.extract = extractvalue { ptr, i160 } %71, 0
  %72 = icmp ne ptr %.fca.0.extract, @nil_typ
  %73 = icmp ne ptr %.fca.0.extract, null
  %.not126 = and i1 %72, %73
  br i1 %.not126, label %74, label %.critedge

74:                                               ; preds = %4
  %.fca.1.extract = extractvalue { ptr, i160 } %71, 1
  %.sroa.5.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %75 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %.sroa.9.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.9.8.extract.trunc = trunc i160 %.sroa.9.8.extract.shift to i64
  %76 = inttoptr i64 %.sroa.9.8.extract.trunc to ptr
  %hash_coef_ptr.i.i144 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i145 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i146 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i147 = load i64, ptr %hash_coef_ptr.i.i144, align 4
  %tbl_size.i.i148 = load i64, ptr %tbl_size_ptr.i.i145, align 4
  %offset_tbl.i.i149 = load ptr, ptr %offset_tbl_ptr.i.i146, align 8
  %product.i.i.i150 = mul i64 %hash_coef.i.i147, 4015701072841558310
  %shifted.i.i.i151 = lshr i64 %product.i.i.i150, 32
  %xored.i.i.i152 = xor i64 %shifted.i.i.i151, %product.i.i.i150
  %hash.i.i.i153 = and i64 %xored.i.i.i152, %tbl_size.i.i148
  %offset_ptr.i.i154 = getelementptr i32, ptr %offset_tbl.i.i149, i64 %hash.i.i.i153
  %offset.i.i155 = load i32, ptr %offset_ptr.i.i154, align 4
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %75, 1
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %76, 2
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, i32 %offset.i.i155, 3
  %81 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %82 = load ptr, ptr %18, align 8
  %83 = call ptr %82(ptr %.fca.1.extract34)
  %84 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %85 = load ptr, ptr %22, align 8
  %86 = call ptr %85(ptr %.fca.1.extract34)
  %87 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %88 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract)
  %89 = sext i32 %offset.i.i155 to i64
  %90 = getelementptr ptr, ptr %.fca.0.extract, i64 %89
  %91 = getelementptr i8, ptr %90, i64 64
  %92 = load ptr, ptr %91, align 8
  %93 = call ptr %92({ ptr, ptr, ptr, i32 } %80, ptr nonnull %5)
  %94 = call i32 %93({ ptr, ptr, ptr, i32 } %80, { ptr, ptr, ptr, i32 } %80, ptr nonnull %5)
  %95 = icmp eq i32 %94, %32
  %96 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %97 = load ptr, ptr %18, align 8
  %98 = call ptr %97(ptr %.fca.1.extract34)
  %99 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %100 = load ptr, ptr %22, align 8
  %101 = call ptr %100(ptr %.fca.1.extract34)
  %102 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %103 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract)
  %104 = getelementptr i8, ptr %90, i64 48
  %105 = load ptr, ptr %104, align 8
  %106 = call ptr %105({ ptr, ptr, ptr, i32 } %80, ptr nonnull %5)
  %107 = call { ptr, i160 } %106({ ptr, ptr, ptr, i32 } %80, { ptr, ptr, ptr, i32 } %80, ptr nonnull %5)
  %108 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %109 = getelementptr i8, ptr %18, i64 56
  %110 = load ptr, ptr %109, align 8
  %111 = load ptr, ptr %110, align 8
  %112 = call { ptr } %111(ptr %.fca.1.extract34)
  %.fca.0.extract72 = extractvalue { ptr } %112, 0
  %113 = call i1 %.fca.0.extract72({ ptr, i160 } %107, { ptr, i160 } %3)
  %114 = and i1 %95, %113
  br i1 %114, label %.thread, label %.critedge

.critedge:                                        ; preds = %4, %74
  %115 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %116 = load ptr, ptr %18, align 8
  %117 = call ptr %116(ptr %.fca.1.extract34)
  %118 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %119 = load ptr, ptr %22, align 8
  %120 = call ptr %119(ptr %.fca.1.extract34)
  store ptr @_parameterization_Ptri32, ptr %6, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %6)
  %122 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %123 = getelementptr i8, ptr %18, i64 88
  %124 = load ptr, ptr %123, align 8
  store ptr @i32_typ, ptr %7, align 8
  %125 = call ptr %124({ ptr, ptr, ptr, i32 } %15, ptr nonnull %7)
  %126 = call i32 %125({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %6, i32 %32)
  %127 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %128 = load ptr, ptr %18, align 8
  %129 = call ptr %128(ptr %.fca.1.extract34)
  %130 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %131 = load ptr, ptr %22, align 8
  %132 = call ptr %131(ptr %.fca.1.extract34)
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %133 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %8)
  %134 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %135 = getelementptr i8, ptr %18, i64 104
  %136 = load ptr, ptr %135, align 8
  store ptr @i32_typ, ptr %9, align 8
  %137 = call ptr %136({ ptr, ptr, ptr, i32 } %15, ptr nonnull %9)
  %138 = call i32 %137({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %8, i32 %126)
  %139 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %140 = getelementptr i8, ptr %18, i64 32
  %141 = load ptr, ptr %140, align 8
  %142 = load ptr, ptr %141, align 8
  %143 = call { ptr, ptr, ptr, i32 } %142(ptr %.fca.1.extract34)
  %.fca.0.extract64 = extractvalue { ptr, ptr, ptr, i32 } %143, 0
  %.fca.1.extract66 = extractvalue { ptr, ptr, ptr, i32 } %143, 1
  %.fca.2.extract68 = extractvalue { ptr, ptr, ptr, i32 } %143, 2
  %.fca.3.extract70 = extractvalue { ptr, ptr, ptr, i32 } %143, 3
  %hash_coef_ptr.i.i158 = getelementptr i8, ptr %.fca.0.extract64, i64 8
  %tbl_size_ptr.i.i159 = getelementptr i8, ptr %.fca.0.extract64, i64 16
  %offset_tbl_ptr.i.i160 = getelementptr i8, ptr %.fca.0.extract64, i64 40
  %hash_coef.i.i161 = load i64, ptr %hash_coef_ptr.i.i158, align 4
  %tbl_size.i.i162 = load i64, ptr %tbl_size_ptr.i.i159, align 4
  %offset_tbl.i.i163 = load ptr, ptr %offset_tbl_ptr.i.i160, align 8
  %product.i.i.i164 = mul i64 %hash_coef.i.i161, -5261542750394134544
  %shifted.i.i.i165 = lshr i64 %product.i.i.i164, 32
  %xored.i.i.i166 = xor i64 %shifted.i.i.i165, %product.i.i.i164
  %hash.i.i.i167 = and i64 %xored.i.i.i166, %tbl_size.i.i162
  %offset_ptr.i.i168 = getelementptr i32, ptr %offset_tbl.i.i163, i64 %hash.i.i.i167
  %offset.i.i169 = load i32, ptr %offset_ptr.i.i168, align 4
  %eq.i172 = icmp eq i32 %.fca.3.extract70, %offset.i.i169
  call void @llvm.assume(i1 %eq.i172) #30
  %144 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract64, 0
  %145 = insertvalue { ptr, ptr, ptr, i32 } %144, ptr %.fca.1.extract66, 1
  %146 = insertvalue { ptr, ptr, ptr, i32 } %145, ptr %.fca.2.extract68, 2
  %147 = insertvalue { ptr, ptr, ptr, i32 } %146, i32 %.fca.3.extract70, 3
  %148 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %149 = load ptr, ptr %18, align 8
  %150 = call ptr %149(ptr %.fca.1.extract34)
  %151 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %152 = load ptr, ptr %22, align 8
  %153 = call ptr %152(ptr %.fca.1.extract34)
  store ptr @_parameterization_Ptri32, ptr %10, align 8
  %154 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %10)
  %155 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract64)
  %156 = sext i32 %.fca.3.extract70 to i64
  %157 = getelementptr ptr, ptr %.fca.0.extract64, i64 %156
  %158 = getelementptr i8, ptr %157, i64 120
  %159 = load ptr, ptr %158, align 8
  store ptr @i32_typ, ptr %11, align 8
  %160 = call ptr %159({ ptr, ptr, ptr, i32 } %147, ptr nonnull %11)
  %161 = call { ptr, i160 } %160({ ptr, ptr, ptr, i32 } %147, { ptr, ptr, ptr, i32 } %147, ptr nonnull %10, i32 %138)
  %.fca.0.extract57 = extractvalue { ptr, i160 } %161, 0
  %162 = icmp ne ptr %.fca.0.extract57, @nil_typ
  %163 = icmp ne ptr %.fca.0.extract57, null
  %.not128 = and i1 %162, %163
  br i1 %.not128, label %164, label %.thread294

164:                                              ; preds = %.critedge
  %.fca.1.extract59 = extractvalue { ptr, i160 } %161, 1
  %.sroa.6.8.extract.trunc = trunc i160 %.fca.1.extract59 to i64
  %165 = inttoptr i64 %.sroa.6.8.extract.trunc to ptr
  %.sroa.11.8.extract.shift = lshr i160 %.fca.1.extract59, 64
  %.sroa.11.8.extract.trunc = trunc i160 %.sroa.11.8.extract.shift to i64
  %166 = inttoptr i64 %.sroa.11.8.extract.trunc to ptr
  %hash_coef_ptr.i.i174 = getelementptr i8, ptr %.fca.0.extract57, i64 8
  %tbl_size_ptr.i.i175 = getelementptr i8, ptr %.fca.0.extract57, i64 16
  %offset_tbl_ptr.i.i176 = getelementptr i8, ptr %.fca.0.extract57, i64 40
  %hash_coef.i.i177 = load i64, ptr %hash_coef_ptr.i.i174, align 4
  %tbl_size.i.i178 = load i64, ptr %tbl_size_ptr.i.i175, align 4
  %offset_tbl.i.i179 = load ptr, ptr %offset_tbl_ptr.i.i176, align 8
  %product.i.i.i180 = mul i64 %hash_coef.i.i177, 4015701072841558310
  %shifted.i.i.i181 = lshr i64 %product.i.i.i180, 32
  %xored.i.i.i182 = xor i64 %shifted.i.i.i181, %product.i.i.i180
  %hash.i.i.i183 = and i64 %xored.i.i.i182, %tbl_size.i.i178
  %offset_ptr.i.i184 = getelementptr i32, ptr %offset_tbl.i.i179, i64 %hash.i.i.i183
  %offset.i.i185 = load i32, ptr %offset_ptr.i.i184, align 4
  %167 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57, 0
  %168 = insertvalue { ptr, ptr, ptr, i32 } %167, ptr %165, 1
  %169 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %166, 2
  %170 = insertvalue { ptr, ptr, ptr, i32 } %169, i32 %offset.i.i185, 3
  %171 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %172 = load ptr, ptr %18, align 8
  %173 = call ptr %172(ptr %.fca.1.extract34)
  %174 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %175 = load ptr, ptr %22, align 8
  %176 = call ptr %175(ptr %.fca.1.extract34)
  %177 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %178 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57)
  %179 = sext i32 %offset.i.i185 to i64
  %180 = getelementptr ptr, ptr %.fca.0.extract57, i64 %179
  %181 = getelementptr i8, ptr %180, i64 64
  %182 = load ptr, ptr %181, align 8
  %183 = call ptr %182({ ptr, ptr, ptr, i32 } %170, ptr nonnull %5)
  %184 = call i32 %183({ ptr, ptr, ptr, i32 } %170, { ptr, ptr, ptr, i32 } %170, ptr nonnull %5)
  %185 = icmp eq i32 %184, %32
  %186 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %187 = load ptr, ptr %18, align 8
  %188 = call ptr %187(ptr %.fca.1.extract34)
  %189 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %190 = load ptr, ptr %22, align 8
  %191 = call ptr %190(ptr %.fca.1.extract34)
  %192 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %193 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57)
  %194 = getelementptr i8, ptr %180, i64 48
  %195 = load ptr, ptr %194, align 8
  %196 = call ptr %195({ ptr, ptr, ptr, i32 } %170, ptr nonnull %5)
  %197 = call { ptr, i160 } %196({ ptr, ptr, ptr, i32 } %170, { ptr, ptr, ptr, i32 } %170, ptr nonnull %5)
  %198 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %199 = getelementptr i8, ptr %18, i64 56
  %200 = load ptr, ptr %199, align 8
  %201 = load ptr, ptr %200, align 8
  %202 = call { ptr } %201(ptr %.fca.1.extract34)
  %.fca.0.extract42 = extractvalue { ptr } %202, 0
  %203 = call i1 %.fca.0.extract42({ ptr, i160 } %197, { ptr, i160 } %3)
  %204 = and i1 %185, %203
  br i1 %204, label %.thread, label %.thread294

.thread:                                          ; preds = %74, %164
  %.pre-phi313 = phi i64 [ %89, %74 ], [ %179, %164 ]
  %.pre-phi312 = phi { ptr, ptr, ptr, i32 } [ %80, %74 ], [ %170, %164 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated = phi ptr [ %.fca.0.extract, %74 ], [ %.fca.0.extract57, %164 ]
  %.reg2mem59.0.sroa.phi120289 = phi ptr [ %.sroa.1, %74 ], [ %.sroa.2124, %164 ]
  %.reg2mem59.0.sroa.phi117288 = phi ptr [ %.sroa.0271, %74 ], [ %.sroa.0123, %164 ]
  %.reg2mem57.0.sroa.phi94287 = phi ptr [ %.sroa.2, %74 ], [ %.sroa.2116, %164 ]
  %.reg2mem57.0.sroa.phi91286 = phi ptr [ %.sroa.0, %74 ], [ %.sroa.0115, %164 ]
  %205 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %206 = load ptr, ptr %18, align 8
  %207 = call ptr %206(ptr %.fca.1.extract34)
  %208 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract32)
  %209 = load ptr, ptr %22, align 8
  %210 = call ptr %209(ptr %.fca.1.extract34)
  %211 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %212 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated)
  %213 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated, i64 %.pre-phi313
  %214 = getelementptr i8, ptr %213, i64 56
  %215 = load ptr, ptr %214, align 8
  %216 = call ptr %215({ ptr, ptr, ptr, i32 } %.pre-phi312, ptr nonnull %5)
  %217 = call { ptr, i160 } %216({ ptr, ptr, ptr, i32 } %.pre-phi312, { ptr, ptr, ptr, i32 } %.pre-phi312, ptr nonnull %5)
  %.fca.0.extract97 = extractvalue { ptr, i160 } %217, 0
  store ptr %.fca.0.extract97, ptr %.reg2mem59.0.sroa.phi117288, align 8
  %.fca.1.extract99 = extractvalue { ptr, i160 } %217, 1
  store i160 %.fca.1.extract99, ptr %.reg2mem59.0.sroa.phi120289, align 8
  store ptr %.fca.0.extract97, ptr %.reg2mem57.0.sroa.phi91286, align 8
  store i160 %.fca.1.extract99, ptr %.reg2mem57.0.sroa.phi94287, align 8
  br label %.thread294

.thread294:                                       ; preds = %.critedge, %164, %.thread
  %.reg2mem51.sroa.0.0 = phi ptr [ %.fca.0.extract97, %.thread ], [ @nil_typ, %164 ], [ @nil_typ, %.critedge ]
  %.reg2mem51.sroa.3.0 = phi i160 [ %.fca.1.extract99, %.thread ], [ undef, %164 ], [ undef, %.critedge ]
  %.reload52.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem51.sroa.0.0, 0
  %.reload52.fca.1.insert = insertvalue { ptr, i160 } %.reload52.fca.0.insert, i160 %.reg2mem51.sroa.3.0, 1
  ret { ptr, i160 } %.reload52.fca.1.insert
}

define { ptr, i160 } @HashMap_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, i160 } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [2 x ptr], align 8
  %7 = alloca { ptr, ptr }, align 8
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca [1 x ptr], align 8
  %13 = alloca { ptr }, align 8
  %14 = alloca [2 x ptr], align 8
  %15 = alloca { ptr, ptr }, align 8
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract11 = extractvalue { ptr, i160 } %3, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract43, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract45, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i.i, 3
  %20 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %21 = sext i32 %offset.i.i to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract41, i64 %21
  %23 = load ptr, ptr %22, align 8
  %24 = tail call ptr %23(ptr %.fca.1.extract43)
  %25 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %26 = getelementptr i8, ptr %22, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = tail call ptr %27(ptr %.fca.1.extract43)
  %29 = alloca [1 x ptr], align 8
  store ptr %24, ptr %29, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %29)
  %31 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %32 = getelementptr i8, ptr %22, i64 80
  %33 = load ptr, ptr %32, align 8
  %34 = alloca { ptr }, align 8
  store ptr %.fca.0.extract11, ptr %34, align 8
  %35 = call ptr %33({ ptr, ptr, ptr, i32 } %19, ptr nonnull %34)
  %36 = call i32 %35({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %29, { ptr, i160 } %3)
  %37 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %38 = load ptr, ptr %22, align 8
  %39 = call ptr %38(ptr %.fca.1.extract43)
  %40 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %41 = load ptr, ptr %26, align 8
  %42 = call ptr %41(ptr %.fca.1.extract43)
  %43 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %43, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %43)
  %45 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %46 = getelementptr i8, ptr %22, i64 96
  %47 = load ptr, ptr %46, align 8
  %48 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %48, align 8
  %49 = call ptr %47({ ptr, ptr, ptr, i32 } %19, ptr nonnull %48)
  %50 = call i32 %49({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %43, i32 %36)
  %51 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %52 = getelementptr i8, ptr %22, i64 24
  %53 = load ptr, ptr %52, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr, ptr, ptr, i32 } %54(ptr %.fca.1.extract43)
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %55, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %55, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %55, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %55, 3
  %hash_coef_ptr.i.i137 = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i138 = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i139 = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i140 = load i64, ptr %hash_coef_ptr.i.i137, align 4
  %tbl_size.i.i141 = load i64, ptr %tbl_size_ptr.i.i138, align 4
  %offset_tbl.i.i142 = load ptr, ptr %offset_tbl_ptr.i.i139, align 8
  %product.i.i.i143 = mul i64 %hash_coef.i.i140, -5261542750394134544
  %shifted.i.i.i144 = lshr i64 %product.i.i.i143, 32
  %xored.i.i.i145 = xor i64 %shifted.i.i.i144, %product.i.i.i143
  %hash.i.i.i146 = and i64 %xored.i.i.i145, %tbl_size.i.i141
  %offset_ptr.i.i147 = getelementptr i32, ptr %offset_tbl.i.i142, i64 %hash.i.i.i146
  %offset.i.i148 = load i32, ptr %offset_ptr.i.i147, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i148
  call void @llvm.assume(i1 %eq.i) #30
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.1.extract4, 1
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.2.extract, 2
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %.fca.3.extract, 3
  %60 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %61 = load ptr, ptr %22, align 8
  %62 = call ptr %61(ptr %.fca.1.extract43)
  %63 = call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract41)
  %64 = load ptr, ptr %26, align 8
  %65 = call ptr %64(ptr %.fca.1.extract43)
  %66 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %66, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %66)
  %68 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract3)
  %69 = sext i32 %.fca.3.extract to i64
  %70 = getelementptr ptr, ptr %.fca.0.extract3, i64 %69
  %71 = getelementptr i8, ptr %70, i64 120
  %72 = load ptr, ptr %71, align 8
  %73 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %73, align 8
  %74 = call ptr %72({ ptr, ptr, ptr, i32 } %59, ptr nonnull %73)
  %75 = call { ptr, i160 } %74({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull %66, i32 %50)
  %.fca.0.extract = extractvalue { ptr, i160 } %75, 0
  %76 = icmp ne ptr %.fca.0.extract, @nil_typ
  %77 = icmp ne ptr %.fca.0.extract, null
  %.not133 = and i1 %76, %77
  br i1 %.not133, label %78, label %155

78:                                               ; preds = %4
  %.fca.1.extract = extractvalue { ptr, i160 } %75, 1
  %.sroa.5352.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %79 = inttoptr i64 %.sroa.5352.8.extract.trunc to ptr
  %.sroa.9355.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.9355.8.extract.trunc = trunc i160 %.sroa.9355.8.extract.shift to i64
  %80 = inttoptr i64 %.sroa.9355.8.extract.trunc to ptr
  %hash_coef_ptr.i.i151 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i152 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i153 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i154 = load i64, ptr %hash_coef_ptr.i.i151, align 4
  %tbl_size.i.i155 = load i64, ptr %tbl_size_ptr.i.i152, align 4
  %offset_tbl.i.i156 = load ptr, ptr %offset_tbl_ptr.i.i153, align 8
  %product.i.i.i157 = mul i64 %hash_coef.i.i154, 4015701072841558310
  %shifted.i.i.i158 = lshr i64 %product.i.i.i157, 32
  %xored.i.i.i159 = xor i64 %shifted.i.i.i158, %product.i.i.i157
  %hash.i.i.i160 = and i64 %xored.i.i.i159, %tbl_size.i.i155
  %offset_ptr.i.i161 = getelementptr i32, ptr %offset_tbl.i.i156, i64 %hash.i.i.i160
  %offset.i.i162 = load i32, ptr %offset_ptr.i.i161, align 4
  %81 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %82 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %79, 1
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %80, 2
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %offset.i.i162, 3
  %85 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %86 = load ptr, ptr %22, align 8
  %87 = call ptr %86(ptr %.fca.1.extract43)
  %88 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %89 = load ptr, ptr %26, align 8
  %90 = call ptr %89(ptr %.fca.1.extract43)
  %91 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %92 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract)
  %93 = sext i32 %offset.i.i162 to i64
  %94 = getelementptr ptr, ptr %.fca.0.extract, i64 %93
  %95 = getelementptr i8, ptr %94, i64 64
  %96 = load ptr, ptr %95, align 8
  %97 = call ptr %96({ ptr, ptr, ptr, i32 } %84, ptr nonnull %5)
  %98 = call i32 %97({ ptr, ptr, ptr, i32 } %84, { ptr, ptr, ptr, i32 } %84, ptr nonnull %5)
  %99 = icmp eq i32 %98, %36
  %100 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %101 = load ptr, ptr %22, align 8
  %102 = call ptr %101(ptr %.fca.1.extract43)
  %103 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %104 = load ptr, ptr %26, align 8
  %105 = call ptr %104(ptr %.fca.1.extract43)
  %106 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %107 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract)
  %108 = getelementptr i8, ptr %94, i64 48
  %109 = load ptr, ptr %108, align 8
  %110 = call ptr %109({ ptr, ptr, ptr, i32 } %84, ptr nonnull %5)
  %111 = call { ptr, i160 } %110({ ptr, ptr, ptr, i32 } %84, { ptr, ptr, ptr, i32 } %84, ptr nonnull %5)
  %112 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %113 = getelementptr i8, ptr %22, i64 56
  %114 = load ptr, ptr %113, align 8
  %115 = load ptr, ptr %114, align 8
  %116 = call { ptr } %115(ptr %.fca.1.extract43)
  %.fca.0.extract117 = extractvalue { ptr } %116, 0
  %117 = call i1 %.fca.0.extract117({ ptr, i160 } %111, { ptr, i160 } %3)
  %118 = and i1 %99, %117
  br i1 %118, label %119, label %155

119:                                              ; preds = %78
  %120 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %121 = load ptr, ptr %22, align 8
  %122 = call ptr %121(ptr %.fca.1.extract43)
  %123 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %124 = load ptr, ptr %26, align 8
  %125 = call ptr %124(ptr %.fca.1.extract43)
  %126 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %127 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract)
  %128 = getelementptr i8, ptr %94, i64 56
  %129 = load ptr, ptr %128, align 8
  %130 = call ptr %129({ ptr, ptr, ptr, i32 } %84, ptr nonnull %5)
  %131 = call { ptr, i160 } %130({ ptr, ptr, ptr, i32 } %84, { ptr, ptr, ptr, i32 } %84, ptr nonnull %5)
  %132 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %133 = load ptr, ptr %52, align 8
  %134 = load ptr, ptr %133, align 8
  %135 = call { ptr, ptr, ptr, i32 } %134(ptr %.fca.1.extract43)
  %.fca.0.extract99 = extractvalue { ptr, ptr, ptr, i32 } %135, 0
  %.fca.1.extract101 = extractvalue { ptr, ptr, ptr, i32 } %135, 1
  %.fca.2.extract103 = extractvalue { ptr, ptr, ptr, i32 } %135, 2
  %.fca.3.extract105 = extractvalue { ptr, ptr, ptr, i32 } %135, 3
  %hash_coef_ptr.i.i165 = getelementptr i8, ptr %.fca.0.extract99, i64 8
  %tbl_size_ptr.i.i166 = getelementptr i8, ptr %.fca.0.extract99, i64 16
  %offset_tbl_ptr.i.i167 = getelementptr i8, ptr %.fca.0.extract99, i64 40
  %hash_coef.i.i168 = load i64, ptr %hash_coef_ptr.i.i165, align 4
  %tbl_size.i.i169 = load i64, ptr %tbl_size_ptr.i.i166, align 4
  %offset_tbl.i.i170 = load ptr, ptr %offset_tbl_ptr.i.i167, align 8
  %product.i.i.i171 = mul i64 %hash_coef.i.i168, -5261542750394134544
  %shifted.i.i.i172 = lshr i64 %product.i.i.i171, 32
  %xored.i.i.i173 = xor i64 %shifted.i.i.i172, %product.i.i.i171
  %hash.i.i.i174 = and i64 %xored.i.i.i173, %tbl_size.i.i169
  %offset_ptr.i.i175 = getelementptr i32, ptr %offset_tbl.i.i170, i64 %hash.i.i.i174
  %offset.i.i176 = load i32, ptr %offset_ptr.i.i175, align 4
  %eq.i179 = icmp eq i32 %.fca.3.extract105, %offset.i.i176
  call void @llvm.assume(i1 %eq.i179) #30
  %136 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract99, 0
  %137 = insertvalue { ptr, ptr, ptr, i32 } %136, ptr %.fca.1.extract101, 1
  %138 = insertvalue { ptr, ptr, ptr, i32 } %137, ptr %.fca.2.extract103, 2
  %139 = insertvalue { ptr, ptr, ptr, i32 } %138, i32 %.fca.3.extract105, 3
  %140 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %141 = load ptr, ptr %22, align 8
  %142 = call ptr %141(ptr %.fca.1.extract43)
  %143 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %144 = load ptr, ptr %26, align 8
  %145 = call ptr %144(ptr %.fca.1.extract43)
  store ptr @_parameterization_Ptri32, ptr %6, align 8
  %146 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @_parameterization_Nil, ptr %146, align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %6)
  %148 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract99)
  %149 = sext i32 %.fca.3.extract105 to i64
  %150 = getelementptr ptr, ptr %.fca.0.extract99, i64 %149
  %151 = getelementptr i8, ptr %150, i64 128
  %152 = load ptr, ptr %151, align 8
  store ptr @i32_typ, ptr %7, align 8
  %153 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @nil_typ, ptr %153, align 8
  %154 = call ptr %152({ ptr, ptr, ptr, i32 } %139, ptr nonnull %7)
  call void %154({ ptr, ptr, ptr, i32 } %139, { ptr, ptr, ptr, i32 } %139, ptr nonnull %6, i32 %50, { ptr, i160 } { ptr @nil_typ, i160 undef })
  br label %.thread365.sink.split

155:                                              ; preds = %78, %4
  %156 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %157 = load ptr, ptr %22, align 8
  %158 = call ptr %157(ptr %.fca.1.extract43)
  %159 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %160 = load ptr, ptr %26, align 8
  %161 = call ptr %160(ptr %.fca.1.extract43)
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %162 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %8)
  %163 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %164 = getelementptr i8, ptr %22, i64 88
  %165 = load ptr, ptr %164, align 8
  store ptr @i32_typ, ptr %9, align 8
  %166 = call ptr %165({ ptr, ptr, ptr, i32 } %19, ptr nonnull %9)
  %167 = call i32 %166({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %8, i32 %36)
  %168 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %169 = load ptr, ptr %22, align 8
  %170 = call ptr %169(ptr %.fca.1.extract43)
  %171 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %172 = load ptr, ptr %26, align 8
  %173 = call ptr %172(ptr %.fca.1.extract43)
  store ptr @_parameterization_Ptri32, ptr %10, align 8
  %174 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %10)
  %175 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %176 = getelementptr i8, ptr %22, i64 104
  %177 = load ptr, ptr %176, align 8
  store ptr @i32_typ, ptr %11, align 8
  %178 = call ptr %177({ ptr, ptr, ptr, i32 } %19, ptr nonnull %11)
  %179 = call i32 %178({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %10, i32 %167)
  %180 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %181 = getelementptr i8, ptr %22, i64 32
  %182 = load ptr, ptr %181, align 8
  %183 = load ptr, ptr %182, align 8
  %184 = call { ptr, ptr, ptr, i32 } %183(ptr %.fca.1.extract43)
  %.fca.0.extract91 = extractvalue { ptr, ptr, ptr, i32 } %184, 0
  %.fca.1.extract93 = extractvalue { ptr, ptr, ptr, i32 } %184, 1
  %.fca.2.extract95 = extractvalue { ptr, ptr, ptr, i32 } %184, 2
  %.fca.3.extract97 = extractvalue { ptr, ptr, ptr, i32 } %184, 3
  %hash_coef_ptr.i.i181 = getelementptr i8, ptr %.fca.0.extract91, i64 8
  %tbl_size_ptr.i.i182 = getelementptr i8, ptr %.fca.0.extract91, i64 16
  %offset_tbl_ptr.i.i183 = getelementptr i8, ptr %.fca.0.extract91, i64 40
  %hash_coef.i.i184 = load i64, ptr %hash_coef_ptr.i.i181, align 4
  %tbl_size.i.i185 = load i64, ptr %tbl_size_ptr.i.i182, align 4
  %offset_tbl.i.i186 = load ptr, ptr %offset_tbl_ptr.i.i183, align 8
  %product.i.i.i187 = mul i64 %hash_coef.i.i184, -5261542750394134544
  %shifted.i.i.i188 = lshr i64 %product.i.i.i187, 32
  %xored.i.i.i189 = xor i64 %shifted.i.i.i188, %product.i.i.i187
  %hash.i.i.i190 = and i64 %xored.i.i.i189, %tbl_size.i.i185
  %offset_ptr.i.i191 = getelementptr i32, ptr %offset_tbl.i.i186, i64 %hash.i.i.i190
  %offset.i.i192 = load i32, ptr %offset_ptr.i.i191, align 4
  %eq.i195 = icmp eq i32 %.fca.3.extract97, %offset.i.i192
  call void @llvm.assume(i1 %eq.i195) #30
  %185 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract91, 0
  %186 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %.fca.1.extract93, 1
  %187 = insertvalue { ptr, ptr, ptr, i32 } %186, ptr %.fca.2.extract95, 2
  %188 = insertvalue { ptr, ptr, ptr, i32 } %187, i32 %.fca.3.extract97, 3
  %189 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %190 = load ptr, ptr %22, align 8
  %191 = call ptr %190(ptr %.fca.1.extract43)
  %192 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %193 = load ptr, ptr %26, align 8
  %194 = call ptr %193(ptr %.fca.1.extract43)
  store ptr @_parameterization_Ptri32, ptr %12, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %12)
  %196 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract91)
  %197 = sext i32 %.fca.3.extract97 to i64
  %198 = getelementptr ptr, ptr %.fca.0.extract91, i64 %197
  %199 = getelementptr i8, ptr %198, i64 120
  %200 = load ptr, ptr %199, align 8
  store ptr @i32_typ, ptr %13, align 8
  %201 = call ptr %200({ ptr, ptr, ptr, i32 } %188, ptr nonnull %13)
  %202 = call { ptr, i160 } %201({ ptr, ptr, ptr, i32 } %188, { ptr, ptr, ptr, i32 } %188, ptr nonnull %12, i32 %179)
  %.fca.0.extract84 = extractvalue { ptr, i160 } %202, 0
  %203 = icmp ne ptr %.fca.0.extract84, @nil_typ
  %204 = icmp ne ptr %.fca.0.extract84, null
  %.not135 = and i1 %203, %204
  br i1 %.not135, label %205, label %.thread365

205:                                              ; preds = %155
  %.fca.1.extract86 = extractvalue { ptr, i160 } %202, 1
  %.sroa.5.8.extract.trunc = trunc i160 %.fca.1.extract86 to i64
  %206 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %.sroa.9.8.extract.shift = lshr i160 %.fca.1.extract86, 64
  %.sroa.9.8.extract.trunc = trunc i160 %.sroa.9.8.extract.shift to i64
  %207 = inttoptr i64 %.sroa.9.8.extract.trunc to ptr
  %hash_coef_ptr.i.i197 = getelementptr i8, ptr %.fca.0.extract84, i64 8
  %tbl_size_ptr.i.i198 = getelementptr i8, ptr %.fca.0.extract84, i64 16
  %offset_tbl_ptr.i.i199 = getelementptr i8, ptr %.fca.0.extract84, i64 40
  %hash_coef.i.i200 = load i64, ptr %hash_coef_ptr.i.i197, align 4
  %tbl_size.i.i201 = load i64, ptr %tbl_size_ptr.i.i198, align 4
  %offset_tbl.i.i202 = load ptr, ptr %offset_tbl_ptr.i.i199, align 8
  %product.i.i.i203 = mul i64 %hash_coef.i.i200, 4015701072841558310
  %shifted.i.i.i204 = lshr i64 %product.i.i.i203, 32
  %xored.i.i.i205 = xor i64 %shifted.i.i.i204, %product.i.i.i203
  %hash.i.i.i206 = and i64 %xored.i.i.i205, %tbl_size.i.i201
  %offset_ptr.i.i207 = getelementptr i32, ptr %offset_tbl.i.i202, i64 %hash.i.i.i206
  %offset.i.i208 = load i32, ptr %offset_ptr.i.i207, align 4
  %208 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract84, 0
  %209 = insertvalue { ptr, ptr, ptr, i32 } %208, ptr %206, 1
  %210 = insertvalue { ptr, ptr, ptr, i32 } %209, ptr %207, 2
  %211 = insertvalue { ptr, ptr, ptr, i32 } %210, i32 %offset.i.i208, 3
  %212 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %213 = load ptr, ptr %22, align 8
  %214 = call ptr %213(ptr %.fca.1.extract43)
  %215 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %216 = load ptr, ptr %26, align 8
  %217 = call ptr %216(ptr %.fca.1.extract43)
  %218 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %219 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract84)
  %220 = sext i32 %offset.i.i208 to i64
  %221 = getelementptr ptr, ptr %.fca.0.extract84, i64 %220
  %222 = getelementptr i8, ptr %221, i64 64
  %223 = load ptr, ptr %222, align 8
  %224 = call ptr %223({ ptr, ptr, ptr, i32 } %211, ptr nonnull %5)
  %225 = call i32 %224({ ptr, ptr, ptr, i32 } %211, { ptr, ptr, ptr, i32 } %211, ptr nonnull %5)
  %226 = icmp eq i32 %225, %36
  %227 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %228 = load ptr, ptr %22, align 8
  %229 = call ptr %228(ptr %.fca.1.extract43)
  %230 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %231 = load ptr, ptr %26, align 8
  %232 = call ptr %231(ptr %.fca.1.extract43)
  %233 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %234 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract84)
  %235 = getelementptr i8, ptr %221, i64 48
  %236 = load ptr, ptr %235, align 8
  %237 = call ptr %236({ ptr, ptr, ptr, i32 } %211, ptr nonnull %5)
  %238 = call { ptr, i160 } %237({ ptr, ptr, ptr, i32 } %211, { ptr, ptr, ptr, i32 } %211, ptr nonnull %5)
  %239 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %240 = getelementptr i8, ptr %22, i64 56
  %241 = load ptr, ptr %240, align 8
  %242 = load ptr, ptr %241, align 8
  %243 = call { ptr } %242(ptr %.fca.1.extract43)
  %.fca.0.extract69 = extractvalue { ptr } %243, 0
  %244 = call i1 %.fca.0.extract69({ ptr, i160 } %238, { ptr, i160 } %3)
  %245 = and i1 %226, %244
  br i1 %245, label %246, label %.thread365

246:                                              ; preds = %205
  %247 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %248 = load ptr, ptr %22, align 8
  %249 = call ptr %248(ptr %.fca.1.extract43)
  %250 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %251 = load ptr, ptr %26, align 8
  %252 = call ptr %251(ptr %.fca.1.extract43)
  %253 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %254 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract84)
  %255 = getelementptr i8, ptr %221, i64 56
  %256 = load ptr, ptr %255, align 8
  %257 = call ptr %256({ ptr, ptr, ptr, i32 } %211, ptr nonnull %5)
  %258 = call { ptr, i160 } %257({ ptr, ptr, ptr, i32 } %211, { ptr, ptr, ptr, i32 } %211, ptr nonnull %5)
  %259 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %260 = load ptr, ptr %181, align 8
  %261 = load ptr, ptr %260, align 8
  %262 = call { ptr, ptr, ptr, i32 } %261(ptr %.fca.1.extract43)
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %262, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %262, 1
  %.fca.2.extract55 = extractvalue { ptr, ptr, ptr, i32 } %262, 2
  %.fca.3.extract57 = extractvalue { ptr, ptr, ptr, i32 } %262, 3
  %hash_coef_ptr.i.i211 = getelementptr i8, ptr %.fca.0.extract51, i64 8
  %tbl_size_ptr.i.i212 = getelementptr i8, ptr %.fca.0.extract51, i64 16
  %offset_tbl_ptr.i.i213 = getelementptr i8, ptr %.fca.0.extract51, i64 40
  %hash_coef.i.i214 = load i64, ptr %hash_coef_ptr.i.i211, align 4
  %tbl_size.i.i215 = load i64, ptr %tbl_size_ptr.i.i212, align 4
  %offset_tbl.i.i216 = load ptr, ptr %offset_tbl_ptr.i.i213, align 8
  %product.i.i.i217 = mul i64 %hash_coef.i.i214, -5261542750394134544
  %shifted.i.i.i218 = lshr i64 %product.i.i.i217, 32
  %xored.i.i.i219 = xor i64 %shifted.i.i.i218, %product.i.i.i217
  %hash.i.i.i220 = and i64 %xored.i.i.i219, %tbl_size.i.i215
  %offset_ptr.i.i221 = getelementptr i32, ptr %offset_tbl.i.i216, i64 %hash.i.i.i220
  %offset.i.i222 = load i32, ptr %offset_ptr.i.i221, align 4
  %eq.i225 = icmp eq i32 %.fca.3.extract57, %offset.i.i222
  call void @llvm.assume(i1 %eq.i225) #30
  %263 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract51, 0
  %264 = insertvalue { ptr, ptr, ptr, i32 } %263, ptr %.fca.1.extract53, 1
  %265 = insertvalue { ptr, ptr, ptr, i32 } %264, ptr %.fca.2.extract55, 2
  %266 = insertvalue { ptr, ptr, ptr, i32 } %265, i32 %.fca.3.extract57, 3
  %267 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %268 = load ptr, ptr %22, align 8
  %269 = call ptr %268(ptr %.fca.1.extract43)
  %270 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %271 = load ptr, ptr %26, align 8
  %272 = call ptr %271(ptr %.fca.1.extract43)
  store ptr @_parameterization_Ptri32, ptr %14, align 8
  %273 = getelementptr inbounds i8, ptr %14, i64 8
  store ptr @_parameterization_Nil, ptr %273, align 8
  %274 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %14)
  %275 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract51)
  %276 = sext i32 %.fca.3.extract57 to i64
  %277 = getelementptr ptr, ptr %.fca.0.extract51, i64 %276
  %278 = getelementptr i8, ptr %277, i64 128
  %279 = load ptr, ptr %278, align 8
  store ptr @i32_typ, ptr %15, align 8
  %280 = getelementptr inbounds i8, ptr %15, i64 8
  store ptr @nil_typ, ptr %280, align 8
  %281 = call ptr %279({ ptr, ptr, ptr, i32 } %266, ptr nonnull %15)
  call void %281({ ptr, ptr, ptr, i32 } %266, { ptr, ptr, ptr, i32 } %266, ptr nonnull %14, i32 %179, { ptr, i160 } { ptr @nil_typ, i160 undef })
  br label %.thread365.sink.split

.thread365.sink.split:                            ; preds = %119, %246
  %.pn = phi { ptr, i160 } [ %258, %246 ], [ %131, %119 ]
  %.reg2mem34.sroa.3.0.ph = extractvalue { ptr, i160 } %.pn, 1
  %.reg2mem34.sroa.0.0.ph = extractvalue { ptr, i160 } %.pn, 0
  %282 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %283 = getelementptr i8, ptr %22, i64 40
  %284 = load ptr, ptr %283, align 8
  %285 = load ptr, ptr %284, align 8
  %286 = call i32 %285(ptr %.fca.1.extract43)
  %287 = add i32 %286, -1
  %288 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull %.fca.0.extract41)
  %289 = load ptr, ptr %283, align 8
  %290 = getelementptr i8, ptr %289, i64 8
  %291 = load ptr, ptr %290, align 8
  call void %291(ptr %.fca.1.extract43, i32 %287)
  br label %.thread365

.thread365:                                       ; preds = %.thread365.sink.split, %155, %205
  %.reg2mem34.sroa.0.0 = phi ptr [ @nil_typ, %205 ], [ @nil_typ, %155 ], [ %.reg2mem34.sroa.0.0.ph, %.thread365.sink.split ]
  %.reg2mem34.sroa.3.0 = phi i160 [ poison, %205 ], [ poison, %155 ], [ %.reg2mem34.sroa.3.0.ph, %.thread365.sink.split ]
  %.reload35.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem34.sroa.0.0, 0
  %.reload35.fca.1.insert = insertvalue { ptr, i160 } %.reload35.fca.0.insert, i160 %.reg2mem34.sroa.3.0, 1
  ret { ptr, i160 } %.reload35.fca.1.insert
}

define void @HashMap_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = tail call ptr %7(ptr %.fca.1.extract)
  %9 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %10 = getelementptr i8, ptr %6, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call ptr %11(ptr %.fca.1.extract)
  %result.i = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %13 = getelementptr i8, ptr %result.i, i64 16
  store ptr @_parameterization_Nil, ptr %13, align 8
  %result.i1 = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %14 = getelementptr i8, ptr %result.i1, i64 16
  store ptr %12, ptr %14, align 8
  %15 = getelementptr i8, ptr %result.i1, i64 8
  store ptr %8, ptr %15, align 8
  %16 = getelementptr i8, ptr %result.i1, i64 24
  store ptr null, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i1)
  store ptr @Entry, ptr %result.i1, align 8
  %18 = getelementptr i8, ptr %result.i, i64 8
  store ptr %result.i1, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %19, align 8
  %20 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @union_typ, ptr %result.i, align 8
  %result.i2 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i, ptr %result.i2, align 8
  %21 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i2)
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 9, 3
  %25 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %26 = load ptr, ptr %6, align 8
  %27 = tail call ptr %26(ptr %.fca.1.extract)
  %28 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %29 = load ptr, ptr %10, align 8
  %30 = tail call ptr %29(ptr %.fca.1.extract)
  %31 = getelementptr i8, ptr %result.i2, i64 16
  store i32 8, ptr %31, align 4
  %32 = getelementptr i8, ptr %result.i2, i64 20
  store i32 8, ptr %32, align 4
  %result.i.i = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %33 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %34 = getelementptr i8, ptr %result.i2, i64 8
  store ptr %result.i.i, ptr %34, align 8
  %35 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %36 = getelementptr i8, ptr %6, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  tail call void %39(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %24)
  %40 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %41 = load ptr, ptr %6, align 8
  %42 = tail call ptr %41(ptr %.fca.1.extract)
  %43 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %44 = load ptr, ptr %10, align 8
  %45 = tail call ptr %44(ptr %.fca.1.extract)
  %result.i17 = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %46 = getelementptr i8, ptr %result.i17, i64 16
  store ptr @_parameterization_Nil, ptr %46, align 8
  %result.i18 = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %47 = getelementptr i8, ptr %result.i18, i64 16
  store ptr %45, ptr %47, align 8
  %48 = getelementptr i8, ptr %result.i18, i64 8
  store ptr %42, ptr %48, align 8
  %49 = getelementptr i8, ptr %result.i18, i64 24
  store ptr null, ptr %49, align 8
  %50 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i18)
  store ptr @Entry, ptr %result.i18, align 8
  %51 = getelementptr i8, ptr %result.i17, i64 8
  store ptr %result.i18, ptr %51, align 8
  %52 = getelementptr i8, ptr %result.i17, i64 24
  store ptr null, ptr %52, align 8
  %53 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i17)
  store ptr @union_typ, ptr %result.i17, align 8
  %result.i19 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i17, ptr %result.i19, align 8
  %54 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i19)
  %55 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i19, 1
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr undef, 2
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 9, 3
  %58 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %59 = load ptr, ptr %6, align 8
  %60 = tail call ptr %59(ptr %.fca.1.extract)
  %61 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %62 = load ptr, ptr %10, align 8
  %63 = tail call ptr %62(ptr %.fca.1.extract)
  %64 = getelementptr i8, ptr %result.i19, i64 16
  store i32 8, ptr %64, align 4
  %65 = getelementptr i8, ptr %result.i19, i64 20
  store i32 8, ptr %65, align 4
  %result.i.i85 = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %66 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %67 = getelementptr i8, ptr %result.i19, i64 8
  store ptr %result.i.i85, ptr %67, align 8
  %68 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %69 = getelementptr i8, ptr %6, i64 32
  %70 = load ptr, ptr %69, align 8
  %71 = getelementptr i8, ptr %70, i64 8
  %72 = load ptr, ptr %71, align 8
  tail call void %72(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %57)
  %73 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %74 = getelementptr i8, ptr %6, i64 40
  %75 = load ptr, ptr %74, align 8
  %76 = getelementptr i8, ptr %75, i64 8
  %77 = load ptr, ptr %76, align 8
  tail call void %77(ptr %.fca.1.extract, i32 0)
  ret void
}

define i32 @HashMap_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 40
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract)
  ret i32 %10
}

define { ptr, ptr, ptr, i32 } @HashMap_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract25)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract25, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract27)
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i34 = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i35 = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i36 = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i37 = load i64, ptr %hash_coef_ptr.i.i34, align 4
  %tbl_size.i.i38 = load i64, ptr %tbl_size_ptr.i.i35, align 4
  %offset_tbl.i.i39 = load ptr, ptr %offset_tbl_ptr.i.i36, align 8
  %product.i.i.i40 = mul i64 %hash_coef.i.i37, -5261542750394134544
  %shifted.i.i.i41 = lshr i64 %product.i.i.i40, 32
  %xored.i.i.i42 = xor i64 %shifted.i.i.i41, %product.i.i.i40
  %hash.i.i.i43 = and i64 %xored.i.i.i42, %tbl_size.i.i38
  %offset_ptr.i.i44 = getelementptr i32, ptr %offset_tbl.i.i39, i64 %hash.i.i.i43
  %offset.i.i45 = load i32, ptr %offset_ptr.i.i44, align 4
  %eq.i = icmp eq i32 %.fca.3.extract23, %offset.i.i45
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract25)
  %13 = getelementptr i8, ptr %7, i64 32
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call { ptr, ptr, ptr, i32 } %15(ptr %.fca.1.extract27)
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %16, 3
  %hash_coef_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i49 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i50 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i51 = load i64, ptr %hash_coef_ptr.i.i48, align 4
  %tbl_size.i.i52 = load i64, ptr %tbl_size_ptr.i.i49, align 4
  %offset_tbl.i.i53 = load ptr, ptr %offset_tbl_ptr.i.i50, align 8
  %product.i.i.i54 = mul i64 %hash_coef.i.i51, -5261542750394134544
  %shifted.i.i.i55 = lshr i64 %product.i.i.i54, 32
  %xored.i.i.i56 = xor i64 %shifted.i.i.i55, %product.i.i.i54
  %hash.i.i.i57 = and i64 %xored.i.i.i56, %tbl_size.i.i52
  %offset_ptr.i.i58 = getelementptr i32, ptr %offset_tbl.i.i53, i64 %hash.i.i.i57
  %offset.i.i59 = load i32, ptr %offset_ptr.i.i58, align 4
  %eq.i62 = icmp eq i32 %.fca.3.extract15, %offset.i.i59
  tail call void @llvm.assume(i1 %eq.i62) #30
  %17 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract25)
  %18 = load ptr, ptr %7, align 8
  %19 = tail call ptr %18(ptr %.fca.1.extract27)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract25)
  %21 = getelementptr i8, ptr %7, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = tail call ptr %22(ptr %.fca.1.extract27)
  %result.i = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %24 = getelementptr i8, ptr %result.i, i64 16
  store ptr %23, ptr %24, align 8
  %25 = getelementptr i8, ptr %result.i, i64 8
  store ptr %19, ptr %25, align 8
  %26 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %26, align 8
  %27 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @Pair, ptr %result.i, align 8
  %result.i63 = tail call noalias dereferenceable_or_null(104) ptr @bump_malloc_inner(i64 noundef 104, ptr nonnull @current_ptr) #29
  store ptr %19, ptr %result.i63, align 8
  %28 = getelementptr i8, ptr %result.i63, i64 8
  store ptr %23, ptr %28, align 8
  %29 = getelementptr i8, ptr %result.i63, i64 16
  store ptr %result.i, ptr %29, align 8
  %30 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i63)
  %31 = alloca { ptr, ptr, ptr, i32 }, align 8
  %32 = getelementptr inbounds i8, ptr %31, i64 8
  %33 = getelementptr inbounds i8, ptr %31, i64 24
  store ptr @HashMapIterator, ptr %31, align 8
  store ptr %result.i63, ptr %32, align 8
  store i32 9, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %31)
  %35 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract25)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = tail call { ptr, ptr, ptr, i32 } %37(ptr %.fca.1.extract27)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %hash_coef_ptr.i.i65 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i66 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i68 = load i64, ptr %hash_coef_ptr.i.i65, align 4
  %tbl_size.i.i69 = load i64, ptr %tbl_size_ptr.i.i66, align 4
  %offset_tbl.i.i70 = load ptr, ptr %offset_tbl_ptr.i.i67, align 8
  %product.i.i.i71 = mul i64 %hash_coef.i.i68, -5261542750394134544
  %shifted.i.i.i72 = lshr i64 %product.i.i.i71, 32
  %xored.i.i.i73 = xor i64 %shifted.i.i.i72, %product.i.i.i71
  %hash.i.i.i74 = and i64 %xored.i.i.i73, %tbl_size.i.i69
  %offset_ptr.i.i75 = getelementptr i32, ptr %offset_tbl.i.i70, i64 %hash.i.i.i74
  %offset.i.i76 = load i32, ptr %offset_ptr.i.i75, align 4
  %eq.i79 = icmp eq i32 %.fca.3.extract7, %offset.i.i76
  tail call void @llvm.assume(i1 %eq.i79) #30
  %39 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract25)
  %40 = load ptr, ptr %13, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = tail call { ptr, ptr, ptr, i32 } %41(ptr %.fca.1.extract27)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %42, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %42, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %42, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %42, 3
  %hash_coef_ptr.i.i81 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i82 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i83 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i84 = load i64, ptr %hash_coef_ptr.i.i81, align 4
  %tbl_size.i.i85 = load i64, ptr %tbl_size_ptr.i.i82, align 4
  %offset_tbl.i.i86 = load ptr, ptr %offset_tbl_ptr.i.i83, align 8
  %product.i.i.i87 = mul i64 %hash_coef.i.i84, -5261542750394134544
  %shifted.i.i.i88 = lshr i64 %product.i.i.i87, 32
  %xored.i.i.i89 = xor i64 %shifted.i.i.i88, %product.i.i.i87
  %hash.i.i.i90 = and i64 %xored.i.i.i89, %tbl_size.i.i85
  %offset_ptr.i.i91 = getelementptr i32, ptr %offset_tbl.i.i86, i64 %hash.i.i.i90
  %offset.i.i92 = load i32, ptr %offset_ptr.i.i91, align 4
  %eq.i95 = icmp eq i32 %.fca.3.extract, %offset.i.i92
  tail call void @llvm.assume(i1 %eq.i95) #30
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract3, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract5, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i63, 1
  %47 = getelementptr inbounds i8, ptr %31, i64 16
  %48 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract25)
  %49 = load ptr, ptr %7, align 8
  %50 = tail call ptr %49(ptr %.fca.1.extract27)
  %51 = tail call ptr @llvm.invariant.start.p0(i64 624, ptr %.fca.0.extract25)
  %52 = load ptr, ptr %21, align 8
  %53 = tail call ptr %52(ptr %.fca.1.extract27)
  %54 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull @HashMapIterator)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %4)
  %hash_coef.i.i37.i = load i64, ptr %hash_coef_ptr.i.i65, align 4
  %tbl_size.i.i38.i = load i64, ptr %tbl_size_ptr.i.i66, align 4
  %offset_tbl.i.i39.i = load ptr, ptr %offset_tbl_ptr.i.i67, align 8
  %product.i.i.i40.i = mul i64 %hash_coef.i.i37.i, -5261542750394134544
  %shifted.i.i.i41.i = lshr i64 %product.i.i.i40.i, 32
  %xored.i.i.i42.i = xor i64 %shifted.i.i.i41.i, %product.i.i.i40.i
  %hash.i.i.i43.i = and i64 %xored.i.i.i42.i, %tbl_size.i.i38.i
  %offset_ptr.i.i44.i = getelementptr i32, ptr %offset_tbl.i.i39.i, i64 %hash.i.i.i43.i
  %offset.i.i59.i = load i32, ptr %offset_ptr.i.i44.i, align 4
  %55 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull @HashMapIterator)
  %56 = getelementptr i8, ptr %result.i63, i64 24
  store ptr %.fca.0.extract1, ptr %56, align 8
  %57 = getelementptr i8, ptr %result.i63, i64 32
  store ptr %.fca.1.extract3, ptr %57, align 8
  %58 = getelementptr i8, ptr %result.i63, i64 40
  store ptr %.fca.2.extract5, ptr %58, align 8
  %59 = getelementptr i8, ptr %result.i63, i64 48
  store i32 %offset.i.i59.i, ptr %59, align 4
  %hash_coef.i.i65.i = load i64, ptr %hash_coef_ptr.i.i81, align 4
  %tbl_size.i.i66.i = load i64, ptr %tbl_size_ptr.i.i82, align 4
  %offset_tbl.i.i67.i = load ptr, ptr %offset_tbl_ptr.i.i83, align 8
  %product.i.i.i68.i = mul i64 %hash_coef.i.i65.i, -5261542750394134544
  %shifted.i.i.i69.i = lshr i64 %product.i.i.i68.i, 32
  %xored.i.i.i70.i = xor i64 %shifted.i.i.i69.i, %product.i.i.i68.i
  %hash.i.i.i71.i = and i64 %xored.i.i.i70.i, %tbl_size.i.i66.i
  %offset_ptr.i.i72.i = getelementptr i32, ptr %offset_tbl.i.i67.i, i64 %hash.i.i.i71.i
  %offset.i.i87.i = load i32, ptr %offset_ptr.i.i72.i, align 4
  %60 = getelementptr i8, ptr %result.i63, i64 56
  store ptr %.fca.0.extract, ptr %60, align 8
  %61 = getelementptr i8, ptr %result.i63, i64 64
  store ptr %.fca.1.extract, ptr %61, align 8
  %62 = getelementptr i8, ptr %result.i63, i64 72
  store ptr %.fca.2.extract, ptr %62, align 8
  %63 = getelementptr i8, ptr %result.i63, i64 80
  store i32 %offset.i.i87.i, ptr %63, align 4
  %64 = getelementptr i8, ptr %result.i63, i64 92
  store i32 0, ptr %64, align 4
  %65 = getelementptr i8, ptr %result.i63, i64 88
  store i32 1, ptr %65, align 4
  %66 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull @HashMapIterator)
  %67 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %offset.i.i59.i, 3
  %hash_coef.i.i93.i = load i64, ptr %hash_coef_ptr.i.i65, align 4
  %tbl_size.i.i94.i = load i64, ptr %tbl_size_ptr.i.i66, align 4
  %offset_tbl.i.i95.i = load ptr, ptr %offset_tbl_ptr.i.i67, align 8
  %product.i.i.i96.i = mul i64 %hash_coef.i.i93.i, -5261542750394134544
  %shifted.i.i.i97.i = lshr i64 %product.i.i.i96.i, 32
  %xored.i.i.i98.i = xor i64 %shifted.i.i.i97.i, %product.i.i.i96.i
  %hash.i.i.i99.i = and i64 %xored.i.i.i98.i, %tbl_size.i.i94.i
  %offset_ptr.i.i100.i = getelementptr i32, ptr %offset_tbl.i.i95.i, i64 %hash.i.i.i99.i
  %offset.i.i101.i = load i32, ptr %offset_ptr.i.i100.i, align 4
  %eq.i.i = icmp eq i32 %offset.i.i59.i, %offset.i.i101.i
  tail call void @llvm.assume(i1 %eq.i.i) #30
  %68 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %69 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract1)
  %70 = sext i32 %offset.i.i59.i to i64
  %71 = getelementptr ptr, ptr %.fca.0.extract1, i64 %70
  %72 = getelementptr i8, ptr %71, i64 64
  %73 = load ptr, ptr %72, align 8
  %74 = call ptr %73({ ptr, ptr, ptr, i32 } %67, ptr nonnull %4)
  %75 = call i32 %74({ ptr, ptr, ptr, i32 } %67, { ptr, ptr, ptr, i32 } %67, ptr nonnull %4)
  %76 = getelementptr i8, ptr %result.i63, i64 96
  store i32 %75, ptr %76, align 4
  %77 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull @HashMapIterator)
  %78 = load ptr, ptr %60, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = load ptr, ptr %61, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 1
  %82 = load ptr, ptr %62, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %82, 2
  %84 = load i32, ptr %63, align 4
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %84, 3
  %hash_coef_ptr.i.i104.i = getelementptr i8, ptr %78, i64 8
  %tbl_size_ptr.i.i105.i = getelementptr i8, ptr %78, i64 16
  %offset_tbl_ptr.i.i106.i = getelementptr i8, ptr %78, i64 40
  %hash_coef.i.i107.i = load i64, ptr %hash_coef_ptr.i.i104.i, align 4
  %tbl_size.i.i108.i = load i64, ptr %tbl_size_ptr.i.i105.i, align 4
  %offset_tbl.i.i109.i = load ptr, ptr %offset_tbl_ptr.i.i106.i, align 8
  %product.i.i.i110.i = mul i64 %hash_coef.i.i107.i, -5261542750394134544
  %shifted.i.i.i111.i = lshr i64 %product.i.i.i110.i, 32
  %xored.i.i.i112.i = xor i64 %shifted.i.i.i111.i, %product.i.i.i110.i
  %hash.i.i.i113.i = and i64 %xored.i.i.i112.i, %tbl_size.i.i108.i
  %offset_ptr.i.i114.i = getelementptr i32, ptr %offset_tbl.i.i109.i, i64 %hash.i.i.i113.i
  %offset.i.i115.i = load i32, ptr %offset_ptr.i.i114.i, align 4
  %eq.i118.i = icmp eq i32 %84, %offset.i.i115.i
  call void @llvm.assume(i1 %eq.i118.i) #30
  %86 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %87 = call ptr @llvm.invariant.start.p0(i64 600, ptr %78)
  %88 = sext i32 %84 to i64
  %89 = getelementptr ptr, ptr %78, i64 %88
  %90 = getelementptr i8, ptr %89, i64 64
  %91 = load ptr, ptr %90, align 8
  %92 = call ptr %91({ ptr, ptr, ptr, i32 } %85, ptr nonnull %4)
  %93 = call i32 %92({ ptr, ptr, ptr, i32 } %85, { ptr, ptr, ptr, i32 } %85, ptr nonnull %4)
  %94 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull @HashMapIterator)
  %95 = getelementptr i8, ptr %result.i63, i64 100
  store i32 %93, ptr %95, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %4)
  %96 = load ptr, ptr %47, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %96, 2
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, i32 22, 3
  ret { ptr, ptr, ptr, i32 } %98
}

define linkonce_odr { ptr, i160 } @_box_union_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @union_typ, ptr %3, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %2 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %2 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 48
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = tail call i64 @llvm.umax.i64(i64 %20, i64 %19)
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %.lr.ph.._crit_edge_crit_edge.i, label %.lr.ph.i

.lr.ph.._crit_edge_crit_edge.i:                   ; preds = %.lr.ph.i
  %26 = add i64 %21, 8
  br label %_size_union_typ.exit

_size_union_typ.exit:                             ; preds = %2, %.lr.ph.._crit_edge_crit_edge.i
  %.reg2mem22.0.lcssa.reg2mem.0.i = phi i64 [ %26, %.lr.ph.._crit_edge_crit_edge.i ], [ 8, %2 ]
  %.reg2mem20.0.lcssa.reg2mem.0.i = phi i64 [ %15, %.lr.ph.._crit_edge_crit_edge.i ], [ 1, %2 ]
  %27 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0.i, %.reg2mem20.0.lcssa.reg2mem.0.i
  %28 = icmp eq i64 %27, 0
  %29 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0.i, %27
  %30 = select i1 %28, i64 0, i64 %29
  %31 = add i64 %30, %.reg2mem22.0.lcssa.reg2mem.0.i
  %32 = icmp eq i64 %31, 32
  br i1 %32, label %._crit_edge, label %33

._crit_edge:                                      ; preds = %33, %_size_union_typ.exit
  %.reg2mem9.0 = phi ptr [ %3, %_size_union_typ.exit ], [ %4, %33 ]
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nonnull align 1 %.reg2mem9.0, ptr align 1 %0, i64 %31, i1 false)
  %.pre = load ptr, ptr %3, align 8
  br label %36

33:                                               ; preds = %_size_union_typ.exit
  %34 = icmp slt i64 %31, 17
  br i1 %34, label %._crit_edge, label %35

35:                                               ; preds = %33
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %31, ptr nonnull @current_ptr) #29
  tail call void @llvm.memcpy.inline.p0.p0.i64(ptr align 1 %result.i, ptr align 1 %0, i64 %31, i1 false)
  store ptr %result.i, ptr %4, align 8
  br label %36

36:                                               ; preds = %35, %._crit_edge
  %37 = phi ptr [ @union_typ, %35 ], [ %.pre, %._crit_edge ]
  %38 = insertvalue { ptr, i160 } undef, ptr %37, 0
  %39 = load i160, ptr %4, align 8
  %40 = insertvalue { ptr, i160 } %38, i160 %39, 1
  ret { ptr, i160 } %40
}

define linkonce_odr { i64, i64 } @_size_nil_typ(ptr %0) {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

define linkonce_odr { ptr, i160 } @_box_nil_typ(ptr %0, ptr %1) {
  ret { ptr, i160 } { ptr @nil_typ, i160 undef }
}

define linkonce_odr void @_unbox_nil_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_HashMapIterator(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 104, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMapIterator_B_init_map_table1ArrayEntryK._V_or_Nil_map_table2ArrayEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @HashMapIterator_init_map_table1ArrayEntryK._V_or_Nil_map_table2ArrayEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -704669437586349537
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i34 = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i35 = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i36 = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i37 = load i64, ptr %hash_coef_ptr.i.i34, align 4
  %tbl_size.i.i38 = load i64, ptr %tbl_size_ptr.i.i35, align 4
  %offset_tbl.i.i39 = load ptr, ptr %offset_tbl_ptr.i.i36, align 8
  %product.i.i.i40 = mul i64 %hash_coef.i.i37, -5261542750394134544
  %shifted.i.i.i41 = lshr i64 %product.i.i.i40, 32
  %xored.i.i.i42 = xor i64 %shifted.i.i.i41, %product.i.i.i40
  %hash.i.i.i43 = and i64 %xored.i.i.i42, %tbl_size.i.i38
  %offset_ptr.i.i44 = getelementptr i32, ptr %offset_tbl.i.i39, i64 %hash.i.i.i43
  %offset.i.i59 = load i32, ptr %offset_ptr.i.i44, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract25, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract19, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract21, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i59, 3
  tail call void %13(ptr %.fca.1.extract27, { ptr, ptr, ptr, i32 } %17)
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i62 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i63 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i64 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i65 = load i64, ptr %hash_coef_ptr.i.i62, align 4
  %tbl_size.i.i66 = load i64, ptr %tbl_size_ptr.i.i63, align 4
  %offset_tbl.i.i67 = load ptr, ptr %offset_tbl_ptr.i.i64, align 8
  %product.i.i.i68 = mul i64 %hash_coef.i.i65, -5261542750394134544
  %shifted.i.i.i69 = lshr i64 %product.i.i.i68, 32
  %xored.i.i.i70 = xor i64 %shifted.i.i.i69, %product.i.i.i68
  %hash.i.i.i71 = and i64 %xored.i.i.i70, %tbl_size.i.i66
  %offset_ptr.i.i72 = getelementptr i32, ptr %offset_tbl.i.i67, i64 %hash.i.i.i71
  %offset.i.i87 = load i32, ptr %offset_ptr.i.i72, align 4
  %18 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %19 = getelementptr i8, ptr %9, i64 32
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract11, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract13, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i87, 3
  tail call void %22(ptr %.fca.1.extract27, { ptr, ptr, ptr, i32 } %26)
  %27 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %28 = getelementptr i8, ptr %9, i64 48
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  tail call void %31(ptr %.fca.1.extract27, i32 0)
  %32 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %33 = getelementptr i8, ptr %9, i64 40
  %34 = load ptr, ptr %33, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  tail call void %36(ptr %.fca.1.extract27, i32 1)
  %37 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %38 = load ptr, ptr %10, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = tail call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract27)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %hash_coef_ptr.i.i90 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i91 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i92 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i93 = load i64, ptr %hash_coef_ptr.i.i90, align 4
  %tbl_size.i.i94 = load i64, ptr %tbl_size_ptr.i.i91, align 4
  %offset_tbl.i.i95 = load ptr, ptr %offset_tbl_ptr.i.i92, align 8
  %product.i.i.i96 = mul i64 %hash_coef.i.i93, -5261542750394134544
  %shifted.i.i.i97 = lshr i64 %product.i.i.i96, 32
  %xored.i.i.i98 = xor i64 %shifted.i.i.i97, %product.i.i.i96
  %hash.i.i.i99 = and i64 %xored.i.i.i98, %tbl_size.i.i94
  %offset_ptr.i.i100 = getelementptr i32, ptr %offset_tbl.i.i95, i64 %hash.i.i.i99
  %offset.i.i101 = load i32, ptr %offset_ptr.i.i100, align 4
  %eq.i = icmp eq i32 %.fca.3.extract7, %offset.i.i101
  tail call void @llvm.assume(i1 %eq.i) #30
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract3, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract5, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract7, 3
  %45 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %46 = load ptr, ptr %9, align 8
  %47 = tail call ptr %46(ptr %.fca.1.extract27)
  %48 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %49 = getelementptr i8, ptr %9, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = tail call ptr %50(ptr %.fca.1.extract27)
  %52 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %53 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract1)
  %54 = sext i32 %.fca.3.extract7 to i64
  %55 = getelementptr ptr, ptr %.fca.0.extract1, i64 %54
  %56 = getelementptr i8, ptr %55, i64 64
  %57 = load ptr, ptr %56, align 8
  %58 = call ptr %57({ ptr, ptr, ptr, i32 } %44, ptr nonnull %6)
  %59 = call i32 %58({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull %6)
  %60 = call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %61 = getelementptr i8, ptr %9, i64 56
  %62 = load ptr, ptr %61, align 8
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  call void %64(ptr %.fca.1.extract27, i32 %59)
  %65 = call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %66 = load ptr, ptr %19, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr, ptr, ptr, i32 } %67(ptr %.fca.1.extract27)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %68, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %68, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %68, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %68, 3
  %hash_coef_ptr.i.i104 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i105 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i106 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i107 = load i64, ptr %hash_coef_ptr.i.i104, align 4
  %tbl_size.i.i108 = load i64, ptr %tbl_size_ptr.i.i105, align 4
  %offset_tbl.i.i109 = load ptr, ptr %offset_tbl_ptr.i.i106, align 8
  %product.i.i.i110 = mul i64 %hash_coef.i.i107, -5261542750394134544
  %shifted.i.i.i111 = lshr i64 %product.i.i.i110, 32
  %xored.i.i.i112 = xor i64 %shifted.i.i.i111, %product.i.i.i110
  %hash.i.i.i113 = and i64 %xored.i.i.i112, %tbl_size.i.i108
  %offset_ptr.i.i114 = getelementptr i32, ptr %offset_tbl.i.i109, i64 %hash.i.i.i113
  %offset.i.i115 = load i32, ptr %offset_ptr.i.i114, align 4
  %eq.i118 = icmp eq i32 %.fca.3.extract, %offset.i.i115
  call void @llvm.assume(i1 %eq.i118) #30
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %.fca.1.extract, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %.fca.2.extract, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %.fca.3.extract, 3
  %73 = call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %74 = load ptr, ptr %9, align 8
  %75 = call ptr %74(ptr %.fca.1.extract27)
  %76 = call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %77 = load ptr, ptr %49, align 8
  %78 = call ptr %77(ptr %.fca.1.extract27)
  %79 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %80 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %81 = sext i32 %.fca.3.extract to i64
  %82 = getelementptr ptr, ptr %.fca.0.extract, i64 %81
  %83 = getelementptr i8, ptr %82, i64 64
  %84 = load ptr, ptr %83, align 8
  %85 = call ptr %84({ ptr, ptr, ptr, i32 } %72, ptr nonnull %6)
  %86 = call i32 %85({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull %6)
  %87 = call ptr @llvm.invariant.start.p0(i64 128, ptr %.fca.0.extract25)
  %88 = getelementptr i8, ptr %9, i64 64
  %89 = load ptr, ptr %88, align 8
  %90 = getelementptr i8, ptr %89, i64 8
  %91 = load ptr, ptr %90, align 8
  call void %91(ptr %.fca.1.extract27, i32 %86)
  ret void
}

define { ptr, i160 } @HashMapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.sroa.3268 = alloca i160, align 8
  %.sroa.0457 = alloca ptr, align 8
  %.sroa.1458 = alloca [20 x i8], align 8
  %.sroa.0265 = alloca ptr, align 8
  %.sroa.2266 = alloca i160, align 8
  %.sroa.0257 = alloca ptr, align 8
  %.sroa.1258 = alloca i160, align 8
  %.sroa.0255 = alloca ptr, align 8
  %.sroa.2256 = alloca i160, align 8
  %.sroa.0247 = alloca ptr, align 8
  %.sroa.1248 = alloca i160, align 8
  %.sroa.0454 = alloca ptr, align 8
  %.sroa.1455 = alloca ptr, align 8
  %.sroa.3456 = alloca ptr, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.sroa.0245 = alloca ptr, align 8
  %.sroa.2246 = alloca i160, align 8
  %.sroa.0237 = alloca ptr, align 8
  %.sroa.2238 = alloca i160, align 8
  %.sroa.0235 = alloca ptr, align 8
  %.sroa.2236 = alloca i160, align 8
  %.sroa.0227 = alloca ptr, align 8
  %.sroa.2228 = alloca i160, align 8
  %.sroa.0225 = alloca ptr, align 8
  %.sroa.2226 = alloca i160, align 8
  %.sroa.0223 = alloca ptr, align 8
  %.sroa.2224 = alloca i160, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %.sroa.3 = alloca i160, align 8
  %.sroa.0449 = alloca ptr, align 8
  %.sroa.1450 = alloca [20 x i8], align 8
  %.sroa.0446 = alloca ptr, align 8
  %.sroa.1447 = alloca i160, align 8
  %.sroa.0154 = alloca ptr, align 8
  %.sroa.1155 = alloca i160, align 8
  %.sroa.0444 = alloca ptr, align 8
  %.sroa.1445 = alloca i160, align 8
  %.sroa.0141 = alloca ptr, align 8
  %.sroa.1 = alloca i160, align 8
  %.sroa.0441 = alloca ptr, align 8
  %.sroa.1442 = alloca ptr, align 8
  %.sroa.3443 = alloca ptr, align 8
  %12 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.sroa.0433 = alloca ptr, align 8
  %.sroa.1434 = alloca i160, align 8
  %.sroa.0101 = alloca ptr, align 8
  %.sroa.2102 = alloca i160, align 8
  %.sroa.0431 = alloca ptr, align 8
  %.sroa.1432 = alloca i160, align 8
  %.sroa.081 = alloca ptr, align 8
  %.sroa.282 = alloca i160, align 8
  %.sroa.069 = alloca ptr, align 8
  %.sroa.270 = alloca i160, align 8
  %.sroa.0 = alloca ptr, align 8
  %.sroa.2 = alloca i160, align 8
  %13 = alloca [2 x ptr], align 8
  %14 = alloca { ptr, ptr }, align 8
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  %16 = alloca [1 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -704669437586349537
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.reg2mem552.0.sroa.gep43 = getelementptr inbounds i8, ptr %9, i64 8
  %.reg2mem552.0.sroa.gep44 = getelementptr inbounds i8, ptr %14, i64 8
  %.reg2mem554.0.sroa.gep47 = getelementptr inbounds i8, ptr %8, i64 8
  %.reg2mem554.0.sroa.gep48 = getelementptr inbounds i8, ptr %13, i64 8
  %.reg2mem576.0.sroa.gep = getelementptr inbounds i8, ptr %7, i64 8
  %.reg2mem576.0.sroa.gep111 = getelementptr inbounds i8, ptr %12, i64 8
  %.reg2mem576.0.sroa.gep113 = getelementptr inbounds i8, ptr %7, i64 24
  %.reg2mem576.0.sroa.gep114 = getelementptr inbounds i8, ptr %12, i64 24
  %.reg2mem576.0.sroa.gep122 = getelementptr inbounds i8, ptr %7, i64 16
  %.reg2mem576.0.sroa.gep123 = getelementptr inbounds i8, ptr %12, i64 16
  %.sroa.1458.8.sroa_idx = getelementptr inbounds i8, ptr %.sroa.1458, i64 8
  %.sroa.1450.8.sroa_idx = getelementptr inbounds i8, ptr %.sroa.1450, i64 8
  %.sroa.1458.16.sroa_idx551 = getelementptr inbounds i8, ptr %.sroa.1458, i64 16
  %.sroa.1450.16.sroa_idx550 = getelementptr inbounds i8, ptr %.sroa.1450, i64 16
  %17 = tail call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %18 = sext i32 %offset.i.i to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract14, i64 %18
  %20 = getelementptr i8, ptr %19, i64 40
  %21 = getelementptr i8, ptr %19, i64 48
  %22 = getelementptr i8, ptr %19, i64 56
  %23 = getelementptr i8, ptr %19, i64 24
  %24 = getelementptr i8, ptr %19, i64 8
  br label %25

25:                                               ; preds = %.critedge271, %3
  %26 = load ptr, ptr %20, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %.fca.1.extract15)
  %29 = icmp eq i32 %28, 1
  br i1 %29, label %.preheader520, label %.critedge

.preheader520:                                    ; preds = %25
  %30 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  br label %31

31:                                               ; preds = %.preheader520, %41
  %32 = load ptr, ptr %21, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract15)
  %35 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %36 = load ptr, ptr %22, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call i32 %37(ptr %.fca.1.extract15)
  %39 = icmp slt i32 %34, %38
  %40 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  br i1 %39, label %41, label %79

41:                                               ; preds = %31
  %42 = load ptr, ptr %21, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call i32 %43(ptr %.fca.1.extract15)
  %45 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %46 = load ptr, ptr %23, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr, ptr, ptr, i32 } %47(ptr %.fca.1.extract15)
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %48, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %48, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %48, 2
  %.fca.3.extract39 = extractvalue { ptr, ptr, ptr, i32 } %48, 3
  %hash_coef_ptr.i.i273 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i274 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i275 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i276 = load i64, ptr %hash_coef_ptr.i.i273, align 4
  %tbl_size.i.i277 = load i64, ptr %tbl_size_ptr.i.i274, align 4
  %offset_tbl.i.i278 = load ptr, ptr %offset_tbl_ptr.i.i275, align 8
  %product.i.i.i279 = mul i64 %hash_coef.i.i276, -5261542750394134544
  %shifted.i.i.i280 = lshr i64 %product.i.i.i279, 32
  %xored.i.i.i281 = xor i64 %shifted.i.i.i280, %product.i.i.i279
  %hash.i.i.i282 = and i64 %xored.i.i.i281, %tbl_size.i.i277
  %offset_ptr.i.i283 = getelementptr i32, ptr %offset_tbl.i.i278, i64 %hash.i.i.i282
  %offset.i.i284 = load i32, ptr %offset_ptr.i.i283, align 4
  %eq.i = icmp eq i32 %.fca.3.extract39, %offset.i.i284
  call void @llvm.assume(i1 %eq.i) #30
  %49 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.1.extract35, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %.fca.2.extract37, 2
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 %.fca.3.extract39, 3
  %53 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %54 = load ptr, ptr %19, align 8
  %55 = call ptr %54(ptr %.fca.1.extract15)
  %56 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %57 = load ptr, ptr %24, align 8
  %58 = call ptr %57(ptr %.fca.1.extract15)
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %60 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract33)
  %61 = sext i32 %.fca.3.extract39 to i64
  %62 = getelementptr ptr, ptr %.fca.0.extract33, i64 %61
  %63 = getelementptr i8, ptr %62, i64 120
  %64 = load ptr, ptr %63, align 8
  store ptr @i32_typ, ptr %6, align 8
  %65 = call ptr %64({ ptr, ptr, ptr, i32 } %52, ptr nonnull %6)
  %66 = call { ptr, i160 } %65({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr nonnull %5, i32 %44)
  %.fca.0.extract29 = extractvalue { ptr, i160 } %66, 0
  %.fca.1.extract31 = extractvalue { ptr, i160 } %66, 1
  store i160 %.fca.1.extract31, ptr %.sroa.3268, align 8
  %67 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %68 = load ptr, ptr %21, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = call i32 %69(ptr %.fca.1.extract15)
  %71 = add i32 %70, 1
  %72 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %73 = load ptr, ptr %21, align 8
  %74 = getelementptr i8, ptr %73, i64 8
  %75 = load ptr, ptr %74, align 8
  call void %75(ptr %.fca.1.extract15, i32 %71)
  %76 = icmp eq ptr %.fca.0.extract29, @nil_typ
  %77 = icmp eq ptr %.fca.0.extract29, null
  %78 = or i1 %76, %77
  br i1 %78, label %31, label %.critedge271.thread.thread

79:                                               ; preds = %31
  %80 = load ptr, ptr %20, align 8
  %81 = getelementptr i8, ptr %80, i64 8
  %82 = load ptr, ptr %81, align 8
  call void %82(ptr %.fca.1.extract15, i32 2)
  %83 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %84 = load ptr, ptr %21, align 8
  %85 = getelementptr i8, ptr %84, i64 8
  %86 = load ptr, ptr %85, align 8
  call void %86(ptr %.fca.1.extract15, i32 0)
  br label %.critedge

.critedge:                                        ; preds = %79, %25
  %87 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %88 = load ptr, ptr %20, align 8
  %89 = load ptr, ptr %88, align 8
  %90 = call i32 %89(ptr %.fca.1.extract15)
  %91 = icmp eq i32 %90, 2
  %92 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  br i1 %91, label %.preheader, label %.critedge271

.critedge271:                                     ; preds = %.critedge
  %93 = load ptr, ptr %20, align 8
  %94 = load ptr, ptr %93, align 8
  %95 = call i32 %94(ptr %.fca.1.extract15)
  %96 = icmp ne i32 %95, 1
  %97 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %98 = load ptr, ptr %20, align 8
  %99 = load ptr, ptr %98, align 8
  %100 = call i32 %99(ptr %.fca.1.extract15)
  %101 = icmp ne i32 %100, 2
  %102 = and i1 %96, %101
  br i1 %102, label %105, label %25

.preheader:                                       ; preds = %.critedge
  %103 = getelementptr i8, ptr %19, i64 64
  %104 = getelementptr i8, ptr %19, i64 32
  br label %152

105:                                              ; preds = %.critedge271
  %result.i = call noalias dereferenceable_or_null(36) ptr @bump_malloc_inner(i64 noundef 36, ptr nonnull @current_ptr) #29
  %106 = load <35 x i8>, ptr @ayamz_Iterator_Error_Invalid_table_state, align 64
  store <35 x i8> %106, ptr %result.i, align 64
  %result.i286 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %107 = getelementptr inbounds i8, ptr %15, i64 8
  %108 = getelementptr inbounds i8, ptr %15, i64 24
  store ptr @String, ptr %15, align 8
  store ptr %result.i286, ptr %107, align 8
  store i32 9, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %15)
  %110 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %111 = load ptr, ptr %19, align 8
  %112 = call ptr %111(ptr %.fca.1.extract15)
  %113 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %114 = load ptr, ptr %24, align 8
  %115 = call ptr %114(ptr %.fca.1.extract15)
  store ptr %result.i, ptr %result.i286, align 8
  %116 = getelementptr i8, ptr %result.i286, i64 8
  store i32 35, ptr %116, align 4
  %117 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %118 = getelementptr i8, ptr %result.i286, i64 12
  store i32 36, ptr %118, align 4
  %119 = load ptr, ptr %15, align 8
  %120 = insertvalue { ptr, i160 } undef, ptr %119, 0
  %121 = load i160, ptr %107, align 8
  %122 = insertvalue { ptr, i160 } %120, i160 %121, 1
  %123 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %124 = load ptr, ptr %19, align 8
  %125 = call ptr %124(ptr %.fca.1.extract15)
  %126 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %127 = load ptr, ptr %24, align 8
  %128 = call ptr %127(ptr %.fca.1.extract15)
  store ptr @_parameterization_String, ptr %16, align 8
  %129 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %16)
  %130 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %131 = getelementptr i8, ptr %119, i64 8
  %132 = getelementptr i8, ptr %119, i64 16
  %133 = getelementptr i8, ptr %119, i64 24
  %134 = getelementptr i8, ptr %119, i64 32
  %135 = load i64, ptr %131, align 4
  %136 = load i64, ptr %132, align 4
  %137 = load ptr, ptr %133, align 8
  %138 = load ptr, ptr %134, align 8
  %result.i.i = call i1 %137(i64 %136, i64 %135, i64 -5126806859456325683, i64 ptrtoint (ptr @nil_typ to i64), ptr readonly %138) #0
  %139 = icmp eq ptr %119, null
  %140 = or i1 %139, %result.i.i
  br i1 %140, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit, label %141

141:                                              ; preds = %105
  %result.i3.i = call i1 %137(i64 %136, i64 %135, i64 2582149688529881115, i64 ptrtoint (ptr @i8_typ to i64), ptr readonly %138) #0
  br i1 %result.i3.i, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit, label %142

142:                                              ; preds = %141
  %result.i4.i = call i1 %137(i64 %136, i64 %135, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %138) #0
  %result.i5.i = call i1 %137(i64 %136, i64 %135, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %138) #0
  %not.result.i4.i = xor i1 %result.i4.i, true
  %.reg2mem49.0.i = select i1 %not.result.i4.i, i1 true, i1 %result.i5.i
  br i1 %.reg2mem49.0.i, label %143, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

143:                                              ; preds = %142
  %result.i6.i = call i1 %137(i64 %136, i64 %135, i64 -757315540097298781, i64 ptrtoint (ptr @f64_typ to i64), ptr readonly %138) #0
  br i1 %result.i6.i, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit, label %144

144:                                              ; preds = %143
  %not.result.i5.i = xor i1 %result.i5.i, true
  %.reg2mem47.0.i = or i1 %result.i4.i, %not.result.i5.i
  br i1 %.reg2mem47.0.i, label %145, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

145:                                              ; preds = %144
  %result.i9.i = call i1 %137(i64 %136, i64 %135, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %138) #0
  %result.i9.not.i = xor i1 %result.i9.i, true
  %.reg2mem45.0.i = or i1 %result.i4.i, %result.i5.i
  %or.cond.i = select i1 %result.i9.not.i, i1 true, i1 %.reg2mem45.0.i
  br i1 %or.cond.i, label %.critedge.i, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

.critedge.i:                                      ; preds = %145
  %result.i12.i = call i1 %137(i64 %136, i64 %135, i64 -2253724949814257982, i64 ptrtoint (ptr @i32_typ to i64), ptr readonly %138) #0
  br i1 %result.i12.i, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit, label %146

146:                                              ; preds = %.critedge.i
  %result.i13.i = call i1 %137(i64 %136, i64 %135, i64 5801531371504802705, i64 ptrtoint (ptr @bool_typ to i64), ptr readonly %138) #0
  %147 = select i1 %result.i13.i, i32 5, i32 1
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit: ; preds = %105, %141, %142, %143, %144, %145, %.critedge.i, %146
  %.reg2mem29.0.i = phi i32 [ 9, %105 ], [ 2, %141 ], [ 3, %143 ], [ %147, %146 ], [ 7, %.critedge.i ], [ 8, %144 ], [ 4, %142 ], [ 6, %145 ]
  %148 = zext nneg i32 %.reg2mem29.0.i to i64
  %149 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %148
  %150 = getelementptr i8, ptr %149, i64 72
  %151 = load ptr, ptr %150, align 8
  call void %151(ptr nonnull %16, { ptr, i160 } %122)
  br label %.thread476

152:                                              ; preds = %.preheader, %161
  %153 = load ptr, ptr %21, align 8
  %154 = load ptr, ptr %153, align 8
  %155 = call i32 %154(ptr %.fca.1.extract15)
  %156 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %157 = load ptr, ptr %103, align 8
  %158 = load ptr, ptr %157, align 8
  %159 = call i32 %158(ptr %.fca.1.extract15)
  %160 = icmp slt i32 %155, %159
  br i1 %160, label %161, label %.thread476

161:                                              ; preds = %152
  %162 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %163 = load ptr, ptr %21, align 8
  %164 = load ptr, ptr %163, align 8
  %165 = call i32 %164(ptr %.fca.1.extract15)
  %166 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %167 = load ptr, ptr %104, align 8
  %168 = load ptr, ptr %167, align 8
  %169 = call { ptr, ptr, ptr, i32 } %168(ptr %.fca.1.extract15)
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %169, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %169, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %169, 2
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %169, 3
  %hash_coef_ptr.i.i288 = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i289 = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i290 = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i291 = load i64, ptr %hash_coef_ptr.i.i288, align 4
  %tbl_size.i.i292 = load i64, ptr %tbl_size_ptr.i.i289, align 4
  %offset_tbl.i.i293 = load ptr, ptr %offset_tbl_ptr.i.i290, align 8
  %product.i.i.i294 = mul i64 %hash_coef.i.i291, -5261542750394134544
  %shifted.i.i.i295 = lshr i64 %product.i.i.i294, 32
  %xored.i.i.i296 = xor i64 %shifted.i.i.i295, %product.i.i.i294
  %hash.i.i.i297 = and i64 %xored.i.i.i296, %tbl_size.i.i292
  %offset_ptr.i.i298 = getelementptr i32, ptr %offset_tbl.i.i293, i64 %hash.i.i.i297
  %offset.i.i299 = load i32, ptr %offset_ptr.i.i298, align 4
  %eq.i302 = icmp eq i32 %.fca.3.extract27, %offset.i.i299
  call void @llvm.assume(i1 %eq.i302) #30
  %170 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %171 = insertvalue { ptr, ptr, ptr, i32 } %170, ptr %.fca.1.extract23, 1
  %172 = insertvalue { ptr, ptr, ptr, i32 } %171, ptr %.fca.2.extract25, 2
  %173 = insertvalue { ptr, ptr, ptr, i32 } %172, i32 %.fca.3.extract27, 3
  %174 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %175 = load ptr, ptr %19, align 8
  %176 = call ptr %175(ptr %.fca.1.extract15)
  %177 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %178 = load ptr, ptr %24, align 8
  %179 = call ptr %178(ptr %.fca.1.extract15)
  store ptr @_parameterization_Ptri32, ptr %10, align 8
  %180 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %10)
  %181 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract21)
  %182 = sext i32 %.fca.3.extract27 to i64
  %183 = getelementptr ptr, ptr %.fca.0.extract21, i64 %182
  %184 = getelementptr i8, ptr %183, i64 120
  %185 = load ptr, ptr %184, align 8
  store ptr @i32_typ, ptr %11, align 8
  %186 = call ptr %185({ ptr, ptr, ptr, i32 } %173, ptr nonnull %11)
  %187 = call { ptr, i160 } %186({ ptr, ptr, ptr, i32 } %173, { ptr, ptr, ptr, i32 } %173, ptr nonnull %10, i32 %165)
  %.fca.0.extract17 = extractvalue { ptr, i160 } %187, 0
  %.fca.1.extract19 = extractvalue { ptr, i160 } %187, 1
  store i160 %.fca.1.extract19, ptr %.sroa.3, align 8
  %188 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %189 = load ptr, ptr %21, align 8
  %190 = load ptr, ptr %189, align 8
  %191 = call i32 %190(ptr %.fca.1.extract15)
  %192 = add i32 %191, 1
  %193 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %194 = load ptr, ptr %21, align 8
  %195 = getelementptr i8, ptr %194, i64 8
  %196 = load ptr, ptr %195, align 8
  call void %196(ptr %.fca.1.extract15, i32 %192)
  %197 = icmp eq ptr %.fca.0.extract17, @nil_typ
  %198 = icmp eq ptr %.fca.0.extract17, null
  %199 = or i1 %197, %198
  br i1 %199, label %152, label %.critedge271.thread.thread

.critedge271.thread.thread:                       ; preds = %41, %161
  %.reg2mem552.0.sroa.phi42 = phi ptr [ %.reg2mem552.0.sroa.gep44, %161 ], [ %.reg2mem552.0.sroa.gep43, %41 ]
  %.reg2mem552.0 = phi ptr [ %14, %161 ], [ %9, %41 ]
  %.reg2mem554.0.sroa.phi46 = phi ptr [ %.reg2mem554.0.sroa.gep48, %161 ], [ %.reg2mem554.0.sroa.gep47, %41 ]
  %.reg2mem554.0 = phi ptr [ %13, %161 ], [ %8, %41 ]
  %.reg2mem556.0.sroa.phi53 = phi ptr [ %.sroa.0, %161 ], [ %.sroa.0223, %41 ]
  %.reg2mem556.0.sroa.phi56 = phi ptr [ %.sroa.2, %161 ], [ %.sroa.2224, %41 ]
  %.reg2mem558.0.sroa.phi63 = phi ptr [ %.sroa.069, %161 ], [ %.sroa.0225, %41 ]
  %.reg2mem558.0.sroa.phi66 = phi ptr [ %.sroa.270, %161 ], [ %.sroa.2226, %41 ]
  %.reg2mem560.0.sroa.phi75 = phi ptr [ %.sroa.081, %161 ], [ %.sroa.0227, %41 ]
  %.reg2mem560.0.sroa.phi78 = phi ptr [ %.sroa.282, %161 ], [ %.sroa.2228, %41 ]
  %.reg2mem562.0.sroa.phi229 = phi ptr [ %.sroa.0431, %161 ], [ %.sroa.0235, %41 ]
  %.reg2mem562.0.sroa.phi232 = phi ptr [ %.sroa.1432, %161 ], [ %.sroa.2236, %41 ]
  %.reg2mem568.0.sroa.phi95 = phi ptr [ %.sroa.0101, %161 ], [ %.sroa.0237, %41 ]
  %.reg2mem568.0.sroa.phi98 = phi ptr [ %.sroa.2102, %161 ], [ %.sroa.2238, %41 ]
  %.reg2mem570.0.sroa.phi239 = phi ptr [ %.sroa.0433, %161 ], [ %.sroa.0245, %41 ]
  %.reg2mem570.0.sroa.phi242 = phi ptr [ %.sroa.1434, %161 ], [ %.sroa.2246, %41 ]
  %.reg2mem576.0.sroa.phi121 = phi ptr [ %.reg2mem576.0.sroa.gep123, %161 ], [ %.reg2mem576.0.sroa.gep122, %41 ]
  %.reg2mem576.0.sroa.phi124 = phi ptr [ %.reg2mem576.0.sroa.gep114, %161 ], [ %.reg2mem576.0.sroa.gep113, %41 ]
  %.reg2mem576.0.sroa.phi130 = phi ptr [ %.reg2mem576.0.sroa.gep111, %161 ], [ %.reg2mem576.0.sroa.gep, %41 ]
  %.reg2mem576.0 = phi ptr [ %12, %161 ], [ %7, %41 ]
  %.reg2mem578.0.sroa.phi = phi ptr [ %.sroa.1442, %161 ], [ %.sroa.1455, %41 ]
  %.reg2mem578.0.sroa.phi134 = phi ptr [ %.sroa.3443, %161 ], [ %.sroa.3456, %41 ]
  %.reg2mem578.0 = phi ptr [ %.sroa.0441, %161 ], [ %.sroa.0454, %41 ]
  %.reg2mem580.0.sroa.phi = phi ptr [ %.sroa.0141, %161 ], [ %.sroa.0247, %41 ]
  %.reg2mem580.0.sroa.phi138 = phi ptr [ %.sroa.1, %161 ], [ %.sroa.1248, %41 ]
  %.reg2mem582.0.sroa.phi249 = phi ptr [ %.sroa.0444, %161 ], [ %.sroa.0255, %41 ]
  %.reg2mem582.0.sroa.phi252 = phi ptr [ %.sroa.1445, %161 ], [ %.sroa.2256, %41 ]
  %.reg2mem588.0.sroa.phi = phi ptr [ %.sroa.0154, %161 ], [ %.sroa.0257, %41 ]
  %.reg2mem588.0.sroa.phi151 = phi ptr [ %.sroa.1155, %161 ], [ %.sroa.1258, %41 ]
  %.reg2mem590.0.sroa.phi259 = phi ptr [ %.sroa.0446, %161 ], [ %.sroa.0265, %41 ]
  %.reg2mem590.0.sroa.phi262 = phi ptr [ %.sroa.1447, %161 ], [ %.sroa.2266, %41 ]
  %.reg2mem596.0.sroa.phi207 = phi ptr [ %.sroa.1450, %161 ], [ %.sroa.1458, %41 ]
  %.reg2mem596.0.sroa.phi210 = phi ptr [ %.sroa.1450.8.sroa_idx, %161 ], [ %.sroa.1458.8.sroa_idx, %41 ]
  %.reg2mem596.0.sroa.phi213 = phi ptr [ %.sroa.1450.16.sroa_idx550, %161 ], [ %.sroa.1458.16.sroa_idx551, %41 ]
  %.reg2mem596.0 = phi ptr [ %.sroa.0449, %161 ], [ %.sroa.0457, %41 ]
  %.reg2mem598.0.sroa.phi.sroa.speculated = phi ptr [ %.fca.0.extract17, %161 ], [ %.fca.0.extract29, %41 ]
  %.reg2mem598.0.sroa.phi217 = phi ptr [ %.sroa.3, %161 ], [ %.sroa.3268, %41 ]
  store ptr %.reg2mem598.0.sroa.phi.sroa.speculated, ptr %.reg2mem596.0, align 8
  %200 = load i160, ptr %.reg2mem598.0.sroa.phi217, align 8
  store i160 %200, ptr %.reg2mem596.0.sroa.phi207, align 8
  %hash_coef_ptr.i.i304 = getelementptr i8, ptr %.reg2mem598.0.sroa.phi.sroa.speculated, i64 8
  %tbl_size_ptr.i.i305 = getelementptr i8, ptr %.reg2mem598.0.sroa.phi.sroa.speculated, i64 16
  %offset_tbl_ptr.i.i306 = getelementptr i8, ptr %.reg2mem598.0.sroa.phi.sroa.speculated, i64 40
  %hash_coef.i.i307 = load i64, ptr %hash_coef_ptr.i.i304, align 4
  %tbl_size.i.i308 = load i64, ptr %tbl_size_ptr.i.i305, align 4
  %offset_tbl.i.i309 = load ptr, ptr %offset_tbl_ptr.i.i306, align 8
  %product.i.i.i310 = mul i64 %hash_coef.i.i307, 4015701072841558310
  %shifted.i.i.i311 = lshr i64 %product.i.i.i310, 32
  %xored.i.i.i312 = xor i64 %shifted.i.i.i311, %product.i.i.i310
  %hash.i.i.i313 = and i64 %xored.i.i.i312, %tbl_size.i.i308
  %offset_ptr.i.i314 = getelementptr i32, ptr %offset_tbl.i.i309, i64 %hash.i.i.i313
  %offset.i.i315 = load i32, ptr %offset_ptr.i.i314, align 4
  store i32 %offset.i.i315, ptr %.reg2mem596.0.sroa.phi213, align 4
  %201 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.reg2mem598.0.sroa.phi.sroa.speculated, 0
  %202 = trunc i160 %200 to i64
  %203 = inttoptr i64 %202 to ptr
  %204 = insertvalue { ptr, ptr, ptr, i32 } %201, ptr %203, 1
  %205 = load ptr, ptr %.reg2mem596.0.sroa.phi210, align 8
  %206 = insertvalue { ptr, ptr, ptr, i32 } %204, ptr %205, 2
  %207 = insertvalue { ptr, ptr, ptr, i32 } %206, i32 %offset.i.i315, 3
  %208 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %209 = load ptr, ptr %19, align 8
  %210 = call ptr %209(ptr %.fca.1.extract15)
  %211 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %212 = load ptr, ptr %24, align 8
  %213 = call ptr %212(ptr %.fca.1.extract15)
  %214 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %215 = call ptr @llvm.invariant.start.p0(i64 104, ptr %.reg2mem598.0.sroa.phi.sroa.speculated)
  %216 = sext i32 %offset.i.i315 to i64
  %217 = getelementptr ptr, ptr %.reg2mem598.0.sroa.phi.sroa.speculated, i64 %216
  %218 = getelementptr i8, ptr %217, i64 48
  %219 = load ptr, ptr %218, align 8
  %220 = call ptr %219({ ptr, ptr, ptr, i32 } %207, ptr nonnull %4)
  %221 = call { ptr, i160 } %220({ ptr, ptr, ptr, i32 } %207, { ptr, ptr, ptr, i32 } %207, ptr nonnull %4)
  %.fca.0.extract156 = extractvalue { ptr, i160 } %221, 0
  store ptr %.fca.0.extract156, ptr %.reg2mem590.0.sroa.phi259, align 8
  %.fca.1.extract158 = extractvalue { ptr, i160 } %221, 1
  store i160 %.fca.1.extract158, ptr %.reg2mem590.0.sroa.phi262, align 8
  store ptr %.fca.0.extract156, ptr %.reg2mem588.0.sroa.phi, align 8
  store i160 %.fca.1.extract158, ptr %.reg2mem588.0.sroa.phi151, align 8
  %222 = load ptr, ptr %.reg2mem596.0, align 8
  %223 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %222, 0
  %224 = load ptr, ptr %.reg2mem596.0.sroa.phi207, align 8
  %225 = insertvalue { ptr, ptr, ptr, i32 } %223, ptr %224, 1
  %226 = load ptr, ptr %.reg2mem596.0.sroa.phi210, align 8
  %227 = insertvalue { ptr, ptr, ptr, i32 } %225, ptr %226, 2
  %228 = load i32, ptr %.reg2mem596.0.sroa.phi213, align 4
  %229 = insertvalue { ptr, ptr, ptr, i32 } %227, i32 %228, 3
  %230 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %231 = load ptr, ptr %19, align 8
  %232 = call ptr %231(ptr %.fca.1.extract15)
  %233 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %234 = load ptr, ptr %24, align 8
  %235 = call ptr %234(ptr %.fca.1.extract15)
  %236 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %237 = call ptr @llvm.invariant.start.p0(i64 104, ptr %222)
  %238 = sext i32 %228 to i64
  %239 = getelementptr ptr, ptr %222, i64 %238
  %240 = getelementptr i8, ptr %239, i64 56
  %241 = load ptr, ptr %240, align 8
  %242 = call ptr %241({ ptr, ptr, ptr, i32 } %229, ptr nonnull %4)
  %243 = call { ptr, i160 } %242({ ptr, ptr, ptr, i32 } %229, { ptr, ptr, ptr, i32 } %229, ptr nonnull %4)
  %.fca.0.extract142 = extractvalue { ptr, i160 } %243, 0
  store ptr %.fca.0.extract142, ptr %.reg2mem582.0.sroa.phi249, align 8
  %.fca.1.extract144 = extractvalue { ptr, i160 } %243, 1
  store i160 %.fca.1.extract144, ptr %.reg2mem582.0.sroa.phi252, align 8
  store ptr %.fca.0.extract142, ptr %.reg2mem580.0.sroa.phi, align 8
  store i160 %.fca.1.extract144, ptr %.reg2mem580.0.sroa.phi138, align 8
  %244 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %245 = load ptr, ptr %19, align 8
  %246 = call ptr %245(ptr %.fca.1.extract15)
  %247 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %248 = load ptr, ptr %24, align 8
  %249 = call ptr %248(ptr %.fca.1.extract15)
  store ptr @Pair, ptr %.reg2mem578.0, align 8
  store ptr %246, ptr %.reg2mem578.0.sroa.phi, align 8
  store ptr %249, ptr %.reg2mem578.0.sroa.phi134, align 8
  %250 = load ptr, ptr %246, align 8
  %251 = getelementptr i8, ptr %250, i64 48
  %252 = load ptr, ptr %251, align 8
  %253 = call { i64, i64 } %252(ptr nonnull %246)
  %254 = extractvalue { i64, i64 } %253, 0
  %255 = extractvalue { i64, i64 } %253, 1
  %256 = urem i64 16, %255
  %257 = icmp eq i64 %256, 0
  %258 = sub i64 %255, %256
  %259 = select i1 %257, i64 0, i64 %258
  %260 = add i64 %254, 16
  %261 = add i64 %260, %259
  %262 = load ptr, ptr %.reg2mem578.0.sroa.phi134, align 8
  %263 = load ptr, ptr %262, align 8
  %264 = getelementptr i8, ptr %263, i64 48
  %265 = load ptr, ptr %264, align 8
  %266 = call { i64, i64 } %265(ptr nonnull %262)
  %267 = extractvalue { i64, i64 } %266, 0
  %268 = extractvalue { i64, i64 } %266, 1
  %269 = call i64 @llvm.umax.i64(i64 %255, i64 %268)
  %270 = call i64 @llvm.umax.i64(i64 %269, i64 8)
  %271 = urem i64 %261, %268
  %272 = icmp eq i64 %271, 0
  %273 = sub i64 %268, %271
  %274 = select i1 %272, i64 0, i64 %273
  %275 = add i64 %267, %261
  %276 = add i64 %275, %274
  %277 = urem i64 %276, %270
  %278 = icmp eq i64 %277, 0
  %279 = sub i64 %270, %277
  %280 = select i1 %278, i64 0, i64 %279
  %281 = add i64 %280, %276
  %result.i317 = call noalias ptr @bump_malloc_inner(i64 noundef %281, ptr nonnull @current_ptr) #29
  store ptr %246, ptr %result.i317, align 8
  %282 = getelementptr i8, ptr %result.i317, i64 8
  store ptr %249, ptr %282, align 8
  %283 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i317)
  store ptr @Pair, ptr %.reg2mem576.0, align 8
  store ptr %result.i317, ptr %.reg2mem576.0.sroa.phi130, align 8
  store i32 9, ptr %.reg2mem576.0.sroa.phi124, align 4
  %284 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %.reg2mem576.0)
  %285 = load ptr, ptr %.reg2mem596.0, align 8
  %286 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %285, 0
  %287 = load ptr, ptr %.reg2mem596.0.sroa.phi207, align 8
  %288 = insertvalue { ptr, ptr, ptr, i32 } %286, ptr %287, 1
  %289 = load ptr, ptr %.reg2mem596.0.sroa.phi210, align 8
  %290 = insertvalue { ptr, ptr, ptr, i32 } %288, ptr %289, 2
  %291 = load i32, ptr %.reg2mem596.0.sroa.phi213, align 4
  %292 = insertvalue { ptr, ptr, ptr, i32 } %290, i32 %291, 3
  %293 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %294 = load ptr, ptr %19, align 8
  %295 = call ptr %294(ptr %.fca.1.extract15)
  %296 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %297 = load ptr, ptr %24, align 8
  %298 = call ptr %297(ptr %.fca.1.extract15)
  %299 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %300 = call ptr @llvm.invariant.start.p0(i64 104, ptr %285)
  %301 = sext i32 %291 to i64
  %302 = getelementptr ptr, ptr %285, i64 %301
  %303 = getelementptr i8, ptr %302, i64 48
  %304 = load ptr, ptr %303, align 8
  %305 = call ptr %304({ ptr, ptr, ptr, i32 } %292, ptr nonnull %4)
  %306 = call { ptr, i160 } %305({ ptr, ptr, ptr, i32 } %292, { ptr, ptr, ptr, i32 } %292, ptr nonnull %4)
  %.fca.0.extract103 = extractvalue { ptr, i160 } %306, 0
  store ptr %.fca.0.extract103, ptr %.reg2mem570.0.sroa.phi239, align 8
  %.fca.1.extract105 = extractvalue { ptr, i160 } %306, 1
  store i160 %.fca.1.extract105, ptr %.reg2mem570.0.sroa.phi242, align 8
  store ptr %.fca.0.extract103, ptr %.reg2mem568.0.sroa.phi95, align 8
  store i160 %.fca.1.extract105, ptr %.reg2mem568.0.sroa.phi98, align 8
  %307 = load ptr, ptr %.reg2mem596.0, align 8
  %308 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %307, 0
  %309 = load ptr, ptr %.reg2mem596.0.sroa.phi207, align 8
  %310 = insertvalue { ptr, ptr, ptr, i32 } %308, ptr %309, 1
  %311 = load ptr, ptr %.reg2mem596.0.sroa.phi210, align 8
  %312 = insertvalue { ptr, ptr, ptr, i32 } %310, ptr %311, 2
  %313 = load i32, ptr %.reg2mem596.0.sroa.phi213, align 4
  %314 = insertvalue { ptr, ptr, ptr, i32 } %312, i32 %313, 3
  %315 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %316 = load ptr, ptr %19, align 8
  %317 = call ptr %316(ptr %.fca.1.extract15)
  %318 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %319 = load ptr, ptr %24, align 8
  %320 = call ptr %319(ptr %.fca.1.extract15)
  %321 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %322 = call ptr @llvm.invariant.start.p0(i64 104, ptr %307)
  %323 = sext i32 %313 to i64
  %324 = getelementptr ptr, ptr %307, i64 %323
  %325 = getelementptr i8, ptr %324, i64 56
  %326 = load ptr, ptr %325, align 8
  %327 = call ptr %326({ ptr, ptr, ptr, i32 } %314, ptr nonnull %4)
  %328 = call { ptr, i160 } %327({ ptr, ptr, ptr, i32 } %314, { ptr, ptr, ptr, i32 } %314, ptr nonnull %4)
  %.fca.0.extract83 = extractvalue { ptr, i160 } %328, 0
  store ptr %.fca.0.extract83, ptr %.reg2mem562.0.sroa.phi229, align 8
  %.fca.1.extract85 = extractvalue { ptr, i160 } %328, 1
  store i160 %.fca.1.extract85, ptr %.reg2mem562.0.sroa.phi232, align 8
  store ptr %.fca.0.extract83, ptr %.reg2mem560.0.sroa.phi75, align 8
  store i160 %.fca.1.extract85, ptr %.reg2mem560.0.sroa.phi78, align 8
  %329 = load ptr, ptr %.reg2mem568.0.sroa.phi95, align 8
  store ptr %329, ptr %.reg2mem558.0.sroa.phi63, align 8
  %330 = load i160, ptr %.reg2mem568.0.sroa.phi98, align 8
  store i160 %330, ptr %.reg2mem558.0.sroa.phi66, align 8
  %331 = insertvalue { ptr, i160 } undef, ptr %329, 0
  %332 = insertvalue { ptr, i160 } %331, i160 %330, 1
  store ptr %.fca.0.extract83, ptr %.reg2mem556.0.sroa.phi53, align 8
  store i160 %.fca.1.extract85, ptr %.reg2mem556.0.sroa.phi56, align 8
  %333 = load ptr, ptr %.reg2mem576.0, align 8
  %334 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %333, 0
  %335 = load ptr, ptr %.reg2mem576.0.sroa.phi130, align 8
  %336 = insertvalue { ptr, ptr, ptr, i32 } %334, ptr %335, 1
  %337 = load ptr, ptr %.reg2mem576.0.sroa.phi121, align 8
  %338 = insertvalue { ptr, ptr, ptr, i32 } %336, ptr %337, 2
  %339 = load i32, ptr %.reg2mem576.0.sroa.phi124, align 4
  %340 = insertvalue { ptr, ptr, ptr, i32 } %338, i32 %339, 3
  %341 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %342 = load ptr, ptr %19, align 8
  %343 = call ptr %342(ptr %.fca.1.extract15)
  %344 = call ptr @llvm.invariant.start.p0(i64 128, ptr nonnull %.fca.0.extract14)
  %345 = load ptr, ptr %24, align 8
  %346 = call ptr %345(ptr %.fca.1.extract15)
  store ptr %343, ptr %.reg2mem554.0, align 8
  store ptr %346, ptr %.reg2mem554.0.sroa.phi46, align 8
  %347 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %.reg2mem554.0)
  %348 = call ptr @llvm.invariant.start.p0(i64 80, ptr %333)
  %349 = sext i32 %339 to i64
  %350 = getelementptr ptr, ptr %333, i64 %349
  %351 = getelementptr i8, ptr %350, i64 32
  %352 = load ptr, ptr %351, align 8
  store ptr %329, ptr %.reg2mem552.0, align 8
  store ptr %.fca.0.extract83, ptr %.reg2mem552.0.sroa.phi42, align 8
  %353 = call ptr %352({ ptr, ptr, ptr, i32 } %340, ptr nonnull %.reg2mem552.0)
  call void %353({ ptr, ptr, ptr, i32 } %340, { ptr, ptr, ptr, i32 } %340, ptr nonnull %.reg2mem554.0, { ptr, i160 } %332, { ptr, i160 } %328)
  %354 = load ptr, ptr %.reg2mem576.0, align 8
  %355 = load i160, ptr %.reg2mem576.0.sroa.phi130, align 4
  br label %.thread476

.thread476:                                       ; preds = %152, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit, %.critedge271.thread.thread
  %.reg2mem548.sroa.4.0 = phi i160 [ %355, %.critedge271.thread.thread ], [ undef, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit ], [ undef, %152 ]
  %.reg2mem548.sroa.0.0 = phi ptr [ %354, %.critedge271.thread.thread ], [ @nil_typ, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit ], [ @nil_typ, %152 ]
  %.reload549.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem548.sroa.0.0, 0
  %.reload549.fca.1.insert = insertvalue { ptr, i160 } %.reload549.fca.0.insert, i160 %.reg2mem548.sroa.4.0, 1
  ret { ptr, i160 } %.reload549.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMapIterator_getter_len2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 100
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_len2(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 100
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMapIterator_getter_len1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 96
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_len1(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 96
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMapIterator_getter_index(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 92
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_index(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 92
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMapIterator_getter_current_table(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_current_table(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 88
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @HashMapIterator_getter_map_table2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_map_table2(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @HashMapIterator_getter_map_table1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_map_table1(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #5 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

define linkonce_odr { i64, i64 } @_size_function_typ(ptr %0) {
  ret { i64, i64 } { i64 8, i64 8 }
}

define linkonce_odr { ptr, i160 } @_box_function_typ(ptr %0, ptr %1) {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

define linkonce_odr void @_unbox_function_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMap_getter_max_displacements(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 112
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_max_displacements(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 112
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_eq(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 104
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_eq(ptr nocapture writeonly %0, { ptr } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 104
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_hasher1_fn(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 96
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_hasher1_fn(ptr nocapture writeonly %0, { ptr } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 96
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMap_getter_size(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_size(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 88
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @HashMap_getter_table2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_table2(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @HashMap_getter_table1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_table1(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_PRNG(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 96
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @PRNG_init_initial_seedPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull %.fca.0.extract)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %. = tail call i32 @llvm.smax.i32(i32 %3, i32 1)
  tail call void %10(ptr %.fca.1.extract, i32 %.)
  ret void
}

define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 40, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i32 %8(ptr %.fca.1.extract)
  %10 = mul i32 %9, 1103515245
  %11 = add i32 %10, 12345
  %12 = and i32 %11, 2147483647
  %13 = tail call ptr @llvm.invariant.start.p0(i64 40, ptr %.fca.0.extract)
  %14 = load ptr, ptr %6, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  tail call void %16(ptr %.fca.1.extract, i32 %12)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 40, ptr %.fca.0.extract)
  %18 = load ptr, ptr %6, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call i32 %19(ptr %.fca.1.extract)
  ret i32 %20
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture readonly %0) #0 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture writeonly %0, i32 %1) #4 {
  store i32 %1, ptr %0, align 4
  ret void
}

define i1 @sfgguycfej(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ojkmfkcqig(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @cwuqubmlcx(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @gojtwpxwke(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @yqpcdritmp(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @wllqseuhnd(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @rfbvuqkrge(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @fwebrmudcg(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @uuudsaoyum(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ytwimdyqgw(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @wwhoiocwxr(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @idwoghntmh(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @budgehkxgp(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @zbizpytnsl(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @cfyycnytdr(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @czvtrjryuh(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @upwpmvgqgw(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @hozfwknbhb(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @clihccxsyp(ptr nest nocapture readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract2 = extractvalue { ptr, i160 } %1, 1
  %.sroa.14.8.extract.trunc = trunc i160 %.fca.1.extract2 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.14.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @gavxfslpwi(ptr nest nocapture readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #5 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

define range(i32 0, -2147483648) i32 @string_hasher({ ptr, ptr, ptr, i32 } %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract5, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract7, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i, 3
  %7 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %8 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract3)
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract3, i64 %9
  %11 = getelementptr i8, ptr %10, i64 120
  %12 = load ptr, ptr %11, align 8
  %13 = call ptr %12({ ptr, ptr, ptr, i32 } %6, ptr nonnull %2)
  %14 = call { ptr, ptr, ptr, i32 } %13({ ptr, ptr, ptr, i32 } %6, { ptr, ptr, ptr, i32 } %6, ptr nonnull %2)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %14, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %14, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %14, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, -7260570988945952630
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %offset.i.i43, 3
  %19 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %20 = call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull %.fca.0.extract)
  %21 = sext i32 %offset.i.i43 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract, i64 %21
  %23 = getelementptr i8, ptr %22, i64 24
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr %24({ ptr, ptr, ptr, i32 } %18, ptr nonnull %2)
  %26 = call { ptr, i160 } %25({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull %2)
  %.fca.0.extract1197 = extractvalue { ptr, i160 } %26, 0
  %27 = icmp ne ptr %.fca.0.extract1197, @nil_typ
  %28 = icmp ne ptr %.fca.0.extract1197, null
  %.not1698 = and i1 %27, %28
  br i1 %.not1698, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %1
  %29 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  br label %30

30:                                               ; preds = %.lr.ph, %30
  %.fca.0.extract11100 = phi ptr [ %.fca.0.extract1197, %.lr.ph ], [ %.fca.0.extract11, %30 ]
  %31 = phi { ptr, i160 } [ %26, %.lr.ph ], [ %51, %30 ]
  %.reg2mem26.099 = phi i32 [ 0, %.lr.ph ], [ %48, %30 ]
  %.fca.1.extract13 = extractvalue { ptr, i160 } %31, 1
  %.sroa.594.8.extract.shift = lshr i160 %.fca.1.extract13, 64
  %.sroa.594.8.extract.trunc = trunc i160 %.sroa.594.8.extract.shift to i64
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract13 to i64
  %32 = inttoptr i64 %.sroa.2.8.extract.trunc to ptr
  %33 = inttoptr i64 %.sroa.594.8.extract.trunc to ptr
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract11100, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract11100, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract11100, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 6681222582356018452
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i56, align 4
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11100, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %32, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %33, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %offset.i.i57, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull %.fca.0.extract11100)
  %39 = sext i32 %offset.i.i57 to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract11100, i64 %39
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load ptr, ptr %41, align 8
  %43 = call ptr %42({ ptr, ptr, ptr, i32 } %37, ptr nonnull %2)
  %44 = call i8 %43({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull %2)
  %45 = sext i8 %44 to i32
  %46 = mul i32 %.reg2mem26.099, 31
  %47 = add i32 %46, %45
  %48 = and i32 %47, 2147483647
  %49 = load ptr, ptr %23, align 8
  %50 = call ptr %49({ ptr, ptr, ptr, i32 } %18, ptr nonnull %2)
  %51 = call { ptr, i160 } %50({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull %2)
  %.fca.0.extract11 = extractvalue { ptr, i160 } %51, 0
  %52 = icmp ne ptr %.fca.0.extract11, @nil_typ
  %53 = icmp ne ptr %.fca.0.extract11, null
  %.not16 = and i1 %52, %53
  br i1 %.not16, label %30, label %._crit_edge

._crit_edge:                                      ; preds = %30, %1
  %.reg2mem26.0.lcssa = phi i32 [ 0, %1 ], [ %48, %30 ]
  ret i32 %.reg2mem26.0.lcssa
}

define i1 @string_eq({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1) local_unnamed_addr {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i35, 3
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract3, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract5, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %11)
  %13 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract1, i64 %14
  %16 = getelementptr i8, ptr %15, i64 88
  %17 = load ptr, ptr %16, align 8
  %18 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %18, align 8
  %19 = call ptr %17({ ptr, ptr, ptr, i32 } %10, ptr nonnull %18)
  %20 = call i1 %19({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull %11, { ptr, ptr, ptr, i32 } %6)
  ret i1 %20
}

define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %7 = ptrtoint ptr %.fca.1.extract to i64
  %8 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i.i to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %8 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext = zext i64 %7 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext
  %9 = insertvalue { ptr, i160 } %6, i160 %.sroa.3.8.insert.insert, 1
  %10 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %10, align 8
  %11 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %10)
  %12 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %13 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %14 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %15 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %16 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %17 = load ptr, ptr %13, align 8
  %18 = load ptr, ptr %14, align 8
  %result.i.i = tail call i1 %17(i64 %16, i64 %15, i64 -5126806859456325683, i64 ptrtoint (ptr @nil_typ to i64), ptr readonly %18) #0
  %19 = icmp eq ptr %.fca.0.extract, null
  %20 = or i1 %19, %result.i.i
  br i1 %20, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116, label %21

21:                                               ; preds = %3
  %result.i3.i = tail call i1 %17(i64 %16, i64 %15, i64 2582149688529881115, i64 ptrtoint (ptr @i8_typ to i64), ptr readonly %18) #0
  br i1 %result.i3.i, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116, label %22

22:                                               ; preds = %21
  %result.i4.i = tail call i1 %17(i64 %16, i64 %15, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %18) #0
  %result.i5.i = tail call i1 %17(i64 %16, i64 %15, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %18) #0
  %not.result.i4.i = xor i1 %result.i4.i, true
  %.reg2mem49.0.i = select i1 %not.result.i4.i, i1 true, i1 %result.i5.i
  br i1 %.reg2mem49.0.i, label %23, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116

23:                                               ; preds = %22
  %result.i6.i = tail call i1 %17(i64 %16, i64 %15, i64 -757315540097298781, i64 ptrtoint (ptr @f64_typ to i64), ptr readonly %18) #0
  br i1 %result.i6.i, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116, label %24

24:                                               ; preds = %23
  %not.result.i5.i = xor i1 %result.i5.i, true
  %.reg2mem47.0.i = or i1 %result.i4.i, %not.result.i5.i
  br i1 %.reg2mem47.0.i, label %25, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116

25:                                               ; preds = %24
  %result.i9.i = tail call i1 %17(i64 %16, i64 %15, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %18) #0
  %result.i9.not.i = xor i1 %result.i9.i, true
  %.reg2mem45.0.i = or i1 %result.i4.i, %result.i5.i
  %or.cond.i = select i1 %result.i9.not.i, i1 true, i1 %.reg2mem45.0.i
  br i1 %or.cond.i, label %.critedge.i, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116

.critedge.i:                                      ; preds = %25
  %result.i12.i = tail call i1 %17(i64 %16, i64 %15, i64 -2253724949814257982, i64 ptrtoint (ptr @i32_typ to i64), ptr readonly %18) #0
  br i1 %result.i12.i, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116, label %26

26:                                               ; preds = %.critedge.i
  %result.i13.i = tail call i1 %17(i64 %16, i64 %15, i64 5801531371504802705, i64 ptrtoint (ptr @bool_typ to i64), ptr readonly %18) #0
  %27 = select i1 %result.i13.i, i32 5, i32 1
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116: ; preds = %3, %21, %22, %23, %24, %25, %.critedge.i, %26
  %.reg2mem29.0.i = phi i32 [ 9, %3 ], [ 2, %21 ], [ 3, %23 ], [ %27, %26 ], [ 7, %.critedge.i ], [ 8, %24 ], [ 4, %22 ], [ 6, %25 ]
  %28 = zext nneg i32 %.reg2mem29.0.i to i64
  %29 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 72
  %31 = load ptr, ptr %30, align 8
  call void %31(ptr nonnull %10, { ptr, i160 } %9)
  %result.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nonnull @current_ptr) #29
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i, align 16
  %result.i22 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %32 = alloca { ptr, ptr, ptr, i32 }, align 8
  %33 = getelementptr inbounds i8, ptr %32, i64 8
  %34 = getelementptr inbounds i8, ptr %32, i64 24
  store ptr @String, ptr %32, align 8
  store ptr %result.i22, ptr %33, align 8
  store i32 9, ptr %34, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %32)
  store ptr %result.i, ptr %result.i22, align 8
  %36 = getelementptr i8, ptr %result.i22, i64 8
  store i32 14, ptr %36, align 4
  %37 = getelementptr i8, ptr %result.i22, i64 12
  store i32 15, ptr %37, align 4
  %38 = load i160, ptr %33, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %.sroa.3.8.extract.trunc.i = trunc i160 %38 to i64
  %40 = inttoptr i64 %.sroa.3.8.extract.trunc.i to ptr
  %41 = getelementptr i8, ptr %40, i64 8
  %42 = load i32, ptr %41, align 4
  %43 = add i32 %42, 1
  %44 = sext i32 %43 to i64
  %result.i.i306 = call noalias ptr @bump_malloc_inner(i64 noundef %44, ptr nonnull @current_ptr) #29
  %45 = load i32, ptr %41, align 4
  %46 = icmp sgt i32 %45, 0
  br i1 %46, label %.lr.ph.i, label %String_c_string_.exit

.lr.ph.i:                                         ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116
  %47 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %48 = load ptr, ptr %40, align 8
  %49 = zext nneg i32 %45 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i306, ptr align 1 %48, i64 %49, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %.lr.ph.i, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit116
  %50 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %51 = sext i32 %45 to i64
  %52 = getelementptr i8, ptr %result.i.i306, i64 %51
  store i8 0, ptr %52, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i306)
  %53 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %1)
  %result.i59 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nonnull @current_ptr) #29
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i59, align 16
  %result.i60 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %54 = alloca { ptr, ptr, ptr, i32 }, align 8
  %55 = getelementptr inbounds i8, ptr %54, i64 8
  %56 = getelementptr inbounds i8, ptr %54, i64 24
  store ptr @String, ptr %54, align 8
  store ptr %result.i60, ptr %55, align 8
  store i32 9, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %54)
  store ptr %result.i59, ptr %result.i60, align 8
  %58 = getelementptr i8, ptr %result.i60, i64 8
  store i32 14, ptr %58, align 4
  %59 = getelementptr i8, ptr %result.i60, i64 12
  store i32 15, ptr %59, align 4
  %60 = load i160, ptr %55, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %.sroa.3.8.extract.trunc.i231 = trunc i160 %60 to i64
  %62 = inttoptr i64 %.sroa.3.8.extract.trunc.i231 to ptr
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load i32, ptr %63, align 4
  %65 = add i32 %64, 1
  %66 = sext i32 %65 to i64
  %result.i.i320 = call noalias ptr @bump_malloc_inner(i64 noundef %66, ptr nonnull @current_ptr) #29
  %67 = load i32, ptr %63, align 4
  %68 = icmp sgt i32 %67, 0
  br i1 %68, label %.lr.ph.i321, label %String_c_string_.exit325

.lr.ph.i321:                                      ; preds = %String_c_string_.exit
  %69 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %70 = load ptr, ptr %62, align 8
  %71 = zext nneg i32 %67 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i320, ptr align 1 %70, i64 %71, i1 false)
  br label %String_c_string_.exit325

String_c_string_.exit325:                         ; preds = %.lr.ph.i321, %String_c_string_.exit
  %72 = sext i32 %67 to i64
  %73 = getelementptr i8, ptr %result.i.i320, i64 %72
  store i8 0, ptr %73, align 1
  %puts.i247 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i320)
  %74 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i64_string, i64 %2)
  %result.i97 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i97, align 4
  %result.i98 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %75 = alloca { ptr, ptr, ptr, i32 }, align 8
  %76 = getelementptr inbounds i8, ptr %75, i64 8
  %77 = getelementptr inbounds i8, ptr %75, i64 24
  store ptr @String, ptr %75, align 8
  store ptr %result.i98, ptr %76, align 8
  store i32 9, ptr %77, align 8
  %78 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %75)
  store ptr %result.i97, ptr %result.i98, align 8
  %79 = getelementptr i8, ptr %result.i98, i64 8
  store i32 3, ptr %79, align 4
  %80 = getelementptr i8, ptr %result.i98, i64 12
  store i32 4, ptr %80, align 4
  %81 = load i160, ptr %76, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %.sroa.3.8.extract.trunc.i250 = trunc i160 %81 to i64
  %83 = inttoptr i64 %.sroa.3.8.extract.trunc.i250 to ptr
  %84 = getelementptr i8, ptr %83, i64 8
  %85 = load i32, ptr %84, align 4
  %86 = add i32 %85, 1
  %87 = sext i32 %86 to i64
  %result.i.i339 = call noalias ptr @bump_malloc_inner(i64 noundef %87, ptr nonnull @current_ptr) #29
  %88 = load i32, ptr %84, align 4
  %89 = icmp sgt i32 %88, 0
  br i1 %89, label %.lr.ph.i340, label %String_c_string_.exit344

.lr.ph.i340:                                      ; preds = %String_c_string_.exit325
  %90 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %91 = load ptr, ptr %83, align 8
  %92 = zext nneg i32 %88 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i339, ptr align 1 %91, i64 %92, i1 false)
  br label %String_c_string_.exit344

String_c_string_.exit344:                         ; preds = %.lr.ph.i340, %String_c_string_.exit325
  %93 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %94 = sext i32 %88 to i64
  %95 = getelementptr i8, ptr %result.i.i339, i64 %94
  store i8 0, ptr %95, align 1
  %puts.i266 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i339)
  %96 = icmp sgt i32 %1, 0
  br i1 %96, label %97, label %._crit_edge

97:                                               ; preds = %String_c_string_.exit344
  %98 = icmp sgt i64 %2, 0
  br i1 %98, label %99, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit174

99:                                               ; preds = %97
  %100 = zext nneg i32 %1 to i64
  %101 = mul i64 %2, 1000000
  %102 = sdiv i64 %101, %100
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit174

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit174: ; preds = %97, %99
  %.reg2mem6.0 = phi i64 [ %102, %99 ], [ 0, %97 ]
  %result.i117 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i117, align 16
  %result.i118 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %103 = getelementptr inbounds i8, ptr %4, i64 8
  %104 = getelementptr inbounds i8, ptr %4, i64 24
  store ptr @String, ptr %4, align 8
  store ptr %result.i118, ptr %103, align 8
  store i32 9, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %4)
  store ptr %result.i117, ptr %result.i118, align 8
  %106 = getelementptr i8, ptr %result.i118, i64 8
  store i32 15, ptr %106, align 4
  %107 = getelementptr i8, ptr %result.i118, i64 12
  store i32 16, ptr %107, align 4
  %108 = load i160, ptr %103, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %.sroa.3.8.extract.trunc.i269 = trunc i160 %108 to i64
  %110 = inttoptr i64 %.sroa.3.8.extract.trunc.i269 to ptr
  %111 = getelementptr i8, ptr %110, i64 8
  %112 = load i32, ptr %111, align 4
  %113 = add i32 %112, 1
  %114 = sext i32 %113 to i64
  %result.i.i358 = call noalias ptr @bump_malloc_inner(i64 noundef %114, ptr nonnull @current_ptr) #29
  %115 = load i32, ptr %111, align 4
  %116 = icmp sgt i32 %115, 0
  br i1 %116, label %.lr.ph.i359, label %String_c_string_.exit363

.lr.ph.i359:                                      ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit174
  %117 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %118 = load ptr, ptr %110, align 8
  %119 = zext nneg i32 %115 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i358, ptr align 1 %118, i64 %119, i1 false)
  br label %String_c_string_.exit363

String_c_string_.exit363:                         ; preds = %.lr.ph.i359, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit174
  %120 = sext i32 %115 to i64
  %121 = getelementptr i8, ptr %result.i.i358, i64 %120
  store i8 0, ptr %121, align 1
  %puts.i285 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i358)
  %122 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i64_string, i64 %.reg2mem6.0)
  %result.i155 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i155, align 4
  %result.i156 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %123 = getelementptr inbounds i8, ptr %5, i64 8
  %124 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @String, ptr %5, align 8
  store ptr %result.i156, ptr %123, align 8
  store i32 9, ptr %124, align 8
  %125 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %5)
  store ptr %result.i155, ptr %result.i156, align 8
  %126 = getelementptr i8, ptr %result.i156, i64 8
  store i32 3, ptr %126, align 4
  %127 = getelementptr i8, ptr %result.i156, i64 12
  store i32 4, ptr %127, align 4
  %128 = load i160, ptr %123, align 8
  %129 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %.sroa.3.8.extract.trunc.i288 = trunc i160 %128 to i64
  %130 = inttoptr i64 %.sroa.3.8.extract.trunc.i288 to ptr
  %131 = getelementptr i8, ptr %130, i64 8
  %132 = load i32, ptr %131, align 4
  %133 = add i32 %132, 1
  %134 = sext i32 %133 to i64
  %result.i.i377 = call noalias ptr @bump_malloc_inner(i64 noundef %134, ptr nonnull @current_ptr) #29
  %135 = load i32, ptr %131, align 4
  %136 = icmp sgt i32 %135, 0
  br i1 %136, label %.lr.ph.i378, label %String_c_string_.exit382

.lr.ph.i378:                                      ; preds = %String_c_string_.exit363
  %137 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %138 = load ptr, ptr %130, align 8
  %139 = zext nneg i32 %135 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i377, ptr align 1 %138, i64 %139, i1 false)
  br label %String_c_string_.exit382

String_c_string_.exit382:                         ; preds = %.lr.ph.i378, %String_c_string_.exit363
  %140 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %141 = sext i32 %135 to i64
  %142 = getelementptr i8, ptr %result.i.i377, i64 %141
  store i8 0, ptr %142, align 1
  %puts.i304 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i377)
  br label %._crit_edge

._crit_edge:                                      ; preds = %String_c_string_.exit344, %String_c_string_.exit382
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %.sroa.0680.i558 = alloca ptr, align 8
  %16 = alloca i64, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [2 x ptr], align 8
  %20 = alloca { ptr, ptr }, align 8
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %.sroa.0.i560 = alloca ptr, align 8
  %24 = alloca i64, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  %30 = alloca { ptr, ptr, ptr, i32 }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [2 x ptr], align 8
  %34 = alloca { ptr, ptr }, align 8
  %35 = alloca i32, align 4
  %36 = alloca i32, align 4
  %37 = alloca i32, align 4
  %.sroa.0680.i = alloca ptr, align 8
  %38 = alloca i64, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [2 x ptr], align 8
  %42 = alloca { ptr, ptr }, align 8
  %43 = alloca i32, align 4
  %44 = alloca i32, align 4
  %45 = alloca i32, align 4
  %.sroa.0.i350 = alloca ptr, align 8
  %46 = alloca i64, align 8
  %47 = alloca { ptr, ptr, ptr, i32 }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.sroa.0271.i = alloca ptr, align 8
  %.sroa.1.i = alloca i160, align 8
  %.sroa.0.i = alloca ptr, align 8
  %.sroa.2.i = alloca i160, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %.sroa.0123.i = alloca ptr, align 8
  %.sroa.2124.i = alloca i160, align 8
  %.sroa.0115.i = alloca ptr, align 8
  %.sroa.2116.i = alloca i160, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca { ptr, ptr, ptr, i32 }, align 8
  %59 = alloca [2 x ptr], align 8
  %60 = alloca { ptr, ptr }, align 8
  %61 = alloca [1 x ptr], align 8
  %62 = alloca { ptr }, align 8
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  %64 = alloca [2 x ptr], align 8
  %65 = alloca { ptr, ptr }, align 8
  %66 = alloca { ptr, ptr, ptr, i32 }, align 8
  %67 = alloca [1 x ptr], align 8
  %68 = alloca { ptr }, align 8
  %oldProtect.i33 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %69 = alloca { ptr, ptr, ptr, i32 }, align 8
  %70 = alloca { ptr, ptr, ptr, i32 }, align 8
  %71 = alloca { ptr, ptr, ptr, i32 }, align 8
  %result.i = tail call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i, align 8
  %72 = getelementptr i8, ptr %result.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %72, align 8
  %73 = getelementptr i8, ptr %result.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %73, align 8
  %74 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i)
  %result.i30 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i31 = call i32 @VirtualProtect(ptr %result.i30, i64 16, i32 64, ptr nonnull %oldProtect.i) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr %result.i30, ptr nonnull @gavxfslpwi, ptr nonnull @i32_hasher)
  %ret.i = call ptr @llvm.adjust.trampoline(ptr readonly %result.i30) #31
  %75 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i30)
  %result.i32 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i33)
  %result.i34 = call i32 @VirtualProtect(ptr %result.i32, i64 16, i32 64, ptr nonnull %oldProtect.i33) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i33)
  call void @llvm.init.trampoline(ptr %result.i32, ptr nonnull @clihccxsyp, ptr nonnull @i32_eq)
  %ret.i35 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i32) #31
  %76 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i32)
  %77 = getelementptr i8, ptr %result.i, i64 96
  store ptr %ret.i, ptr %77, align 8
  %78 = getelementptr i8, ptr %result.i, i64 104
  store ptr %ret.i35, ptr %78, align 8
  %result.i.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %79 = getelementptr i8, ptr %result.i.i, i64 16
  store ptr @_parameterization_Nil, ptr %79, align 8
  %result.i4.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %80 = getelementptr i8, ptr %result.i4.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %80, align 8
  %81 = getelementptr i8, ptr %result.i4.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %81, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i)
  store ptr @Entry, ptr %result.i4.i, align 8
  %83 = getelementptr i8, ptr %result.i.i, i64 8
  store ptr %result.i4.i, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i)
  store ptr @union_typ, ptr %result.i.i, align 8
  %result.i5.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i, ptr %result.i5.i, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i)
  %86 = getelementptr i8, ptr %result.i5.i, i64 16
  store i32 8, ptr %86, align 4
  %87 = getelementptr i8, ptr %result.i5.i, i64 20
  store i32 8, ptr %87, align 4
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %88 = getelementptr i8, ptr %result.i5.i, i64 8
  store ptr %result.i.i.i, ptr %88, align 8
  %89 = getelementptr i8, ptr %result.i, i64 24
  store ptr @Array, ptr %89, align 8
  %90 = getelementptr i8, ptr %result.i, i64 32
  store ptr %result.i5.i, ptr %90, align 8
  %91 = getelementptr i8, ptr %result.i, i64 40
  %92 = getelementptr i8, ptr %result.i, i64 48
  store i32 9, ptr %92, align 4
  %result.i20.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %93 = getelementptr i8, ptr %result.i20.i, i64 16
  store ptr @_parameterization_Nil, ptr %93, align 8
  %result.i21.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %94 = getelementptr i8, ptr %result.i21.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %94, align 8
  %95 = getelementptr i8, ptr %result.i21.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %95, align 8
  %96 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i)
  store ptr @Entry, ptr %result.i21.i, align 8
  %97 = getelementptr i8, ptr %result.i20.i, i64 8
  store ptr %result.i21.i, ptr %97, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i)
  store ptr @union_typ, ptr %result.i20.i, align 8
  %result.i22.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i, ptr %result.i22.i, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i)
  %100 = getelementptr i8, ptr %result.i22.i, i64 16
  store i32 8, ptr %100, align 4
  %101 = getelementptr i8, ptr %result.i22.i, i64 20
  store i32 8, ptr %101, align 4
  %result.i.i97.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %102 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %103 = getelementptr i8, ptr %result.i22.i, i64 8
  store ptr %result.i.i97.i, ptr %103, align 8
  %104 = getelementptr i8, ptr %result.i, i64 56
  store ptr @Array, ptr %104, align 8
  %105 = getelementptr i8, ptr %result.i, i64 64
  store ptr %result.i22.i, ptr %105, align 8
  %106 = getelementptr i8, ptr %result.i, i64 72
  %107 = getelementptr i8, ptr %result.i, i64 80
  store i32 9, ptr %107, align 4
  %108 = getelementptr i8, ptr %result.i, i64 88
  %109 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %110 = getelementptr i8, ptr %result.i, i64 112
  store i32 100, ptr %110, align 4
  %111 = call i64 @clock()
  %112 = icmp sgt i32 %0, 0
  br i1 %112, label %._crit_edge.preheader, label %1592

._crit_edge.preheader:                            ; preds = %1
  %113 = getelementptr inbounds i8, ptr %66, i64 8
  %114 = getelementptr inbounds i8, ptr %66, i64 24
  %115 = getelementptr inbounds i8, ptr %66, i64 16
  %116 = getelementptr inbounds i8, ptr %63, i64 8
  %117 = getelementptr inbounds i8, ptr %63, i64 24
  %118 = getelementptr inbounds i8, ptr %63, i64 16
  %119 = getelementptr inbounds i8, ptr %64, i64 8
  %120 = getelementptr inbounds i8, ptr %65, i64 8
  %121 = getelementptr inbounds i8, ptr %58, i64 8
  %122 = getelementptr inbounds i8, ptr %58, i64 24
  %123 = getelementptr inbounds i8, ptr %58, i64 16
  %124 = getelementptr inbounds i8, ptr %59, i64 8
  %125 = getelementptr inbounds i8, ptr %60, i64 8
  %126 = getelementptr inbounds i8, ptr %52, i64 8
  %127 = getelementptr inbounds i8, ptr %52, i64 24
  %128 = getelementptr inbounds i8, ptr %52, i64 16
  %129 = getelementptr inbounds i8, ptr %53, i64 8
  %130 = getelementptr inbounds i8, ptr %53, i64 24
  %131 = getelementptr inbounds i8, ptr %53, i64 16
  %132 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %133 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr undef, 2
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, i32 9, 3
  %135 = getelementptr inbounds i8, ptr %47, i64 8
  %136 = getelementptr inbounds i8, ptr %47, i64 16
  %137 = getelementptr inbounds i8, ptr %47, i64 24
  %138 = getelementptr inbounds i8, ptr %41, i64 8
  %139 = getelementptr inbounds i8, ptr %42, i64 8
  %140 = getelementptr inbounds i8, ptr %33, i64 8
  %141 = getelementptr inbounds i8, ptr %34, i64 8
  %142 = getelementptr inbounds i8, ptr %29, i64 8
  %143 = getelementptr inbounds i8, ptr %29, i64 24
  %144 = getelementptr inbounds i8, ptr %29, i64 16
  %145 = getelementptr inbounds i8, ptr %30, i64 8
  %146 = getelementptr inbounds i8, ptr %30, i64 24
  %147 = getelementptr inbounds i8, ptr %30, i64 16
  %148 = getelementptr inbounds i8, ptr %19, i64 8
  %149 = getelementptr inbounds i8, ptr %20, i64 8
  %150 = getelementptr inbounds i8, ptr %11, i64 8
  %151 = getelementptr inbounds i8, ptr %12, i64 8
  %152 = getelementptr inbounds i8, ptr %7, i64 8
  %153 = getelementptr inbounds i8, ptr %7, i64 24
  %154 = getelementptr inbounds i8, ptr %7, i64 16
  %155 = getelementptr inbounds i8, ptr %8, i64 8
  %156 = getelementptr inbounds i8, ptr %8, i64 24
  %157 = getelementptr inbounds i8, ptr %8, i64 16
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %HashMap_insert_keyK_valueV.exit
  %.reg2mem48.085 = phi i32 [ %158, %HashMap_insert_keyK_valueV.exit ], [ 0, %._crit_edge.preheader ]
  %158 = add nuw nsw i32 %.reg2mem48.085, 1
  %.sroa.023.0.insert.ext = zext nneg i32 %.reg2mem48.085 to i160
  %159 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.023.0.insert.ext, 1
  %.sroa.020.0.insert.ext = zext nneg i32 %158 to i160
  %160 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.020.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %59)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %60)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %62)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %63)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %64)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %65)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %66)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %68)
  %161 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %162 = load ptr, ptr %77, align 8
  %163 = call i32 %162({ ptr, i160 } %159)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %164 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %165 = load ptr, ptr %89, align 8
  %166 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %165, 0
  %167 = load ptr, ptr %90, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } %166, ptr %167, 1
  %169 = load ptr, ptr %91, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %169, 2
  %171 = load i32, ptr %92, align 4
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, i32 %171, 3
  %hash_coef_ptr.i.i10.i = getelementptr i8, ptr %165, i64 8
  %tbl_size_ptr.i.i11.i = getelementptr i8, ptr %165, i64 16
  %offset_tbl_ptr.i.i12.i = getelementptr i8, ptr %165, i64 40
  %hash_coef.i.i13.i = load i64, ptr %hash_coef_ptr.i.i10.i, align 4
  %tbl_size.i.i14.i = load i64, ptr %tbl_size_ptr.i.i11.i, align 4
  %offset_tbl.i.i15.i = load ptr, ptr %offset_tbl_ptr.i.i12.i, align 8
  %product.i.i.i16.i = mul i64 %hash_coef.i.i13.i, -5261542750394134544
  %shifted.i.i.i17.i = lshr i64 %product.i.i.i16.i, 32
  %xored.i.i.i18.i = xor i64 %shifted.i.i.i17.i, %product.i.i.i16.i
  %hash.i.i.i19.i = and i64 %xored.i.i.i18.i, %tbl_size.i.i14.i
  %offset_ptr.i.i20.i = getelementptr i32, ptr %offset_tbl.i.i15.i, i64 %hash.i.i.i19.i
  %offset.i.i21.i = load i32, ptr %offset_ptr.i.i20.i, align 4
  %eq.i.i297 = icmp eq i32 %171, %offset.i.i21.i
  call void @llvm.assume(i1 %eq.i.i297) #30
  %173 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %174 = call ptr @llvm.invariant.start.p0(i64 600, ptr %165)
  %175 = sext i32 %171 to i64
  %176 = getelementptr ptr, ptr %165, i64 %175
  %177 = getelementptr i8, ptr %176, i64 64
  %178 = load ptr, ptr %177, align 8
  %179 = call ptr %178({ ptr, ptr, ptr, i32 } %172, ptr nonnull %2)
  %180 = call i32 %179({ ptr, ptr, ptr, i32 } %172, { ptr, ptr, ptr, i32 } %172, ptr nonnull %2)
  %181 = add i32 %180, -1
  %182 = and i32 %181, %163
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %183 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %184 = load ptr, ptr %89, align 8
  %185 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %184, 0
  %186 = load ptr, ptr %90, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %186, 1
  %188 = load ptr, ptr %91, align 8
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, ptr %188, 2
  %190 = load i32, ptr %92, align 4
  %191 = insertvalue { ptr, ptr, ptr, i32 } %189, i32 %190, 3
  %hash_coef_ptr.i.i162.i = getelementptr i8, ptr %184, i64 8
  %tbl_size_ptr.i.i163.i = getelementptr i8, ptr %184, i64 16
  %offset_tbl_ptr.i.i164.i = getelementptr i8, ptr %184, i64 40
  %hash_coef.i.i165.i = load i64, ptr %hash_coef_ptr.i.i162.i, align 4
  %tbl_size.i.i166.i = load i64, ptr %tbl_size_ptr.i.i163.i, align 4
  %offset_tbl.i.i167.i = load ptr, ptr %offset_tbl_ptr.i.i164.i, align 8
  %product.i.i.i168.i = mul i64 %hash_coef.i.i165.i, -5261542750394134544
  %shifted.i.i.i169.i = lshr i64 %product.i.i.i168.i, 32
  %xored.i.i.i170.i = xor i64 %shifted.i.i.i169.i, %product.i.i.i168.i
  %hash.i.i.i171.i = and i64 %xored.i.i.i170.i, %tbl_size.i.i166.i
  %offset_ptr.i.i172.i = getelementptr i32, ptr %offset_tbl.i.i167.i, i64 %hash.i.i.i171.i
  %offset.i.i173.i = load i32, ptr %offset_ptr.i.i172.i, align 4
  %eq.i.i = icmp eq i32 %190, %offset.i.i173.i
  call void @llvm.assume(i1 %eq.i.i) #30
  store ptr @_parameterization_Ptri32, ptr %67, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %67)
  %193 = call ptr @llvm.invariant.start.p0(i64 600, ptr %184)
  %194 = sext i32 %190 to i64
  %195 = getelementptr ptr, ptr %184, i64 %194
  %196 = getelementptr i8, ptr %195, i64 120
  %197 = load ptr, ptr %196, align 8
  store ptr @i32_typ, ptr %68, align 8
  %198 = call ptr %197({ ptr, ptr, ptr, i32 } %191, ptr nonnull %68)
  %199 = call { ptr, i160 } %198({ ptr, ptr, ptr, i32 } %191, { ptr, ptr, ptr, i32 } %191, ptr nonnull %67, i32 %182)
  %.fca.0.extract.i = extractvalue { ptr, i160 } %199, 0
  %200 = icmp ne ptr %.fca.0.extract.i, @nil_typ
  %201 = icmp ne ptr %.fca.0.extract.i, null
  %.not149.i = and i1 %200, %201
  br i1 %.not149.i, label %202, label %.critedge.i

202:                                              ; preds = %._crit_edge
  %.fca.1.extract.i = extractvalue { ptr, i160 } %199, 1
  %.sroa.4520.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i64
  %203 = inttoptr i64 %.sroa.4520.8.extract.trunc.i to ptr
  %.sroa.7522.8.extract.shift.i = lshr i160 %.fca.1.extract.i, 64
  %.sroa.7522.8.extract.trunc.i = trunc i160 %.sroa.7522.8.extract.shift.i to i64
  %204 = inttoptr i64 %.sroa.7522.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract.i, i64 8
  %tbl_size_ptr.i.i177.i = getelementptr i8, ptr %.fca.0.extract.i, i64 16
  %offset_tbl_ptr.i.i178.i = getelementptr i8, ptr %.fca.0.extract.i, i64 40
  %hash_coef.i.i179.i = load i64, ptr %hash_coef_ptr.i.i176.i, align 4
  %tbl_size.i.i180.i = load i64, ptr %tbl_size_ptr.i.i177.i, align 4
  %offset_tbl.i.i181.i = load ptr, ptr %offset_tbl_ptr.i.i178.i, align 8
  %product.i.i.i182.i = mul i64 %hash_coef.i.i179.i, 4015701072841558310
  %shifted.i.i.i183.i = lshr i64 %product.i.i.i182.i, 32
  %xored.i.i.i184.i = xor i64 %shifted.i.i.i183.i, %product.i.i.i182.i
  %hash.i.i.i185.i = and i64 %xored.i.i.i184.i, %tbl_size.i.i180.i
  %offset_ptr.i.i186.i = getelementptr i32, ptr %offset_tbl.i.i181.i, i64 %hash.i.i.i185.i
  %offset.i.i187.i = load i32, ptr %offset_ptr.i.i186.i, align 4
  %205 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i, 0
  %206 = insertvalue { ptr, ptr, ptr, i32 } %205, ptr %203, 1
  %207 = insertvalue { ptr, ptr, ptr, i32 } %206, ptr %204, 2
  %208 = insertvalue { ptr, ptr, ptr, i32 } %207, i32 %offset.i.i187.i, 3
  %209 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %210 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %211 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i)
  %212 = sext i32 %offset.i.i187.i to i64
  %213 = getelementptr ptr, ptr %.fca.0.extract.i, i64 %212
  %214 = getelementptr i8, ptr %213, i64 64
  %215 = load ptr, ptr %214, align 8
  %216 = call ptr %215({ ptr, ptr, ptr, i32 } %208, ptr nonnull %2)
  %217 = call i32 %216({ ptr, ptr, ptr, i32 } %208, { ptr, ptr, ptr, i32 } %208, ptr nonnull %2)
  %218 = icmp eq i32 %217, %163
  %219 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %220 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %221 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i)
  %222 = getelementptr i8, ptr %213, i64 48
  %223 = load ptr, ptr %222, align 8
  %224 = call ptr %223({ ptr, ptr, ptr, i32 } %208, ptr nonnull %2)
  %225 = call { ptr, i160 } %224({ ptr, ptr, ptr, i32 } %208, { ptr, ptr, ptr, i32 } %208, ptr nonnull %2)
  %226 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %227 = load ptr, ptr %78, align 8
  %228 = call i1 %227({ ptr, i160 } %225, { ptr, i160 } %159)
  %229 = and i1 %218, %228
  br i1 %229, label %230, label %.critedge.i

230:                                              ; preds = %202
  %231 = load ptr, ptr %result.i, align 8
  %232 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %233 = load ptr, ptr %72, align 8
  %234 = load ptr, ptr %231, align 8
  %235 = getelementptr i8, ptr %234, i64 48
  %236 = load ptr, ptr %235, align 8
  %237 = call { i64, i64 } %236(ptr nonnull %231)
  %238 = extractvalue { i64, i64 } %237, 0
  %239 = extractvalue { i64, i64 } %237, 1
  %240 = urem i64 20, %239
  %241 = icmp eq i64 %240, 0
  %242 = sub i64 %239, %240
  %243 = select i1 %241, i64 0, i64 %242
  %244 = add i64 %238, 20
  %245 = add i64 %244, %243
  %246 = load ptr, ptr %233, align 8
  %247 = getelementptr i8, ptr %246, i64 48
  %248 = load ptr, ptr %247, align 8
  %249 = call { i64, i64 } %248(ptr nonnull %233)
  %250 = extractvalue { i64, i64 } %249, 0
  %251 = extractvalue { i64, i64 } %249, 1
  %252 = call i64 @llvm.umax.i64(i64 %239, i64 %251)
  %253 = call i64 @llvm.umax.i64(i64 %252, i64 8)
  %254 = urem i64 %245, %251
  %255 = icmp eq i64 %254, 0
  %256 = sub i64 %251, %254
  %257 = select i1 %255, i64 0, i64 %256
  %258 = add i64 %250, %245
  %259 = add i64 %258, %257
  %260 = urem i64 %259, %253
  %261 = icmp eq i64 %260, 0
  %262 = sub i64 %253, %260
  %263 = select i1 %261, i64 0, i64 %262
  %264 = add i64 %263, %259
  %result.i.i154 = call noalias ptr @bump_malloc_inner(i64 noundef %264, ptr nonnull @current_ptr) #29
  store ptr %231, ptr %result.i.i154, align 8
  %265 = getelementptr i8, ptr %result.i.i154, i64 8
  store ptr %233, ptr %265, align 8
  %266 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i154)
  store ptr @Entry, ptr %58, align 8
  store ptr %result.i.i154, ptr %121, align 8
  store i32 9, ptr %122, align 8
  %267 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %58)
  %268 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %269 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %270 = load ptr, ptr %231, align 8
  %271 = getelementptr i8, ptr %270, i64 48
  %272 = load ptr, ptr %271, align 8
  %273 = call { i64, i64 } %272(ptr nonnull %231)
  %274 = extractvalue { i64, i64 } %273, 1
  %275 = urem i64 20, %274
  %276 = icmp eq i64 %275, 0
  %reass.sub1416 = sub i64 %274, %275
  %277 = add i64 %reass.sub1416, 20
  %278 = select i1 %276, i64 20, i64 %277
  %279 = getelementptr i8, ptr %result.i.i154, i64 %278
  %280 = load ptr, ptr %result.i.i154, align 8
  %281 = load ptr, ptr %280, align 8
  %282 = getelementptr i8, ptr %281, i64 64
  %283 = load ptr, ptr %282, align 8
  call void %283({ ptr, i160 } %159, ptr nonnull %280, ptr %279)
  %284 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %285 = load ptr, ptr %result.i.i154, align 8
  %286 = load ptr, ptr %285, align 8
  %287 = getelementptr i8, ptr %286, i64 48
  %288 = load ptr, ptr %287, align 8
  %289 = call { i64, i64 } %288(ptr nonnull %285)
  %290 = extractvalue { i64, i64 } %289, 0
  %291 = extractvalue { i64, i64 } %289, 1
  %292 = urem i64 20, %291
  %293 = icmp eq i64 %292, 0
  %294 = sub i64 %291, %292
  %295 = select i1 %293, i64 0, i64 %294
  %296 = add i64 %290, 20
  %297 = add i64 %296, %295
  %298 = load ptr, ptr %265, align 8
  %299 = load ptr, ptr %298, align 8
  %300 = getelementptr i8, ptr %299, i64 48
  %301 = load ptr, ptr %300, align 8
  %302 = call { i64, i64 } %301(ptr nonnull %298)
  %303 = extractvalue { i64, i64 } %302, 1
  %304 = urem i64 %297, %303
  %305 = icmp eq i64 %304, 0
  %306 = sub i64 %303, %304
  %307 = select i1 %305, i64 0, i64 %306
  %308 = getelementptr i8, ptr %result.i.i154, i64 %297
  %309 = getelementptr i8, ptr %308, i64 %307
  %310 = load ptr, ptr %265, align 8
  %311 = load ptr, ptr %310, align 8
  %312 = getelementptr i8, ptr %311, i64 64
  %313 = load ptr, ptr %312, align 8
  call void %313({ ptr, i160 } %160, ptr nonnull %310, ptr %309)
  %314 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %315 = getelementptr i8, ptr %result.i.i154, i64 16
  store i32 %163, ptr %315, align 4
  %316 = load ptr, ptr %123, align 8
  %317 = ptrtoint ptr %result.i.i154 to i64
  %318 = ptrtoint ptr %316 to i64
  %.sroa.2127.0.insert.ext.i = zext i64 %318 to i160
  %.sroa.2127.0.insert.shift.i = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i, 64
  %.sroa.0126.0.insert.ext.i = zext i64 %317 to i160
  %.sroa.2127.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.shift.i, %.sroa.0126.0.insert.ext.i
  %.sroa.0126.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.insert.i, 3062541302288446171170371466885913903104
  %319 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i, 1
  %320 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %321 = load ptr, ptr %89, align 8
  %322 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %321, 0
  %323 = load ptr, ptr %90, align 8
  %324 = insertvalue { ptr, ptr, ptr, i32 } %322, ptr %323, 1
  %325 = load ptr, ptr %91, align 8
  %326 = insertvalue { ptr, ptr, ptr, i32 } %324, ptr %325, 2
  %327 = load i32, ptr %92, align 4
  %328 = insertvalue { ptr, ptr, ptr, i32 } %326, i32 %327, 3
  %hash_coef_ptr.i.i204.i = getelementptr i8, ptr %321, i64 8
  %tbl_size_ptr.i.i205.i = getelementptr i8, ptr %321, i64 16
  %offset_tbl_ptr.i.i206.i = getelementptr i8, ptr %321, i64 40
  %hash_coef.i.i207.i = load i64, ptr %hash_coef_ptr.i.i204.i, align 4
  %tbl_size.i.i208.i = load i64, ptr %tbl_size_ptr.i.i205.i, align 4
  %offset_tbl.i.i209.i = load ptr, ptr %offset_tbl_ptr.i.i206.i, align 8
  %product.i.i.i210.i = mul i64 %hash_coef.i.i207.i, -5261542750394134544
  %shifted.i.i.i211.i = lshr i64 %product.i.i.i210.i, 32
  %xored.i.i.i212.i = xor i64 %shifted.i.i.i211.i, %product.i.i.i210.i
  %hash.i.i.i213.i = and i64 %xored.i.i.i212.i, %tbl_size.i.i208.i
  %offset_ptr.i.i214.i = getelementptr i32, ptr %offset_tbl.i.i209.i, i64 %hash.i.i.i213.i
  %offset.i.i215.i = load i32, ptr %offset_ptr.i.i214.i, align 4
  %eq.i218.i = icmp eq i32 %327, %offset.i.i215.i
  call void @llvm.assume(i1 %eq.i218.i) #30
  %329 = load ptr, ptr %result.i, align 8
  %330 = load ptr, ptr %72, align 8
  %result.i219.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %331 = getelementptr i8, ptr %result.i219.i, i64 16
  store ptr %330, ptr %331, align 8
  %332 = getelementptr i8, ptr %result.i219.i, i64 8
  store ptr %329, ptr %332, align 8
  %333 = getelementptr i8, ptr %result.i219.i, i64 24
  store ptr null, ptr %333, align 8
  %334 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i)
  store ptr @Entry, ptr %result.i219.i, align 8
  store ptr @_parameterization_Ptri32, ptr %59, align 8
  store ptr %result.i219.i, ptr %124, align 8
  %335 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %59)
  %336 = call ptr @llvm.invariant.start.p0(i64 600, ptr %321)
  %337 = sext i32 %327 to i64
  %338 = getelementptr ptr, ptr %321, i64 %337
  %339 = getelementptr i8, ptr %338, i64 128
  %340 = load ptr, ptr %339, align 8
  store ptr @i32_typ, ptr %60, align 8
  store ptr @Entry, ptr %125, align 8
  %341 = call ptr %340({ ptr, ptr, ptr, i32 } %328, ptr nonnull %60)
  call void %341({ ptr, ptr, ptr, i32 } %328, { ptr, ptr, ptr, i32 } %328, ptr nonnull %59, i32 %182, { ptr, i160 } %319)
  br label %HashMap_insert_keyK_valueV.exit

.critedge.i:                                      ; preds = %202, %._crit_edge
  %342 = add i32 %163, 2127912214
  %343 = shl i32 %163, 12
  %344 = add i32 %342, %343
  %345 = ashr i32 %344, 19
  %346 = xor i32 %344, %345
  %347 = xor i32 %346, -949894596
  %348 = add i32 %347, 374761393
  %349 = shl i32 %347, 5
  %350 = add i32 %348, %349
  %351 = add i32 %350, -744332180
  %352 = shl i32 %350, 9
  %353 = xor i32 %351, %352
  %354 = add i32 %353, -42973499
  %355 = shl i32 %353, 3
  %356 = add i32 %354, %355
  %357 = ashr i32 %356, 16
  %358 = xor i32 %356, %357
  %359 = xor i32 %358, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %360 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %361 = load ptr, ptr %104, align 8
  %362 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %361, 0
  %363 = load ptr, ptr %105, align 8
  %364 = insertvalue { ptr, ptr, ptr, i32 } %362, ptr %363, 1
  %365 = load ptr, ptr %106, align 8
  %366 = insertvalue { ptr, ptr, ptr, i32 } %364, ptr %365, 2
  %367 = load i32, ptr %107, align 4
  %368 = insertvalue { ptr, ptr, ptr, i32 } %366, i32 %367, 3
  %hash_coef_ptr.i.i10.i315 = getelementptr i8, ptr %361, i64 8
  %tbl_size_ptr.i.i11.i316 = getelementptr i8, ptr %361, i64 16
  %offset_tbl_ptr.i.i12.i317 = getelementptr i8, ptr %361, i64 40
  %hash_coef.i.i13.i318 = load i64, ptr %hash_coef_ptr.i.i10.i315, align 4
  %tbl_size.i.i14.i319 = load i64, ptr %tbl_size_ptr.i.i11.i316, align 4
  %offset_tbl.i.i15.i320 = load ptr, ptr %offset_tbl_ptr.i.i12.i317, align 8
  %product.i.i.i16.i321 = mul i64 %hash_coef.i.i13.i318, -5261542750394134544
  %shifted.i.i.i17.i322 = lshr i64 %product.i.i.i16.i321, 32
  %xored.i.i.i18.i323 = xor i64 %shifted.i.i.i17.i322, %product.i.i.i16.i321
  %hash.i.i.i19.i324 = and i64 %xored.i.i.i18.i323, %tbl_size.i.i14.i319
  %offset_ptr.i.i20.i325 = getelementptr i32, ptr %offset_tbl.i.i15.i320, i64 %hash.i.i.i19.i324
  %offset.i.i21.i326 = load i32, ptr %offset_ptr.i.i20.i325, align 4
  %eq.i.i327 = icmp eq i32 %367, %offset.i.i21.i326
  call void @llvm.assume(i1 %eq.i.i327) #30
  %369 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %370 = call ptr @llvm.invariant.start.p0(i64 600, ptr %361)
  %371 = sext i32 %367 to i64
  %372 = getelementptr ptr, ptr %361, i64 %371
  %373 = getelementptr i8, ptr %372, i64 64
  %374 = load ptr, ptr %373, align 8
  %375 = call ptr %374({ ptr, ptr, ptr, i32 } %368, ptr nonnull %2)
  %376 = call i32 %375({ ptr, ptr, ptr, i32 } %368, { ptr, ptr, ptr, i32 } %368, ptr nonnull %2)
  %377 = add i32 %376, -1
  %378 = and i32 %377, %359
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %379 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %380 = load ptr, ptr %104, align 8
  %381 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %380, 0
  %382 = load ptr, ptr %105, align 8
  %383 = insertvalue { ptr, ptr, ptr, i32 } %381, ptr %382, 1
  %384 = load ptr, ptr %106, align 8
  %385 = insertvalue { ptr, ptr, ptr, i32 } %383, ptr %384, 2
  %386 = load i32, ptr %107, align 4
  %387 = insertvalue { ptr, ptr, ptr, i32 } %385, i32 %386, 3
  %hash_coef_ptr.i.i221.i = getelementptr i8, ptr %380, i64 8
  %tbl_size_ptr.i.i222.i = getelementptr i8, ptr %380, i64 16
  %offset_tbl_ptr.i.i223.i = getelementptr i8, ptr %380, i64 40
  %hash_coef.i.i224.i = load i64, ptr %hash_coef_ptr.i.i221.i, align 4
  %tbl_size.i.i225.i = load i64, ptr %tbl_size_ptr.i.i222.i, align 4
  %offset_tbl.i.i226.i = load ptr, ptr %offset_tbl_ptr.i.i223.i, align 8
  %product.i.i.i227.i = mul i64 %hash_coef.i.i224.i, -5261542750394134544
  %shifted.i.i.i228.i = lshr i64 %product.i.i.i227.i, 32
  %xored.i.i.i229.i = xor i64 %shifted.i.i.i228.i, %product.i.i.i227.i
  %hash.i.i.i230.i = and i64 %xored.i.i.i229.i, %tbl_size.i.i225.i
  %offset_ptr.i.i231.i = getelementptr i32, ptr %offset_tbl.i.i226.i, i64 %hash.i.i.i230.i
  %offset.i.i232.i = load i32, ptr %offset_ptr.i.i231.i, align 4
  %eq.i235.i = icmp eq i32 %386, %offset.i.i232.i
  call void @llvm.assume(i1 %eq.i235.i) #30
  store ptr @_parameterization_Ptri32, ptr %61, align 8
  %388 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %61)
  %389 = call ptr @llvm.invariant.start.p0(i64 600, ptr %380)
  %390 = sext i32 %386 to i64
  %391 = getelementptr ptr, ptr %380, i64 %390
  %392 = getelementptr i8, ptr %391, i64 120
  %393 = load ptr, ptr %392, align 8
  store ptr @i32_typ, ptr %62, align 8
  %394 = call ptr %393({ ptr, ptr, ptr, i32 } %387, ptr nonnull %62)
  %395 = call { ptr, i160 } %394({ ptr, ptr, ptr, i32 } %387, { ptr, ptr, ptr, i32 } %387, ptr nonnull %61, i32 %378)
  %.fca.0.extract102.i = extractvalue { ptr, i160 } %395, 0
  %396 = icmp ne ptr %.fca.0.extract102.i, @nil_typ
  %397 = icmp ne ptr %.fca.0.extract102.i, null
  %.not151.i = and i1 %396, %397
  br i1 %.not151.i, label %398, label %.critedge158.i

398:                                              ; preds = %.critedge.i
  %.fca.1.extract104.i = extractvalue { ptr, i160 } %395, 1
  %.sroa.4.8.extract.trunc.i = trunc i160 %.fca.1.extract104.i to i64
  %399 = inttoptr i64 %.sroa.4.8.extract.trunc.i to ptr
  %.sroa.7508.8.extract.shift.i = lshr i160 %.fca.1.extract104.i, 64
  %.sroa.7508.8.extract.trunc.i = trunc i160 %.sroa.7508.8.extract.shift.i to i64
  %400 = inttoptr i64 %.sroa.7508.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i237.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 8
  %tbl_size_ptr.i.i238.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 16
  %offset_tbl_ptr.i.i239.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 40
  %hash_coef.i.i240.i = load i64, ptr %hash_coef_ptr.i.i237.i, align 4
  %tbl_size.i.i241.i = load i64, ptr %tbl_size_ptr.i.i238.i, align 4
  %offset_tbl.i.i242.i = load ptr, ptr %offset_tbl_ptr.i.i239.i, align 8
  %product.i.i.i243.i = mul i64 %hash_coef.i.i240.i, 4015701072841558310
  %shifted.i.i.i244.i = lshr i64 %product.i.i.i243.i, 32
  %xored.i.i.i245.i = xor i64 %shifted.i.i.i244.i, %product.i.i.i243.i
  %hash.i.i.i246.i = and i64 %xored.i.i.i245.i, %tbl_size.i.i241.i
  %offset_ptr.i.i247.i = getelementptr i32, ptr %offset_tbl.i.i242.i, i64 %hash.i.i.i246.i
  %offset.i.i248.i = load i32, ptr %offset_ptr.i.i247.i, align 4
  %401 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i, 0
  %402 = insertvalue { ptr, ptr, ptr, i32 } %401, ptr %399, 1
  %403 = insertvalue { ptr, ptr, ptr, i32 } %402, ptr %400, 2
  %404 = insertvalue { ptr, ptr, ptr, i32 } %403, i32 %offset.i.i248.i, 3
  %405 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %406 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %407 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %408 = sext i32 %offset.i.i248.i to i64
  %409 = getelementptr ptr, ptr %.fca.0.extract102.i, i64 %408
  %410 = getelementptr i8, ptr %409, i64 64
  %411 = load ptr, ptr %410, align 8
  %412 = call ptr %411({ ptr, ptr, ptr, i32 } %404, ptr nonnull %2)
  %413 = call i32 %412({ ptr, ptr, ptr, i32 } %404, { ptr, ptr, ptr, i32 } %404, ptr nonnull %2)
  %414 = icmp eq i32 %413, %163
  %415 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %416 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %417 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %418 = getelementptr i8, ptr %409, i64 48
  %419 = load ptr, ptr %418, align 8
  %420 = call ptr %419({ ptr, ptr, ptr, i32 } %404, ptr nonnull %2)
  %421 = call { ptr, i160 } %420({ ptr, ptr, ptr, i32 } %404, { ptr, ptr, ptr, i32 } %404, ptr nonnull %2)
  %422 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %423 = load ptr, ptr %78, align 8
  %424 = call i1 %423({ ptr, i160 } %421, { ptr, i160 } %159)
  %425 = and i1 %414, %424
  br i1 %425, label %426, label %.critedge158.i

426:                                              ; preds = %398
  %427 = load ptr, ptr %result.i, align 8
  %428 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %429 = load ptr, ptr %72, align 8
  %430 = load ptr, ptr %427, align 8
  %431 = getelementptr i8, ptr %430, i64 48
  %432 = load ptr, ptr %431, align 8
  %433 = call { i64, i64 } %432(ptr nonnull %427)
  %434 = extractvalue { i64, i64 } %433, 0
  %435 = extractvalue { i64, i64 } %433, 1
  %436 = urem i64 20, %435
  %437 = icmp eq i64 %436, 0
  %438 = sub i64 %435, %436
  %439 = select i1 %437, i64 0, i64 %438
  %440 = add i64 %434, 20
  %441 = add i64 %440, %439
  %442 = load ptr, ptr %429, align 8
  %443 = getelementptr i8, ptr %442, i64 48
  %444 = load ptr, ptr %443, align 8
  %445 = call { i64, i64 } %444(ptr nonnull %429)
  %446 = extractvalue { i64, i64 } %445, 0
  %447 = extractvalue { i64, i64 } %445, 1
  %448 = call i64 @llvm.umax.i64(i64 %435, i64 %447)
  %449 = call i64 @llvm.umax.i64(i64 %448, i64 8)
  %450 = urem i64 %441, %447
  %451 = icmp eq i64 %450, 0
  %452 = sub i64 %447, %450
  %453 = select i1 %451, i64 0, i64 %452
  %454 = add i64 %446, %441
  %455 = add i64 %454, %453
  %456 = urem i64 %455, %449
  %457 = icmp eq i64 %456, 0
  %458 = sub i64 %449, %456
  %459 = select i1 %457, i64 0, i64 %458
  %460 = add i64 %459, %455
  %result.i250.i = call noalias ptr @bump_malloc_inner(i64 noundef %460, ptr nonnull @current_ptr) #29
  store ptr %427, ptr %result.i250.i, align 8
  %461 = getelementptr i8, ptr %result.i250.i, i64 8
  store ptr %429, ptr %461, align 8
  %462 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i)
  store ptr @Entry, ptr %63, align 8
  store ptr %result.i250.i, ptr %116, align 8
  store i32 9, ptr %117, align 8
  %463 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %63)
  %464 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %465 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %466 = load ptr, ptr %427, align 8
  %467 = getelementptr i8, ptr %466, i64 48
  %468 = load ptr, ptr %467, align 8
  %469 = call { i64, i64 } %468(ptr nonnull %427)
  %470 = extractvalue { i64, i64 } %469, 1
  %471 = urem i64 20, %470
  %472 = icmp eq i64 %471, 0
  %reass.sub = sub i64 %470, %471
  %473 = add i64 %reass.sub, 20
  %474 = select i1 %472, i64 20, i64 %473
  %475 = getelementptr i8, ptr %result.i250.i, i64 %474
  %476 = load ptr, ptr %result.i250.i, align 8
  %477 = load ptr, ptr %476, align 8
  %478 = getelementptr i8, ptr %477, i64 64
  %479 = load ptr, ptr %478, align 8
  call void %479({ ptr, i160 } %159, ptr nonnull %476, ptr %475)
  %480 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %481 = load ptr, ptr %result.i250.i, align 8
  %482 = load ptr, ptr %481, align 8
  %483 = getelementptr i8, ptr %482, i64 48
  %484 = load ptr, ptr %483, align 8
  %485 = call { i64, i64 } %484(ptr nonnull %481)
  %486 = extractvalue { i64, i64 } %485, 0
  %487 = extractvalue { i64, i64 } %485, 1
  %488 = urem i64 20, %487
  %489 = icmp eq i64 %488, 0
  %490 = sub i64 %487, %488
  %491 = select i1 %489, i64 0, i64 %490
  %492 = add i64 %486, 20
  %493 = add i64 %492, %491
  %494 = load ptr, ptr %461, align 8
  %495 = load ptr, ptr %494, align 8
  %496 = getelementptr i8, ptr %495, i64 48
  %497 = load ptr, ptr %496, align 8
  %498 = call { i64, i64 } %497(ptr nonnull %494)
  %499 = extractvalue { i64, i64 } %498, 1
  %500 = urem i64 %493, %499
  %501 = icmp eq i64 %500, 0
  %502 = sub i64 %499, %500
  %503 = select i1 %501, i64 0, i64 %502
  %504 = getelementptr i8, ptr %result.i250.i, i64 %493
  %505 = getelementptr i8, ptr %504, i64 %503
  %506 = load ptr, ptr %461, align 8
  %507 = load ptr, ptr %506, align 8
  %508 = getelementptr i8, ptr %507, i64 64
  %509 = load ptr, ptr %508, align 8
  call void %509({ ptr, i160 } %160, ptr nonnull %506, ptr %505)
  %510 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %511 = getelementptr i8, ptr %result.i250.i, i64 16
  store i32 %163, ptr %511, align 4
  %512 = load ptr, ptr %118, align 8
  %513 = ptrtoint ptr %result.i250.i to i64
  %514 = ptrtoint ptr %512 to i64
  %.sroa.282.0.insert.ext.i = zext i64 %514 to i160
  %.sroa.282.0.insert.shift.i = shl nuw nsw i160 %.sroa.282.0.insert.ext.i, 64
  %.sroa.081.0.insert.ext.i = zext i64 %513 to i160
  %.sroa.282.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.shift.i, %.sroa.081.0.insert.ext.i
  %.sroa.081.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.insert.i, 3062541302288446171170371466885913903104
  %515 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i, 1
  %516 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %517 = load ptr, ptr %104, align 8
  %518 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %517, 0
  %519 = load ptr, ptr %105, align 8
  %520 = insertvalue { ptr, ptr, ptr, i32 } %518, ptr %519, 1
  %521 = load ptr, ptr %106, align 8
  %522 = insertvalue { ptr, ptr, ptr, i32 } %520, ptr %521, 2
  %523 = load i32, ptr %107, align 4
  %524 = insertvalue { ptr, ptr, ptr, i32 } %522, i32 %523, 3
  %hash_coef_ptr.i.i266.i = getelementptr i8, ptr %517, i64 8
  %tbl_size_ptr.i.i267.i = getelementptr i8, ptr %517, i64 16
  %offset_tbl_ptr.i.i268.i = getelementptr i8, ptr %517, i64 40
  %hash_coef.i.i269.i = load i64, ptr %hash_coef_ptr.i.i266.i, align 4
  %tbl_size.i.i270.i = load i64, ptr %tbl_size_ptr.i.i267.i, align 4
  %offset_tbl.i.i271.i = load ptr, ptr %offset_tbl_ptr.i.i268.i, align 8
  %product.i.i.i272.i = mul i64 %hash_coef.i.i269.i, -5261542750394134544
  %shifted.i.i.i273.i = lshr i64 %product.i.i.i272.i, 32
  %xored.i.i.i274.i = xor i64 %shifted.i.i.i273.i, %product.i.i.i272.i
  %hash.i.i.i275.i = and i64 %xored.i.i.i274.i, %tbl_size.i.i270.i
  %offset_ptr.i.i276.i = getelementptr i32, ptr %offset_tbl.i.i271.i, i64 %hash.i.i.i275.i
  %offset.i.i277.i = load i32, ptr %offset_ptr.i.i276.i, align 4
  %eq.i280.i = icmp eq i32 %523, %offset.i.i277.i
  call void @llvm.assume(i1 %eq.i280.i) #30
  %525 = load ptr, ptr %result.i, align 8
  %526 = load ptr, ptr %72, align 8
  %result.i281.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %527 = getelementptr i8, ptr %result.i281.i, i64 16
  store ptr %526, ptr %527, align 8
  %528 = getelementptr i8, ptr %result.i281.i, i64 8
  store ptr %525, ptr %528, align 8
  %529 = getelementptr i8, ptr %result.i281.i, i64 24
  store ptr null, ptr %529, align 8
  %530 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i)
  store ptr @Entry, ptr %result.i281.i, align 8
  store ptr @_parameterization_Ptri32, ptr %64, align 8
  store ptr %result.i281.i, ptr %119, align 8
  %531 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %64)
  %532 = call ptr @llvm.invariant.start.p0(i64 600, ptr %517)
  %533 = sext i32 %523 to i64
  %534 = getelementptr ptr, ptr %517, i64 %533
  %535 = getelementptr i8, ptr %534, i64 128
  %536 = load ptr, ptr %535, align 8
  store ptr @i32_typ, ptr %65, align 8
  store ptr @Entry, ptr %120, align 8
  %537 = call ptr %536({ ptr, ptr, ptr, i32 } %524, ptr nonnull %65)
  call void %537({ ptr, ptr, ptr, i32 } %524, { ptr, ptr, ptr, i32 } %524, ptr nonnull %64, i32 %378, { ptr, i160 } %515)
  br label %HashMap_insert_keyK_valueV.exit

.critedge158.i:                                   ; preds = %398, %.critedge.i
  %538 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %539 = load ptr, ptr %89, align 8
  %540 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %539, 0
  %541 = load ptr, ptr %90, align 8
  %542 = insertvalue { ptr, ptr, ptr, i32 } %540, ptr %541, 1
  %543 = load ptr, ptr %91, align 8
  %544 = insertvalue { ptr, ptr, ptr, i32 } %542, ptr %543, 2
  %545 = load i32, ptr %92, align 4
  %546 = insertvalue { ptr, ptr, ptr, i32 } %544, i32 %545, 3
  %hash_coef_ptr.i.i283.i = getelementptr i8, ptr %539, i64 8
  %tbl_size_ptr.i.i284.i = getelementptr i8, ptr %539, i64 16
  %offset_tbl_ptr.i.i285.i = getelementptr i8, ptr %539, i64 40
  %hash_coef.i.i286.i = load i64, ptr %hash_coef_ptr.i.i283.i, align 4
  %tbl_size.i.i287.i = load i64, ptr %tbl_size_ptr.i.i284.i, align 4
  %offset_tbl.i.i288.i = load ptr, ptr %offset_tbl_ptr.i.i285.i, align 8
  %product.i.i.i289.i = mul i64 %hash_coef.i.i286.i, -5261542750394134544
  %shifted.i.i.i290.i = lshr i64 %product.i.i.i289.i, 32
  %xored.i.i.i291.i = xor i64 %shifted.i.i.i290.i, %product.i.i.i289.i
  %hash.i.i.i292.i = and i64 %xored.i.i.i291.i, %tbl_size.i.i287.i
  %offset_ptr.i.i293.i = getelementptr i32, ptr %offset_tbl.i.i288.i, i64 %hash.i.i.i292.i
  %offset.i.i294.i = load i32, ptr %offset_ptr.i.i293.i, align 4
  %eq.i297.i = icmp eq i32 %545, %offset.i.i294.i
  call void @llvm.assume(i1 %eq.i297.i) #30
  %547 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %548 = call ptr @llvm.invariant.start.p0(i64 600, ptr %539)
  %549 = sext i32 %545 to i64
  %550 = getelementptr ptr, ptr %539, i64 %549
  %551 = getelementptr i8, ptr %550, i64 64
  %552 = load ptr, ptr %551, align 8
  %553 = call ptr %552({ ptr, ptr, ptr, i32 } %546, ptr nonnull %2)
  %554 = call i32 %553({ ptr, ptr, ptr, i32 } %546, { ptr, ptr, ptr, i32 } %546, ptr nonnull %2)
  %555 = load i32, ptr %108, align 4
  %.not.i = icmp slt i32 %555, %554
  br i1 %.not.i, label %._crit_edge.i, label %556

556:                                              ; preds = %.critedge158.i
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %53)
  %557 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %558 = load ptr, ptr %89, align 8
  %559 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %558, 0
  %560 = load ptr, ptr %90, align 8
  %561 = insertvalue { ptr, ptr, ptr, i32 } %559, ptr %560, 1
  %562 = load ptr, ptr %91, align 8
  %563 = insertvalue { ptr, ptr, ptr, i32 } %561, ptr %562, 2
  %564 = load i32, ptr %92, align 4
  %565 = insertvalue { ptr, ptr, ptr, i32 } %563, i32 %564, 3
  %hash_coef_ptr.i.i64.i = getelementptr i8, ptr %558, i64 8
  %tbl_size_ptr.i.i65.i = getelementptr i8, ptr %558, i64 16
  %offset_tbl_ptr.i.i66.i = getelementptr i8, ptr %558, i64 40
  %hash_coef.i.i67.i = load i64, ptr %hash_coef_ptr.i.i64.i, align 4
  %tbl_size.i.i68.i = load i64, ptr %tbl_size_ptr.i.i65.i, align 4
  %offset_tbl.i.i69.i = load ptr, ptr %offset_tbl_ptr.i.i66.i, align 8
  %product.i.i.i70.i = mul i64 %hash_coef.i.i67.i, -5261542750394134544
  %shifted.i.i.i71.i = lshr i64 %product.i.i.i70.i, 32
  %xored.i.i.i72.i = xor i64 %shifted.i.i.i71.i, %product.i.i.i70.i
  %hash.i.i.i73.i = and i64 %xored.i.i.i72.i, %tbl_size.i.i68.i
  %offset_ptr.i.i74.i = getelementptr i32, ptr %offset_tbl.i.i69.i, i64 %hash.i.i.i73.i
  %offset.i.i75.i = load i32, ptr %offset_ptr.i.i74.i, align 4
  %eq.i.i341 = icmp eq i32 %564, %offset.i.i75.i
  call void @llvm.assume(i1 %eq.i.i341) #30
  %566 = load ptr, ptr %104, align 8
  %567 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %566, 0
  %568 = load ptr, ptr %105, align 8
  %569 = insertvalue { ptr, ptr, ptr, i32 } %567, ptr %568, 1
  %570 = load ptr, ptr %106, align 8
  %571 = insertvalue { ptr, ptr, ptr, i32 } %569, ptr %570, 2
  %572 = load i32, ptr %107, align 4
  %573 = insertvalue { ptr, ptr, ptr, i32 } %571, i32 %572, 3
  %hash_coef_ptr.i.i92.i = getelementptr i8, ptr %566, i64 8
  %tbl_size_ptr.i.i93.i = getelementptr i8, ptr %566, i64 16
  %offset_tbl_ptr.i.i94.i = getelementptr i8, ptr %566, i64 40
  %hash_coef.i.i95.i = load i64, ptr %hash_coef_ptr.i.i92.i, align 4
  %tbl_size.i.i96.i = load i64, ptr %tbl_size_ptr.i.i93.i, align 4
  %offset_tbl.i.i97.i = load ptr, ptr %offset_tbl_ptr.i.i94.i, align 8
  %product.i.i.i98.i = mul i64 %hash_coef.i.i95.i, -5261542750394134544
  %shifted.i.i.i99.i = lshr i64 %product.i.i.i98.i, 32
  %xored.i.i.i100.i = xor i64 %shifted.i.i.i99.i, %product.i.i.i98.i
  %hash.i.i.i101.i = and i64 %xored.i.i.i100.i, %tbl_size.i.i96.i
  %offset_ptr.i.i102.i = getelementptr i32, ptr %offset_tbl.i.i97.i, i64 %hash.i.i.i101.i
  %offset.i.i103.i = load i32, ptr %offset_ptr.i.i102.i, align 4
  %eq.i106.i = icmp eq i32 %572, %offset.i.i103.i
  call void @llvm.assume(i1 %eq.i106.i) #30
  %574 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %575 = call ptr @llvm.invariant.start.p0(i64 600, ptr %558)
  %576 = sext i32 %564 to i64
  %577 = getelementptr ptr, ptr %558, i64 %576
  %578 = getelementptr i8, ptr %577, i64 64
  %579 = load ptr, ptr %578, align 8
  %580 = call ptr %579({ ptr, ptr, ptr, i32 } %565, ptr nonnull %2)
  %581 = call i32 %580({ ptr, ptr, ptr, i32 } %565, { ptr, ptr, ptr, i32 } %565, ptr nonnull %2)
  %582 = shl i32 %581, 1
  %583 = load i32, ptr %108, align 4
  %584 = load ptr, ptr %result.i, align 8
  %585 = load ptr, ptr %72, align 8
  %586 = sext i32 %583 to i64
  %587 = shl nsw i64 %586, 5
  %result.i.i.i347 = call noalias ptr @bump_malloc_inner(i64 noundef %587, ptr nonnull @current_ptr) #29
  %588 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %589 = icmp sgt i32 %581, 0
  br i1 %589, label %.lr.ph434.i, label %._crit_edge395.i

.lr.ph434.i:                                      ; preds = %556
  %invariant.gep.i = getelementptr i8, ptr %558, i64 120
  %590 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i = getelementptr ptr, ptr %invariant.gep.i, i64 %576
  br label %591

591:                                              ; preds = %613, %.lr.ph434.i
  %.reg2mem105.0432.i = phi i32 [ 0, %.lr.ph434.i ], [ %.reg2mem101.0.i, %613 ]
  %.reg2mem103.0431.i = phi i32 [ 0, %.lr.ph434.i ], [ %614, %613 ]
  store ptr @_parameterization_Ptri32, ptr %48, align 8
  %592 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %48)
  %593 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %558)
  %594 = load ptr, ptr %gep.i, align 8
  store ptr @i32_typ, ptr %49, align 8
  %595 = call ptr %594({ ptr, ptr, ptr, i32 } %565, ptr nonnull %49)
  %596 = call { ptr, i160 } %595({ ptr, ptr, ptr, i32 } %565, { ptr, ptr, ptr, i32 } %565, ptr nonnull %48, i32 %.reg2mem103.0431.i)
  %.fca.0.extract52.i = extractvalue { ptr, i160 } %596, 0
  %597 = icmp ne ptr %.fca.0.extract52.i, @nil_typ
  %598 = icmp ne ptr %.fca.0.extract52.i, null
  %.not60.i = and i1 %597, %598
  br i1 %.not60.i, label %599, label %613

599:                                              ; preds = %591
  %hash_coef_ptr.i.i137.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 8
  %tbl_size_ptr.i.i138.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 16
  %offset_tbl_ptr.i.i139.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 40
  %hash_coef.i.i140.i = load i64, ptr %hash_coef_ptr.i.i137.i, align 4
  %tbl_size.i.i141.i = load i64, ptr %tbl_size_ptr.i.i138.i, align 4
  %offset_tbl.i.i142.i = load ptr, ptr %offset_tbl_ptr.i.i139.i, align 8
  %product.i.i.i143.i = mul i64 %hash_coef.i.i140.i, 4015701072841558310
  %shifted.i.i.i144.i = lshr i64 %product.i.i.i143.i, 32
  %xored.i.i.i145.i = xor i64 %shifted.i.i.i144.i, %product.i.i.i143.i
  %hash.i.i.i146.i = and i64 %xored.i.i.i145.i, %tbl_size.i.i141.i
  %offset_ptr.i.i147.i = getelementptr i32, ptr %offset_tbl.i.i142.i, i64 %hash.i.i.i146.i
  %offset.i.i148.i = load i32, ptr %offset_ptr.i.i147.i, align 4
  %600 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %601 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %602 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %603 = icmp slt i32 %.reg2mem105.0432.i, %583
  br i1 %603, label %604, label %._crit_edge.i349

604:                                              ; preds = %599
  %.fca.1.extract54.i = extractvalue { ptr, i160 } %596, 1
  %.sroa.351.0.insert.ext.i = zext i32 %offset.i.i148.i to i160
  %.sroa.351.0.insert.shift.i = shl nuw i160 %.sroa.351.0.insert.ext.i, 128
  %605 = and i160 %.fca.1.extract54.i, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i = or disjoint i160 %.sroa.351.0.insert.shift.i, %605
  %606 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %607 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %608 = sext i32 %.reg2mem105.0432.i to i64
  %609 = shl nsw i64 %608, 5
  %610 = getelementptr i8, ptr %result.i.i.i347, i64 %609
  store ptr %.fca.0.extract52.i, ptr %610, align 8
  %611 = getelementptr i8, ptr %610, i64 8
  store i160 %.sroa.049.0.insert.insert.i, ptr %611, align 4
  br label %._crit_edge.i349

._crit_edge.i349:                                 ; preds = %604, %599
  %612 = add i32 %.reg2mem105.0432.i, 1
  br label %613

613:                                              ; preds = %._crit_edge.i349, %591
  %.reg2mem101.0.i = phi i32 [ %612, %._crit_edge.i349 ], [ %.reg2mem105.0432.i, %591 ]
  %614 = add nuw nsw i32 %.reg2mem103.0431.i, 1
  %615 = icmp slt i32 %614, %581
  br i1 %615, label %591, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %613
  %invariant.gep396.i = getelementptr i8, ptr %566, i64 120
  %616 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %617 = sext i32 %572 to i64
  %gep397.i = getelementptr ptr, ptr %invariant.gep396.i, i64 %617
  br label %618

618:                                              ; preds = %640, %.lr.ph.i
  %.reg2mem91.0394.i = phi i32 [ %.reg2mem101.0.i, %.lr.ph.i ], [ %.reg2mem87.0.i, %640 ]
  %.reg2mem89.0393.i = phi i32 [ 0, %.lr.ph.i ], [ %641, %640 ]
  store ptr @_parameterization_Ptri32, ptr %50, align 8
  %619 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %50)
  %620 = call ptr @llvm.invariant.start.p0(i64 600, ptr %566)
  %621 = load ptr, ptr %gep397.i, align 8
  store ptr @i32_typ, ptr %51, align 8
  %622 = call ptr %621({ ptr, ptr, ptr, i32 } %573, ptr nonnull %51)
  %623 = call { ptr, i160 } %622({ ptr, ptr, ptr, i32 } %573, { ptr, ptr, ptr, i32 } %573, ptr nonnull %50, i32 %.reg2mem89.0393.i)
  %.fca.0.extract42.i = extractvalue { ptr, i160 } %623, 0
  %624 = icmp ne ptr %.fca.0.extract42.i, @nil_typ
  %625 = icmp ne ptr %.fca.0.extract42.i, null
  %.not62.i = and i1 %624, %625
  br i1 %.not62.i, label %626, label %640

626:                                              ; preds = %618
  %hash_coef_ptr.i.i152.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 8
  %tbl_size_ptr.i.i153.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 16
  %offset_tbl_ptr.i.i154.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 40
  %hash_coef.i.i155.i = load i64, ptr %hash_coef_ptr.i.i152.i, align 4
  %tbl_size.i.i156.i = load i64, ptr %tbl_size_ptr.i.i153.i, align 4
  %offset_tbl.i.i157.i = load ptr, ptr %offset_tbl_ptr.i.i154.i, align 8
  %product.i.i.i158.i = mul i64 %hash_coef.i.i155.i, 4015701072841558310
  %shifted.i.i.i159.i = lshr i64 %product.i.i.i158.i, 32
  %xored.i.i.i160.i = xor i64 %shifted.i.i.i159.i, %product.i.i.i158.i
  %hash.i.i.i161.i = and i64 %xored.i.i.i160.i, %tbl_size.i.i156.i
  %offset_ptr.i.i162.i = getelementptr i32, ptr %offset_tbl.i.i157.i, i64 %hash.i.i.i161.i
  %offset.i.i163.i = load i32, ptr %offset_ptr.i.i162.i, align 4
  %627 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %628 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %629 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %630 = icmp slt i32 %.reg2mem91.0394.i, %583
  br i1 %630, label %631, label %._crit_edge1.i348

631:                                              ; preds = %626
  %.fca.1.extract44.i = extractvalue { ptr, i160 } %623, 1
  %.sroa.3.0.insert.ext.i = zext i32 %offset.i.i163.i to i160
  %.sroa.3.0.insert.shift.i = shl nuw i160 %.sroa.3.0.insert.ext.i, 128
  %632 = and i160 %.fca.1.extract44.i, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i = or disjoint i160 %.sroa.3.0.insert.shift.i, %632
  %633 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %634 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %635 = sext i32 %.reg2mem91.0394.i to i64
  %636 = shl nsw i64 %635, 5
  %637 = getelementptr i8, ptr %result.i.i.i347, i64 %636
  store ptr %.fca.0.extract42.i, ptr %637, align 8
  %638 = getelementptr i8, ptr %637, i64 8
  store i160 %.sroa.040.0.insert.insert.i, ptr %638, align 4
  br label %._crit_edge1.i348

._crit_edge1.i348:                                ; preds = %631, %626
  %639 = add i32 %.reg2mem91.0394.i, 1
  br label %640

640:                                              ; preds = %._crit_edge1.i348, %618
  %.reg2mem87.0.i = phi i32 [ %639, %._crit_edge1.i348 ], [ %.reg2mem91.0394.i, %618 ]
  %641 = add nuw nsw i32 %.reg2mem89.0393.i, 1
  %642 = icmp slt i32 %641, %581
  br i1 %642, label %618, label %._crit_edge395.i.loopexit

._crit_edge395.i.loopexit:                        ; preds = %640
  %.pre = load ptr, ptr %result.i, align 8
  %.pre1073 = load ptr, ptr %72, align 8
  br label %._crit_edge395.i

._crit_edge395.i:                                 ; preds = %._crit_edge395.i.loopexit, %556
  %643 = phi ptr [ %585, %556 ], [ %.pre1073, %._crit_edge395.i.loopexit ]
  %644 = phi ptr [ %584, %556 ], [ %.pre, %._crit_edge395.i.loopexit ]
  %.reg2mem91.0.lcssa.i = phi i32 [ 0, %556 ], [ %.reg2mem87.0.i, %._crit_edge395.i.loopexit ]
  %645 = call i32 @llvm.smax.i32(i32 %582, i32 16)
  %result.i166.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %646 = getelementptr i8, ptr %result.i166.i, i64 16
  store ptr @_parameterization_Nil, ptr %646, align 8
  %result.i167.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %647 = getelementptr i8, ptr %result.i167.i, i64 16
  store ptr %643, ptr %647, align 8
  %648 = getelementptr i8, ptr %result.i167.i, i64 8
  store ptr %644, ptr %648, align 8
  %649 = getelementptr i8, ptr %result.i167.i, i64 24
  store ptr null, ptr %649, align 8
  %650 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i)
  store ptr @Entry, ptr %result.i167.i, align 8
  %651 = getelementptr i8, ptr %result.i166.i, i64 8
  store ptr %result.i167.i, ptr %651, align 8
  %652 = getelementptr i8, ptr %result.i166.i, i64 24
  store ptr null, ptr %652, align 8
  %653 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i)
  store ptr @union_typ, ptr %result.i166.i, align 8
  %result.i168.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i, ptr %result.i168.i, align 8
  %654 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i)
  store ptr @Array, ptr %52, align 8
  store ptr %result.i168.i, ptr %126, align 8
  store i32 9, ptr %127, align 8
  %655 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %52)
  %656 = getelementptr i8, ptr %result.i168.i, i64 16
  store i32 %645, ptr %656, align 4
  %657 = getelementptr i8, ptr %result.i168.i, i64 20
  store i32 %645, ptr %657, align 4
  %658 = zext nneg i32 %645 to i64
  %659 = shl nuw nsw i64 %658, 5
  %result.i.i416.i = call noalias ptr @bump_malloc_inner(i64 noundef %659, ptr nonnull @current_ptr) #29
  %660 = getelementptr i8, ptr %result.i168.i, i64 8
  store ptr %result.i.i416.i, ptr %660, align 8
  %661 = load ptr, ptr %128, align 8
  store ptr @Array, ptr %89, align 8
  store ptr %result.i168.i, ptr %90, align 8
  store ptr %661, ptr %91, align 8
  store i32 9, ptr %92, align 4
  %662 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %663 = getelementptr i8, ptr %result.i183.i, i64 16
  store ptr @_parameterization_Nil, ptr %663, align 8
  %result.i184.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %664 = getelementptr i8, ptr %result.i184.i, i64 16
  store ptr %643, ptr %664, align 8
  %665 = getelementptr i8, ptr %result.i184.i, i64 8
  store ptr %644, ptr %665, align 8
  %666 = getelementptr i8, ptr %result.i184.i, i64 24
  store ptr null, ptr %666, align 8
  %667 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i)
  store ptr @Entry, ptr %result.i184.i, align 8
  %668 = getelementptr i8, ptr %result.i183.i, i64 8
  store ptr %result.i184.i, ptr %668, align 8
  %669 = getelementptr i8, ptr %result.i183.i, i64 24
  store ptr null, ptr %669, align 8
  %670 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i)
  store ptr @union_typ, ptr %result.i183.i, align 8
  %result.i185.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i, ptr %result.i185.i, align 8
  %671 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i)
  store ptr @Array, ptr %53, align 8
  store ptr %result.i185.i, ptr %129, align 8
  store i32 9, ptr %130, align 8
  %672 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %53)
  %673 = getelementptr i8, ptr %result.i185.i, i64 16
  store i32 %645, ptr %673, align 4
  %674 = getelementptr i8, ptr %result.i185.i, i64 20
  store i32 %645, ptr %674, align 4
  %result.i.i430.i = call noalias ptr @bump_malloc_inner(i64 noundef %659, ptr nonnull @current_ptr) #29
  %675 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %676 = getelementptr i8, ptr %result.i185.i, i64 8
  store ptr %result.i.i430.i, ptr %676, align 8
  %677 = load ptr, ptr %131, align 8
  store ptr @Array, ptr %104, align 8
  store ptr %result.i185.i, ptr %105, align 8
  store ptr %677, ptr %106, align 8
  store i32 9, ptr %107, align 4
  store i32 0, ptr %108, align 4
  %678 = icmp sgt i32 %.reg2mem91.0.lcssa.i, 0
  br i1 %678, label %.lr.ph400.i, label %HashMap_resize_.exit

.lr.ph400.i:                                      ; preds = %._crit_edge395.i
  %679 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %680 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %681 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %._crit_edge2.i, %.lr.ph400.i
  %.reg2mem77.0398.i = phi i32 [ 0, %.lr.ph400.i ], [ %695, %._crit_edge2.i ]
  %682 = zext nneg i32 %.reg2mem77.0398.i to i64
  %683 = shl nuw nsw i64 %682, 5
  %684 = getelementptr i8, ptr %result.i.i.i347, i64 %683
  %685 = load ptr, ptr %684, align 8
  %686 = getelementptr i8, ptr %684, i64 8
  %687 = load i160, ptr %686, align 4
  %.sroa.3362.8.extract.trunc.i = trunc i160 %687 to i64
  %688 = inttoptr i64 %.sroa.3362.8.extract.trunc.i to ptr
  %.sroa.5363.8.extract.shift.i = lshr i160 %687, 64
  %.sroa.5363.8.extract.trunc.i = trunc i160 %.sroa.5363.8.extract.shift.i to i64
  %689 = inttoptr i64 %.sroa.5363.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i201.i = getelementptr i8, ptr %685, i64 8
  %tbl_size_ptr.i.i202.i = getelementptr i8, ptr %685, i64 16
  %offset_tbl_ptr.i.i203.i = getelementptr i8, ptr %685, i64 40
  %hash_coef.i.i232.i = load i64, ptr %hash_coef_ptr.i.i201.i, align 4
  %tbl_size.i.i233.i = load i64, ptr %tbl_size_ptr.i.i202.i, align 4
  %offset_tbl.i.i234.i = load ptr, ptr %offset_tbl_ptr.i.i203.i, align 8
  %product.i.i.i235.i = mul i64 %hash_coef.i.i232.i, 4015701072841558310
  %shifted.i.i.i236.i = lshr i64 %product.i.i.i235.i, 32
  %xored.i.i.i237.i = xor i64 %shifted.i.i.i236.i, %product.i.i.i235.i
  %hash.i.i.i238.i = and i64 %xored.i.i.i237.i, %tbl_size.i.i233.i
  %offset_ptr.i.i239.i = getelementptr i32, ptr %offset_tbl.i.i234.i, i64 %hash.i.i.i238.i
  %offset.i.i240.i = load i32, ptr %offset_ptr.i.i239.i, align 4
  %690 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %685, 0
  %691 = insertvalue { ptr, ptr, ptr, i32 } %690, ptr %688, 1
  %692 = insertvalue { ptr, ptr, ptr, i32 } %691, ptr %689, 2
  %693 = insertvalue { ptr, ptr, ptr, i32 } %692, i32 %offset.i.i240.i, 3
  %694 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %693)
  %695 = add nuw nsw i32 %.reg2mem77.0398.i, 1
  %696 = icmp slt i32 %695, %.reg2mem91.0.lcssa.i
  br i1 %696, label %._crit_edge2.i, label %HashMap_resize_.exit

HashMap_resize_.exit:                             ; preds = %._crit_edge2.i, %._crit_edge395.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %53)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %HashMap_resize_.exit, %.critedge158.i
  %697 = load ptr, ptr %result.i, align 8
  %698 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %699 = load ptr, ptr %72, align 8
  %700 = load ptr, ptr %697, align 8
  %701 = getelementptr i8, ptr %700, i64 48
  %702 = load ptr, ptr %701, align 8
  %703 = call { i64, i64 } %702(ptr nonnull %697)
  %704 = extractvalue { i64, i64 } %703, 0
  %705 = extractvalue { i64, i64 } %703, 1
  %706 = urem i64 20, %705
  %707 = icmp eq i64 %706, 0
  %708 = sub i64 %705, %706
  %709 = select i1 %707, i64 0, i64 %708
  %710 = add i64 %704, 20
  %711 = add i64 %710, %709
  %712 = load ptr, ptr %699, align 8
  %713 = getelementptr i8, ptr %712, i64 48
  %714 = load ptr, ptr %713, align 8
  %715 = call { i64, i64 } %714(ptr nonnull %699)
  %716 = extractvalue { i64, i64 } %715, 0
  %717 = extractvalue { i64, i64 } %715, 1
  %718 = call i64 @llvm.umax.i64(i64 %705, i64 %717)
  %719 = call i64 @llvm.umax.i64(i64 %718, i64 8)
  %720 = urem i64 %711, %717
  %721 = icmp eq i64 %720, 0
  %722 = sub i64 %717, %720
  %723 = select i1 %721, i64 0, i64 %722
  %724 = add i64 %716, %711
  %725 = add i64 %724, %723
  %726 = urem i64 %725, %719
  %727 = icmp eq i64 %726, 0
  %728 = sub i64 %719, %726
  %729 = select i1 %727, i64 0, i64 %728
  %730 = add i64 %729, %725
  %result.i298.i = call noalias ptr @bump_malloc_inner(i64 noundef %730, ptr nonnull @current_ptr) #29
  store ptr %697, ptr %result.i298.i, align 8
  %731 = getelementptr i8, ptr %result.i298.i, i64 8
  store ptr %699, ptr %731, align 8
  %732 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i)
  store ptr @Entry, ptr %66, align 8
  store ptr %result.i298.i, ptr %113, align 8
  store i32 9, ptr %114, align 8
  %733 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %66)
  %734 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %735 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %736 = load ptr, ptr %697, align 8
  %737 = getelementptr i8, ptr %736, i64 48
  %738 = load ptr, ptr %737, align 8
  %739 = call { i64, i64 } %738(ptr nonnull %697)
  %740 = extractvalue { i64, i64 } %739, 1
  %741 = urem i64 20, %740
  %742 = icmp eq i64 %741, 0
  %reass.sub1415 = sub i64 %740, %741
  %743 = add i64 %reass.sub1415, 20
  %744 = select i1 %742, i64 20, i64 %743
  %745 = getelementptr i8, ptr %result.i298.i, i64 %744
  %746 = load ptr, ptr %result.i298.i, align 8
  %747 = load ptr, ptr %746, align 8
  %748 = getelementptr i8, ptr %747, i64 64
  %749 = load ptr, ptr %748, align 8
  call void %749({ ptr, i160 } %159, ptr nonnull %746, ptr %745)
  %750 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %751 = load ptr, ptr %result.i298.i, align 8
  %752 = load ptr, ptr %751, align 8
  %753 = getelementptr i8, ptr %752, i64 48
  %754 = load ptr, ptr %753, align 8
  %755 = call { i64, i64 } %754(ptr nonnull %751)
  %756 = extractvalue { i64, i64 } %755, 0
  %757 = extractvalue { i64, i64 } %755, 1
  %758 = urem i64 20, %757
  %759 = icmp eq i64 %758, 0
  %760 = sub i64 %757, %758
  %761 = select i1 %759, i64 0, i64 %760
  %762 = add i64 %756, 20
  %763 = add i64 %762, %761
  %764 = load ptr, ptr %731, align 8
  %765 = load ptr, ptr %764, align 8
  %766 = getelementptr i8, ptr %765, i64 48
  %767 = load ptr, ptr %766, align 8
  %768 = call { i64, i64 } %767(ptr nonnull %764)
  %769 = extractvalue { i64, i64 } %768, 1
  %770 = urem i64 %763, %769
  %771 = icmp eq i64 %770, 0
  %772 = sub i64 %769, %770
  %773 = select i1 %771, i64 0, i64 %772
  %774 = getelementptr i8, ptr %result.i298.i, i64 %763
  %775 = getelementptr i8, ptr %774, i64 %773
  %776 = load ptr, ptr %731, align 8
  %777 = load ptr, ptr %776, align 8
  %778 = getelementptr i8, ptr %777, i64 64
  %779 = load ptr, ptr %778, align 8
  call void %779({ ptr, i160 } %160, ptr nonnull %776, ptr %775)
  %780 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %781 = getelementptr i8, ptr %result.i298.i, i64 16
  store i32 %163, ptr %781, align 4
  %782 = load ptr, ptr %115, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i350)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %47)
  store ptr @Entry, ptr %47, align 8
  store ptr %result.i298.i, ptr %135, align 8
  store ptr %782, ptr %136, align 8
  store i32 9, ptr %137, align 8
  %783 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %47)
  %784 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %785 = load i32, ptr %110, align 4
  %786 = icmp sgt i32 %785, 0
  br i1 %786, label %.lr.ph.i380, label %._crit_edge1.i

.lr.ph.i380:                                      ; preds = %._crit_edge.i
  %787 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %788 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %789

789:                                              ; preds = %.cont.cont.i, %.lr.ph.i380
  %offset.i.i260.i1021 = phi i32 [ 9, %.lr.ph.i380 ], [ %offset.i.i260.i, %.cont.cont.i ]
  %.sroa.speculated346.i1019 = phi ptr [ %782, %.lr.ph.i380 ], [ %.sroa.speculated346.i, %.cont.cont.i ]
  %.sroa.speculated352.i1017 = phi ptr [ %result.i298.i, %.lr.ph.i380 ], [ %.sroa.speculated352.i, %.cont.cont.i ]
  %.reg2mem195.0678.i = phi i32 [ 1, %.lr.ph.i380 ], [ %945, %.cont.cont.i ]
  %.reg2mem193.0677.i = phi i32 [ 0, %.lr.ph.i380 ], [ %946, %.cont.cont.i ]
  %790 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i1017, 1
  %791 = insertvalue { ptr, ptr, ptr, i32 } %790, ptr %.sroa.speculated346.i1019, 2
  %792 = insertvalue { ptr, ptr, ptr, i32 } %791, i32 %offset.i.i260.i1021, 3
  %793 = sext i32 %offset.i.i260.i1021 to i64
  %gep = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %793
  %794 = load ptr, ptr %gep, align 8
  %795 = call ptr %794({ ptr, ptr, ptr, i32 } %792, ptr nonnull %2)
  %796 = call i32 %795({ ptr, ptr, ptr, i32 } %792, { ptr, ptr, ptr, i32 } %792, ptr nonnull %2)
  %797 = icmp eq i32 %.reg2mem195.0678.i, 1
  %798 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %797, label %799, label %863

799:                                              ; preds = %789
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %800 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %801 = load ptr, ptr %89, align 8
  %802 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %801, 0
  %803 = load ptr, ptr %90, align 8
  %804 = insertvalue { ptr, ptr, ptr, i32 } %802, ptr %803, 1
  %805 = load ptr, ptr %91, align 8
  %806 = insertvalue { ptr, ptr, ptr, i32 } %804, ptr %805, 2
  %807 = load i32, ptr %92, align 4
  %808 = insertvalue { ptr, ptr, ptr, i32 } %806, i32 %807, 3
  %hash_coef_ptr.i.i10.i1151 = getelementptr i8, ptr %801, i64 8
  %tbl_size_ptr.i.i11.i1152 = getelementptr i8, ptr %801, i64 16
  %offset_tbl_ptr.i.i12.i1153 = getelementptr i8, ptr %801, i64 40
  %hash_coef.i.i13.i1154 = load i64, ptr %hash_coef_ptr.i.i10.i1151, align 4
  %tbl_size.i.i14.i1155 = load i64, ptr %tbl_size_ptr.i.i11.i1152, align 4
  %offset_tbl.i.i15.i1156 = load ptr, ptr %offset_tbl_ptr.i.i12.i1153, align 8
  %product.i.i.i16.i1157 = mul i64 %hash_coef.i.i13.i1154, -5261542750394134544
  %shifted.i.i.i17.i1158 = lshr i64 %product.i.i.i16.i1157, 32
  %xored.i.i.i18.i1159 = xor i64 %shifted.i.i.i17.i1158, %product.i.i.i16.i1157
  %hash.i.i.i19.i1160 = and i64 %xored.i.i.i18.i1159, %tbl_size.i.i14.i1155
  %offset_ptr.i.i20.i1161 = getelementptr i32, ptr %offset_tbl.i.i15.i1156, i64 %hash.i.i.i19.i1160
  %offset.i.i21.i1162 = load i32, ptr %offset_ptr.i.i20.i1161, align 4
  %eq.i.i1163 = icmp eq i32 %807, %offset.i.i21.i1162
  call void @llvm.assume(i1 %eq.i.i1163) #30
  %809 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %810 = call ptr @llvm.invariant.start.p0(i64 600, ptr %801)
  %811 = sext i32 %807 to i64
  %812 = getelementptr ptr, ptr %801, i64 %811
  %813 = getelementptr i8, ptr %812, i64 64
  %814 = load ptr, ptr %813, align 8
  %815 = call ptr %814({ ptr, ptr, ptr, i32 } %808, ptr nonnull %2)
  %816 = call i32 %815({ ptr, ptr, ptr, i32 } %808, { ptr, ptr, ptr, i32 } %808, ptr nonnull %2)
  %817 = add i32 %816, -1
  %818 = and i32 %817, %796
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %819 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %820 = load ptr, ptr %89, align 8
  %821 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %820, 0
  %822 = load ptr, ptr %90, align 8
  %823 = insertvalue { ptr, ptr, ptr, i32 } %821, ptr %822, 1
  %824 = load ptr, ptr %91, align 8
  %825 = insertvalue { ptr, ptr, ptr, i32 } %823, ptr %824, 2
  %826 = load i32, ptr %92, align 4
  %827 = insertvalue { ptr, ptr, ptr, i32 } %825, i32 %826, 3
  %hash_coef_ptr.i.i172.i = getelementptr i8, ptr %820, i64 8
  %tbl_size_ptr.i.i173.i = getelementptr i8, ptr %820, i64 16
  %offset_tbl_ptr.i.i174.i = getelementptr i8, ptr %820, i64 40
  %hash_coef.i.i175.i = load i64, ptr %hash_coef_ptr.i.i172.i, align 4
  %tbl_size.i.i176.i = load i64, ptr %tbl_size_ptr.i.i173.i, align 4
  %offset_tbl.i.i177.i = load ptr, ptr %offset_tbl_ptr.i.i174.i, align 8
  %product.i.i.i178.i = mul i64 %hash_coef.i.i175.i, -5261542750394134544
  %shifted.i.i.i179.i = lshr i64 %product.i.i.i178.i, 32
  %xored.i.i.i180.i = xor i64 %shifted.i.i.i179.i, %product.i.i.i178.i
  %hash.i.i.i181.i = and i64 %xored.i.i.i180.i, %tbl_size.i.i176.i
  %offset_ptr.i.i182.i = getelementptr i32, ptr %offset_tbl.i.i177.i, i64 %hash.i.i.i181.i
  %offset.i.i183.i = load i32, ptr %offset_ptr.i.i182.i, align 4
  %eq.i.i383 = icmp eq i32 %826, %offset.i.i183.i
  call void @llvm.assume(i1 %eq.i.i383) #30
  store ptr @_parameterization_Ptri32, ptr %31, align 8
  %828 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %31)
  %829 = call ptr @llvm.invariant.start.p0(i64 600, ptr %820)
  %830 = sext i32 %826 to i64
  %831 = getelementptr ptr, ptr %820, i64 %830
  %832 = getelementptr i8, ptr %831, i64 120
  %833 = load ptr, ptr %832, align 8
  store ptr @i32_typ, ptr %32, align 8
  %834 = call ptr %833({ ptr, ptr, ptr, i32 } %827, ptr nonnull %32)
  %835 = call { ptr, i160 } %834({ ptr, ptr, ptr, i32 } %827, { ptr, ptr, ptr, i32 } %827, ptr nonnull %31, i32 %818)
  %.fca.0.extract112.i = extractvalue { ptr, i160 } %835, 0
  %836 = ptrtoint ptr %.sroa.speculated352.i1017 to i64
  %837 = ptrtoint ptr %.sroa.speculated346.i1019 to i64
  %.sroa.3111.0.insert.ext.i = zext i32 %offset.i.i260.i1021 to i160
  %.sroa.3111.0.insert.shift.i = shl nuw i160 %.sroa.3111.0.insert.ext.i, 128
  %.sroa.2110.0.insert.ext.i = zext i64 %837 to i160
  %.sroa.2110.0.insert.shift.i = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i, 64
  %.sroa.2110.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.shift.i, %.sroa.3111.0.insert.shift.i
  %.sroa.0109.0.insert.ext.i = zext i64 %836 to i160
  %.sroa.0109.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.insert.i, %.sroa.0109.0.insert.ext.i
  %838 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i, 1
  %839 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %840 = load ptr, ptr %89, align 8
  %841 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %840, 0
  %842 = load ptr, ptr %90, align 8
  %843 = insertvalue { ptr, ptr, ptr, i32 } %841, ptr %842, 1
  %844 = load ptr, ptr %91, align 8
  %845 = insertvalue { ptr, ptr, ptr, i32 } %843, ptr %844, 2
  %846 = load i32, ptr %92, align 4
  %847 = insertvalue { ptr, ptr, ptr, i32 } %845, i32 %846, 3
  %hash_coef_ptr.i.i186.i = getelementptr i8, ptr %840, i64 8
  %tbl_size_ptr.i.i187.i = getelementptr i8, ptr %840, i64 16
  %offset_tbl_ptr.i.i188.i = getelementptr i8, ptr %840, i64 40
  %hash_coef.i.i189.i = load i64, ptr %hash_coef_ptr.i.i186.i, align 4
  %tbl_size.i.i190.i = load i64, ptr %tbl_size_ptr.i.i187.i, align 4
  %offset_tbl.i.i191.i = load ptr, ptr %offset_tbl_ptr.i.i188.i, align 8
  %product.i.i.i192.i = mul i64 %hash_coef.i.i189.i, -5261542750394134544
  %shifted.i.i.i193.i = lshr i64 %product.i.i.i192.i, 32
  %xored.i.i.i194.i = xor i64 %shifted.i.i.i193.i, %product.i.i.i192.i
  %hash.i.i.i195.i = and i64 %xored.i.i.i194.i, %tbl_size.i.i190.i
  %offset_ptr.i.i196.i = getelementptr i32, ptr %offset_tbl.i.i191.i, i64 %hash.i.i.i195.i
  %offset.i.i197.i = load i32, ptr %offset_ptr.i.i196.i, align 4
  %eq.i200.i = icmp eq i32 %846, %offset.i.i197.i
  call void @llvm.assume(i1 %eq.i200.i) #30
  %848 = load ptr, ptr %result.i, align 8
  %849 = load ptr, ptr %72, align 8
  %result.i.i384 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %850 = getelementptr i8, ptr %result.i.i384, i64 16
  store ptr %849, ptr %850, align 8
  %851 = getelementptr i8, ptr %result.i.i384, i64 8
  store ptr %848, ptr %851, align 8
  %852 = getelementptr i8, ptr %result.i.i384, i64 24
  store ptr null, ptr %852, align 8
  %853 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i384)
  store ptr @Entry, ptr %result.i.i384, align 8
  store ptr @_parameterization_Ptri32, ptr %33, align 8
  store ptr %result.i.i384, ptr %140, align 8
  %854 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %33)
  %855 = call ptr @llvm.invariant.start.p0(i64 600, ptr %840)
  %856 = sext i32 %846 to i64
  %857 = getelementptr ptr, ptr %840, i64 %856
  %858 = getelementptr i8, ptr %857, i64 128
  %859 = load ptr, ptr %858, align 8
  store ptr @i32_typ, ptr %34, align 8
  store ptr @Entry, ptr %141, align 8
  %860 = call ptr %859({ ptr, ptr, ptr, i32 } %847, ptr nonnull %34)
  call void %860({ ptr, ptr, ptr, i32 } %847, { ptr, ptr, ptr, i32 } %847, ptr nonnull %33, i32 %818, { ptr, i160 } %838)
  %861 = icmp ne ptr %.fca.0.extract112.i, @nil_typ
  %862 = icmp ne ptr %.fca.0.extract112.i, null
  %.not140.i = and i1 %861, %862
  br i1 %.not140.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

863:                                              ; preds = %789
  %864 = add i32 %796, 2127912214
  %865 = shl i32 %796, 12
  %866 = add i32 %864, %865
  %867 = ashr i32 %866, 19
  %868 = xor i32 %866, %867
  %869 = xor i32 %868, -949894596
  %870 = add i32 %869, 374761393
  %871 = shl i32 %869, 5
  %872 = add i32 %870, %871
  %873 = add i32 %872, -744332180
  %874 = shl i32 %872, 9
  %875 = xor i32 %873, %874
  %876 = add i32 %875, -42973499
  %877 = shl i32 %875, 3
  %878 = add i32 %876, %877
  %879 = ashr i32 %878, 16
  %880 = xor i32 %878, %879
  %881 = xor i32 %880, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %882 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %883 = load ptr, ptr %104, align 8
  %884 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %883, 0
  %885 = load ptr, ptr %105, align 8
  %886 = insertvalue { ptr, ptr, ptr, i32 } %884, ptr %885, 1
  %887 = load ptr, ptr %106, align 8
  %888 = insertvalue { ptr, ptr, ptr, i32 } %886, ptr %887, 2
  %889 = load i32, ptr %107, align 4
  %890 = insertvalue { ptr, ptr, ptr, i32 } %888, i32 %889, 3
  %hash_coef_ptr.i.i10.i1181 = getelementptr i8, ptr %883, i64 8
  %tbl_size_ptr.i.i11.i1182 = getelementptr i8, ptr %883, i64 16
  %offset_tbl_ptr.i.i12.i1183 = getelementptr i8, ptr %883, i64 40
  %hash_coef.i.i13.i1184 = load i64, ptr %hash_coef_ptr.i.i10.i1181, align 4
  %tbl_size.i.i14.i1185 = load i64, ptr %tbl_size_ptr.i.i11.i1182, align 4
  %offset_tbl.i.i15.i1186 = load ptr, ptr %offset_tbl_ptr.i.i12.i1183, align 8
  %product.i.i.i16.i1187 = mul i64 %hash_coef.i.i13.i1184, -5261542750394134544
  %shifted.i.i.i17.i1188 = lshr i64 %product.i.i.i16.i1187, 32
  %xored.i.i.i18.i1189 = xor i64 %shifted.i.i.i17.i1188, %product.i.i.i16.i1187
  %hash.i.i.i19.i1190 = and i64 %xored.i.i.i18.i1189, %tbl_size.i.i14.i1185
  %offset_ptr.i.i20.i1191 = getelementptr i32, ptr %offset_tbl.i.i15.i1186, i64 %hash.i.i.i19.i1190
  %offset.i.i21.i1192 = load i32, ptr %offset_ptr.i.i20.i1191, align 4
  %eq.i.i1193 = icmp eq i32 %889, %offset.i.i21.i1192
  call void @llvm.assume(i1 %eq.i.i1193) #30
  %891 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %892 = call ptr @llvm.invariant.start.p0(i64 600, ptr %883)
  %893 = sext i32 %889 to i64
  %894 = getelementptr ptr, ptr %883, i64 %893
  %895 = getelementptr i8, ptr %894, i64 64
  %896 = load ptr, ptr %895, align 8
  %897 = call ptr %896({ ptr, ptr, ptr, i32 } %890, ptr nonnull %2)
  %898 = call i32 %897({ ptr, ptr, ptr, i32 } %890, { ptr, ptr, ptr, i32 } %890, ptr nonnull %2)
  %899 = add i32 %898, -1
  %900 = and i32 %899, %881
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %901 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %902 = load ptr, ptr %104, align 8
  %903 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %902, 0
  %904 = load ptr, ptr %105, align 8
  %905 = insertvalue { ptr, ptr, ptr, i32 } %903, ptr %904, 1
  %906 = load ptr, ptr %106, align 8
  %907 = insertvalue { ptr, ptr, ptr, i32 } %905, ptr %906, 2
  %908 = load i32, ptr %107, align 4
  %909 = insertvalue { ptr, ptr, ptr, i32 } %907, i32 %908, 3
  %hash_coef_ptr.i.i202.i = getelementptr i8, ptr %902, i64 8
  %tbl_size_ptr.i.i203.i = getelementptr i8, ptr %902, i64 16
  %offset_tbl_ptr.i.i204.i = getelementptr i8, ptr %902, i64 40
  %hash_coef.i.i205.i = load i64, ptr %hash_coef_ptr.i.i202.i, align 4
  %tbl_size.i.i206.i = load i64, ptr %tbl_size_ptr.i.i203.i, align 4
  %offset_tbl.i.i207.i = load ptr, ptr %offset_tbl_ptr.i.i204.i, align 8
  %product.i.i.i208.i = mul i64 %hash_coef.i.i205.i, -5261542750394134544
  %shifted.i.i.i209.i = lshr i64 %product.i.i.i208.i, 32
  %xored.i.i.i210.i = xor i64 %shifted.i.i.i209.i, %product.i.i.i208.i
  %hash.i.i.i211.i = and i64 %xored.i.i.i210.i, %tbl_size.i.i206.i
  %offset_ptr.i.i212.i = getelementptr i32, ptr %offset_tbl.i.i207.i, i64 %hash.i.i.i211.i
  %offset.i.i213.i = load i32, ptr %offset_ptr.i.i212.i, align 4
  %eq.i216.i = icmp eq i32 %908, %offset.i.i213.i
  call void @llvm.assume(i1 %eq.i216.i) #30
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %910 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %39)
  %911 = call ptr @llvm.invariant.start.p0(i64 600, ptr %902)
  %912 = sext i32 %908 to i64
  %913 = getelementptr ptr, ptr %902, i64 %912
  %914 = getelementptr i8, ptr %913, i64 120
  %915 = load ptr, ptr %914, align 8
  store ptr @i32_typ, ptr %40, align 8
  %916 = call ptr %915({ ptr, ptr, ptr, i32 } %909, ptr nonnull %40)
  %917 = call { ptr, i160 } %916({ ptr, ptr, ptr, i32 } %909, { ptr, ptr, ptr, i32 } %909, ptr nonnull %39, i32 %900)
  %.fca.0.extract87.i = extractvalue { ptr, i160 } %917, 0
  %918 = ptrtoint ptr %.sroa.speculated352.i1017 to i64
  %919 = ptrtoint ptr %.sroa.speculated346.i1019 to i64
  %.sroa.3.0.insert.ext.i381 = zext i32 %offset.i.i260.i1021 to i160
  %.sroa.3.0.insert.shift.i382 = shl nuw i160 %.sroa.3.0.insert.ext.i381, 128
  %.sroa.2.0.insert.ext.i = zext i64 %919 to i160
  %.sroa.2.0.insert.shift.i = shl nuw nsw i160 %.sroa.2.0.insert.ext.i, 64
  %.sroa.2.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.shift.i, %.sroa.3.0.insert.shift.i382
  %.sroa.0.0.insert.ext.i = zext i64 %918 to i160
  %.sroa.0.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.insert.i, %.sroa.0.0.insert.ext.i
  %920 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i, 1
  %921 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %922 = load ptr, ptr %104, align 8
  %923 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %922, 0
  %924 = load ptr, ptr %105, align 8
  %925 = insertvalue { ptr, ptr, ptr, i32 } %923, ptr %924, 1
  %926 = load ptr, ptr %106, align 8
  %927 = insertvalue { ptr, ptr, ptr, i32 } %925, ptr %926, 2
  %928 = load i32, ptr %107, align 4
  %929 = insertvalue { ptr, ptr, ptr, i32 } %927, i32 %928, 3
  %hash_coef_ptr.i.i218.i = getelementptr i8, ptr %922, i64 8
  %tbl_size_ptr.i.i219.i = getelementptr i8, ptr %922, i64 16
  %offset_tbl_ptr.i.i220.i = getelementptr i8, ptr %922, i64 40
  %hash_coef.i.i221.i = load i64, ptr %hash_coef_ptr.i.i218.i, align 4
  %tbl_size.i.i222.i = load i64, ptr %tbl_size_ptr.i.i219.i, align 4
  %offset_tbl.i.i223.i = load ptr, ptr %offset_tbl_ptr.i.i220.i, align 8
  %product.i.i.i224.i = mul i64 %hash_coef.i.i221.i, -5261542750394134544
  %shifted.i.i.i225.i = lshr i64 %product.i.i.i224.i, 32
  %xored.i.i.i226.i = xor i64 %shifted.i.i.i225.i, %product.i.i.i224.i
  %hash.i.i.i227.i = and i64 %xored.i.i.i226.i, %tbl_size.i.i222.i
  %offset_ptr.i.i228.i = getelementptr i32, ptr %offset_tbl.i.i223.i, i64 %hash.i.i.i227.i
  %offset.i.i229.i = load i32, ptr %offset_ptr.i.i228.i, align 4
  %eq.i232.i = icmp eq i32 %928, %offset.i.i229.i
  call void @llvm.assume(i1 %eq.i232.i) #30
  %930 = load ptr, ptr %result.i, align 8
  %931 = load ptr, ptr %72, align 8
  %result.i233.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %932 = getelementptr i8, ptr %result.i233.i, i64 16
  store ptr %931, ptr %932, align 8
  %933 = getelementptr i8, ptr %result.i233.i, i64 8
  store ptr %930, ptr %933, align 8
  %934 = getelementptr i8, ptr %result.i233.i, i64 24
  store ptr null, ptr %934, align 8
  %935 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i)
  store ptr @Entry, ptr %result.i233.i, align 8
  store ptr @_parameterization_Ptri32, ptr %41, align 8
  store ptr %result.i233.i, ptr %138, align 8
  %936 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %41)
  %937 = call ptr @llvm.invariant.start.p0(i64 600, ptr %922)
  %938 = sext i32 %928 to i64
  %939 = getelementptr ptr, ptr %922, i64 %938
  %940 = getelementptr i8, ptr %939, i64 128
  %941 = load ptr, ptr %940, align 8
  store ptr @i32_typ, ptr %42, align 8
  store ptr @Entry, ptr %139, align 8
  %942 = call ptr %941({ ptr, ptr, ptr, i32 } %929, ptr nonnull %42)
  call void %942({ ptr, ptr, ptr, i32 } %929, { ptr, ptr, ptr, i32 } %929, ptr nonnull %41, i32 %900, { ptr, i160 } %920)
  %943 = icmp ne ptr %.fca.0.extract87.i, @nil_typ
  %944 = icmp ne ptr %.fca.0.extract87.i, null
  %.not138.i = and i1 %943, %944
  br i1 %.not138.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %863, %799
  %.sink = phi { ptr, i160 } [ %835, %799 ], [ %917, %863 ]
  %945 = phi i32 [ 2, %799 ], [ 1, %863 ]
  %vptr.i248.sroa.speculated.i = phi ptr [ %.fca.0.extract112.i, %799 ], [ %.fca.0.extract87.i, %863 ]
  %.fca.1.extract89.i = extractvalue { ptr, i160 } %.sink, 1
  %.sroa.3407.sroa.4.0.extract.shift.i = lshr i160 %.fca.1.extract89.i, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i = trunc i160 %.fca.1.extract89.i to i64
  %.sroa.speculated352.i = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i to ptr
  %.sroa.speculated346.i = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i to ptr
  %hash_coef_ptr.i.i249.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i250.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i251.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 40
  %hash_coef.i.i252.i = load i64, ptr %hash_coef_ptr.i.i249.i, align 4
  %tbl_size.i.i253.i = load i64, ptr %tbl_size_ptr.i.i250.i, align 4
  %offset_tbl.i.i254.i = load ptr, ptr %offset_tbl_ptr.i.i251.i, align 8
  %product.i.i.i255.i = mul i64 %hash_coef.i.i252.i, 4015701072841558310
  %shifted.i.i.i256.i = lshr i64 %product.i.i.i255.i, 32
  %xored.i.i.i257.i = xor i64 %shifted.i.i.i256.i, %product.i.i.i255.i
  %hash.i.i.i258.i = and i64 %xored.i.i.i257.i, %tbl_size.i.i253.i
  %offset_ptr.i.i259.i = getelementptr i32, ptr %offset_tbl.i.i254.i, i64 %hash.i.i.i258.i
  %offset.i.i260.i = load i32, ptr %offset_ptr.i.i259.i, align 4
  store ptr %vptr.i248.sroa.speculated.i, ptr %47, align 8
  store ptr %.sroa.speculated352.i, ptr %135, align 8
  store ptr %.sroa.speculated346.i, ptr %136, align 8
  store i32 %offset.i.i260.i, ptr %137, align 8
  %946 = add nuw nsw i32 %.reg2mem193.0677.i, 1
  %947 = load i32, ptr %110, align 4
  %948 = icmp slt i32 %946, %947
  br i1 %948, label %789, label %._crit_edge1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %799, %863
  %949 = phi ptr [ %43, %863 ], [ %35, %799 ]
  %950 = phi ptr [ %44, %863 ], [ %36, %799 ]
  %951 = phi ptr [ %45, %863 ], [ %37, %799 ]
  %952 = phi ptr [ %.sroa.0.i350, %863 ], [ %.sroa.0680.i, %799 ]
  %953 = phi ptr [ %46, %863 ], [ %38, %799 ]
  %954 = load i32, ptr %108, align 4
  store i32 %954, ptr %949, align 4
  store i32 1, ptr %950, align 4
  %955 = add i32 %954, 1
  store i32 %955, ptr %951, align 4
  %956 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %955, ptr %108, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %953, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %952, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i350)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.i:                                   ; preds = %.cont.cont.i, %._crit_edge.i
  %957 = load i160, ptr %135, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i350)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %30)
  %958 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %959 = load ptr, ptr %89, align 8
  %960 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %959, 0
  %961 = load ptr, ptr %90, align 8
  %962 = insertvalue { ptr, ptr, ptr, i32 } %960, ptr %961, 1
  %963 = load ptr, ptr %91, align 8
  %964 = insertvalue { ptr, ptr, ptr, i32 } %962, ptr %963, 2
  %965 = load i32, ptr %92, align 4
  %966 = insertvalue { ptr, ptr, ptr, i32 } %964, i32 %965, 3
  %hash_coef_ptr.i.i64.i404 = getelementptr i8, ptr %959, i64 8
  %tbl_size_ptr.i.i65.i405 = getelementptr i8, ptr %959, i64 16
  %offset_tbl_ptr.i.i66.i406 = getelementptr i8, ptr %959, i64 40
  %hash_coef.i.i67.i407 = load i64, ptr %hash_coef_ptr.i.i64.i404, align 4
  %tbl_size.i.i68.i408 = load i64, ptr %tbl_size_ptr.i.i65.i405, align 4
  %offset_tbl.i.i69.i409 = load ptr, ptr %offset_tbl_ptr.i.i66.i406, align 8
  %product.i.i.i70.i410 = mul i64 %hash_coef.i.i67.i407, -5261542750394134544
  %shifted.i.i.i71.i411 = lshr i64 %product.i.i.i70.i410, 32
  %xored.i.i.i72.i412 = xor i64 %shifted.i.i.i71.i411, %product.i.i.i70.i410
  %hash.i.i.i73.i413 = and i64 %xored.i.i.i72.i412, %tbl_size.i.i68.i408
  %offset_ptr.i.i74.i414 = getelementptr i32, ptr %offset_tbl.i.i69.i409, i64 %hash.i.i.i73.i413
  %offset.i.i75.i415 = load i32, ptr %offset_ptr.i.i74.i414, align 4
  %eq.i.i416 = icmp eq i32 %965, %offset.i.i75.i415
  call void @llvm.assume(i1 %eq.i.i416) #30
  %967 = load ptr, ptr %104, align 8
  %968 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %967, 0
  %969 = load ptr, ptr %105, align 8
  %970 = insertvalue { ptr, ptr, ptr, i32 } %968, ptr %969, 1
  %971 = load ptr, ptr %106, align 8
  %972 = insertvalue { ptr, ptr, ptr, i32 } %970, ptr %971, 2
  %973 = load i32, ptr %107, align 4
  %974 = insertvalue { ptr, ptr, ptr, i32 } %972, i32 %973, 3
  %hash_coef_ptr.i.i92.i421 = getelementptr i8, ptr %967, i64 8
  %tbl_size_ptr.i.i93.i422 = getelementptr i8, ptr %967, i64 16
  %offset_tbl_ptr.i.i94.i423 = getelementptr i8, ptr %967, i64 40
  %hash_coef.i.i95.i424 = load i64, ptr %hash_coef_ptr.i.i92.i421, align 4
  %tbl_size.i.i96.i425 = load i64, ptr %tbl_size_ptr.i.i93.i422, align 4
  %offset_tbl.i.i97.i426 = load ptr, ptr %offset_tbl_ptr.i.i94.i423, align 8
  %product.i.i.i98.i427 = mul i64 %hash_coef.i.i95.i424, -5261542750394134544
  %shifted.i.i.i99.i428 = lshr i64 %product.i.i.i98.i427, 32
  %xored.i.i.i100.i429 = xor i64 %shifted.i.i.i99.i428, %product.i.i.i98.i427
  %hash.i.i.i101.i430 = and i64 %xored.i.i.i100.i429, %tbl_size.i.i96.i425
  %offset_ptr.i.i102.i431 = getelementptr i32, ptr %offset_tbl.i.i97.i426, i64 %hash.i.i.i101.i430
  %offset.i.i103.i432 = load i32, ptr %offset_ptr.i.i102.i431, align 4
  %eq.i106.i433 = icmp eq i32 %973, %offset.i.i103.i432
  call void @llvm.assume(i1 %eq.i106.i433) #30
  %975 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %976 = call ptr @llvm.invariant.start.p0(i64 600, ptr %959)
  %977 = sext i32 %965 to i64
  %978 = getelementptr ptr, ptr %959, i64 %977
  %979 = getelementptr i8, ptr %978, i64 64
  %980 = load ptr, ptr %979, align 8
  %981 = call ptr %980({ ptr, ptr, ptr, i32 } %966, ptr nonnull %2)
  %982 = call i32 %981({ ptr, ptr, ptr, i32 } %966, { ptr, ptr, ptr, i32 } %966, ptr nonnull %2)
  %983 = shl i32 %982, 1
  %984 = load i32, ptr %108, align 4
  %985 = load ptr, ptr %result.i, align 8
  %986 = load ptr, ptr %72, align 8
  %987 = sext i32 %984 to i64
  %988 = shl nsw i64 %987, 5
  %result.i.i.i436 = call noalias ptr @bump_malloc_inner(i64 noundef %988, ptr nonnull @current_ptr) #29
  %989 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %990 = icmp sgt i32 %982, 0
  br i1 %990, label %.lr.ph434.i506, label %._crit_edge395.i450

.lr.ph434.i506:                                   ; preds = %._crit_edge1.i
  %invariant.gep.i449 = getelementptr i8, ptr %959, i64 120
  %991 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i509 = getelementptr ptr, ptr %invariant.gep.i449, i64 %977
  br label %992

992:                                              ; preds = %1014, %.lr.ph434.i506
  %.reg2mem105.0432.i507 = phi i32 [ 0, %.lr.ph434.i506 ], [ %.reg2mem101.0.i512, %1014 ]
  %.reg2mem103.0431.i508 = phi i32 [ 0, %.lr.ph434.i506 ], [ %1015, %1014 ]
  store ptr @_parameterization_Ptri32, ptr %25, align 8
  %993 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %25)
  %994 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %959)
  %995 = load ptr, ptr %gep.i509, align 8
  store ptr @i32_typ, ptr %26, align 8
  %996 = call ptr %995({ ptr, ptr, ptr, i32 } %966, ptr nonnull %26)
  %997 = call { ptr, i160 } %996({ ptr, ptr, ptr, i32 } %966, { ptr, ptr, ptr, i32 } %966, ptr nonnull %25, i32 %.reg2mem103.0431.i508)
  %.fca.0.extract52.i510 = extractvalue { ptr, i160 } %997, 0
  %998 = icmp ne ptr %.fca.0.extract52.i510, @nil_typ
  %999 = icmp ne ptr %.fca.0.extract52.i510, null
  %.not60.i511 = and i1 %998, %999
  br i1 %.not60.i511, label %1000, label %1014

1000:                                             ; preds = %992
  %hash_coef_ptr.i.i137.i539 = getelementptr i8, ptr %.fca.0.extract52.i510, i64 8
  %tbl_size_ptr.i.i138.i540 = getelementptr i8, ptr %.fca.0.extract52.i510, i64 16
  %offset_tbl_ptr.i.i139.i541 = getelementptr i8, ptr %.fca.0.extract52.i510, i64 40
  %hash_coef.i.i140.i542 = load i64, ptr %hash_coef_ptr.i.i137.i539, align 4
  %tbl_size.i.i141.i543 = load i64, ptr %tbl_size_ptr.i.i138.i540, align 4
  %offset_tbl.i.i142.i544 = load ptr, ptr %offset_tbl_ptr.i.i139.i541, align 8
  %product.i.i.i143.i545 = mul i64 %hash_coef.i.i140.i542, 4015701072841558310
  %shifted.i.i.i144.i546 = lshr i64 %product.i.i.i143.i545, 32
  %xored.i.i.i145.i547 = xor i64 %shifted.i.i.i144.i546, %product.i.i.i143.i545
  %hash.i.i.i146.i548 = and i64 %xored.i.i.i145.i547, %tbl_size.i.i141.i543
  %offset_ptr.i.i147.i549 = getelementptr i32, ptr %offset_tbl.i.i142.i544, i64 %hash.i.i.i146.i548
  %offset.i.i148.i550 = load i32, ptr %offset_ptr.i.i147.i549, align 4
  %1001 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1002 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1003 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1004 = icmp slt i32 %.reg2mem105.0432.i507, %984
  br i1 %1004, label %1005, label %._crit_edge.i551

1005:                                             ; preds = %1000
  %.fca.1.extract54.i552 = extractvalue { ptr, i160 } %997, 1
  %.sroa.351.0.insert.ext.i553 = zext i32 %offset.i.i148.i550 to i160
  %.sroa.351.0.insert.shift.i554 = shl nuw i160 %.sroa.351.0.insert.ext.i553, 128
  %1006 = and i160 %.fca.1.extract54.i552, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i555 = or disjoint i160 %.sroa.351.0.insert.shift.i554, %1006
  %1007 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1008 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1009 = sext i32 %.reg2mem105.0432.i507 to i64
  %1010 = shl nsw i64 %1009, 5
  %1011 = getelementptr i8, ptr %result.i.i.i436, i64 %1010
  store ptr %.fca.0.extract52.i510, ptr %1011, align 8
  %1012 = getelementptr i8, ptr %1011, i64 8
  store i160 %.sroa.049.0.insert.insert.i555, ptr %1012, align 4
  br label %._crit_edge.i551

._crit_edge.i551:                                 ; preds = %1005, %1000
  %1013 = add i32 %.reg2mem105.0432.i507, 1
  br label %1014

1014:                                             ; preds = %._crit_edge.i551, %992
  %.reg2mem101.0.i512 = phi i32 [ %1013, %._crit_edge.i551 ], [ %.reg2mem105.0432.i507, %992 ]
  %1015 = add nuw nsw i32 %.reg2mem103.0431.i508, 1
  %1016 = icmp slt i32 %1015, %982
  br i1 %1016, label %992, label %.lr.ph.i513

.lr.ph.i513:                                      ; preds = %1014
  %invariant.gep396.i514 = getelementptr i8, ptr %967, i64 120
  %1017 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1018 = sext i32 %973 to i64
  %gep397.i517 = getelementptr ptr, ptr %invariant.gep396.i514, i64 %1018
  br label %1019

1019:                                             ; preds = %1041, %.lr.ph.i513
  %.reg2mem91.0394.i515 = phi i32 [ %.reg2mem101.0.i512, %.lr.ph.i513 ], [ %.reg2mem87.0.i520, %1041 ]
  %.reg2mem89.0393.i516 = phi i32 [ 0, %.lr.ph.i513 ], [ %1042, %1041 ]
  store ptr @_parameterization_Ptri32, ptr %27, align 8
  %1020 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %27)
  %1021 = call ptr @llvm.invariant.start.p0(i64 600, ptr %967)
  %1022 = load ptr, ptr %gep397.i517, align 8
  store ptr @i32_typ, ptr %28, align 8
  %1023 = call ptr %1022({ ptr, ptr, ptr, i32 } %974, ptr nonnull %28)
  %1024 = call { ptr, i160 } %1023({ ptr, ptr, ptr, i32 } %974, { ptr, ptr, ptr, i32 } %974, ptr nonnull %27, i32 %.reg2mem89.0393.i516)
  %.fca.0.extract42.i518 = extractvalue { ptr, i160 } %1024, 0
  %1025 = icmp ne ptr %.fca.0.extract42.i518, @nil_typ
  %1026 = icmp ne ptr %.fca.0.extract42.i518, null
  %.not62.i519 = and i1 %1025, %1026
  br i1 %.not62.i519, label %1027, label %1041

1027:                                             ; preds = %1019
  %hash_coef_ptr.i.i152.i521 = getelementptr i8, ptr %.fca.0.extract42.i518, i64 8
  %tbl_size_ptr.i.i153.i522 = getelementptr i8, ptr %.fca.0.extract42.i518, i64 16
  %offset_tbl_ptr.i.i154.i523 = getelementptr i8, ptr %.fca.0.extract42.i518, i64 40
  %hash_coef.i.i155.i524 = load i64, ptr %hash_coef_ptr.i.i152.i521, align 4
  %tbl_size.i.i156.i525 = load i64, ptr %tbl_size_ptr.i.i153.i522, align 4
  %offset_tbl.i.i157.i526 = load ptr, ptr %offset_tbl_ptr.i.i154.i523, align 8
  %product.i.i.i158.i527 = mul i64 %hash_coef.i.i155.i524, 4015701072841558310
  %shifted.i.i.i159.i528 = lshr i64 %product.i.i.i158.i527, 32
  %xored.i.i.i160.i529 = xor i64 %shifted.i.i.i159.i528, %product.i.i.i158.i527
  %hash.i.i.i161.i530 = and i64 %xored.i.i.i160.i529, %tbl_size.i.i156.i525
  %offset_ptr.i.i162.i531 = getelementptr i32, ptr %offset_tbl.i.i157.i526, i64 %hash.i.i.i161.i530
  %offset.i.i163.i532 = load i32, ptr %offset_ptr.i.i162.i531, align 4
  %1028 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1029 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1030 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1031 = icmp slt i32 %.reg2mem91.0394.i515, %984
  br i1 %1031, label %1032, label %._crit_edge1.i533

1032:                                             ; preds = %1027
  %.fca.1.extract44.i534 = extractvalue { ptr, i160 } %1024, 1
  %.sroa.3.0.insert.ext.i535 = zext i32 %offset.i.i163.i532 to i160
  %.sroa.3.0.insert.shift.i536 = shl nuw i160 %.sroa.3.0.insert.ext.i535, 128
  %1033 = and i160 %.fca.1.extract44.i534, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i537 = or disjoint i160 %.sroa.3.0.insert.shift.i536, %1033
  %1034 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1035 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1036 = sext i32 %.reg2mem91.0394.i515 to i64
  %1037 = shl nsw i64 %1036, 5
  %1038 = getelementptr i8, ptr %result.i.i.i436, i64 %1037
  store ptr %.fca.0.extract42.i518, ptr %1038, align 8
  %1039 = getelementptr i8, ptr %1038, i64 8
  store i160 %.sroa.040.0.insert.insert.i537, ptr %1039, align 4
  br label %._crit_edge1.i533

._crit_edge1.i533:                                ; preds = %1032, %1027
  %1040 = add i32 %.reg2mem91.0394.i515, 1
  br label %1041

1041:                                             ; preds = %._crit_edge1.i533, %1019
  %.reg2mem87.0.i520 = phi i32 [ %1040, %._crit_edge1.i533 ], [ %.reg2mem91.0394.i515, %1019 ]
  %1042 = add nuw nsw i32 %.reg2mem89.0393.i516, 1
  %1043 = icmp slt i32 %1042, %982
  br i1 %1043, label %1019, label %._crit_edge395.i450.loopexit

._crit_edge395.i450.loopexit:                     ; preds = %1041
  %.pre1074 = load ptr, ptr %result.i, align 8
  %.pre1075 = load ptr, ptr %72, align 8
  br label %._crit_edge395.i450

._crit_edge395.i450:                              ; preds = %._crit_edge395.i450.loopexit, %._crit_edge1.i
  %1044 = phi ptr [ %986, %._crit_edge1.i ], [ %.pre1075, %._crit_edge395.i450.loopexit ]
  %1045 = phi ptr [ %985, %._crit_edge1.i ], [ %.pre1074, %._crit_edge395.i450.loopexit ]
  %.reg2mem91.0.lcssa.i451 = phi i32 [ 0, %._crit_edge1.i ], [ %.reg2mem87.0.i520, %._crit_edge395.i450.loopexit ]
  %1046 = call i32 @llvm.smax.i32(i32 %983, i32 16)
  %result.i166.i452 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1047 = getelementptr i8, ptr %result.i166.i452, i64 16
  store ptr @_parameterization_Nil, ptr %1047, align 8
  %result.i167.i453 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1048 = getelementptr i8, ptr %result.i167.i453, i64 16
  store ptr %1044, ptr %1048, align 8
  %1049 = getelementptr i8, ptr %result.i167.i453, i64 8
  store ptr %1045, ptr %1049, align 8
  %1050 = getelementptr i8, ptr %result.i167.i453, i64 24
  store ptr null, ptr %1050, align 8
  %1051 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i453)
  store ptr @Entry, ptr %result.i167.i453, align 8
  %1052 = getelementptr i8, ptr %result.i166.i452, i64 8
  store ptr %result.i167.i453, ptr %1052, align 8
  %1053 = getelementptr i8, ptr %result.i166.i452, i64 24
  store ptr null, ptr %1053, align 8
  %1054 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i452)
  store ptr @union_typ, ptr %result.i166.i452, align 8
  %result.i168.i454 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i452, ptr %result.i168.i454, align 8
  %1055 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i454)
  store ptr @Array, ptr %29, align 8
  store ptr %result.i168.i454, ptr %142, align 8
  store i32 9, ptr %143, align 8
  %1056 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %29)
  %1057 = getelementptr i8, ptr %result.i168.i454, i64 16
  store i32 %1046, ptr %1057, align 4
  %1058 = getelementptr i8, ptr %result.i168.i454, i64 20
  store i32 %1046, ptr %1058, align 4
  %1059 = zext nneg i32 %1046 to i64
  %1060 = shl nuw nsw i64 %1059, 5
  %result.i.i416.i455 = call noalias ptr @bump_malloc_inner(i64 noundef %1060, ptr nonnull @current_ptr) #29
  %1061 = getelementptr i8, ptr %result.i168.i454, i64 8
  store ptr %result.i.i416.i455, ptr %1061, align 8
  %1062 = load ptr, ptr %144, align 8
  store ptr @Array, ptr %89, align 8
  store ptr %result.i168.i454, ptr %90, align 8
  store ptr %1062, ptr %91, align 8
  store i32 9, ptr %92, align 4
  %1063 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i468 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1064 = getelementptr i8, ptr %result.i183.i468, i64 16
  store ptr @_parameterization_Nil, ptr %1064, align 8
  %result.i184.i469 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1065 = getelementptr i8, ptr %result.i184.i469, i64 16
  store ptr %1044, ptr %1065, align 8
  %1066 = getelementptr i8, ptr %result.i184.i469, i64 8
  store ptr %1045, ptr %1066, align 8
  %1067 = getelementptr i8, ptr %result.i184.i469, i64 24
  store ptr null, ptr %1067, align 8
  %1068 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i469)
  store ptr @Entry, ptr %result.i184.i469, align 8
  %1069 = getelementptr i8, ptr %result.i183.i468, i64 8
  store ptr %result.i184.i469, ptr %1069, align 8
  %1070 = getelementptr i8, ptr %result.i183.i468, i64 24
  store ptr null, ptr %1070, align 8
  %1071 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i468)
  store ptr @union_typ, ptr %result.i183.i468, align 8
  %result.i185.i470 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i468, ptr %result.i185.i470, align 8
  %1072 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i470)
  store ptr @Array, ptr %30, align 8
  store ptr %result.i185.i470, ptr %145, align 8
  store i32 9, ptr %146, align 8
  %1073 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %30)
  %1074 = getelementptr i8, ptr %result.i185.i470, i64 16
  store i32 %1046, ptr %1074, align 4
  %1075 = getelementptr i8, ptr %result.i185.i470, i64 20
  store i32 %1046, ptr %1075, align 4
  %result.i.i430.i471 = call noalias ptr @bump_malloc_inner(i64 noundef %1060, ptr nonnull @current_ptr) #29
  %1076 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1077 = getelementptr i8, ptr %result.i185.i470, i64 8
  store ptr %result.i.i430.i471, ptr %1077, align 8
  %1078 = load ptr, ptr %147, align 8
  store ptr @Array, ptr %104, align 8
  store ptr %result.i185.i470, ptr %105, align 8
  store ptr %1078, ptr %106, align 8
  store i32 9, ptr %107, align 4
  store i32 0, ptr %108, align 4
  %1079 = icmp sgt i32 %.reg2mem91.0.lcssa.i451, 0
  br i1 %1079, label %.lr.ph400.i484, label %HashMap_resize_.exit557

.lr.ph400.i484:                                   ; preds = %._crit_edge395.i450
  %1080 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1081 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1082 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i486

._crit_edge2.i486:                                ; preds = %._crit_edge2.i486, %.lr.ph400.i484
  %.reg2mem77.0398.i487 = phi i32 [ 0, %.lr.ph400.i484 ], [ %1096, %._crit_edge2.i486 ]
  %1083 = zext nneg i32 %.reg2mem77.0398.i487 to i64
  %1084 = shl nuw nsw i64 %1083, 5
  %1085 = getelementptr i8, ptr %result.i.i.i436, i64 %1084
  %1086 = load ptr, ptr %1085, align 8
  %1087 = getelementptr i8, ptr %1085, i64 8
  %1088 = load i160, ptr %1087, align 4
  %.sroa.3362.8.extract.trunc.i490 = trunc i160 %1088 to i64
  %1089 = inttoptr i64 %.sroa.3362.8.extract.trunc.i490 to ptr
  %.sroa.5363.8.extract.shift.i491 = lshr i160 %1088, 64
  %.sroa.5363.8.extract.trunc.i492 = trunc i160 %.sroa.5363.8.extract.shift.i491 to i64
  %1090 = inttoptr i64 %.sroa.5363.8.extract.trunc.i492 to ptr
  %hash_coef_ptr.i.i201.i493 = getelementptr i8, ptr %1086, i64 8
  %tbl_size_ptr.i.i202.i494 = getelementptr i8, ptr %1086, i64 16
  %offset_tbl_ptr.i.i203.i495 = getelementptr i8, ptr %1086, i64 40
  %hash_coef.i.i232.i496 = load i64, ptr %hash_coef_ptr.i.i201.i493, align 4
  %tbl_size.i.i233.i497 = load i64, ptr %tbl_size_ptr.i.i202.i494, align 4
  %offset_tbl.i.i234.i498 = load ptr, ptr %offset_tbl_ptr.i.i203.i495, align 8
  %product.i.i.i235.i499 = mul i64 %hash_coef.i.i232.i496, 4015701072841558310
  %shifted.i.i.i236.i500 = lshr i64 %product.i.i.i235.i499, 32
  %xored.i.i.i237.i501 = xor i64 %shifted.i.i.i236.i500, %product.i.i.i235.i499
  %hash.i.i.i238.i502 = and i64 %xored.i.i.i237.i501, %tbl_size.i.i233.i497
  %offset_ptr.i.i239.i503 = getelementptr i32, ptr %offset_tbl.i.i234.i498, i64 %hash.i.i.i238.i502
  %offset.i.i240.i504 = load i32, ptr %offset_ptr.i.i239.i503, align 4
  %1091 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1086, 0
  %1092 = insertvalue { ptr, ptr, ptr, i32 } %1091, ptr %1089, 1
  %1093 = insertvalue { ptr, ptr, ptr, i32 } %1092, ptr %1090, 2
  %1094 = insertvalue { ptr, ptr, ptr, i32 } %1093, i32 %offset.i.i240.i504, 3
  %1095 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1094)
  %1096 = add nuw nsw i32 %.reg2mem77.0398.i487, 1
  %1097 = icmp slt i32 %1096, %.reg2mem91.0.lcssa.i451
  br i1 %1097, label %._crit_edge2.i486, label %HashMap_resize_.exit557

HashMap_resize_.exit557:                          ; preds = %._crit_edge2.i486, %._crit_edge395.i450
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %30)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i558)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i560)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %24)
  %1098 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1099 = load i32, ptr %110, align 4
  %1100 = icmp sgt i32 %1099, 0
  br i1 %1100, label %.lr.ph.i595, label %._crit_edge1.1.i

.lr.ph.i595:                                      ; preds = %HashMap_resize_.exit557
  %1101 = lshr i160 %957, 64
  %1102 = insertelement <2 x i160> poison, i160 %1101, i64 0
  %1103 = insertelement <2 x i160> %1102, i160 %957, i64 1
  %1104 = trunc <2 x i160> %1103 to <2 x i64>
  %1105 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1106 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1107

1107:                                             ; preds = %.cont.cont.i649, %.lr.ph.i595
  %offset.i.i260.i6661029 = phi i32 [ 9, %.lr.ph.i595 ], [ %offset.i.i260.i666, %.cont.cont.i649 ]
  %.reg2mem195.0678.i597 = phi i32 [ 1, %.lr.ph.i595 ], [ %1262, %.cont.cont.i649 ]
  %.reg2mem193.0677.i598 = phi i32 [ 0, %.lr.ph.i595 ], [ %1267, %.cont.cont.i649 ]
  %1108 = phi <2 x i64> [ %1104, %.lr.ph.i595 ], [ %1266, %.cont.cont.i649 ]
  %1109 = extractelement <2 x i64> %1108, i64 1
  %.sroa.speculated352.i6531025 = inttoptr i64 %1109 to ptr
  %1110 = extractelement <2 x i64> %1108, i64 0
  %.sroa.speculated346.i6541027 = inttoptr i64 %1110 to ptr
  %1111 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i6531025, 1
  %1112 = insertvalue { ptr, ptr, ptr, i32 } %1111, ptr %.sroa.speculated346.i6541027, 2
  %1113 = insertvalue { ptr, ptr, ptr, i32 } %1112, i32 %offset.i.i260.i6661029, 3
  %1114 = sext i32 %offset.i.i260.i6661029 to i64
  %gep1023 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1114
  %1115 = load ptr, ptr %gep1023, align 8
  %1116 = call ptr %1115({ ptr, ptr, ptr, i32 } %1113, ptr nonnull %2)
  %1117 = call i32 %1116({ ptr, ptr, ptr, i32 } %1113, { ptr, ptr, ptr, i32 } %1113, ptr nonnull %2)
  %1118 = icmp eq i32 %.reg2mem195.0678.i597, 1
  %1119 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1118, label %1120, label %1182

1120:                                             ; preds = %1107
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1121 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1122 = load ptr, ptr %89, align 8
  %1123 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1122, 0
  %1124 = load ptr, ptr %90, align 8
  %1125 = insertvalue { ptr, ptr, ptr, i32 } %1123, ptr %1124, 1
  %1126 = load ptr, ptr %91, align 8
  %1127 = insertvalue { ptr, ptr, ptr, i32 } %1125, ptr %1126, 2
  %1128 = load i32, ptr %92, align 4
  %1129 = insertvalue { ptr, ptr, ptr, i32 } %1127, i32 %1128, 3
  %hash_coef_ptr.i.i10.i1284 = getelementptr i8, ptr %1122, i64 8
  %tbl_size_ptr.i.i11.i1285 = getelementptr i8, ptr %1122, i64 16
  %offset_tbl_ptr.i.i12.i1286 = getelementptr i8, ptr %1122, i64 40
  %hash_coef.i.i13.i1287 = load i64, ptr %hash_coef_ptr.i.i10.i1284, align 4
  %tbl_size.i.i14.i1288 = load i64, ptr %tbl_size_ptr.i.i11.i1285, align 4
  %offset_tbl.i.i15.i1289 = load ptr, ptr %offset_tbl_ptr.i.i12.i1286, align 8
  %product.i.i.i16.i1290 = mul i64 %hash_coef.i.i13.i1287, -5261542750394134544
  %shifted.i.i.i17.i1291 = lshr i64 %product.i.i.i16.i1290, 32
  %xored.i.i.i18.i1292 = xor i64 %shifted.i.i.i17.i1291, %product.i.i.i16.i1290
  %hash.i.i.i19.i1293 = and i64 %xored.i.i.i18.i1292, %tbl_size.i.i14.i1288
  %offset_ptr.i.i20.i1294 = getelementptr i32, ptr %offset_tbl.i.i15.i1289, i64 %hash.i.i.i19.i1293
  %offset.i.i21.i1295 = load i32, ptr %offset_ptr.i.i20.i1294, align 4
  %eq.i.i1296 = icmp eq i32 %1128, %offset.i.i21.i1295
  call void @llvm.assume(i1 %eq.i.i1296) #30
  %1130 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1131 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1122)
  %1132 = sext i32 %1128 to i64
  %1133 = getelementptr ptr, ptr %1122, i64 %1132
  %1134 = getelementptr i8, ptr %1133, i64 64
  %1135 = load ptr, ptr %1134, align 8
  %1136 = call ptr %1135({ ptr, ptr, ptr, i32 } %1129, ptr nonnull %2)
  %1137 = call i32 %1136({ ptr, ptr, ptr, i32 } %1129, { ptr, ptr, ptr, i32 } %1129, ptr nonnull %2)
  %1138 = add i32 %1137, -1
  %1139 = and i32 %1138, %1117
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1140 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1141 = load ptr, ptr %89, align 8
  %1142 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1141, 0
  %1143 = load ptr, ptr %90, align 8
  %1144 = insertvalue { ptr, ptr, ptr, i32 } %1142, ptr %1143, 1
  %1145 = load ptr, ptr %91, align 8
  %1146 = insertvalue { ptr, ptr, ptr, i32 } %1144, ptr %1145, 2
  %1147 = load i32, ptr %92, align 4
  %1148 = insertvalue { ptr, ptr, ptr, i32 } %1146, i32 %1147, 3
  %hash_coef_ptr.i.i172.i671 = getelementptr i8, ptr %1141, i64 8
  %tbl_size_ptr.i.i173.i672 = getelementptr i8, ptr %1141, i64 16
  %offset_tbl_ptr.i.i174.i673 = getelementptr i8, ptr %1141, i64 40
  %hash_coef.i.i175.i674 = load i64, ptr %hash_coef_ptr.i.i172.i671, align 4
  %tbl_size.i.i176.i675 = load i64, ptr %tbl_size_ptr.i.i173.i672, align 4
  %offset_tbl.i.i177.i676 = load ptr, ptr %offset_tbl_ptr.i.i174.i673, align 8
  %product.i.i.i178.i677 = mul i64 %hash_coef.i.i175.i674, -5261542750394134544
  %shifted.i.i.i179.i678 = lshr i64 %product.i.i.i178.i677, 32
  %xored.i.i.i180.i679 = xor i64 %shifted.i.i.i179.i678, %product.i.i.i178.i677
  %hash.i.i.i181.i680 = and i64 %xored.i.i.i180.i679, %tbl_size.i.i176.i675
  %offset_ptr.i.i182.i681 = getelementptr i32, ptr %offset_tbl.i.i177.i676, i64 %hash.i.i.i181.i680
  %offset.i.i183.i682 = load i32, ptr %offset_ptr.i.i182.i681, align 4
  %eq.i.i683 = icmp eq i32 %1147, %offset.i.i183.i682
  call void @llvm.assume(i1 %eq.i.i683) #30
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  %1149 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %9)
  %1150 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1141)
  %1151 = sext i32 %1147 to i64
  %1152 = getelementptr ptr, ptr %1141, i64 %1151
  %1153 = getelementptr i8, ptr %1152, i64 120
  %1154 = load ptr, ptr %1153, align 8
  store ptr @i32_typ, ptr %10, align 8
  %1155 = call ptr %1154({ ptr, ptr, ptr, i32 } %1148, ptr nonnull %10)
  %1156 = call { ptr, i160 } %1155({ ptr, ptr, ptr, i32 } %1148, { ptr, ptr, ptr, i32 } %1148, ptr nonnull %9, i32 %1139)
  %.fca.0.extract112.i684 = extractvalue { ptr, i160 } %1156, 0
  %.sroa.3111.0.insert.ext.i685 = zext i32 %offset.i.i260.i6661029 to i160
  %.sroa.3111.0.insert.shift.i686 = shl nuw i160 %.sroa.3111.0.insert.ext.i685, 128
  %.sroa.2110.0.insert.ext.i687 = zext i64 %1110 to i160
  %.sroa.2110.0.insert.shift.i688 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i687, 64
  %.sroa.2110.0.insert.insert.i689 = or disjoint i160 %.sroa.2110.0.insert.shift.i688, %.sroa.3111.0.insert.shift.i686
  %.sroa.0109.0.insert.ext.i690 = zext i64 %1109 to i160
  %.sroa.0109.0.insert.insert.i691 = or disjoint i160 %.sroa.2110.0.insert.insert.i689, %.sroa.0109.0.insert.ext.i690
  %1157 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i691, 1
  %1158 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1159 = load ptr, ptr %89, align 8
  %1160 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1159, 0
  %1161 = load ptr, ptr %90, align 8
  %1162 = insertvalue { ptr, ptr, ptr, i32 } %1160, ptr %1161, 1
  %1163 = load ptr, ptr %91, align 8
  %1164 = insertvalue { ptr, ptr, ptr, i32 } %1162, ptr %1163, 2
  %1165 = load i32, ptr %92, align 4
  %1166 = insertvalue { ptr, ptr, ptr, i32 } %1164, i32 %1165, 3
  %hash_coef_ptr.i.i186.i696 = getelementptr i8, ptr %1159, i64 8
  %tbl_size_ptr.i.i187.i697 = getelementptr i8, ptr %1159, i64 16
  %offset_tbl_ptr.i.i188.i698 = getelementptr i8, ptr %1159, i64 40
  %hash_coef.i.i189.i699 = load i64, ptr %hash_coef_ptr.i.i186.i696, align 4
  %tbl_size.i.i190.i700 = load i64, ptr %tbl_size_ptr.i.i187.i697, align 4
  %offset_tbl.i.i191.i701 = load ptr, ptr %offset_tbl_ptr.i.i188.i698, align 8
  %product.i.i.i192.i702 = mul i64 %hash_coef.i.i189.i699, -5261542750394134544
  %shifted.i.i.i193.i703 = lshr i64 %product.i.i.i192.i702, 32
  %xored.i.i.i194.i704 = xor i64 %shifted.i.i.i193.i703, %product.i.i.i192.i702
  %hash.i.i.i195.i705 = and i64 %xored.i.i.i194.i704, %tbl_size.i.i190.i700
  %offset_ptr.i.i196.i706 = getelementptr i32, ptr %offset_tbl.i.i191.i701, i64 %hash.i.i.i195.i705
  %offset.i.i197.i707 = load i32, ptr %offset_ptr.i.i196.i706, align 4
  %eq.i200.i708 = icmp eq i32 %1165, %offset.i.i197.i707
  call void @llvm.assume(i1 %eq.i200.i708) #30
  %1167 = load ptr, ptr %result.i, align 8
  %1168 = load ptr, ptr %72, align 8
  %result.i.i709 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1169 = getelementptr i8, ptr %result.i.i709, i64 16
  store ptr %1168, ptr %1169, align 8
  %1170 = getelementptr i8, ptr %result.i.i709, i64 8
  store ptr %1167, ptr %1170, align 8
  %1171 = getelementptr i8, ptr %result.i.i709, i64 24
  store ptr null, ptr %1171, align 8
  %1172 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i709)
  store ptr @Entry, ptr %result.i.i709, align 8
  store ptr @_parameterization_Ptri32, ptr %11, align 8
  store ptr %result.i.i709, ptr %150, align 8
  %1173 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %11)
  %1174 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1159)
  %1175 = sext i32 %1165 to i64
  %1176 = getelementptr ptr, ptr %1159, i64 %1175
  %1177 = getelementptr i8, ptr %1176, i64 128
  %1178 = load ptr, ptr %1177, align 8
  store ptr @i32_typ, ptr %12, align 8
  store ptr @Entry, ptr %151, align 8
  %1179 = call ptr %1178({ ptr, ptr, ptr, i32 } %1166, ptr nonnull %12)
  call void %1179({ ptr, ptr, ptr, i32 } %1166, { ptr, ptr, ptr, i32 } %1166, ptr nonnull %11, i32 %1139, { ptr, i160 } %1157)
  %1180 = icmp ne ptr %.fca.0.extract112.i684, @nil_typ
  %1181 = icmp ne ptr %.fca.0.extract112.i684, null
  %.not140.i710 = and i1 %1180, %1181
  br i1 %.not140.i710, label %.cont.cont.i649, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit716.thread

1182:                                             ; preds = %1107
  %1183 = add i32 %1117, 2127912214
  %1184 = shl i32 %1117, 12
  %1185 = add i32 %1183, %1184
  %1186 = ashr i32 %1185, 19
  %1187 = xor i32 %1185, %1186
  %1188 = xor i32 %1187, -949894596
  %1189 = add i32 %1188, 374761393
  %1190 = shl i32 %1188, 5
  %1191 = add i32 %1189, %1190
  %1192 = add i32 %1191, -744332180
  %1193 = shl i32 %1191, 9
  %1194 = xor i32 %1192, %1193
  %1195 = add i32 %1194, -42973499
  %1196 = shl i32 %1194, 3
  %1197 = add i32 %1195, %1196
  %1198 = ashr i32 %1197, 16
  %1199 = xor i32 %1197, %1198
  %1200 = xor i32 %1199, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1201 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1202 = load ptr, ptr %104, align 8
  %1203 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1202, 0
  %1204 = load ptr, ptr %105, align 8
  %1205 = insertvalue { ptr, ptr, ptr, i32 } %1203, ptr %1204, 1
  %1206 = load ptr, ptr %106, align 8
  %1207 = insertvalue { ptr, ptr, ptr, i32 } %1205, ptr %1206, 2
  %1208 = load i32, ptr %107, align 4
  %1209 = insertvalue { ptr, ptr, ptr, i32 } %1207, i32 %1208, 3
  %hash_coef_ptr.i.i10.i1314 = getelementptr i8, ptr %1202, i64 8
  %tbl_size_ptr.i.i11.i1315 = getelementptr i8, ptr %1202, i64 16
  %offset_tbl_ptr.i.i12.i1316 = getelementptr i8, ptr %1202, i64 40
  %hash_coef.i.i13.i1317 = load i64, ptr %hash_coef_ptr.i.i10.i1314, align 4
  %tbl_size.i.i14.i1318 = load i64, ptr %tbl_size_ptr.i.i11.i1315, align 4
  %offset_tbl.i.i15.i1319 = load ptr, ptr %offset_tbl_ptr.i.i12.i1316, align 8
  %product.i.i.i16.i1320 = mul i64 %hash_coef.i.i13.i1317, -5261542750394134544
  %shifted.i.i.i17.i1321 = lshr i64 %product.i.i.i16.i1320, 32
  %xored.i.i.i18.i1322 = xor i64 %shifted.i.i.i17.i1321, %product.i.i.i16.i1320
  %hash.i.i.i19.i1323 = and i64 %xored.i.i.i18.i1322, %tbl_size.i.i14.i1318
  %offset_ptr.i.i20.i1324 = getelementptr i32, ptr %offset_tbl.i.i15.i1319, i64 %hash.i.i.i19.i1323
  %offset.i.i21.i1325 = load i32, ptr %offset_ptr.i.i20.i1324, align 4
  %eq.i.i1326 = icmp eq i32 %1208, %offset.i.i21.i1325
  call void @llvm.assume(i1 %eq.i.i1326) #30
  %1210 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1211 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1202)
  %1212 = sext i32 %1208 to i64
  %1213 = getelementptr ptr, ptr %1202, i64 %1212
  %1214 = getelementptr i8, ptr %1213, i64 64
  %1215 = load ptr, ptr %1214, align 8
  %1216 = call ptr %1215({ ptr, ptr, ptr, i32 } %1209, ptr nonnull %2)
  %1217 = call i32 %1216({ ptr, ptr, ptr, i32 } %1209, { ptr, ptr, ptr, i32 } %1209, ptr nonnull %2)
  %1218 = add i32 %1217, -1
  %1219 = and i32 %1218, %1200
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1220 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1221 = load ptr, ptr %104, align 8
  %1222 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1221, 0
  %1223 = load ptr, ptr %105, align 8
  %1224 = insertvalue { ptr, ptr, ptr, i32 } %1222, ptr %1223, 1
  %1225 = load ptr, ptr %106, align 8
  %1226 = insertvalue { ptr, ptr, ptr, i32 } %1224, ptr %1225, 2
  %1227 = load i32, ptr %107, align 4
  %1228 = insertvalue { ptr, ptr, ptr, i32 } %1226, i32 %1227, 3
  %hash_coef_ptr.i.i202.i603 = getelementptr i8, ptr %1221, i64 8
  %tbl_size_ptr.i.i203.i604 = getelementptr i8, ptr %1221, i64 16
  %offset_tbl_ptr.i.i204.i605 = getelementptr i8, ptr %1221, i64 40
  %hash_coef.i.i205.i606 = load i64, ptr %hash_coef_ptr.i.i202.i603, align 4
  %tbl_size.i.i206.i607 = load i64, ptr %tbl_size_ptr.i.i203.i604, align 4
  %offset_tbl.i.i207.i608 = load ptr, ptr %offset_tbl_ptr.i.i204.i605, align 8
  %product.i.i.i208.i609 = mul i64 %hash_coef.i.i205.i606, -5261542750394134544
  %shifted.i.i.i209.i610 = lshr i64 %product.i.i.i208.i609, 32
  %xored.i.i.i210.i611 = xor i64 %shifted.i.i.i209.i610, %product.i.i.i208.i609
  %hash.i.i.i211.i612 = and i64 %xored.i.i.i210.i611, %tbl_size.i.i206.i607
  %offset_ptr.i.i212.i613 = getelementptr i32, ptr %offset_tbl.i.i207.i608, i64 %hash.i.i.i211.i612
  %offset.i.i213.i614 = load i32, ptr %offset_ptr.i.i212.i613, align 4
  %eq.i216.i615 = icmp eq i32 %1227, %offset.i.i213.i614
  call void @llvm.assume(i1 %eq.i216.i615) #30
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %1229 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %17)
  %1230 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1221)
  %1231 = sext i32 %1227 to i64
  %1232 = getelementptr ptr, ptr %1221, i64 %1231
  %1233 = getelementptr i8, ptr %1232, i64 120
  %1234 = load ptr, ptr %1233, align 8
  store ptr @i32_typ, ptr %18, align 8
  %1235 = call ptr %1234({ ptr, ptr, ptr, i32 } %1228, ptr nonnull %18)
  %1236 = call { ptr, i160 } %1235({ ptr, ptr, ptr, i32 } %1228, { ptr, ptr, ptr, i32 } %1228, ptr nonnull %17, i32 %1219)
  %.fca.0.extract87.i616 = extractvalue { ptr, i160 } %1236, 0
  %.sroa.3.0.insert.ext.i617 = zext i32 %offset.i.i260.i6661029 to i160
  %.sroa.3.0.insert.shift.i618 = shl nuw i160 %.sroa.3.0.insert.ext.i617, 128
  %.sroa.2.0.insert.ext.i619 = zext i64 %1110 to i160
  %.sroa.2.0.insert.shift.i620 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i619, 64
  %.sroa.2.0.insert.insert.i621 = or disjoint i160 %.sroa.2.0.insert.shift.i620, %.sroa.3.0.insert.shift.i618
  %.sroa.0.0.insert.ext.i622 = zext i64 %1109 to i160
  %.sroa.0.0.insert.insert.i623 = or disjoint i160 %.sroa.2.0.insert.insert.i621, %.sroa.0.0.insert.ext.i622
  %1237 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i623, 1
  %1238 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1239 = load ptr, ptr %104, align 8
  %1240 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1239, 0
  %1241 = load ptr, ptr %105, align 8
  %1242 = insertvalue { ptr, ptr, ptr, i32 } %1240, ptr %1241, 1
  %1243 = load ptr, ptr %106, align 8
  %1244 = insertvalue { ptr, ptr, ptr, i32 } %1242, ptr %1243, 2
  %1245 = load i32, ptr %107, align 4
  %1246 = insertvalue { ptr, ptr, ptr, i32 } %1244, i32 %1245, 3
  %hash_coef_ptr.i.i218.i628 = getelementptr i8, ptr %1239, i64 8
  %tbl_size_ptr.i.i219.i629 = getelementptr i8, ptr %1239, i64 16
  %offset_tbl_ptr.i.i220.i630 = getelementptr i8, ptr %1239, i64 40
  %hash_coef.i.i221.i631 = load i64, ptr %hash_coef_ptr.i.i218.i628, align 4
  %tbl_size.i.i222.i632 = load i64, ptr %tbl_size_ptr.i.i219.i629, align 4
  %offset_tbl.i.i223.i633 = load ptr, ptr %offset_tbl_ptr.i.i220.i630, align 8
  %product.i.i.i224.i634 = mul i64 %hash_coef.i.i221.i631, -5261542750394134544
  %shifted.i.i.i225.i635 = lshr i64 %product.i.i.i224.i634, 32
  %xored.i.i.i226.i636 = xor i64 %shifted.i.i.i225.i635, %product.i.i.i224.i634
  %hash.i.i.i227.i637 = and i64 %xored.i.i.i226.i636, %tbl_size.i.i222.i632
  %offset_ptr.i.i228.i638 = getelementptr i32, ptr %offset_tbl.i.i223.i633, i64 %hash.i.i.i227.i637
  %offset.i.i229.i639 = load i32, ptr %offset_ptr.i.i228.i638, align 4
  %eq.i232.i640 = icmp eq i32 %1245, %offset.i.i229.i639
  call void @llvm.assume(i1 %eq.i232.i640) #30
  %1247 = load ptr, ptr %result.i, align 8
  %1248 = load ptr, ptr %72, align 8
  %result.i233.i641 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1249 = getelementptr i8, ptr %result.i233.i641, i64 16
  store ptr %1248, ptr %1249, align 8
  %1250 = getelementptr i8, ptr %result.i233.i641, i64 8
  store ptr %1247, ptr %1250, align 8
  %1251 = getelementptr i8, ptr %result.i233.i641, i64 24
  store ptr null, ptr %1251, align 8
  %1252 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i641)
  store ptr @Entry, ptr %result.i233.i641, align 8
  store ptr @_parameterization_Ptri32, ptr %19, align 8
  store ptr %result.i233.i641, ptr %148, align 8
  %1253 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %19)
  %1254 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1239)
  %1255 = sext i32 %1245 to i64
  %1256 = getelementptr ptr, ptr %1239, i64 %1255
  %1257 = getelementptr i8, ptr %1256, i64 128
  %1258 = load ptr, ptr %1257, align 8
  store ptr @i32_typ, ptr %20, align 8
  store ptr @Entry, ptr %149, align 8
  %1259 = call ptr %1258({ ptr, ptr, ptr, i32 } %1246, ptr nonnull %20)
  call void %1259({ ptr, ptr, ptr, i32 } %1246, { ptr, ptr, ptr, i32 } %1246, ptr nonnull %19, i32 %1219, { ptr, i160 } %1237)
  %1260 = icmp ne ptr %.fca.0.extract87.i616, @nil_typ
  %1261 = icmp ne ptr %.fca.0.extract87.i616, null
  %.not138.i642 = and i1 %1260, %1261
  br i1 %.not138.i642, label %.cont.cont.i649, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit716.thread

.cont.cont.i649:                                  ; preds = %1182, %1120
  %.sink1037 = phi { ptr, i160 } [ %1156, %1120 ], [ %1236, %1182 ]
  %1262 = phi i32 [ 2, %1120 ], [ 1, %1182 ]
  %vptr.i248.sroa.speculated.i652 = phi ptr [ %.fca.0.extract112.i684, %1120 ], [ %.fca.0.extract87.i616, %1182 ]
  %.fca.1.extract89.i645 = extractvalue { ptr, i160 } %.sink1037, 1
  %.sroa.3407.sroa.4.0.extract.shift.i646 = lshr i160 %.fca.1.extract89.i645, 64
  %1263 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i646 to i64
  %1264 = insertelement <2 x i64> poison, i64 %1263, i64 0
  %1265 = trunc i160 %.fca.1.extract89.i645 to i64
  %1266 = insertelement <2 x i64> %1264, i64 %1265, i64 1
  %hash_coef_ptr.i.i249.i655 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i652, i64 8
  %tbl_size_ptr.i.i250.i656 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i652, i64 16
  %offset_tbl_ptr.i.i251.i657 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i652, i64 40
  %hash_coef.i.i252.i658 = load i64, ptr %hash_coef_ptr.i.i249.i655, align 4
  %tbl_size.i.i253.i659 = load i64, ptr %tbl_size_ptr.i.i250.i656, align 4
  %offset_tbl.i.i254.i660 = load ptr, ptr %offset_tbl_ptr.i.i251.i657, align 8
  %product.i.i.i255.i661 = mul i64 %hash_coef.i.i252.i658, 4015701072841558310
  %shifted.i.i.i256.i662 = lshr i64 %product.i.i.i255.i661, 32
  %xored.i.i.i257.i663 = xor i64 %shifted.i.i.i256.i662, %product.i.i.i255.i661
  %hash.i.i.i258.i664 = and i64 %xored.i.i.i257.i663, %tbl_size.i.i253.i659
  %offset_ptr.i.i259.i665 = getelementptr i32, ptr %offset_tbl.i.i254.i660, i64 %hash.i.i.i258.i664
  %offset.i.i260.i666 = load i32, ptr %offset_ptr.i.i259.i665, align 4
  %1267 = add nuw nsw i32 %.reg2mem193.0677.i598, 1
  %1268 = load i32, ptr %110, align 4
  %1269 = icmp slt i32 %1267, %1268
  br i1 %1269, label %1107, label %._crit_edge1.1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit716.thread: ; preds = %1120, %1182
  %1270 = phi ptr [ %21, %1182 ], [ %13, %1120 ]
  %1271 = phi ptr [ %22, %1182 ], [ %14, %1120 ]
  %1272 = phi ptr [ %23, %1182 ], [ %15, %1120 ]
  %1273 = phi ptr [ %.sroa.0.i560, %1182 ], [ %.sroa.0680.i558, %1120 ]
  %1274 = phi ptr [ %24, %1182 ], [ %16, %1120 ]
  %1275 = load i32, ptr %108, align 4
  store i32 %1275, ptr %1270, align 4
  store i32 1, ptr %1271, align 4
  %1276 = add i32 %1275, 1
  store i32 %1276, ptr %1272, align 4
  %1277 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1276, ptr %108, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1274, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1273, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i558)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i560)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.1.i:                                 ; preds = %.cont.cont.i649, %HashMap_resize_.exit557
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i558)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i560)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %8)
  %1278 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1279 = load ptr, ptr %89, align 8
  %1280 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1279, 0
  %1281 = load ptr, ptr %90, align 8
  %1282 = insertvalue { ptr, ptr, ptr, i32 } %1280, ptr %1281, 1
  %1283 = load ptr, ptr %91, align 8
  %1284 = insertvalue { ptr, ptr, ptr, i32 } %1282, ptr %1283, 2
  %1285 = load i32, ptr %92, align 4
  %1286 = insertvalue { ptr, ptr, ptr, i32 } %1284, i32 %1285, 3
  %hash_coef_ptr.i.i64.i734 = getelementptr i8, ptr %1279, i64 8
  %tbl_size_ptr.i.i65.i735 = getelementptr i8, ptr %1279, i64 16
  %offset_tbl_ptr.i.i66.i736 = getelementptr i8, ptr %1279, i64 40
  %hash_coef.i.i67.i737 = load i64, ptr %hash_coef_ptr.i.i64.i734, align 4
  %tbl_size.i.i68.i738 = load i64, ptr %tbl_size_ptr.i.i65.i735, align 4
  %offset_tbl.i.i69.i739 = load ptr, ptr %offset_tbl_ptr.i.i66.i736, align 8
  %product.i.i.i70.i740 = mul i64 %hash_coef.i.i67.i737, -5261542750394134544
  %shifted.i.i.i71.i741 = lshr i64 %product.i.i.i70.i740, 32
  %xored.i.i.i72.i742 = xor i64 %shifted.i.i.i71.i741, %product.i.i.i70.i740
  %hash.i.i.i73.i743 = and i64 %xored.i.i.i72.i742, %tbl_size.i.i68.i738
  %offset_ptr.i.i74.i744 = getelementptr i32, ptr %offset_tbl.i.i69.i739, i64 %hash.i.i.i73.i743
  %offset.i.i75.i745 = load i32, ptr %offset_ptr.i.i74.i744, align 4
  %eq.i.i746 = icmp eq i32 %1285, %offset.i.i75.i745
  call void @llvm.assume(i1 %eq.i.i746) #30
  %1287 = load ptr, ptr %104, align 8
  %1288 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1287, 0
  %1289 = load ptr, ptr %105, align 8
  %1290 = insertvalue { ptr, ptr, ptr, i32 } %1288, ptr %1289, 1
  %1291 = load ptr, ptr %106, align 8
  %1292 = insertvalue { ptr, ptr, ptr, i32 } %1290, ptr %1291, 2
  %1293 = load i32, ptr %107, align 4
  %1294 = insertvalue { ptr, ptr, ptr, i32 } %1292, i32 %1293, 3
  %hash_coef_ptr.i.i92.i751 = getelementptr i8, ptr %1287, i64 8
  %tbl_size_ptr.i.i93.i752 = getelementptr i8, ptr %1287, i64 16
  %offset_tbl_ptr.i.i94.i753 = getelementptr i8, ptr %1287, i64 40
  %hash_coef.i.i95.i754 = load i64, ptr %hash_coef_ptr.i.i92.i751, align 4
  %tbl_size.i.i96.i755 = load i64, ptr %tbl_size_ptr.i.i93.i752, align 4
  %offset_tbl.i.i97.i756 = load ptr, ptr %offset_tbl_ptr.i.i94.i753, align 8
  %product.i.i.i98.i757 = mul i64 %hash_coef.i.i95.i754, -5261542750394134544
  %shifted.i.i.i99.i758 = lshr i64 %product.i.i.i98.i757, 32
  %xored.i.i.i100.i759 = xor i64 %shifted.i.i.i99.i758, %product.i.i.i98.i757
  %hash.i.i.i101.i760 = and i64 %xored.i.i.i100.i759, %tbl_size.i.i96.i755
  %offset_ptr.i.i102.i761 = getelementptr i32, ptr %offset_tbl.i.i97.i756, i64 %hash.i.i.i101.i760
  %offset.i.i103.i762 = load i32, ptr %offset_ptr.i.i102.i761, align 4
  %eq.i106.i763 = icmp eq i32 %1293, %offset.i.i103.i762
  call void @llvm.assume(i1 %eq.i106.i763) #30
  %1295 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1296 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1279)
  %1297 = sext i32 %1285 to i64
  %1298 = getelementptr ptr, ptr %1279, i64 %1297
  %1299 = getelementptr i8, ptr %1298, i64 64
  %1300 = load ptr, ptr %1299, align 8
  %1301 = call ptr %1300({ ptr, ptr, ptr, i32 } %1286, ptr nonnull %2)
  %1302 = call i32 %1301({ ptr, ptr, ptr, i32 } %1286, { ptr, ptr, ptr, i32 } %1286, ptr nonnull %2)
  %1303 = shl i32 %1302, 1
  %1304 = load i32, ptr %108, align 4
  %1305 = load ptr, ptr %result.i, align 8
  %1306 = load ptr, ptr %72, align 8
  %1307 = sext i32 %1304 to i64
  %1308 = shl nsw i64 %1307, 5
  %result.i.i.i766 = call noalias ptr @bump_malloc_inner(i64 noundef %1308, ptr nonnull @current_ptr) #29
  %1309 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1310 = icmp sgt i32 %1302, 0
  br i1 %1310, label %.lr.ph434.i836, label %._crit_edge395.i780

.lr.ph434.i836:                                   ; preds = %._crit_edge1.1.i
  %invariant.gep.i779 = getelementptr i8, ptr %1279, i64 120
  %1311 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i839 = getelementptr ptr, ptr %invariant.gep.i779, i64 %1297
  br label %1312

1312:                                             ; preds = %1334, %.lr.ph434.i836
  %.reg2mem105.0432.i837 = phi i32 [ 0, %.lr.ph434.i836 ], [ %.reg2mem101.0.i842, %1334 ]
  %.reg2mem103.0431.i838 = phi i32 [ 0, %.lr.ph434.i836 ], [ %1335, %1334 ]
  store ptr @_parameterization_Ptri32, ptr %3, align 8
  %1313 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %3)
  %1314 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1279)
  %1315 = load ptr, ptr %gep.i839, align 8
  store ptr @i32_typ, ptr %4, align 8
  %1316 = call ptr %1315({ ptr, ptr, ptr, i32 } %1286, ptr nonnull %4)
  %1317 = call { ptr, i160 } %1316({ ptr, ptr, ptr, i32 } %1286, { ptr, ptr, ptr, i32 } %1286, ptr nonnull %3, i32 %.reg2mem103.0431.i838)
  %.fca.0.extract52.i840 = extractvalue { ptr, i160 } %1317, 0
  %1318 = icmp ne ptr %.fca.0.extract52.i840, @nil_typ
  %1319 = icmp ne ptr %.fca.0.extract52.i840, null
  %.not60.i841 = and i1 %1318, %1319
  br i1 %.not60.i841, label %1320, label %1334

1320:                                             ; preds = %1312
  %hash_coef_ptr.i.i137.i869 = getelementptr i8, ptr %.fca.0.extract52.i840, i64 8
  %tbl_size_ptr.i.i138.i870 = getelementptr i8, ptr %.fca.0.extract52.i840, i64 16
  %offset_tbl_ptr.i.i139.i871 = getelementptr i8, ptr %.fca.0.extract52.i840, i64 40
  %hash_coef.i.i140.i872 = load i64, ptr %hash_coef_ptr.i.i137.i869, align 4
  %tbl_size.i.i141.i873 = load i64, ptr %tbl_size_ptr.i.i138.i870, align 4
  %offset_tbl.i.i142.i874 = load ptr, ptr %offset_tbl_ptr.i.i139.i871, align 8
  %product.i.i.i143.i875 = mul i64 %hash_coef.i.i140.i872, 4015701072841558310
  %shifted.i.i.i144.i876 = lshr i64 %product.i.i.i143.i875, 32
  %xored.i.i.i145.i877 = xor i64 %shifted.i.i.i144.i876, %product.i.i.i143.i875
  %hash.i.i.i146.i878 = and i64 %xored.i.i.i145.i877, %tbl_size.i.i141.i873
  %offset_ptr.i.i147.i879 = getelementptr i32, ptr %offset_tbl.i.i142.i874, i64 %hash.i.i.i146.i878
  %offset.i.i148.i880 = load i32, ptr %offset_ptr.i.i147.i879, align 4
  %1321 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1322 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1323 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1324 = icmp slt i32 %.reg2mem105.0432.i837, %1304
  br i1 %1324, label %1325, label %._crit_edge.i881

1325:                                             ; preds = %1320
  %.fca.1.extract54.i882 = extractvalue { ptr, i160 } %1317, 1
  %.sroa.351.0.insert.ext.i883 = zext i32 %offset.i.i148.i880 to i160
  %.sroa.351.0.insert.shift.i884 = shl nuw i160 %.sroa.351.0.insert.ext.i883, 128
  %1326 = and i160 %.fca.1.extract54.i882, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i885 = or disjoint i160 %.sroa.351.0.insert.shift.i884, %1326
  %1327 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1328 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1329 = sext i32 %.reg2mem105.0432.i837 to i64
  %1330 = shl nsw i64 %1329, 5
  %1331 = getelementptr i8, ptr %result.i.i.i766, i64 %1330
  store ptr %.fca.0.extract52.i840, ptr %1331, align 8
  %1332 = getelementptr i8, ptr %1331, i64 8
  store i160 %.sroa.049.0.insert.insert.i885, ptr %1332, align 4
  br label %._crit_edge.i881

._crit_edge.i881:                                 ; preds = %1325, %1320
  %1333 = add i32 %.reg2mem105.0432.i837, 1
  br label %1334

1334:                                             ; preds = %._crit_edge.i881, %1312
  %.reg2mem101.0.i842 = phi i32 [ %1333, %._crit_edge.i881 ], [ %.reg2mem105.0432.i837, %1312 ]
  %1335 = add nuw nsw i32 %.reg2mem103.0431.i838, 1
  %1336 = icmp slt i32 %1335, %1302
  br i1 %1336, label %1312, label %.lr.ph.i843

.lr.ph.i843:                                      ; preds = %1334
  %invariant.gep396.i844 = getelementptr i8, ptr %1287, i64 120
  %1337 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1338 = sext i32 %1293 to i64
  %gep397.i847 = getelementptr ptr, ptr %invariant.gep396.i844, i64 %1338
  br label %1339

1339:                                             ; preds = %1361, %.lr.ph.i843
  %.reg2mem91.0394.i845 = phi i32 [ %.reg2mem101.0.i842, %.lr.ph.i843 ], [ %.reg2mem87.0.i850, %1361 ]
  %.reg2mem89.0393.i846 = phi i32 [ 0, %.lr.ph.i843 ], [ %1362, %1361 ]
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %1340 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %1341 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1287)
  %1342 = load ptr, ptr %gep397.i847, align 8
  store ptr @i32_typ, ptr %6, align 8
  %1343 = call ptr %1342({ ptr, ptr, ptr, i32 } %1294, ptr nonnull %6)
  %1344 = call { ptr, i160 } %1343({ ptr, ptr, ptr, i32 } %1294, { ptr, ptr, ptr, i32 } %1294, ptr nonnull %5, i32 %.reg2mem89.0393.i846)
  %.fca.0.extract42.i848 = extractvalue { ptr, i160 } %1344, 0
  %1345 = icmp ne ptr %.fca.0.extract42.i848, @nil_typ
  %1346 = icmp ne ptr %.fca.0.extract42.i848, null
  %.not62.i849 = and i1 %1345, %1346
  br i1 %.not62.i849, label %1347, label %1361

1347:                                             ; preds = %1339
  %hash_coef_ptr.i.i152.i851 = getelementptr i8, ptr %.fca.0.extract42.i848, i64 8
  %tbl_size_ptr.i.i153.i852 = getelementptr i8, ptr %.fca.0.extract42.i848, i64 16
  %offset_tbl_ptr.i.i154.i853 = getelementptr i8, ptr %.fca.0.extract42.i848, i64 40
  %hash_coef.i.i155.i854 = load i64, ptr %hash_coef_ptr.i.i152.i851, align 4
  %tbl_size.i.i156.i855 = load i64, ptr %tbl_size_ptr.i.i153.i852, align 4
  %offset_tbl.i.i157.i856 = load ptr, ptr %offset_tbl_ptr.i.i154.i853, align 8
  %product.i.i.i158.i857 = mul i64 %hash_coef.i.i155.i854, 4015701072841558310
  %shifted.i.i.i159.i858 = lshr i64 %product.i.i.i158.i857, 32
  %xored.i.i.i160.i859 = xor i64 %shifted.i.i.i159.i858, %product.i.i.i158.i857
  %hash.i.i.i161.i860 = and i64 %xored.i.i.i160.i859, %tbl_size.i.i156.i855
  %offset_ptr.i.i162.i861 = getelementptr i32, ptr %offset_tbl.i.i157.i856, i64 %hash.i.i.i161.i860
  %offset.i.i163.i862 = load i32, ptr %offset_ptr.i.i162.i861, align 4
  %1348 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1349 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1350 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1351 = icmp slt i32 %.reg2mem91.0394.i845, %1304
  br i1 %1351, label %1352, label %._crit_edge1.i863

1352:                                             ; preds = %1347
  %.fca.1.extract44.i864 = extractvalue { ptr, i160 } %1344, 1
  %.sroa.3.0.insert.ext.i865 = zext i32 %offset.i.i163.i862 to i160
  %.sroa.3.0.insert.shift.i866 = shl nuw i160 %.sroa.3.0.insert.ext.i865, 128
  %1353 = and i160 %.fca.1.extract44.i864, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i867 = or disjoint i160 %.sroa.3.0.insert.shift.i866, %1353
  %1354 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1355 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1356 = sext i32 %.reg2mem91.0394.i845 to i64
  %1357 = shl nsw i64 %1356, 5
  %1358 = getelementptr i8, ptr %result.i.i.i766, i64 %1357
  store ptr %.fca.0.extract42.i848, ptr %1358, align 8
  %1359 = getelementptr i8, ptr %1358, i64 8
  store i160 %.sroa.040.0.insert.insert.i867, ptr %1359, align 4
  br label %._crit_edge1.i863

._crit_edge1.i863:                                ; preds = %1352, %1347
  %1360 = add i32 %.reg2mem91.0394.i845, 1
  br label %1361

1361:                                             ; preds = %._crit_edge1.i863, %1339
  %.reg2mem87.0.i850 = phi i32 [ %1360, %._crit_edge1.i863 ], [ %.reg2mem91.0394.i845, %1339 ]
  %1362 = add nuw nsw i32 %.reg2mem89.0393.i846, 1
  %1363 = icmp slt i32 %1362, %1302
  br i1 %1363, label %1339, label %._crit_edge395.i780.loopexit

._crit_edge395.i780.loopexit:                     ; preds = %1361
  %.pre1076 = load ptr, ptr %result.i, align 8
  %.pre1077 = load ptr, ptr %72, align 8
  br label %._crit_edge395.i780

._crit_edge395.i780:                              ; preds = %._crit_edge395.i780.loopexit, %._crit_edge1.1.i
  %1364 = phi ptr [ %1306, %._crit_edge1.1.i ], [ %.pre1077, %._crit_edge395.i780.loopexit ]
  %1365 = phi ptr [ %1305, %._crit_edge1.1.i ], [ %.pre1076, %._crit_edge395.i780.loopexit ]
  %.reg2mem91.0.lcssa.i781 = phi i32 [ 0, %._crit_edge1.1.i ], [ %.reg2mem87.0.i850, %._crit_edge395.i780.loopexit ]
  %1366 = call i32 @llvm.smax.i32(i32 %1303, i32 16)
  %result.i166.i782 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1367 = getelementptr i8, ptr %result.i166.i782, i64 16
  store ptr @_parameterization_Nil, ptr %1367, align 8
  %result.i167.i783 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1368 = getelementptr i8, ptr %result.i167.i783, i64 16
  store ptr %1364, ptr %1368, align 8
  %1369 = getelementptr i8, ptr %result.i167.i783, i64 8
  store ptr %1365, ptr %1369, align 8
  %1370 = getelementptr i8, ptr %result.i167.i783, i64 24
  store ptr null, ptr %1370, align 8
  %1371 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i783)
  store ptr @Entry, ptr %result.i167.i783, align 8
  %1372 = getelementptr i8, ptr %result.i166.i782, i64 8
  store ptr %result.i167.i783, ptr %1372, align 8
  %1373 = getelementptr i8, ptr %result.i166.i782, i64 24
  store ptr null, ptr %1373, align 8
  %1374 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i782)
  store ptr @union_typ, ptr %result.i166.i782, align 8
  %result.i168.i784 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i782, ptr %result.i168.i784, align 8
  %1375 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i784)
  store ptr @Array, ptr %7, align 8
  store ptr %result.i168.i784, ptr %152, align 8
  store i32 9, ptr %153, align 8
  %1376 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %7)
  %1377 = getelementptr i8, ptr %result.i168.i784, i64 16
  store i32 %1366, ptr %1377, align 4
  %1378 = getelementptr i8, ptr %result.i168.i784, i64 20
  store i32 %1366, ptr %1378, align 4
  %1379 = zext nneg i32 %1366 to i64
  %1380 = shl nuw nsw i64 %1379, 5
  %result.i.i416.i785 = call noalias ptr @bump_malloc_inner(i64 noundef %1380, ptr nonnull @current_ptr) #29
  %1381 = getelementptr i8, ptr %result.i168.i784, i64 8
  store ptr %result.i.i416.i785, ptr %1381, align 8
  %1382 = load ptr, ptr %154, align 8
  store ptr @Array, ptr %89, align 8
  store ptr %result.i168.i784, ptr %90, align 8
  store ptr %1382, ptr %91, align 8
  store i32 9, ptr %92, align 4
  %result.i183.i798 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1383 = getelementptr i8, ptr %result.i183.i798, i64 16
  store ptr @_parameterization_Nil, ptr %1383, align 8
  %result.i184.i799 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1384 = getelementptr i8, ptr %result.i184.i799, i64 16
  store ptr %1364, ptr %1384, align 8
  %1385 = getelementptr i8, ptr %result.i184.i799, i64 8
  store ptr %1365, ptr %1385, align 8
  %1386 = getelementptr i8, ptr %result.i184.i799, i64 24
  store ptr null, ptr %1386, align 8
  %1387 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i799)
  store ptr @Entry, ptr %result.i184.i799, align 8
  %1388 = getelementptr i8, ptr %result.i183.i798, i64 8
  store ptr %result.i184.i799, ptr %1388, align 8
  %1389 = getelementptr i8, ptr %result.i183.i798, i64 24
  store ptr null, ptr %1389, align 8
  %1390 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i798)
  store ptr @union_typ, ptr %result.i183.i798, align 8
  %result.i185.i800 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i798, ptr %result.i185.i800, align 8
  %1391 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i800)
  store ptr @Array, ptr %8, align 8
  store ptr %result.i185.i800, ptr %155, align 8
  store i32 9, ptr %156, align 8
  %1392 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %8)
  %1393 = getelementptr i8, ptr %result.i185.i800, i64 16
  store i32 %1366, ptr %1393, align 4
  %1394 = getelementptr i8, ptr %result.i185.i800, i64 20
  store i32 %1366, ptr %1394, align 4
  %result.i.i430.i801 = call noalias ptr @bump_malloc_inner(i64 noundef %1380, ptr nonnull @current_ptr) #29
  %1395 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1396 = getelementptr i8, ptr %result.i185.i800, i64 8
  store ptr %result.i.i430.i801, ptr %1396, align 8
  %1397 = load ptr, ptr %157, align 8
  store ptr @Array, ptr %104, align 8
  store ptr %result.i185.i800, ptr %105, align 8
  store ptr %1397, ptr %106, align 8
  store i32 9, ptr %107, align 4
  %1398 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 0, ptr %108, align 4
  %1399 = icmp sgt i32 %.reg2mem91.0.lcssa.i781, 0
  br i1 %1399, label %.lr.ph400.i814, label %HashMap_resize_.exit887

.lr.ph400.i814:                                   ; preds = %._crit_edge395.i780
  %1400 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1401 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1402 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i816

._crit_edge2.i816:                                ; preds = %._crit_edge2.i816, %.lr.ph400.i814
  %.reg2mem77.0398.i817 = phi i32 [ 0, %.lr.ph400.i814 ], [ %1416, %._crit_edge2.i816 ]
  %1403 = zext nneg i32 %.reg2mem77.0398.i817 to i64
  %1404 = shl nuw nsw i64 %1403, 5
  %1405 = getelementptr i8, ptr %result.i.i.i766, i64 %1404
  %1406 = load ptr, ptr %1405, align 8
  %1407 = getelementptr i8, ptr %1405, i64 8
  %1408 = load i160, ptr %1407, align 4
  %.sroa.3362.8.extract.trunc.i820 = trunc i160 %1408 to i64
  %1409 = inttoptr i64 %.sroa.3362.8.extract.trunc.i820 to ptr
  %.sroa.5363.8.extract.shift.i821 = lshr i160 %1408, 64
  %.sroa.5363.8.extract.trunc.i822 = trunc i160 %.sroa.5363.8.extract.shift.i821 to i64
  %1410 = inttoptr i64 %.sroa.5363.8.extract.trunc.i822 to ptr
  %hash_coef_ptr.i.i201.i823 = getelementptr i8, ptr %1406, i64 8
  %tbl_size_ptr.i.i202.i824 = getelementptr i8, ptr %1406, i64 16
  %offset_tbl_ptr.i.i203.i825 = getelementptr i8, ptr %1406, i64 40
  %hash_coef.i.i232.i826 = load i64, ptr %hash_coef_ptr.i.i201.i823, align 4
  %tbl_size.i.i233.i827 = load i64, ptr %tbl_size_ptr.i.i202.i824, align 4
  %offset_tbl.i.i234.i828 = load ptr, ptr %offset_tbl_ptr.i.i203.i825, align 8
  %product.i.i.i235.i829 = mul i64 %hash_coef.i.i232.i826, 4015701072841558310
  %shifted.i.i.i236.i830 = lshr i64 %product.i.i.i235.i829, 32
  %xored.i.i.i237.i831 = xor i64 %shifted.i.i.i236.i830, %product.i.i.i235.i829
  %hash.i.i.i238.i832 = and i64 %xored.i.i.i237.i831, %tbl_size.i.i233.i827
  %offset_ptr.i.i239.i833 = getelementptr i32, ptr %offset_tbl.i.i234.i828, i64 %hash.i.i.i238.i832
  %offset.i.i240.i834 = load i32, ptr %offset_ptr.i.i239.i833, align 4
  %1411 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1406, 0
  %1412 = insertvalue { ptr, ptr, ptr, i32 } %1411, ptr %1409, 1
  %1413 = insertvalue { ptr, ptr, ptr, i32 } %1412, ptr %1410, 2
  %1414 = insertvalue { ptr, ptr, ptr, i32 } %1413, i32 %offset.i.i240.i834, 3
  %1415 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1414)
  %1416 = add nuw nsw i32 %.reg2mem77.0398.i817, 1
  %1417 = icmp slt i32 %1416, %.reg2mem91.0.lcssa.i781
  br i1 %1417, label %._crit_edge2.i816, label %HashMap_resize_.exit887

HashMap_resize_.exit887:                          ; preds = %._crit_edge2.i816, %._crit_edge395.i780
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %8)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit716.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %230, %426, %HashMap_resize_.exit887
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %59)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  %1418 = icmp slt i32 %158, %0
  br i1 %1418, label %._crit_edge, label %._crit_edge1

._crit_edge1:                                     ; preds = %HashMap_insert_keyK_valueV.exit
  %1419 = call i64 @clock()
  %1420 = add nsw i32 %0, -1
  %.sroa.017.0.insert.ext = zext nneg i32 %1420 to i160
  %1421 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.017.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %57)
  %1422 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1423 = load ptr, ptr %77, align 8
  %1424 = call i32 %1423({ ptr, i160 } %1421)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1425 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1426 = load ptr, ptr %89, align 8
  %1427 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1426, 0
  %1428 = load ptr, ptr %90, align 8
  %1429 = insertvalue { ptr, ptr, ptr, i32 } %1427, ptr %1428, 1
  %1430 = load ptr, ptr %91, align 8
  %1431 = insertvalue { ptr, ptr, ptr, i32 } %1429, ptr %1430, 2
  %1432 = load i32, ptr %92, align 4
  %1433 = insertvalue { ptr, ptr, ptr, i32 } %1431, i32 %1432, 3
  %hash_coef_ptr.i.i10.i920 = getelementptr i8, ptr %1426, i64 8
  %tbl_size_ptr.i.i11.i921 = getelementptr i8, ptr %1426, i64 16
  %offset_tbl_ptr.i.i12.i922 = getelementptr i8, ptr %1426, i64 40
  %hash_coef.i.i13.i923 = load i64, ptr %hash_coef_ptr.i.i10.i920, align 4
  %tbl_size.i.i14.i924 = load i64, ptr %tbl_size_ptr.i.i11.i921, align 4
  %offset_tbl.i.i15.i925 = load ptr, ptr %offset_tbl_ptr.i.i12.i922, align 8
  %product.i.i.i16.i926 = mul i64 %hash_coef.i.i13.i923, -5261542750394134544
  %shifted.i.i.i17.i927 = lshr i64 %product.i.i.i16.i926, 32
  %xored.i.i.i18.i928 = xor i64 %shifted.i.i.i17.i927, %product.i.i.i16.i926
  %hash.i.i.i19.i929 = and i64 %xored.i.i.i18.i928, %tbl_size.i.i14.i924
  %offset_ptr.i.i20.i930 = getelementptr i32, ptr %offset_tbl.i.i15.i925, i64 %hash.i.i.i19.i929
  %offset.i.i21.i931 = load i32, ptr %offset_ptr.i.i20.i930, align 4
  %eq.i.i932 = icmp eq i32 %1432, %offset.i.i21.i931
  call void @llvm.assume(i1 %eq.i.i932) #30
  %1434 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1435 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1426)
  %1436 = sext i32 %1432 to i64
  %1437 = getelementptr ptr, ptr %1426, i64 %1436
  %1438 = getelementptr i8, ptr %1437, i64 64
  %1439 = load ptr, ptr %1438, align 8
  %1440 = call ptr %1439({ ptr, ptr, ptr, i32 } %1433, ptr nonnull %2)
  %1441 = call i32 %1440({ ptr, ptr, ptr, i32 } %1433, { ptr, ptr, ptr, i32 } %1433, ptr nonnull %2)
  %1442 = add i32 %1441, -1
  %1443 = and i32 %1442, %1424
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1444 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1445 = load ptr, ptr %89, align 8
  %1446 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1445, 0
  %1447 = load ptr, ptr %90, align 8
  %1448 = insertvalue { ptr, ptr, ptr, i32 } %1446, ptr %1447, 1
  %1449 = load ptr, ptr %91, align 8
  %1450 = insertvalue { ptr, ptr, ptr, i32 } %1448, ptr %1449, 2
  %1451 = load i32, ptr %92, align 4
  %1452 = insertvalue { ptr, ptr, ptr, i32 } %1450, i32 %1451, 3
  %hash_coef_ptr.i.i130.i = getelementptr i8, ptr %1445, i64 8
  %tbl_size_ptr.i.i131.i = getelementptr i8, ptr %1445, i64 16
  %offset_tbl_ptr.i.i132.i = getelementptr i8, ptr %1445, i64 40
  %hash_coef.i.i133.i = load i64, ptr %hash_coef_ptr.i.i130.i, align 4
  %tbl_size.i.i134.i = load i64, ptr %tbl_size_ptr.i.i131.i, align 4
  %offset_tbl.i.i135.i = load ptr, ptr %offset_tbl_ptr.i.i132.i, align 8
  %product.i.i.i136.i = mul i64 %hash_coef.i.i133.i, -5261542750394134544
  %shifted.i.i.i137.i = lshr i64 %product.i.i.i136.i, 32
  %xored.i.i.i138.i = xor i64 %shifted.i.i.i137.i, %product.i.i.i136.i
  %hash.i.i.i139.i = and i64 %xored.i.i.i138.i, %tbl_size.i.i134.i
  %offset_ptr.i.i140.i = getelementptr i32, ptr %offset_tbl.i.i135.i, i64 %hash.i.i.i139.i
  %offset.i.i141.i = load i32, ptr %offset_ptr.i.i140.i, align 4
  %eq.i.i169 = icmp eq i32 %1451, %offset.i.i141.i
  call void @llvm.assume(i1 %eq.i.i169) #30
  store ptr @_parameterization_Ptri32, ptr %56, align 8
  %1453 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %56)
  %1454 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1445)
  %1455 = sext i32 %1451 to i64
  %1456 = getelementptr ptr, ptr %1445, i64 %1455
  %1457 = getelementptr i8, ptr %1456, i64 120
  %1458 = load ptr, ptr %1457, align 8
  store ptr @i32_typ, ptr %57, align 8
  %1459 = call ptr %1458({ ptr, ptr, ptr, i32 } %1452, ptr nonnull %57)
  %1460 = call { ptr, i160 } %1459({ ptr, ptr, ptr, i32 } %1452, { ptr, ptr, ptr, i32 } %1452, ptr nonnull %56, i32 %1443)
  %.fca.0.extract.i170 = extractvalue { ptr, i160 } %1460, 0
  %1461 = icmp ne ptr %.fca.0.extract.i170, @nil_typ
  %1462 = icmp ne ptr %.fca.0.extract.i170, null
  %.not126.i = and i1 %1461, %1462
  br i1 %.not126.i, label %1463, label %.critedge.i171

1463:                                             ; preds = %._crit_edge1
  %.fca.1.extract.i176 = extractvalue { ptr, i160 } %1460, 1
  %.sroa.5.8.extract.trunc.i = trunc i160 %.fca.1.extract.i176 to i64
  %1464 = inttoptr i64 %.sroa.5.8.extract.trunc.i to ptr
  %.sroa.9.8.extract.shift.i = lshr i160 %.fca.1.extract.i176, 64
  %.sroa.9.8.extract.trunc.i = trunc i160 %.sroa.9.8.extract.shift.i to i64
  %1465 = inttoptr i64 %.sroa.9.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i144.i = getelementptr i8, ptr %.fca.0.extract.i170, i64 8
  %tbl_size_ptr.i.i145.i = getelementptr i8, ptr %.fca.0.extract.i170, i64 16
  %offset_tbl_ptr.i.i146.i = getelementptr i8, ptr %.fca.0.extract.i170, i64 40
  %hash_coef.i.i147.i = load i64, ptr %hash_coef_ptr.i.i144.i, align 4
  %tbl_size.i.i148.i = load i64, ptr %tbl_size_ptr.i.i145.i, align 4
  %offset_tbl.i.i149.i = load ptr, ptr %offset_tbl_ptr.i.i146.i, align 8
  %product.i.i.i150.i = mul i64 %hash_coef.i.i147.i, 4015701072841558310
  %shifted.i.i.i151.i = lshr i64 %product.i.i.i150.i, 32
  %xored.i.i.i152.i = xor i64 %shifted.i.i.i151.i, %product.i.i.i150.i
  %hash.i.i.i153.i = and i64 %xored.i.i.i152.i, %tbl_size.i.i148.i
  %offset_ptr.i.i154.i = getelementptr i32, ptr %offset_tbl.i.i149.i, i64 %hash.i.i.i153.i
  %offset.i.i155.i = load i32, ptr %offset_ptr.i.i154.i, align 4
  %1466 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i170, 0
  %1467 = insertvalue { ptr, ptr, ptr, i32 } %1466, ptr %1464, 1
  %1468 = insertvalue { ptr, ptr, ptr, i32 } %1467, ptr %1465, 2
  %1469 = insertvalue { ptr, ptr, ptr, i32 } %1468, i32 %offset.i.i155.i, 3
  %1470 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1471 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1472 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i170)
  %1473 = sext i32 %offset.i.i155.i to i64
  %1474 = getelementptr ptr, ptr %.fca.0.extract.i170, i64 %1473
  %1475 = getelementptr i8, ptr %1474, i64 64
  %1476 = load ptr, ptr %1475, align 8
  %1477 = call ptr %1476({ ptr, ptr, ptr, i32 } %1469, ptr nonnull %2)
  %1478 = call i32 %1477({ ptr, ptr, ptr, i32 } %1469, { ptr, ptr, ptr, i32 } %1469, ptr nonnull %2)
  %1479 = icmp eq i32 %1478, %1424
  %1480 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1481 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1482 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i170)
  %1483 = getelementptr i8, ptr %1474, i64 48
  %1484 = load ptr, ptr %1483, align 8
  %1485 = call ptr %1484({ ptr, ptr, ptr, i32 } %1469, ptr nonnull %2)
  %1486 = call { ptr, i160 } %1485({ ptr, ptr, ptr, i32 } %1469, { ptr, ptr, ptr, i32 } %1469, ptr nonnull %2)
  %1487 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1488 = load ptr, ptr %78, align 8
  %1489 = call i1 %1488({ ptr, i160 } %1486, { ptr, i160 } %1421)
  %1490 = and i1 %1479, %1489
  br i1 %1490, label %HashMap_get_keyK.exit, label %.critedge.i171

.critedge.i171:                                   ; preds = %1463, %._crit_edge1
  %1491 = add i32 %1424, 2127912214
  %1492 = shl i32 %1424, 12
  %1493 = add i32 %1491, %1492
  %1494 = ashr i32 %1493, 19
  %1495 = xor i32 %1493, %1494
  %1496 = xor i32 %1495, -949894596
  %1497 = add i32 %1496, 374761393
  %1498 = shl i32 %1496, 5
  %1499 = add i32 %1497, %1498
  %1500 = add i32 %1499, -744332180
  %1501 = shl i32 %1499, 9
  %1502 = xor i32 %1500, %1501
  %1503 = add i32 %1502, -42973499
  %1504 = shl i32 %1502, 3
  %1505 = add i32 %1503, %1504
  %1506 = ashr i32 %1505, 16
  %1507 = xor i32 %1505, %1506
  %1508 = xor i32 %1507, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1509 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1510 = load ptr, ptr %104, align 8
  %1511 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1510, 0
  %1512 = load ptr, ptr %105, align 8
  %1513 = insertvalue { ptr, ptr, ptr, i32 } %1511, ptr %1512, 1
  %1514 = load ptr, ptr %106, align 8
  %1515 = insertvalue { ptr, ptr, ptr, i32 } %1513, ptr %1514, 2
  %1516 = load i32, ptr %107, align 4
  %1517 = insertvalue { ptr, ptr, ptr, i32 } %1515, i32 %1516, 3
  %hash_coef_ptr.i.i10.i951 = getelementptr i8, ptr %1510, i64 8
  %tbl_size_ptr.i.i11.i952 = getelementptr i8, ptr %1510, i64 16
  %offset_tbl_ptr.i.i12.i953 = getelementptr i8, ptr %1510, i64 40
  %hash_coef.i.i13.i954 = load i64, ptr %hash_coef_ptr.i.i10.i951, align 4
  %tbl_size.i.i14.i955 = load i64, ptr %tbl_size_ptr.i.i11.i952, align 4
  %offset_tbl.i.i15.i956 = load ptr, ptr %offset_tbl_ptr.i.i12.i953, align 8
  %product.i.i.i16.i957 = mul i64 %hash_coef.i.i13.i954, -5261542750394134544
  %shifted.i.i.i17.i958 = lshr i64 %product.i.i.i16.i957, 32
  %xored.i.i.i18.i959 = xor i64 %shifted.i.i.i17.i958, %product.i.i.i16.i957
  %hash.i.i.i19.i960 = and i64 %xored.i.i.i18.i959, %tbl_size.i.i14.i955
  %offset_ptr.i.i20.i961 = getelementptr i32, ptr %offset_tbl.i.i15.i956, i64 %hash.i.i.i19.i960
  %offset.i.i21.i962 = load i32, ptr %offset_ptr.i.i20.i961, align 4
  %eq.i.i963 = icmp eq i32 %1516, %offset.i.i21.i962
  call void @llvm.assume(i1 %eq.i.i963) #30
  %1518 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1519 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1510)
  %1520 = sext i32 %1516 to i64
  %1521 = getelementptr ptr, ptr %1510, i64 %1520
  %1522 = getelementptr i8, ptr %1521, i64 64
  %1523 = load ptr, ptr %1522, align 8
  %1524 = call ptr %1523({ ptr, ptr, ptr, i32 } %1517, ptr nonnull %2)
  %1525 = call i32 %1524({ ptr, ptr, ptr, i32 } %1517, { ptr, ptr, ptr, i32 } %1517, ptr nonnull %2)
  %1526 = add i32 %1525, -1
  %1527 = and i32 %1526, %1508
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1528 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1529 = load ptr, ptr %104, align 8
  %1530 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1529, 0
  %1531 = load ptr, ptr %105, align 8
  %1532 = insertvalue { ptr, ptr, ptr, i32 } %1530, ptr %1531, 1
  %1533 = load ptr, ptr %106, align 8
  %1534 = insertvalue { ptr, ptr, ptr, i32 } %1532, ptr %1533, 2
  %1535 = load i32, ptr %107, align 4
  %1536 = insertvalue { ptr, ptr, ptr, i32 } %1534, i32 %1535, 3
  %hash_coef_ptr.i.i158.i = getelementptr i8, ptr %1529, i64 8
  %tbl_size_ptr.i.i159.i = getelementptr i8, ptr %1529, i64 16
  %offset_tbl_ptr.i.i160.i = getelementptr i8, ptr %1529, i64 40
  %hash_coef.i.i161.i = load i64, ptr %hash_coef_ptr.i.i158.i, align 4
  %tbl_size.i.i162.i = load i64, ptr %tbl_size_ptr.i.i159.i, align 4
  %offset_tbl.i.i163.i = load ptr, ptr %offset_tbl_ptr.i.i160.i, align 8
  %product.i.i.i164.i = mul i64 %hash_coef.i.i161.i, -5261542750394134544
  %shifted.i.i.i165.i = lshr i64 %product.i.i.i164.i, 32
  %xored.i.i.i166.i = xor i64 %shifted.i.i.i165.i, %product.i.i.i164.i
  %hash.i.i.i167.i = and i64 %xored.i.i.i166.i, %tbl_size.i.i162.i
  %offset_ptr.i.i168.i = getelementptr i32, ptr %offset_tbl.i.i163.i, i64 %hash.i.i.i167.i
  %offset.i.i169.i = load i32, ptr %offset_ptr.i.i168.i, align 4
  %eq.i172.i = icmp eq i32 %1535, %offset.i.i169.i
  call void @llvm.assume(i1 %eq.i172.i) #30
  store ptr @_parameterization_Ptri32, ptr %54, align 8
  %1537 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %54)
  %1538 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1529)
  %1539 = sext i32 %1535 to i64
  %1540 = getelementptr ptr, ptr %1529, i64 %1539
  %1541 = getelementptr i8, ptr %1540, i64 120
  %1542 = load ptr, ptr %1541, align 8
  store ptr @i32_typ, ptr %55, align 8
  %1543 = call ptr %1542({ ptr, ptr, ptr, i32 } %1536, ptr nonnull %55)
  %1544 = call { ptr, i160 } %1543({ ptr, ptr, ptr, i32 } %1536, { ptr, ptr, ptr, i32 } %1536, ptr nonnull %54, i32 %1527)
  %.fca.0.extract57.i = extractvalue { ptr, i160 } %1544, 0
  %1545 = icmp ne ptr %.fca.0.extract57.i, @nil_typ
  %1546 = icmp ne ptr %.fca.0.extract57.i, null
  %.not128.i = and i1 %1545, %1546
  br i1 %.not128.i, label %1547, label %HashMap_get_keyK.exit.thread

1547:                                             ; preds = %.critedge.i171
  %.fca.1.extract59.i = extractvalue { ptr, i160 } %1544, 1
  %.sroa.6.8.extract.trunc.i = trunc i160 %.fca.1.extract59.i to i64
  %1548 = inttoptr i64 %.sroa.6.8.extract.trunc.i to ptr
  %.sroa.11.8.extract.shift.i = lshr i160 %.fca.1.extract59.i, 64
  %.sroa.11.8.extract.trunc.i = trunc i160 %.sroa.11.8.extract.shift.i to i64
  %1549 = inttoptr i64 %.sroa.11.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i174.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 8
  %tbl_size_ptr.i.i175.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 16
  %offset_tbl_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 40
  %hash_coef.i.i177.i = load i64, ptr %hash_coef_ptr.i.i174.i, align 4
  %tbl_size.i.i178.i = load i64, ptr %tbl_size_ptr.i.i175.i, align 4
  %offset_tbl.i.i179.i = load ptr, ptr %offset_tbl_ptr.i.i176.i, align 8
  %product.i.i.i180.i = mul i64 %hash_coef.i.i177.i, 4015701072841558310
  %shifted.i.i.i181.i = lshr i64 %product.i.i.i180.i, 32
  %xored.i.i.i182.i = xor i64 %shifted.i.i.i181.i, %product.i.i.i180.i
  %hash.i.i.i183.i = and i64 %xored.i.i.i182.i, %tbl_size.i.i178.i
  %offset_ptr.i.i184.i = getelementptr i32, ptr %offset_tbl.i.i179.i, i64 %hash.i.i.i183.i
  %offset.i.i185.i = load i32, ptr %offset_ptr.i.i184.i, align 4
  %1550 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i, 0
  %1551 = insertvalue { ptr, ptr, ptr, i32 } %1550, ptr %1548, 1
  %1552 = insertvalue { ptr, ptr, ptr, i32 } %1551, ptr %1549, 2
  %1553 = insertvalue { ptr, ptr, ptr, i32 } %1552, i32 %offset.i.i185.i, 3
  %1554 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1555 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1556 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %1557 = sext i32 %offset.i.i185.i to i64
  %1558 = getelementptr ptr, ptr %.fca.0.extract57.i, i64 %1557
  %1559 = getelementptr i8, ptr %1558, i64 64
  %1560 = load ptr, ptr %1559, align 8
  %1561 = call ptr %1560({ ptr, ptr, ptr, i32 } %1553, ptr nonnull %2)
  %1562 = call i32 %1561({ ptr, ptr, ptr, i32 } %1553, { ptr, ptr, ptr, i32 } %1553, ptr nonnull %2)
  %1563 = icmp eq i32 %1562, %1424
  %1564 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1565 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1566 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %1567 = getelementptr i8, ptr %1558, i64 48
  %1568 = load ptr, ptr %1567, align 8
  %1569 = call ptr %1568({ ptr, ptr, ptr, i32 } %1553, ptr nonnull %2)
  %1570 = call { ptr, i160 } %1569({ ptr, ptr, ptr, i32 } %1553, { ptr, ptr, ptr, i32 } %1553, ptr nonnull %2)
  %1571 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1572 = load ptr, ptr %78, align 8
  %1573 = call i1 %1572({ ptr, i160 } %1570, { ptr, i160 } %1421)
  %1574 = and i1 %1563, %1573
  br i1 %1574, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %1547, %.critedge.i171
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %57)
  br label %1586

HashMap_get_keyK.exit:                            ; preds = %1463, %1547
  %.pre-phi313.i = phi i64 [ %1473, %1463 ], [ %1557, %1547 ]
  %.pre-phi312.i = phi { ptr, ptr, ptr, i32 } [ %1469, %1463 ], [ %1553, %1547 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i = phi ptr [ %.fca.0.extract.i170, %1463 ], [ %.fca.0.extract57.i, %1547 ]
  %.reg2mem59.0.sroa.phi120289.i = phi ptr [ %.sroa.1.i, %1463 ], [ %.sroa.2124.i, %1547 ]
  %.reg2mem59.0.sroa.phi117288.i = phi ptr [ %.sroa.0271.i, %1463 ], [ %.sroa.0123.i, %1547 ]
  %.reg2mem57.0.sroa.phi94287.i = phi ptr [ %.sroa.2.i, %1463 ], [ %.sroa.2116.i, %1547 ]
  %.reg2mem57.0.sroa.phi91286.i = phi ptr [ %.sroa.0.i, %1463 ], [ %.sroa.0115.i, %1547 ]
  %1575 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1576 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1577 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i)
  %1578 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i, i64 %.pre-phi313.i
  %1579 = getelementptr i8, ptr %1578, i64 56
  %1580 = load ptr, ptr %1579, align 8
  %1581 = call ptr %1580({ ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %1582 = call { ptr, i160 } %1581({ ptr, ptr, ptr, i32 } %.pre-phi312.i, { ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %.fca.0.extract97.i = extractvalue { ptr, i160 } %1582, 0
  store ptr %.fca.0.extract97.i, ptr %.reg2mem59.0.sroa.phi117288.i, align 8
  %.fca.1.extract99.i = extractvalue { ptr, i160 } %1582, 1
  store i160 %.fca.1.extract99.i, ptr %.reg2mem59.0.sroa.phi120289.i, align 8
  store ptr %.fca.0.extract97.i, ptr %.reg2mem57.0.sroa.phi91286.i, align 8
  store i160 %.fca.1.extract99.i, ptr %.reg2mem57.0.sroa.phi94287.i, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %57)
  %1583 = icmp ne ptr %.fca.0.extract97.i, @nil_typ
  %1584 = icmp ne ptr %.fca.0.extract97.i, null
  %.not27 = and i1 %1583, %1584
  br i1 %.not27, label %1585, label %1586

1585:                                             ; preds = %HashMap_get_keyK.exit
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract99.i to i32
  %.not = icmp eq i32 %0, %.sroa.2.8.extract.trunc
  br label %1586

1586:                                             ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit, %1585
  %.reg2mem44.0 = phi i1 [ %.not, %1585 ], [ false, %HashMap_get_keyK.exit ], [ false, %HashMap_get_keyK.exit.thread ]
  %1587 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1588 = load i32, ptr %108, align 4
  %1589 = icmp eq i32 %1588, %0
  %1590 = select i1 %1589, i1 %.reg2mem44.0, i1 false
  %1591 = freeze i1 %1590
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

1592:                                             ; preds = %1
  %1593 = call i64 @clock()
  %1594 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit: ; preds = %1586, %1592
  %1595 = phi i64 [ %1419, %1586 ], [ %1593, %1592 ]
  %.reg2mem40.0.in = phi i1 [ %1591, %1586 ], [ true, %1592 ]
  %result.i36 = call noalias dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nonnull @current_ptr) #29
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i36, align 32
  %result.i37 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %1596 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i37, 1
  %1597 = insertvalue { ptr, ptr, ptr, i32 } %1596, ptr undef, 2
  %1598 = insertvalue { ptr, ptr, ptr, i32 } %1597, i32 9, 3
  store ptr %result.i36, ptr %result.i37, align 8
  %1599 = getelementptr i8, ptr %result.i37, i64 8
  store i32 17, ptr %1599, align 4
  %1600 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1601 = getelementptr i8, ptr %result.i37, i64 12
  store i32 18, ptr %1601, align 4
  %1602 = sub i64 %1595, %111
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %1598, i32 %0, i64 %1602)
  %result.i38 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nonnull @current_ptr) #29
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i38, align 32
  %result.i39 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %1603 = getelementptr inbounds i8, ptr %69, i64 8
  %1604 = getelementptr inbounds i8, ptr %69, i64 24
  store ptr @String, ptr %69, align 8
  store ptr %result.i39, ptr %1603, align 8
  store i32 9, ptr %1604, align 8
  %1605 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %69)
  store ptr %result.i38, ptr %result.i39, align 8
  %1606 = getelementptr i8, ptr %result.i39, i64 8
  store i32 18, ptr %1606, align 4
  %1607 = getelementptr i8, ptr %result.i39, i64 12
  store i32 19, ptr %1607, align 4
  %1608 = load i160, ptr %1603, align 8
  %1609 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i = trunc i160 %1608 to i64
  %1610 = inttoptr i64 %.sroa.3.8.extract.trunc.i to ptr
  %1611 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1612 = getelementptr i8, ptr %1610, i64 8
  %1613 = load i32, ptr %1612, align 4
  %1614 = add i32 %1613, 1
  %1615 = sext i32 %1614 to i64
  %result.i.i978 = call noalias ptr @bump_malloc_inner(i64 noundef %1615, ptr nonnull @current_ptr) #29
  %1616 = load i32, ptr %1612, align 4
  %1617 = icmp sgt i32 %1616, 0
  br i1 %1617, label %.lr.ph.i979, label %String_c_string_.exit

.lr.ph.i979:                                      ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %1618 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1619 = load ptr, ptr %1610, align 8
  %1620 = zext nneg i32 %1616 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i978, ptr align 1 %1619, i64 %1620, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %.lr.ph.i979, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %1621 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1622 = sext i32 %1616 to i64
  %1623 = getelementptr i8, ptr %result.i.i978, i64 %1622
  store i8 0, ptr %1623, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i978)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i40 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nonnull @current_ptr) #29
  %spec.select = select i1 %.reg2mem40.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %1624 = select i1 %.reg2mem40.0.in, ptr %70, ptr %71
  store <4 x i8> %spec.select, ptr %result.i40, align 4
  %result.i61 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem40.0.in, ptr %70, ptr %71
  %.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  %.sroa.sel1004.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem40.0.in, ptr %70, ptr %71
  %.sroa.sel1004.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.sroa.sel1004.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 24
  store ptr @String, ptr %1624, align 8
  store ptr %result.i61, ptr %.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store i32 9, ptr %.sroa.sel1004.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1625 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %1624)
  store ptr %result.i40, ptr %result.i61, align 8
  %1626 = getelementptr i8, ptr %result.i61, i64 8
  store i32 4, ptr %1626, align 4
  %1627 = getelementptr i8, ptr %result.i61, i64 12
  store i32 5, ptr %1627, align 4
  %1628 = load i160, ptr %.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1629 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i226 = trunc i160 %1628 to i64
  %1630 = inttoptr i64 %.sroa.3.8.extract.trunc.i226 to ptr
  %1631 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1632 = getelementptr i8, ptr %1630, i64 8
  %1633 = load i32, ptr %1632, align 4
  %1634 = add i32 %1633, 1
  %1635 = sext i32 %1634 to i64
  %result.i.i995 = call noalias ptr @bump_malloc_inner(i64 noundef %1635, ptr nonnull @current_ptr) #29
  %1636 = load i32, ptr %1632, align 4
  %1637 = icmp sgt i32 %1636, 0
  br i1 %1637, label %.lr.ph.i996, label %String_c_string_.exit1000

.lr.ph.i996:                                      ; preds = %String_c_string_.exit
  %1638 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1639 = load ptr, ptr %1630, align 8
  %1640 = zext nneg i32 %1636 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i995, ptr align 1 %1639, i64 %1640, i1 false)
  br label %String_c_string_.exit1000

String_c_string_.exit1000:                        ; preds = %.lr.ph.i996, %String_c_string_.exit
  %1641 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1642 = sext i32 %1636 to i64
  %1643 = getelementptr i8, ptr %result.i.i995, i64 %1642
  store i8 0, ptr %1643, align 1
  %puts.i242 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i995)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #2

declare i64 @clock() local_unnamed_addr

define linkonce_odr { i64, i64 } @_size_bool_typ(ptr %0) {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

define linkonce_odr { ptr, i160 } @_box_bool_typ(ptr %0, ptr %1) {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

define linkonce_odr void @_unbox_bool_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

define void @benchmark_insert_random(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %.sroa.0680.i2039 = alloca ptr, align 8
  %16 = alloca i64, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [2 x ptr], align 8
  %20 = alloca { ptr, ptr }, align 8
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %.sroa.0.i2041 = alloca ptr, align 8
  %24 = alloca i64, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  %30 = alloca { ptr, ptr, ptr, i32 }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [2 x ptr], align 8
  %34 = alloca { ptr, ptr }, align 8
  %35 = alloca i32, align 4
  %36 = alloca i32, align 4
  %37 = alloca i32, align 4
  %.sroa.0680.i1724 = alloca ptr, align 8
  %38 = alloca i64, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [2 x ptr], align 8
  %42 = alloca { ptr, ptr }, align 8
  %43 = alloca i32, align 4
  %44 = alloca i32, align 4
  %45 = alloca i32, align 4
  %.sroa.0.i1725 = alloca ptr, align 8
  %46 = alloca i64, align 8
  %47 = alloca { ptr, ptr, ptr, i32 }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = alloca { ptr, ptr, ptr, i32 }, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca { ptr, ptr, ptr, i32 }, align 8
  %59 = alloca { ptr, ptr, ptr, i32 }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [2 x ptr], align 8
  %63 = alloca { ptr, ptr }, align 8
  %64 = alloca i32, align 4
  %65 = alloca i32, align 4
  %66 = alloca i32, align 4
  %.sroa.0680.i1053 = alloca ptr, align 8
  %67 = alloca i64, align 8
  %68 = alloca [1 x ptr], align 8
  %69 = alloca { ptr }, align 8
  %70 = alloca [2 x ptr], align 8
  %71 = alloca { ptr, ptr }, align 8
  %72 = alloca i32, align 4
  %73 = alloca i32, align 4
  %74 = alloca i32, align 4
  %.sroa.0.i1055 = alloca ptr, align 8
  %75 = alloca i64, align 8
  %76 = alloca [1 x ptr], align 8
  %77 = alloca { ptr }, align 8
  %78 = alloca [1 x ptr], align 8
  %79 = alloca { ptr }, align 8
  %80 = alloca { ptr, ptr, ptr, i32 }, align 8
  %81 = alloca { ptr, ptr, ptr, i32 }, align 8
  %82 = alloca [1 x ptr], align 8
  %83 = alloca { ptr }, align 8
  %84 = alloca [2 x ptr], align 8
  %85 = alloca { ptr, ptr }, align 8
  %86 = alloca i32, align 4
  %87 = alloca i32, align 4
  %88 = alloca i32, align 4
  %.sroa.0680.i = alloca ptr, align 8
  %89 = alloca i64, align 8
  %90 = alloca [1 x ptr], align 8
  %91 = alloca { ptr }, align 8
  %92 = alloca [2 x ptr], align 8
  %93 = alloca { ptr, ptr }, align 8
  %94 = alloca i32, align 4
  %95 = alloca i32, align 4
  %96 = alloca i32, align 4
  %.sroa.0.i845 = alloca ptr, align 8
  %97 = alloca i64, align 8
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  %99 = alloca [1 x ptr], align 8
  %100 = alloca { ptr }, align 8
  %101 = alloca [1 x ptr], align 8
  %102 = alloca { ptr }, align 8
  %103 = alloca { ptr, ptr, ptr, i32 }, align 8
  %104 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.sroa.0271.i = alloca ptr, align 8
  %.sroa.1.i = alloca i160, align 8
  %.sroa.0.i = alloca ptr, align 8
  %.sroa.2.i = alloca i160, align 8
  %105 = alloca [1 x ptr], align 8
  %106 = alloca { ptr }, align 8
  %.sroa.0123.i = alloca ptr, align 8
  %.sroa.2124.i = alloca i160, align 8
  %.sroa.0115.i = alloca ptr, align 8
  %.sroa.2116.i = alloca i160, align 8
  %107 = alloca [1 x ptr], align 8
  %108 = alloca { ptr }, align 8
  %109 = alloca { ptr, ptr, ptr, i32 }, align 8
  %110 = alloca [2 x ptr], align 8
  %111 = alloca { ptr, ptr }, align 8
  %112 = alloca [1 x ptr], align 8
  %113 = alloca { ptr }, align 8
  %114 = alloca { ptr, ptr, ptr, i32 }, align 8
  %115 = alloca [2 x ptr], align 8
  %116 = alloca { ptr, ptr }, align 8
  %117 = alloca { ptr, ptr, ptr, i32 }, align 8
  %118 = alloca [1 x ptr], align 8
  %119 = alloca { ptr }, align 8
  %120 = alloca { ptr, ptr, ptr, i32 }, align 8
  %121 = alloca [2 x ptr], align 8
  %122 = alloca { ptr, ptr }, align 8
  %123 = alloca [1 x ptr], align 8
  %124 = alloca { ptr }, align 8
  %125 = alloca { ptr, ptr, ptr, i32 }, align 8
  %126 = alloca [2 x ptr], align 8
  %127 = alloca { ptr, ptr }, align 8
  %128 = alloca { ptr, ptr, ptr, i32 }, align 8
  %129 = alloca [1 x ptr], align 8
  %130 = alloca { ptr }, align 8
  %oldProtect.i94 = alloca i32, align 4
  %oldProtect.i90 = alloca i32, align 4
  %oldProtect.i55 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.039.sroa.0 = alloca i8, align 8
  %131 = alloca { ptr, ptr, ptr, i32 }, align 8
  %132 = alloca { ptr, ptr, ptr, i32 }, align 8
  %133 = alloca { ptr, ptr, ptr, i32 }, align 8
  %134 = alloca { ptr, ptr, ptr, i32 }, align 8
  %135 = alloca { ptr, ptr, ptr, i32 }, align 8
  %result.i = tail call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i, align 8
  %136 = getelementptr i8, ptr %result.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %136, align 8
  %137 = getelementptr i8, ptr %result.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %137, align 8
  %138 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i)
  %result.i52 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i53 = call i32 @VirtualProtect(ptr %result.i52, i64 16, i32 64, ptr nonnull %oldProtect.i) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr %result.i52, ptr nonnull @hozfwknbhb, ptr nonnull @i32_hasher)
  %ret.i = call ptr @llvm.adjust.trampoline(ptr readonly %result.i52) #31
  %139 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i52)
  %result.i54 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i55)
  %result.i56 = call i32 @VirtualProtect(ptr %result.i54, i64 16, i32 64, ptr nonnull %oldProtect.i55) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i55)
  call void @llvm.init.trampoline(ptr %result.i54, ptr nonnull @upwpmvgqgw, ptr nonnull @i32_eq)
  %ret.i57 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i54) #31
  %140 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i54)
  %141 = getelementptr i8, ptr %result.i, i64 96
  store ptr %ret.i, ptr %141, align 8
  %142 = getelementptr i8, ptr %result.i, i64 104
  store ptr %ret.i57, ptr %142, align 8
  %result.i.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %143 = getelementptr i8, ptr %result.i.i, i64 16
  store ptr @_parameterization_Nil, ptr %143, align 8
  %result.i4.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %144 = getelementptr i8, ptr %result.i4.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %144, align 8
  %145 = getelementptr i8, ptr %result.i4.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %145, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i)
  store ptr @Entry, ptr %result.i4.i, align 8
  %147 = getelementptr i8, ptr %result.i.i, i64 8
  store ptr %result.i4.i, ptr %147, align 8
  %148 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i)
  store ptr @union_typ, ptr %result.i.i, align 8
  %result.i5.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i, ptr %result.i5.i, align 8
  %149 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i)
  %150 = getelementptr i8, ptr %result.i5.i, i64 16
  store i32 8, ptr %150, align 4
  %151 = getelementptr i8, ptr %result.i5.i, i64 20
  store i32 8, ptr %151, align 4
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %152 = getelementptr i8, ptr %result.i5.i, i64 8
  store ptr %result.i.i.i, ptr %152, align 8
  %153 = getelementptr i8, ptr %result.i, i64 24
  store ptr @Array, ptr %153, align 8
  %154 = getelementptr i8, ptr %result.i, i64 32
  store ptr %result.i5.i, ptr %154, align 8
  %155 = getelementptr i8, ptr %result.i, i64 48
  store i32 9, ptr %155, align 4
  %result.i20.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %156 = getelementptr i8, ptr %result.i20.i, i64 16
  store ptr @_parameterization_Nil, ptr %156, align 8
  %result.i21.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %157 = getelementptr i8, ptr %result.i21.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %157, align 8
  %158 = getelementptr i8, ptr %result.i21.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %158, align 8
  %159 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i)
  store ptr @Entry, ptr %result.i21.i, align 8
  %160 = getelementptr i8, ptr %result.i20.i, i64 8
  store ptr %result.i21.i, ptr %160, align 8
  %161 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i)
  store ptr @union_typ, ptr %result.i20.i, align 8
  %result.i22.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i, ptr %result.i22.i, align 8
  %162 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i)
  %163 = getelementptr i8, ptr %result.i22.i, i64 16
  store i32 8, ptr %163, align 4
  %164 = getelementptr i8, ptr %result.i22.i, i64 20
  store i32 8, ptr %164, align 4
  %result.i.i97.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %165 = getelementptr i8, ptr %result.i22.i, i64 8
  store ptr %result.i.i97.i, ptr %165, align 8
  %166 = getelementptr i8, ptr %result.i, i64 56
  store ptr @Array, ptr %166, align 8
  %167 = getelementptr i8, ptr %result.i, i64 64
  store ptr %result.i22.i, ptr %167, align 8
  %168 = getelementptr i8, ptr %result.i, i64 80
  store i32 9, ptr %168, align 4
  %169 = getelementptr i8, ptr %result.i, i64 112
  store i32 100, ptr %169, align 4
  %result.i58 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  %170 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  store i32 123, ptr %result.i58, align 4
  %result.i73 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i73, align 8
  %171 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i73)
  %172 = getelementptr i8, ptr %result.i73, i64 20
  store i32 %0, ptr %172, align 4
  %173 = sext i32 %0 to i64
  %174 = shl nsw i64 %173, 5
  %result.i.i257 = call noalias ptr @bump_malloc_inner(i64 noundef %174, ptr nonnull @current_ptr) #29
  %175 = getelementptr i8, ptr %result.i73, i64 8
  store ptr %result.i.i257, ptr %175, align 8
  %result.i88 = call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i88, align 8
  %176 = getelementptr i8, ptr %result.i88, i64 8
  store ptr @_parameterization_Ptri1, ptr %176, align 8
  %177 = getelementptr i8, ptr %result.i88, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %177, align 8
  %178 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i88)
  %result.i89 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i90)
  %result.i91 = call i32 @VirtualProtect(ptr %result.i89, i64 16, i32 64, ptr nonnull %oldProtect.i90) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i90)
  call void @llvm.init.trampoline(ptr %result.i89, ptr nonnull @czvtrjryuh, ptr nonnull @i32_hasher)
  %ret.i92 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i89) #31
  %179 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i89)
  %result.i93 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i94)
  %result.i95 = call i32 @VirtualProtect(ptr %result.i93, i64 16, i32 64, ptr nonnull %oldProtect.i94) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i94)
  call void @llvm.init.trampoline(ptr %result.i93, ptr nonnull @cfyycnytdr, ptr nonnull @i32_eq)
  %ret.i96 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i93) #31
  %180 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i93)
  %181 = getelementptr i8, ptr %result.i88, i64 96
  store ptr %ret.i92, ptr %181, align 8
  %182 = getelementptr i8, ptr %result.i88, i64 104
  store ptr %ret.i96, ptr %182, align 8
  %result.i.i368 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %183 = getelementptr i8, ptr %result.i.i368, i64 16
  store ptr @_parameterization_Nil, ptr %183, align 8
  %result.i4.i369 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %184 = getelementptr i8, ptr %result.i4.i369, i64 16
  store ptr @_parameterization_Ptri1, ptr %184, align 8
  %185 = getelementptr i8, ptr %result.i4.i369, i64 8
  store ptr @_parameterization_Ptri32, ptr %185, align 8
  %186 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i369)
  store ptr @Entry, ptr %result.i4.i369, align 8
  %187 = getelementptr i8, ptr %result.i.i368, i64 8
  store ptr %result.i4.i369, ptr %187, align 8
  %188 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i368)
  store ptr @union_typ, ptr %result.i.i368, align 8
  %result.i5.i370 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i368, ptr %result.i5.i370, align 8
  %189 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i370)
  %190 = getelementptr i8, ptr %result.i5.i370, i64 16
  store i32 8, ptr %190, align 4
  %191 = getelementptr i8, ptr %result.i5.i370, i64 20
  store i32 8, ptr %191, align 4
  %result.i.i.i371 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %192 = getelementptr i8, ptr %result.i5.i370, i64 8
  store ptr %result.i.i.i371, ptr %192, align 8
  %193 = getelementptr i8, ptr %result.i88, i64 24
  store ptr @Array, ptr %193, align 8
  %194 = getelementptr i8, ptr %result.i88, i64 32
  store ptr %result.i5.i370, ptr %194, align 8
  %195 = getelementptr i8, ptr %result.i88, i64 40
  %196 = getelementptr i8, ptr %result.i88, i64 48
  store i32 9, ptr %196, align 4
  %197 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i20.i372 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %198 = getelementptr i8, ptr %result.i20.i372, i64 16
  store ptr @_parameterization_Nil, ptr %198, align 8
  %result.i21.i373 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %199 = getelementptr i8, ptr %result.i21.i373, i64 16
  store ptr @_parameterization_Ptri1, ptr %199, align 8
  %200 = getelementptr i8, ptr %result.i21.i373, i64 8
  store ptr @_parameterization_Ptri32, ptr %200, align 8
  %201 = getelementptr i8, ptr %result.i21.i373, i64 24
  store ptr null, ptr %201, align 8
  %202 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i373)
  store ptr @Entry, ptr %result.i21.i373, align 8
  %203 = getelementptr i8, ptr %result.i20.i372, i64 8
  store ptr %result.i21.i373, ptr %203, align 8
  %204 = getelementptr i8, ptr %result.i20.i372, i64 24
  store ptr null, ptr %204, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i372)
  store ptr @union_typ, ptr %result.i20.i372, align 8
  %result.i22.i374 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i372, ptr %result.i22.i374, align 8
  %206 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i374)
  %207 = getelementptr i8, ptr %result.i22.i374, i64 16
  store i32 8, ptr %207, align 4
  %208 = getelementptr i8, ptr %result.i22.i374, i64 20
  store i32 8, ptr %208, align 4
  %result.i.i97.i375 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %209 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %210 = getelementptr i8, ptr %result.i22.i374, i64 8
  store ptr %result.i.i97.i375, ptr %210, align 8
  %211 = getelementptr i8, ptr %result.i88, i64 56
  store ptr @Array, ptr %211, align 8
  %212 = getelementptr i8, ptr %result.i88, i64 64
  store ptr %result.i22.i374, ptr %212, align 8
  %213 = getelementptr i8, ptr %result.i88, i64 72
  %214 = getelementptr i8, ptr %result.i88, i64 80
  store i32 9, ptr %214, align 4
  %215 = getelementptr i8, ptr %result.i88, i64 88
  store i32 0, ptr %215, align 4
  %216 = getelementptr i8, ptr %result.i88, i64 112
  store i32 100, ptr %216, align 4
  %217 = icmp sgt i32 %0, 0
  br i1 %217, label %.lr.ph, label %._crit_edge240.thread

._crit_edge240.thread:                            ; preds = %1
  %218 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %219 = call i64 @clock()
  %220 = call i64 @clock()
  %221 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %222 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %223 = getelementptr i8, ptr %result.i, i64 88
  %224 = load i32, ptr %223, align 4
  %225 = icmp eq i32 %224, 0
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

.lr.ph:                                           ; preds = %1
  %226 = add nsw i32 %0, -1
  %227 = getelementptr inbounds i8, ptr %128, i64 8
  %228 = getelementptr inbounds i8, ptr %128, i64 24
  %229 = getelementptr inbounds i8, ptr %128, i64 16
  %230 = getelementptr inbounds i8, ptr %125, i64 8
  %231 = getelementptr inbounds i8, ptr %125, i64 24
  %232 = getelementptr inbounds i8, ptr %125, i64 16
  %233 = getelementptr inbounds i8, ptr %126, i64 8
  %234 = getelementptr inbounds i8, ptr %127, i64 8
  %235 = getelementptr inbounds i8, ptr %120, i64 8
  %236 = getelementptr inbounds i8, ptr %120, i64 24
  %237 = getelementptr inbounds i8, ptr %120, i64 16
  %238 = getelementptr inbounds i8, ptr %121, i64 8
  %239 = getelementptr inbounds i8, ptr %122, i64 8
  %240 = getelementptr inbounds i8, ptr %103, i64 8
  %241 = getelementptr inbounds i8, ptr %103, i64 24
  %242 = getelementptr inbounds i8, ptr %103, i64 16
  %243 = getelementptr inbounds i8, ptr %104, i64 8
  %244 = getelementptr inbounds i8, ptr %104, i64 24
  %245 = getelementptr inbounds i8, ptr %104, i64 16
  %246 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i88, 1
  %247 = insertvalue { ptr, ptr, ptr, i32 } %246, ptr undef, 2
  %248 = insertvalue { ptr, ptr, ptr, i32 } %247, i32 9, 3
  %249 = getelementptr inbounds i8, ptr %98, i64 8
  %250 = getelementptr inbounds i8, ptr %98, i64 16
  %251 = getelementptr inbounds i8, ptr %98, i64 24
  %252 = getelementptr inbounds i8, ptr %92, i64 8
  %253 = getelementptr inbounds i8, ptr %93, i64 8
  %254 = getelementptr inbounds i8, ptr %84, i64 8
  %255 = getelementptr inbounds i8, ptr %85, i64 8
  %256 = getelementptr inbounds i8, ptr %80, i64 8
  %257 = getelementptr inbounds i8, ptr %80, i64 24
  %258 = getelementptr inbounds i8, ptr %80, i64 16
  %259 = getelementptr inbounds i8, ptr %81, i64 8
  %260 = getelementptr inbounds i8, ptr %81, i64 24
  %261 = getelementptr inbounds i8, ptr %81, i64 16
  %262 = getelementptr inbounds i8, ptr %70, i64 8
  %263 = getelementptr inbounds i8, ptr %71, i64 8
  %264 = getelementptr inbounds i8, ptr %62, i64 8
  %265 = getelementptr inbounds i8, ptr %63, i64 8
  %266 = getelementptr inbounds i8, ptr %58, i64 8
  %267 = getelementptr inbounds i8, ptr %58, i64 24
  %268 = getelementptr inbounds i8, ptr %58, i64 16
  %269 = getelementptr inbounds i8, ptr %59, i64 8
  %270 = getelementptr inbounds i8, ptr %59, i64 24
  %271 = getelementptr inbounds i8, ptr %59, i64 16
  br label %272

272:                                              ; preds = %.lr.ph, %HashMap_insert_keyK_valueV.exit
  %.reg2mem87.0238 = phi i32 [ 0, %.lr.ph ], [ %1545, %HashMap_insert_keyK_valueV.exit ]
  %.reg2mem85.0237 = phi i32 [ -1, %.lr.ph ], [ %286, %HashMap_insert_keyK_valueV.exit ]
  %273 = load i32, ptr %result.i58, align 4
  %274 = mul i32 %273, 1103515245
  %275 = add i32 %274, 12345
  %276 = and i32 %275, 2147483647
  store i32 %276, ptr %result.i58, align 4
  %277 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  %.sroa.045.0.insert.ext = zext nneg i32 %276 to i160
  %278 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.045.0.insert.ext, 1
  %279 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %280 = load ptr, ptr %175, align 8
  %281 = zext nneg i32 %.reg2mem87.0238 to i64
  %282 = shl nuw nsw i64 %281, 5
  %283 = getelementptr i8, ptr %280, i64 %282
  store ptr @i32_typ, ptr %283, align 8
  %284 = getelementptr i8, ptr %283, i64 8
  store i160 %.sroa.045.0.insert.ext, ptr %284, align 4
  %285 = icmp eq i32 %.reg2mem87.0238, %226
  %286 = select i1 %285, i32 %276, i32 %.reg2mem85.0237
  store i1 true, ptr %.sroa.039.sroa.0, align 8
  %.sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.0. = load i8, ptr %.sroa.039.sroa.0, align 8
  %.sroa.039.0.insert.ext = zext i8 %.sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.sroa.0.0..sroa.039.0. to i160
  %287 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.039.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %120)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %121)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %122)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %123)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %124)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %125)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %126)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %127)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %128)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %129)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %130)
  %288 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %289 = load ptr, ptr %181, align 8
  %290 = call i32 %289({ ptr, i160 } %278)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %291 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %292 = load ptr, ptr %193, align 8
  %293 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %292, 0
  %294 = load ptr, ptr %194, align 8
  %295 = insertvalue { ptr, ptr, ptr, i32 } %293, ptr %294, 1
  %296 = load ptr, ptr %195, align 8
  %297 = insertvalue { ptr, ptr, ptr, i32 } %295, ptr %296, 2
  %298 = load i32, ptr %196, align 4
  %299 = insertvalue { ptr, ptr, ptr, i32 } %297, i32 %298, 3
  %hash_coef_ptr.i.i10.i = getelementptr i8, ptr %292, i64 8
  %tbl_size_ptr.i.i11.i = getelementptr i8, ptr %292, i64 16
  %offset_tbl_ptr.i.i12.i = getelementptr i8, ptr %292, i64 40
  %hash_coef.i.i13.i = load i64, ptr %hash_coef_ptr.i.i10.i, align 4
  %tbl_size.i.i14.i = load i64, ptr %tbl_size_ptr.i.i11.i, align 4
  %offset_tbl.i.i15.i = load ptr, ptr %offset_tbl_ptr.i.i12.i, align 8
  %product.i.i.i16.i = mul i64 %hash_coef.i.i13.i, -5261542750394134544
  %shifted.i.i.i17.i = lshr i64 %product.i.i.i16.i, 32
  %xored.i.i.i18.i = xor i64 %shifted.i.i.i17.i, %product.i.i.i16.i
  %hash.i.i.i19.i = and i64 %xored.i.i.i18.i, %tbl_size.i.i14.i
  %offset_ptr.i.i20.i = getelementptr i32, ptr %offset_tbl.i.i15.i, i64 %hash.i.i.i19.i
  %offset.i.i21.i = load i32, ptr %offset_ptr.i.i20.i, align 4
  %eq.i.i791 = icmp eq i32 %298, %offset.i.i21.i
  call void @llvm.assume(i1 %eq.i.i791) #30
  %300 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %301 = call ptr @llvm.invariant.start.p0(i64 600, ptr %292)
  %302 = sext i32 %298 to i64
  %303 = getelementptr ptr, ptr %292, i64 %302
  %304 = getelementptr i8, ptr %303, i64 64
  %305 = load ptr, ptr %304, align 8
  %306 = call ptr %305({ ptr, ptr, ptr, i32 } %299, ptr nonnull %2)
  %307 = call i32 %306({ ptr, ptr, ptr, i32 } %299, { ptr, ptr, ptr, i32 } %299, ptr nonnull %2)
  %308 = add i32 %307, -1
  %309 = and i32 %308, %290
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %310 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %311 = load ptr, ptr %193, align 8
  %312 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %311, 0
  %313 = load ptr, ptr %194, align 8
  %314 = insertvalue { ptr, ptr, ptr, i32 } %312, ptr %313, 1
  %315 = load ptr, ptr %195, align 8
  %316 = insertvalue { ptr, ptr, ptr, i32 } %314, ptr %315, 2
  %317 = load i32, ptr %196, align 4
  %318 = insertvalue { ptr, ptr, ptr, i32 } %316, i32 %317, 3
  %hash_coef_ptr.i.i162.i = getelementptr i8, ptr %311, i64 8
  %tbl_size_ptr.i.i163.i = getelementptr i8, ptr %311, i64 16
  %offset_tbl_ptr.i.i164.i = getelementptr i8, ptr %311, i64 40
  %hash_coef.i.i165.i = load i64, ptr %hash_coef_ptr.i.i162.i, align 4
  %tbl_size.i.i166.i = load i64, ptr %tbl_size_ptr.i.i163.i, align 4
  %offset_tbl.i.i167.i = load ptr, ptr %offset_tbl_ptr.i.i164.i, align 8
  %product.i.i.i168.i = mul i64 %hash_coef.i.i165.i, -5261542750394134544
  %shifted.i.i.i169.i = lshr i64 %product.i.i.i168.i, 32
  %xored.i.i.i170.i = xor i64 %shifted.i.i.i169.i, %product.i.i.i168.i
  %hash.i.i.i171.i = and i64 %xored.i.i.i170.i, %tbl_size.i.i166.i
  %offset_ptr.i.i172.i = getelementptr i32, ptr %offset_tbl.i.i167.i, i64 %hash.i.i.i171.i
  %offset.i.i173.i = load i32, ptr %offset_ptr.i.i172.i, align 4
  %eq.i.i = icmp eq i32 %317, %offset.i.i173.i
  call void @llvm.assume(i1 %eq.i.i) #30
  store ptr @_parameterization_Ptri32, ptr %129, align 8
  %319 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %129)
  %320 = call ptr @llvm.invariant.start.p0(i64 600, ptr %311)
  %321 = sext i32 %317 to i64
  %322 = getelementptr ptr, ptr %311, i64 %321
  %323 = getelementptr i8, ptr %322, i64 120
  %324 = load ptr, ptr %323, align 8
  store ptr @i32_typ, ptr %130, align 8
  %325 = call ptr %324({ ptr, ptr, ptr, i32 } %318, ptr nonnull %130)
  %326 = call { ptr, i160 } %325({ ptr, ptr, ptr, i32 } %318, { ptr, ptr, ptr, i32 } %318, ptr nonnull %129, i32 %309)
  %.fca.0.extract.i414 = extractvalue { ptr, i160 } %326, 0
  %327 = icmp ne ptr %.fca.0.extract.i414, @nil_typ
  %328 = icmp ne ptr %.fca.0.extract.i414, null
  %.not149.i = and i1 %327, %328
  br i1 %.not149.i, label %329, label %.critedge.i

329:                                              ; preds = %272
  %.fca.1.extract.i = extractvalue { ptr, i160 } %326, 1
  %.sroa.4520.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i64
  %330 = inttoptr i64 %.sroa.4520.8.extract.trunc.i to ptr
  %.sroa.7522.8.extract.shift.i = lshr i160 %.fca.1.extract.i, 64
  %.sroa.7522.8.extract.trunc.i = trunc i160 %.sroa.7522.8.extract.shift.i to i64
  %331 = inttoptr i64 %.sroa.7522.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract.i414, i64 8
  %tbl_size_ptr.i.i177.i = getelementptr i8, ptr %.fca.0.extract.i414, i64 16
  %offset_tbl_ptr.i.i178.i = getelementptr i8, ptr %.fca.0.extract.i414, i64 40
  %hash_coef.i.i179.i = load i64, ptr %hash_coef_ptr.i.i176.i, align 4
  %tbl_size.i.i180.i = load i64, ptr %tbl_size_ptr.i.i177.i, align 4
  %offset_tbl.i.i181.i = load ptr, ptr %offset_tbl_ptr.i.i178.i, align 8
  %product.i.i.i182.i = mul i64 %hash_coef.i.i179.i, 4015701072841558310
  %shifted.i.i.i183.i = lshr i64 %product.i.i.i182.i, 32
  %xored.i.i.i184.i = xor i64 %shifted.i.i.i183.i, %product.i.i.i182.i
  %hash.i.i.i185.i = and i64 %xored.i.i.i184.i, %tbl_size.i.i180.i
  %offset_ptr.i.i186.i = getelementptr i32, ptr %offset_tbl.i.i181.i, i64 %hash.i.i.i185.i
  %offset.i.i187.i = load i32, ptr %offset_ptr.i.i186.i, align 4
  %332 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i414, 0
  %333 = insertvalue { ptr, ptr, ptr, i32 } %332, ptr %330, 1
  %334 = insertvalue { ptr, ptr, ptr, i32 } %333, ptr %331, 2
  %335 = insertvalue { ptr, ptr, ptr, i32 } %334, i32 %offset.i.i187.i, 3
  %336 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %337 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %338 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i414)
  %339 = sext i32 %offset.i.i187.i to i64
  %340 = getelementptr ptr, ptr %.fca.0.extract.i414, i64 %339
  %341 = getelementptr i8, ptr %340, i64 64
  %342 = load ptr, ptr %341, align 8
  %343 = call ptr %342({ ptr, ptr, ptr, i32 } %335, ptr nonnull %2)
  %344 = call i32 %343({ ptr, ptr, ptr, i32 } %335, { ptr, ptr, ptr, i32 } %335, ptr nonnull %2)
  %345 = icmp eq i32 %344, %290
  %346 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %347 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %348 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i414)
  %349 = getelementptr i8, ptr %340, i64 48
  %350 = load ptr, ptr %349, align 8
  %351 = call ptr %350({ ptr, ptr, ptr, i32 } %335, ptr nonnull %2)
  %352 = call { ptr, i160 } %351({ ptr, ptr, ptr, i32 } %335, { ptr, ptr, ptr, i32 } %335, ptr nonnull %2)
  %353 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %354 = load ptr, ptr %182, align 8
  %355 = call i1 %354({ ptr, i160 } %352, { ptr, i160 } %278)
  %356 = and i1 %345, %355
  br i1 %356, label %357, label %.critedge.i

357:                                              ; preds = %329
  %358 = load ptr, ptr %result.i88, align 8
  %359 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %360 = load ptr, ptr %176, align 8
  %361 = load ptr, ptr %358, align 8
  %362 = getelementptr i8, ptr %361, i64 48
  %363 = load ptr, ptr %362, align 8
  %364 = call { i64, i64 } %363(ptr nonnull %358)
  %365 = extractvalue { i64, i64 } %364, 0
  %366 = extractvalue { i64, i64 } %364, 1
  %367 = urem i64 20, %366
  %368 = icmp eq i64 %367, 0
  %369 = sub i64 %366, %367
  %370 = select i1 %368, i64 0, i64 %369
  %371 = add i64 %365, 20
  %372 = add i64 %371, %370
  %373 = load ptr, ptr %360, align 8
  %374 = getelementptr i8, ptr %373, i64 48
  %375 = load ptr, ptr %374, align 8
  %376 = call { i64, i64 } %375(ptr nonnull %360)
  %377 = extractvalue { i64, i64 } %376, 0
  %378 = extractvalue { i64, i64 } %376, 1
  %379 = call i64 @llvm.umax.i64(i64 %366, i64 %378)
  %380 = call i64 @llvm.umax.i64(i64 %379, i64 8)
  %381 = urem i64 %372, %378
  %382 = icmp eq i64 %381, 0
  %383 = sub i64 %378, %381
  %384 = select i1 %382, i64 0, i64 %383
  %385 = add i64 %377, %372
  %386 = add i64 %385, %384
  %387 = urem i64 %386, %380
  %388 = icmp eq i64 %387, 0
  %389 = sub i64 %380, %387
  %390 = select i1 %388, i64 0, i64 %389
  %391 = add i64 %390, %386
  %result.i.i415 = call noalias ptr @bump_malloc_inner(i64 noundef %391, ptr nonnull @current_ptr) #29
  store ptr %358, ptr %result.i.i415, align 8
  %392 = getelementptr i8, ptr %result.i.i415, i64 8
  store ptr %360, ptr %392, align 8
  %393 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i415)
  store ptr @Entry, ptr %120, align 8
  store ptr %result.i.i415, ptr %235, align 8
  store i32 9, ptr %236, align 8
  %394 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %120)
  %395 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %396 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %397 = load ptr, ptr %358, align 8
  %398 = getelementptr i8, ptr %397, i64 48
  %399 = load ptr, ptr %398, align 8
  %400 = call { i64, i64 } %399(ptr nonnull %358)
  %401 = extractvalue { i64, i64 } %400, 1
  %402 = urem i64 20, %401
  %403 = icmp eq i64 %402, 0
  %reass.sub3212 = sub i64 %401, %402
  %404 = add i64 %reass.sub3212, 20
  %405 = select i1 %403, i64 20, i64 %404
  %406 = getelementptr i8, ptr %result.i.i415, i64 %405
  %407 = load ptr, ptr %result.i.i415, align 8
  %408 = load ptr, ptr %407, align 8
  %409 = getelementptr i8, ptr %408, i64 64
  %410 = load ptr, ptr %409, align 8
  call void %410({ ptr, i160 } %278, ptr nonnull %407, ptr %406)
  %411 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %412 = load ptr, ptr %result.i.i415, align 8
  %413 = load ptr, ptr %412, align 8
  %414 = getelementptr i8, ptr %413, i64 48
  %415 = load ptr, ptr %414, align 8
  %416 = call { i64, i64 } %415(ptr nonnull %412)
  %417 = extractvalue { i64, i64 } %416, 0
  %418 = extractvalue { i64, i64 } %416, 1
  %419 = urem i64 20, %418
  %420 = icmp eq i64 %419, 0
  %421 = sub i64 %418, %419
  %422 = select i1 %420, i64 0, i64 %421
  %423 = add i64 %417, 20
  %424 = add i64 %423, %422
  %425 = load ptr, ptr %392, align 8
  %426 = load ptr, ptr %425, align 8
  %427 = getelementptr i8, ptr %426, i64 48
  %428 = load ptr, ptr %427, align 8
  %429 = call { i64, i64 } %428(ptr nonnull %425)
  %430 = extractvalue { i64, i64 } %429, 1
  %431 = urem i64 %424, %430
  %432 = icmp eq i64 %431, 0
  %433 = sub i64 %430, %431
  %434 = select i1 %432, i64 0, i64 %433
  %435 = getelementptr i8, ptr %result.i.i415, i64 %424
  %436 = getelementptr i8, ptr %435, i64 %434
  %437 = load ptr, ptr %392, align 8
  %438 = load ptr, ptr %437, align 8
  %439 = getelementptr i8, ptr %438, i64 64
  %440 = load ptr, ptr %439, align 8
  call void %440({ ptr, i160 } %287, ptr nonnull %437, ptr %436)
  %441 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %442 = getelementptr i8, ptr %result.i.i415, i64 16
  store i32 %290, ptr %442, align 4
  %443 = load ptr, ptr %237, align 8
  %444 = ptrtoint ptr %result.i.i415 to i64
  %445 = ptrtoint ptr %443 to i64
  %.sroa.2127.0.insert.ext.i = zext i64 %445 to i160
  %.sroa.2127.0.insert.shift.i = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i, 64
  %.sroa.0126.0.insert.ext.i = zext i64 %444 to i160
  %.sroa.2127.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.shift.i, %.sroa.0126.0.insert.ext.i
  %.sroa.0126.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.insert.i, 3062541302288446171170371466885913903104
  %446 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i, 1
  %447 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %448 = load ptr, ptr %193, align 8
  %449 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %448, 0
  %450 = load ptr, ptr %194, align 8
  %451 = insertvalue { ptr, ptr, ptr, i32 } %449, ptr %450, 1
  %452 = load ptr, ptr %195, align 8
  %453 = insertvalue { ptr, ptr, ptr, i32 } %451, ptr %452, 2
  %454 = load i32, ptr %196, align 4
  %455 = insertvalue { ptr, ptr, ptr, i32 } %453, i32 %454, 3
  %hash_coef_ptr.i.i204.i = getelementptr i8, ptr %448, i64 8
  %tbl_size_ptr.i.i205.i = getelementptr i8, ptr %448, i64 16
  %offset_tbl_ptr.i.i206.i = getelementptr i8, ptr %448, i64 40
  %hash_coef.i.i207.i = load i64, ptr %hash_coef_ptr.i.i204.i, align 4
  %tbl_size.i.i208.i = load i64, ptr %tbl_size_ptr.i.i205.i, align 4
  %offset_tbl.i.i209.i = load ptr, ptr %offset_tbl_ptr.i.i206.i, align 8
  %product.i.i.i210.i = mul i64 %hash_coef.i.i207.i, -5261542750394134544
  %shifted.i.i.i211.i = lshr i64 %product.i.i.i210.i, 32
  %xored.i.i.i212.i = xor i64 %shifted.i.i.i211.i, %product.i.i.i210.i
  %hash.i.i.i213.i = and i64 %xored.i.i.i212.i, %tbl_size.i.i208.i
  %offset_ptr.i.i214.i = getelementptr i32, ptr %offset_tbl.i.i209.i, i64 %hash.i.i.i213.i
  %offset.i.i215.i = load i32, ptr %offset_ptr.i.i214.i, align 4
  %eq.i218.i = icmp eq i32 %454, %offset.i.i215.i
  call void @llvm.assume(i1 %eq.i218.i) #30
  %456 = load ptr, ptr %result.i88, align 8
  %457 = load ptr, ptr %176, align 8
  %result.i219.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %458 = getelementptr i8, ptr %result.i219.i, i64 16
  store ptr %457, ptr %458, align 8
  %459 = getelementptr i8, ptr %result.i219.i, i64 8
  store ptr %456, ptr %459, align 8
  %460 = getelementptr i8, ptr %result.i219.i, i64 24
  store ptr null, ptr %460, align 8
  %461 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i)
  store ptr @Entry, ptr %result.i219.i, align 8
  store ptr @_parameterization_Ptri32, ptr %121, align 8
  store ptr %result.i219.i, ptr %238, align 8
  %462 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %121)
  %463 = call ptr @llvm.invariant.start.p0(i64 600, ptr %448)
  %464 = sext i32 %454 to i64
  %465 = getelementptr ptr, ptr %448, i64 %464
  %466 = getelementptr i8, ptr %465, i64 128
  %467 = load ptr, ptr %466, align 8
  store ptr @i32_typ, ptr %122, align 8
  store ptr @Entry, ptr %239, align 8
  %468 = call ptr %467({ ptr, ptr, ptr, i32 } %455, ptr nonnull %122)
  call void %468({ ptr, ptr, ptr, i32 } %455, { ptr, ptr, ptr, i32 } %455, ptr nonnull %121, i32 %309, { ptr, i160 } %446)
  br label %HashMap_insert_keyK_valueV.exit

.critedge.i:                                      ; preds = %329, %272
  %469 = add i32 %290, 2127912214
  %470 = shl i32 %290, 12
  %471 = add i32 %469, %470
  %472 = ashr i32 %471, 19
  %473 = xor i32 %471, %472
  %474 = xor i32 %473, -949894596
  %475 = add i32 %474, 374761393
  %476 = shl i32 %474, 5
  %477 = add i32 %475, %476
  %478 = add i32 %477, -744332180
  %479 = shl i32 %477, 9
  %480 = xor i32 %478, %479
  %481 = add i32 %480, -42973499
  %482 = shl i32 %480, 3
  %483 = add i32 %481, %482
  %484 = ashr i32 %483, 16
  %485 = xor i32 %483, %484
  %486 = xor i32 %485, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %487 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %488 = load ptr, ptr %211, align 8
  %489 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %488, 0
  %490 = load ptr, ptr %212, align 8
  %491 = insertvalue { ptr, ptr, ptr, i32 } %489, ptr %490, 1
  %492 = load ptr, ptr %213, align 8
  %493 = insertvalue { ptr, ptr, ptr, i32 } %491, ptr %492, 2
  %494 = load i32, ptr %214, align 4
  %495 = insertvalue { ptr, ptr, ptr, i32 } %493, i32 %494, 3
  %hash_coef_ptr.i.i10.i809 = getelementptr i8, ptr %488, i64 8
  %tbl_size_ptr.i.i11.i810 = getelementptr i8, ptr %488, i64 16
  %offset_tbl_ptr.i.i12.i811 = getelementptr i8, ptr %488, i64 40
  %hash_coef.i.i13.i812 = load i64, ptr %hash_coef_ptr.i.i10.i809, align 4
  %tbl_size.i.i14.i813 = load i64, ptr %tbl_size_ptr.i.i11.i810, align 4
  %offset_tbl.i.i15.i814 = load ptr, ptr %offset_tbl_ptr.i.i12.i811, align 8
  %product.i.i.i16.i815 = mul i64 %hash_coef.i.i13.i812, -5261542750394134544
  %shifted.i.i.i17.i816 = lshr i64 %product.i.i.i16.i815, 32
  %xored.i.i.i18.i817 = xor i64 %shifted.i.i.i17.i816, %product.i.i.i16.i815
  %hash.i.i.i19.i818 = and i64 %xored.i.i.i18.i817, %tbl_size.i.i14.i813
  %offset_ptr.i.i20.i819 = getelementptr i32, ptr %offset_tbl.i.i15.i814, i64 %hash.i.i.i19.i818
  %offset.i.i21.i820 = load i32, ptr %offset_ptr.i.i20.i819, align 4
  %eq.i.i821 = icmp eq i32 %494, %offset.i.i21.i820
  call void @llvm.assume(i1 %eq.i.i821) #30
  %496 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %497 = call ptr @llvm.invariant.start.p0(i64 600, ptr %488)
  %498 = sext i32 %494 to i64
  %499 = getelementptr ptr, ptr %488, i64 %498
  %500 = getelementptr i8, ptr %499, i64 64
  %501 = load ptr, ptr %500, align 8
  %502 = call ptr %501({ ptr, ptr, ptr, i32 } %495, ptr nonnull %2)
  %503 = call i32 %502({ ptr, ptr, ptr, i32 } %495, { ptr, ptr, ptr, i32 } %495, ptr nonnull %2)
  %504 = add i32 %503, -1
  %505 = and i32 %504, %486
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %506 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %507 = load ptr, ptr %211, align 8
  %508 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %507, 0
  %509 = load ptr, ptr %212, align 8
  %510 = insertvalue { ptr, ptr, ptr, i32 } %508, ptr %509, 1
  %511 = load ptr, ptr %213, align 8
  %512 = insertvalue { ptr, ptr, ptr, i32 } %510, ptr %511, 2
  %513 = load i32, ptr %214, align 4
  %514 = insertvalue { ptr, ptr, ptr, i32 } %512, i32 %513, 3
  %hash_coef_ptr.i.i221.i = getelementptr i8, ptr %507, i64 8
  %tbl_size_ptr.i.i222.i = getelementptr i8, ptr %507, i64 16
  %offset_tbl_ptr.i.i223.i = getelementptr i8, ptr %507, i64 40
  %hash_coef.i.i224.i = load i64, ptr %hash_coef_ptr.i.i221.i, align 4
  %tbl_size.i.i225.i = load i64, ptr %tbl_size_ptr.i.i222.i, align 4
  %offset_tbl.i.i226.i = load ptr, ptr %offset_tbl_ptr.i.i223.i, align 8
  %product.i.i.i227.i = mul i64 %hash_coef.i.i224.i, -5261542750394134544
  %shifted.i.i.i228.i = lshr i64 %product.i.i.i227.i, 32
  %xored.i.i.i229.i = xor i64 %shifted.i.i.i228.i, %product.i.i.i227.i
  %hash.i.i.i230.i = and i64 %xored.i.i.i229.i, %tbl_size.i.i225.i
  %offset_ptr.i.i231.i = getelementptr i32, ptr %offset_tbl.i.i226.i, i64 %hash.i.i.i230.i
  %offset.i.i232.i = load i32, ptr %offset_ptr.i.i231.i, align 4
  %eq.i235.i = icmp eq i32 %513, %offset.i.i232.i
  call void @llvm.assume(i1 %eq.i235.i) #30
  store ptr @_parameterization_Ptri32, ptr %123, align 8
  %515 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %123)
  %516 = call ptr @llvm.invariant.start.p0(i64 600, ptr %507)
  %517 = sext i32 %513 to i64
  %518 = getelementptr ptr, ptr %507, i64 %517
  %519 = getelementptr i8, ptr %518, i64 120
  %520 = load ptr, ptr %519, align 8
  store ptr @i32_typ, ptr %124, align 8
  %521 = call ptr %520({ ptr, ptr, ptr, i32 } %514, ptr nonnull %124)
  %522 = call { ptr, i160 } %521({ ptr, ptr, ptr, i32 } %514, { ptr, ptr, ptr, i32 } %514, ptr nonnull %123, i32 %505)
  %.fca.0.extract102.i = extractvalue { ptr, i160 } %522, 0
  %523 = icmp ne ptr %.fca.0.extract102.i, @nil_typ
  %524 = icmp ne ptr %.fca.0.extract102.i, null
  %.not151.i = and i1 %523, %524
  br i1 %.not151.i, label %525, label %.critedge158.i

525:                                              ; preds = %.critedge.i
  %.fca.1.extract104.i = extractvalue { ptr, i160 } %522, 1
  %.sroa.4.8.extract.trunc.i = trunc i160 %.fca.1.extract104.i to i64
  %526 = inttoptr i64 %.sroa.4.8.extract.trunc.i to ptr
  %.sroa.7508.8.extract.shift.i = lshr i160 %.fca.1.extract104.i, 64
  %.sroa.7508.8.extract.trunc.i = trunc i160 %.sroa.7508.8.extract.shift.i to i64
  %527 = inttoptr i64 %.sroa.7508.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i237.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 8
  %tbl_size_ptr.i.i238.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 16
  %offset_tbl_ptr.i.i239.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 40
  %hash_coef.i.i240.i = load i64, ptr %hash_coef_ptr.i.i237.i, align 4
  %tbl_size.i.i241.i = load i64, ptr %tbl_size_ptr.i.i238.i, align 4
  %offset_tbl.i.i242.i = load ptr, ptr %offset_tbl_ptr.i.i239.i, align 8
  %product.i.i.i243.i = mul i64 %hash_coef.i.i240.i, 4015701072841558310
  %shifted.i.i.i244.i = lshr i64 %product.i.i.i243.i, 32
  %xored.i.i.i245.i = xor i64 %shifted.i.i.i244.i, %product.i.i.i243.i
  %hash.i.i.i246.i = and i64 %xored.i.i.i245.i, %tbl_size.i.i241.i
  %offset_ptr.i.i247.i = getelementptr i32, ptr %offset_tbl.i.i242.i, i64 %hash.i.i.i246.i
  %offset.i.i248.i = load i32, ptr %offset_ptr.i.i247.i, align 4
  %528 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i, 0
  %529 = insertvalue { ptr, ptr, ptr, i32 } %528, ptr %526, 1
  %530 = insertvalue { ptr, ptr, ptr, i32 } %529, ptr %527, 2
  %531 = insertvalue { ptr, ptr, ptr, i32 } %530, i32 %offset.i.i248.i, 3
  %532 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %533 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %534 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %535 = sext i32 %offset.i.i248.i to i64
  %536 = getelementptr ptr, ptr %.fca.0.extract102.i, i64 %535
  %537 = getelementptr i8, ptr %536, i64 64
  %538 = load ptr, ptr %537, align 8
  %539 = call ptr %538({ ptr, ptr, ptr, i32 } %531, ptr nonnull %2)
  %540 = call i32 %539({ ptr, ptr, ptr, i32 } %531, { ptr, ptr, ptr, i32 } %531, ptr nonnull %2)
  %541 = icmp eq i32 %540, %290
  %542 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %543 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %544 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %545 = getelementptr i8, ptr %536, i64 48
  %546 = load ptr, ptr %545, align 8
  %547 = call ptr %546({ ptr, ptr, ptr, i32 } %531, ptr nonnull %2)
  %548 = call { ptr, i160 } %547({ ptr, ptr, ptr, i32 } %531, { ptr, ptr, ptr, i32 } %531, ptr nonnull %2)
  %549 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %550 = load ptr, ptr %182, align 8
  %551 = call i1 %550({ ptr, i160 } %548, { ptr, i160 } %278)
  %552 = and i1 %541, %551
  br i1 %552, label %553, label %.critedge158.i

553:                                              ; preds = %525
  %554 = load ptr, ptr %result.i88, align 8
  %555 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %556 = load ptr, ptr %176, align 8
  %557 = load ptr, ptr %554, align 8
  %558 = getelementptr i8, ptr %557, i64 48
  %559 = load ptr, ptr %558, align 8
  %560 = call { i64, i64 } %559(ptr nonnull %554)
  %561 = extractvalue { i64, i64 } %560, 0
  %562 = extractvalue { i64, i64 } %560, 1
  %563 = urem i64 20, %562
  %564 = icmp eq i64 %563, 0
  %565 = sub i64 %562, %563
  %566 = select i1 %564, i64 0, i64 %565
  %567 = add i64 %561, 20
  %568 = add i64 %567, %566
  %569 = load ptr, ptr %556, align 8
  %570 = getelementptr i8, ptr %569, i64 48
  %571 = load ptr, ptr %570, align 8
  %572 = call { i64, i64 } %571(ptr nonnull %556)
  %573 = extractvalue { i64, i64 } %572, 0
  %574 = extractvalue { i64, i64 } %572, 1
  %575 = call i64 @llvm.umax.i64(i64 %562, i64 %574)
  %576 = call i64 @llvm.umax.i64(i64 %575, i64 8)
  %577 = urem i64 %568, %574
  %578 = icmp eq i64 %577, 0
  %579 = sub i64 %574, %577
  %580 = select i1 %578, i64 0, i64 %579
  %581 = add i64 %573, %568
  %582 = add i64 %581, %580
  %583 = urem i64 %582, %576
  %584 = icmp eq i64 %583, 0
  %585 = sub i64 %576, %583
  %586 = select i1 %584, i64 0, i64 %585
  %587 = add i64 %586, %582
  %result.i250.i = call noalias ptr @bump_malloc_inner(i64 noundef %587, ptr nonnull @current_ptr) #29
  store ptr %554, ptr %result.i250.i, align 8
  %588 = getelementptr i8, ptr %result.i250.i, i64 8
  store ptr %556, ptr %588, align 8
  %589 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i)
  store ptr @Entry, ptr %125, align 8
  store ptr %result.i250.i, ptr %230, align 8
  store i32 9, ptr %231, align 8
  %590 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %125)
  %591 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %592 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %593 = load ptr, ptr %554, align 8
  %594 = getelementptr i8, ptr %593, i64 48
  %595 = load ptr, ptr %594, align 8
  %596 = call { i64, i64 } %595(ptr nonnull %554)
  %597 = extractvalue { i64, i64 } %596, 1
  %598 = urem i64 20, %597
  %599 = icmp eq i64 %598, 0
  %reass.sub3211 = sub i64 %597, %598
  %600 = add i64 %reass.sub3211, 20
  %601 = select i1 %599, i64 20, i64 %600
  %602 = getelementptr i8, ptr %result.i250.i, i64 %601
  %603 = load ptr, ptr %result.i250.i, align 8
  %604 = load ptr, ptr %603, align 8
  %605 = getelementptr i8, ptr %604, i64 64
  %606 = load ptr, ptr %605, align 8
  call void %606({ ptr, i160 } %278, ptr nonnull %603, ptr %602)
  %607 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %608 = load ptr, ptr %result.i250.i, align 8
  %609 = load ptr, ptr %608, align 8
  %610 = getelementptr i8, ptr %609, i64 48
  %611 = load ptr, ptr %610, align 8
  %612 = call { i64, i64 } %611(ptr nonnull %608)
  %613 = extractvalue { i64, i64 } %612, 0
  %614 = extractvalue { i64, i64 } %612, 1
  %615 = urem i64 20, %614
  %616 = icmp eq i64 %615, 0
  %617 = sub i64 %614, %615
  %618 = select i1 %616, i64 0, i64 %617
  %619 = add i64 %613, 20
  %620 = add i64 %619, %618
  %621 = load ptr, ptr %588, align 8
  %622 = load ptr, ptr %621, align 8
  %623 = getelementptr i8, ptr %622, i64 48
  %624 = load ptr, ptr %623, align 8
  %625 = call { i64, i64 } %624(ptr nonnull %621)
  %626 = extractvalue { i64, i64 } %625, 1
  %627 = urem i64 %620, %626
  %628 = icmp eq i64 %627, 0
  %629 = sub i64 %626, %627
  %630 = select i1 %628, i64 0, i64 %629
  %631 = getelementptr i8, ptr %result.i250.i, i64 %620
  %632 = getelementptr i8, ptr %631, i64 %630
  %633 = load ptr, ptr %588, align 8
  %634 = load ptr, ptr %633, align 8
  %635 = getelementptr i8, ptr %634, i64 64
  %636 = load ptr, ptr %635, align 8
  call void %636({ ptr, i160 } %287, ptr nonnull %633, ptr %632)
  %637 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %638 = getelementptr i8, ptr %result.i250.i, i64 16
  store i32 %290, ptr %638, align 4
  %639 = load ptr, ptr %232, align 8
  %640 = ptrtoint ptr %result.i250.i to i64
  %641 = ptrtoint ptr %639 to i64
  %.sroa.282.0.insert.ext.i = zext i64 %641 to i160
  %.sroa.282.0.insert.shift.i = shl nuw nsw i160 %.sroa.282.0.insert.ext.i, 64
  %.sroa.081.0.insert.ext.i = zext i64 %640 to i160
  %.sroa.282.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.shift.i, %.sroa.081.0.insert.ext.i
  %.sroa.081.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.insert.i, 3062541302288446171170371466885913903104
  %642 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i, 1
  %643 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %644 = load ptr, ptr %211, align 8
  %645 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %644, 0
  %646 = load ptr, ptr %212, align 8
  %647 = insertvalue { ptr, ptr, ptr, i32 } %645, ptr %646, 1
  %648 = load ptr, ptr %213, align 8
  %649 = insertvalue { ptr, ptr, ptr, i32 } %647, ptr %648, 2
  %650 = load i32, ptr %214, align 4
  %651 = insertvalue { ptr, ptr, ptr, i32 } %649, i32 %650, 3
  %hash_coef_ptr.i.i266.i = getelementptr i8, ptr %644, i64 8
  %tbl_size_ptr.i.i267.i = getelementptr i8, ptr %644, i64 16
  %offset_tbl_ptr.i.i268.i = getelementptr i8, ptr %644, i64 40
  %hash_coef.i.i269.i = load i64, ptr %hash_coef_ptr.i.i266.i, align 4
  %tbl_size.i.i270.i = load i64, ptr %tbl_size_ptr.i.i267.i, align 4
  %offset_tbl.i.i271.i = load ptr, ptr %offset_tbl_ptr.i.i268.i, align 8
  %product.i.i.i272.i = mul i64 %hash_coef.i.i269.i, -5261542750394134544
  %shifted.i.i.i273.i = lshr i64 %product.i.i.i272.i, 32
  %xored.i.i.i274.i = xor i64 %shifted.i.i.i273.i, %product.i.i.i272.i
  %hash.i.i.i275.i = and i64 %xored.i.i.i274.i, %tbl_size.i.i270.i
  %offset_ptr.i.i276.i = getelementptr i32, ptr %offset_tbl.i.i271.i, i64 %hash.i.i.i275.i
  %offset.i.i277.i = load i32, ptr %offset_ptr.i.i276.i, align 4
  %eq.i280.i = icmp eq i32 %650, %offset.i.i277.i
  call void @llvm.assume(i1 %eq.i280.i) #30
  %652 = load ptr, ptr %result.i88, align 8
  %653 = load ptr, ptr %176, align 8
  %result.i281.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %654 = getelementptr i8, ptr %result.i281.i, i64 16
  store ptr %653, ptr %654, align 8
  %655 = getelementptr i8, ptr %result.i281.i, i64 8
  store ptr %652, ptr %655, align 8
  %656 = getelementptr i8, ptr %result.i281.i, i64 24
  store ptr null, ptr %656, align 8
  %657 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i)
  store ptr @Entry, ptr %result.i281.i, align 8
  store ptr @_parameterization_Ptri32, ptr %126, align 8
  store ptr %result.i281.i, ptr %233, align 8
  %658 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %126)
  %659 = call ptr @llvm.invariant.start.p0(i64 600, ptr %644)
  %660 = sext i32 %650 to i64
  %661 = getelementptr ptr, ptr %644, i64 %660
  %662 = getelementptr i8, ptr %661, i64 128
  %663 = load ptr, ptr %662, align 8
  store ptr @i32_typ, ptr %127, align 8
  store ptr @Entry, ptr %234, align 8
  %664 = call ptr %663({ ptr, ptr, ptr, i32 } %651, ptr nonnull %127)
  call void %664({ ptr, ptr, ptr, i32 } %651, { ptr, ptr, ptr, i32 } %651, ptr nonnull %126, i32 %505, { ptr, i160 } %642)
  br label %HashMap_insert_keyK_valueV.exit

.critedge158.i:                                   ; preds = %525, %.critedge.i
  %665 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %666 = load ptr, ptr %193, align 8
  %667 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %666, 0
  %668 = load ptr, ptr %194, align 8
  %669 = insertvalue { ptr, ptr, ptr, i32 } %667, ptr %668, 1
  %670 = load ptr, ptr %195, align 8
  %671 = insertvalue { ptr, ptr, ptr, i32 } %669, ptr %670, 2
  %672 = load i32, ptr %196, align 4
  %673 = insertvalue { ptr, ptr, ptr, i32 } %671, i32 %672, 3
  %hash_coef_ptr.i.i283.i = getelementptr i8, ptr %666, i64 8
  %tbl_size_ptr.i.i284.i = getelementptr i8, ptr %666, i64 16
  %offset_tbl_ptr.i.i285.i = getelementptr i8, ptr %666, i64 40
  %hash_coef.i.i286.i = load i64, ptr %hash_coef_ptr.i.i283.i, align 4
  %tbl_size.i.i287.i = load i64, ptr %tbl_size_ptr.i.i284.i, align 4
  %offset_tbl.i.i288.i = load ptr, ptr %offset_tbl_ptr.i.i285.i, align 8
  %product.i.i.i289.i = mul i64 %hash_coef.i.i286.i, -5261542750394134544
  %shifted.i.i.i290.i = lshr i64 %product.i.i.i289.i, 32
  %xored.i.i.i291.i = xor i64 %shifted.i.i.i290.i, %product.i.i.i289.i
  %hash.i.i.i292.i = and i64 %xored.i.i.i291.i, %tbl_size.i.i287.i
  %offset_ptr.i.i293.i = getelementptr i32, ptr %offset_tbl.i.i288.i, i64 %hash.i.i.i292.i
  %offset.i.i294.i = load i32, ptr %offset_ptr.i.i293.i, align 4
  %eq.i297.i = icmp eq i32 %672, %offset.i.i294.i
  call void @llvm.assume(i1 %eq.i297.i) #30
  %674 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %675 = call ptr @llvm.invariant.start.p0(i64 600, ptr %666)
  %676 = sext i32 %672 to i64
  %677 = getelementptr ptr, ptr %666, i64 %676
  %678 = getelementptr i8, ptr %677, i64 64
  %679 = load ptr, ptr %678, align 8
  %680 = call ptr %679({ ptr, ptr, ptr, i32 } %673, ptr nonnull %2)
  %681 = call i32 %680({ ptr, ptr, ptr, i32 } %673, { ptr, ptr, ptr, i32 } %673, ptr nonnull %2)
  %682 = load i32, ptr %215, align 4
  %.not.i = icmp slt i32 %682, %681
  br i1 %.not.i, label %._crit_edge.i, label %683

683:                                              ; preds = %.critedge158.i
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %99)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %100)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %101)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %102)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %103)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %104)
  %684 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %685 = load ptr, ptr %193, align 8
  %686 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %685, 0
  %687 = load ptr, ptr %194, align 8
  %688 = insertvalue { ptr, ptr, ptr, i32 } %686, ptr %687, 1
  %689 = load ptr, ptr %195, align 8
  %690 = insertvalue { ptr, ptr, ptr, i32 } %688, ptr %689, 2
  %691 = load i32, ptr %196, align 4
  %692 = insertvalue { ptr, ptr, ptr, i32 } %690, i32 %691, 3
  %hash_coef_ptr.i.i64.i = getelementptr i8, ptr %685, i64 8
  %tbl_size_ptr.i.i65.i = getelementptr i8, ptr %685, i64 16
  %offset_tbl_ptr.i.i66.i = getelementptr i8, ptr %685, i64 40
  %hash_coef.i.i67.i = load i64, ptr %hash_coef_ptr.i.i64.i, align 4
  %tbl_size.i.i68.i = load i64, ptr %tbl_size_ptr.i.i65.i, align 4
  %offset_tbl.i.i69.i = load ptr, ptr %offset_tbl_ptr.i.i66.i, align 8
  %product.i.i.i70.i = mul i64 %hash_coef.i.i67.i, -5261542750394134544
  %shifted.i.i.i71.i = lshr i64 %product.i.i.i70.i, 32
  %xored.i.i.i72.i = xor i64 %shifted.i.i.i71.i, %product.i.i.i70.i
  %hash.i.i.i73.i = and i64 %xored.i.i.i72.i, %tbl_size.i.i68.i
  %offset_ptr.i.i74.i = getelementptr i32, ptr %offset_tbl.i.i69.i, i64 %hash.i.i.i73.i
  %offset.i.i75.i = load i32, ptr %offset_ptr.i.i74.i, align 4
  %eq.i.i835 = icmp eq i32 %691, %offset.i.i75.i
  call void @llvm.assume(i1 %eq.i.i835) #30
  %693 = load ptr, ptr %211, align 8
  %694 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %693, 0
  %695 = load ptr, ptr %212, align 8
  %696 = insertvalue { ptr, ptr, ptr, i32 } %694, ptr %695, 1
  %697 = load ptr, ptr %213, align 8
  %698 = insertvalue { ptr, ptr, ptr, i32 } %696, ptr %697, 2
  %699 = load i32, ptr %214, align 4
  %700 = insertvalue { ptr, ptr, ptr, i32 } %698, i32 %699, 3
  %hash_coef_ptr.i.i92.i = getelementptr i8, ptr %693, i64 8
  %tbl_size_ptr.i.i93.i = getelementptr i8, ptr %693, i64 16
  %offset_tbl_ptr.i.i94.i = getelementptr i8, ptr %693, i64 40
  %hash_coef.i.i95.i = load i64, ptr %hash_coef_ptr.i.i92.i, align 4
  %tbl_size.i.i96.i = load i64, ptr %tbl_size_ptr.i.i93.i, align 4
  %offset_tbl.i.i97.i = load ptr, ptr %offset_tbl_ptr.i.i94.i, align 8
  %product.i.i.i98.i = mul i64 %hash_coef.i.i95.i, -5261542750394134544
  %shifted.i.i.i99.i = lshr i64 %product.i.i.i98.i, 32
  %xored.i.i.i100.i = xor i64 %shifted.i.i.i99.i, %product.i.i.i98.i
  %hash.i.i.i101.i = and i64 %xored.i.i.i100.i, %tbl_size.i.i96.i
  %offset_ptr.i.i102.i = getelementptr i32, ptr %offset_tbl.i.i97.i, i64 %hash.i.i.i101.i
  %offset.i.i103.i = load i32, ptr %offset_ptr.i.i102.i, align 4
  %eq.i106.i = icmp eq i32 %699, %offset.i.i103.i
  call void @llvm.assume(i1 %eq.i106.i) #30
  %701 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %702 = call ptr @llvm.invariant.start.p0(i64 600, ptr %685)
  %703 = sext i32 %691 to i64
  %704 = getelementptr ptr, ptr %685, i64 %703
  %705 = getelementptr i8, ptr %704, i64 64
  %706 = load ptr, ptr %705, align 8
  %707 = call ptr %706({ ptr, ptr, ptr, i32 } %692, ptr nonnull %2)
  %708 = call i32 %707({ ptr, ptr, ptr, i32 } %692, { ptr, ptr, ptr, i32 } %692, ptr nonnull %2)
  %709 = shl i32 %708, 1
  %710 = load i32, ptr %215, align 4
  %711 = load ptr, ptr %result.i88, align 8
  %712 = load ptr, ptr %176, align 8
  %713 = sext i32 %710 to i64
  %714 = shl nsw i64 %713, 5
  %result.i.i.i841 = call noalias ptr @bump_malloc_inner(i64 noundef %714, ptr nonnull @current_ptr) #29
  %715 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %716 = icmp sgt i32 %708, 0
  br i1 %716, label %.lr.ph434.i, label %._crit_edge395.i

.lr.ph434.i:                                      ; preds = %683
  %invariant.gep.i = getelementptr i8, ptr %685, i64 120
  %717 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i = getelementptr ptr, ptr %invariant.gep.i, i64 %703
  br label %718

718:                                              ; preds = %740, %.lr.ph434.i
  %.reg2mem105.0432.i = phi i32 [ 0, %.lr.ph434.i ], [ %.reg2mem101.0.i, %740 ]
  %.reg2mem103.0431.i = phi i32 [ 0, %.lr.ph434.i ], [ %741, %740 ]
  store ptr @_parameterization_Ptri32, ptr %99, align 8
  %719 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %99)
  %720 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %685)
  %721 = load ptr, ptr %gep.i, align 8
  store ptr @i32_typ, ptr %100, align 8
  %722 = call ptr %721({ ptr, ptr, ptr, i32 } %692, ptr nonnull %100)
  %723 = call { ptr, i160 } %722({ ptr, ptr, ptr, i32 } %692, { ptr, ptr, ptr, i32 } %692, ptr nonnull %99, i32 %.reg2mem103.0431.i)
  %.fca.0.extract52.i = extractvalue { ptr, i160 } %723, 0
  %724 = icmp ne ptr %.fca.0.extract52.i, @nil_typ
  %725 = icmp ne ptr %.fca.0.extract52.i, null
  %.not60.i = and i1 %724, %725
  br i1 %.not60.i, label %726, label %740

726:                                              ; preds = %718
  %hash_coef_ptr.i.i137.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 8
  %tbl_size_ptr.i.i138.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 16
  %offset_tbl_ptr.i.i139.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 40
  %hash_coef.i.i140.i = load i64, ptr %hash_coef_ptr.i.i137.i, align 4
  %tbl_size.i.i141.i = load i64, ptr %tbl_size_ptr.i.i138.i, align 4
  %offset_tbl.i.i142.i = load ptr, ptr %offset_tbl_ptr.i.i139.i, align 8
  %product.i.i.i143.i = mul i64 %hash_coef.i.i140.i, 4015701072841558310
  %shifted.i.i.i144.i = lshr i64 %product.i.i.i143.i, 32
  %xored.i.i.i145.i = xor i64 %shifted.i.i.i144.i, %product.i.i.i143.i
  %hash.i.i.i146.i = and i64 %xored.i.i.i145.i, %tbl_size.i.i141.i
  %offset_ptr.i.i147.i = getelementptr i32, ptr %offset_tbl.i.i142.i, i64 %hash.i.i.i146.i
  %offset.i.i148.i = load i32, ptr %offset_ptr.i.i147.i, align 4
  %727 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %728 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %729 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %730 = icmp slt i32 %.reg2mem105.0432.i, %710
  br i1 %730, label %731, label %._crit_edge.i844

731:                                              ; preds = %726
  %.fca.1.extract54.i = extractvalue { ptr, i160 } %723, 1
  %.sroa.351.0.insert.ext.i = zext i32 %offset.i.i148.i to i160
  %.sroa.351.0.insert.shift.i = shl nuw i160 %.sroa.351.0.insert.ext.i, 128
  %732 = and i160 %.fca.1.extract54.i, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i = or disjoint i160 %.sroa.351.0.insert.shift.i, %732
  %733 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %734 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %735 = sext i32 %.reg2mem105.0432.i to i64
  %736 = shl nsw i64 %735, 5
  %737 = getelementptr i8, ptr %result.i.i.i841, i64 %736
  store ptr %.fca.0.extract52.i, ptr %737, align 8
  %738 = getelementptr i8, ptr %737, i64 8
  store i160 %.sroa.049.0.insert.insert.i, ptr %738, align 4
  br label %._crit_edge.i844

._crit_edge.i844:                                 ; preds = %731, %726
  %739 = add i32 %.reg2mem105.0432.i, 1
  br label %740

740:                                              ; preds = %._crit_edge.i844, %718
  %.reg2mem101.0.i = phi i32 [ %739, %._crit_edge.i844 ], [ %.reg2mem105.0432.i, %718 ]
  %741 = add nuw nsw i32 %.reg2mem103.0431.i, 1
  %742 = icmp slt i32 %741, %708
  br i1 %742, label %718, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %740
  %invariant.gep396.i = getelementptr i8, ptr %693, i64 120
  %743 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %744 = sext i32 %699 to i64
  %gep397.i = getelementptr ptr, ptr %invariant.gep396.i, i64 %744
  br label %745

745:                                              ; preds = %767, %.lr.ph.i
  %.reg2mem91.0394.i = phi i32 [ %.reg2mem101.0.i, %.lr.ph.i ], [ %.reg2mem87.0.i, %767 ]
  %.reg2mem89.0393.i = phi i32 [ 0, %.lr.ph.i ], [ %768, %767 ]
  store ptr @_parameterization_Ptri32, ptr %101, align 8
  %746 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %101)
  %747 = call ptr @llvm.invariant.start.p0(i64 600, ptr %693)
  %748 = load ptr, ptr %gep397.i, align 8
  store ptr @i32_typ, ptr %102, align 8
  %749 = call ptr %748({ ptr, ptr, ptr, i32 } %700, ptr nonnull %102)
  %750 = call { ptr, i160 } %749({ ptr, ptr, ptr, i32 } %700, { ptr, ptr, ptr, i32 } %700, ptr nonnull %101, i32 %.reg2mem89.0393.i)
  %.fca.0.extract42.i842 = extractvalue { ptr, i160 } %750, 0
  %751 = icmp ne ptr %.fca.0.extract42.i842, @nil_typ
  %752 = icmp ne ptr %.fca.0.extract42.i842, null
  %.not62.i = and i1 %751, %752
  br i1 %.not62.i, label %753, label %767

753:                                              ; preds = %745
  %hash_coef_ptr.i.i152.i = getelementptr i8, ptr %.fca.0.extract42.i842, i64 8
  %tbl_size_ptr.i.i153.i = getelementptr i8, ptr %.fca.0.extract42.i842, i64 16
  %offset_tbl_ptr.i.i154.i = getelementptr i8, ptr %.fca.0.extract42.i842, i64 40
  %hash_coef.i.i155.i = load i64, ptr %hash_coef_ptr.i.i152.i, align 4
  %tbl_size.i.i156.i = load i64, ptr %tbl_size_ptr.i.i153.i, align 4
  %offset_tbl.i.i157.i = load ptr, ptr %offset_tbl_ptr.i.i154.i, align 8
  %product.i.i.i158.i = mul i64 %hash_coef.i.i155.i, 4015701072841558310
  %shifted.i.i.i159.i = lshr i64 %product.i.i.i158.i, 32
  %xored.i.i.i160.i = xor i64 %shifted.i.i.i159.i, %product.i.i.i158.i
  %hash.i.i.i161.i = and i64 %xored.i.i.i160.i, %tbl_size.i.i156.i
  %offset_ptr.i.i162.i = getelementptr i32, ptr %offset_tbl.i.i157.i, i64 %hash.i.i.i161.i
  %offset.i.i163.i = load i32, ptr %offset_ptr.i.i162.i, align 4
  %754 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %755 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %756 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %757 = icmp slt i32 %.reg2mem91.0394.i, %710
  br i1 %757, label %758, label %._crit_edge1.i843

758:                                              ; preds = %753
  %.fca.1.extract44.i = extractvalue { ptr, i160 } %750, 1
  %.sroa.3.0.insert.ext.i = zext i32 %offset.i.i163.i to i160
  %.sroa.3.0.insert.shift.i = shl nuw i160 %.sroa.3.0.insert.ext.i, 128
  %759 = and i160 %.fca.1.extract44.i, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i = or disjoint i160 %.sroa.3.0.insert.shift.i, %759
  %760 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %761 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %762 = sext i32 %.reg2mem91.0394.i to i64
  %763 = shl nsw i64 %762, 5
  %764 = getelementptr i8, ptr %result.i.i.i841, i64 %763
  store ptr %.fca.0.extract42.i842, ptr %764, align 8
  %765 = getelementptr i8, ptr %764, i64 8
  store i160 %.sroa.040.0.insert.insert.i, ptr %765, align 4
  br label %._crit_edge1.i843

._crit_edge1.i843:                                ; preds = %758, %753
  %766 = add i32 %.reg2mem91.0394.i, 1
  br label %767

767:                                              ; preds = %._crit_edge1.i843, %745
  %.reg2mem87.0.i = phi i32 [ %766, %._crit_edge1.i843 ], [ %.reg2mem91.0394.i, %745 ]
  %768 = add nuw nsw i32 %.reg2mem89.0393.i, 1
  %769 = icmp slt i32 %768, %708
  br i1 %769, label %745, label %._crit_edge395.i.loopexit

._crit_edge395.i.loopexit:                        ; preds = %767
  %.pre = load ptr, ptr %result.i88, align 8
  %.pre2487 = load ptr, ptr %176, align 8
  br label %._crit_edge395.i

._crit_edge395.i:                                 ; preds = %._crit_edge395.i.loopexit, %683
  %770 = phi ptr [ %712, %683 ], [ %.pre2487, %._crit_edge395.i.loopexit ]
  %771 = phi ptr [ %711, %683 ], [ %.pre, %._crit_edge395.i.loopexit ]
  %.reg2mem91.0.lcssa.i = phi i32 [ 0, %683 ], [ %.reg2mem87.0.i, %._crit_edge395.i.loopexit ]
  %772 = call i32 @llvm.smax.i32(i32 %709, i32 16)
  %result.i166.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %773 = getelementptr i8, ptr %result.i166.i, i64 16
  store ptr @_parameterization_Nil, ptr %773, align 8
  %result.i167.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %774 = getelementptr i8, ptr %result.i167.i, i64 16
  store ptr %770, ptr %774, align 8
  %775 = getelementptr i8, ptr %result.i167.i, i64 8
  store ptr %771, ptr %775, align 8
  %776 = getelementptr i8, ptr %result.i167.i, i64 24
  store ptr null, ptr %776, align 8
  %777 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i)
  store ptr @Entry, ptr %result.i167.i, align 8
  %778 = getelementptr i8, ptr %result.i166.i, i64 8
  store ptr %result.i167.i, ptr %778, align 8
  %779 = getelementptr i8, ptr %result.i166.i, i64 24
  store ptr null, ptr %779, align 8
  %780 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i)
  store ptr @union_typ, ptr %result.i166.i, align 8
  %result.i168.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i, ptr %result.i168.i, align 8
  %781 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i)
  store ptr @Array, ptr %103, align 8
  store ptr %result.i168.i, ptr %240, align 8
  store i32 9, ptr %241, align 8
  %782 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %103)
  %783 = getelementptr i8, ptr %result.i168.i, i64 16
  store i32 %772, ptr %783, align 4
  %784 = getelementptr i8, ptr %result.i168.i, i64 20
  store i32 %772, ptr %784, align 4
  %785 = zext nneg i32 %772 to i64
  %786 = shl nuw nsw i64 %785, 5
  %result.i.i416.i = call noalias ptr @bump_malloc_inner(i64 noundef %786, ptr nonnull @current_ptr) #29
  %787 = getelementptr i8, ptr %result.i168.i, i64 8
  store ptr %result.i.i416.i, ptr %787, align 8
  %788 = load ptr, ptr %242, align 8
  store ptr @Array, ptr %193, align 8
  store ptr %result.i168.i, ptr %194, align 8
  store ptr %788, ptr %195, align 8
  store i32 9, ptr %196, align 4
  %789 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %790 = getelementptr i8, ptr %result.i183.i, i64 16
  store ptr @_parameterization_Nil, ptr %790, align 8
  %result.i184.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %791 = getelementptr i8, ptr %result.i184.i, i64 16
  store ptr %770, ptr %791, align 8
  %792 = getelementptr i8, ptr %result.i184.i, i64 8
  store ptr %771, ptr %792, align 8
  %793 = getelementptr i8, ptr %result.i184.i, i64 24
  store ptr null, ptr %793, align 8
  %794 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i)
  store ptr @Entry, ptr %result.i184.i, align 8
  %795 = getelementptr i8, ptr %result.i183.i, i64 8
  store ptr %result.i184.i, ptr %795, align 8
  %796 = getelementptr i8, ptr %result.i183.i, i64 24
  store ptr null, ptr %796, align 8
  %797 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i)
  store ptr @union_typ, ptr %result.i183.i, align 8
  %result.i185.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i, ptr %result.i185.i, align 8
  %798 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i)
  store ptr @Array, ptr %104, align 8
  store ptr %result.i185.i, ptr %243, align 8
  store i32 9, ptr %244, align 8
  %799 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %104)
  %800 = getelementptr i8, ptr %result.i185.i, i64 16
  store i32 %772, ptr %800, align 4
  %801 = getelementptr i8, ptr %result.i185.i, i64 20
  store i32 %772, ptr %801, align 4
  %result.i.i430.i = call noalias ptr @bump_malloc_inner(i64 noundef %786, ptr nonnull @current_ptr) #29
  %802 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %803 = getelementptr i8, ptr %result.i185.i, i64 8
  store ptr %result.i.i430.i, ptr %803, align 8
  %804 = load ptr, ptr %245, align 8
  store ptr @Array, ptr %211, align 8
  store ptr %result.i185.i, ptr %212, align 8
  store ptr %804, ptr %213, align 8
  store i32 9, ptr %214, align 4
  store i32 0, ptr %215, align 4
  %805 = icmp sgt i32 %.reg2mem91.0.lcssa.i, 0
  br i1 %805, label %.lr.ph400.i, label %HashMap_resize_.exit

.lr.ph400.i:                                      ; preds = %._crit_edge395.i
  %806 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %807 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %808 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %._crit_edge2.i, %.lr.ph400.i
  %.reg2mem77.0398.i = phi i32 [ 0, %.lr.ph400.i ], [ %822, %._crit_edge2.i ]
  %809 = zext nneg i32 %.reg2mem77.0398.i to i64
  %810 = shl nuw nsw i64 %809, 5
  %811 = getelementptr i8, ptr %result.i.i.i841, i64 %810
  %812 = load ptr, ptr %811, align 8
  %813 = getelementptr i8, ptr %811, i64 8
  %814 = load i160, ptr %813, align 4
  %.sroa.3362.8.extract.trunc.i = trunc i160 %814 to i64
  %815 = inttoptr i64 %.sroa.3362.8.extract.trunc.i to ptr
  %.sroa.5363.8.extract.shift.i = lshr i160 %814, 64
  %.sroa.5363.8.extract.trunc.i = trunc i160 %.sroa.5363.8.extract.shift.i to i64
  %816 = inttoptr i64 %.sroa.5363.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i201.i = getelementptr i8, ptr %812, i64 8
  %tbl_size_ptr.i.i202.i = getelementptr i8, ptr %812, i64 16
  %offset_tbl_ptr.i.i203.i = getelementptr i8, ptr %812, i64 40
  %hash_coef.i.i232.i = load i64, ptr %hash_coef_ptr.i.i201.i, align 4
  %tbl_size.i.i233.i = load i64, ptr %tbl_size_ptr.i.i202.i, align 4
  %offset_tbl.i.i234.i = load ptr, ptr %offset_tbl_ptr.i.i203.i, align 8
  %product.i.i.i235.i = mul i64 %hash_coef.i.i232.i, 4015701072841558310
  %shifted.i.i.i236.i = lshr i64 %product.i.i.i235.i, 32
  %xored.i.i.i237.i = xor i64 %shifted.i.i.i236.i, %product.i.i.i235.i
  %hash.i.i.i238.i = and i64 %xored.i.i.i237.i, %tbl_size.i.i233.i
  %offset_ptr.i.i239.i = getelementptr i32, ptr %offset_tbl.i.i234.i, i64 %hash.i.i.i238.i
  %offset.i.i240.i = load i32, ptr %offset_ptr.i.i239.i, align 4
  %817 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %812, 0
  %818 = insertvalue { ptr, ptr, ptr, i32 } %817, ptr %815, 1
  %819 = insertvalue { ptr, ptr, ptr, i32 } %818, ptr %816, 2
  %820 = insertvalue { ptr, ptr, ptr, i32 } %819, i32 %offset.i.i240.i, 3
  %821 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %248, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %820)
  %822 = add nuw nsw i32 %.reg2mem77.0398.i, 1
  %823 = icmp slt i32 %822, %.reg2mem91.0.lcssa.i
  br i1 %823, label %._crit_edge2.i, label %HashMap_resize_.exit

HashMap_resize_.exit:                             ; preds = %._crit_edge2.i, %._crit_edge395.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %99)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %100)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %101)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %102)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %103)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %104)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %HashMap_resize_.exit, %.critedge158.i
  %824 = load ptr, ptr %result.i88, align 8
  %825 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %826 = load ptr, ptr %176, align 8
  %827 = load ptr, ptr %824, align 8
  %828 = getelementptr i8, ptr %827, i64 48
  %829 = load ptr, ptr %828, align 8
  %830 = call { i64, i64 } %829(ptr nonnull %824)
  %831 = extractvalue { i64, i64 } %830, 0
  %832 = extractvalue { i64, i64 } %830, 1
  %833 = urem i64 20, %832
  %834 = icmp eq i64 %833, 0
  %835 = sub i64 %832, %833
  %836 = select i1 %834, i64 0, i64 %835
  %837 = add i64 %831, 20
  %838 = add i64 %837, %836
  %839 = load ptr, ptr %826, align 8
  %840 = getelementptr i8, ptr %839, i64 48
  %841 = load ptr, ptr %840, align 8
  %842 = call { i64, i64 } %841(ptr nonnull %826)
  %843 = extractvalue { i64, i64 } %842, 0
  %844 = extractvalue { i64, i64 } %842, 1
  %845 = call i64 @llvm.umax.i64(i64 %832, i64 %844)
  %846 = call i64 @llvm.umax.i64(i64 %845, i64 8)
  %847 = urem i64 %838, %844
  %848 = icmp eq i64 %847, 0
  %849 = sub i64 %844, %847
  %850 = select i1 %848, i64 0, i64 %849
  %851 = add i64 %843, %838
  %852 = add i64 %851, %850
  %853 = urem i64 %852, %846
  %854 = icmp eq i64 %853, 0
  %855 = sub i64 %846, %853
  %856 = select i1 %854, i64 0, i64 %855
  %857 = add i64 %856, %852
  %result.i298.i = call noalias ptr @bump_malloc_inner(i64 noundef %857, ptr nonnull @current_ptr) #29
  store ptr %824, ptr %result.i298.i, align 8
  %858 = getelementptr i8, ptr %result.i298.i, i64 8
  store ptr %826, ptr %858, align 8
  %859 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i)
  store ptr @Entry, ptr %128, align 8
  store ptr %result.i298.i, ptr %227, align 8
  store i32 9, ptr %228, align 8
  %860 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %128)
  %861 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %862 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %863 = load ptr, ptr %824, align 8
  %864 = getelementptr i8, ptr %863, i64 48
  %865 = load ptr, ptr %864, align 8
  %866 = call { i64, i64 } %865(ptr nonnull %824)
  %867 = extractvalue { i64, i64 } %866, 1
  %868 = urem i64 20, %867
  %869 = icmp eq i64 %868, 0
  %reass.sub3210 = sub i64 %867, %868
  %870 = add i64 %reass.sub3210, 20
  %871 = select i1 %869, i64 20, i64 %870
  %872 = getelementptr i8, ptr %result.i298.i, i64 %871
  %873 = load ptr, ptr %result.i298.i, align 8
  %874 = load ptr, ptr %873, align 8
  %875 = getelementptr i8, ptr %874, i64 64
  %876 = load ptr, ptr %875, align 8
  call void %876({ ptr, i160 } %278, ptr nonnull %873, ptr %872)
  %877 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %878 = load ptr, ptr %result.i298.i, align 8
  %879 = load ptr, ptr %878, align 8
  %880 = getelementptr i8, ptr %879, i64 48
  %881 = load ptr, ptr %880, align 8
  %882 = call { i64, i64 } %881(ptr nonnull %878)
  %883 = extractvalue { i64, i64 } %882, 0
  %884 = extractvalue { i64, i64 } %882, 1
  %885 = urem i64 20, %884
  %886 = icmp eq i64 %885, 0
  %887 = sub i64 %884, %885
  %888 = select i1 %886, i64 0, i64 %887
  %889 = add i64 %883, 20
  %890 = add i64 %889, %888
  %891 = load ptr, ptr %858, align 8
  %892 = load ptr, ptr %891, align 8
  %893 = getelementptr i8, ptr %892, i64 48
  %894 = load ptr, ptr %893, align 8
  %895 = call { i64, i64 } %894(ptr nonnull %891)
  %896 = extractvalue { i64, i64 } %895, 1
  %897 = urem i64 %890, %896
  %898 = icmp eq i64 %897, 0
  %899 = sub i64 %896, %897
  %900 = select i1 %898, i64 0, i64 %899
  %901 = getelementptr i8, ptr %result.i298.i, i64 %890
  %902 = getelementptr i8, ptr %901, i64 %900
  %903 = load ptr, ptr %858, align 8
  %904 = load ptr, ptr %903, align 8
  %905 = getelementptr i8, ptr %904, i64 64
  %906 = load ptr, ptr %905, align 8
  call void %906({ ptr, i160 } %287, ptr nonnull %903, ptr %902)
  %907 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %908 = getelementptr i8, ptr %result.i298.i, i64 16
  store i32 %290, ptr %908, align 4
  %909 = load ptr, ptr %229, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i845)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %98)
  store ptr @Entry, ptr %98, align 8
  store ptr %result.i298.i, ptr %249, align 8
  store ptr %909, ptr %250, align 8
  store i32 9, ptr %251, align 8
  %910 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %98)
  %911 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %912 = load i32, ptr %216, align 4
  %913 = icmp sgt i32 %912, 0
  br i1 %913, label %.lr.ph.i875, label %._crit_edge1.i

.lr.ph.i875:                                      ; preds = %._crit_edge.i
  %914 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %915 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %916

916:                                              ; preds = %.cont.cont.i, %.lr.ph.i875
  %offset.i.i260.i1486 = phi i32 [ 9, %.lr.ph.i875 ], [ %offset.i.i260.i, %.cont.cont.i ]
  %.sroa.speculated346.i1484 = phi ptr [ %909, %.lr.ph.i875 ], [ %.sroa.speculated346.i, %.cont.cont.i ]
  %.sroa.speculated352.i1482 = phi ptr [ %result.i298.i, %.lr.ph.i875 ], [ %.sroa.speculated352.i, %.cont.cont.i ]
  %.reg2mem195.0678.i = phi i32 [ 1, %.lr.ph.i875 ], [ %1072, %.cont.cont.i ]
  %.reg2mem193.0677.i = phi i32 [ 0, %.lr.ph.i875 ], [ %1073, %.cont.cont.i ]
  %917 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i1482, 1
  %918 = insertvalue { ptr, ptr, ptr, i32 } %917, ptr %.sroa.speculated346.i1484, 2
  %919 = insertvalue { ptr, ptr, ptr, i32 } %918, i32 %offset.i.i260.i1486, 3
  %920 = sext i32 %offset.i.i260.i1486 to i64
  %gep1481 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %920
  %921 = load ptr, ptr %gep1481, align 8
  %922 = call ptr %921({ ptr, ptr, ptr, i32 } %919, ptr nonnull %2)
  %923 = call i32 %922({ ptr, ptr, ptr, i32 } %919, { ptr, ptr, ptr, i32 } %919, ptr nonnull %2)
  %924 = icmp eq i32 %.reg2mem195.0678.i, 1
  %925 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %924, label %926, label %990

926:                                              ; preds = %916
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %927 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %928 = load ptr, ptr %193, align 8
  %929 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %928, 0
  %930 = load ptr, ptr %194, align 8
  %931 = insertvalue { ptr, ptr, ptr, i32 } %929, ptr %930, 1
  %932 = load ptr, ptr %195, align 8
  %933 = insertvalue { ptr, ptr, ptr, i32 } %931, ptr %932, 2
  %934 = load i32, ptr %196, align 4
  %935 = insertvalue { ptr, ptr, ptr, i32 } %933, i32 %934, 3
  %hash_coef_ptr.i.i10.i2568 = getelementptr i8, ptr %928, i64 8
  %tbl_size_ptr.i.i11.i2569 = getelementptr i8, ptr %928, i64 16
  %offset_tbl_ptr.i.i12.i2570 = getelementptr i8, ptr %928, i64 40
  %hash_coef.i.i13.i2571 = load i64, ptr %hash_coef_ptr.i.i10.i2568, align 4
  %tbl_size.i.i14.i2572 = load i64, ptr %tbl_size_ptr.i.i11.i2569, align 4
  %offset_tbl.i.i15.i2573 = load ptr, ptr %offset_tbl_ptr.i.i12.i2570, align 8
  %product.i.i.i16.i2574 = mul i64 %hash_coef.i.i13.i2571, -5261542750394134544
  %shifted.i.i.i17.i2575 = lshr i64 %product.i.i.i16.i2574, 32
  %xored.i.i.i18.i2576 = xor i64 %shifted.i.i.i17.i2575, %product.i.i.i16.i2574
  %hash.i.i.i19.i2577 = and i64 %xored.i.i.i18.i2576, %tbl_size.i.i14.i2572
  %offset_ptr.i.i20.i2578 = getelementptr i32, ptr %offset_tbl.i.i15.i2573, i64 %hash.i.i.i19.i2577
  %offset.i.i21.i2579 = load i32, ptr %offset_ptr.i.i20.i2578, align 4
  %eq.i.i2580 = icmp eq i32 %934, %offset.i.i21.i2579
  call void @llvm.assume(i1 %eq.i.i2580) #30
  %936 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %937 = call ptr @llvm.invariant.start.p0(i64 600, ptr %928)
  %938 = sext i32 %934 to i64
  %939 = getelementptr ptr, ptr %928, i64 %938
  %940 = getelementptr i8, ptr %939, i64 64
  %941 = load ptr, ptr %940, align 8
  %942 = call ptr %941({ ptr, ptr, ptr, i32 } %935, ptr nonnull %2)
  %943 = call i32 %942({ ptr, ptr, ptr, i32 } %935, { ptr, ptr, ptr, i32 } %935, ptr nonnull %2)
  %944 = add i32 %943, -1
  %945 = and i32 %944, %923
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %946 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %947 = load ptr, ptr %193, align 8
  %948 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %947, 0
  %949 = load ptr, ptr %194, align 8
  %950 = insertvalue { ptr, ptr, ptr, i32 } %948, ptr %949, 1
  %951 = load ptr, ptr %195, align 8
  %952 = insertvalue { ptr, ptr, ptr, i32 } %950, ptr %951, 2
  %953 = load i32, ptr %196, align 4
  %954 = insertvalue { ptr, ptr, ptr, i32 } %952, i32 %953, 3
  %hash_coef_ptr.i.i172.i = getelementptr i8, ptr %947, i64 8
  %tbl_size_ptr.i.i173.i = getelementptr i8, ptr %947, i64 16
  %offset_tbl_ptr.i.i174.i = getelementptr i8, ptr %947, i64 40
  %hash_coef.i.i175.i = load i64, ptr %hash_coef_ptr.i.i172.i, align 4
  %tbl_size.i.i176.i = load i64, ptr %tbl_size_ptr.i.i173.i, align 4
  %offset_tbl.i.i177.i = load ptr, ptr %offset_tbl_ptr.i.i174.i, align 8
  %product.i.i.i178.i = mul i64 %hash_coef.i.i175.i, -5261542750394134544
  %shifted.i.i.i179.i = lshr i64 %product.i.i.i178.i, 32
  %xored.i.i.i180.i = xor i64 %shifted.i.i.i179.i, %product.i.i.i178.i
  %hash.i.i.i181.i = and i64 %xored.i.i.i180.i, %tbl_size.i.i176.i
  %offset_ptr.i.i182.i = getelementptr i32, ptr %offset_tbl.i.i177.i, i64 %hash.i.i.i181.i
  %offset.i.i183.i = load i32, ptr %offset_ptr.i.i182.i, align 4
  %eq.i.i878 = icmp eq i32 %953, %offset.i.i183.i
  call void @llvm.assume(i1 %eq.i.i878) #30
  store ptr @_parameterization_Ptri32, ptr %82, align 8
  %955 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %82)
  %956 = call ptr @llvm.invariant.start.p0(i64 600, ptr %947)
  %957 = sext i32 %953 to i64
  %958 = getelementptr ptr, ptr %947, i64 %957
  %959 = getelementptr i8, ptr %958, i64 120
  %960 = load ptr, ptr %959, align 8
  store ptr @i32_typ, ptr %83, align 8
  %961 = call ptr %960({ ptr, ptr, ptr, i32 } %954, ptr nonnull %83)
  %962 = call { ptr, i160 } %961({ ptr, ptr, ptr, i32 } %954, { ptr, ptr, ptr, i32 } %954, ptr nonnull %82, i32 %945)
  %.fca.0.extract112.i = extractvalue { ptr, i160 } %962, 0
  %963 = ptrtoint ptr %.sroa.speculated352.i1482 to i64
  %964 = ptrtoint ptr %.sroa.speculated346.i1484 to i64
  %.sroa.3111.0.insert.ext.i = zext i32 %offset.i.i260.i1486 to i160
  %.sroa.3111.0.insert.shift.i = shl nuw i160 %.sroa.3111.0.insert.ext.i, 128
  %.sroa.2110.0.insert.ext.i = zext i64 %964 to i160
  %.sroa.2110.0.insert.shift.i = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i, 64
  %.sroa.2110.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.shift.i, %.sroa.3111.0.insert.shift.i
  %.sroa.0109.0.insert.ext.i = zext i64 %963 to i160
  %.sroa.0109.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.insert.i, %.sroa.0109.0.insert.ext.i
  %965 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i, 1
  %966 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %967 = load ptr, ptr %193, align 8
  %968 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %967, 0
  %969 = load ptr, ptr %194, align 8
  %970 = insertvalue { ptr, ptr, ptr, i32 } %968, ptr %969, 1
  %971 = load ptr, ptr %195, align 8
  %972 = insertvalue { ptr, ptr, ptr, i32 } %970, ptr %971, 2
  %973 = load i32, ptr %196, align 4
  %974 = insertvalue { ptr, ptr, ptr, i32 } %972, i32 %973, 3
  %hash_coef_ptr.i.i186.i = getelementptr i8, ptr %967, i64 8
  %tbl_size_ptr.i.i187.i = getelementptr i8, ptr %967, i64 16
  %offset_tbl_ptr.i.i188.i = getelementptr i8, ptr %967, i64 40
  %hash_coef.i.i189.i = load i64, ptr %hash_coef_ptr.i.i186.i, align 4
  %tbl_size.i.i190.i = load i64, ptr %tbl_size_ptr.i.i187.i, align 4
  %offset_tbl.i.i191.i = load ptr, ptr %offset_tbl_ptr.i.i188.i, align 8
  %product.i.i.i192.i = mul i64 %hash_coef.i.i189.i, -5261542750394134544
  %shifted.i.i.i193.i = lshr i64 %product.i.i.i192.i, 32
  %xored.i.i.i194.i = xor i64 %shifted.i.i.i193.i, %product.i.i.i192.i
  %hash.i.i.i195.i = and i64 %xored.i.i.i194.i, %tbl_size.i.i190.i
  %offset_ptr.i.i196.i = getelementptr i32, ptr %offset_tbl.i.i191.i, i64 %hash.i.i.i195.i
  %offset.i.i197.i = load i32, ptr %offset_ptr.i.i196.i, align 4
  %eq.i200.i = icmp eq i32 %973, %offset.i.i197.i
  call void @llvm.assume(i1 %eq.i200.i) #30
  %975 = load ptr, ptr %result.i88, align 8
  %976 = load ptr, ptr %176, align 8
  %result.i.i879 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %977 = getelementptr i8, ptr %result.i.i879, i64 16
  store ptr %976, ptr %977, align 8
  %978 = getelementptr i8, ptr %result.i.i879, i64 8
  store ptr %975, ptr %978, align 8
  %979 = getelementptr i8, ptr %result.i.i879, i64 24
  store ptr null, ptr %979, align 8
  %980 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i879)
  store ptr @Entry, ptr %result.i.i879, align 8
  store ptr @_parameterization_Ptri32, ptr %84, align 8
  store ptr %result.i.i879, ptr %254, align 8
  %981 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %84)
  %982 = call ptr @llvm.invariant.start.p0(i64 600, ptr %967)
  %983 = sext i32 %973 to i64
  %984 = getelementptr ptr, ptr %967, i64 %983
  %985 = getelementptr i8, ptr %984, i64 128
  %986 = load ptr, ptr %985, align 8
  store ptr @i32_typ, ptr %85, align 8
  store ptr @Entry, ptr %255, align 8
  %987 = call ptr %986({ ptr, ptr, ptr, i32 } %974, ptr nonnull %85)
  call void %987({ ptr, ptr, ptr, i32 } %974, { ptr, ptr, ptr, i32 } %974, ptr nonnull %84, i32 %945, { ptr, i160 } %965)
  %988 = icmp ne ptr %.fca.0.extract112.i, @nil_typ
  %989 = icmp ne ptr %.fca.0.extract112.i, null
  %.not140.i = and i1 %988, %989
  br i1 %.not140.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

990:                                              ; preds = %916
  %991 = add i32 %923, 2127912214
  %992 = shl i32 %923, 12
  %993 = add i32 %991, %992
  %994 = ashr i32 %993, 19
  %995 = xor i32 %993, %994
  %996 = xor i32 %995, -949894596
  %997 = add i32 %996, 374761393
  %998 = shl i32 %996, 5
  %999 = add i32 %997, %998
  %1000 = add i32 %999, -744332180
  %1001 = shl i32 %999, 9
  %1002 = xor i32 %1000, %1001
  %1003 = add i32 %1002, -42973499
  %1004 = shl i32 %1002, 3
  %1005 = add i32 %1003, %1004
  %1006 = ashr i32 %1005, 16
  %1007 = xor i32 %1005, %1006
  %1008 = xor i32 %1007, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1009 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1010 = load ptr, ptr %211, align 8
  %1011 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1010, 0
  %1012 = load ptr, ptr %212, align 8
  %1013 = insertvalue { ptr, ptr, ptr, i32 } %1011, ptr %1012, 1
  %1014 = load ptr, ptr %213, align 8
  %1015 = insertvalue { ptr, ptr, ptr, i32 } %1013, ptr %1014, 2
  %1016 = load i32, ptr %214, align 4
  %1017 = insertvalue { ptr, ptr, ptr, i32 } %1015, i32 %1016, 3
  %hash_coef_ptr.i.i10.i2598 = getelementptr i8, ptr %1010, i64 8
  %tbl_size_ptr.i.i11.i2599 = getelementptr i8, ptr %1010, i64 16
  %offset_tbl_ptr.i.i12.i2600 = getelementptr i8, ptr %1010, i64 40
  %hash_coef.i.i13.i2601 = load i64, ptr %hash_coef_ptr.i.i10.i2598, align 4
  %tbl_size.i.i14.i2602 = load i64, ptr %tbl_size_ptr.i.i11.i2599, align 4
  %offset_tbl.i.i15.i2603 = load ptr, ptr %offset_tbl_ptr.i.i12.i2600, align 8
  %product.i.i.i16.i2604 = mul i64 %hash_coef.i.i13.i2601, -5261542750394134544
  %shifted.i.i.i17.i2605 = lshr i64 %product.i.i.i16.i2604, 32
  %xored.i.i.i18.i2606 = xor i64 %shifted.i.i.i17.i2605, %product.i.i.i16.i2604
  %hash.i.i.i19.i2607 = and i64 %xored.i.i.i18.i2606, %tbl_size.i.i14.i2602
  %offset_ptr.i.i20.i2608 = getelementptr i32, ptr %offset_tbl.i.i15.i2603, i64 %hash.i.i.i19.i2607
  %offset.i.i21.i2609 = load i32, ptr %offset_ptr.i.i20.i2608, align 4
  %eq.i.i2610 = icmp eq i32 %1016, %offset.i.i21.i2609
  call void @llvm.assume(i1 %eq.i.i2610) #30
  %1018 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1019 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1010)
  %1020 = sext i32 %1016 to i64
  %1021 = getelementptr ptr, ptr %1010, i64 %1020
  %1022 = getelementptr i8, ptr %1021, i64 64
  %1023 = load ptr, ptr %1022, align 8
  %1024 = call ptr %1023({ ptr, ptr, ptr, i32 } %1017, ptr nonnull %2)
  %1025 = call i32 %1024({ ptr, ptr, ptr, i32 } %1017, { ptr, ptr, ptr, i32 } %1017, ptr nonnull %2)
  %1026 = add i32 %1025, -1
  %1027 = and i32 %1026, %1008
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1028 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1029 = load ptr, ptr %211, align 8
  %1030 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1029, 0
  %1031 = load ptr, ptr %212, align 8
  %1032 = insertvalue { ptr, ptr, ptr, i32 } %1030, ptr %1031, 1
  %1033 = load ptr, ptr %213, align 8
  %1034 = insertvalue { ptr, ptr, ptr, i32 } %1032, ptr %1033, 2
  %1035 = load i32, ptr %214, align 4
  %1036 = insertvalue { ptr, ptr, ptr, i32 } %1034, i32 %1035, 3
  %hash_coef_ptr.i.i202.i = getelementptr i8, ptr %1029, i64 8
  %tbl_size_ptr.i.i203.i = getelementptr i8, ptr %1029, i64 16
  %offset_tbl_ptr.i.i204.i = getelementptr i8, ptr %1029, i64 40
  %hash_coef.i.i205.i = load i64, ptr %hash_coef_ptr.i.i202.i, align 4
  %tbl_size.i.i206.i = load i64, ptr %tbl_size_ptr.i.i203.i, align 4
  %offset_tbl.i.i207.i = load ptr, ptr %offset_tbl_ptr.i.i204.i, align 8
  %product.i.i.i208.i = mul i64 %hash_coef.i.i205.i, -5261542750394134544
  %shifted.i.i.i209.i = lshr i64 %product.i.i.i208.i, 32
  %xored.i.i.i210.i = xor i64 %shifted.i.i.i209.i, %product.i.i.i208.i
  %hash.i.i.i211.i = and i64 %xored.i.i.i210.i, %tbl_size.i.i206.i
  %offset_ptr.i.i212.i = getelementptr i32, ptr %offset_tbl.i.i207.i, i64 %hash.i.i.i211.i
  %offset.i.i213.i = load i32, ptr %offset_ptr.i.i212.i, align 4
  %eq.i216.i = icmp eq i32 %1035, %offset.i.i213.i
  call void @llvm.assume(i1 %eq.i216.i) #30
  store ptr @_parameterization_Ptri32, ptr %90, align 8
  %1037 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %90)
  %1038 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1029)
  %1039 = sext i32 %1035 to i64
  %1040 = getelementptr ptr, ptr %1029, i64 %1039
  %1041 = getelementptr i8, ptr %1040, i64 120
  %1042 = load ptr, ptr %1041, align 8
  store ptr @i32_typ, ptr %91, align 8
  %1043 = call ptr %1042({ ptr, ptr, ptr, i32 } %1036, ptr nonnull %91)
  %1044 = call { ptr, i160 } %1043({ ptr, ptr, ptr, i32 } %1036, { ptr, ptr, ptr, i32 } %1036, ptr nonnull %90, i32 %1027)
  %.fca.0.extract87.i = extractvalue { ptr, i160 } %1044, 0
  %1045 = ptrtoint ptr %.sroa.speculated352.i1482 to i64
  %1046 = ptrtoint ptr %.sroa.speculated346.i1484 to i64
  %.sroa.3.0.insert.ext.i876 = zext i32 %offset.i.i260.i1486 to i160
  %.sroa.3.0.insert.shift.i877 = shl nuw i160 %.sroa.3.0.insert.ext.i876, 128
  %.sroa.2.0.insert.ext.i = zext i64 %1046 to i160
  %.sroa.2.0.insert.shift.i = shl nuw nsw i160 %.sroa.2.0.insert.ext.i, 64
  %.sroa.2.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.shift.i, %.sroa.3.0.insert.shift.i877
  %.sroa.0.0.insert.ext.i = zext i64 %1045 to i160
  %.sroa.0.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.insert.i, %.sroa.0.0.insert.ext.i
  %1047 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i, 1
  %1048 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1049 = load ptr, ptr %211, align 8
  %1050 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1049, 0
  %1051 = load ptr, ptr %212, align 8
  %1052 = insertvalue { ptr, ptr, ptr, i32 } %1050, ptr %1051, 1
  %1053 = load ptr, ptr %213, align 8
  %1054 = insertvalue { ptr, ptr, ptr, i32 } %1052, ptr %1053, 2
  %1055 = load i32, ptr %214, align 4
  %1056 = insertvalue { ptr, ptr, ptr, i32 } %1054, i32 %1055, 3
  %hash_coef_ptr.i.i218.i = getelementptr i8, ptr %1049, i64 8
  %tbl_size_ptr.i.i219.i = getelementptr i8, ptr %1049, i64 16
  %offset_tbl_ptr.i.i220.i = getelementptr i8, ptr %1049, i64 40
  %hash_coef.i.i221.i = load i64, ptr %hash_coef_ptr.i.i218.i, align 4
  %tbl_size.i.i222.i = load i64, ptr %tbl_size_ptr.i.i219.i, align 4
  %offset_tbl.i.i223.i = load ptr, ptr %offset_tbl_ptr.i.i220.i, align 8
  %product.i.i.i224.i = mul i64 %hash_coef.i.i221.i, -5261542750394134544
  %shifted.i.i.i225.i = lshr i64 %product.i.i.i224.i, 32
  %xored.i.i.i226.i = xor i64 %shifted.i.i.i225.i, %product.i.i.i224.i
  %hash.i.i.i227.i = and i64 %xored.i.i.i226.i, %tbl_size.i.i222.i
  %offset_ptr.i.i228.i = getelementptr i32, ptr %offset_tbl.i.i223.i, i64 %hash.i.i.i227.i
  %offset.i.i229.i = load i32, ptr %offset_ptr.i.i228.i, align 4
  %eq.i232.i = icmp eq i32 %1055, %offset.i.i229.i
  call void @llvm.assume(i1 %eq.i232.i) #30
  %1057 = load ptr, ptr %result.i88, align 8
  %1058 = load ptr, ptr %176, align 8
  %result.i233.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1059 = getelementptr i8, ptr %result.i233.i, i64 16
  store ptr %1058, ptr %1059, align 8
  %1060 = getelementptr i8, ptr %result.i233.i, i64 8
  store ptr %1057, ptr %1060, align 8
  %1061 = getelementptr i8, ptr %result.i233.i, i64 24
  store ptr null, ptr %1061, align 8
  %1062 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i)
  store ptr @Entry, ptr %result.i233.i, align 8
  store ptr @_parameterization_Ptri32, ptr %92, align 8
  store ptr %result.i233.i, ptr %252, align 8
  %1063 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %92)
  %1064 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1049)
  %1065 = sext i32 %1055 to i64
  %1066 = getelementptr ptr, ptr %1049, i64 %1065
  %1067 = getelementptr i8, ptr %1066, i64 128
  %1068 = load ptr, ptr %1067, align 8
  store ptr @i32_typ, ptr %93, align 8
  store ptr @Entry, ptr %253, align 8
  %1069 = call ptr %1068({ ptr, ptr, ptr, i32 } %1056, ptr nonnull %93)
  call void %1069({ ptr, ptr, ptr, i32 } %1056, { ptr, ptr, ptr, i32 } %1056, ptr nonnull %92, i32 %1027, { ptr, i160 } %1047)
  %1070 = icmp ne ptr %.fca.0.extract87.i, @nil_typ
  %1071 = icmp ne ptr %.fca.0.extract87.i, null
  %.not138.i = and i1 %1070, %1071
  br i1 %.not138.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %990, %926
  %.sink = phi { ptr, i160 } [ %962, %926 ], [ %1044, %990 ]
  %1072 = phi i32 [ 2, %926 ], [ 1, %990 ]
  %vptr.i248.sroa.speculated.i = phi ptr [ %.fca.0.extract112.i, %926 ], [ %.fca.0.extract87.i, %990 ]
  %.fca.1.extract89.i = extractvalue { ptr, i160 } %.sink, 1
  %.sroa.3407.sroa.4.0.extract.shift.i = lshr i160 %.fca.1.extract89.i, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i = trunc i160 %.fca.1.extract89.i to i64
  %.sroa.speculated352.i = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i to ptr
  %.sroa.speculated346.i = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i to ptr
  %hash_coef_ptr.i.i249.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i250.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i251.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 40
  %hash_coef.i.i252.i = load i64, ptr %hash_coef_ptr.i.i249.i, align 4
  %tbl_size.i.i253.i = load i64, ptr %tbl_size_ptr.i.i250.i, align 4
  %offset_tbl.i.i254.i = load ptr, ptr %offset_tbl_ptr.i.i251.i, align 8
  %product.i.i.i255.i = mul i64 %hash_coef.i.i252.i, 4015701072841558310
  %shifted.i.i.i256.i = lshr i64 %product.i.i.i255.i, 32
  %xored.i.i.i257.i = xor i64 %shifted.i.i.i256.i, %product.i.i.i255.i
  %hash.i.i.i258.i = and i64 %xored.i.i.i257.i, %tbl_size.i.i253.i
  %offset_ptr.i.i259.i = getelementptr i32, ptr %offset_tbl.i.i254.i, i64 %hash.i.i.i258.i
  %offset.i.i260.i = load i32, ptr %offset_ptr.i.i259.i, align 4
  store ptr %vptr.i248.sroa.speculated.i, ptr %98, align 8
  store ptr %.sroa.speculated352.i, ptr %249, align 8
  store ptr %.sroa.speculated346.i, ptr %250, align 8
  store i32 %offset.i.i260.i, ptr %251, align 8
  %1073 = add nuw nsw i32 %.reg2mem193.0677.i, 1
  %1074 = load i32, ptr %216, align 4
  %1075 = icmp slt i32 %1073, %1074
  br i1 %1075, label %916, label %._crit_edge1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %926, %990
  %1076 = phi ptr [ %94, %990 ], [ %86, %926 ]
  %1077 = phi ptr [ %95, %990 ], [ %87, %926 ]
  %1078 = phi ptr [ %96, %990 ], [ %88, %926 ]
  %1079 = phi ptr [ %.sroa.0.i845, %990 ], [ %.sroa.0680.i, %926 ]
  %1080 = phi ptr [ %97, %990 ], [ %89, %926 ]
  %1081 = load i32, ptr %215, align 4
  store i32 %1081, ptr %1076, align 4
  store i32 1, ptr %1077, align 4
  %1082 = add i32 %1081, 1
  store i32 %1082, ptr %1078, align 4
  %1083 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1082, ptr %215, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1080, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1079, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i845)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %98)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.i:                                   ; preds = %.cont.cont.i, %._crit_edge.i
  %1084 = load i160, ptr %249, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i845)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %98)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %76)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %77)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %78)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %79)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %80)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %81)
  %1085 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1086 = load ptr, ptr %193, align 8
  %1087 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1086, 0
  %1088 = load ptr, ptr %194, align 8
  %1089 = insertvalue { ptr, ptr, ptr, i32 } %1087, ptr %1088, 1
  %1090 = load ptr, ptr %195, align 8
  %1091 = insertvalue { ptr, ptr, ptr, i32 } %1089, ptr %1090, 2
  %1092 = load i32, ptr %196, align 4
  %1093 = insertvalue { ptr, ptr, ptr, i32 } %1091, i32 %1092, 3
  %hash_coef_ptr.i.i64.i899 = getelementptr i8, ptr %1086, i64 8
  %tbl_size_ptr.i.i65.i900 = getelementptr i8, ptr %1086, i64 16
  %offset_tbl_ptr.i.i66.i901 = getelementptr i8, ptr %1086, i64 40
  %hash_coef.i.i67.i902 = load i64, ptr %hash_coef_ptr.i.i64.i899, align 4
  %tbl_size.i.i68.i903 = load i64, ptr %tbl_size_ptr.i.i65.i900, align 4
  %offset_tbl.i.i69.i904 = load ptr, ptr %offset_tbl_ptr.i.i66.i901, align 8
  %product.i.i.i70.i905 = mul i64 %hash_coef.i.i67.i902, -5261542750394134544
  %shifted.i.i.i71.i906 = lshr i64 %product.i.i.i70.i905, 32
  %xored.i.i.i72.i907 = xor i64 %shifted.i.i.i71.i906, %product.i.i.i70.i905
  %hash.i.i.i73.i908 = and i64 %xored.i.i.i72.i907, %tbl_size.i.i68.i903
  %offset_ptr.i.i74.i909 = getelementptr i32, ptr %offset_tbl.i.i69.i904, i64 %hash.i.i.i73.i908
  %offset.i.i75.i910 = load i32, ptr %offset_ptr.i.i74.i909, align 4
  %eq.i.i911 = icmp eq i32 %1092, %offset.i.i75.i910
  call void @llvm.assume(i1 %eq.i.i911) #30
  %1094 = load ptr, ptr %211, align 8
  %1095 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1094, 0
  %1096 = load ptr, ptr %212, align 8
  %1097 = insertvalue { ptr, ptr, ptr, i32 } %1095, ptr %1096, 1
  %1098 = load ptr, ptr %213, align 8
  %1099 = insertvalue { ptr, ptr, ptr, i32 } %1097, ptr %1098, 2
  %1100 = load i32, ptr %214, align 4
  %1101 = insertvalue { ptr, ptr, ptr, i32 } %1099, i32 %1100, 3
  %hash_coef_ptr.i.i92.i916 = getelementptr i8, ptr %1094, i64 8
  %tbl_size_ptr.i.i93.i917 = getelementptr i8, ptr %1094, i64 16
  %offset_tbl_ptr.i.i94.i918 = getelementptr i8, ptr %1094, i64 40
  %hash_coef.i.i95.i919 = load i64, ptr %hash_coef_ptr.i.i92.i916, align 4
  %tbl_size.i.i96.i920 = load i64, ptr %tbl_size_ptr.i.i93.i917, align 4
  %offset_tbl.i.i97.i921 = load ptr, ptr %offset_tbl_ptr.i.i94.i918, align 8
  %product.i.i.i98.i922 = mul i64 %hash_coef.i.i95.i919, -5261542750394134544
  %shifted.i.i.i99.i923 = lshr i64 %product.i.i.i98.i922, 32
  %xored.i.i.i100.i924 = xor i64 %shifted.i.i.i99.i923, %product.i.i.i98.i922
  %hash.i.i.i101.i925 = and i64 %xored.i.i.i100.i924, %tbl_size.i.i96.i920
  %offset_ptr.i.i102.i926 = getelementptr i32, ptr %offset_tbl.i.i97.i921, i64 %hash.i.i.i101.i925
  %offset.i.i103.i927 = load i32, ptr %offset_ptr.i.i102.i926, align 4
  %eq.i106.i928 = icmp eq i32 %1100, %offset.i.i103.i927
  call void @llvm.assume(i1 %eq.i106.i928) #30
  %1102 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1103 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1086)
  %1104 = sext i32 %1092 to i64
  %1105 = getelementptr ptr, ptr %1086, i64 %1104
  %1106 = getelementptr i8, ptr %1105, i64 64
  %1107 = load ptr, ptr %1106, align 8
  %1108 = call ptr %1107({ ptr, ptr, ptr, i32 } %1093, ptr nonnull %2)
  %1109 = call i32 %1108({ ptr, ptr, ptr, i32 } %1093, { ptr, ptr, ptr, i32 } %1093, ptr nonnull %2)
  %1110 = shl i32 %1109, 1
  %1111 = load i32, ptr %215, align 4
  %1112 = load ptr, ptr %result.i88, align 8
  %1113 = load ptr, ptr %176, align 8
  %1114 = sext i32 %1111 to i64
  %1115 = shl nsw i64 %1114, 5
  %result.i.i.i931 = call noalias ptr @bump_malloc_inner(i64 noundef %1115, ptr nonnull @current_ptr) #29
  %1116 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1117 = icmp sgt i32 %1109, 0
  br i1 %1117, label %.lr.ph434.i1001, label %._crit_edge395.i945

.lr.ph434.i1001:                                  ; preds = %._crit_edge1.i
  %invariant.gep.i944 = getelementptr i8, ptr %1086, i64 120
  %1118 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1004 = getelementptr ptr, ptr %invariant.gep.i944, i64 %1104
  br label %1119

1119:                                             ; preds = %1141, %.lr.ph434.i1001
  %.reg2mem105.0432.i1002 = phi i32 [ 0, %.lr.ph434.i1001 ], [ %.reg2mem101.0.i1007, %1141 ]
  %.reg2mem103.0431.i1003 = phi i32 [ 0, %.lr.ph434.i1001 ], [ %1142, %1141 ]
  store ptr @_parameterization_Ptri32, ptr %76, align 8
  %1120 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %76)
  %1121 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1086)
  %1122 = load ptr, ptr %gep.i1004, align 8
  store ptr @i32_typ, ptr %77, align 8
  %1123 = call ptr %1122({ ptr, ptr, ptr, i32 } %1093, ptr nonnull %77)
  %1124 = call { ptr, i160 } %1123({ ptr, ptr, ptr, i32 } %1093, { ptr, ptr, ptr, i32 } %1093, ptr nonnull %76, i32 %.reg2mem103.0431.i1003)
  %.fca.0.extract52.i1005 = extractvalue { ptr, i160 } %1124, 0
  %1125 = icmp ne ptr %.fca.0.extract52.i1005, @nil_typ
  %1126 = icmp ne ptr %.fca.0.extract52.i1005, null
  %.not60.i1006 = and i1 %1125, %1126
  br i1 %.not60.i1006, label %1127, label %1141

1127:                                             ; preds = %1119
  %hash_coef_ptr.i.i137.i1034 = getelementptr i8, ptr %.fca.0.extract52.i1005, i64 8
  %tbl_size_ptr.i.i138.i1035 = getelementptr i8, ptr %.fca.0.extract52.i1005, i64 16
  %offset_tbl_ptr.i.i139.i1036 = getelementptr i8, ptr %.fca.0.extract52.i1005, i64 40
  %hash_coef.i.i140.i1037 = load i64, ptr %hash_coef_ptr.i.i137.i1034, align 4
  %tbl_size.i.i141.i1038 = load i64, ptr %tbl_size_ptr.i.i138.i1035, align 4
  %offset_tbl.i.i142.i1039 = load ptr, ptr %offset_tbl_ptr.i.i139.i1036, align 8
  %product.i.i.i143.i1040 = mul i64 %hash_coef.i.i140.i1037, 4015701072841558310
  %shifted.i.i.i144.i1041 = lshr i64 %product.i.i.i143.i1040, 32
  %xored.i.i.i145.i1042 = xor i64 %shifted.i.i.i144.i1041, %product.i.i.i143.i1040
  %hash.i.i.i146.i1043 = and i64 %xored.i.i.i145.i1042, %tbl_size.i.i141.i1038
  %offset_ptr.i.i147.i1044 = getelementptr i32, ptr %offset_tbl.i.i142.i1039, i64 %hash.i.i.i146.i1043
  %offset.i.i148.i1045 = load i32, ptr %offset_ptr.i.i147.i1044, align 4
  %1128 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1129 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1130 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1131 = icmp slt i32 %.reg2mem105.0432.i1002, %1111
  br i1 %1131, label %1132, label %._crit_edge.i1046

1132:                                             ; preds = %1127
  %.fca.1.extract54.i1047 = extractvalue { ptr, i160 } %1124, 1
  %.sroa.351.0.insert.ext.i1048 = zext i32 %offset.i.i148.i1045 to i160
  %.sroa.351.0.insert.shift.i1049 = shl nuw i160 %.sroa.351.0.insert.ext.i1048, 128
  %1133 = and i160 %.fca.1.extract54.i1047, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1050 = or disjoint i160 %.sroa.351.0.insert.shift.i1049, %1133
  %1134 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1135 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1136 = sext i32 %.reg2mem105.0432.i1002 to i64
  %1137 = shl nsw i64 %1136, 5
  %1138 = getelementptr i8, ptr %result.i.i.i931, i64 %1137
  store ptr %.fca.0.extract52.i1005, ptr %1138, align 8
  %1139 = getelementptr i8, ptr %1138, i64 8
  store i160 %.sroa.049.0.insert.insert.i1050, ptr %1139, align 4
  br label %._crit_edge.i1046

._crit_edge.i1046:                                ; preds = %1132, %1127
  %1140 = add i32 %.reg2mem105.0432.i1002, 1
  br label %1141

1141:                                             ; preds = %._crit_edge.i1046, %1119
  %.reg2mem101.0.i1007 = phi i32 [ %1140, %._crit_edge.i1046 ], [ %.reg2mem105.0432.i1002, %1119 ]
  %1142 = add nuw nsw i32 %.reg2mem103.0431.i1003, 1
  %1143 = icmp slt i32 %1142, %1109
  br i1 %1143, label %1119, label %.lr.ph.i1008

.lr.ph.i1008:                                     ; preds = %1141
  %invariant.gep396.i1009 = getelementptr i8, ptr %1094, i64 120
  %1144 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1145 = sext i32 %1100 to i64
  %gep397.i1012 = getelementptr ptr, ptr %invariant.gep396.i1009, i64 %1145
  br label %1146

1146:                                             ; preds = %1168, %.lr.ph.i1008
  %.reg2mem91.0394.i1010 = phi i32 [ %.reg2mem101.0.i1007, %.lr.ph.i1008 ], [ %.reg2mem87.0.i1015, %1168 ]
  %.reg2mem89.0393.i1011 = phi i32 [ 0, %.lr.ph.i1008 ], [ %1169, %1168 ]
  store ptr @_parameterization_Ptri32, ptr %78, align 8
  %1147 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %78)
  %1148 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1094)
  %1149 = load ptr, ptr %gep397.i1012, align 8
  store ptr @i32_typ, ptr %79, align 8
  %1150 = call ptr %1149({ ptr, ptr, ptr, i32 } %1101, ptr nonnull %79)
  %1151 = call { ptr, i160 } %1150({ ptr, ptr, ptr, i32 } %1101, { ptr, ptr, ptr, i32 } %1101, ptr nonnull %78, i32 %.reg2mem89.0393.i1011)
  %.fca.0.extract42.i1013 = extractvalue { ptr, i160 } %1151, 0
  %1152 = icmp ne ptr %.fca.0.extract42.i1013, @nil_typ
  %1153 = icmp ne ptr %.fca.0.extract42.i1013, null
  %.not62.i1014 = and i1 %1152, %1153
  br i1 %.not62.i1014, label %1154, label %1168

1154:                                             ; preds = %1146
  %hash_coef_ptr.i.i152.i1016 = getelementptr i8, ptr %.fca.0.extract42.i1013, i64 8
  %tbl_size_ptr.i.i153.i1017 = getelementptr i8, ptr %.fca.0.extract42.i1013, i64 16
  %offset_tbl_ptr.i.i154.i1018 = getelementptr i8, ptr %.fca.0.extract42.i1013, i64 40
  %hash_coef.i.i155.i1019 = load i64, ptr %hash_coef_ptr.i.i152.i1016, align 4
  %tbl_size.i.i156.i1020 = load i64, ptr %tbl_size_ptr.i.i153.i1017, align 4
  %offset_tbl.i.i157.i1021 = load ptr, ptr %offset_tbl_ptr.i.i154.i1018, align 8
  %product.i.i.i158.i1022 = mul i64 %hash_coef.i.i155.i1019, 4015701072841558310
  %shifted.i.i.i159.i1023 = lshr i64 %product.i.i.i158.i1022, 32
  %xored.i.i.i160.i1024 = xor i64 %shifted.i.i.i159.i1023, %product.i.i.i158.i1022
  %hash.i.i.i161.i1025 = and i64 %xored.i.i.i160.i1024, %tbl_size.i.i156.i1020
  %offset_ptr.i.i162.i1026 = getelementptr i32, ptr %offset_tbl.i.i157.i1021, i64 %hash.i.i.i161.i1025
  %offset.i.i163.i1027 = load i32, ptr %offset_ptr.i.i162.i1026, align 4
  %1155 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1156 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1157 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1158 = icmp slt i32 %.reg2mem91.0394.i1010, %1111
  br i1 %1158, label %1159, label %._crit_edge1.i1028

1159:                                             ; preds = %1154
  %.fca.1.extract44.i1029 = extractvalue { ptr, i160 } %1151, 1
  %.sroa.3.0.insert.ext.i1030 = zext i32 %offset.i.i163.i1027 to i160
  %.sroa.3.0.insert.shift.i1031 = shl nuw i160 %.sroa.3.0.insert.ext.i1030, 128
  %1160 = and i160 %.fca.1.extract44.i1029, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1032 = or disjoint i160 %.sroa.3.0.insert.shift.i1031, %1160
  %1161 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1162 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1163 = sext i32 %.reg2mem91.0394.i1010 to i64
  %1164 = shl nsw i64 %1163, 5
  %1165 = getelementptr i8, ptr %result.i.i.i931, i64 %1164
  store ptr %.fca.0.extract42.i1013, ptr %1165, align 8
  %1166 = getelementptr i8, ptr %1165, i64 8
  store i160 %.sroa.040.0.insert.insert.i1032, ptr %1166, align 4
  br label %._crit_edge1.i1028

._crit_edge1.i1028:                               ; preds = %1159, %1154
  %1167 = add i32 %.reg2mem91.0394.i1010, 1
  br label %1168

1168:                                             ; preds = %._crit_edge1.i1028, %1146
  %.reg2mem87.0.i1015 = phi i32 [ %1167, %._crit_edge1.i1028 ], [ %.reg2mem91.0394.i1010, %1146 ]
  %1169 = add nuw nsw i32 %.reg2mem89.0393.i1011, 1
  %1170 = icmp slt i32 %1169, %1109
  br i1 %1170, label %1146, label %._crit_edge395.i945.loopexit

._crit_edge395.i945.loopexit:                     ; preds = %1168
  %.pre2488 = load ptr, ptr %result.i88, align 8
  %.pre2489 = load ptr, ptr %176, align 8
  br label %._crit_edge395.i945

._crit_edge395.i945:                              ; preds = %._crit_edge395.i945.loopexit, %._crit_edge1.i
  %1171 = phi ptr [ %1113, %._crit_edge1.i ], [ %.pre2489, %._crit_edge395.i945.loopexit ]
  %1172 = phi ptr [ %1112, %._crit_edge1.i ], [ %.pre2488, %._crit_edge395.i945.loopexit ]
  %.reg2mem91.0.lcssa.i946 = phi i32 [ 0, %._crit_edge1.i ], [ %.reg2mem87.0.i1015, %._crit_edge395.i945.loopexit ]
  %1173 = call i32 @llvm.smax.i32(i32 %1110, i32 16)
  %result.i166.i947 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1174 = getelementptr i8, ptr %result.i166.i947, i64 16
  store ptr @_parameterization_Nil, ptr %1174, align 8
  %result.i167.i948 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1175 = getelementptr i8, ptr %result.i167.i948, i64 16
  store ptr %1171, ptr %1175, align 8
  %1176 = getelementptr i8, ptr %result.i167.i948, i64 8
  store ptr %1172, ptr %1176, align 8
  %1177 = getelementptr i8, ptr %result.i167.i948, i64 24
  store ptr null, ptr %1177, align 8
  %1178 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i948)
  store ptr @Entry, ptr %result.i167.i948, align 8
  %1179 = getelementptr i8, ptr %result.i166.i947, i64 8
  store ptr %result.i167.i948, ptr %1179, align 8
  %1180 = getelementptr i8, ptr %result.i166.i947, i64 24
  store ptr null, ptr %1180, align 8
  %1181 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i947)
  store ptr @union_typ, ptr %result.i166.i947, align 8
  %result.i168.i949 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i947, ptr %result.i168.i949, align 8
  %1182 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i949)
  store ptr @Array, ptr %80, align 8
  store ptr %result.i168.i949, ptr %256, align 8
  store i32 9, ptr %257, align 8
  %1183 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %80)
  %1184 = getelementptr i8, ptr %result.i168.i949, i64 16
  store i32 %1173, ptr %1184, align 4
  %1185 = getelementptr i8, ptr %result.i168.i949, i64 20
  store i32 %1173, ptr %1185, align 4
  %1186 = zext nneg i32 %1173 to i64
  %1187 = shl nuw nsw i64 %1186, 5
  %result.i.i416.i950 = call noalias ptr @bump_malloc_inner(i64 noundef %1187, ptr nonnull @current_ptr) #29
  %1188 = getelementptr i8, ptr %result.i168.i949, i64 8
  store ptr %result.i.i416.i950, ptr %1188, align 8
  %1189 = load ptr, ptr %258, align 8
  store ptr @Array, ptr %193, align 8
  store ptr %result.i168.i949, ptr %194, align 8
  store ptr %1189, ptr %195, align 8
  store i32 9, ptr %196, align 4
  %1190 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i963 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1191 = getelementptr i8, ptr %result.i183.i963, i64 16
  store ptr @_parameterization_Nil, ptr %1191, align 8
  %result.i184.i964 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1192 = getelementptr i8, ptr %result.i184.i964, i64 16
  store ptr %1171, ptr %1192, align 8
  %1193 = getelementptr i8, ptr %result.i184.i964, i64 8
  store ptr %1172, ptr %1193, align 8
  %1194 = getelementptr i8, ptr %result.i184.i964, i64 24
  store ptr null, ptr %1194, align 8
  %1195 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i964)
  store ptr @Entry, ptr %result.i184.i964, align 8
  %1196 = getelementptr i8, ptr %result.i183.i963, i64 8
  store ptr %result.i184.i964, ptr %1196, align 8
  %1197 = getelementptr i8, ptr %result.i183.i963, i64 24
  store ptr null, ptr %1197, align 8
  %1198 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i963)
  store ptr @union_typ, ptr %result.i183.i963, align 8
  %result.i185.i965 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i963, ptr %result.i185.i965, align 8
  %1199 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i965)
  store ptr @Array, ptr %81, align 8
  store ptr %result.i185.i965, ptr %259, align 8
  store i32 9, ptr %260, align 8
  %1200 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %81)
  %1201 = getelementptr i8, ptr %result.i185.i965, i64 16
  store i32 %1173, ptr %1201, align 4
  %1202 = getelementptr i8, ptr %result.i185.i965, i64 20
  store i32 %1173, ptr %1202, align 4
  %result.i.i430.i966 = call noalias ptr @bump_malloc_inner(i64 noundef %1187, ptr nonnull @current_ptr) #29
  %1203 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1204 = getelementptr i8, ptr %result.i185.i965, i64 8
  store ptr %result.i.i430.i966, ptr %1204, align 8
  %1205 = load ptr, ptr %261, align 8
  store ptr @Array, ptr %211, align 8
  store ptr %result.i185.i965, ptr %212, align 8
  store ptr %1205, ptr %213, align 8
  store i32 9, ptr %214, align 4
  store i32 0, ptr %215, align 4
  %1206 = icmp sgt i32 %.reg2mem91.0.lcssa.i946, 0
  br i1 %1206, label %.lr.ph400.i979, label %HashMap_resize_.exit1052

.lr.ph400.i979:                                   ; preds = %._crit_edge395.i945
  %1207 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1208 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1209 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i981

._crit_edge2.i981:                                ; preds = %._crit_edge2.i981, %.lr.ph400.i979
  %.reg2mem77.0398.i982 = phi i32 [ 0, %.lr.ph400.i979 ], [ %1223, %._crit_edge2.i981 ]
  %1210 = zext nneg i32 %.reg2mem77.0398.i982 to i64
  %1211 = shl nuw nsw i64 %1210, 5
  %1212 = getelementptr i8, ptr %result.i.i.i931, i64 %1211
  %1213 = load ptr, ptr %1212, align 8
  %1214 = getelementptr i8, ptr %1212, i64 8
  %1215 = load i160, ptr %1214, align 4
  %.sroa.3362.8.extract.trunc.i985 = trunc i160 %1215 to i64
  %1216 = inttoptr i64 %.sroa.3362.8.extract.trunc.i985 to ptr
  %.sroa.5363.8.extract.shift.i986 = lshr i160 %1215, 64
  %.sroa.5363.8.extract.trunc.i987 = trunc i160 %.sroa.5363.8.extract.shift.i986 to i64
  %1217 = inttoptr i64 %.sroa.5363.8.extract.trunc.i987 to ptr
  %hash_coef_ptr.i.i201.i988 = getelementptr i8, ptr %1213, i64 8
  %tbl_size_ptr.i.i202.i989 = getelementptr i8, ptr %1213, i64 16
  %offset_tbl_ptr.i.i203.i990 = getelementptr i8, ptr %1213, i64 40
  %hash_coef.i.i232.i991 = load i64, ptr %hash_coef_ptr.i.i201.i988, align 4
  %tbl_size.i.i233.i992 = load i64, ptr %tbl_size_ptr.i.i202.i989, align 4
  %offset_tbl.i.i234.i993 = load ptr, ptr %offset_tbl_ptr.i.i203.i990, align 8
  %product.i.i.i235.i994 = mul i64 %hash_coef.i.i232.i991, 4015701072841558310
  %shifted.i.i.i236.i995 = lshr i64 %product.i.i.i235.i994, 32
  %xored.i.i.i237.i996 = xor i64 %shifted.i.i.i236.i995, %product.i.i.i235.i994
  %hash.i.i.i238.i997 = and i64 %xored.i.i.i237.i996, %tbl_size.i.i233.i992
  %offset_ptr.i.i239.i998 = getelementptr i32, ptr %offset_tbl.i.i234.i993, i64 %hash.i.i.i238.i997
  %offset.i.i240.i999 = load i32, ptr %offset_ptr.i.i239.i998, align 4
  %1218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1213, 0
  %1219 = insertvalue { ptr, ptr, ptr, i32 } %1218, ptr %1216, 1
  %1220 = insertvalue { ptr, ptr, ptr, i32 } %1219, ptr %1217, 2
  %1221 = insertvalue { ptr, ptr, ptr, i32 } %1220, i32 %offset.i.i240.i999, 3
  %1222 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %248, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1221)
  %1223 = add nuw nsw i32 %.reg2mem77.0398.i982, 1
  %1224 = icmp slt i32 %1223, %.reg2mem91.0.lcssa.i946
  br i1 %1224, label %._crit_edge2.i981, label %HashMap_resize_.exit1052

HashMap_resize_.exit1052:                         ; preds = %._crit_edge2.i981, %._crit_edge395.i945
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %76)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %77)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %78)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %79)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %80)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %81)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i1053)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1055)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %75)
  %1225 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1226 = load i32, ptr %216, align 4
  %1227 = icmp sgt i32 %1226, 0
  br i1 %1227, label %.lr.ph.i1090, label %._crit_edge1.1.i

.lr.ph.i1090:                                     ; preds = %HashMap_resize_.exit1052
  %1228 = lshr i160 %1084, 64
  %1229 = insertelement <2 x i160> poison, i160 %1228, i64 0
  %1230 = insertelement <2 x i160> %1229, i160 %1084, i64 1
  %1231 = trunc <2 x i160> %1230 to <2 x i64>
  %1232 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1233 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1234

1234:                                             ; preds = %.cont.cont.i1144, %.lr.ph.i1090
  %offset.i.i260.i11611494 = phi i32 [ 9, %.lr.ph.i1090 ], [ %offset.i.i260.i1161, %.cont.cont.i1144 ]
  %.reg2mem195.0678.i1092 = phi i32 [ 1, %.lr.ph.i1090 ], [ %1389, %.cont.cont.i1144 ]
  %.reg2mem193.0677.i1093 = phi i32 [ 0, %.lr.ph.i1090 ], [ %1394, %.cont.cont.i1144 ]
  %1235 = phi <2 x i64> [ %1231, %.lr.ph.i1090 ], [ %1393, %.cont.cont.i1144 ]
  %1236 = extractelement <2 x i64> %1235, i64 1
  %.sroa.speculated352.i11481490 = inttoptr i64 %1236 to ptr
  %1237 = extractelement <2 x i64> %1235, i64 0
  %.sroa.speculated346.i11491492 = inttoptr i64 %1237 to ptr
  %1238 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i11481490, 1
  %1239 = insertvalue { ptr, ptr, ptr, i32 } %1238, ptr %.sroa.speculated346.i11491492, 2
  %1240 = insertvalue { ptr, ptr, ptr, i32 } %1239, i32 %offset.i.i260.i11611494, 3
  %1241 = sext i32 %offset.i.i260.i11611494 to i64
  %gep1488 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1241
  %1242 = load ptr, ptr %gep1488, align 8
  %1243 = call ptr %1242({ ptr, ptr, ptr, i32 } %1240, ptr nonnull %2)
  %1244 = call i32 %1243({ ptr, ptr, ptr, i32 } %1240, { ptr, ptr, ptr, i32 } %1240, ptr nonnull %2)
  %1245 = icmp eq i32 %.reg2mem195.0678.i1092, 1
  %1246 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1245, label %1247, label %1309

1247:                                             ; preds = %1234
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1248 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1249 = load ptr, ptr %193, align 8
  %1250 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1249, 0
  %1251 = load ptr, ptr %194, align 8
  %1252 = insertvalue { ptr, ptr, ptr, i32 } %1250, ptr %1251, 1
  %1253 = load ptr, ptr %195, align 8
  %1254 = insertvalue { ptr, ptr, ptr, i32 } %1252, ptr %1253, 2
  %1255 = load i32, ptr %196, align 4
  %1256 = insertvalue { ptr, ptr, ptr, i32 } %1254, i32 %1255, 3
  %hash_coef_ptr.i.i10.i2701 = getelementptr i8, ptr %1249, i64 8
  %tbl_size_ptr.i.i11.i2702 = getelementptr i8, ptr %1249, i64 16
  %offset_tbl_ptr.i.i12.i2703 = getelementptr i8, ptr %1249, i64 40
  %hash_coef.i.i13.i2704 = load i64, ptr %hash_coef_ptr.i.i10.i2701, align 4
  %tbl_size.i.i14.i2705 = load i64, ptr %tbl_size_ptr.i.i11.i2702, align 4
  %offset_tbl.i.i15.i2706 = load ptr, ptr %offset_tbl_ptr.i.i12.i2703, align 8
  %product.i.i.i16.i2707 = mul i64 %hash_coef.i.i13.i2704, -5261542750394134544
  %shifted.i.i.i17.i2708 = lshr i64 %product.i.i.i16.i2707, 32
  %xored.i.i.i18.i2709 = xor i64 %shifted.i.i.i17.i2708, %product.i.i.i16.i2707
  %hash.i.i.i19.i2710 = and i64 %xored.i.i.i18.i2709, %tbl_size.i.i14.i2705
  %offset_ptr.i.i20.i2711 = getelementptr i32, ptr %offset_tbl.i.i15.i2706, i64 %hash.i.i.i19.i2710
  %offset.i.i21.i2712 = load i32, ptr %offset_ptr.i.i20.i2711, align 4
  %eq.i.i2713 = icmp eq i32 %1255, %offset.i.i21.i2712
  call void @llvm.assume(i1 %eq.i.i2713) #30
  %1257 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1258 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1249)
  %1259 = sext i32 %1255 to i64
  %1260 = getelementptr ptr, ptr %1249, i64 %1259
  %1261 = getelementptr i8, ptr %1260, i64 64
  %1262 = load ptr, ptr %1261, align 8
  %1263 = call ptr %1262({ ptr, ptr, ptr, i32 } %1256, ptr nonnull %2)
  %1264 = call i32 %1263({ ptr, ptr, ptr, i32 } %1256, { ptr, ptr, ptr, i32 } %1256, ptr nonnull %2)
  %1265 = add i32 %1264, -1
  %1266 = and i32 %1265, %1244
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1267 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1268 = load ptr, ptr %193, align 8
  %1269 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1268, 0
  %1270 = load ptr, ptr %194, align 8
  %1271 = insertvalue { ptr, ptr, ptr, i32 } %1269, ptr %1270, 1
  %1272 = load ptr, ptr %195, align 8
  %1273 = insertvalue { ptr, ptr, ptr, i32 } %1271, ptr %1272, 2
  %1274 = load i32, ptr %196, align 4
  %1275 = insertvalue { ptr, ptr, ptr, i32 } %1273, i32 %1274, 3
  %hash_coef_ptr.i.i172.i1166 = getelementptr i8, ptr %1268, i64 8
  %tbl_size_ptr.i.i173.i1167 = getelementptr i8, ptr %1268, i64 16
  %offset_tbl_ptr.i.i174.i1168 = getelementptr i8, ptr %1268, i64 40
  %hash_coef.i.i175.i1169 = load i64, ptr %hash_coef_ptr.i.i172.i1166, align 4
  %tbl_size.i.i176.i1170 = load i64, ptr %tbl_size_ptr.i.i173.i1167, align 4
  %offset_tbl.i.i177.i1171 = load ptr, ptr %offset_tbl_ptr.i.i174.i1168, align 8
  %product.i.i.i178.i1172 = mul i64 %hash_coef.i.i175.i1169, -5261542750394134544
  %shifted.i.i.i179.i1173 = lshr i64 %product.i.i.i178.i1172, 32
  %xored.i.i.i180.i1174 = xor i64 %shifted.i.i.i179.i1173, %product.i.i.i178.i1172
  %hash.i.i.i181.i1175 = and i64 %xored.i.i.i180.i1174, %tbl_size.i.i176.i1170
  %offset_ptr.i.i182.i1176 = getelementptr i32, ptr %offset_tbl.i.i177.i1171, i64 %hash.i.i.i181.i1175
  %offset.i.i183.i1177 = load i32, ptr %offset_ptr.i.i182.i1176, align 4
  %eq.i.i1178 = icmp eq i32 %1274, %offset.i.i183.i1177
  call void @llvm.assume(i1 %eq.i.i1178) #30
  store ptr @_parameterization_Ptri32, ptr %60, align 8
  %1276 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %60)
  %1277 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1268)
  %1278 = sext i32 %1274 to i64
  %1279 = getelementptr ptr, ptr %1268, i64 %1278
  %1280 = getelementptr i8, ptr %1279, i64 120
  %1281 = load ptr, ptr %1280, align 8
  store ptr @i32_typ, ptr %61, align 8
  %1282 = call ptr %1281({ ptr, ptr, ptr, i32 } %1275, ptr nonnull %61)
  %1283 = call { ptr, i160 } %1282({ ptr, ptr, ptr, i32 } %1275, { ptr, ptr, ptr, i32 } %1275, ptr nonnull %60, i32 %1266)
  %.fca.0.extract112.i1179 = extractvalue { ptr, i160 } %1283, 0
  %.sroa.3111.0.insert.ext.i1180 = zext i32 %offset.i.i260.i11611494 to i160
  %.sroa.3111.0.insert.shift.i1181 = shl nuw i160 %.sroa.3111.0.insert.ext.i1180, 128
  %.sroa.2110.0.insert.ext.i1182 = zext i64 %1237 to i160
  %.sroa.2110.0.insert.shift.i1183 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i1182, 64
  %.sroa.2110.0.insert.insert.i1184 = or disjoint i160 %.sroa.2110.0.insert.shift.i1183, %.sroa.3111.0.insert.shift.i1181
  %.sroa.0109.0.insert.ext.i1185 = zext i64 %1236 to i160
  %.sroa.0109.0.insert.insert.i1186 = or disjoint i160 %.sroa.2110.0.insert.insert.i1184, %.sroa.0109.0.insert.ext.i1185
  %1284 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i1186, 1
  %1285 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1286 = load ptr, ptr %193, align 8
  %1287 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1286, 0
  %1288 = load ptr, ptr %194, align 8
  %1289 = insertvalue { ptr, ptr, ptr, i32 } %1287, ptr %1288, 1
  %1290 = load ptr, ptr %195, align 8
  %1291 = insertvalue { ptr, ptr, ptr, i32 } %1289, ptr %1290, 2
  %1292 = load i32, ptr %196, align 4
  %1293 = insertvalue { ptr, ptr, ptr, i32 } %1291, i32 %1292, 3
  %hash_coef_ptr.i.i186.i1191 = getelementptr i8, ptr %1286, i64 8
  %tbl_size_ptr.i.i187.i1192 = getelementptr i8, ptr %1286, i64 16
  %offset_tbl_ptr.i.i188.i1193 = getelementptr i8, ptr %1286, i64 40
  %hash_coef.i.i189.i1194 = load i64, ptr %hash_coef_ptr.i.i186.i1191, align 4
  %tbl_size.i.i190.i1195 = load i64, ptr %tbl_size_ptr.i.i187.i1192, align 4
  %offset_tbl.i.i191.i1196 = load ptr, ptr %offset_tbl_ptr.i.i188.i1193, align 8
  %product.i.i.i192.i1197 = mul i64 %hash_coef.i.i189.i1194, -5261542750394134544
  %shifted.i.i.i193.i1198 = lshr i64 %product.i.i.i192.i1197, 32
  %xored.i.i.i194.i1199 = xor i64 %shifted.i.i.i193.i1198, %product.i.i.i192.i1197
  %hash.i.i.i195.i1200 = and i64 %xored.i.i.i194.i1199, %tbl_size.i.i190.i1195
  %offset_ptr.i.i196.i1201 = getelementptr i32, ptr %offset_tbl.i.i191.i1196, i64 %hash.i.i.i195.i1200
  %offset.i.i197.i1202 = load i32, ptr %offset_ptr.i.i196.i1201, align 4
  %eq.i200.i1203 = icmp eq i32 %1292, %offset.i.i197.i1202
  call void @llvm.assume(i1 %eq.i200.i1203) #30
  %1294 = load ptr, ptr %result.i88, align 8
  %1295 = load ptr, ptr %176, align 8
  %result.i.i1204 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1296 = getelementptr i8, ptr %result.i.i1204, i64 16
  store ptr %1295, ptr %1296, align 8
  %1297 = getelementptr i8, ptr %result.i.i1204, i64 8
  store ptr %1294, ptr %1297, align 8
  %1298 = getelementptr i8, ptr %result.i.i1204, i64 24
  store ptr null, ptr %1298, align 8
  %1299 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1204)
  store ptr @Entry, ptr %result.i.i1204, align 8
  store ptr @_parameterization_Ptri32, ptr %62, align 8
  store ptr %result.i.i1204, ptr %264, align 8
  %1300 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %62)
  %1301 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1286)
  %1302 = sext i32 %1292 to i64
  %1303 = getelementptr ptr, ptr %1286, i64 %1302
  %1304 = getelementptr i8, ptr %1303, i64 128
  %1305 = load ptr, ptr %1304, align 8
  store ptr @i32_typ, ptr %63, align 8
  store ptr @Entry, ptr %265, align 8
  %1306 = call ptr %1305({ ptr, ptr, ptr, i32 } %1293, ptr nonnull %63)
  call void %1306({ ptr, ptr, ptr, i32 } %1293, { ptr, ptr, ptr, i32 } %1293, ptr nonnull %62, i32 %1266, { ptr, i160 } %1284)
  %1307 = icmp ne ptr %.fca.0.extract112.i1179, @nil_typ
  %1308 = icmp ne ptr %.fca.0.extract112.i1179, null
  %.not140.i1205 = and i1 %1307, %1308
  br i1 %.not140.i1205, label %.cont.cont.i1144, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1211.thread

1309:                                             ; preds = %1234
  %1310 = add i32 %1244, 2127912214
  %1311 = shl i32 %1244, 12
  %1312 = add i32 %1310, %1311
  %1313 = ashr i32 %1312, 19
  %1314 = xor i32 %1312, %1313
  %1315 = xor i32 %1314, -949894596
  %1316 = add i32 %1315, 374761393
  %1317 = shl i32 %1315, 5
  %1318 = add i32 %1316, %1317
  %1319 = add i32 %1318, -744332180
  %1320 = shl i32 %1318, 9
  %1321 = xor i32 %1319, %1320
  %1322 = add i32 %1321, -42973499
  %1323 = shl i32 %1321, 3
  %1324 = add i32 %1322, %1323
  %1325 = ashr i32 %1324, 16
  %1326 = xor i32 %1324, %1325
  %1327 = xor i32 %1326, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1328 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1329 = load ptr, ptr %211, align 8
  %1330 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1329, 0
  %1331 = load ptr, ptr %212, align 8
  %1332 = insertvalue { ptr, ptr, ptr, i32 } %1330, ptr %1331, 1
  %1333 = load ptr, ptr %213, align 8
  %1334 = insertvalue { ptr, ptr, ptr, i32 } %1332, ptr %1333, 2
  %1335 = load i32, ptr %214, align 4
  %1336 = insertvalue { ptr, ptr, ptr, i32 } %1334, i32 %1335, 3
  %hash_coef_ptr.i.i10.i2731 = getelementptr i8, ptr %1329, i64 8
  %tbl_size_ptr.i.i11.i2732 = getelementptr i8, ptr %1329, i64 16
  %offset_tbl_ptr.i.i12.i2733 = getelementptr i8, ptr %1329, i64 40
  %hash_coef.i.i13.i2734 = load i64, ptr %hash_coef_ptr.i.i10.i2731, align 4
  %tbl_size.i.i14.i2735 = load i64, ptr %tbl_size_ptr.i.i11.i2732, align 4
  %offset_tbl.i.i15.i2736 = load ptr, ptr %offset_tbl_ptr.i.i12.i2733, align 8
  %product.i.i.i16.i2737 = mul i64 %hash_coef.i.i13.i2734, -5261542750394134544
  %shifted.i.i.i17.i2738 = lshr i64 %product.i.i.i16.i2737, 32
  %xored.i.i.i18.i2739 = xor i64 %shifted.i.i.i17.i2738, %product.i.i.i16.i2737
  %hash.i.i.i19.i2740 = and i64 %xored.i.i.i18.i2739, %tbl_size.i.i14.i2735
  %offset_ptr.i.i20.i2741 = getelementptr i32, ptr %offset_tbl.i.i15.i2736, i64 %hash.i.i.i19.i2740
  %offset.i.i21.i2742 = load i32, ptr %offset_ptr.i.i20.i2741, align 4
  %eq.i.i2743 = icmp eq i32 %1335, %offset.i.i21.i2742
  call void @llvm.assume(i1 %eq.i.i2743) #30
  %1337 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1338 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1329)
  %1339 = sext i32 %1335 to i64
  %1340 = getelementptr ptr, ptr %1329, i64 %1339
  %1341 = getelementptr i8, ptr %1340, i64 64
  %1342 = load ptr, ptr %1341, align 8
  %1343 = call ptr %1342({ ptr, ptr, ptr, i32 } %1336, ptr nonnull %2)
  %1344 = call i32 %1343({ ptr, ptr, ptr, i32 } %1336, { ptr, ptr, ptr, i32 } %1336, ptr nonnull %2)
  %1345 = add i32 %1344, -1
  %1346 = and i32 %1345, %1327
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1347 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1348 = load ptr, ptr %211, align 8
  %1349 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1348, 0
  %1350 = load ptr, ptr %212, align 8
  %1351 = insertvalue { ptr, ptr, ptr, i32 } %1349, ptr %1350, 1
  %1352 = load ptr, ptr %213, align 8
  %1353 = insertvalue { ptr, ptr, ptr, i32 } %1351, ptr %1352, 2
  %1354 = load i32, ptr %214, align 4
  %1355 = insertvalue { ptr, ptr, ptr, i32 } %1353, i32 %1354, 3
  %hash_coef_ptr.i.i202.i1098 = getelementptr i8, ptr %1348, i64 8
  %tbl_size_ptr.i.i203.i1099 = getelementptr i8, ptr %1348, i64 16
  %offset_tbl_ptr.i.i204.i1100 = getelementptr i8, ptr %1348, i64 40
  %hash_coef.i.i205.i1101 = load i64, ptr %hash_coef_ptr.i.i202.i1098, align 4
  %tbl_size.i.i206.i1102 = load i64, ptr %tbl_size_ptr.i.i203.i1099, align 4
  %offset_tbl.i.i207.i1103 = load ptr, ptr %offset_tbl_ptr.i.i204.i1100, align 8
  %product.i.i.i208.i1104 = mul i64 %hash_coef.i.i205.i1101, -5261542750394134544
  %shifted.i.i.i209.i1105 = lshr i64 %product.i.i.i208.i1104, 32
  %xored.i.i.i210.i1106 = xor i64 %shifted.i.i.i209.i1105, %product.i.i.i208.i1104
  %hash.i.i.i211.i1107 = and i64 %xored.i.i.i210.i1106, %tbl_size.i.i206.i1102
  %offset_ptr.i.i212.i1108 = getelementptr i32, ptr %offset_tbl.i.i207.i1103, i64 %hash.i.i.i211.i1107
  %offset.i.i213.i1109 = load i32, ptr %offset_ptr.i.i212.i1108, align 4
  %eq.i216.i1110 = icmp eq i32 %1354, %offset.i.i213.i1109
  call void @llvm.assume(i1 %eq.i216.i1110) #30
  store ptr @_parameterization_Ptri32, ptr %68, align 8
  %1356 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %68)
  %1357 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1348)
  %1358 = sext i32 %1354 to i64
  %1359 = getelementptr ptr, ptr %1348, i64 %1358
  %1360 = getelementptr i8, ptr %1359, i64 120
  %1361 = load ptr, ptr %1360, align 8
  store ptr @i32_typ, ptr %69, align 8
  %1362 = call ptr %1361({ ptr, ptr, ptr, i32 } %1355, ptr nonnull %69)
  %1363 = call { ptr, i160 } %1362({ ptr, ptr, ptr, i32 } %1355, { ptr, ptr, ptr, i32 } %1355, ptr nonnull %68, i32 %1346)
  %.fca.0.extract87.i1111 = extractvalue { ptr, i160 } %1363, 0
  %.sroa.3.0.insert.ext.i1112 = zext i32 %offset.i.i260.i11611494 to i160
  %.sroa.3.0.insert.shift.i1113 = shl nuw i160 %.sroa.3.0.insert.ext.i1112, 128
  %.sroa.2.0.insert.ext.i1114 = zext i64 %1237 to i160
  %.sroa.2.0.insert.shift.i1115 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i1114, 64
  %.sroa.2.0.insert.insert.i1116 = or disjoint i160 %.sroa.2.0.insert.shift.i1115, %.sroa.3.0.insert.shift.i1113
  %.sroa.0.0.insert.ext.i1117 = zext i64 %1236 to i160
  %.sroa.0.0.insert.insert.i1118 = or disjoint i160 %.sroa.2.0.insert.insert.i1116, %.sroa.0.0.insert.ext.i1117
  %1364 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i1118, 1
  %1365 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1366 = load ptr, ptr %211, align 8
  %1367 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1366, 0
  %1368 = load ptr, ptr %212, align 8
  %1369 = insertvalue { ptr, ptr, ptr, i32 } %1367, ptr %1368, 1
  %1370 = load ptr, ptr %213, align 8
  %1371 = insertvalue { ptr, ptr, ptr, i32 } %1369, ptr %1370, 2
  %1372 = load i32, ptr %214, align 4
  %1373 = insertvalue { ptr, ptr, ptr, i32 } %1371, i32 %1372, 3
  %hash_coef_ptr.i.i218.i1123 = getelementptr i8, ptr %1366, i64 8
  %tbl_size_ptr.i.i219.i1124 = getelementptr i8, ptr %1366, i64 16
  %offset_tbl_ptr.i.i220.i1125 = getelementptr i8, ptr %1366, i64 40
  %hash_coef.i.i221.i1126 = load i64, ptr %hash_coef_ptr.i.i218.i1123, align 4
  %tbl_size.i.i222.i1127 = load i64, ptr %tbl_size_ptr.i.i219.i1124, align 4
  %offset_tbl.i.i223.i1128 = load ptr, ptr %offset_tbl_ptr.i.i220.i1125, align 8
  %product.i.i.i224.i1129 = mul i64 %hash_coef.i.i221.i1126, -5261542750394134544
  %shifted.i.i.i225.i1130 = lshr i64 %product.i.i.i224.i1129, 32
  %xored.i.i.i226.i1131 = xor i64 %shifted.i.i.i225.i1130, %product.i.i.i224.i1129
  %hash.i.i.i227.i1132 = and i64 %xored.i.i.i226.i1131, %tbl_size.i.i222.i1127
  %offset_ptr.i.i228.i1133 = getelementptr i32, ptr %offset_tbl.i.i223.i1128, i64 %hash.i.i.i227.i1132
  %offset.i.i229.i1134 = load i32, ptr %offset_ptr.i.i228.i1133, align 4
  %eq.i232.i1135 = icmp eq i32 %1372, %offset.i.i229.i1134
  call void @llvm.assume(i1 %eq.i232.i1135) #30
  %1374 = load ptr, ptr %result.i88, align 8
  %1375 = load ptr, ptr %176, align 8
  %result.i233.i1136 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1376 = getelementptr i8, ptr %result.i233.i1136, i64 16
  store ptr %1375, ptr %1376, align 8
  %1377 = getelementptr i8, ptr %result.i233.i1136, i64 8
  store ptr %1374, ptr %1377, align 8
  %1378 = getelementptr i8, ptr %result.i233.i1136, i64 24
  store ptr null, ptr %1378, align 8
  %1379 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i1136)
  store ptr @Entry, ptr %result.i233.i1136, align 8
  store ptr @_parameterization_Ptri32, ptr %70, align 8
  store ptr %result.i233.i1136, ptr %262, align 8
  %1380 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %70)
  %1381 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1366)
  %1382 = sext i32 %1372 to i64
  %1383 = getelementptr ptr, ptr %1366, i64 %1382
  %1384 = getelementptr i8, ptr %1383, i64 128
  %1385 = load ptr, ptr %1384, align 8
  store ptr @i32_typ, ptr %71, align 8
  store ptr @Entry, ptr %263, align 8
  %1386 = call ptr %1385({ ptr, ptr, ptr, i32 } %1373, ptr nonnull %71)
  call void %1386({ ptr, ptr, ptr, i32 } %1373, { ptr, ptr, ptr, i32 } %1373, ptr nonnull %70, i32 %1346, { ptr, i160 } %1364)
  %1387 = icmp ne ptr %.fca.0.extract87.i1111, @nil_typ
  %1388 = icmp ne ptr %.fca.0.extract87.i1111, null
  %.not138.i1137 = and i1 %1387, %1388
  br i1 %.not138.i1137, label %.cont.cont.i1144, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1211.thread

.cont.cont.i1144:                                 ; preds = %1309, %1247
  %.sink1505 = phi { ptr, i160 } [ %1283, %1247 ], [ %1363, %1309 ]
  %1389 = phi i32 [ 2, %1247 ], [ 1, %1309 ]
  %vptr.i248.sroa.speculated.i1147 = phi ptr [ %.fca.0.extract112.i1179, %1247 ], [ %.fca.0.extract87.i1111, %1309 ]
  %.fca.1.extract89.i1140 = extractvalue { ptr, i160 } %.sink1505, 1
  %.sroa.3407.sroa.4.0.extract.shift.i1141 = lshr i160 %.fca.1.extract89.i1140, 64
  %1390 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i1141 to i64
  %1391 = insertelement <2 x i64> poison, i64 %1390, i64 0
  %1392 = trunc i160 %.fca.1.extract89.i1140 to i64
  %1393 = insertelement <2 x i64> %1391, i64 %1392, i64 1
  %hash_coef_ptr.i.i249.i1150 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1147, i64 8
  %tbl_size_ptr.i.i250.i1151 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1147, i64 16
  %offset_tbl_ptr.i.i251.i1152 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1147, i64 40
  %hash_coef.i.i252.i1153 = load i64, ptr %hash_coef_ptr.i.i249.i1150, align 4
  %tbl_size.i.i253.i1154 = load i64, ptr %tbl_size_ptr.i.i250.i1151, align 4
  %offset_tbl.i.i254.i1155 = load ptr, ptr %offset_tbl_ptr.i.i251.i1152, align 8
  %product.i.i.i255.i1156 = mul i64 %hash_coef.i.i252.i1153, 4015701072841558310
  %shifted.i.i.i256.i1157 = lshr i64 %product.i.i.i255.i1156, 32
  %xored.i.i.i257.i1158 = xor i64 %shifted.i.i.i256.i1157, %product.i.i.i255.i1156
  %hash.i.i.i258.i1159 = and i64 %xored.i.i.i257.i1158, %tbl_size.i.i253.i1154
  %offset_ptr.i.i259.i1160 = getelementptr i32, ptr %offset_tbl.i.i254.i1155, i64 %hash.i.i.i258.i1159
  %offset.i.i260.i1161 = load i32, ptr %offset_ptr.i.i259.i1160, align 4
  %1394 = add nuw nsw i32 %.reg2mem193.0677.i1093, 1
  %1395 = load i32, ptr %216, align 4
  %1396 = icmp slt i32 %1394, %1395
  br i1 %1396, label %1234, label %._crit_edge1.1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1211.thread: ; preds = %1247, %1309
  %1397 = phi ptr [ %72, %1309 ], [ %64, %1247 ]
  %1398 = phi ptr [ %73, %1309 ], [ %65, %1247 ]
  %1399 = phi ptr [ %74, %1309 ], [ %66, %1247 ]
  %1400 = phi ptr [ %.sroa.0.i1055, %1309 ], [ %.sroa.0680.i1053, %1247 ]
  %1401 = phi ptr [ %75, %1309 ], [ %67, %1247 ]
  %1402 = load i32, ptr %215, align 4
  store i32 %1402, ptr %1397, align 4
  store i32 1, ptr %1398, align 4
  %1403 = add i32 %1402, 1
  store i32 %1403, ptr %1399, align 4
  %1404 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1403, ptr %215, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1401, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1400, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1053)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1055)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %75)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.1.i:                                 ; preds = %.cont.cont.i1144, %HashMap_resize_.exit1052
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1053)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1055)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %75)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %57)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %59)
  %1405 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1406 = load ptr, ptr %193, align 8
  %1407 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1406, 0
  %1408 = load ptr, ptr %194, align 8
  %1409 = insertvalue { ptr, ptr, ptr, i32 } %1407, ptr %1408, 1
  %1410 = load ptr, ptr %195, align 8
  %1411 = insertvalue { ptr, ptr, ptr, i32 } %1409, ptr %1410, 2
  %1412 = load i32, ptr %196, align 4
  %1413 = insertvalue { ptr, ptr, ptr, i32 } %1411, i32 %1412, 3
  %hash_coef_ptr.i.i64.i1229 = getelementptr i8, ptr %1406, i64 8
  %tbl_size_ptr.i.i65.i1230 = getelementptr i8, ptr %1406, i64 16
  %offset_tbl_ptr.i.i66.i1231 = getelementptr i8, ptr %1406, i64 40
  %hash_coef.i.i67.i1232 = load i64, ptr %hash_coef_ptr.i.i64.i1229, align 4
  %tbl_size.i.i68.i1233 = load i64, ptr %tbl_size_ptr.i.i65.i1230, align 4
  %offset_tbl.i.i69.i1234 = load ptr, ptr %offset_tbl_ptr.i.i66.i1231, align 8
  %product.i.i.i70.i1235 = mul i64 %hash_coef.i.i67.i1232, -5261542750394134544
  %shifted.i.i.i71.i1236 = lshr i64 %product.i.i.i70.i1235, 32
  %xored.i.i.i72.i1237 = xor i64 %shifted.i.i.i71.i1236, %product.i.i.i70.i1235
  %hash.i.i.i73.i1238 = and i64 %xored.i.i.i72.i1237, %tbl_size.i.i68.i1233
  %offset_ptr.i.i74.i1239 = getelementptr i32, ptr %offset_tbl.i.i69.i1234, i64 %hash.i.i.i73.i1238
  %offset.i.i75.i1240 = load i32, ptr %offset_ptr.i.i74.i1239, align 4
  %eq.i.i1241 = icmp eq i32 %1412, %offset.i.i75.i1240
  call void @llvm.assume(i1 %eq.i.i1241) #30
  %1414 = load ptr, ptr %211, align 8
  %1415 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1414, 0
  %1416 = load ptr, ptr %212, align 8
  %1417 = insertvalue { ptr, ptr, ptr, i32 } %1415, ptr %1416, 1
  %1418 = load ptr, ptr %213, align 8
  %1419 = insertvalue { ptr, ptr, ptr, i32 } %1417, ptr %1418, 2
  %1420 = load i32, ptr %214, align 4
  %1421 = insertvalue { ptr, ptr, ptr, i32 } %1419, i32 %1420, 3
  %hash_coef_ptr.i.i92.i1246 = getelementptr i8, ptr %1414, i64 8
  %tbl_size_ptr.i.i93.i1247 = getelementptr i8, ptr %1414, i64 16
  %offset_tbl_ptr.i.i94.i1248 = getelementptr i8, ptr %1414, i64 40
  %hash_coef.i.i95.i1249 = load i64, ptr %hash_coef_ptr.i.i92.i1246, align 4
  %tbl_size.i.i96.i1250 = load i64, ptr %tbl_size_ptr.i.i93.i1247, align 4
  %offset_tbl.i.i97.i1251 = load ptr, ptr %offset_tbl_ptr.i.i94.i1248, align 8
  %product.i.i.i98.i1252 = mul i64 %hash_coef.i.i95.i1249, -5261542750394134544
  %shifted.i.i.i99.i1253 = lshr i64 %product.i.i.i98.i1252, 32
  %xored.i.i.i100.i1254 = xor i64 %shifted.i.i.i99.i1253, %product.i.i.i98.i1252
  %hash.i.i.i101.i1255 = and i64 %xored.i.i.i100.i1254, %tbl_size.i.i96.i1250
  %offset_ptr.i.i102.i1256 = getelementptr i32, ptr %offset_tbl.i.i97.i1251, i64 %hash.i.i.i101.i1255
  %offset.i.i103.i1257 = load i32, ptr %offset_ptr.i.i102.i1256, align 4
  %eq.i106.i1258 = icmp eq i32 %1420, %offset.i.i103.i1257
  call void @llvm.assume(i1 %eq.i106.i1258) #30
  %1422 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1423 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1406)
  %1424 = sext i32 %1412 to i64
  %1425 = getelementptr ptr, ptr %1406, i64 %1424
  %1426 = getelementptr i8, ptr %1425, i64 64
  %1427 = load ptr, ptr %1426, align 8
  %1428 = call ptr %1427({ ptr, ptr, ptr, i32 } %1413, ptr nonnull %2)
  %1429 = call i32 %1428({ ptr, ptr, ptr, i32 } %1413, { ptr, ptr, ptr, i32 } %1413, ptr nonnull %2)
  %1430 = shl i32 %1429, 1
  %1431 = load i32, ptr %215, align 4
  %1432 = load ptr, ptr %result.i88, align 8
  %1433 = load ptr, ptr %176, align 8
  %1434 = sext i32 %1431 to i64
  %1435 = shl nsw i64 %1434, 5
  %result.i.i.i1261 = call noalias ptr @bump_malloc_inner(i64 noundef %1435, ptr nonnull @current_ptr) #29
  %1436 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1437 = icmp sgt i32 %1429, 0
  br i1 %1437, label %.lr.ph434.i1331, label %._crit_edge395.i1275

.lr.ph434.i1331:                                  ; preds = %._crit_edge1.1.i
  %invariant.gep.i1274 = getelementptr i8, ptr %1406, i64 120
  %1438 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1334 = getelementptr ptr, ptr %invariant.gep.i1274, i64 %1424
  br label %1439

1439:                                             ; preds = %1461, %.lr.ph434.i1331
  %.reg2mem105.0432.i1332 = phi i32 [ 0, %.lr.ph434.i1331 ], [ %.reg2mem101.0.i1337, %1461 ]
  %.reg2mem103.0431.i1333 = phi i32 [ 0, %.lr.ph434.i1331 ], [ %1462, %1461 ]
  store ptr @_parameterization_Ptri32, ptr %54, align 8
  %1440 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %54)
  %1441 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1406)
  %1442 = load ptr, ptr %gep.i1334, align 8
  store ptr @i32_typ, ptr %55, align 8
  %1443 = call ptr %1442({ ptr, ptr, ptr, i32 } %1413, ptr nonnull %55)
  %1444 = call { ptr, i160 } %1443({ ptr, ptr, ptr, i32 } %1413, { ptr, ptr, ptr, i32 } %1413, ptr nonnull %54, i32 %.reg2mem103.0431.i1333)
  %.fca.0.extract52.i1335 = extractvalue { ptr, i160 } %1444, 0
  %1445 = icmp ne ptr %.fca.0.extract52.i1335, @nil_typ
  %1446 = icmp ne ptr %.fca.0.extract52.i1335, null
  %.not60.i1336 = and i1 %1445, %1446
  br i1 %.not60.i1336, label %1447, label %1461

1447:                                             ; preds = %1439
  %hash_coef_ptr.i.i137.i1364 = getelementptr i8, ptr %.fca.0.extract52.i1335, i64 8
  %tbl_size_ptr.i.i138.i1365 = getelementptr i8, ptr %.fca.0.extract52.i1335, i64 16
  %offset_tbl_ptr.i.i139.i1366 = getelementptr i8, ptr %.fca.0.extract52.i1335, i64 40
  %hash_coef.i.i140.i1367 = load i64, ptr %hash_coef_ptr.i.i137.i1364, align 4
  %tbl_size.i.i141.i1368 = load i64, ptr %tbl_size_ptr.i.i138.i1365, align 4
  %offset_tbl.i.i142.i1369 = load ptr, ptr %offset_tbl_ptr.i.i139.i1366, align 8
  %product.i.i.i143.i1370 = mul i64 %hash_coef.i.i140.i1367, 4015701072841558310
  %shifted.i.i.i144.i1371 = lshr i64 %product.i.i.i143.i1370, 32
  %xored.i.i.i145.i1372 = xor i64 %shifted.i.i.i144.i1371, %product.i.i.i143.i1370
  %hash.i.i.i146.i1373 = and i64 %xored.i.i.i145.i1372, %tbl_size.i.i141.i1368
  %offset_ptr.i.i147.i1374 = getelementptr i32, ptr %offset_tbl.i.i142.i1369, i64 %hash.i.i.i146.i1373
  %offset.i.i148.i1375 = load i32, ptr %offset_ptr.i.i147.i1374, align 4
  %1448 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1449 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1450 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1451 = icmp slt i32 %.reg2mem105.0432.i1332, %1431
  br i1 %1451, label %1452, label %._crit_edge.i1376

1452:                                             ; preds = %1447
  %.fca.1.extract54.i1377 = extractvalue { ptr, i160 } %1444, 1
  %.sroa.351.0.insert.ext.i1378 = zext i32 %offset.i.i148.i1375 to i160
  %.sroa.351.0.insert.shift.i1379 = shl nuw i160 %.sroa.351.0.insert.ext.i1378, 128
  %1453 = and i160 %.fca.1.extract54.i1377, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1380 = or disjoint i160 %.sroa.351.0.insert.shift.i1379, %1453
  %1454 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1455 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1456 = sext i32 %.reg2mem105.0432.i1332 to i64
  %1457 = shl nsw i64 %1456, 5
  %1458 = getelementptr i8, ptr %result.i.i.i1261, i64 %1457
  store ptr %.fca.0.extract52.i1335, ptr %1458, align 8
  %1459 = getelementptr i8, ptr %1458, i64 8
  store i160 %.sroa.049.0.insert.insert.i1380, ptr %1459, align 4
  br label %._crit_edge.i1376

._crit_edge.i1376:                                ; preds = %1452, %1447
  %1460 = add i32 %.reg2mem105.0432.i1332, 1
  br label %1461

1461:                                             ; preds = %._crit_edge.i1376, %1439
  %.reg2mem101.0.i1337 = phi i32 [ %1460, %._crit_edge.i1376 ], [ %.reg2mem105.0432.i1332, %1439 ]
  %1462 = add nuw nsw i32 %.reg2mem103.0431.i1333, 1
  %1463 = icmp slt i32 %1462, %1429
  br i1 %1463, label %1439, label %.lr.ph.i1338

.lr.ph.i1338:                                     ; preds = %1461
  %invariant.gep396.i1339 = getelementptr i8, ptr %1414, i64 120
  %1464 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1465 = sext i32 %1420 to i64
  %gep397.i1342 = getelementptr ptr, ptr %invariant.gep396.i1339, i64 %1465
  br label %1466

1466:                                             ; preds = %1488, %.lr.ph.i1338
  %.reg2mem91.0394.i1340 = phi i32 [ %.reg2mem101.0.i1337, %.lr.ph.i1338 ], [ %.reg2mem87.0.i1345, %1488 ]
  %.reg2mem89.0393.i1341 = phi i32 [ 0, %.lr.ph.i1338 ], [ %1489, %1488 ]
  store ptr @_parameterization_Ptri32, ptr %56, align 8
  %1467 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %56)
  %1468 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1414)
  %1469 = load ptr, ptr %gep397.i1342, align 8
  store ptr @i32_typ, ptr %57, align 8
  %1470 = call ptr %1469({ ptr, ptr, ptr, i32 } %1421, ptr nonnull %57)
  %1471 = call { ptr, i160 } %1470({ ptr, ptr, ptr, i32 } %1421, { ptr, ptr, ptr, i32 } %1421, ptr nonnull %56, i32 %.reg2mem89.0393.i1341)
  %.fca.0.extract42.i1343 = extractvalue { ptr, i160 } %1471, 0
  %1472 = icmp ne ptr %.fca.0.extract42.i1343, @nil_typ
  %1473 = icmp ne ptr %.fca.0.extract42.i1343, null
  %.not62.i1344 = and i1 %1472, %1473
  br i1 %.not62.i1344, label %1474, label %1488

1474:                                             ; preds = %1466
  %hash_coef_ptr.i.i152.i1346 = getelementptr i8, ptr %.fca.0.extract42.i1343, i64 8
  %tbl_size_ptr.i.i153.i1347 = getelementptr i8, ptr %.fca.0.extract42.i1343, i64 16
  %offset_tbl_ptr.i.i154.i1348 = getelementptr i8, ptr %.fca.0.extract42.i1343, i64 40
  %hash_coef.i.i155.i1349 = load i64, ptr %hash_coef_ptr.i.i152.i1346, align 4
  %tbl_size.i.i156.i1350 = load i64, ptr %tbl_size_ptr.i.i153.i1347, align 4
  %offset_tbl.i.i157.i1351 = load ptr, ptr %offset_tbl_ptr.i.i154.i1348, align 8
  %product.i.i.i158.i1352 = mul i64 %hash_coef.i.i155.i1349, 4015701072841558310
  %shifted.i.i.i159.i1353 = lshr i64 %product.i.i.i158.i1352, 32
  %xored.i.i.i160.i1354 = xor i64 %shifted.i.i.i159.i1353, %product.i.i.i158.i1352
  %hash.i.i.i161.i1355 = and i64 %xored.i.i.i160.i1354, %tbl_size.i.i156.i1350
  %offset_ptr.i.i162.i1356 = getelementptr i32, ptr %offset_tbl.i.i157.i1351, i64 %hash.i.i.i161.i1355
  %offset.i.i163.i1357 = load i32, ptr %offset_ptr.i.i162.i1356, align 4
  %1475 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1476 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1477 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1478 = icmp slt i32 %.reg2mem91.0394.i1340, %1431
  br i1 %1478, label %1479, label %._crit_edge1.i1358

1479:                                             ; preds = %1474
  %.fca.1.extract44.i1359 = extractvalue { ptr, i160 } %1471, 1
  %.sroa.3.0.insert.ext.i1360 = zext i32 %offset.i.i163.i1357 to i160
  %.sroa.3.0.insert.shift.i1361 = shl nuw i160 %.sroa.3.0.insert.ext.i1360, 128
  %1480 = and i160 %.fca.1.extract44.i1359, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1362 = or disjoint i160 %.sroa.3.0.insert.shift.i1361, %1480
  %1481 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1482 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1483 = sext i32 %.reg2mem91.0394.i1340 to i64
  %1484 = shl nsw i64 %1483, 5
  %1485 = getelementptr i8, ptr %result.i.i.i1261, i64 %1484
  store ptr %.fca.0.extract42.i1343, ptr %1485, align 8
  %1486 = getelementptr i8, ptr %1485, i64 8
  store i160 %.sroa.040.0.insert.insert.i1362, ptr %1486, align 4
  br label %._crit_edge1.i1358

._crit_edge1.i1358:                               ; preds = %1479, %1474
  %1487 = add i32 %.reg2mem91.0394.i1340, 1
  br label %1488

1488:                                             ; preds = %._crit_edge1.i1358, %1466
  %.reg2mem87.0.i1345 = phi i32 [ %1487, %._crit_edge1.i1358 ], [ %.reg2mem91.0394.i1340, %1466 ]
  %1489 = add nuw nsw i32 %.reg2mem89.0393.i1341, 1
  %1490 = icmp slt i32 %1489, %1429
  br i1 %1490, label %1466, label %._crit_edge395.i1275.loopexit

._crit_edge395.i1275.loopexit:                    ; preds = %1488
  %.pre2490 = load ptr, ptr %result.i88, align 8
  %.pre2491 = load ptr, ptr %176, align 8
  br label %._crit_edge395.i1275

._crit_edge395.i1275:                             ; preds = %._crit_edge395.i1275.loopexit, %._crit_edge1.1.i
  %1491 = phi ptr [ %1433, %._crit_edge1.1.i ], [ %.pre2491, %._crit_edge395.i1275.loopexit ]
  %1492 = phi ptr [ %1432, %._crit_edge1.1.i ], [ %.pre2490, %._crit_edge395.i1275.loopexit ]
  %.reg2mem91.0.lcssa.i1276 = phi i32 [ 0, %._crit_edge1.1.i ], [ %.reg2mem87.0.i1345, %._crit_edge395.i1275.loopexit ]
  %1493 = call i32 @llvm.smax.i32(i32 %1430, i32 16)
  %result.i166.i1277 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1494 = getelementptr i8, ptr %result.i166.i1277, i64 16
  store ptr @_parameterization_Nil, ptr %1494, align 8
  %result.i167.i1278 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1495 = getelementptr i8, ptr %result.i167.i1278, i64 16
  store ptr %1491, ptr %1495, align 8
  %1496 = getelementptr i8, ptr %result.i167.i1278, i64 8
  store ptr %1492, ptr %1496, align 8
  %1497 = getelementptr i8, ptr %result.i167.i1278, i64 24
  store ptr null, ptr %1497, align 8
  %1498 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1278)
  store ptr @Entry, ptr %result.i167.i1278, align 8
  %1499 = getelementptr i8, ptr %result.i166.i1277, i64 8
  store ptr %result.i167.i1278, ptr %1499, align 8
  %1500 = getelementptr i8, ptr %result.i166.i1277, i64 24
  store ptr null, ptr %1500, align 8
  %1501 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1277)
  store ptr @union_typ, ptr %result.i166.i1277, align 8
  %result.i168.i1279 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1277, ptr %result.i168.i1279, align 8
  %1502 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1279)
  store ptr @Array, ptr %58, align 8
  store ptr %result.i168.i1279, ptr %266, align 8
  store i32 9, ptr %267, align 8
  %1503 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %58)
  %1504 = getelementptr i8, ptr %result.i168.i1279, i64 16
  store i32 %1493, ptr %1504, align 4
  %1505 = getelementptr i8, ptr %result.i168.i1279, i64 20
  store i32 %1493, ptr %1505, align 4
  %1506 = zext nneg i32 %1493 to i64
  %1507 = shl nuw nsw i64 %1506, 5
  %result.i.i416.i1280 = call noalias ptr @bump_malloc_inner(i64 noundef %1507, ptr nonnull @current_ptr) #29
  %1508 = getelementptr i8, ptr %result.i168.i1279, i64 8
  store ptr %result.i.i416.i1280, ptr %1508, align 8
  %1509 = load ptr, ptr %268, align 8
  store ptr @Array, ptr %193, align 8
  store ptr %result.i168.i1279, ptr %194, align 8
  store ptr %1509, ptr %195, align 8
  store i32 9, ptr %196, align 4
  %result.i183.i1293 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1510 = getelementptr i8, ptr %result.i183.i1293, i64 16
  store ptr @_parameterization_Nil, ptr %1510, align 8
  %result.i184.i1294 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1511 = getelementptr i8, ptr %result.i184.i1294, i64 16
  store ptr %1491, ptr %1511, align 8
  %1512 = getelementptr i8, ptr %result.i184.i1294, i64 8
  store ptr %1492, ptr %1512, align 8
  %1513 = getelementptr i8, ptr %result.i184.i1294, i64 24
  store ptr null, ptr %1513, align 8
  %1514 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1294)
  store ptr @Entry, ptr %result.i184.i1294, align 8
  %1515 = getelementptr i8, ptr %result.i183.i1293, i64 8
  store ptr %result.i184.i1294, ptr %1515, align 8
  %1516 = getelementptr i8, ptr %result.i183.i1293, i64 24
  store ptr null, ptr %1516, align 8
  %1517 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1293)
  store ptr @union_typ, ptr %result.i183.i1293, align 8
  %result.i185.i1295 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1293, ptr %result.i185.i1295, align 8
  %1518 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1295)
  store ptr @Array, ptr %59, align 8
  store ptr %result.i185.i1295, ptr %269, align 8
  store i32 9, ptr %270, align 8
  %1519 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %59)
  %1520 = getelementptr i8, ptr %result.i185.i1295, i64 16
  store i32 %1493, ptr %1520, align 4
  %1521 = getelementptr i8, ptr %result.i185.i1295, i64 20
  store i32 %1493, ptr %1521, align 4
  %result.i.i430.i1296 = call noalias ptr @bump_malloc_inner(i64 noundef %1507, ptr nonnull @current_ptr) #29
  %1522 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1523 = getelementptr i8, ptr %result.i185.i1295, i64 8
  store ptr %result.i.i430.i1296, ptr %1523, align 8
  %1524 = load ptr, ptr %271, align 8
  store ptr @Array, ptr %211, align 8
  store ptr %result.i185.i1295, ptr %212, align 8
  store ptr %1524, ptr %213, align 8
  store i32 9, ptr %214, align 4
  %1525 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 0, ptr %215, align 4
  %1526 = icmp sgt i32 %.reg2mem91.0.lcssa.i1276, 0
  br i1 %1526, label %.lr.ph400.i1309, label %HashMap_resize_.exit1382

.lr.ph400.i1309:                                  ; preds = %._crit_edge395.i1275
  %1527 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1528 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1529 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1311

._crit_edge2.i1311:                               ; preds = %._crit_edge2.i1311, %.lr.ph400.i1309
  %.reg2mem77.0398.i1312 = phi i32 [ 0, %.lr.ph400.i1309 ], [ %1543, %._crit_edge2.i1311 ]
  %1530 = zext nneg i32 %.reg2mem77.0398.i1312 to i64
  %1531 = shl nuw nsw i64 %1530, 5
  %1532 = getelementptr i8, ptr %result.i.i.i1261, i64 %1531
  %1533 = load ptr, ptr %1532, align 8
  %1534 = getelementptr i8, ptr %1532, i64 8
  %1535 = load i160, ptr %1534, align 4
  %.sroa.3362.8.extract.trunc.i1315 = trunc i160 %1535 to i64
  %1536 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1315 to ptr
  %.sroa.5363.8.extract.shift.i1316 = lshr i160 %1535, 64
  %.sroa.5363.8.extract.trunc.i1317 = trunc i160 %.sroa.5363.8.extract.shift.i1316 to i64
  %1537 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1317 to ptr
  %hash_coef_ptr.i.i201.i1318 = getelementptr i8, ptr %1533, i64 8
  %tbl_size_ptr.i.i202.i1319 = getelementptr i8, ptr %1533, i64 16
  %offset_tbl_ptr.i.i203.i1320 = getelementptr i8, ptr %1533, i64 40
  %hash_coef.i.i232.i1321 = load i64, ptr %hash_coef_ptr.i.i201.i1318, align 4
  %tbl_size.i.i233.i1322 = load i64, ptr %tbl_size_ptr.i.i202.i1319, align 4
  %offset_tbl.i.i234.i1323 = load ptr, ptr %offset_tbl_ptr.i.i203.i1320, align 8
  %product.i.i.i235.i1324 = mul i64 %hash_coef.i.i232.i1321, 4015701072841558310
  %shifted.i.i.i236.i1325 = lshr i64 %product.i.i.i235.i1324, 32
  %xored.i.i.i237.i1326 = xor i64 %shifted.i.i.i236.i1325, %product.i.i.i235.i1324
  %hash.i.i.i238.i1327 = and i64 %xored.i.i.i237.i1326, %tbl_size.i.i233.i1322
  %offset_ptr.i.i239.i1328 = getelementptr i32, ptr %offset_tbl.i.i234.i1323, i64 %hash.i.i.i238.i1327
  %offset.i.i240.i1329 = load i32, ptr %offset_ptr.i.i239.i1328, align 4
  %1538 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1533, 0
  %1539 = insertvalue { ptr, ptr, ptr, i32 } %1538, ptr %1536, 1
  %1540 = insertvalue { ptr, ptr, ptr, i32 } %1539, ptr %1537, 2
  %1541 = insertvalue { ptr, ptr, ptr, i32 } %1540, i32 %offset.i.i240.i1329, 3
  %1542 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %248, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1541)
  %1543 = add nuw nsw i32 %.reg2mem77.0398.i1312, 1
  %1544 = icmp slt i32 %1543, %.reg2mem91.0.lcssa.i1276
  br i1 %1544, label %._crit_edge2.i1311, label %HashMap_resize_.exit1382

HashMap_resize_.exit1382:                         ; preds = %._crit_edge2.i1311, %._crit_edge395.i1275
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %57)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %59)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1211.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %357, %553, %HashMap_resize_.exit1382
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %120)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %121)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %122)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %123)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %124)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %125)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %126)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %127)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %128)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %129)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %130)
  %1545 = add nuw nsw i32 %.reg2mem87.0238, 1
  %1546 = icmp slt i32 %1545, %0
  br i1 %1546, label %272, label %._crit_edge240

._crit_edge240:                                   ; preds = %HashMap_insert_keyK_valueV.exit
  %1547 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1548 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1549 = load i32, ptr %215, align 4
  %1550 = call i64 @clock()
  %1551 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1552 = load ptr, ptr %175, align 8
  %invariant.gep = getelementptr i8, ptr %1552, i64 8
  %1553 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1554 = getelementptr inbounds i8, ptr %117, i64 8
  %1555 = getelementptr inbounds i8, ptr %117, i64 24
  %1556 = getelementptr inbounds i8, ptr %117, i64 16
  %1557 = getelementptr inbounds i8, ptr %114, i64 8
  %1558 = getelementptr inbounds i8, ptr %114, i64 24
  %1559 = getelementptr inbounds i8, ptr %114, i64 16
  %1560 = getelementptr inbounds i8, ptr %115, i64 8
  %1561 = getelementptr inbounds i8, ptr %116, i64 8
  %1562 = getelementptr inbounds i8, ptr %109, i64 8
  %1563 = getelementptr inbounds i8, ptr %109, i64 24
  %1564 = getelementptr inbounds i8, ptr %109, i64 16
  %1565 = getelementptr inbounds i8, ptr %110, i64 8
  %1566 = getelementptr inbounds i8, ptr %111, i64 8
  %1567 = getelementptr i8, ptr %result.i, i64 40
  %1568 = getelementptr i8, ptr %result.i, i64 72
  %1569 = getelementptr i8, ptr %result.i, i64 88
  %1570 = getelementptr inbounds i8, ptr %52, i64 8
  %1571 = getelementptr inbounds i8, ptr %52, i64 24
  %1572 = getelementptr inbounds i8, ptr %52, i64 16
  %1573 = getelementptr inbounds i8, ptr %53, i64 8
  %1574 = getelementptr inbounds i8, ptr %53, i64 24
  %1575 = getelementptr inbounds i8, ptr %53, i64 16
  %1576 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %1577 = insertvalue { ptr, ptr, ptr, i32 } %1576, ptr undef, 2
  %1578 = insertvalue { ptr, ptr, ptr, i32 } %1577, i32 9, 3
  %1579 = getelementptr inbounds i8, ptr %47, i64 8
  %1580 = getelementptr inbounds i8, ptr %47, i64 16
  %1581 = getelementptr inbounds i8, ptr %47, i64 24
  %1582 = getelementptr inbounds i8, ptr %41, i64 8
  %1583 = getelementptr inbounds i8, ptr %42, i64 8
  %1584 = getelementptr inbounds i8, ptr %33, i64 8
  %1585 = getelementptr inbounds i8, ptr %34, i64 8
  %1586 = getelementptr inbounds i8, ptr %29, i64 8
  %1587 = getelementptr inbounds i8, ptr %29, i64 24
  %1588 = getelementptr inbounds i8, ptr %29, i64 16
  %1589 = getelementptr inbounds i8, ptr %30, i64 8
  %1590 = getelementptr inbounds i8, ptr %30, i64 24
  %1591 = getelementptr inbounds i8, ptr %30, i64 16
  %1592 = getelementptr inbounds i8, ptr %19, i64 8
  %1593 = getelementptr inbounds i8, ptr %20, i64 8
  %1594 = getelementptr inbounds i8, ptr %11, i64 8
  %1595 = getelementptr inbounds i8, ptr %12, i64 8
  %1596 = getelementptr inbounds i8, ptr %7, i64 8
  %1597 = getelementptr inbounds i8, ptr %7, i64 24
  %1598 = getelementptr inbounds i8, ptr %7, i64 16
  %1599 = getelementptr inbounds i8, ptr %8, i64 8
  %1600 = getelementptr inbounds i8, ptr %8, i64 24
  %1601 = getelementptr inbounds i8, ptr %8, i64 16
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge240, %HashMap_insert_keyK_valueV.exit701
  %.reg2mem75.0241 = phi i32 [ 0, %._crit_edge240 ], [ %2865, %HashMap_insert_keyK_valueV.exit701 ]
  %1602 = zext nneg i32 %.reg2mem75.0241 to i64
  %1603 = shl nuw nsw i64 %1602, 5
  %gep = getelementptr i8, ptr %invariant.gep, i64 %1603
  %1604 = load i160, ptr %gep, align 4
  %.sroa.1.8.extract.trunc = trunc i160 %1604 to i32
  %1605 = add i32 %.sroa.1.8.extract.trunc, 1
  %.sroa.033.0.insert.ext = and i160 %1604, 4294967295
  %1606 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.033.0.insert.ext, 1
  %.sroa.030.0.insert.ext = zext i32 %1605 to i160
  %1607 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.030.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %109)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %111)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %113)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %114)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %115)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %116)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %117)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %118)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %119)
  %1608 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1609 = load ptr, ptr %141, align 8
  %1610 = call i32 %1609({ ptr, i160 } %1606)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1611 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1612 = load ptr, ptr %153, align 8
  %1613 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1612, 0
  %1614 = load ptr, ptr %154, align 8
  %1615 = insertvalue { ptr, ptr, ptr, i32 } %1613, ptr %1614, 1
  %1616 = load ptr, ptr %1567, align 8
  %1617 = insertvalue { ptr, ptr, ptr, i32 } %1615, ptr %1616, 2
  %1618 = load i32, ptr %155, align 4
  %1619 = insertvalue { ptr, ptr, ptr, i32 } %1617, i32 %1618, 3
  %hash_coef_ptr.i.i10.i1548 = getelementptr i8, ptr %1612, i64 8
  %tbl_size_ptr.i.i11.i1549 = getelementptr i8, ptr %1612, i64 16
  %offset_tbl_ptr.i.i12.i1550 = getelementptr i8, ptr %1612, i64 40
  %hash_coef.i.i13.i1551 = load i64, ptr %hash_coef_ptr.i.i10.i1548, align 4
  %tbl_size.i.i14.i1552 = load i64, ptr %tbl_size_ptr.i.i11.i1549, align 4
  %offset_tbl.i.i15.i1553 = load ptr, ptr %offset_tbl_ptr.i.i12.i1550, align 8
  %product.i.i.i16.i1554 = mul i64 %hash_coef.i.i13.i1551, -5261542750394134544
  %shifted.i.i.i17.i1555 = lshr i64 %product.i.i.i16.i1554, 32
  %xored.i.i.i18.i1556 = xor i64 %shifted.i.i.i17.i1555, %product.i.i.i16.i1554
  %hash.i.i.i19.i1557 = and i64 %xored.i.i.i18.i1556, %tbl_size.i.i14.i1552
  %offset_ptr.i.i20.i1558 = getelementptr i32, ptr %offset_tbl.i.i15.i1553, i64 %hash.i.i.i19.i1557
  %offset.i.i21.i1559 = load i32, ptr %offset_ptr.i.i20.i1558, align 4
  %eq.i.i1560 = icmp eq i32 %1618, %offset.i.i21.i1559
  call void @llvm.assume(i1 %eq.i.i1560) #30
  %1620 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1621 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1612)
  %1622 = sext i32 %1618 to i64
  %1623 = getelementptr ptr, ptr %1612, i64 %1622
  %1624 = getelementptr i8, ptr %1623, i64 64
  %1625 = load ptr, ptr %1624, align 8
  %1626 = call ptr %1625({ ptr, ptr, ptr, i32 } %1619, ptr nonnull %2)
  %1627 = call i32 %1626({ ptr, ptr, ptr, i32 } %1619, { ptr, ptr, ptr, i32 } %1619, ptr nonnull %2)
  %1628 = add i32 %1627, -1
  %1629 = and i32 %1628, %1610
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1630 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1631 = load ptr, ptr %153, align 8
  %1632 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1631, 0
  %1633 = load ptr, ptr %154, align 8
  %1634 = insertvalue { ptr, ptr, ptr, i32 } %1632, ptr %1633, 1
  %1635 = load ptr, ptr %1567, align 8
  %1636 = insertvalue { ptr, ptr, ptr, i32 } %1634, ptr %1635, 2
  %1637 = load i32, ptr %155, align 4
  %1638 = insertvalue { ptr, ptr, ptr, i32 } %1636, i32 %1637, 3
  %hash_coef_ptr.i.i162.i552 = getelementptr i8, ptr %1631, i64 8
  %tbl_size_ptr.i.i163.i553 = getelementptr i8, ptr %1631, i64 16
  %offset_tbl_ptr.i.i164.i554 = getelementptr i8, ptr %1631, i64 40
  %hash_coef.i.i165.i555 = load i64, ptr %hash_coef_ptr.i.i162.i552, align 4
  %tbl_size.i.i166.i556 = load i64, ptr %tbl_size_ptr.i.i163.i553, align 4
  %offset_tbl.i.i167.i557 = load ptr, ptr %offset_tbl_ptr.i.i164.i554, align 8
  %product.i.i.i168.i558 = mul i64 %hash_coef.i.i165.i555, -5261542750394134544
  %shifted.i.i.i169.i559 = lshr i64 %product.i.i.i168.i558, 32
  %xored.i.i.i170.i560 = xor i64 %shifted.i.i.i169.i559, %product.i.i.i168.i558
  %hash.i.i.i171.i561 = and i64 %xored.i.i.i170.i560, %tbl_size.i.i166.i556
  %offset_ptr.i.i172.i562 = getelementptr i32, ptr %offset_tbl.i.i167.i557, i64 %hash.i.i.i171.i561
  %offset.i.i173.i563 = load i32, ptr %offset_ptr.i.i172.i562, align 4
  %eq.i.i564 = icmp eq i32 %1637, %offset.i.i173.i563
  call void @llvm.assume(i1 %eq.i.i564) #30
  store ptr @_parameterization_Ptri32, ptr %118, align 8
  %1639 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %118)
  %1640 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1631)
  %1641 = sext i32 %1637 to i64
  %1642 = getelementptr ptr, ptr %1631, i64 %1641
  %1643 = getelementptr i8, ptr %1642, i64 120
  %1644 = load ptr, ptr %1643, align 8
  store ptr @i32_typ, ptr %119, align 8
  %1645 = call ptr %1644({ ptr, ptr, ptr, i32 } %1638, ptr nonnull %119)
  %1646 = call { ptr, i160 } %1645({ ptr, ptr, ptr, i32 } %1638, { ptr, ptr, ptr, i32 } %1638, ptr nonnull %118, i32 %1629)
  %.fca.0.extract.i565 = extractvalue { ptr, i160 } %1646, 0
  %1647 = icmp ne ptr %.fca.0.extract.i565, @nil_typ
  %1648 = icmp ne ptr %.fca.0.extract.i565, null
  %.not149.i566 = and i1 %1647, %1648
  br i1 %.not149.i566, label %1649, label %.critedge.i567

1649:                                             ; preds = %._crit_edge
  %.fca.1.extract.i660 = extractvalue { ptr, i160 } %1646, 1
  %.sroa.4520.8.extract.trunc.i661 = trunc i160 %.fca.1.extract.i660 to i64
  %1650 = inttoptr i64 %.sroa.4520.8.extract.trunc.i661 to ptr
  %.sroa.7522.8.extract.shift.i662 = lshr i160 %.fca.1.extract.i660, 64
  %.sroa.7522.8.extract.trunc.i663 = trunc i160 %.sroa.7522.8.extract.shift.i662 to i64
  %1651 = inttoptr i64 %.sroa.7522.8.extract.trunc.i663 to ptr
  %hash_coef_ptr.i.i176.i664 = getelementptr i8, ptr %.fca.0.extract.i565, i64 8
  %tbl_size_ptr.i.i177.i665 = getelementptr i8, ptr %.fca.0.extract.i565, i64 16
  %offset_tbl_ptr.i.i178.i666 = getelementptr i8, ptr %.fca.0.extract.i565, i64 40
  %hash_coef.i.i179.i667 = load i64, ptr %hash_coef_ptr.i.i176.i664, align 4
  %tbl_size.i.i180.i668 = load i64, ptr %tbl_size_ptr.i.i177.i665, align 4
  %offset_tbl.i.i181.i669 = load ptr, ptr %offset_tbl_ptr.i.i178.i666, align 8
  %product.i.i.i182.i670 = mul i64 %hash_coef.i.i179.i667, 4015701072841558310
  %shifted.i.i.i183.i671 = lshr i64 %product.i.i.i182.i670, 32
  %xored.i.i.i184.i672 = xor i64 %shifted.i.i.i183.i671, %product.i.i.i182.i670
  %hash.i.i.i185.i673 = and i64 %xored.i.i.i184.i672, %tbl_size.i.i180.i668
  %offset_ptr.i.i186.i674 = getelementptr i32, ptr %offset_tbl.i.i181.i669, i64 %hash.i.i.i185.i673
  %offset.i.i187.i675 = load i32, ptr %offset_ptr.i.i186.i674, align 4
  %1652 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i565, 0
  %1653 = insertvalue { ptr, ptr, ptr, i32 } %1652, ptr %1650, 1
  %1654 = insertvalue { ptr, ptr, ptr, i32 } %1653, ptr %1651, 2
  %1655 = insertvalue { ptr, ptr, ptr, i32 } %1654, i32 %offset.i.i187.i675, 3
  %1656 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1657 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1658 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i565)
  %1659 = sext i32 %offset.i.i187.i675 to i64
  %1660 = getelementptr ptr, ptr %.fca.0.extract.i565, i64 %1659
  %1661 = getelementptr i8, ptr %1660, i64 64
  %1662 = load ptr, ptr %1661, align 8
  %1663 = call ptr %1662({ ptr, ptr, ptr, i32 } %1655, ptr nonnull %2)
  %1664 = call i32 %1663({ ptr, ptr, ptr, i32 } %1655, { ptr, ptr, ptr, i32 } %1655, ptr nonnull %2)
  %1665 = icmp eq i32 %1664, %1610
  %1666 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1667 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1668 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i565)
  %1669 = getelementptr i8, ptr %1660, i64 48
  %1670 = load ptr, ptr %1669, align 8
  %1671 = call ptr %1670({ ptr, ptr, ptr, i32 } %1655, ptr nonnull %2)
  %1672 = call { ptr, i160 } %1671({ ptr, ptr, ptr, i32 } %1655, { ptr, ptr, ptr, i32 } %1655, ptr nonnull %2)
  %1673 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1674 = load ptr, ptr %142, align 8
  %1675 = call i1 %1674({ ptr, i160 } %1672, { ptr, i160 } %1606)
  %1676 = and i1 %1665, %1675
  br i1 %1676, label %1677, label %.critedge.i567

1677:                                             ; preds = %1649
  %1678 = load ptr, ptr %result.i, align 8
  %1679 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1680 = load ptr, ptr %136, align 8
  %1681 = load ptr, ptr %1678, align 8
  %1682 = getelementptr i8, ptr %1681, i64 48
  %1683 = load ptr, ptr %1682, align 8
  %1684 = call { i64, i64 } %1683(ptr nonnull %1678)
  %1685 = extractvalue { i64, i64 } %1684, 0
  %1686 = extractvalue { i64, i64 } %1684, 1
  %1687 = urem i64 20, %1686
  %1688 = icmp eq i64 %1687, 0
  %1689 = sub i64 %1686, %1687
  %1690 = select i1 %1688, i64 0, i64 %1689
  %1691 = add i64 %1685, 20
  %1692 = add i64 %1691, %1690
  %1693 = load ptr, ptr %1680, align 8
  %1694 = getelementptr i8, ptr %1693, i64 48
  %1695 = load ptr, ptr %1694, align 8
  %1696 = call { i64, i64 } %1695(ptr nonnull %1680)
  %1697 = extractvalue { i64, i64 } %1696, 0
  %1698 = extractvalue { i64, i64 } %1696, 1
  %1699 = call i64 @llvm.umax.i64(i64 %1686, i64 %1698)
  %1700 = call i64 @llvm.umax.i64(i64 %1699, i64 8)
  %1701 = urem i64 %1692, %1698
  %1702 = icmp eq i64 %1701, 0
  %1703 = sub i64 %1698, %1701
  %1704 = select i1 %1702, i64 0, i64 %1703
  %1705 = add i64 %1697, %1692
  %1706 = add i64 %1705, %1704
  %1707 = urem i64 %1706, %1700
  %1708 = icmp eq i64 %1707, 0
  %1709 = sub i64 %1700, %1707
  %1710 = select i1 %1708, i64 0, i64 %1709
  %1711 = add i64 %1710, %1706
  %result.i.i677 = call noalias ptr @bump_malloc_inner(i64 noundef %1711, ptr nonnull @current_ptr) #29
  store ptr %1678, ptr %result.i.i677, align 8
  %1712 = getelementptr i8, ptr %result.i.i677, i64 8
  store ptr %1680, ptr %1712, align 8
  %1713 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i677)
  store ptr @Entry, ptr %109, align 8
  store ptr %result.i.i677, ptr %1562, align 8
  store i32 9, ptr %1563, align 8
  %1714 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %109)
  %1715 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1716 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1717 = load ptr, ptr %1678, align 8
  %1718 = getelementptr i8, ptr %1717, i64 48
  %1719 = load ptr, ptr %1718, align 8
  %1720 = call { i64, i64 } %1719(ptr nonnull %1678)
  %1721 = extractvalue { i64, i64 } %1720, 1
  %1722 = urem i64 20, %1721
  %1723 = icmp eq i64 %1722, 0
  %reass.sub3215 = sub i64 %1721, %1722
  %1724 = add i64 %reass.sub3215, 20
  %1725 = select i1 %1723, i64 20, i64 %1724
  %1726 = getelementptr i8, ptr %result.i.i677, i64 %1725
  %1727 = load ptr, ptr %result.i.i677, align 8
  %1728 = load ptr, ptr %1727, align 8
  %1729 = getelementptr i8, ptr %1728, i64 64
  %1730 = load ptr, ptr %1729, align 8
  call void %1730({ ptr, i160 } %1606, ptr nonnull %1727, ptr %1726)
  %1731 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1732 = load ptr, ptr %result.i.i677, align 8
  %1733 = load ptr, ptr %1732, align 8
  %1734 = getelementptr i8, ptr %1733, i64 48
  %1735 = load ptr, ptr %1734, align 8
  %1736 = call { i64, i64 } %1735(ptr nonnull %1732)
  %1737 = extractvalue { i64, i64 } %1736, 0
  %1738 = extractvalue { i64, i64 } %1736, 1
  %1739 = urem i64 20, %1738
  %1740 = icmp eq i64 %1739, 0
  %1741 = sub i64 %1738, %1739
  %1742 = select i1 %1740, i64 0, i64 %1741
  %1743 = add i64 %1737, 20
  %1744 = add i64 %1743, %1742
  %1745 = load ptr, ptr %1712, align 8
  %1746 = load ptr, ptr %1745, align 8
  %1747 = getelementptr i8, ptr %1746, i64 48
  %1748 = load ptr, ptr %1747, align 8
  %1749 = call { i64, i64 } %1748(ptr nonnull %1745)
  %1750 = extractvalue { i64, i64 } %1749, 1
  %1751 = urem i64 %1744, %1750
  %1752 = icmp eq i64 %1751, 0
  %1753 = sub i64 %1750, %1751
  %1754 = select i1 %1752, i64 0, i64 %1753
  %1755 = getelementptr i8, ptr %result.i.i677, i64 %1744
  %1756 = getelementptr i8, ptr %1755, i64 %1754
  %1757 = load ptr, ptr %1712, align 8
  %1758 = load ptr, ptr %1757, align 8
  %1759 = getelementptr i8, ptr %1758, i64 64
  %1760 = load ptr, ptr %1759, align 8
  call void %1760({ ptr, i160 } %1607, ptr nonnull %1757, ptr %1756)
  %1761 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1762 = getelementptr i8, ptr %result.i.i677, i64 16
  store i32 %1610, ptr %1762, align 4
  %1763 = load ptr, ptr %1564, align 8
  %1764 = ptrtoint ptr %result.i.i677 to i64
  %1765 = ptrtoint ptr %1763 to i64
  %.sroa.2127.0.insert.ext.i678 = zext i64 %1765 to i160
  %.sroa.2127.0.insert.shift.i679 = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i678, 64
  %.sroa.0126.0.insert.ext.i681 = zext i64 %1764 to i160
  %.sroa.2127.0.insert.insert.i680 = or disjoint i160 %.sroa.2127.0.insert.shift.i679, %.sroa.0126.0.insert.ext.i681
  %.sroa.0126.0.insert.insert.i682 = or disjoint i160 %.sroa.2127.0.insert.insert.i680, 3062541302288446171170371466885913903104
  %1766 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i682, 1
  %1767 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1768 = load ptr, ptr %153, align 8
  %1769 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1768, 0
  %1770 = load ptr, ptr %154, align 8
  %1771 = insertvalue { ptr, ptr, ptr, i32 } %1769, ptr %1770, 1
  %1772 = load ptr, ptr %1567, align 8
  %1773 = insertvalue { ptr, ptr, ptr, i32 } %1771, ptr %1772, 2
  %1774 = load i32, ptr %155, align 4
  %1775 = insertvalue { ptr, ptr, ptr, i32 } %1773, i32 %1774, 3
  %hash_coef_ptr.i.i204.i687 = getelementptr i8, ptr %1768, i64 8
  %tbl_size_ptr.i.i205.i688 = getelementptr i8, ptr %1768, i64 16
  %offset_tbl_ptr.i.i206.i689 = getelementptr i8, ptr %1768, i64 40
  %hash_coef.i.i207.i690 = load i64, ptr %hash_coef_ptr.i.i204.i687, align 4
  %tbl_size.i.i208.i691 = load i64, ptr %tbl_size_ptr.i.i205.i688, align 4
  %offset_tbl.i.i209.i692 = load ptr, ptr %offset_tbl_ptr.i.i206.i689, align 8
  %product.i.i.i210.i693 = mul i64 %hash_coef.i.i207.i690, -5261542750394134544
  %shifted.i.i.i211.i694 = lshr i64 %product.i.i.i210.i693, 32
  %xored.i.i.i212.i695 = xor i64 %shifted.i.i.i211.i694, %product.i.i.i210.i693
  %hash.i.i.i213.i696 = and i64 %xored.i.i.i212.i695, %tbl_size.i.i208.i691
  %offset_ptr.i.i214.i697 = getelementptr i32, ptr %offset_tbl.i.i209.i692, i64 %hash.i.i.i213.i696
  %offset.i.i215.i698 = load i32, ptr %offset_ptr.i.i214.i697, align 4
  %eq.i218.i699 = icmp eq i32 %1774, %offset.i.i215.i698
  call void @llvm.assume(i1 %eq.i218.i699) #30
  %1776 = load ptr, ptr %result.i, align 8
  %1777 = load ptr, ptr %136, align 8
  %result.i219.i700 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1778 = getelementptr i8, ptr %result.i219.i700, i64 16
  store ptr %1777, ptr %1778, align 8
  %1779 = getelementptr i8, ptr %result.i219.i700, i64 8
  store ptr %1776, ptr %1779, align 8
  %1780 = getelementptr i8, ptr %result.i219.i700, i64 24
  store ptr null, ptr %1780, align 8
  %1781 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i700)
  store ptr @Entry, ptr %result.i219.i700, align 8
  store ptr @_parameterization_Ptri32, ptr %110, align 8
  store ptr %result.i219.i700, ptr %1565, align 8
  %1782 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %110)
  %1783 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1768)
  %1784 = sext i32 %1774 to i64
  %1785 = getelementptr ptr, ptr %1768, i64 %1784
  %1786 = getelementptr i8, ptr %1785, i64 128
  %1787 = load ptr, ptr %1786, align 8
  store ptr @i32_typ, ptr %111, align 8
  store ptr @Entry, ptr %1566, align 8
  %1788 = call ptr %1787({ ptr, ptr, ptr, i32 } %1775, ptr nonnull %111)
  call void %1788({ ptr, ptr, ptr, i32 } %1775, { ptr, ptr, ptr, i32 } %1775, ptr nonnull %110, i32 %1629, { ptr, i160 } %1766)
  br label %HashMap_insert_keyK_valueV.exit701

.critedge.i567:                                   ; preds = %1649, %._crit_edge
  %1789 = add i32 %1610, 2127912214
  %1790 = shl i32 %1610, 12
  %1791 = add i32 %1789, %1790
  %1792 = ashr i32 %1791, 19
  %1793 = xor i32 %1791, %1792
  %1794 = xor i32 %1793, -949894596
  %1795 = add i32 %1794, 374761393
  %1796 = shl i32 %1794, 5
  %1797 = add i32 %1795, %1796
  %1798 = add i32 %1797, -744332180
  %1799 = shl i32 %1797, 9
  %1800 = xor i32 %1798, %1799
  %1801 = add i32 %1800, -42973499
  %1802 = shl i32 %1800, 3
  %1803 = add i32 %1801, %1802
  %1804 = ashr i32 %1803, 16
  %1805 = xor i32 %1803, %1804
  %1806 = xor i32 %1805, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1807 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1808 = load ptr, ptr %166, align 8
  %1809 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1808, 0
  %1810 = load ptr, ptr %167, align 8
  %1811 = insertvalue { ptr, ptr, ptr, i32 } %1809, ptr %1810, 1
  %1812 = load ptr, ptr %1568, align 8
  %1813 = insertvalue { ptr, ptr, ptr, i32 } %1811, ptr %1812, 2
  %1814 = load i32, ptr %168, align 4
  %1815 = insertvalue { ptr, ptr, ptr, i32 } %1813, i32 %1814, 3
  %hash_coef_ptr.i.i10.i1579 = getelementptr i8, ptr %1808, i64 8
  %tbl_size_ptr.i.i11.i1580 = getelementptr i8, ptr %1808, i64 16
  %offset_tbl_ptr.i.i12.i1581 = getelementptr i8, ptr %1808, i64 40
  %hash_coef.i.i13.i1582 = load i64, ptr %hash_coef_ptr.i.i10.i1579, align 4
  %tbl_size.i.i14.i1583 = load i64, ptr %tbl_size_ptr.i.i11.i1580, align 4
  %offset_tbl.i.i15.i1584 = load ptr, ptr %offset_tbl_ptr.i.i12.i1581, align 8
  %product.i.i.i16.i1585 = mul i64 %hash_coef.i.i13.i1582, -5261542750394134544
  %shifted.i.i.i17.i1586 = lshr i64 %product.i.i.i16.i1585, 32
  %xored.i.i.i18.i1587 = xor i64 %shifted.i.i.i17.i1586, %product.i.i.i16.i1585
  %hash.i.i.i19.i1588 = and i64 %xored.i.i.i18.i1587, %tbl_size.i.i14.i1583
  %offset_ptr.i.i20.i1589 = getelementptr i32, ptr %offset_tbl.i.i15.i1584, i64 %hash.i.i.i19.i1588
  %offset.i.i21.i1590 = load i32, ptr %offset_ptr.i.i20.i1589, align 4
  %eq.i.i1591 = icmp eq i32 %1814, %offset.i.i21.i1590
  call void @llvm.assume(i1 %eq.i.i1591) #30
  %1816 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1817 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1808)
  %1818 = sext i32 %1814 to i64
  %1819 = getelementptr ptr, ptr %1808, i64 %1818
  %1820 = getelementptr i8, ptr %1819, i64 64
  %1821 = load ptr, ptr %1820, align 8
  %1822 = call ptr %1821({ ptr, ptr, ptr, i32 } %1815, ptr nonnull %2)
  %1823 = call i32 %1822({ ptr, ptr, ptr, i32 } %1815, { ptr, ptr, ptr, i32 } %1815, ptr nonnull %2)
  %1824 = add i32 %1823, -1
  %1825 = and i32 %1824, %1806
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1826 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1827 = load ptr, ptr %166, align 8
  %1828 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1827, 0
  %1829 = load ptr, ptr %167, align 8
  %1830 = insertvalue { ptr, ptr, ptr, i32 } %1828, ptr %1829, 1
  %1831 = load ptr, ptr %1568, align 8
  %1832 = insertvalue { ptr, ptr, ptr, i32 } %1830, ptr %1831, 2
  %1833 = load i32, ptr %168, align 4
  %1834 = insertvalue { ptr, ptr, ptr, i32 } %1832, i32 %1833, 3
  %hash_coef_ptr.i.i221.i572 = getelementptr i8, ptr %1827, i64 8
  %tbl_size_ptr.i.i222.i573 = getelementptr i8, ptr %1827, i64 16
  %offset_tbl_ptr.i.i223.i574 = getelementptr i8, ptr %1827, i64 40
  %hash_coef.i.i224.i575 = load i64, ptr %hash_coef_ptr.i.i221.i572, align 4
  %tbl_size.i.i225.i576 = load i64, ptr %tbl_size_ptr.i.i222.i573, align 4
  %offset_tbl.i.i226.i577 = load ptr, ptr %offset_tbl_ptr.i.i223.i574, align 8
  %product.i.i.i227.i578 = mul i64 %hash_coef.i.i224.i575, -5261542750394134544
  %shifted.i.i.i228.i579 = lshr i64 %product.i.i.i227.i578, 32
  %xored.i.i.i229.i580 = xor i64 %shifted.i.i.i228.i579, %product.i.i.i227.i578
  %hash.i.i.i230.i581 = and i64 %xored.i.i.i229.i580, %tbl_size.i.i225.i576
  %offset_ptr.i.i231.i582 = getelementptr i32, ptr %offset_tbl.i.i226.i577, i64 %hash.i.i.i230.i581
  %offset.i.i232.i583 = load i32, ptr %offset_ptr.i.i231.i582, align 4
  %eq.i235.i584 = icmp eq i32 %1833, %offset.i.i232.i583
  call void @llvm.assume(i1 %eq.i235.i584) #30
  store ptr @_parameterization_Ptri32, ptr %112, align 8
  %1835 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %112)
  %1836 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1827)
  %1837 = sext i32 %1833 to i64
  %1838 = getelementptr ptr, ptr %1827, i64 %1837
  %1839 = getelementptr i8, ptr %1838, i64 120
  %1840 = load ptr, ptr %1839, align 8
  store ptr @i32_typ, ptr %113, align 8
  %1841 = call ptr %1840({ ptr, ptr, ptr, i32 } %1834, ptr nonnull %113)
  %1842 = call { ptr, i160 } %1841({ ptr, ptr, ptr, i32 } %1834, { ptr, ptr, ptr, i32 } %1834, ptr nonnull %112, i32 %1825)
  %.fca.0.extract102.i585 = extractvalue { ptr, i160 } %1842, 0
  %1843 = icmp ne ptr %.fca.0.extract102.i585, @nil_typ
  %1844 = icmp ne ptr %.fca.0.extract102.i585, null
  %.not151.i586 = and i1 %1843, %1844
  br i1 %.not151.i586, label %1845, label %.critedge158.i587

1845:                                             ; preds = %.critedge.i567
  %.fca.1.extract104.i619 = extractvalue { ptr, i160 } %1842, 1
  %.sroa.4.8.extract.trunc.i620 = trunc i160 %.fca.1.extract104.i619 to i64
  %1846 = inttoptr i64 %.sroa.4.8.extract.trunc.i620 to ptr
  %.sroa.7508.8.extract.shift.i621 = lshr i160 %.fca.1.extract104.i619, 64
  %.sroa.7508.8.extract.trunc.i622 = trunc i160 %.sroa.7508.8.extract.shift.i621 to i64
  %1847 = inttoptr i64 %.sroa.7508.8.extract.trunc.i622 to ptr
  %hash_coef_ptr.i.i237.i623 = getelementptr i8, ptr %.fca.0.extract102.i585, i64 8
  %tbl_size_ptr.i.i238.i624 = getelementptr i8, ptr %.fca.0.extract102.i585, i64 16
  %offset_tbl_ptr.i.i239.i625 = getelementptr i8, ptr %.fca.0.extract102.i585, i64 40
  %hash_coef.i.i240.i626 = load i64, ptr %hash_coef_ptr.i.i237.i623, align 4
  %tbl_size.i.i241.i627 = load i64, ptr %tbl_size_ptr.i.i238.i624, align 4
  %offset_tbl.i.i242.i628 = load ptr, ptr %offset_tbl_ptr.i.i239.i625, align 8
  %product.i.i.i243.i629 = mul i64 %hash_coef.i.i240.i626, 4015701072841558310
  %shifted.i.i.i244.i630 = lshr i64 %product.i.i.i243.i629, 32
  %xored.i.i.i245.i631 = xor i64 %shifted.i.i.i244.i630, %product.i.i.i243.i629
  %hash.i.i.i246.i632 = and i64 %xored.i.i.i245.i631, %tbl_size.i.i241.i627
  %offset_ptr.i.i247.i633 = getelementptr i32, ptr %offset_tbl.i.i242.i628, i64 %hash.i.i.i246.i632
  %offset.i.i248.i634 = load i32, ptr %offset_ptr.i.i247.i633, align 4
  %1848 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i585, 0
  %1849 = insertvalue { ptr, ptr, ptr, i32 } %1848, ptr %1846, 1
  %1850 = insertvalue { ptr, ptr, ptr, i32 } %1849, ptr %1847, 2
  %1851 = insertvalue { ptr, ptr, ptr, i32 } %1850, i32 %offset.i.i248.i634, 3
  %1852 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1853 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1854 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i585)
  %1855 = sext i32 %offset.i.i248.i634 to i64
  %1856 = getelementptr ptr, ptr %.fca.0.extract102.i585, i64 %1855
  %1857 = getelementptr i8, ptr %1856, i64 64
  %1858 = load ptr, ptr %1857, align 8
  %1859 = call ptr %1858({ ptr, ptr, ptr, i32 } %1851, ptr nonnull %2)
  %1860 = call i32 %1859({ ptr, ptr, ptr, i32 } %1851, { ptr, ptr, ptr, i32 } %1851, ptr nonnull %2)
  %1861 = icmp eq i32 %1860, %1610
  %1862 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1863 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1864 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i585)
  %1865 = getelementptr i8, ptr %1856, i64 48
  %1866 = load ptr, ptr %1865, align 8
  %1867 = call ptr %1866({ ptr, ptr, ptr, i32 } %1851, ptr nonnull %2)
  %1868 = call { ptr, i160 } %1867({ ptr, ptr, ptr, i32 } %1851, { ptr, ptr, ptr, i32 } %1851, ptr nonnull %2)
  %1869 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1870 = load ptr, ptr %142, align 8
  %1871 = call i1 %1870({ ptr, i160 } %1868, { ptr, i160 } %1606)
  %1872 = and i1 %1861, %1871
  br i1 %1872, label %1873, label %.critedge158.i587

1873:                                             ; preds = %1845
  %1874 = load ptr, ptr %result.i, align 8
  %1875 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1876 = load ptr, ptr %136, align 8
  %1877 = load ptr, ptr %1874, align 8
  %1878 = getelementptr i8, ptr %1877, i64 48
  %1879 = load ptr, ptr %1878, align 8
  %1880 = call { i64, i64 } %1879(ptr nonnull %1874)
  %1881 = extractvalue { i64, i64 } %1880, 0
  %1882 = extractvalue { i64, i64 } %1880, 1
  %1883 = urem i64 20, %1882
  %1884 = icmp eq i64 %1883, 0
  %1885 = sub i64 %1882, %1883
  %1886 = select i1 %1884, i64 0, i64 %1885
  %1887 = add i64 %1881, 20
  %1888 = add i64 %1887, %1886
  %1889 = load ptr, ptr %1876, align 8
  %1890 = getelementptr i8, ptr %1889, i64 48
  %1891 = load ptr, ptr %1890, align 8
  %1892 = call { i64, i64 } %1891(ptr nonnull %1876)
  %1893 = extractvalue { i64, i64 } %1892, 0
  %1894 = extractvalue { i64, i64 } %1892, 1
  %1895 = call i64 @llvm.umax.i64(i64 %1882, i64 %1894)
  %1896 = call i64 @llvm.umax.i64(i64 %1895, i64 8)
  %1897 = urem i64 %1888, %1894
  %1898 = icmp eq i64 %1897, 0
  %1899 = sub i64 %1894, %1897
  %1900 = select i1 %1898, i64 0, i64 %1899
  %1901 = add i64 %1893, %1888
  %1902 = add i64 %1901, %1900
  %1903 = urem i64 %1902, %1896
  %1904 = icmp eq i64 %1903, 0
  %1905 = sub i64 %1896, %1903
  %1906 = select i1 %1904, i64 0, i64 %1905
  %1907 = add i64 %1906, %1902
  %result.i250.i636 = call noalias ptr @bump_malloc_inner(i64 noundef %1907, ptr nonnull @current_ptr) #29
  store ptr %1874, ptr %result.i250.i636, align 8
  %1908 = getelementptr i8, ptr %result.i250.i636, i64 8
  store ptr %1876, ptr %1908, align 8
  %1909 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i636)
  store ptr @Entry, ptr %114, align 8
  store ptr %result.i250.i636, ptr %1557, align 8
  store i32 9, ptr %1558, align 8
  %1910 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %114)
  %1911 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1912 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1913 = load ptr, ptr %1874, align 8
  %1914 = getelementptr i8, ptr %1913, i64 48
  %1915 = load ptr, ptr %1914, align 8
  %1916 = call { i64, i64 } %1915(ptr nonnull %1874)
  %1917 = extractvalue { i64, i64 } %1916, 1
  %1918 = urem i64 20, %1917
  %1919 = icmp eq i64 %1918, 0
  %reass.sub3214 = sub i64 %1917, %1918
  %1920 = add i64 %reass.sub3214, 20
  %1921 = select i1 %1919, i64 20, i64 %1920
  %1922 = getelementptr i8, ptr %result.i250.i636, i64 %1921
  %1923 = load ptr, ptr %result.i250.i636, align 8
  %1924 = load ptr, ptr %1923, align 8
  %1925 = getelementptr i8, ptr %1924, i64 64
  %1926 = load ptr, ptr %1925, align 8
  call void %1926({ ptr, i160 } %1606, ptr nonnull %1923, ptr %1922)
  %1927 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1928 = load ptr, ptr %result.i250.i636, align 8
  %1929 = load ptr, ptr %1928, align 8
  %1930 = getelementptr i8, ptr %1929, i64 48
  %1931 = load ptr, ptr %1930, align 8
  %1932 = call { i64, i64 } %1931(ptr nonnull %1928)
  %1933 = extractvalue { i64, i64 } %1932, 0
  %1934 = extractvalue { i64, i64 } %1932, 1
  %1935 = urem i64 20, %1934
  %1936 = icmp eq i64 %1935, 0
  %1937 = sub i64 %1934, %1935
  %1938 = select i1 %1936, i64 0, i64 %1937
  %1939 = add i64 %1933, 20
  %1940 = add i64 %1939, %1938
  %1941 = load ptr, ptr %1908, align 8
  %1942 = load ptr, ptr %1941, align 8
  %1943 = getelementptr i8, ptr %1942, i64 48
  %1944 = load ptr, ptr %1943, align 8
  %1945 = call { i64, i64 } %1944(ptr nonnull %1941)
  %1946 = extractvalue { i64, i64 } %1945, 1
  %1947 = urem i64 %1940, %1946
  %1948 = icmp eq i64 %1947, 0
  %1949 = sub i64 %1946, %1947
  %1950 = select i1 %1948, i64 0, i64 %1949
  %1951 = getelementptr i8, ptr %result.i250.i636, i64 %1940
  %1952 = getelementptr i8, ptr %1951, i64 %1950
  %1953 = load ptr, ptr %1908, align 8
  %1954 = load ptr, ptr %1953, align 8
  %1955 = getelementptr i8, ptr %1954, i64 64
  %1956 = load ptr, ptr %1955, align 8
  call void %1956({ ptr, i160 } %1607, ptr nonnull %1953, ptr %1952)
  %1957 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1958 = getelementptr i8, ptr %result.i250.i636, i64 16
  store i32 %1610, ptr %1958, align 4
  %1959 = load ptr, ptr %1559, align 8
  %1960 = ptrtoint ptr %result.i250.i636 to i64
  %1961 = ptrtoint ptr %1959 to i64
  %.sroa.282.0.insert.ext.i637 = zext i64 %1961 to i160
  %.sroa.282.0.insert.shift.i638 = shl nuw nsw i160 %.sroa.282.0.insert.ext.i637, 64
  %.sroa.081.0.insert.ext.i640 = zext i64 %1960 to i160
  %.sroa.282.0.insert.insert.i639 = or disjoint i160 %.sroa.282.0.insert.shift.i638, %.sroa.081.0.insert.ext.i640
  %.sroa.081.0.insert.insert.i641 = or disjoint i160 %.sroa.282.0.insert.insert.i639, 3062541302288446171170371466885913903104
  %1962 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i641, 1
  %1963 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1964 = load ptr, ptr %166, align 8
  %1965 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1964, 0
  %1966 = load ptr, ptr %167, align 8
  %1967 = insertvalue { ptr, ptr, ptr, i32 } %1965, ptr %1966, 1
  %1968 = load ptr, ptr %1568, align 8
  %1969 = insertvalue { ptr, ptr, ptr, i32 } %1967, ptr %1968, 2
  %1970 = load i32, ptr %168, align 4
  %1971 = insertvalue { ptr, ptr, ptr, i32 } %1969, i32 %1970, 3
  %hash_coef_ptr.i.i266.i646 = getelementptr i8, ptr %1964, i64 8
  %tbl_size_ptr.i.i267.i647 = getelementptr i8, ptr %1964, i64 16
  %offset_tbl_ptr.i.i268.i648 = getelementptr i8, ptr %1964, i64 40
  %hash_coef.i.i269.i649 = load i64, ptr %hash_coef_ptr.i.i266.i646, align 4
  %tbl_size.i.i270.i650 = load i64, ptr %tbl_size_ptr.i.i267.i647, align 4
  %offset_tbl.i.i271.i651 = load ptr, ptr %offset_tbl_ptr.i.i268.i648, align 8
  %product.i.i.i272.i652 = mul i64 %hash_coef.i.i269.i649, -5261542750394134544
  %shifted.i.i.i273.i653 = lshr i64 %product.i.i.i272.i652, 32
  %xored.i.i.i274.i654 = xor i64 %shifted.i.i.i273.i653, %product.i.i.i272.i652
  %hash.i.i.i275.i655 = and i64 %xored.i.i.i274.i654, %tbl_size.i.i270.i650
  %offset_ptr.i.i276.i656 = getelementptr i32, ptr %offset_tbl.i.i271.i651, i64 %hash.i.i.i275.i655
  %offset.i.i277.i657 = load i32, ptr %offset_ptr.i.i276.i656, align 4
  %eq.i280.i658 = icmp eq i32 %1970, %offset.i.i277.i657
  call void @llvm.assume(i1 %eq.i280.i658) #30
  %1972 = load ptr, ptr %result.i, align 8
  %1973 = load ptr, ptr %136, align 8
  %result.i281.i659 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1974 = getelementptr i8, ptr %result.i281.i659, i64 16
  store ptr %1973, ptr %1974, align 8
  %1975 = getelementptr i8, ptr %result.i281.i659, i64 8
  store ptr %1972, ptr %1975, align 8
  %1976 = getelementptr i8, ptr %result.i281.i659, i64 24
  store ptr null, ptr %1976, align 8
  %1977 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i659)
  store ptr @Entry, ptr %result.i281.i659, align 8
  store ptr @_parameterization_Ptri32, ptr %115, align 8
  store ptr %result.i281.i659, ptr %1560, align 8
  %1978 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %115)
  %1979 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1964)
  %1980 = sext i32 %1970 to i64
  %1981 = getelementptr ptr, ptr %1964, i64 %1980
  %1982 = getelementptr i8, ptr %1981, i64 128
  %1983 = load ptr, ptr %1982, align 8
  store ptr @i32_typ, ptr %116, align 8
  store ptr @Entry, ptr %1561, align 8
  %1984 = call ptr %1983({ ptr, ptr, ptr, i32 } %1971, ptr nonnull %116)
  call void %1984({ ptr, ptr, ptr, i32 } %1971, { ptr, ptr, ptr, i32 } %1971, ptr nonnull %115, i32 %1825, { ptr, i160 } %1962)
  br label %HashMap_insert_keyK_valueV.exit701

.critedge158.i587:                                ; preds = %1845, %.critedge.i567
  %1985 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1986 = load ptr, ptr %153, align 8
  %1987 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1986, 0
  %1988 = load ptr, ptr %154, align 8
  %1989 = insertvalue { ptr, ptr, ptr, i32 } %1987, ptr %1988, 1
  %1990 = load ptr, ptr %1567, align 8
  %1991 = insertvalue { ptr, ptr, ptr, i32 } %1989, ptr %1990, 2
  %1992 = load i32, ptr %155, align 4
  %1993 = insertvalue { ptr, ptr, ptr, i32 } %1991, i32 %1992, 3
  %hash_coef_ptr.i.i283.i592 = getelementptr i8, ptr %1986, i64 8
  %tbl_size_ptr.i.i284.i593 = getelementptr i8, ptr %1986, i64 16
  %offset_tbl_ptr.i.i285.i594 = getelementptr i8, ptr %1986, i64 40
  %hash_coef.i.i286.i595 = load i64, ptr %hash_coef_ptr.i.i283.i592, align 4
  %tbl_size.i.i287.i596 = load i64, ptr %tbl_size_ptr.i.i284.i593, align 4
  %offset_tbl.i.i288.i597 = load ptr, ptr %offset_tbl_ptr.i.i285.i594, align 8
  %product.i.i.i289.i598 = mul i64 %hash_coef.i.i286.i595, -5261542750394134544
  %shifted.i.i.i290.i599 = lshr i64 %product.i.i.i289.i598, 32
  %xored.i.i.i291.i600 = xor i64 %shifted.i.i.i290.i599, %product.i.i.i289.i598
  %hash.i.i.i292.i601 = and i64 %xored.i.i.i291.i600, %tbl_size.i.i287.i596
  %offset_ptr.i.i293.i602 = getelementptr i32, ptr %offset_tbl.i.i288.i597, i64 %hash.i.i.i292.i601
  %offset.i.i294.i603 = load i32, ptr %offset_ptr.i.i293.i602, align 4
  %eq.i297.i604 = icmp eq i32 %1992, %offset.i.i294.i603
  call void @llvm.assume(i1 %eq.i297.i604) #30
  %1994 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1995 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1986)
  %1996 = sext i32 %1992 to i64
  %1997 = getelementptr ptr, ptr %1986, i64 %1996
  %1998 = getelementptr i8, ptr %1997, i64 64
  %1999 = load ptr, ptr %1998, align 8
  %2000 = call ptr %1999({ ptr, ptr, ptr, i32 } %1993, ptr nonnull %2)
  %2001 = call i32 %2000({ ptr, ptr, ptr, i32 } %1993, { ptr, ptr, ptr, i32 } %1993, ptr nonnull %2)
  %2002 = load i32, ptr %1569, align 4
  %.not.i605 = icmp slt i32 %2002, %2001
  br i1 %.not.i605, label %._crit_edge.i606, label %2003

2003:                                             ; preds = %.critedge158.i587
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %53)
  %2004 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2005 = load ptr, ptr %153, align 8
  %2006 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2005, 0
  %2007 = load ptr, ptr %154, align 8
  %2008 = insertvalue { ptr, ptr, ptr, i32 } %2006, ptr %2007, 1
  %2009 = load ptr, ptr %1567, align 8
  %2010 = insertvalue { ptr, ptr, ptr, i32 } %2008, ptr %2009, 2
  %2011 = load i32, ptr %155, align 4
  %2012 = insertvalue { ptr, ptr, ptr, i32 } %2010, i32 %2011, 3
  %hash_coef_ptr.i.i64.i1608 = getelementptr i8, ptr %2005, i64 8
  %tbl_size_ptr.i.i65.i1609 = getelementptr i8, ptr %2005, i64 16
  %offset_tbl_ptr.i.i66.i1610 = getelementptr i8, ptr %2005, i64 40
  %hash_coef.i.i67.i1611 = load i64, ptr %hash_coef_ptr.i.i64.i1608, align 4
  %tbl_size.i.i68.i1612 = load i64, ptr %tbl_size_ptr.i.i65.i1609, align 4
  %offset_tbl.i.i69.i1613 = load ptr, ptr %offset_tbl_ptr.i.i66.i1610, align 8
  %product.i.i.i70.i1614 = mul i64 %hash_coef.i.i67.i1611, -5261542750394134544
  %shifted.i.i.i71.i1615 = lshr i64 %product.i.i.i70.i1614, 32
  %xored.i.i.i72.i1616 = xor i64 %shifted.i.i.i71.i1615, %product.i.i.i70.i1614
  %hash.i.i.i73.i1617 = and i64 %xored.i.i.i72.i1616, %tbl_size.i.i68.i1612
  %offset_ptr.i.i74.i1618 = getelementptr i32, ptr %offset_tbl.i.i69.i1613, i64 %hash.i.i.i73.i1617
  %offset.i.i75.i1619 = load i32, ptr %offset_ptr.i.i74.i1618, align 4
  %eq.i.i1620 = icmp eq i32 %2011, %offset.i.i75.i1619
  call void @llvm.assume(i1 %eq.i.i1620) #30
  %2013 = load ptr, ptr %166, align 8
  %2014 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2013, 0
  %2015 = load ptr, ptr %167, align 8
  %2016 = insertvalue { ptr, ptr, ptr, i32 } %2014, ptr %2015, 1
  %2017 = load ptr, ptr %1568, align 8
  %2018 = insertvalue { ptr, ptr, ptr, i32 } %2016, ptr %2017, 2
  %2019 = load i32, ptr %168, align 4
  %2020 = insertvalue { ptr, ptr, ptr, i32 } %2018, i32 %2019, 3
  %hash_coef_ptr.i.i92.i1625 = getelementptr i8, ptr %2013, i64 8
  %tbl_size_ptr.i.i93.i1626 = getelementptr i8, ptr %2013, i64 16
  %offset_tbl_ptr.i.i94.i1627 = getelementptr i8, ptr %2013, i64 40
  %hash_coef.i.i95.i1628 = load i64, ptr %hash_coef_ptr.i.i92.i1625, align 4
  %tbl_size.i.i96.i1629 = load i64, ptr %tbl_size_ptr.i.i93.i1626, align 4
  %offset_tbl.i.i97.i1630 = load ptr, ptr %offset_tbl_ptr.i.i94.i1627, align 8
  %product.i.i.i98.i1631 = mul i64 %hash_coef.i.i95.i1628, -5261542750394134544
  %shifted.i.i.i99.i1632 = lshr i64 %product.i.i.i98.i1631, 32
  %xored.i.i.i100.i1633 = xor i64 %shifted.i.i.i99.i1632, %product.i.i.i98.i1631
  %hash.i.i.i101.i1634 = and i64 %xored.i.i.i100.i1633, %tbl_size.i.i96.i1629
  %offset_ptr.i.i102.i1635 = getelementptr i32, ptr %offset_tbl.i.i97.i1630, i64 %hash.i.i.i101.i1634
  %offset.i.i103.i1636 = load i32, ptr %offset_ptr.i.i102.i1635, align 4
  %eq.i106.i1637 = icmp eq i32 %2019, %offset.i.i103.i1636
  call void @llvm.assume(i1 %eq.i106.i1637) #30
  %2021 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2022 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2005)
  %2023 = sext i32 %2011 to i64
  %2024 = getelementptr ptr, ptr %2005, i64 %2023
  %2025 = getelementptr i8, ptr %2024, i64 64
  %2026 = load ptr, ptr %2025, align 8
  %2027 = call ptr %2026({ ptr, ptr, ptr, i32 } %2012, ptr nonnull %2)
  %2028 = call i32 %2027({ ptr, ptr, ptr, i32 } %2012, { ptr, ptr, ptr, i32 } %2012, ptr nonnull %2)
  %2029 = shl i32 %2028, 1
  %2030 = load i32, ptr %1569, align 4
  %2031 = load ptr, ptr %result.i, align 8
  %2032 = load ptr, ptr %136, align 8
  %2033 = sext i32 %2030 to i64
  %2034 = shl nsw i64 %2033, 5
  %result.i.i.i1640 = call noalias ptr @bump_malloc_inner(i64 noundef %2034, ptr nonnull @current_ptr) #29
  %2035 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2036 = icmp sgt i32 %2028, 0
  br i1 %2036, label %.lr.ph434.i1673, label %._crit_edge395.i1642

.lr.ph434.i1673:                                  ; preds = %2003
  %invariant.gep.i1641 = getelementptr i8, ptr %2005, i64 120
  %2037 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1676 = getelementptr ptr, ptr %invariant.gep.i1641, i64 %2023
  br label %2038

2038:                                             ; preds = %2060, %.lr.ph434.i1673
  %.reg2mem105.0432.i1674 = phi i32 [ 0, %.lr.ph434.i1673 ], [ %.reg2mem101.0.i1679, %2060 ]
  %.reg2mem103.0431.i1675 = phi i32 [ 0, %.lr.ph434.i1673 ], [ %2061, %2060 ]
  store ptr @_parameterization_Ptri32, ptr %48, align 8
  %2039 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %48)
  %2040 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2005)
  %2041 = load ptr, ptr %gep.i1676, align 8
  store ptr @i32_typ, ptr %49, align 8
  %2042 = call ptr %2041({ ptr, ptr, ptr, i32 } %2012, ptr nonnull %49)
  %2043 = call { ptr, i160 } %2042({ ptr, ptr, ptr, i32 } %2012, { ptr, ptr, ptr, i32 } %2012, ptr nonnull %48, i32 %.reg2mem103.0431.i1675)
  %.fca.0.extract52.i1677 = extractvalue { ptr, i160 } %2043, 0
  %2044 = icmp ne ptr %.fca.0.extract52.i1677, @nil_typ
  %2045 = icmp ne ptr %.fca.0.extract52.i1677, null
  %.not60.i1678 = and i1 %2044, %2045
  br i1 %.not60.i1678, label %2046, label %2060

2046:                                             ; preds = %2038
  %hash_coef_ptr.i.i137.i1705 = getelementptr i8, ptr %.fca.0.extract52.i1677, i64 8
  %tbl_size_ptr.i.i138.i1706 = getelementptr i8, ptr %.fca.0.extract52.i1677, i64 16
  %offset_tbl_ptr.i.i139.i1707 = getelementptr i8, ptr %.fca.0.extract52.i1677, i64 40
  %hash_coef.i.i140.i1708 = load i64, ptr %hash_coef_ptr.i.i137.i1705, align 4
  %tbl_size.i.i141.i1709 = load i64, ptr %tbl_size_ptr.i.i138.i1706, align 4
  %offset_tbl.i.i142.i1710 = load ptr, ptr %offset_tbl_ptr.i.i139.i1707, align 8
  %product.i.i.i143.i1711 = mul i64 %hash_coef.i.i140.i1708, 4015701072841558310
  %shifted.i.i.i144.i1712 = lshr i64 %product.i.i.i143.i1711, 32
  %xored.i.i.i145.i1713 = xor i64 %shifted.i.i.i144.i1712, %product.i.i.i143.i1711
  %hash.i.i.i146.i1714 = and i64 %xored.i.i.i145.i1713, %tbl_size.i.i141.i1709
  %offset_ptr.i.i147.i1715 = getelementptr i32, ptr %offset_tbl.i.i142.i1710, i64 %hash.i.i.i146.i1714
  %offset.i.i148.i1716 = load i32, ptr %offset_ptr.i.i147.i1715, align 4
  %2047 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2048 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2049 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2050 = icmp slt i32 %.reg2mem105.0432.i1674, %2030
  br i1 %2050, label %2051, label %._crit_edge.i1717

2051:                                             ; preds = %2046
  %.fca.1.extract54.i1718 = extractvalue { ptr, i160 } %2043, 1
  %.sroa.351.0.insert.ext.i1719 = zext i32 %offset.i.i148.i1716 to i160
  %.sroa.351.0.insert.shift.i1720 = shl nuw i160 %.sroa.351.0.insert.ext.i1719, 128
  %2052 = and i160 %.fca.1.extract54.i1718, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1721 = or disjoint i160 %.sroa.351.0.insert.shift.i1720, %2052
  %2053 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2054 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2055 = sext i32 %.reg2mem105.0432.i1674 to i64
  %2056 = shl nsw i64 %2055, 5
  %2057 = getelementptr i8, ptr %result.i.i.i1640, i64 %2056
  store ptr %.fca.0.extract52.i1677, ptr %2057, align 8
  %2058 = getelementptr i8, ptr %2057, i64 8
  store i160 %.sroa.049.0.insert.insert.i1721, ptr %2058, align 4
  br label %._crit_edge.i1717

._crit_edge.i1717:                                ; preds = %2051, %2046
  %2059 = add i32 %.reg2mem105.0432.i1674, 1
  br label %2060

2060:                                             ; preds = %._crit_edge.i1717, %2038
  %.reg2mem101.0.i1679 = phi i32 [ %2059, %._crit_edge.i1717 ], [ %.reg2mem105.0432.i1674, %2038 ]
  %2061 = add nuw nsw i32 %.reg2mem103.0431.i1675, 1
  %2062 = icmp slt i32 %2061, %2028
  br i1 %2062, label %2038, label %.lr.ph.i1680

.lr.ph.i1680:                                     ; preds = %2060
  %invariant.gep396.i1681 = getelementptr i8, ptr %2013, i64 120
  %2063 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2064 = sext i32 %2019 to i64
  %gep397.i1684 = getelementptr ptr, ptr %invariant.gep396.i1681, i64 %2064
  br label %2065

2065:                                             ; preds = %2087, %.lr.ph.i1680
  %.reg2mem91.0394.i1682 = phi i32 [ %.reg2mem101.0.i1679, %.lr.ph.i1680 ], [ %.reg2mem87.0.i1686, %2087 ]
  %.reg2mem89.0393.i1683 = phi i32 [ 0, %.lr.ph.i1680 ], [ %2088, %2087 ]
  store ptr @_parameterization_Ptri32, ptr %50, align 8
  %2066 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %50)
  %2067 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2013)
  %2068 = load ptr, ptr %gep397.i1684, align 8
  store ptr @i32_typ, ptr %51, align 8
  %2069 = call ptr %2068({ ptr, ptr, ptr, i32 } %2020, ptr nonnull %51)
  %2070 = call { ptr, i160 } %2069({ ptr, ptr, ptr, i32 } %2020, { ptr, ptr, ptr, i32 } %2020, ptr nonnull %50, i32 %.reg2mem89.0393.i1683)
  %.fca.0.extract42.i = extractvalue { ptr, i160 } %2070, 0
  %2071 = icmp ne ptr %.fca.0.extract42.i, @nil_typ
  %2072 = icmp ne ptr %.fca.0.extract42.i, null
  %.not62.i1685 = and i1 %2071, %2072
  br i1 %.not62.i1685, label %2073, label %2087

2073:                                             ; preds = %2065
  %hash_coef_ptr.i.i152.i1687 = getelementptr i8, ptr %.fca.0.extract42.i, i64 8
  %tbl_size_ptr.i.i153.i1688 = getelementptr i8, ptr %.fca.0.extract42.i, i64 16
  %offset_tbl_ptr.i.i154.i1689 = getelementptr i8, ptr %.fca.0.extract42.i, i64 40
  %hash_coef.i.i155.i1690 = load i64, ptr %hash_coef_ptr.i.i152.i1687, align 4
  %tbl_size.i.i156.i1691 = load i64, ptr %tbl_size_ptr.i.i153.i1688, align 4
  %offset_tbl.i.i157.i1692 = load ptr, ptr %offset_tbl_ptr.i.i154.i1689, align 8
  %product.i.i.i158.i1693 = mul i64 %hash_coef.i.i155.i1690, 4015701072841558310
  %shifted.i.i.i159.i1694 = lshr i64 %product.i.i.i158.i1693, 32
  %xored.i.i.i160.i1695 = xor i64 %shifted.i.i.i159.i1694, %product.i.i.i158.i1693
  %hash.i.i.i161.i1696 = and i64 %xored.i.i.i160.i1695, %tbl_size.i.i156.i1691
  %offset_ptr.i.i162.i1697 = getelementptr i32, ptr %offset_tbl.i.i157.i1692, i64 %hash.i.i.i161.i1696
  %offset.i.i163.i1698 = load i32, ptr %offset_ptr.i.i162.i1697, align 4
  %2074 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2075 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2076 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2077 = icmp slt i32 %.reg2mem91.0394.i1682, %2030
  br i1 %2077, label %2078, label %._crit_edge1.i1699

2078:                                             ; preds = %2073
  %.fca.1.extract44.i1700 = extractvalue { ptr, i160 } %2070, 1
  %.sroa.3.0.insert.ext.i1701 = zext i32 %offset.i.i163.i1698 to i160
  %.sroa.3.0.insert.shift.i1702 = shl nuw i160 %.sroa.3.0.insert.ext.i1701, 128
  %2079 = and i160 %.fca.1.extract44.i1700, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1703 = or disjoint i160 %.sroa.3.0.insert.shift.i1702, %2079
  %2080 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2081 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2082 = sext i32 %.reg2mem91.0394.i1682 to i64
  %2083 = shl nsw i64 %2082, 5
  %2084 = getelementptr i8, ptr %result.i.i.i1640, i64 %2083
  store ptr %.fca.0.extract42.i, ptr %2084, align 8
  %2085 = getelementptr i8, ptr %2084, i64 8
  store i160 %.sroa.040.0.insert.insert.i1703, ptr %2085, align 4
  br label %._crit_edge1.i1699

._crit_edge1.i1699:                               ; preds = %2078, %2073
  %2086 = add i32 %.reg2mem91.0394.i1682, 1
  br label %2087

2087:                                             ; preds = %._crit_edge1.i1699, %2065
  %.reg2mem87.0.i1686 = phi i32 [ %2086, %._crit_edge1.i1699 ], [ %.reg2mem91.0394.i1682, %2065 ]
  %2088 = add nuw nsw i32 %.reg2mem89.0393.i1683, 1
  %2089 = icmp slt i32 %2088, %2028
  br i1 %2089, label %2065, label %._crit_edge395.i1642.loopexit

._crit_edge395.i1642.loopexit:                    ; preds = %2087
  %.pre2857 = load ptr, ptr %result.i, align 8
  %.pre2858 = load ptr, ptr %136, align 8
  br label %._crit_edge395.i1642

._crit_edge395.i1642:                             ; preds = %._crit_edge395.i1642.loopexit, %2003
  %2090 = phi ptr [ %2032, %2003 ], [ %.pre2858, %._crit_edge395.i1642.loopexit ]
  %2091 = phi ptr [ %2031, %2003 ], [ %.pre2857, %._crit_edge395.i1642.loopexit ]
  %.reg2mem91.0.lcssa.i1643 = phi i32 [ 0, %2003 ], [ %.reg2mem87.0.i1686, %._crit_edge395.i1642.loopexit ]
  %2092 = call i32 @llvm.smax.i32(i32 %2029, i32 16)
  %result.i166.i1644 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2093 = getelementptr i8, ptr %result.i166.i1644, i64 16
  store ptr @_parameterization_Nil, ptr %2093, align 8
  %result.i167.i1645 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2094 = getelementptr i8, ptr %result.i167.i1645, i64 16
  store ptr %2090, ptr %2094, align 8
  %2095 = getelementptr i8, ptr %result.i167.i1645, i64 8
  store ptr %2091, ptr %2095, align 8
  %2096 = getelementptr i8, ptr %result.i167.i1645, i64 24
  store ptr null, ptr %2096, align 8
  %2097 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1645)
  store ptr @Entry, ptr %result.i167.i1645, align 8
  %2098 = getelementptr i8, ptr %result.i166.i1644, i64 8
  store ptr %result.i167.i1645, ptr %2098, align 8
  %2099 = getelementptr i8, ptr %result.i166.i1644, i64 24
  store ptr null, ptr %2099, align 8
  %2100 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1644)
  store ptr @union_typ, ptr %result.i166.i1644, align 8
  %result.i168.i1646 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1644, ptr %result.i168.i1646, align 8
  %2101 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1646)
  store ptr @Array, ptr %52, align 8
  store ptr %result.i168.i1646, ptr %1570, align 8
  store i32 9, ptr %1571, align 8
  %2102 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %52)
  %2103 = getelementptr i8, ptr %result.i168.i1646, i64 16
  store i32 %2092, ptr %2103, align 4
  %2104 = getelementptr i8, ptr %result.i168.i1646, i64 20
  store i32 %2092, ptr %2104, align 4
  %2105 = zext nneg i32 %2092 to i64
  %2106 = shl nuw nsw i64 %2105, 5
  %result.i.i416.i1647 = call noalias ptr @bump_malloc_inner(i64 noundef %2106, ptr nonnull @current_ptr) #29
  %2107 = getelementptr i8, ptr %result.i168.i1646, i64 8
  store ptr %result.i.i416.i1647, ptr %2107, align 8
  %2108 = load ptr, ptr %1572, align 8
  store ptr @Array, ptr %153, align 8
  store ptr %result.i168.i1646, ptr %154, align 8
  store ptr %2108, ptr %1567, align 8
  store i32 9, ptr %155, align 4
  %2109 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i1648 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2110 = getelementptr i8, ptr %result.i183.i1648, i64 16
  store ptr @_parameterization_Nil, ptr %2110, align 8
  %result.i184.i1649 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2111 = getelementptr i8, ptr %result.i184.i1649, i64 16
  store ptr %2090, ptr %2111, align 8
  %2112 = getelementptr i8, ptr %result.i184.i1649, i64 8
  store ptr %2091, ptr %2112, align 8
  %2113 = getelementptr i8, ptr %result.i184.i1649, i64 24
  store ptr null, ptr %2113, align 8
  %2114 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1649)
  store ptr @Entry, ptr %result.i184.i1649, align 8
  %2115 = getelementptr i8, ptr %result.i183.i1648, i64 8
  store ptr %result.i184.i1649, ptr %2115, align 8
  %2116 = getelementptr i8, ptr %result.i183.i1648, i64 24
  store ptr null, ptr %2116, align 8
  %2117 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1648)
  store ptr @union_typ, ptr %result.i183.i1648, align 8
  %result.i185.i1650 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1648, ptr %result.i185.i1650, align 8
  %2118 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1650)
  store ptr @Array, ptr %53, align 8
  store ptr %result.i185.i1650, ptr %1573, align 8
  store i32 9, ptr %1574, align 8
  %2119 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %53)
  %2120 = getelementptr i8, ptr %result.i185.i1650, i64 16
  store i32 %2092, ptr %2120, align 4
  %2121 = getelementptr i8, ptr %result.i185.i1650, i64 20
  store i32 %2092, ptr %2121, align 4
  %result.i.i430.i1651 = call noalias ptr @bump_malloc_inner(i64 noundef %2106, ptr nonnull @current_ptr) #29
  %2122 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2123 = getelementptr i8, ptr %result.i185.i1650, i64 8
  store ptr %result.i.i430.i1651, ptr %2123, align 8
  %2124 = load ptr, ptr %1575, align 8
  store ptr @Array, ptr %166, align 8
  store ptr %result.i185.i1650, ptr %167, align 8
  store ptr %2124, ptr %1568, align 8
  store i32 9, ptr %168, align 4
  store i32 0, ptr %1569, align 4
  %2125 = icmp sgt i32 %.reg2mem91.0.lcssa.i1643, 0
  br i1 %2125, label %.lr.ph400.i1652, label %HashMap_resize_.exit1723

.lr.ph400.i1652:                                  ; preds = %._crit_edge395.i1642
  %2126 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2127 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2128 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1653

._crit_edge2.i1653:                               ; preds = %._crit_edge2.i1653, %.lr.ph400.i1652
  %.reg2mem77.0398.i1654 = phi i32 [ 0, %.lr.ph400.i1652 ], [ %2142, %._crit_edge2.i1653 ]
  %2129 = zext nneg i32 %.reg2mem77.0398.i1654 to i64
  %2130 = shl nuw nsw i64 %2129, 5
  %2131 = getelementptr i8, ptr %result.i.i.i1640, i64 %2130
  %2132 = load ptr, ptr %2131, align 8
  %2133 = getelementptr i8, ptr %2131, i64 8
  %2134 = load i160, ptr %2133, align 4
  %.sroa.3362.8.extract.trunc.i1657 = trunc i160 %2134 to i64
  %2135 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1657 to ptr
  %.sroa.5363.8.extract.shift.i1658 = lshr i160 %2134, 64
  %.sroa.5363.8.extract.trunc.i1659 = trunc i160 %.sroa.5363.8.extract.shift.i1658 to i64
  %2136 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1659 to ptr
  %hash_coef_ptr.i.i201.i1660 = getelementptr i8, ptr %2132, i64 8
  %tbl_size_ptr.i.i202.i1661 = getelementptr i8, ptr %2132, i64 16
  %offset_tbl_ptr.i.i203.i1662 = getelementptr i8, ptr %2132, i64 40
  %hash_coef.i.i232.i1663 = load i64, ptr %hash_coef_ptr.i.i201.i1660, align 4
  %tbl_size.i.i233.i1664 = load i64, ptr %tbl_size_ptr.i.i202.i1661, align 4
  %offset_tbl.i.i234.i1665 = load ptr, ptr %offset_tbl_ptr.i.i203.i1662, align 8
  %product.i.i.i235.i1666 = mul i64 %hash_coef.i.i232.i1663, 4015701072841558310
  %shifted.i.i.i236.i1667 = lshr i64 %product.i.i.i235.i1666, 32
  %xored.i.i.i237.i1668 = xor i64 %shifted.i.i.i236.i1667, %product.i.i.i235.i1666
  %hash.i.i.i238.i1669 = and i64 %xored.i.i.i237.i1668, %tbl_size.i.i233.i1664
  %offset_ptr.i.i239.i1670 = getelementptr i32, ptr %offset_tbl.i.i234.i1665, i64 %hash.i.i.i238.i1669
  %offset.i.i240.i1671 = load i32, ptr %offset_ptr.i.i239.i1670, align 4
  %2137 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2132, 0
  %2138 = insertvalue { ptr, ptr, ptr, i32 } %2137, ptr %2135, 1
  %2139 = insertvalue { ptr, ptr, ptr, i32 } %2138, ptr %2136, 2
  %2140 = insertvalue { ptr, ptr, ptr, i32 } %2139, i32 %offset.i.i240.i1671, 3
  %2141 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %1578, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2140)
  %2142 = add nuw nsw i32 %.reg2mem77.0398.i1654, 1
  %2143 = icmp slt i32 %2142, %.reg2mem91.0.lcssa.i1643
  br i1 %2143, label %._crit_edge2.i1653, label %HashMap_resize_.exit1723

HashMap_resize_.exit1723:                         ; preds = %._crit_edge2.i1653, %._crit_edge395.i1642
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %53)
  br label %._crit_edge.i606

._crit_edge.i606:                                 ; preds = %HashMap_resize_.exit1723, %.critedge158.i587
  %2144 = load ptr, ptr %result.i, align 8
  %2145 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2146 = load ptr, ptr %136, align 8
  %2147 = load ptr, ptr %2144, align 8
  %2148 = getelementptr i8, ptr %2147, i64 48
  %2149 = load ptr, ptr %2148, align 8
  %2150 = call { i64, i64 } %2149(ptr nonnull %2144)
  %2151 = extractvalue { i64, i64 } %2150, 0
  %2152 = extractvalue { i64, i64 } %2150, 1
  %2153 = urem i64 20, %2152
  %2154 = icmp eq i64 %2153, 0
  %2155 = sub i64 %2152, %2153
  %2156 = select i1 %2154, i64 0, i64 %2155
  %2157 = add i64 %2151, 20
  %2158 = add i64 %2157, %2156
  %2159 = load ptr, ptr %2146, align 8
  %2160 = getelementptr i8, ptr %2159, i64 48
  %2161 = load ptr, ptr %2160, align 8
  %2162 = call { i64, i64 } %2161(ptr nonnull %2146)
  %2163 = extractvalue { i64, i64 } %2162, 0
  %2164 = extractvalue { i64, i64 } %2162, 1
  %2165 = call i64 @llvm.umax.i64(i64 %2152, i64 %2164)
  %2166 = call i64 @llvm.umax.i64(i64 %2165, i64 8)
  %2167 = urem i64 %2158, %2164
  %2168 = icmp eq i64 %2167, 0
  %2169 = sub i64 %2164, %2167
  %2170 = select i1 %2168, i64 0, i64 %2169
  %2171 = add i64 %2163, %2158
  %2172 = add i64 %2171, %2170
  %2173 = urem i64 %2172, %2166
  %2174 = icmp eq i64 %2173, 0
  %2175 = sub i64 %2166, %2173
  %2176 = select i1 %2174, i64 0, i64 %2175
  %2177 = add i64 %2176, %2172
  %result.i298.i607 = call noalias ptr @bump_malloc_inner(i64 noundef %2177, ptr nonnull @current_ptr) #29
  store ptr %2144, ptr %result.i298.i607, align 8
  %2178 = getelementptr i8, ptr %result.i298.i607, i64 8
  store ptr %2146, ptr %2178, align 8
  %2179 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i607)
  store ptr @Entry, ptr %117, align 8
  store ptr %result.i298.i607, ptr %1554, align 8
  store i32 9, ptr %1555, align 8
  %2180 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %117)
  %2181 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2182 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2183 = load ptr, ptr %2144, align 8
  %2184 = getelementptr i8, ptr %2183, i64 48
  %2185 = load ptr, ptr %2184, align 8
  %2186 = call { i64, i64 } %2185(ptr nonnull %2144)
  %2187 = extractvalue { i64, i64 } %2186, 1
  %2188 = urem i64 20, %2187
  %2189 = icmp eq i64 %2188, 0
  %reass.sub3213 = sub i64 %2187, %2188
  %2190 = add i64 %reass.sub3213, 20
  %2191 = select i1 %2189, i64 20, i64 %2190
  %2192 = getelementptr i8, ptr %result.i298.i607, i64 %2191
  %2193 = load ptr, ptr %result.i298.i607, align 8
  %2194 = load ptr, ptr %2193, align 8
  %2195 = getelementptr i8, ptr %2194, i64 64
  %2196 = load ptr, ptr %2195, align 8
  call void %2196({ ptr, i160 } %1606, ptr nonnull %2193, ptr %2192)
  %2197 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2198 = load ptr, ptr %result.i298.i607, align 8
  %2199 = load ptr, ptr %2198, align 8
  %2200 = getelementptr i8, ptr %2199, i64 48
  %2201 = load ptr, ptr %2200, align 8
  %2202 = call { i64, i64 } %2201(ptr nonnull %2198)
  %2203 = extractvalue { i64, i64 } %2202, 0
  %2204 = extractvalue { i64, i64 } %2202, 1
  %2205 = urem i64 20, %2204
  %2206 = icmp eq i64 %2205, 0
  %2207 = sub i64 %2204, %2205
  %2208 = select i1 %2206, i64 0, i64 %2207
  %2209 = add i64 %2203, 20
  %2210 = add i64 %2209, %2208
  %2211 = load ptr, ptr %2178, align 8
  %2212 = load ptr, ptr %2211, align 8
  %2213 = getelementptr i8, ptr %2212, i64 48
  %2214 = load ptr, ptr %2213, align 8
  %2215 = call { i64, i64 } %2214(ptr nonnull %2211)
  %2216 = extractvalue { i64, i64 } %2215, 1
  %2217 = urem i64 %2210, %2216
  %2218 = icmp eq i64 %2217, 0
  %2219 = sub i64 %2216, %2217
  %2220 = select i1 %2218, i64 0, i64 %2219
  %2221 = getelementptr i8, ptr %result.i298.i607, i64 %2210
  %2222 = getelementptr i8, ptr %2221, i64 %2220
  %2223 = load ptr, ptr %2178, align 8
  %2224 = load ptr, ptr %2223, align 8
  %2225 = getelementptr i8, ptr %2224, i64 64
  %2226 = load ptr, ptr %2225, align 8
  call void %2226({ ptr, i160 } %1607, ptr nonnull %2223, ptr %2222)
  %2227 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2228 = getelementptr i8, ptr %result.i298.i607, i64 16
  store i32 %1610, ptr %2228, align 4
  %2229 = load ptr, ptr %1556, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i1724)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1725)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %47)
  store ptr @Entry, ptr %47, align 8
  store ptr %result.i298.i607, ptr %1579, align 8
  store ptr %2229, ptr %1580, align 8
  store i32 9, ptr %1581, align 8
  %2230 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %47)
  %2231 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2232 = load i32, ptr %169, align 4
  %2233 = icmp sgt i32 %2232, 0
  br i1 %2233, label %.lr.ph.i1755, label %._crit_edge1.i612

.lr.ph.i1755:                                     ; preds = %._crit_edge.i606
  %2234 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2235 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %2236

2236:                                             ; preds = %.cont.cont.i1806, %.lr.ph.i1755
  %offset.i.i260.i18212470 = phi i32 [ 9, %.lr.ph.i1755 ], [ %offset.i.i260.i1821, %.cont.cont.i1806 ]
  %.sroa.speculated346.i18092468 = phi ptr [ %2229, %.lr.ph.i1755 ], [ %.sroa.speculated346.i1809, %.cont.cont.i1806 ]
  %.sroa.speculated352.i18082466 = phi ptr [ %result.i298.i607, %.lr.ph.i1755 ], [ %.sroa.speculated352.i1808, %.cont.cont.i1806 ]
  %.reg2mem195.0678.i1756 = phi i32 [ 1, %.lr.ph.i1755 ], [ %2392, %.cont.cont.i1806 ]
  %.reg2mem193.0677.i1757 = phi i32 [ 0, %.lr.ph.i1755 ], [ %2393, %.cont.cont.i1806 ]
  %2237 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i18082466, 1
  %2238 = insertvalue { ptr, ptr, ptr, i32 } %2237, ptr %.sroa.speculated346.i18092468, 2
  %2239 = insertvalue { ptr, ptr, ptr, i32 } %2238, i32 %offset.i.i260.i18212470, 3
  %2240 = sext i32 %offset.i.i260.i18212470 to i64
  %gep2465 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %2240
  %2241 = load ptr, ptr %gep2465, align 8
  %2242 = call ptr %2241({ ptr, ptr, ptr, i32 } %2239, ptr nonnull %2)
  %2243 = call i32 %2242({ ptr, ptr, ptr, i32 } %2239, { ptr, ptr, ptr, i32 } %2239, ptr nonnull %2)
  %2244 = icmp eq i32 %.reg2mem195.0678.i1756, 1
  %2245 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %2244, label %2246, label %2310

2246:                                             ; preds = %2236
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2247 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2248 = load ptr, ptr %153, align 8
  %2249 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2248, 0
  %2250 = load ptr, ptr %154, align 8
  %2251 = insertvalue { ptr, ptr, ptr, i32 } %2249, ptr %2250, 1
  %2252 = load ptr, ptr %1567, align 8
  %2253 = insertvalue { ptr, ptr, ptr, i32 } %2251, ptr %2252, 2
  %2254 = load i32, ptr %155, align 4
  %2255 = insertvalue { ptr, ptr, ptr, i32 } %2253, i32 %2254, 3
  %hash_coef_ptr.i.i10.i2937 = getelementptr i8, ptr %2248, i64 8
  %tbl_size_ptr.i.i11.i2938 = getelementptr i8, ptr %2248, i64 16
  %offset_tbl_ptr.i.i12.i2939 = getelementptr i8, ptr %2248, i64 40
  %hash_coef.i.i13.i2940 = load i64, ptr %hash_coef_ptr.i.i10.i2937, align 4
  %tbl_size.i.i14.i2941 = load i64, ptr %tbl_size_ptr.i.i11.i2938, align 4
  %offset_tbl.i.i15.i2942 = load ptr, ptr %offset_tbl_ptr.i.i12.i2939, align 8
  %product.i.i.i16.i2943 = mul i64 %hash_coef.i.i13.i2940, -5261542750394134544
  %shifted.i.i.i17.i2944 = lshr i64 %product.i.i.i16.i2943, 32
  %xored.i.i.i18.i2945 = xor i64 %shifted.i.i.i17.i2944, %product.i.i.i16.i2943
  %hash.i.i.i19.i2946 = and i64 %xored.i.i.i18.i2945, %tbl_size.i.i14.i2941
  %offset_ptr.i.i20.i2947 = getelementptr i32, ptr %offset_tbl.i.i15.i2942, i64 %hash.i.i.i19.i2946
  %offset.i.i21.i2948 = load i32, ptr %offset_ptr.i.i20.i2947, align 4
  %eq.i.i2949 = icmp eq i32 %2254, %offset.i.i21.i2948
  call void @llvm.assume(i1 %eq.i.i2949) #30
  %2256 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2257 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2248)
  %2258 = sext i32 %2254 to i64
  %2259 = getelementptr ptr, ptr %2248, i64 %2258
  %2260 = getelementptr i8, ptr %2259, i64 64
  %2261 = load ptr, ptr %2260, align 8
  %2262 = call ptr %2261({ ptr, ptr, ptr, i32 } %2255, ptr nonnull %2)
  %2263 = call i32 %2262({ ptr, ptr, ptr, i32 } %2255, { ptr, ptr, ptr, i32 } %2255, ptr nonnull %2)
  %2264 = add i32 %2263, -1
  %2265 = and i32 %2264, %2243
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2266 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2267 = load ptr, ptr %153, align 8
  %2268 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2267, 0
  %2269 = load ptr, ptr %154, align 8
  %2270 = insertvalue { ptr, ptr, ptr, i32 } %2268, ptr %2269, 1
  %2271 = load ptr, ptr %1567, align 8
  %2272 = insertvalue { ptr, ptr, ptr, i32 } %2270, ptr %2271, 2
  %2273 = load i32, ptr %155, align 4
  %2274 = insertvalue { ptr, ptr, ptr, i32 } %2272, i32 %2273, 3
  %hash_coef_ptr.i.i172.i1826 = getelementptr i8, ptr %2267, i64 8
  %tbl_size_ptr.i.i173.i1827 = getelementptr i8, ptr %2267, i64 16
  %offset_tbl_ptr.i.i174.i1828 = getelementptr i8, ptr %2267, i64 40
  %hash_coef.i.i175.i1829 = load i64, ptr %hash_coef_ptr.i.i172.i1826, align 4
  %tbl_size.i.i176.i1830 = load i64, ptr %tbl_size_ptr.i.i173.i1827, align 4
  %offset_tbl.i.i177.i1831 = load ptr, ptr %offset_tbl_ptr.i.i174.i1828, align 8
  %product.i.i.i178.i1832 = mul i64 %hash_coef.i.i175.i1829, -5261542750394134544
  %shifted.i.i.i179.i1833 = lshr i64 %product.i.i.i178.i1832, 32
  %xored.i.i.i180.i1834 = xor i64 %shifted.i.i.i179.i1833, %product.i.i.i178.i1832
  %hash.i.i.i181.i1835 = and i64 %xored.i.i.i180.i1834, %tbl_size.i.i176.i1830
  %offset_ptr.i.i182.i1836 = getelementptr i32, ptr %offset_tbl.i.i177.i1831, i64 %hash.i.i.i181.i1835
  %offset.i.i183.i1837 = load i32, ptr %offset_ptr.i.i182.i1836, align 4
  %eq.i.i1838 = icmp eq i32 %2273, %offset.i.i183.i1837
  call void @llvm.assume(i1 %eq.i.i1838) #30
  store ptr @_parameterization_Ptri32, ptr %31, align 8
  %2275 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %31)
  %2276 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2267)
  %2277 = sext i32 %2273 to i64
  %2278 = getelementptr ptr, ptr %2267, i64 %2277
  %2279 = getelementptr i8, ptr %2278, i64 120
  %2280 = load ptr, ptr %2279, align 8
  store ptr @i32_typ, ptr %32, align 8
  %2281 = call ptr %2280({ ptr, ptr, ptr, i32 } %2274, ptr nonnull %32)
  %2282 = call { ptr, i160 } %2281({ ptr, ptr, ptr, i32 } %2274, { ptr, ptr, ptr, i32 } %2274, ptr nonnull %31, i32 %2265)
  %.fca.0.extract112.i1839 = extractvalue { ptr, i160 } %2282, 0
  %2283 = ptrtoint ptr %.sroa.speculated352.i18082466 to i64
  %2284 = ptrtoint ptr %.sroa.speculated346.i18092468 to i64
  %.sroa.3111.0.insert.ext.i1840 = zext i32 %offset.i.i260.i18212470 to i160
  %.sroa.3111.0.insert.shift.i1841 = shl nuw i160 %.sroa.3111.0.insert.ext.i1840, 128
  %.sroa.2110.0.insert.ext.i1842 = zext i64 %2284 to i160
  %.sroa.2110.0.insert.shift.i1843 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i1842, 64
  %.sroa.2110.0.insert.insert.i1844 = or disjoint i160 %.sroa.2110.0.insert.shift.i1843, %.sroa.3111.0.insert.shift.i1841
  %.sroa.0109.0.insert.ext.i1845 = zext i64 %2283 to i160
  %.sroa.0109.0.insert.insert.i1846 = or disjoint i160 %.sroa.2110.0.insert.insert.i1844, %.sroa.0109.0.insert.ext.i1845
  %2285 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i1846, 1
  %2286 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2287 = load ptr, ptr %153, align 8
  %2288 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2287, 0
  %2289 = load ptr, ptr %154, align 8
  %2290 = insertvalue { ptr, ptr, ptr, i32 } %2288, ptr %2289, 1
  %2291 = load ptr, ptr %1567, align 8
  %2292 = insertvalue { ptr, ptr, ptr, i32 } %2290, ptr %2291, 2
  %2293 = load i32, ptr %155, align 4
  %2294 = insertvalue { ptr, ptr, ptr, i32 } %2292, i32 %2293, 3
  %hash_coef_ptr.i.i186.i1851 = getelementptr i8, ptr %2287, i64 8
  %tbl_size_ptr.i.i187.i1852 = getelementptr i8, ptr %2287, i64 16
  %offset_tbl_ptr.i.i188.i1853 = getelementptr i8, ptr %2287, i64 40
  %hash_coef.i.i189.i1854 = load i64, ptr %hash_coef_ptr.i.i186.i1851, align 4
  %tbl_size.i.i190.i1855 = load i64, ptr %tbl_size_ptr.i.i187.i1852, align 4
  %offset_tbl.i.i191.i1856 = load ptr, ptr %offset_tbl_ptr.i.i188.i1853, align 8
  %product.i.i.i192.i1857 = mul i64 %hash_coef.i.i189.i1854, -5261542750394134544
  %shifted.i.i.i193.i1858 = lshr i64 %product.i.i.i192.i1857, 32
  %xored.i.i.i194.i1859 = xor i64 %shifted.i.i.i193.i1858, %product.i.i.i192.i1857
  %hash.i.i.i195.i1860 = and i64 %xored.i.i.i194.i1859, %tbl_size.i.i190.i1855
  %offset_ptr.i.i196.i1861 = getelementptr i32, ptr %offset_tbl.i.i191.i1856, i64 %hash.i.i.i195.i1860
  %offset.i.i197.i1862 = load i32, ptr %offset_ptr.i.i196.i1861, align 4
  %eq.i200.i1863 = icmp eq i32 %2293, %offset.i.i197.i1862
  call void @llvm.assume(i1 %eq.i200.i1863) #30
  %2295 = load ptr, ptr %result.i, align 8
  %2296 = load ptr, ptr %136, align 8
  %result.i.i1864 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2297 = getelementptr i8, ptr %result.i.i1864, i64 16
  store ptr %2296, ptr %2297, align 8
  %2298 = getelementptr i8, ptr %result.i.i1864, i64 8
  store ptr %2295, ptr %2298, align 8
  %2299 = getelementptr i8, ptr %result.i.i1864, i64 24
  store ptr null, ptr %2299, align 8
  %2300 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1864)
  store ptr @Entry, ptr %result.i.i1864, align 8
  store ptr @_parameterization_Ptri32, ptr %33, align 8
  store ptr %result.i.i1864, ptr %1584, align 8
  %2301 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %33)
  %2302 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2287)
  %2303 = sext i32 %2293 to i64
  %2304 = getelementptr ptr, ptr %2287, i64 %2303
  %2305 = getelementptr i8, ptr %2304, i64 128
  %2306 = load ptr, ptr %2305, align 8
  store ptr @i32_typ, ptr %34, align 8
  store ptr @Entry, ptr %1585, align 8
  %2307 = call ptr %2306({ ptr, ptr, ptr, i32 } %2294, ptr nonnull %34)
  call void %2307({ ptr, ptr, ptr, i32 } %2294, { ptr, ptr, ptr, i32 } %2294, ptr nonnull %33, i32 %2265, { ptr, i160 } %2285)
  %2308 = icmp ne ptr %.fca.0.extract112.i1839, @nil_typ
  %2309 = icmp ne ptr %.fca.0.extract112.i1839, null
  %.not140.i1865 = and i1 %2308, %2309
  br i1 %.not140.i1865, label %.cont.cont.i1806, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2448

2310:                                             ; preds = %2236
  %2311 = add i32 %2243, 2127912214
  %2312 = shl i32 %2243, 12
  %2313 = add i32 %2311, %2312
  %2314 = ashr i32 %2313, 19
  %2315 = xor i32 %2313, %2314
  %2316 = xor i32 %2315, -949894596
  %2317 = add i32 %2316, 374761393
  %2318 = shl i32 %2316, 5
  %2319 = add i32 %2317, %2318
  %2320 = add i32 %2319, -744332180
  %2321 = shl i32 %2319, 9
  %2322 = xor i32 %2320, %2321
  %2323 = add i32 %2322, -42973499
  %2324 = shl i32 %2322, 3
  %2325 = add i32 %2323, %2324
  %2326 = ashr i32 %2325, 16
  %2327 = xor i32 %2325, %2326
  %2328 = xor i32 %2327, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2329 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2330 = load ptr, ptr %166, align 8
  %2331 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2330, 0
  %2332 = load ptr, ptr %167, align 8
  %2333 = insertvalue { ptr, ptr, ptr, i32 } %2331, ptr %2332, 1
  %2334 = load ptr, ptr %1568, align 8
  %2335 = insertvalue { ptr, ptr, ptr, i32 } %2333, ptr %2334, 2
  %2336 = load i32, ptr %168, align 4
  %2337 = insertvalue { ptr, ptr, ptr, i32 } %2335, i32 %2336, 3
  %hash_coef_ptr.i.i10.i2967 = getelementptr i8, ptr %2330, i64 8
  %tbl_size_ptr.i.i11.i2968 = getelementptr i8, ptr %2330, i64 16
  %offset_tbl_ptr.i.i12.i2969 = getelementptr i8, ptr %2330, i64 40
  %hash_coef.i.i13.i2970 = load i64, ptr %hash_coef_ptr.i.i10.i2967, align 4
  %tbl_size.i.i14.i2971 = load i64, ptr %tbl_size_ptr.i.i11.i2968, align 4
  %offset_tbl.i.i15.i2972 = load ptr, ptr %offset_tbl_ptr.i.i12.i2969, align 8
  %product.i.i.i16.i2973 = mul i64 %hash_coef.i.i13.i2970, -5261542750394134544
  %shifted.i.i.i17.i2974 = lshr i64 %product.i.i.i16.i2973, 32
  %xored.i.i.i18.i2975 = xor i64 %shifted.i.i.i17.i2974, %product.i.i.i16.i2973
  %hash.i.i.i19.i2976 = and i64 %xored.i.i.i18.i2975, %tbl_size.i.i14.i2971
  %offset_ptr.i.i20.i2977 = getelementptr i32, ptr %offset_tbl.i.i15.i2972, i64 %hash.i.i.i19.i2976
  %offset.i.i21.i2978 = load i32, ptr %offset_ptr.i.i20.i2977, align 4
  %eq.i.i2979 = icmp eq i32 %2336, %offset.i.i21.i2978
  call void @llvm.assume(i1 %eq.i.i2979) #30
  %2338 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2339 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2330)
  %2340 = sext i32 %2336 to i64
  %2341 = getelementptr ptr, ptr %2330, i64 %2340
  %2342 = getelementptr i8, ptr %2341, i64 64
  %2343 = load ptr, ptr %2342, align 8
  %2344 = call ptr %2343({ ptr, ptr, ptr, i32 } %2337, ptr nonnull %2)
  %2345 = call i32 %2344({ ptr, ptr, ptr, i32 } %2337, { ptr, ptr, ptr, i32 } %2337, ptr nonnull %2)
  %2346 = add i32 %2345, -1
  %2347 = and i32 %2346, %2328
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2348 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2349 = load ptr, ptr %166, align 8
  %2350 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2349, 0
  %2351 = load ptr, ptr %167, align 8
  %2352 = insertvalue { ptr, ptr, ptr, i32 } %2350, ptr %2351, 1
  %2353 = load ptr, ptr %1568, align 8
  %2354 = insertvalue { ptr, ptr, ptr, i32 } %2352, ptr %2353, 2
  %2355 = load i32, ptr %168, align 4
  %2356 = insertvalue { ptr, ptr, ptr, i32 } %2354, i32 %2355, 3
  %hash_coef_ptr.i.i202.i1762 = getelementptr i8, ptr %2349, i64 8
  %tbl_size_ptr.i.i203.i1763 = getelementptr i8, ptr %2349, i64 16
  %offset_tbl_ptr.i.i204.i1764 = getelementptr i8, ptr %2349, i64 40
  %hash_coef.i.i205.i1765 = load i64, ptr %hash_coef_ptr.i.i202.i1762, align 4
  %tbl_size.i.i206.i1766 = load i64, ptr %tbl_size_ptr.i.i203.i1763, align 4
  %offset_tbl.i.i207.i1767 = load ptr, ptr %offset_tbl_ptr.i.i204.i1764, align 8
  %product.i.i.i208.i1768 = mul i64 %hash_coef.i.i205.i1765, -5261542750394134544
  %shifted.i.i.i209.i1769 = lshr i64 %product.i.i.i208.i1768, 32
  %xored.i.i.i210.i1770 = xor i64 %shifted.i.i.i209.i1769, %product.i.i.i208.i1768
  %hash.i.i.i211.i1771 = and i64 %xored.i.i.i210.i1770, %tbl_size.i.i206.i1766
  %offset_ptr.i.i212.i1772 = getelementptr i32, ptr %offset_tbl.i.i207.i1767, i64 %hash.i.i.i211.i1771
  %offset.i.i213.i1773 = load i32, ptr %offset_ptr.i.i212.i1772, align 4
  %eq.i216.i1774 = icmp eq i32 %2355, %offset.i.i213.i1773
  call void @llvm.assume(i1 %eq.i216.i1774) #30
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %2357 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %39)
  %2358 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2349)
  %2359 = sext i32 %2355 to i64
  %2360 = getelementptr ptr, ptr %2349, i64 %2359
  %2361 = getelementptr i8, ptr %2360, i64 120
  %2362 = load ptr, ptr %2361, align 8
  store ptr @i32_typ, ptr %40, align 8
  %2363 = call ptr %2362({ ptr, ptr, ptr, i32 } %2356, ptr nonnull %40)
  %2364 = call { ptr, i160 } %2363({ ptr, ptr, ptr, i32 } %2356, { ptr, ptr, ptr, i32 } %2356, ptr nonnull %39, i32 %2347)
  %.fca.0.extract87.i1775 = extractvalue { ptr, i160 } %2364, 0
  %2365 = ptrtoint ptr %.sroa.speculated352.i18082466 to i64
  %2366 = ptrtoint ptr %.sroa.speculated346.i18092468 to i64
  %.sroa.3.0.insert.ext.i1776 = zext i32 %offset.i.i260.i18212470 to i160
  %.sroa.3.0.insert.shift.i1777 = shl nuw i160 %.sroa.3.0.insert.ext.i1776, 128
  %.sroa.2.0.insert.ext.i1778 = zext i64 %2366 to i160
  %.sroa.2.0.insert.shift.i1779 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i1778, 64
  %.sroa.2.0.insert.insert.i1780 = or disjoint i160 %.sroa.2.0.insert.shift.i1779, %.sroa.3.0.insert.shift.i1777
  %.sroa.0.0.insert.ext.i1781 = zext i64 %2365 to i160
  %.sroa.0.0.insert.insert.i1782 = or disjoint i160 %.sroa.2.0.insert.insert.i1780, %.sroa.0.0.insert.ext.i1781
  %2367 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i1782, 1
  %2368 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2369 = load ptr, ptr %166, align 8
  %2370 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2369, 0
  %2371 = load ptr, ptr %167, align 8
  %2372 = insertvalue { ptr, ptr, ptr, i32 } %2370, ptr %2371, 1
  %2373 = load ptr, ptr %1568, align 8
  %2374 = insertvalue { ptr, ptr, ptr, i32 } %2372, ptr %2373, 2
  %2375 = load i32, ptr %168, align 4
  %2376 = insertvalue { ptr, ptr, ptr, i32 } %2374, i32 %2375, 3
  %hash_coef_ptr.i.i218.i1787 = getelementptr i8, ptr %2369, i64 8
  %tbl_size_ptr.i.i219.i1788 = getelementptr i8, ptr %2369, i64 16
  %offset_tbl_ptr.i.i220.i1789 = getelementptr i8, ptr %2369, i64 40
  %hash_coef.i.i221.i1790 = load i64, ptr %hash_coef_ptr.i.i218.i1787, align 4
  %tbl_size.i.i222.i1791 = load i64, ptr %tbl_size_ptr.i.i219.i1788, align 4
  %offset_tbl.i.i223.i1792 = load ptr, ptr %offset_tbl_ptr.i.i220.i1789, align 8
  %product.i.i.i224.i1793 = mul i64 %hash_coef.i.i221.i1790, -5261542750394134544
  %shifted.i.i.i225.i1794 = lshr i64 %product.i.i.i224.i1793, 32
  %xored.i.i.i226.i1795 = xor i64 %shifted.i.i.i225.i1794, %product.i.i.i224.i1793
  %hash.i.i.i227.i1796 = and i64 %xored.i.i.i226.i1795, %tbl_size.i.i222.i1791
  %offset_ptr.i.i228.i1797 = getelementptr i32, ptr %offset_tbl.i.i223.i1792, i64 %hash.i.i.i227.i1796
  %offset.i.i229.i1798 = load i32, ptr %offset_ptr.i.i228.i1797, align 4
  %eq.i232.i1799 = icmp eq i32 %2375, %offset.i.i229.i1798
  call void @llvm.assume(i1 %eq.i232.i1799) #30
  %2377 = load ptr, ptr %result.i, align 8
  %2378 = load ptr, ptr %136, align 8
  %result.i233.i1800 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2379 = getelementptr i8, ptr %result.i233.i1800, i64 16
  store ptr %2378, ptr %2379, align 8
  %2380 = getelementptr i8, ptr %result.i233.i1800, i64 8
  store ptr %2377, ptr %2380, align 8
  %2381 = getelementptr i8, ptr %result.i233.i1800, i64 24
  store ptr null, ptr %2381, align 8
  %2382 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i1800)
  store ptr @Entry, ptr %result.i233.i1800, align 8
  store ptr @_parameterization_Ptri32, ptr %41, align 8
  store ptr %result.i233.i1800, ptr %1582, align 8
  %2383 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %41)
  %2384 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2369)
  %2385 = sext i32 %2375 to i64
  %2386 = getelementptr ptr, ptr %2369, i64 %2385
  %2387 = getelementptr i8, ptr %2386, i64 128
  %2388 = load ptr, ptr %2387, align 8
  store ptr @i32_typ, ptr %42, align 8
  store ptr @Entry, ptr %1583, align 8
  %2389 = call ptr %2388({ ptr, ptr, ptr, i32 } %2376, ptr nonnull %42)
  call void %2389({ ptr, ptr, ptr, i32 } %2376, { ptr, ptr, ptr, i32 } %2376, ptr nonnull %41, i32 %2347, { ptr, i160 } %2367)
  %2390 = icmp ne ptr %.fca.0.extract87.i1775, @nil_typ
  %2391 = icmp ne ptr %.fca.0.extract87.i1775, null
  %.not138.i1801 = and i1 %2390, %2391
  br i1 %.not138.i1801, label %.cont.cont.i1806, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2448

.cont.cont.i1806:                                 ; preds = %2310, %2246
  %.sink2493 = phi { ptr, i160 } [ %2282, %2246 ], [ %2364, %2310 ]
  %2392 = phi i32 [ 2, %2246 ], [ 1, %2310 ]
  %vptr.i248.sroa.speculated.i1807 = phi ptr [ %.fca.0.extract112.i1839, %2246 ], [ %.fca.0.extract87.i1775, %2310 ]
  %.fca.1.extract89.i1802 = extractvalue { ptr, i160 } %.sink2493, 1
  %.sroa.3407.sroa.4.0.extract.shift.i1803 = lshr i160 %.fca.1.extract89.i1802, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i1804 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i1803 to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i1805 = trunc i160 %.fca.1.extract89.i1802 to i64
  %.sroa.speculated352.i1808 = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i1805 to ptr
  %.sroa.speculated346.i1809 = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i1804 to ptr
  %hash_coef_ptr.i.i249.i1810 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1807, i64 8
  %tbl_size_ptr.i.i250.i1811 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1807, i64 16
  %offset_tbl_ptr.i.i251.i1812 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1807, i64 40
  %hash_coef.i.i252.i1813 = load i64, ptr %hash_coef_ptr.i.i249.i1810, align 4
  %tbl_size.i.i253.i1814 = load i64, ptr %tbl_size_ptr.i.i250.i1811, align 4
  %offset_tbl.i.i254.i1815 = load ptr, ptr %offset_tbl_ptr.i.i251.i1812, align 8
  %product.i.i.i255.i1816 = mul i64 %hash_coef.i.i252.i1813, 4015701072841558310
  %shifted.i.i.i256.i1817 = lshr i64 %product.i.i.i255.i1816, 32
  %xored.i.i.i257.i1818 = xor i64 %shifted.i.i.i256.i1817, %product.i.i.i255.i1816
  %hash.i.i.i258.i1819 = and i64 %xored.i.i.i257.i1818, %tbl_size.i.i253.i1814
  %offset_ptr.i.i259.i1820 = getelementptr i32, ptr %offset_tbl.i.i254.i1815, i64 %hash.i.i.i258.i1819
  %offset.i.i260.i1821 = load i32, ptr %offset_ptr.i.i259.i1820, align 4
  store ptr %vptr.i248.sroa.speculated.i1807, ptr %47, align 8
  store ptr %.sroa.speculated352.i1808, ptr %1579, align 8
  store ptr %.sroa.speculated346.i1809, ptr %1580, align 8
  store i32 %offset.i.i260.i1821, ptr %1581, align 8
  %2393 = add nuw nsw i32 %.reg2mem193.0677.i1757, 1
  %2394 = load i32, ptr %169, align 4
  %2395 = icmp slt i32 %2393, %2394
  br i1 %2395, label %2236, label %._crit_edge1.i612

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2448: ; preds = %2246, %2310
  %2396 = phi ptr [ %43, %2310 ], [ %35, %2246 ]
  %2397 = phi ptr [ %44, %2310 ], [ %36, %2246 ]
  %2398 = phi ptr [ %45, %2310 ], [ %37, %2246 ]
  %2399 = phi ptr [ %.sroa.0.i1725, %2310 ], [ %.sroa.0680.i1724, %2246 ]
  %2400 = phi ptr [ %46, %2310 ], [ %38, %2246 ]
  %2401 = load i32, ptr %1569, align 4
  store i32 %2401, ptr %2396, align 4
  store i32 1, ptr %2397, align 4
  %2402 = add i32 %2401, 1
  store i32 %2402, ptr %2398, align 4
  %2403 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %2402, ptr %1569, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2400, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2399, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1724)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1725)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  br label %HashMap_insert_keyK_valueV.exit701

._crit_edge1.i612:                                ; preds = %.cont.cont.i1806, %._crit_edge.i606
  %2404 = load i160, ptr %1579, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1724)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1725)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %30)
  %2405 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2406 = load ptr, ptr %153, align 8
  %2407 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2406, 0
  %2408 = load ptr, ptr %154, align 8
  %2409 = insertvalue { ptr, ptr, ptr, i32 } %2407, ptr %2408, 1
  %2410 = load ptr, ptr %1567, align 8
  %2411 = insertvalue { ptr, ptr, ptr, i32 } %2409, ptr %2410, 2
  %2412 = load i32, ptr %155, align 4
  %2413 = insertvalue { ptr, ptr, ptr, i32 } %2411, i32 %2412, 3
  %hash_coef_ptr.i.i64.i1885 = getelementptr i8, ptr %2406, i64 8
  %tbl_size_ptr.i.i65.i1886 = getelementptr i8, ptr %2406, i64 16
  %offset_tbl_ptr.i.i66.i1887 = getelementptr i8, ptr %2406, i64 40
  %hash_coef.i.i67.i1888 = load i64, ptr %hash_coef_ptr.i.i64.i1885, align 4
  %tbl_size.i.i68.i1889 = load i64, ptr %tbl_size_ptr.i.i65.i1886, align 4
  %offset_tbl.i.i69.i1890 = load ptr, ptr %offset_tbl_ptr.i.i66.i1887, align 8
  %product.i.i.i70.i1891 = mul i64 %hash_coef.i.i67.i1888, -5261542750394134544
  %shifted.i.i.i71.i1892 = lshr i64 %product.i.i.i70.i1891, 32
  %xored.i.i.i72.i1893 = xor i64 %shifted.i.i.i71.i1892, %product.i.i.i70.i1891
  %hash.i.i.i73.i1894 = and i64 %xored.i.i.i72.i1893, %tbl_size.i.i68.i1889
  %offset_ptr.i.i74.i1895 = getelementptr i32, ptr %offset_tbl.i.i69.i1890, i64 %hash.i.i.i73.i1894
  %offset.i.i75.i1896 = load i32, ptr %offset_ptr.i.i74.i1895, align 4
  %eq.i.i1897 = icmp eq i32 %2412, %offset.i.i75.i1896
  call void @llvm.assume(i1 %eq.i.i1897) #30
  %2414 = load ptr, ptr %166, align 8
  %2415 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2414, 0
  %2416 = load ptr, ptr %167, align 8
  %2417 = insertvalue { ptr, ptr, ptr, i32 } %2415, ptr %2416, 1
  %2418 = load ptr, ptr %1568, align 8
  %2419 = insertvalue { ptr, ptr, ptr, i32 } %2417, ptr %2418, 2
  %2420 = load i32, ptr %168, align 4
  %2421 = insertvalue { ptr, ptr, ptr, i32 } %2419, i32 %2420, 3
  %hash_coef_ptr.i.i92.i1902 = getelementptr i8, ptr %2414, i64 8
  %tbl_size_ptr.i.i93.i1903 = getelementptr i8, ptr %2414, i64 16
  %offset_tbl_ptr.i.i94.i1904 = getelementptr i8, ptr %2414, i64 40
  %hash_coef.i.i95.i1905 = load i64, ptr %hash_coef_ptr.i.i92.i1902, align 4
  %tbl_size.i.i96.i1906 = load i64, ptr %tbl_size_ptr.i.i93.i1903, align 4
  %offset_tbl.i.i97.i1907 = load ptr, ptr %offset_tbl_ptr.i.i94.i1904, align 8
  %product.i.i.i98.i1908 = mul i64 %hash_coef.i.i95.i1905, -5261542750394134544
  %shifted.i.i.i99.i1909 = lshr i64 %product.i.i.i98.i1908, 32
  %xored.i.i.i100.i1910 = xor i64 %shifted.i.i.i99.i1909, %product.i.i.i98.i1908
  %hash.i.i.i101.i1911 = and i64 %xored.i.i.i100.i1910, %tbl_size.i.i96.i1906
  %offset_ptr.i.i102.i1912 = getelementptr i32, ptr %offset_tbl.i.i97.i1907, i64 %hash.i.i.i101.i1911
  %offset.i.i103.i1913 = load i32, ptr %offset_ptr.i.i102.i1912, align 4
  %eq.i106.i1914 = icmp eq i32 %2420, %offset.i.i103.i1913
  call void @llvm.assume(i1 %eq.i106.i1914) #30
  %2422 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2423 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2406)
  %2424 = sext i32 %2412 to i64
  %2425 = getelementptr ptr, ptr %2406, i64 %2424
  %2426 = getelementptr i8, ptr %2425, i64 64
  %2427 = load ptr, ptr %2426, align 8
  %2428 = call ptr %2427({ ptr, ptr, ptr, i32 } %2413, ptr nonnull %2)
  %2429 = call i32 %2428({ ptr, ptr, ptr, i32 } %2413, { ptr, ptr, ptr, i32 } %2413, ptr nonnull %2)
  %2430 = shl i32 %2429, 1
  %2431 = load i32, ptr %1569, align 4
  %2432 = load ptr, ptr %result.i, align 8
  %2433 = load ptr, ptr %136, align 8
  %2434 = sext i32 %2431 to i64
  %2435 = shl nsw i64 %2434, 5
  %result.i.i.i1917 = call noalias ptr @bump_malloc_inner(i64 noundef %2435, ptr nonnull @current_ptr) #29
  %2436 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2437 = icmp sgt i32 %2429, 0
  br i1 %2437, label %.lr.ph434.i1987, label %._crit_edge395.i1931

.lr.ph434.i1987:                                  ; preds = %._crit_edge1.i612
  %invariant.gep.i1930 = getelementptr i8, ptr %2406, i64 120
  %2438 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1990 = getelementptr ptr, ptr %invariant.gep.i1930, i64 %2424
  br label %2439

2439:                                             ; preds = %2461, %.lr.ph434.i1987
  %.reg2mem105.0432.i1988 = phi i32 [ 0, %.lr.ph434.i1987 ], [ %.reg2mem101.0.i1993, %2461 ]
  %.reg2mem103.0431.i1989 = phi i32 [ 0, %.lr.ph434.i1987 ], [ %2462, %2461 ]
  store ptr @_parameterization_Ptri32, ptr %25, align 8
  %2440 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %25)
  %2441 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2406)
  %2442 = load ptr, ptr %gep.i1990, align 8
  store ptr @i32_typ, ptr %26, align 8
  %2443 = call ptr %2442({ ptr, ptr, ptr, i32 } %2413, ptr nonnull %26)
  %2444 = call { ptr, i160 } %2443({ ptr, ptr, ptr, i32 } %2413, { ptr, ptr, ptr, i32 } %2413, ptr nonnull %25, i32 %.reg2mem103.0431.i1989)
  %.fca.0.extract52.i1991 = extractvalue { ptr, i160 } %2444, 0
  %2445 = icmp ne ptr %.fca.0.extract52.i1991, @nil_typ
  %2446 = icmp ne ptr %.fca.0.extract52.i1991, null
  %.not60.i1992 = and i1 %2445, %2446
  br i1 %.not60.i1992, label %2447, label %2461

2447:                                             ; preds = %2439
  %hash_coef_ptr.i.i137.i2020 = getelementptr i8, ptr %.fca.0.extract52.i1991, i64 8
  %tbl_size_ptr.i.i138.i2021 = getelementptr i8, ptr %.fca.0.extract52.i1991, i64 16
  %offset_tbl_ptr.i.i139.i2022 = getelementptr i8, ptr %.fca.0.extract52.i1991, i64 40
  %hash_coef.i.i140.i2023 = load i64, ptr %hash_coef_ptr.i.i137.i2020, align 4
  %tbl_size.i.i141.i2024 = load i64, ptr %tbl_size_ptr.i.i138.i2021, align 4
  %offset_tbl.i.i142.i2025 = load ptr, ptr %offset_tbl_ptr.i.i139.i2022, align 8
  %product.i.i.i143.i2026 = mul i64 %hash_coef.i.i140.i2023, 4015701072841558310
  %shifted.i.i.i144.i2027 = lshr i64 %product.i.i.i143.i2026, 32
  %xored.i.i.i145.i2028 = xor i64 %shifted.i.i.i144.i2027, %product.i.i.i143.i2026
  %hash.i.i.i146.i2029 = and i64 %xored.i.i.i145.i2028, %tbl_size.i.i141.i2024
  %offset_ptr.i.i147.i2030 = getelementptr i32, ptr %offset_tbl.i.i142.i2025, i64 %hash.i.i.i146.i2029
  %offset.i.i148.i2031 = load i32, ptr %offset_ptr.i.i147.i2030, align 4
  %2448 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2449 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2450 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2451 = icmp slt i32 %.reg2mem105.0432.i1988, %2431
  br i1 %2451, label %2452, label %._crit_edge.i2032

2452:                                             ; preds = %2447
  %.fca.1.extract54.i2033 = extractvalue { ptr, i160 } %2444, 1
  %.sroa.351.0.insert.ext.i2034 = zext i32 %offset.i.i148.i2031 to i160
  %.sroa.351.0.insert.shift.i2035 = shl nuw i160 %.sroa.351.0.insert.ext.i2034, 128
  %2453 = and i160 %.fca.1.extract54.i2033, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2036 = or disjoint i160 %.sroa.351.0.insert.shift.i2035, %2453
  %2454 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2455 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2456 = sext i32 %.reg2mem105.0432.i1988 to i64
  %2457 = shl nsw i64 %2456, 5
  %2458 = getelementptr i8, ptr %result.i.i.i1917, i64 %2457
  store ptr %.fca.0.extract52.i1991, ptr %2458, align 8
  %2459 = getelementptr i8, ptr %2458, i64 8
  store i160 %.sroa.049.0.insert.insert.i2036, ptr %2459, align 4
  br label %._crit_edge.i2032

._crit_edge.i2032:                                ; preds = %2452, %2447
  %2460 = add i32 %.reg2mem105.0432.i1988, 1
  br label %2461

2461:                                             ; preds = %._crit_edge.i2032, %2439
  %.reg2mem101.0.i1993 = phi i32 [ %2460, %._crit_edge.i2032 ], [ %.reg2mem105.0432.i1988, %2439 ]
  %2462 = add nuw nsw i32 %.reg2mem103.0431.i1989, 1
  %2463 = icmp slt i32 %2462, %2429
  br i1 %2463, label %2439, label %.lr.ph.i1994

.lr.ph.i1994:                                     ; preds = %2461
  %invariant.gep396.i1995 = getelementptr i8, ptr %2414, i64 120
  %2464 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2465 = sext i32 %2420 to i64
  %gep397.i1998 = getelementptr ptr, ptr %invariant.gep396.i1995, i64 %2465
  br label %2466

2466:                                             ; preds = %2488, %.lr.ph.i1994
  %.reg2mem91.0394.i1996 = phi i32 [ %.reg2mem101.0.i1993, %.lr.ph.i1994 ], [ %.reg2mem87.0.i2001, %2488 ]
  %.reg2mem89.0393.i1997 = phi i32 [ 0, %.lr.ph.i1994 ], [ %2489, %2488 ]
  store ptr @_parameterization_Ptri32, ptr %27, align 8
  %2467 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %27)
  %2468 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2414)
  %2469 = load ptr, ptr %gep397.i1998, align 8
  store ptr @i32_typ, ptr %28, align 8
  %2470 = call ptr %2469({ ptr, ptr, ptr, i32 } %2421, ptr nonnull %28)
  %2471 = call { ptr, i160 } %2470({ ptr, ptr, ptr, i32 } %2421, { ptr, ptr, ptr, i32 } %2421, ptr nonnull %27, i32 %.reg2mem89.0393.i1997)
  %.fca.0.extract42.i1999 = extractvalue { ptr, i160 } %2471, 0
  %2472 = icmp ne ptr %.fca.0.extract42.i1999, @nil_typ
  %2473 = icmp ne ptr %.fca.0.extract42.i1999, null
  %.not62.i2000 = and i1 %2472, %2473
  br i1 %.not62.i2000, label %2474, label %2488

2474:                                             ; preds = %2466
  %hash_coef_ptr.i.i152.i2002 = getelementptr i8, ptr %.fca.0.extract42.i1999, i64 8
  %tbl_size_ptr.i.i153.i2003 = getelementptr i8, ptr %.fca.0.extract42.i1999, i64 16
  %offset_tbl_ptr.i.i154.i2004 = getelementptr i8, ptr %.fca.0.extract42.i1999, i64 40
  %hash_coef.i.i155.i2005 = load i64, ptr %hash_coef_ptr.i.i152.i2002, align 4
  %tbl_size.i.i156.i2006 = load i64, ptr %tbl_size_ptr.i.i153.i2003, align 4
  %offset_tbl.i.i157.i2007 = load ptr, ptr %offset_tbl_ptr.i.i154.i2004, align 8
  %product.i.i.i158.i2008 = mul i64 %hash_coef.i.i155.i2005, 4015701072841558310
  %shifted.i.i.i159.i2009 = lshr i64 %product.i.i.i158.i2008, 32
  %xored.i.i.i160.i2010 = xor i64 %shifted.i.i.i159.i2009, %product.i.i.i158.i2008
  %hash.i.i.i161.i2011 = and i64 %xored.i.i.i160.i2010, %tbl_size.i.i156.i2006
  %offset_ptr.i.i162.i2012 = getelementptr i32, ptr %offset_tbl.i.i157.i2007, i64 %hash.i.i.i161.i2011
  %offset.i.i163.i2013 = load i32, ptr %offset_ptr.i.i162.i2012, align 4
  %2475 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2476 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2477 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2478 = icmp slt i32 %.reg2mem91.0394.i1996, %2431
  br i1 %2478, label %2479, label %._crit_edge1.i2014

2479:                                             ; preds = %2474
  %.fca.1.extract44.i2015 = extractvalue { ptr, i160 } %2471, 1
  %.sroa.3.0.insert.ext.i2016 = zext i32 %offset.i.i163.i2013 to i160
  %.sroa.3.0.insert.shift.i2017 = shl nuw i160 %.sroa.3.0.insert.ext.i2016, 128
  %2480 = and i160 %.fca.1.extract44.i2015, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2018 = or disjoint i160 %.sroa.3.0.insert.shift.i2017, %2480
  %2481 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2482 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2483 = sext i32 %.reg2mem91.0394.i1996 to i64
  %2484 = shl nsw i64 %2483, 5
  %2485 = getelementptr i8, ptr %result.i.i.i1917, i64 %2484
  store ptr %.fca.0.extract42.i1999, ptr %2485, align 8
  %2486 = getelementptr i8, ptr %2485, i64 8
  store i160 %.sroa.040.0.insert.insert.i2018, ptr %2486, align 4
  br label %._crit_edge1.i2014

._crit_edge1.i2014:                               ; preds = %2479, %2474
  %2487 = add i32 %.reg2mem91.0394.i1996, 1
  br label %2488

2488:                                             ; preds = %._crit_edge1.i2014, %2466
  %.reg2mem87.0.i2001 = phi i32 [ %2487, %._crit_edge1.i2014 ], [ %.reg2mem91.0394.i1996, %2466 ]
  %2489 = add nuw nsw i32 %.reg2mem89.0393.i1997, 1
  %2490 = icmp slt i32 %2489, %2429
  br i1 %2490, label %2466, label %._crit_edge395.i1931.loopexit

._crit_edge395.i1931.loopexit:                    ; preds = %2488
  %.pre2859 = load ptr, ptr %result.i, align 8
  %.pre2860 = load ptr, ptr %136, align 8
  br label %._crit_edge395.i1931

._crit_edge395.i1931:                             ; preds = %._crit_edge395.i1931.loopexit, %._crit_edge1.i612
  %2491 = phi ptr [ %2433, %._crit_edge1.i612 ], [ %.pre2860, %._crit_edge395.i1931.loopexit ]
  %2492 = phi ptr [ %2432, %._crit_edge1.i612 ], [ %.pre2859, %._crit_edge395.i1931.loopexit ]
  %.reg2mem91.0.lcssa.i1932 = phi i32 [ 0, %._crit_edge1.i612 ], [ %.reg2mem87.0.i2001, %._crit_edge395.i1931.loopexit ]
  %2493 = call i32 @llvm.smax.i32(i32 %2430, i32 16)
  %result.i166.i1933 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2494 = getelementptr i8, ptr %result.i166.i1933, i64 16
  store ptr @_parameterization_Nil, ptr %2494, align 8
  %result.i167.i1934 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2495 = getelementptr i8, ptr %result.i167.i1934, i64 16
  store ptr %2491, ptr %2495, align 8
  %2496 = getelementptr i8, ptr %result.i167.i1934, i64 8
  store ptr %2492, ptr %2496, align 8
  %2497 = getelementptr i8, ptr %result.i167.i1934, i64 24
  store ptr null, ptr %2497, align 8
  %2498 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1934)
  store ptr @Entry, ptr %result.i167.i1934, align 8
  %2499 = getelementptr i8, ptr %result.i166.i1933, i64 8
  store ptr %result.i167.i1934, ptr %2499, align 8
  %2500 = getelementptr i8, ptr %result.i166.i1933, i64 24
  store ptr null, ptr %2500, align 8
  %2501 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1933)
  store ptr @union_typ, ptr %result.i166.i1933, align 8
  %result.i168.i1935 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1933, ptr %result.i168.i1935, align 8
  %2502 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1935)
  store ptr @Array, ptr %29, align 8
  store ptr %result.i168.i1935, ptr %1586, align 8
  store i32 9, ptr %1587, align 8
  %2503 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %29)
  %2504 = getelementptr i8, ptr %result.i168.i1935, i64 16
  store i32 %2493, ptr %2504, align 4
  %2505 = getelementptr i8, ptr %result.i168.i1935, i64 20
  store i32 %2493, ptr %2505, align 4
  %2506 = zext nneg i32 %2493 to i64
  %2507 = shl nuw nsw i64 %2506, 5
  %result.i.i416.i1936 = call noalias ptr @bump_malloc_inner(i64 noundef %2507, ptr nonnull @current_ptr) #29
  %2508 = getelementptr i8, ptr %result.i168.i1935, i64 8
  store ptr %result.i.i416.i1936, ptr %2508, align 8
  %2509 = load ptr, ptr %1588, align 8
  store ptr @Array, ptr %153, align 8
  store ptr %result.i168.i1935, ptr %154, align 8
  store ptr %2509, ptr %1567, align 8
  store i32 9, ptr %155, align 4
  %2510 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i1949 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2511 = getelementptr i8, ptr %result.i183.i1949, i64 16
  store ptr @_parameterization_Nil, ptr %2511, align 8
  %result.i184.i1950 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2512 = getelementptr i8, ptr %result.i184.i1950, i64 16
  store ptr %2491, ptr %2512, align 8
  %2513 = getelementptr i8, ptr %result.i184.i1950, i64 8
  store ptr %2492, ptr %2513, align 8
  %2514 = getelementptr i8, ptr %result.i184.i1950, i64 24
  store ptr null, ptr %2514, align 8
  %2515 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1950)
  store ptr @Entry, ptr %result.i184.i1950, align 8
  %2516 = getelementptr i8, ptr %result.i183.i1949, i64 8
  store ptr %result.i184.i1950, ptr %2516, align 8
  %2517 = getelementptr i8, ptr %result.i183.i1949, i64 24
  store ptr null, ptr %2517, align 8
  %2518 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1949)
  store ptr @union_typ, ptr %result.i183.i1949, align 8
  %result.i185.i1951 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1949, ptr %result.i185.i1951, align 8
  %2519 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1951)
  store ptr @Array, ptr %30, align 8
  store ptr %result.i185.i1951, ptr %1589, align 8
  store i32 9, ptr %1590, align 8
  %2520 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %30)
  %2521 = getelementptr i8, ptr %result.i185.i1951, i64 16
  store i32 %2493, ptr %2521, align 4
  %2522 = getelementptr i8, ptr %result.i185.i1951, i64 20
  store i32 %2493, ptr %2522, align 4
  %result.i.i430.i1952 = call noalias ptr @bump_malloc_inner(i64 noundef %2507, ptr nonnull @current_ptr) #29
  %2523 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2524 = getelementptr i8, ptr %result.i185.i1951, i64 8
  store ptr %result.i.i430.i1952, ptr %2524, align 8
  %2525 = load ptr, ptr %1591, align 8
  store ptr @Array, ptr %166, align 8
  store ptr %result.i185.i1951, ptr %167, align 8
  store ptr %2525, ptr %1568, align 8
  store i32 9, ptr %168, align 4
  store i32 0, ptr %1569, align 4
  %2526 = icmp sgt i32 %.reg2mem91.0.lcssa.i1932, 0
  br i1 %2526, label %.lr.ph400.i1965, label %HashMap_resize_.exit2038

.lr.ph400.i1965:                                  ; preds = %._crit_edge395.i1931
  %2527 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2528 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2529 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1967

._crit_edge2.i1967:                               ; preds = %._crit_edge2.i1967, %.lr.ph400.i1965
  %.reg2mem77.0398.i1968 = phi i32 [ 0, %.lr.ph400.i1965 ], [ %2543, %._crit_edge2.i1967 ]
  %2530 = zext nneg i32 %.reg2mem77.0398.i1968 to i64
  %2531 = shl nuw nsw i64 %2530, 5
  %2532 = getelementptr i8, ptr %result.i.i.i1917, i64 %2531
  %2533 = load ptr, ptr %2532, align 8
  %2534 = getelementptr i8, ptr %2532, i64 8
  %2535 = load i160, ptr %2534, align 4
  %.sroa.3362.8.extract.trunc.i1971 = trunc i160 %2535 to i64
  %2536 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1971 to ptr
  %.sroa.5363.8.extract.shift.i1972 = lshr i160 %2535, 64
  %.sroa.5363.8.extract.trunc.i1973 = trunc i160 %.sroa.5363.8.extract.shift.i1972 to i64
  %2537 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1973 to ptr
  %hash_coef_ptr.i.i201.i1974 = getelementptr i8, ptr %2533, i64 8
  %tbl_size_ptr.i.i202.i1975 = getelementptr i8, ptr %2533, i64 16
  %offset_tbl_ptr.i.i203.i1976 = getelementptr i8, ptr %2533, i64 40
  %hash_coef.i.i232.i1977 = load i64, ptr %hash_coef_ptr.i.i201.i1974, align 4
  %tbl_size.i.i233.i1978 = load i64, ptr %tbl_size_ptr.i.i202.i1975, align 4
  %offset_tbl.i.i234.i1979 = load ptr, ptr %offset_tbl_ptr.i.i203.i1976, align 8
  %product.i.i.i235.i1980 = mul i64 %hash_coef.i.i232.i1977, 4015701072841558310
  %shifted.i.i.i236.i1981 = lshr i64 %product.i.i.i235.i1980, 32
  %xored.i.i.i237.i1982 = xor i64 %shifted.i.i.i236.i1981, %product.i.i.i235.i1980
  %hash.i.i.i238.i1983 = and i64 %xored.i.i.i237.i1982, %tbl_size.i.i233.i1978
  %offset_ptr.i.i239.i1984 = getelementptr i32, ptr %offset_tbl.i.i234.i1979, i64 %hash.i.i.i238.i1983
  %offset.i.i240.i1985 = load i32, ptr %offset_ptr.i.i239.i1984, align 4
  %2538 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2533, 0
  %2539 = insertvalue { ptr, ptr, ptr, i32 } %2538, ptr %2536, 1
  %2540 = insertvalue { ptr, ptr, ptr, i32 } %2539, ptr %2537, 2
  %2541 = insertvalue { ptr, ptr, ptr, i32 } %2540, i32 %offset.i.i240.i1985, 3
  %2542 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %1578, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2541)
  %2543 = add nuw nsw i32 %.reg2mem77.0398.i1968, 1
  %2544 = icmp slt i32 %2543, %.reg2mem91.0.lcssa.i1932
  br i1 %2544, label %._crit_edge2.i1967, label %HashMap_resize_.exit2038

HashMap_resize_.exit2038:                         ; preds = %._crit_edge2.i1967, %._crit_edge395.i1931
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %30)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i2039)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i2041)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %24)
  %2545 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2546 = load i32, ptr %169, align 4
  %2547 = icmp sgt i32 %2546, 0
  br i1 %2547, label %.lr.ph.i2076, label %._crit_edge1.1.i618

.lr.ph.i2076:                                     ; preds = %HashMap_resize_.exit2038
  %2548 = lshr i160 %2404, 64
  %2549 = insertelement <2 x i160> poison, i160 %2548, i64 0
  %2550 = insertelement <2 x i160> %2549, i160 %2404, i64 1
  %2551 = trunc <2 x i160> %2550 to <2 x i64>
  %2552 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2553 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %2554

2554:                                             ; preds = %.cont.cont.i2130, %.lr.ph.i2076
  %offset.i.i260.i21472478 = phi i32 [ 9, %.lr.ph.i2076 ], [ %offset.i.i260.i2147, %.cont.cont.i2130 ]
  %.reg2mem195.0678.i2078 = phi i32 [ 1, %.lr.ph.i2076 ], [ %2709, %.cont.cont.i2130 ]
  %.reg2mem193.0677.i2079 = phi i32 [ 0, %.lr.ph.i2076 ], [ %2714, %.cont.cont.i2130 ]
  %2555 = phi <2 x i64> [ %2551, %.lr.ph.i2076 ], [ %2713, %.cont.cont.i2130 ]
  %2556 = extractelement <2 x i64> %2555, i64 1
  %.sroa.speculated352.i21342474 = inttoptr i64 %2556 to ptr
  %2557 = extractelement <2 x i64> %2555, i64 0
  %.sroa.speculated346.i21352476 = inttoptr i64 %2557 to ptr
  %2558 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i21342474, 1
  %2559 = insertvalue { ptr, ptr, ptr, i32 } %2558, ptr %.sroa.speculated346.i21352476, 2
  %2560 = insertvalue { ptr, ptr, ptr, i32 } %2559, i32 %offset.i.i260.i21472478, 3
  %2561 = sext i32 %offset.i.i260.i21472478 to i64
  %gep2472 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %2561
  %2562 = load ptr, ptr %gep2472, align 8
  %2563 = call ptr %2562({ ptr, ptr, ptr, i32 } %2560, ptr nonnull %2)
  %2564 = call i32 %2563({ ptr, ptr, ptr, i32 } %2560, { ptr, ptr, ptr, i32 } %2560, ptr nonnull %2)
  %2565 = icmp eq i32 %.reg2mem195.0678.i2078, 1
  %2566 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %2565, label %2567, label %2629

2567:                                             ; preds = %2554
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2568 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2569 = load ptr, ptr %153, align 8
  %2570 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2569, 0
  %2571 = load ptr, ptr %154, align 8
  %2572 = insertvalue { ptr, ptr, ptr, i32 } %2570, ptr %2571, 1
  %2573 = load ptr, ptr %1567, align 8
  %2574 = insertvalue { ptr, ptr, ptr, i32 } %2572, ptr %2573, 2
  %2575 = load i32, ptr %155, align 4
  %2576 = insertvalue { ptr, ptr, ptr, i32 } %2574, i32 %2575, 3
  %hash_coef_ptr.i.i10.i3070 = getelementptr i8, ptr %2569, i64 8
  %tbl_size_ptr.i.i11.i3071 = getelementptr i8, ptr %2569, i64 16
  %offset_tbl_ptr.i.i12.i3072 = getelementptr i8, ptr %2569, i64 40
  %hash_coef.i.i13.i3073 = load i64, ptr %hash_coef_ptr.i.i10.i3070, align 4
  %tbl_size.i.i14.i3074 = load i64, ptr %tbl_size_ptr.i.i11.i3071, align 4
  %offset_tbl.i.i15.i3075 = load ptr, ptr %offset_tbl_ptr.i.i12.i3072, align 8
  %product.i.i.i16.i3076 = mul i64 %hash_coef.i.i13.i3073, -5261542750394134544
  %shifted.i.i.i17.i3077 = lshr i64 %product.i.i.i16.i3076, 32
  %xored.i.i.i18.i3078 = xor i64 %shifted.i.i.i17.i3077, %product.i.i.i16.i3076
  %hash.i.i.i19.i3079 = and i64 %xored.i.i.i18.i3078, %tbl_size.i.i14.i3074
  %offset_ptr.i.i20.i3080 = getelementptr i32, ptr %offset_tbl.i.i15.i3075, i64 %hash.i.i.i19.i3079
  %offset.i.i21.i3081 = load i32, ptr %offset_ptr.i.i20.i3080, align 4
  %eq.i.i3082 = icmp eq i32 %2575, %offset.i.i21.i3081
  call void @llvm.assume(i1 %eq.i.i3082) #30
  %2577 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2578 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2569)
  %2579 = sext i32 %2575 to i64
  %2580 = getelementptr ptr, ptr %2569, i64 %2579
  %2581 = getelementptr i8, ptr %2580, i64 64
  %2582 = load ptr, ptr %2581, align 8
  %2583 = call ptr %2582({ ptr, ptr, ptr, i32 } %2576, ptr nonnull %2)
  %2584 = call i32 %2583({ ptr, ptr, ptr, i32 } %2576, { ptr, ptr, ptr, i32 } %2576, ptr nonnull %2)
  %2585 = add i32 %2584, -1
  %2586 = and i32 %2585, %2564
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2587 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2588 = load ptr, ptr %153, align 8
  %2589 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2588, 0
  %2590 = load ptr, ptr %154, align 8
  %2591 = insertvalue { ptr, ptr, ptr, i32 } %2589, ptr %2590, 1
  %2592 = load ptr, ptr %1567, align 8
  %2593 = insertvalue { ptr, ptr, ptr, i32 } %2591, ptr %2592, 2
  %2594 = load i32, ptr %155, align 4
  %2595 = insertvalue { ptr, ptr, ptr, i32 } %2593, i32 %2594, 3
  %hash_coef_ptr.i.i172.i2152 = getelementptr i8, ptr %2588, i64 8
  %tbl_size_ptr.i.i173.i2153 = getelementptr i8, ptr %2588, i64 16
  %offset_tbl_ptr.i.i174.i2154 = getelementptr i8, ptr %2588, i64 40
  %hash_coef.i.i175.i2155 = load i64, ptr %hash_coef_ptr.i.i172.i2152, align 4
  %tbl_size.i.i176.i2156 = load i64, ptr %tbl_size_ptr.i.i173.i2153, align 4
  %offset_tbl.i.i177.i2157 = load ptr, ptr %offset_tbl_ptr.i.i174.i2154, align 8
  %product.i.i.i178.i2158 = mul i64 %hash_coef.i.i175.i2155, -5261542750394134544
  %shifted.i.i.i179.i2159 = lshr i64 %product.i.i.i178.i2158, 32
  %xored.i.i.i180.i2160 = xor i64 %shifted.i.i.i179.i2159, %product.i.i.i178.i2158
  %hash.i.i.i181.i2161 = and i64 %xored.i.i.i180.i2160, %tbl_size.i.i176.i2156
  %offset_ptr.i.i182.i2162 = getelementptr i32, ptr %offset_tbl.i.i177.i2157, i64 %hash.i.i.i181.i2161
  %offset.i.i183.i2163 = load i32, ptr %offset_ptr.i.i182.i2162, align 4
  %eq.i.i2164 = icmp eq i32 %2594, %offset.i.i183.i2163
  call void @llvm.assume(i1 %eq.i.i2164) #30
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  %2596 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %9)
  %2597 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2588)
  %2598 = sext i32 %2594 to i64
  %2599 = getelementptr ptr, ptr %2588, i64 %2598
  %2600 = getelementptr i8, ptr %2599, i64 120
  %2601 = load ptr, ptr %2600, align 8
  store ptr @i32_typ, ptr %10, align 8
  %2602 = call ptr %2601({ ptr, ptr, ptr, i32 } %2595, ptr nonnull %10)
  %2603 = call { ptr, i160 } %2602({ ptr, ptr, ptr, i32 } %2595, { ptr, ptr, ptr, i32 } %2595, ptr nonnull %9, i32 %2586)
  %.fca.0.extract112.i2165 = extractvalue { ptr, i160 } %2603, 0
  %.sroa.3111.0.insert.ext.i2166 = zext i32 %offset.i.i260.i21472478 to i160
  %.sroa.3111.0.insert.shift.i2167 = shl nuw i160 %.sroa.3111.0.insert.ext.i2166, 128
  %.sroa.2110.0.insert.ext.i2168 = zext i64 %2557 to i160
  %.sroa.2110.0.insert.shift.i2169 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i2168, 64
  %.sroa.2110.0.insert.insert.i2170 = or disjoint i160 %.sroa.2110.0.insert.shift.i2169, %.sroa.3111.0.insert.shift.i2167
  %.sroa.0109.0.insert.ext.i2171 = zext i64 %2556 to i160
  %.sroa.0109.0.insert.insert.i2172 = or disjoint i160 %.sroa.2110.0.insert.insert.i2170, %.sroa.0109.0.insert.ext.i2171
  %2604 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i2172, 1
  %2605 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2606 = load ptr, ptr %153, align 8
  %2607 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2606, 0
  %2608 = load ptr, ptr %154, align 8
  %2609 = insertvalue { ptr, ptr, ptr, i32 } %2607, ptr %2608, 1
  %2610 = load ptr, ptr %1567, align 8
  %2611 = insertvalue { ptr, ptr, ptr, i32 } %2609, ptr %2610, 2
  %2612 = load i32, ptr %155, align 4
  %2613 = insertvalue { ptr, ptr, ptr, i32 } %2611, i32 %2612, 3
  %hash_coef_ptr.i.i186.i2177 = getelementptr i8, ptr %2606, i64 8
  %tbl_size_ptr.i.i187.i2178 = getelementptr i8, ptr %2606, i64 16
  %offset_tbl_ptr.i.i188.i2179 = getelementptr i8, ptr %2606, i64 40
  %hash_coef.i.i189.i2180 = load i64, ptr %hash_coef_ptr.i.i186.i2177, align 4
  %tbl_size.i.i190.i2181 = load i64, ptr %tbl_size_ptr.i.i187.i2178, align 4
  %offset_tbl.i.i191.i2182 = load ptr, ptr %offset_tbl_ptr.i.i188.i2179, align 8
  %product.i.i.i192.i2183 = mul i64 %hash_coef.i.i189.i2180, -5261542750394134544
  %shifted.i.i.i193.i2184 = lshr i64 %product.i.i.i192.i2183, 32
  %xored.i.i.i194.i2185 = xor i64 %shifted.i.i.i193.i2184, %product.i.i.i192.i2183
  %hash.i.i.i195.i2186 = and i64 %xored.i.i.i194.i2185, %tbl_size.i.i190.i2181
  %offset_ptr.i.i196.i2187 = getelementptr i32, ptr %offset_tbl.i.i191.i2182, i64 %hash.i.i.i195.i2186
  %offset.i.i197.i2188 = load i32, ptr %offset_ptr.i.i196.i2187, align 4
  %eq.i200.i2189 = icmp eq i32 %2612, %offset.i.i197.i2188
  call void @llvm.assume(i1 %eq.i200.i2189) #30
  %2614 = load ptr, ptr %result.i, align 8
  %2615 = load ptr, ptr %136, align 8
  %result.i.i2190 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2616 = getelementptr i8, ptr %result.i.i2190, i64 16
  store ptr %2615, ptr %2616, align 8
  %2617 = getelementptr i8, ptr %result.i.i2190, i64 8
  store ptr %2614, ptr %2617, align 8
  %2618 = getelementptr i8, ptr %result.i.i2190, i64 24
  store ptr null, ptr %2618, align 8
  %2619 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i2190)
  store ptr @Entry, ptr %result.i.i2190, align 8
  store ptr @_parameterization_Ptri32, ptr %11, align 8
  store ptr %result.i.i2190, ptr %1594, align 8
  %2620 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %11)
  %2621 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2606)
  %2622 = sext i32 %2612 to i64
  %2623 = getelementptr ptr, ptr %2606, i64 %2622
  %2624 = getelementptr i8, ptr %2623, i64 128
  %2625 = load ptr, ptr %2624, align 8
  store ptr @i32_typ, ptr %12, align 8
  store ptr @Entry, ptr %1595, align 8
  %2626 = call ptr %2625({ ptr, ptr, ptr, i32 } %2613, ptr nonnull %12)
  call void %2626({ ptr, ptr, ptr, i32 } %2613, { ptr, ptr, ptr, i32 } %2613, ptr nonnull %11, i32 %2586, { ptr, i160 } %2604)
  %2627 = icmp ne ptr %.fca.0.extract112.i2165, @nil_typ
  %2628 = icmp ne ptr %.fca.0.extract112.i2165, null
  %.not140.i2191 = and i1 %2627, %2628
  br i1 %.not140.i2191, label %.cont.cont.i2130, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2197.thread

2629:                                             ; preds = %2554
  %2630 = add i32 %2564, 2127912214
  %2631 = shl i32 %2564, 12
  %2632 = add i32 %2630, %2631
  %2633 = ashr i32 %2632, 19
  %2634 = xor i32 %2632, %2633
  %2635 = xor i32 %2634, -949894596
  %2636 = add i32 %2635, 374761393
  %2637 = shl i32 %2635, 5
  %2638 = add i32 %2636, %2637
  %2639 = add i32 %2638, -744332180
  %2640 = shl i32 %2638, 9
  %2641 = xor i32 %2639, %2640
  %2642 = add i32 %2641, -42973499
  %2643 = shl i32 %2641, 3
  %2644 = add i32 %2642, %2643
  %2645 = ashr i32 %2644, 16
  %2646 = xor i32 %2644, %2645
  %2647 = xor i32 %2646, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2648 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2649 = load ptr, ptr %166, align 8
  %2650 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2649, 0
  %2651 = load ptr, ptr %167, align 8
  %2652 = insertvalue { ptr, ptr, ptr, i32 } %2650, ptr %2651, 1
  %2653 = load ptr, ptr %1568, align 8
  %2654 = insertvalue { ptr, ptr, ptr, i32 } %2652, ptr %2653, 2
  %2655 = load i32, ptr %168, align 4
  %2656 = insertvalue { ptr, ptr, ptr, i32 } %2654, i32 %2655, 3
  %hash_coef_ptr.i.i10.i3100 = getelementptr i8, ptr %2649, i64 8
  %tbl_size_ptr.i.i11.i3101 = getelementptr i8, ptr %2649, i64 16
  %offset_tbl_ptr.i.i12.i3102 = getelementptr i8, ptr %2649, i64 40
  %hash_coef.i.i13.i3103 = load i64, ptr %hash_coef_ptr.i.i10.i3100, align 4
  %tbl_size.i.i14.i3104 = load i64, ptr %tbl_size_ptr.i.i11.i3101, align 4
  %offset_tbl.i.i15.i3105 = load ptr, ptr %offset_tbl_ptr.i.i12.i3102, align 8
  %product.i.i.i16.i3106 = mul i64 %hash_coef.i.i13.i3103, -5261542750394134544
  %shifted.i.i.i17.i3107 = lshr i64 %product.i.i.i16.i3106, 32
  %xored.i.i.i18.i3108 = xor i64 %shifted.i.i.i17.i3107, %product.i.i.i16.i3106
  %hash.i.i.i19.i3109 = and i64 %xored.i.i.i18.i3108, %tbl_size.i.i14.i3104
  %offset_ptr.i.i20.i3110 = getelementptr i32, ptr %offset_tbl.i.i15.i3105, i64 %hash.i.i.i19.i3109
  %offset.i.i21.i3111 = load i32, ptr %offset_ptr.i.i20.i3110, align 4
  %eq.i.i3112 = icmp eq i32 %2655, %offset.i.i21.i3111
  call void @llvm.assume(i1 %eq.i.i3112) #30
  %2657 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2658 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2649)
  %2659 = sext i32 %2655 to i64
  %2660 = getelementptr ptr, ptr %2649, i64 %2659
  %2661 = getelementptr i8, ptr %2660, i64 64
  %2662 = load ptr, ptr %2661, align 8
  %2663 = call ptr %2662({ ptr, ptr, ptr, i32 } %2656, ptr nonnull %2)
  %2664 = call i32 %2663({ ptr, ptr, ptr, i32 } %2656, { ptr, ptr, ptr, i32 } %2656, ptr nonnull %2)
  %2665 = add i32 %2664, -1
  %2666 = and i32 %2665, %2647
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2667 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2668 = load ptr, ptr %166, align 8
  %2669 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2668, 0
  %2670 = load ptr, ptr %167, align 8
  %2671 = insertvalue { ptr, ptr, ptr, i32 } %2669, ptr %2670, 1
  %2672 = load ptr, ptr %1568, align 8
  %2673 = insertvalue { ptr, ptr, ptr, i32 } %2671, ptr %2672, 2
  %2674 = load i32, ptr %168, align 4
  %2675 = insertvalue { ptr, ptr, ptr, i32 } %2673, i32 %2674, 3
  %hash_coef_ptr.i.i202.i2084 = getelementptr i8, ptr %2668, i64 8
  %tbl_size_ptr.i.i203.i2085 = getelementptr i8, ptr %2668, i64 16
  %offset_tbl_ptr.i.i204.i2086 = getelementptr i8, ptr %2668, i64 40
  %hash_coef.i.i205.i2087 = load i64, ptr %hash_coef_ptr.i.i202.i2084, align 4
  %tbl_size.i.i206.i2088 = load i64, ptr %tbl_size_ptr.i.i203.i2085, align 4
  %offset_tbl.i.i207.i2089 = load ptr, ptr %offset_tbl_ptr.i.i204.i2086, align 8
  %product.i.i.i208.i2090 = mul i64 %hash_coef.i.i205.i2087, -5261542750394134544
  %shifted.i.i.i209.i2091 = lshr i64 %product.i.i.i208.i2090, 32
  %xored.i.i.i210.i2092 = xor i64 %shifted.i.i.i209.i2091, %product.i.i.i208.i2090
  %hash.i.i.i211.i2093 = and i64 %xored.i.i.i210.i2092, %tbl_size.i.i206.i2088
  %offset_ptr.i.i212.i2094 = getelementptr i32, ptr %offset_tbl.i.i207.i2089, i64 %hash.i.i.i211.i2093
  %offset.i.i213.i2095 = load i32, ptr %offset_ptr.i.i212.i2094, align 4
  %eq.i216.i2096 = icmp eq i32 %2674, %offset.i.i213.i2095
  call void @llvm.assume(i1 %eq.i216.i2096) #30
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %2676 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %17)
  %2677 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2668)
  %2678 = sext i32 %2674 to i64
  %2679 = getelementptr ptr, ptr %2668, i64 %2678
  %2680 = getelementptr i8, ptr %2679, i64 120
  %2681 = load ptr, ptr %2680, align 8
  store ptr @i32_typ, ptr %18, align 8
  %2682 = call ptr %2681({ ptr, ptr, ptr, i32 } %2675, ptr nonnull %18)
  %2683 = call { ptr, i160 } %2682({ ptr, ptr, ptr, i32 } %2675, { ptr, ptr, ptr, i32 } %2675, ptr nonnull %17, i32 %2666)
  %.fca.0.extract87.i2097 = extractvalue { ptr, i160 } %2683, 0
  %.sroa.3.0.insert.ext.i2098 = zext i32 %offset.i.i260.i21472478 to i160
  %.sroa.3.0.insert.shift.i2099 = shl nuw i160 %.sroa.3.0.insert.ext.i2098, 128
  %.sroa.2.0.insert.ext.i2100 = zext i64 %2557 to i160
  %.sroa.2.0.insert.shift.i2101 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i2100, 64
  %.sroa.2.0.insert.insert.i2102 = or disjoint i160 %.sroa.2.0.insert.shift.i2101, %.sroa.3.0.insert.shift.i2099
  %.sroa.0.0.insert.ext.i2103 = zext i64 %2556 to i160
  %.sroa.0.0.insert.insert.i2104 = or disjoint i160 %.sroa.2.0.insert.insert.i2102, %.sroa.0.0.insert.ext.i2103
  %2684 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i2104, 1
  %2685 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2686 = load ptr, ptr %166, align 8
  %2687 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2686, 0
  %2688 = load ptr, ptr %167, align 8
  %2689 = insertvalue { ptr, ptr, ptr, i32 } %2687, ptr %2688, 1
  %2690 = load ptr, ptr %1568, align 8
  %2691 = insertvalue { ptr, ptr, ptr, i32 } %2689, ptr %2690, 2
  %2692 = load i32, ptr %168, align 4
  %2693 = insertvalue { ptr, ptr, ptr, i32 } %2691, i32 %2692, 3
  %hash_coef_ptr.i.i218.i2109 = getelementptr i8, ptr %2686, i64 8
  %tbl_size_ptr.i.i219.i2110 = getelementptr i8, ptr %2686, i64 16
  %offset_tbl_ptr.i.i220.i2111 = getelementptr i8, ptr %2686, i64 40
  %hash_coef.i.i221.i2112 = load i64, ptr %hash_coef_ptr.i.i218.i2109, align 4
  %tbl_size.i.i222.i2113 = load i64, ptr %tbl_size_ptr.i.i219.i2110, align 4
  %offset_tbl.i.i223.i2114 = load ptr, ptr %offset_tbl_ptr.i.i220.i2111, align 8
  %product.i.i.i224.i2115 = mul i64 %hash_coef.i.i221.i2112, -5261542750394134544
  %shifted.i.i.i225.i2116 = lshr i64 %product.i.i.i224.i2115, 32
  %xored.i.i.i226.i2117 = xor i64 %shifted.i.i.i225.i2116, %product.i.i.i224.i2115
  %hash.i.i.i227.i2118 = and i64 %xored.i.i.i226.i2117, %tbl_size.i.i222.i2113
  %offset_ptr.i.i228.i2119 = getelementptr i32, ptr %offset_tbl.i.i223.i2114, i64 %hash.i.i.i227.i2118
  %offset.i.i229.i2120 = load i32, ptr %offset_ptr.i.i228.i2119, align 4
  %eq.i232.i2121 = icmp eq i32 %2692, %offset.i.i229.i2120
  call void @llvm.assume(i1 %eq.i232.i2121) #30
  %2694 = load ptr, ptr %result.i, align 8
  %2695 = load ptr, ptr %136, align 8
  %result.i233.i2122 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2696 = getelementptr i8, ptr %result.i233.i2122, i64 16
  store ptr %2695, ptr %2696, align 8
  %2697 = getelementptr i8, ptr %result.i233.i2122, i64 8
  store ptr %2694, ptr %2697, align 8
  %2698 = getelementptr i8, ptr %result.i233.i2122, i64 24
  store ptr null, ptr %2698, align 8
  %2699 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i2122)
  store ptr @Entry, ptr %result.i233.i2122, align 8
  store ptr @_parameterization_Ptri32, ptr %19, align 8
  store ptr %result.i233.i2122, ptr %1592, align 8
  %2700 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %19)
  %2701 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2686)
  %2702 = sext i32 %2692 to i64
  %2703 = getelementptr ptr, ptr %2686, i64 %2702
  %2704 = getelementptr i8, ptr %2703, i64 128
  %2705 = load ptr, ptr %2704, align 8
  store ptr @i32_typ, ptr %20, align 8
  store ptr @Entry, ptr %1593, align 8
  %2706 = call ptr %2705({ ptr, ptr, ptr, i32 } %2693, ptr nonnull %20)
  call void %2706({ ptr, ptr, ptr, i32 } %2693, { ptr, ptr, ptr, i32 } %2693, ptr nonnull %19, i32 %2666, { ptr, i160 } %2684)
  %2707 = icmp ne ptr %.fca.0.extract87.i2097, @nil_typ
  %2708 = icmp ne ptr %.fca.0.extract87.i2097, null
  %.not138.i2123 = and i1 %2707, %2708
  br i1 %.not138.i2123, label %.cont.cont.i2130, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2197.thread

.cont.cont.i2130:                                 ; preds = %2629, %2567
  %.sink2495 = phi { ptr, i160 } [ %2603, %2567 ], [ %2683, %2629 ]
  %2709 = phi i32 [ 2, %2567 ], [ 1, %2629 ]
  %vptr.i248.sroa.speculated.i2133 = phi ptr [ %.fca.0.extract112.i2165, %2567 ], [ %.fca.0.extract87.i2097, %2629 ]
  %.fca.1.extract89.i2126 = extractvalue { ptr, i160 } %.sink2495, 1
  %.sroa.3407.sroa.4.0.extract.shift.i2127 = lshr i160 %.fca.1.extract89.i2126, 64
  %2710 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i2127 to i64
  %2711 = insertelement <2 x i64> poison, i64 %2710, i64 0
  %2712 = trunc i160 %.fca.1.extract89.i2126 to i64
  %2713 = insertelement <2 x i64> %2711, i64 %2712, i64 1
  %hash_coef_ptr.i.i249.i2136 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2133, i64 8
  %tbl_size_ptr.i.i250.i2137 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2133, i64 16
  %offset_tbl_ptr.i.i251.i2138 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2133, i64 40
  %hash_coef.i.i252.i2139 = load i64, ptr %hash_coef_ptr.i.i249.i2136, align 4
  %tbl_size.i.i253.i2140 = load i64, ptr %tbl_size_ptr.i.i250.i2137, align 4
  %offset_tbl.i.i254.i2141 = load ptr, ptr %offset_tbl_ptr.i.i251.i2138, align 8
  %product.i.i.i255.i2142 = mul i64 %hash_coef.i.i252.i2139, 4015701072841558310
  %shifted.i.i.i256.i2143 = lshr i64 %product.i.i.i255.i2142, 32
  %xored.i.i.i257.i2144 = xor i64 %shifted.i.i.i256.i2143, %product.i.i.i255.i2142
  %hash.i.i.i258.i2145 = and i64 %xored.i.i.i257.i2144, %tbl_size.i.i253.i2140
  %offset_ptr.i.i259.i2146 = getelementptr i32, ptr %offset_tbl.i.i254.i2141, i64 %hash.i.i.i258.i2145
  %offset.i.i260.i2147 = load i32, ptr %offset_ptr.i.i259.i2146, align 4
  %2714 = add nuw nsw i32 %.reg2mem193.0677.i2079, 1
  %2715 = load i32, ptr %169, align 4
  %2716 = icmp slt i32 %2714, %2715
  br i1 %2716, label %2554, label %._crit_edge1.1.i618

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2197.thread: ; preds = %2567, %2629
  %2717 = phi ptr [ %21, %2629 ], [ %13, %2567 ]
  %2718 = phi ptr [ %22, %2629 ], [ %14, %2567 ]
  %2719 = phi ptr [ %23, %2629 ], [ %15, %2567 ]
  %2720 = phi ptr [ %.sroa.0.i2041, %2629 ], [ %.sroa.0680.i2039, %2567 ]
  %2721 = phi ptr [ %24, %2629 ], [ %16, %2567 ]
  %2722 = load i32, ptr %1569, align 4
  store i32 %2722, ptr %2717, align 4
  store i32 1, ptr %2718, align 4
  %2723 = add i32 %2722, 1
  store i32 %2723, ptr %2719, align 4
  %2724 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %2723, ptr %1569, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2721, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2720, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2039)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2041)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  br label %HashMap_insert_keyK_valueV.exit701

._crit_edge1.1.i618:                              ; preds = %.cont.cont.i2130, %HashMap_resize_.exit2038
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2039)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2041)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %8)
  %2725 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2726 = load ptr, ptr %153, align 8
  %2727 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2726, 0
  %2728 = load ptr, ptr %154, align 8
  %2729 = insertvalue { ptr, ptr, ptr, i32 } %2727, ptr %2728, 1
  %2730 = load ptr, ptr %1567, align 8
  %2731 = insertvalue { ptr, ptr, ptr, i32 } %2729, ptr %2730, 2
  %2732 = load i32, ptr %155, align 4
  %2733 = insertvalue { ptr, ptr, ptr, i32 } %2731, i32 %2732, 3
  %hash_coef_ptr.i.i64.i2215 = getelementptr i8, ptr %2726, i64 8
  %tbl_size_ptr.i.i65.i2216 = getelementptr i8, ptr %2726, i64 16
  %offset_tbl_ptr.i.i66.i2217 = getelementptr i8, ptr %2726, i64 40
  %hash_coef.i.i67.i2218 = load i64, ptr %hash_coef_ptr.i.i64.i2215, align 4
  %tbl_size.i.i68.i2219 = load i64, ptr %tbl_size_ptr.i.i65.i2216, align 4
  %offset_tbl.i.i69.i2220 = load ptr, ptr %offset_tbl_ptr.i.i66.i2217, align 8
  %product.i.i.i70.i2221 = mul i64 %hash_coef.i.i67.i2218, -5261542750394134544
  %shifted.i.i.i71.i2222 = lshr i64 %product.i.i.i70.i2221, 32
  %xored.i.i.i72.i2223 = xor i64 %shifted.i.i.i71.i2222, %product.i.i.i70.i2221
  %hash.i.i.i73.i2224 = and i64 %xored.i.i.i72.i2223, %tbl_size.i.i68.i2219
  %offset_ptr.i.i74.i2225 = getelementptr i32, ptr %offset_tbl.i.i69.i2220, i64 %hash.i.i.i73.i2224
  %offset.i.i75.i2226 = load i32, ptr %offset_ptr.i.i74.i2225, align 4
  %eq.i.i2227 = icmp eq i32 %2732, %offset.i.i75.i2226
  call void @llvm.assume(i1 %eq.i.i2227) #30
  %2734 = load ptr, ptr %166, align 8
  %2735 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2734, 0
  %2736 = load ptr, ptr %167, align 8
  %2737 = insertvalue { ptr, ptr, ptr, i32 } %2735, ptr %2736, 1
  %2738 = load ptr, ptr %1568, align 8
  %2739 = insertvalue { ptr, ptr, ptr, i32 } %2737, ptr %2738, 2
  %2740 = load i32, ptr %168, align 4
  %2741 = insertvalue { ptr, ptr, ptr, i32 } %2739, i32 %2740, 3
  %hash_coef_ptr.i.i92.i2232 = getelementptr i8, ptr %2734, i64 8
  %tbl_size_ptr.i.i93.i2233 = getelementptr i8, ptr %2734, i64 16
  %offset_tbl_ptr.i.i94.i2234 = getelementptr i8, ptr %2734, i64 40
  %hash_coef.i.i95.i2235 = load i64, ptr %hash_coef_ptr.i.i92.i2232, align 4
  %tbl_size.i.i96.i2236 = load i64, ptr %tbl_size_ptr.i.i93.i2233, align 4
  %offset_tbl.i.i97.i2237 = load ptr, ptr %offset_tbl_ptr.i.i94.i2234, align 8
  %product.i.i.i98.i2238 = mul i64 %hash_coef.i.i95.i2235, -5261542750394134544
  %shifted.i.i.i99.i2239 = lshr i64 %product.i.i.i98.i2238, 32
  %xored.i.i.i100.i2240 = xor i64 %shifted.i.i.i99.i2239, %product.i.i.i98.i2238
  %hash.i.i.i101.i2241 = and i64 %xored.i.i.i100.i2240, %tbl_size.i.i96.i2236
  %offset_ptr.i.i102.i2242 = getelementptr i32, ptr %offset_tbl.i.i97.i2237, i64 %hash.i.i.i101.i2241
  %offset.i.i103.i2243 = load i32, ptr %offset_ptr.i.i102.i2242, align 4
  %eq.i106.i2244 = icmp eq i32 %2740, %offset.i.i103.i2243
  call void @llvm.assume(i1 %eq.i106.i2244) #30
  %2742 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2743 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2726)
  %2744 = sext i32 %2732 to i64
  %2745 = getelementptr ptr, ptr %2726, i64 %2744
  %2746 = getelementptr i8, ptr %2745, i64 64
  %2747 = load ptr, ptr %2746, align 8
  %2748 = call ptr %2747({ ptr, ptr, ptr, i32 } %2733, ptr nonnull %2)
  %2749 = call i32 %2748({ ptr, ptr, ptr, i32 } %2733, { ptr, ptr, ptr, i32 } %2733, ptr nonnull %2)
  %2750 = shl i32 %2749, 1
  %2751 = load i32, ptr %1569, align 4
  %2752 = load ptr, ptr %result.i, align 8
  %2753 = load ptr, ptr %136, align 8
  %2754 = sext i32 %2751 to i64
  %2755 = shl nsw i64 %2754, 5
  %result.i.i.i2247 = call noalias ptr @bump_malloc_inner(i64 noundef %2755, ptr nonnull @current_ptr) #29
  %2756 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2757 = icmp sgt i32 %2749, 0
  br i1 %2757, label %.lr.ph434.i2317, label %._crit_edge395.i2261

.lr.ph434.i2317:                                  ; preds = %._crit_edge1.1.i618
  %invariant.gep.i2260 = getelementptr i8, ptr %2726, i64 120
  %2758 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i2320 = getelementptr ptr, ptr %invariant.gep.i2260, i64 %2744
  br label %2759

2759:                                             ; preds = %2781, %.lr.ph434.i2317
  %.reg2mem105.0432.i2318 = phi i32 [ 0, %.lr.ph434.i2317 ], [ %.reg2mem101.0.i2323, %2781 ]
  %.reg2mem103.0431.i2319 = phi i32 [ 0, %.lr.ph434.i2317 ], [ %2782, %2781 ]
  store ptr @_parameterization_Ptri32, ptr %3, align 8
  %2760 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %3)
  %2761 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2726)
  %2762 = load ptr, ptr %gep.i2320, align 8
  store ptr @i32_typ, ptr %4, align 8
  %2763 = call ptr %2762({ ptr, ptr, ptr, i32 } %2733, ptr nonnull %4)
  %2764 = call { ptr, i160 } %2763({ ptr, ptr, ptr, i32 } %2733, { ptr, ptr, ptr, i32 } %2733, ptr nonnull %3, i32 %.reg2mem103.0431.i2319)
  %.fca.0.extract52.i2321 = extractvalue { ptr, i160 } %2764, 0
  %2765 = icmp ne ptr %.fca.0.extract52.i2321, @nil_typ
  %2766 = icmp ne ptr %.fca.0.extract52.i2321, null
  %.not60.i2322 = and i1 %2765, %2766
  br i1 %.not60.i2322, label %2767, label %2781

2767:                                             ; preds = %2759
  %hash_coef_ptr.i.i137.i2350 = getelementptr i8, ptr %.fca.0.extract52.i2321, i64 8
  %tbl_size_ptr.i.i138.i2351 = getelementptr i8, ptr %.fca.0.extract52.i2321, i64 16
  %offset_tbl_ptr.i.i139.i2352 = getelementptr i8, ptr %.fca.0.extract52.i2321, i64 40
  %hash_coef.i.i140.i2353 = load i64, ptr %hash_coef_ptr.i.i137.i2350, align 4
  %tbl_size.i.i141.i2354 = load i64, ptr %tbl_size_ptr.i.i138.i2351, align 4
  %offset_tbl.i.i142.i2355 = load ptr, ptr %offset_tbl_ptr.i.i139.i2352, align 8
  %product.i.i.i143.i2356 = mul i64 %hash_coef.i.i140.i2353, 4015701072841558310
  %shifted.i.i.i144.i2357 = lshr i64 %product.i.i.i143.i2356, 32
  %xored.i.i.i145.i2358 = xor i64 %shifted.i.i.i144.i2357, %product.i.i.i143.i2356
  %hash.i.i.i146.i2359 = and i64 %xored.i.i.i145.i2358, %tbl_size.i.i141.i2354
  %offset_ptr.i.i147.i2360 = getelementptr i32, ptr %offset_tbl.i.i142.i2355, i64 %hash.i.i.i146.i2359
  %offset.i.i148.i2361 = load i32, ptr %offset_ptr.i.i147.i2360, align 4
  %2768 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2769 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2770 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2771 = icmp slt i32 %.reg2mem105.0432.i2318, %2751
  br i1 %2771, label %2772, label %._crit_edge.i2362

2772:                                             ; preds = %2767
  %.fca.1.extract54.i2363 = extractvalue { ptr, i160 } %2764, 1
  %.sroa.351.0.insert.ext.i2364 = zext i32 %offset.i.i148.i2361 to i160
  %.sroa.351.0.insert.shift.i2365 = shl nuw i160 %.sroa.351.0.insert.ext.i2364, 128
  %2773 = and i160 %.fca.1.extract54.i2363, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2366 = or disjoint i160 %.sroa.351.0.insert.shift.i2365, %2773
  %2774 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2775 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2776 = sext i32 %.reg2mem105.0432.i2318 to i64
  %2777 = shl nsw i64 %2776, 5
  %2778 = getelementptr i8, ptr %result.i.i.i2247, i64 %2777
  store ptr %.fca.0.extract52.i2321, ptr %2778, align 8
  %2779 = getelementptr i8, ptr %2778, i64 8
  store i160 %.sroa.049.0.insert.insert.i2366, ptr %2779, align 4
  br label %._crit_edge.i2362

._crit_edge.i2362:                                ; preds = %2772, %2767
  %2780 = add i32 %.reg2mem105.0432.i2318, 1
  br label %2781

2781:                                             ; preds = %._crit_edge.i2362, %2759
  %.reg2mem101.0.i2323 = phi i32 [ %2780, %._crit_edge.i2362 ], [ %.reg2mem105.0432.i2318, %2759 ]
  %2782 = add nuw nsw i32 %.reg2mem103.0431.i2319, 1
  %2783 = icmp slt i32 %2782, %2749
  br i1 %2783, label %2759, label %.lr.ph.i2324

.lr.ph.i2324:                                     ; preds = %2781
  %invariant.gep396.i2325 = getelementptr i8, ptr %2734, i64 120
  %2784 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2785 = sext i32 %2740 to i64
  %gep397.i2328 = getelementptr ptr, ptr %invariant.gep396.i2325, i64 %2785
  br label %2786

2786:                                             ; preds = %2808, %.lr.ph.i2324
  %.reg2mem91.0394.i2326 = phi i32 [ %.reg2mem101.0.i2323, %.lr.ph.i2324 ], [ %.reg2mem87.0.i2331, %2808 ]
  %.reg2mem89.0393.i2327 = phi i32 [ 0, %.lr.ph.i2324 ], [ %2809, %2808 ]
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %2787 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %2788 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2734)
  %2789 = load ptr, ptr %gep397.i2328, align 8
  store ptr @i32_typ, ptr %6, align 8
  %2790 = call ptr %2789({ ptr, ptr, ptr, i32 } %2741, ptr nonnull %6)
  %2791 = call { ptr, i160 } %2790({ ptr, ptr, ptr, i32 } %2741, { ptr, ptr, ptr, i32 } %2741, ptr nonnull %5, i32 %.reg2mem89.0393.i2327)
  %.fca.0.extract42.i2329 = extractvalue { ptr, i160 } %2791, 0
  %2792 = icmp ne ptr %.fca.0.extract42.i2329, @nil_typ
  %2793 = icmp ne ptr %.fca.0.extract42.i2329, null
  %.not62.i2330 = and i1 %2792, %2793
  br i1 %.not62.i2330, label %2794, label %2808

2794:                                             ; preds = %2786
  %hash_coef_ptr.i.i152.i2332 = getelementptr i8, ptr %.fca.0.extract42.i2329, i64 8
  %tbl_size_ptr.i.i153.i2333 = getelementptr i8, ptr %.fca.0.extract42.i2329, i64 16
  %offset_tbl_ptr.i.i154.i2334 = getelementptr i8, ptr %.fca.0.extract42.i2329, i64 40
  %hash_coef.i.i155.i2335 = load i64, ptr %hash_coef_ptr.i.i152.i2332, align 4
  %tbl_size.i.i156.i2336 = load i64, ptr %tbl_size_ptr.i.i153.i2333, align 4
  %offset_tbl.i.i157.i2337 = load ptr, ptr %offset_tbl_ptr.i.i154.i2334, align 8
  %product.i.i.i158.i2338 = mul i64 %hash_coef.i.i155.i2335, 4015701072841558310
  %shifted.i.i.i159.i2339 = lshr i64 %product.i.i.i158.i2338, 32
  %xored.i.i.i160.i2340 = xor i64 %shifted.i.i.i159.i2339, %product.i.i.i158.i2338
  %hash.i.i.i161.i2341 = and i64 %xored.i.i.i160.i2340, %tbl_size.i.i156.i2336
  %offset_ptr.i.i162.i2342 = getelementptr i32, ptr %offset_tbl.i.i157.i2337, i64 %hash.i.i.i161.i2341
  %offset.i.i163.i2343 = load i32, ptr %offset_ptr.i.i162.i2342, align 4
  %2795 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2796 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2797 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2798 = icmp slt i32 %.reg2mem91.0394.i2326, %2751
  br i1 %2798, label %2799, label %._crit_edge1.i2344

2799:                                             ; preds = %2794
  %.fca.1.extract44.i2345 = extractvalue { ptr, i160 } %2791, 1
  %.sroa.3.0.insert.ext.i2346 = zext i32 %offset.i.i163.i2343 to i160
  %.sroa.3.0.insert.shift.i2347 = shl nuw i160 %.sroa.3.0.insert.ext.i2346, 128
  %2800 = and i160 %.fca.1.extract44.i2345, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2348 = or disjoint i160 %.sroa.3.0.insert.shift.i2347, %2800
  %2801 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2802 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2803 = sext i32 %.reg2mem91.0394.i2326 to i64
  %2804 = shl nsw i64 %2803, 5
  %2805 = getelementptr i8, ptr %result.i.i.i2247, i64 %2804
  store ptr %.fca.0.extract42.i2329, ptr %2805, align 8
  %2806 = getelementptr i8, ptr %2805, i64 8
  store i160 %.sroa.040.0.insert.insert.i2348, ptr %2806, align 4
  br label %._crit_edge1.i2344

._crit_edge1.i2344:                               ; preds = %2799, %2794
  %2807 = add i32 %.reg2mem91.0394.i2326, 1
  br label %2808

2808:                                             ; preds = %._crit_edge1.i2344, %2786
  %.reg2mem87.0.i2331 = phi i32 [ %2807, %._crit_edge1.i2344 ], [ %.reg2mem91.0394.i2326, %2786 ]
  %2809 = add nuw nsw i32 %.reg2mem89.0393.i2327, 1
  %2810 = icmp slt i32 %2809, %2749
  br i1 %2810, label %2786, label %._crit_edge395.i2261.loopexit

._crit_edge395.i2261.loopexit:                    ; preds = %2808
  %.pre2861 = load ptr, ptr %result.i, align 8
  %.pre2862 = load ptr, ptr %136, align 8
  br label %._crit_edge395.i2261

._crit_edge395.i2261:                             ; preds = %._crit_edge395.i2261.loopexit, %._crit_edge1.1.i618
  %2811 = phi ptr [ %2753, %._crit_edge1.1.i618 ], [ %.pre2862, %._crit_edge395.i2261.loopexit ]
  %2812 = phi ptr [ %2752, %._crit_edge1.1.i618 ], [ %.pre2861, %._crit_edge395.i2261.loopexit ]
  %.reg2mem91.0.lcssa.i2262 = phi i32 [ 0, %._crit_edge1.1.i618 ], [ %.reg2mem87.0.i2331, %._crit_edge395.i2261.loopexit ]
  %2813 = call i32 @llvm.smax.i32(i32 %2750, i32 16)
  %result.i166.i2263 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2814 = getelementptr i8, ptr %result.i166.i2263, i64 16
  store ptr @_parameterization_Nil, ptr %2814, align 8
  %result.i167.i2264 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2815 = getelementptr i8, ptr %result.i167.i2264, i64 16
  store ptr %2811, ptr %2815, align 8
  %2816 = getelementptr i8, ptr %result.i167.i2264, i64 8
  store ptr %2812, ptr %2816, align 8
  %2817 = getelementptr i8, ptr %result.i167.i2264, i64 24
  store ptr null, ptr %2817, align 8
  %2818 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i2264)
  store ptr @Entry, ptr %result.i167.i2264, align 8
  %2819 = getelementptr i8, ptr %result.i166.i2263, i64 8
  store ptr %result.i167.i2264, ptr %2819, align 8
  %2820 = getelementptr i8, ptr %result.i166.i2263, i64 24
  store ptr null, ptr %2820, align 8
  %2821 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i2263)
  store ptr @union_typ, ptr %result.i166.i2263, align 8
  %result.i168.i2265 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i2263, ptr %result.i168.i2265, align 8
  %2822 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i2265)
  store ptr @Array, ptr %7, align 8
  store ptr %result.i168.i2265, ptr %1596, align 8
  store i32 9, ptr %1597, align 8
  %2823 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %7)
  %2824 = getelementptr i8, ptr %result.i168.i2265, i64 16
  store i32 %2813, ptr %2824, align 4
  %2825 = getelementptr i8, ptr %result.i168.i2265, i64 20
  store i32 %2813, ptr %2825, align 4
  %2826 = zext nneg i32 %2813 to i64
  %2827 = shl nuw nsw i64 %2826, 5
  %result.i.i416.i2266 = call noalias ptr @bump_malloc_inner(i64 noundef %2827, ptr nonnull @current_ptr) #29
  %2828 = getelementptr i8, ptr %result.i168.i2265, i64 8
  store ptr %result.i.i416.i2266, ptr %2828, align 8
  %2829 = load ptr, ptr %1598, align 8
  store ptr @Array, ptr %153, align 8
  store ptr %result.i168.i2265, ptr %154, align 8
  store ptr %2829, ptr %1567, align 8
  store i32 9, ptr %155, align 4
  %result.i183.i2279 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2830 = getelementptr i8, ptr %result.i183.i2279, i64 16
  store ptr @_parameterization_Nil, ptr %2830, align 8
  %result.i184.i2280 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2831 = getelementptr i8, ptr %result.i184.i2280, i64 16
  store ptr %2811, ptr %2831, align 8
  %2832 = getelementptr i8, ptr %result.i184.i2280, i64 8
  store ptr %2812, ptr %2832, align 8
  %2833 = getelementptr i8, ptr %result.i184.i2280, i64 24
  store ptr null, ptr %2833, align 8
  %2834 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i2280)
  store ptr @Entry, ptr %result.i184.i2280, align 8
  %2835 = getelementptr i8, ptr %result.i183.i2279, i64 8
  store ptr %result.i184.i2280, ptr %2835, align 8
  %2836 = getelementptr i8, ptr %result.i183.i2279, i64 24
  store ptr null, ptr %2836, align 8
  %2837 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i2279)
  store ptr @union_typ, ptr %result.i183.i2279, align 8
  %result.i185.i2281 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i2279, ptr %result.i185.i2281, align 8
  %2838 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i2281)
  store ptr @Array, ptr %8, align 8
  store ptr %result.i185.i2281, ptr %1599, align 8
  store i32 9, ptr %1600, align 8
  %2839 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %8)
  %2840 = getelementptr i8, ptr %result.i185.i2281, i64 16
  store i32 %2813, ptr %2840, align 4
  %2841 = getelementptr i8, ptr %result.i185.i2281, i64 20
  store i32 %2813, ptr %2841, align 4
  %result.i.i430.i2282 = call noalias ptr @bump_malloc_inner(i64 noundef %2827, ptr nonnull @current_ptr) #29
  %2842 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2843 = getelementptr i8, ptr %result.i185.i2281, i64 8
  store ptr %result.i.i430.i2282, ptr %2843, align 8
  %2844 = load ptr, ptr %1601, align 8
  store ptr @Array, ptr %166, align 8
  store ptr %result.i185.i2281, ptr %167, align 8
  store ptr %2844, ptr %1568, align 8
  store i32 9, ptr %168, align 4
  %2845 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 0, ptr %1569, align 4
  %2846 = icmp sgt i32 %.reg2mem91.0.lcssa.i2262, 0
  br i1 %2846, label %.lr.ph400.i2295, label %HashMap_resize_.exit2368

.lr.ph400.i2295:                                  ; preds = %._crit_edge395.i2261
  %2847 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2848 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2849 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i2297

._crit_edge2.i2297:                               ; preds = %._crit_edge2.i2297, %.lr.ph400.i2295
  %.reg2mem77.0398.i2298 = phi i32 [ 0, %.lr.ph400.i2295 ], [ %2863, %._crit_edge2.i2297 ]
  %2850 = zext nneg i32 %.reg2mem77.0398.i2298 to i64
  %2851 = shl nuw nsw i64 %2850, 5
  %2852 = getelementptr i8, ptr %result.i.i.i2247, i64 %2851
  %2853 = load ptr, ptr %2852, align 8
  %2854 = getelementptr i8, ptr %2852, i64 8
  %2855 = load i160, ptr %2854, align 4
  %.sroa.3362.8.extract.trunc.i2301 = trunc i160 %2855 to i64
  %2856 = inttoptr i64 %.sroa.3362.8.extract.trunc.i2301 to ptr
  %.sroa.5363.8.extract.shift.i2302 = lshr i160 %2855, 64
  %.sroa.5363.8.extract.trunc.i2303 = trunc i160 %.sroa.5363.8.extract.shift.i2302 to i64
  %2857 = inttoptr i64 %.sroa.5363.8.extract.trunc.i2303 to ptr
  %hash_coef_ptr.i.i201.i2304 = getelementptr i8, ptr %2853, i64 8
  %tbl_size_ptr.i.i202.i2305 = getelementptr i8, ptr %2853, i64 16
  %offset_tbl_ptr.i.i203.i2306 = getelementptr i8, ptr %2853, i64 40
  %hash_coef.i.i232.i2307 = load i64, ptr %hash_coef_ptr.i.i201.i2304, align 4
  %tbl_size.i.i233.i2308 = load i64, ptr %tbl_size_ptr.i.i202.i2305, align 4
  %offset_tbl.i.i234.i2309 = load ptr, ptr %offset_tbl_ptr.i.i203.i2306, align 8
  %product.i.i.i235.i2310 = mul i64 %hash_coef.i.i232.i2307, 4015701072841558310
  %shifted.i.i.i236.i2311 = lshr i64 %product.i.i.i235.i2310, 32
  %xored.i.i.i237.i2312 = xor i64 %shifted.i.i.i236.i2311, %product.i.i.i235.i2310
  %hash.i.i.i238.i2313 = and i64 %xored.i.i.i237.i2312, %tbl_size.i.i233.i2308
  %offset_ptr.i.i239.i2314 = getelementptr i32, ptr %offset_tbl.i.i234.i2309, i64 %hash.i.i.i238.i2313
  %offset.i.i240.i2315 = load i32, ptr %offset_ptr.i.i239.i2314, align 4
  %2858 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2853, 0
  %2859 = insertvalue { ptr, ptr, ptr, i32 } %2858, ptr %2856, 1
  %2860 = insertvalue { ptr, ptr, ptr, i32 } %2859, ptr %2857, 2
  %2861 = insertvalue { ptr, ptr, ptr, i32 } %2860, i32 %offset.i.i240.i2315, 3
  %2862 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %1578, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2861)
  %2863 = add nuw nsw i32 %.reg2mem77.0398.i2298, 1
  %2864 = icmp slt i32 %2863, %.reg2mem91.0.lcssa.i2262
  br i1 %2864, label %._crit_edge2.i2297, label %HashMap_resize_.exit2368

HashMap_resize_.exit2368:                         ; preds = %._crit_edge2.i2297, %._crit_edge395.i2261
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %8)
  br label %HashMap_insert_keyK_valueV.exit701

HashMap_insert_keyK_valueV.exit701:               ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2197.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2448, %1677, %1873, %HashMap_resize_.exit2368
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %109)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %111)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %113)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %114)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %115)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %116)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %117)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %118)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %119)
  %2865 = add nuw nsw i32 %.reg2mem75.0241, 1
  %2866 = icmp slt i32 %2865, %0
  br i1 %2866, label %._crit_edge, label %._crit_edge1

._crit_edge1:                                     ; preds = %HashMap_insert_keyK_valueV.exit701
  %2867 = call i64 @clock()
  %.sroa.027.0.insert.ext = zext i32 %286 to i160
  %2868 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.027.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %108)
  %2869 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2870 = load ptr, ptr %141, align 8
  %2871 = call i32 %2870({ ptr, i160 } %2868)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2872 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2873 = load ptr, ptr %153, align 8
  %2874 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2873, 0
  %2875 = load ptr, ptr %154, align 8
  %2876 = insertvalue { ptr, ptr, ptr, i32 } %2874, ptr %2875, 1
  %2877 = load ptr, ptr %1567, align 8
  %2878 = insertvalue { ptr, ptr, ptr, i32 } %2876, ptr %2877, 2
  %2879 = load i32, ptr %155, align 4
  %2880 = insertvalue { ptr, ptr, ptr, i32 } %2878, i32 %2879, 3
  %hash_coef_ptr.i.i10.i2401 = getelementptr i8, ptr %2873, i64 8
  %tbl_size_ptr.i.i11.i2402 = getelementptr i8, ptr %2873, i64 16
  %offset_tbl_ptr.i.i12.i2403 = getelementptr i8, ptr %2873, i64 40
  %hash_coef.i.i13.i2404 = load i64, ptr %hash_coef_ptr.i.i10.i2401, align 4
  %tbl_size.i.i14.i2405 = load i64, ptr %tbl_size_ptr.i.i11.i2402, align 4
  %offset_tbl.i.i15.i2406 = load ptr, ptr %offset_tbl_ptr.i.i12.i2403, align 8
  %product.i.i.i16.i2407 = mul i64 %hash_coef.i.i13.i2404, -5261542750394134544
  %shifted.i.i.i17.i2408 = lshr i64 %product.i.i.i16.i2407, 32
  %xored.i.i.i18.i2409 = xor i64 %shifted.i.i.i17.i2408, %product.i.i.i16.i2407
  %hash.i.i.i19.i2410 = and i64 %xored.i.i.i18.i2409, %tbl_size.i.i14.i2405
  %offset_ptr.i.i20.i2411 = getelementptr i32, ptr %offset_tbl.i.i15.i2406, i64 %hash.i.i.i19.i2410
  %offset.i.i21.i2412 = load i32, ptr %offset_ptr.i.i20.i2411, align 4
  %eq.i.i2413 = icmp eq i32 %2879, %offset.i.i21.i2412
  call void @llvm.assume(i1 %eq.i.i2413) #30
  %2881 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2882 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2873)
  %2883 = sext i32 %2879 to i64
  %2884 = getelementptr ptr, ptr %2873, i64 %2883
  %2885 = getelementptr i8, ptr %2884, i64 64
  %2886 = load ptr, ptr %2885, align 8
  %2887 = call ptr %2886({ ptr, ptr, ptr, i32 } %2880, ptr nonnull %2)
  %2888 = call i32 %2887({ ptr, ptr, ptr, i32 } %2880, { ptr, ptr, ptr, i32 } %2880, ptr nonnull %2)
  %2889 = add i32 %2888, -1
  %2890 = and i32 %2889, %2871
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2891 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2892 = load ptr, ptr %153, align 8
  %2893 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2892, 0
  %2894 = load ptr, ptr %154, align 8
  %2895 = insertvalue { ptr, ptr, ptr, i32 } %2893, ptr %2894, 1
  %2896 = load ptr, ptr %1567, align 8
  %2897 = insertvalue { ptr, ptr, ptr, i32 } %2895, ptr %2896, 2
  %2898 = load i32, ptr %155, align 4
  %2899 = insertvalue { ptr, ptr, ptr, i32 } %2897, i32 %2898, 3
  %hash_coef_ptr.i.i130.i = getelementptr i8, ptr %2892, i64 8
  %tbl_size_ptr.i.i131.i = getelementptr i8, ptr %2892, i64 16
  %offset_tbl_ptr.i.i132.i = getelementptr i8, ptr %2892, i64 40
  %hash_coef.i.i133.i = load i64, ptr %hash_coef_ptr.i.i130.i, align 4
  %tbl_size.i.i134.i = load i64, ptr %tbl_size_ptr.i.i131.i, align 4
  %offset_tbl.i.i135.i = load ptr, ptr %offset_tbl_ptr.i.i132.i, align 8
  %product.i.i.i136.i = mul i64 %hash_coef.i.i133.i, -5261542750394134544
  %shifted.i.i.i137.i = lshr i64 %product.i.i.i136.i, 32
  %xored.i.i.i138.i = xor i64 %shifted.i.i.i137.i, %product.i.i.i136.i
  %hash.i.i.i139.i = and i64 %xored.i.i.i138.i, %tbl_size.i.i134.i
  %offset_ptr.i.i140.i = getelementptr i32, ptr %offset_tbl.i.i135.i, i64 %hash.i.i.i139.i
  %offset.i.i141.i = load i32, ptr %offset_ptr.i.i140.i, align 4
  %eq.i.i716 = icmp eq i32 %2898, %offset.i.i141.i
  call void @llvm.assume(i1 %eq.i.i716) #30
  store ptr @_parameterization_Ptri32, ptr %107, align 8
  %2900 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %107)
  %2901 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2892)
  %2902 = sext i32 %2898 to i64
  %2903 = getelementptr ptr, ptr %2892, i64 %2902
  %2904 = getelementptr i8, ptr %2903, i64 120
  %2905 = load ptr, ptr %2904, align 8
  store ptr @i32_typ, ptr %108, align 8
  %2906 = call ptr %2905({ ptr, ptr, ptr, i32 } %2899, ptr nonnull %108)
  %2907 = call { ptr, i160 } %2906({ ptr, ptr, ptr, i32 } %2899, { ptr, ptr, ptr, i32 } %2899, ptr nonnull %107, i32 %2890)
  %.fca.0.extract.i717 = extractvalue { ptr, i160 } %2907, 0
  %2908 = icmp ne ptr %.fca.0.extract.i717, @nil_typ
  %2909 = icmp ne ptr %.fca.0.extract.i717, null
  %.not126.i = and i1 %2908, %2909
  br i1 %.not126.i, label %2910, label %.critedge.i718

2910:                                             ; preds = %._crit_edge1
  %.fca.1.extract.i723 = extractvalue { ptr, i160 } %2907, 1
  %.sroa.5.8.extract.trunc.i724 = trunc i160 %.fca.1.extract.i723 to i64
  %2911 = inttoptr i64 %.sroa.5.8.extract.trunc.i724 to ptr
  %.sroa.9.8.extract.shift.i = lshr i160 %.fca.1.extract.i723, 64
  %.sroa.9.8.extract.trunc.i = trunc i160 %.sroa.9.8.extract.shift.i to i64
  %2912 = inttoptr i64 %.sroa.9.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i144.i = getelementptr i8, ptr %.fca.0.extract.i717, i64 8
  %tbl_size_ptr.i.i145.i = getelementptr i8, ptr %.fca.0.extract.i717, i64 16
  %offset_tbl_ptr.i.i146.i = getelementptr i8, ptr %.fca.0.extract.i717, i64 40
  %hash_coef.i.i147.i = load i64, ptr %hash_coef_ptr.i.i144.i, align 4
  %tbl_size.i.i148.i = load i64, ptr %tbl_size_ptr.i.i145.i, align 4
  %offset_tbl.i.i149.i = load ptr, ptr %offset_tbl_ptr.i.i146.i, align 8
  %product.i.i.i150.i = mul i64 %hash_coef.i.i147.i, 4015701072841558310
  %shifted.i.i.i151.i = lshr i64 %product.i.i.i150.i, 32
  %xored.i.i.i152.i = xor i64 %shifted.i.i.i151.i, %product.i.i.i150.i
  %hash.i.i.i153.i = and i64 %xored.i.i.i152.i, %tbl_size.i.i148.i
  %offset_ptr.i.i154.i = getelementptr i32, ptr %offset_tbl.i.i149.i, i64 %hash.i.i.i153.i
  %offset.i.i155.i = load i32, ptr %offset_ptr.i.i154.i, align 4
  %2913 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i717, 0
  %2914 = insertvalue { ptr, ptr, ptr, i32 } %2913, ptr %2911, 1
  %2915 = insertvalue { ptr, ptr, ptr, i32 } %2914, ptr %2912, 2
  %2916 = insertvalue { ptr, ptr, ptr, i32 } %2915, i32 %offset.i.i155.i, 3
  %2917 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2918 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2919 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i717)
  %2920 = sext i32 %offset.i.i155.i to i64
  %2921 = getelementptr ptr, ptr %.fca.0.extract.i717, i64 %2920
  %2922 = getelementptr i8, ptr %2921, i64 64
  %2923 = load ptr, ptr %2922, align 8
  %2924 = call ptr %2923({ ptr, ptr, ptr, i32 } %2916, ptr nonnull %2)
  %2925 = call i32 %2924({ ptr, ptr, ptr, i32 } %2916, { ptr, ptr, ptr, i32 } %2916, ptr nonnull %2)
  %2926 = icmp eq i32 %2925, %2871
  %2927 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2928 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2929 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i717)
  %2930 = getelementptr i8, ptr %2921, i64 48
  %2931 = load ptr, ptr %2930, align 8
  %2932 = call ptr %2931({ ptr, ptr, ptr, i32 } %2916, ptr nonnull %2)
  %2933 = call { ptr, i160 } %2932({ ptr, ptr, ptr, i32 } %2916, { ptr, ptr, ptr, i32 } %2916, ptr nonnull %2)
  %2934 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2935 = load ptr, ptr %142, align 8
  %2936 = call i1 %2935({ ptr, i160 } %2933, { ptr, i160 } %2868)
  %2937 = and i1 %2926, %2936
  br i1 %2937, label %HashMap_get_keyK.exit, label %.critedge.i718

.critedge.i718:                                   ; preds = %2910, %._crit_edge1
  %2938 = add i32 %2871, 2127912214
  %2939 = shl i32 %2871, 12
  %2940 = add i32 %2938, %2939
  %2941 = ashr i32 %2940, 19
  %2942 = xor i32 %2940, %2941
  %2943 = xor i32 %2942, -949894596
  %2944 = add i32 %2943, 374761393
  %2945 = shl i32 %2943, 5
  %2946 = add i32 %2944, %2945
  %2947 = add i32 %2946, -744332180
  %2948 = shl i32 %2946, 9
  %2949 = xor i32 %2947, %2948
  %2950 = add i32 %2949, -42973499
  %2951 = shl i32 %2949, 3
  %2952 = add i32 %2950, %2951
  %2953 = ashr i32 %2952, 16
  %2954 = xor i32 %2952, %2953
  %2955 = xor i32 %2954, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2956 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2957 = load ptr, ptr %166, align 8
  %2958 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2957, 0
  %2959 = load ptr, ptr %167, align 8
  %2960 = insertvalue { ptr, ptr, ptr, i32 } %2958, ptr %2959, 1
  %2961 = load ptr, ptr %1568, align 8
  %2962 = insertvalue { ptr, ptr, ptr, i32 } %2960, ptr %2961, 2
  %2963 = load i32, ptr %168, align 4
  %2964 = insertvalue { ptr, ptr, ptr, i32 } %2962, i32 %2963, 3
  %hash_coef_ptr.i.i10.i2432 = getelementptr i8, ptr %2957, i64 8
  %tbl_size_ptr.i.i11.i2433 = getelementptr i8, ptr %2957, i64 16
  %offset_tbl_ptr.i.i12.i2434 = getelementptr i8, ptr %2957, i64 40
  %hash_coef.i.i13.i2435 = load i64, ptr %hash_coef_ptr.i.i10.i2432, align 4
  %tbl_size.i.i14.i2436 = load i64, ptr %tbl_size_ptr.i.i11.i2433, align 4
  %offset_tbl.i.i15.i2437 = load ptr, ptr %offset_tbl_ptr.i.i12.i2434, align 8
  %product.i.i.i16.i2438 = mul i64 %hash_coef.i.i13.i2435, -5261542750394134544
  %shifted.i.i.i17.i2439 = lshr i64 %product.i.i.i16.i2438, 32
  %xored.i.i.i18.i2440 = xor i64 %shifted.i.i.i17.i2439, %product.i.i.i16.i2438
  %hash.i.i.i19.i2441 = and i64 %xored.i.i.i18.i2440, %tbl_size.i.i14.i2436
  %offset_ptr.i.i20.i2442 = getelementptr i32, ptr %offset_tbl.i.i15.i2437, i64 %hash.i.i.i19.i2441
  %offset.i.i21.i2443 = load i32, ptr %offset_ptr.i.i20.i2442, align 4
  %eq.i.i2444 = icmp eq i32 %2963, %offset.i.i21.i2443
  call void @llvm.assume(i1 %eq.i.i2444) #30
  %2965 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2966 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2957)
  %2967 = sext i32 %2963 to i64
  %2968 = getelementptr ptr, ptr %2957, i64 %2967
  %2969 = getelementptr i8, ptr %2968, i64 64
  %2970 = load ptr, ptr %2969, align 8
  %2971 = call ptr %2970({ ptr, ptr, ptr, i32 } %2964, ptr nonnull %2)
  %2972 = call i32 %2971({ ptr, ptr, ptr, i32 } %2964, { ptr, ptr, ptr, i32 } %2964, ptr nonnull %2)
  %2973 = add i32 %2972, -1
  %2974 = and i32 %2973, %2955
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2975 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2976 = load ptr, ptr %166, align 8
  %2977 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2976, 0
  %2978 = load ptr, ptr %167, align 8
  %2979 = insertvalue { ptr, ptr, ptr, i32 } %2977, ptr %2978, 1
  %2980 = load ptr, ptr %1568, align 8
  %2981 = insertvalue { ptr, ptr, ptr, i32 } %2979, ptr %2980, 2
  %2982 = load i32, ptr %168, align 4
  %2983 = insertvalue { ptr, ptr, ptr, i32 } %2981, i32 %2982, 3
  %hash_coef_ptr.i.i158.i = getelementptr i8, ptr %2976, i64 8
  %tbl_size_ptr.i.i159.i = getelementptr i8, ptr %2976, i64 16
  %offset_tbl_ptr.i.i160.i = getelementptr i8, ptr %2976, i64 40
  %hash_coef.i.i161.i = load i64, ptr %hash_coef_ptr.i.i158.i, align 4
  %tbl_size.i.i162.i = load i64, ptr %tbl_size_ptr.i.i159.i, align 4
  %offset_tbl.i.i163.i = load ptr, ptr %offset_tbl_ptr.i.i160.i, align 8
  %product.i.i.i164.i = mul i64 %hash_coef.i.i161.i, -5261542750394134544
  %shifted.i.i.i165.i = lshr i64 %product.i.i.i164.i, 32
  %xored.i.i.i166.i = xor i64 %shifted.i.i.i165.i, %product.i.i.i164.i
  %hash.i.i.i167.i = and i64 %xored.i.i.i166.i, %tbl_size.i.i162.i
  %offset_ptr.i.i168.i = getelementptr i32, ptr %offset_tbl.i.i163.i, i64 %hash.i.i.i167.i
  %offset.i.i169.i = load i32, ptr %offset_ptr.i.i168.i, align 4
  %eq.i172.i = icmp eq i32 %2982, %offset.i.i169.i
  call void @llvm.assume(i1 %eq.i172.i) #30
  store ptr @_parameterization_Ptri32, ptr %105, align 8
  %2984 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %105)
  %2985 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2976)
  %2986 = sext i32 %2982 to i64
  %2987 = getelementptr ptr, ptr %2976, i64 %2986
  %2988 = getelementptr i8, ptr %2987, i64 120
  %2989 = load ptr, ptr %2988, align 8
  store ptr @i32_typ, ptr %106, align 8
  %2990 = call ptr %2989({ ptr, ptr, ptr, i32 } %2983, ptr nonnull %106)
  %2991 = call { ptr, i160 } %2990({ ptr, ptr, ptr, i32 } %2983, { ptr, ptr, ptr, i32 } %2983, ptr nonnull %105, i32 %2974)
  %.fca.0.extract57.i = extractvalue { ptr, i160 } %2991, 0
  %2992 = icmp ne ptr %.fca.0.extract57.i, @nil_typ
  %2993 = icmp ne ptr %.fca.0.extract57.i, null
  %.not128.i = and i1 %2992, %2993
  br i1 %.not128.i, label %2994, label %HashMap_get_keyK.exit.thread

2994:                                             ; preds = %.critedge.i718
  %.fca.1.extract59.i = extractvalue { ptr, i160 } %2991, 1
  %.sroa.6.8.extract.trunc.i = trunc i160 %.fca.1.extract59.i to i64
  %2995 = inttoptr i64 %.sroa.6.8.extract.trunc.i to ptr
  %.sroa.11.8.extract.shift.i = lshr i160 %.fca.1.extract59.i, 64
  %.sroa.11.8.extract.trunc.i = trunc i160 %.sroa.11.8.extract.shift.i to i64
  %2996 = inttoptr i64 %.sroa.11.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i174.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 8
  %tbl_size_ptr.i.i175.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 16
  %offset_tbl_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 40
  %hash_coef.i.i177.i = load i64, ptr %hash_coef_ptr.i.i174.i, align 4
  %tbl_size.i.i178.i = load i64, ptr %tbl_size_ptr.i.i175.i, align 4
  %offset_tbl.i.i179.i = load ptr, ptr %offset_tbl_ptr.i.i176.i, align 8
  %product.i.i.i180.i = mul i64 %hash_coef.i.i177.i, 4015701072841558310
  %shifted.i.i.i181.i = lshr i64 %product.i.i.i180.i, 32
  %xored.i.i.i182.i = xor i64 %shifted.i.i.i181.i, %product.i.i.i180.i
  %hash.i.i.i183.i = and i64 %xored.i.i.i182.i, %tbl_size.i.i178.i
  %offset_ptr.i.i184.i = getelementptr i32, ptr %offset_tbl.i.i179.i, i64 %hash.i.i.i183.i
  %offset.i.i185.i = load i32, ptr %offset_ptr.i.i184.i, align 4
  %2997 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i, 0
  %2998 = insertvalue { ptr, ptr, ptr, i32 } %2997, ptr %2995, 1
  %2999 = insertvalue { ptr, ptr, ptr, i32 } %2998, ptr %2996, 2
  %3000 = insertvalue { ptr, ptr, ptr, i32 } %2999, i32 %offset.i.i185.i, 3
  %3001 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3002 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3003 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %3004 = sext i32 %offset.i.i185.i to i64
  %3005 = getelementptr ptr, ptr %.fca.0.extract57.i, i64 %3004
  %3006 = getelementptr i8, ptr %3005, i64 64
  %3007 = load ptr, ptr %3006, align 8
  %3008 = call ptr %3007({ ptr, ptr, ptr, i32 } %3000, ptr nonnull %2)
  %3009 = call i32 %3008({ ptr, ptr, ptr, i32 } %3000, { ptr, ptr, ptr, i32 } %3000, ptr nonnull %2)
  %3010 = icmp eq i32 %3009, %2871
  %3011 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3012 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3013 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %3014 = getelementptr i8, ptr %3005, i64 48
  %3015 = load ptr, ptr %3014, align 8
  %3016 = call ptr %3015({ ptr, ptr, ptr, i32 } %3000, ptr nonnull %2)
  %3017 = call { ptr, i160 } %3016({ ptr, ptr, ptr, i32 } %3000, { ptr, ptr, ptr, i32 } %3000, ptr nonnull %2)
  %3018 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3019 = load ptr, ptr %142, align 8
  %3020 = call i1 %3019({ ptr, i160 } %3017, { ptr, i160 } %2868)
  %3021 = and i1 %3010, %3020
  br i1 %3021, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %2994, %.critedge.i718
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %108)
  br label %3034

HashMap_get_keyK.exit:                            ; preds = %2910, %2994
  %.pre-phi313.i = phi i64 [ %2920, %2910 ], [ %3004, %2994 ]
  %.pre-phi312.i = phi { ptr, ptr, ptr, i32 } [ %2916, %2910 ], [ %3000, %2994 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i = phi ptr [ %.fca.0.extract.i717, %2910 ], [ %.fca.0.extract57.i, %2994 ]
  %.reg2mem59.0.sroa.phi120289.i = phi ptr [ %.sroa.1.i, %2910 ], [ %.sroa.2124.i, %2994 ]
  %.reg2mem59.0.sroa.phi117288.i = phi ptr [ %.sroa.0271.i, %2910 ], [ %.sroa.0123.i, %2994 ]
  %.reg2mem57.0.sroa.phi94287.i = phi ptr [ %.sroa.2.i, %2910 ], [ %.sroa.2116.i, %2994 ]
  %.reg2mem57.0.sroa.phi91286.i = phi ptr [ %.sroa.0.i, %2910 ], [ %.sroa.0115.i, %2994 ]
  %3022 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3023 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3024 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i)
  %3025 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i, i64 %.pre-phi313.i
  %3026 = getelementptr i8, ptr %3025, i64 56
  %3027 = load ptr, ptr %3026, align 8
  %3028 = call ptr %3027({ ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %3029 = call { ptr, i160 } %3028({ ptr, ptr, ptr, i32 } %.pre-phi312.i, { ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %.fca.0.extract97.i = extractvalue { ptr, i160 } %3029, 0
  store ptr %.fca.0.extract97.i, ptr %.reg2mem59.0.sroa.phi117288.i, align 8
  %.fca.1.extract99.i = extractvalue { ptr, i160 } %3029, 1
  store i160 %.fca.1.extract99.i, ptr %.reg2mem59.0.sroa.phi120289.i, align 8
  store ptr %.fca.0.extract97.i, ptr %.reg2mem57.0.sroa.phi91286.i, align 8
  store i160 %.fca.1.extract99.i, ptr %.reg2mem57.0.sroa.phi94287.i, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %108)
  %3030 = icmp ne ptr %.fca.0.extract97.i, @nil_typ
  %3031 = icmp ne ptr %.fca.0.extract97.i, null
  %.not49 = and i1 %3030, %3031
  br i1 %.not49, label %3032, label %3034

3032:                                             ; preds = %HashMap_get_keyK.exit
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract99.i to i32
  %3033 = add i32 %286, 1
  %.not = icmp eq i32 %3033, %.sroa.2.8.extract.trunc
  br label %3034

3034:                                             ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit, %3032
  %.reg2mem71.0 = phi i1 [ %.not, %3032 ], [ false, %HashMap_get_keyK.exit ], [ false, %HashMap_get_keyK.exit.thread ]
  %3035 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3036 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3037 = load i32, ptr %1569, align 4
  %3038 = icmp eq i32 %3037, %1549
  %3039 = select i1 %3038, i1 %.reg2mem71.0, i1 false
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit: ; preds = %3034, %._crit_edge240.thread
  %3040 = phi i64 [ %1550, %3034 ], [ %219, %._crit_edge240.thread ]
  %3041 = phi i32 [ %1549, %3034 ], [ 0, %._crit_edge240.thread ]
  %3042 = phi i64 [ %2867, %3034 ], [ %220, %._crit_edge240.thread ]
  %.reg2mem67.0.in = phi i1 [ %3039, %3034 ], [ %225, %._crit_edge240.thread ]
  %result.i111 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nonnull @current_ptr) #29
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i111, align 16
  %result.i112 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3043 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i112, 1
  %3044 = insertvalue { ptr, ptr, ptr, i32 } %3043, ptr undef, 2
  %3045 = insertvalue { ptr, ptr, ptr, i32 } %3044, i32 9, 3
  store ptr %result.i111, ptr %result.i112, align 8
  %3046 = getelementptr i8, ptr %result.i112, i64 8
  store i32 13, ptr %3046, align 4
  %3047 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3048 = getelementptr i8, ptr %result.i112, i64 12
  store i32 14, ptr %3048, align 4
  %3049 = sub i64 %3042, %3040
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %3045, i32 %0, i64 %3049)
  %result.i113 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nonnull @current_ptr) #29
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i113, align 32
  %result.i114 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3050 = getelementptr inbounds i8, ptr %131, i64 8
  %3051 = getelementptr inbounds i8, ptr %131, i64 24
  store ptr @String, ptr %131, align 8
  store ptr %result.i114, ptr %3050, align 8
  store i32 9, ptr %3051, align 8
  %3052 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %131)
  store ptr %result.i113, ptr %result.i114, align 8
  %3053 = getelementptr i8, ptr %result.i114, i64 8
  store i32 18, ptr %3053, align 4
  %3054 = getelementptr i8, ptr %result.i114, i64 12
  store i32 19, ptr %3054, align 4
  %3055 = load i160, ptr %3050, align 8
  %3056 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i = trunc i160 %3055 to i64
  %3057 = inttoptr i64 %.sroa.3.8.extract.trunc.i to ptr
  %3058 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3059 = getelementptr i8, ptr %3057, i64 8
  %3060 = load i32, ptr %3059, align 4
  %3061 = add i32 %3060, 1
  %3062 = sext i32 %3061 to i64
  %result.i.i1397 = call noalias ptr @bump_malloc_inner(i64 noundef %3062, ptr nonnull @current_ptr) #29
  %3063 = load i32, ptr %3059, align 4
  %3064 = icmp sgt i32 %3063, 0
  br i1 %3064, label %.lr.ph.i1398, label %String_c_string_.exit

.lr.ph.i1398:                                     ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %3065 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3066 = load ptr, ptr %3057, align 8
  %3067 = zext nneg i32 %3063 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1397, ptr align 1 %3066, i64 %3067, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %.lr.ph.i1398, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %3068 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3069 = sext i32 %3063 to i64
  %3070 = getelementptr i8, ptr %result.i.i1397, i64 %3069
  store i8 0, ptr %3070, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1397)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i115 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nonnull @current_ptr) #29
  %. = select i1 %.reg2mem67.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.353 = select i1 %.reg2mem67.0.in, ptr %132, ptr %133
  store <4 x i8> %., ptr %result.i115, align 4
  %result.i116 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %.353.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem67.0.in, ptr %132, ptr %133
  %.353.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.353.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  %.353.sroa.sel524.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem67.0.in, ptr %132, ptr %133
  %.353.sroa.sel524.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.353.sroa.sel524.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 24
  store ptr @String, ptr %.353, align 8
  store ptr %result.i116, ptr %.353.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store i32 9, ptr %.353.sroa.sel524.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %3071 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %.353)
  store ptr %result.i115, ptr %result.i116, align 8
  %3072 = getelementptr i8, ptr %result.i116, i64 8
  store i32 4, ptr %3072, align 4
  %3073 = getelementptr i8, ptr %result.i116, i64 12
  store i32 5, ptr %3073, align 4
  %3074 = load i160, ptr %.353.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %3075 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i463 = trunc i160 %3074 to i64
  %3076 = inttoptr i64 %.sroa.3.8.extract.trunc.i463 to ptr
  %3077 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3078 = getelementptr i8, ptr %3076, i64 8
  %3079 = load i32, ptr %3078, align 4
  %3080 = add i32 %3079, 1
  %3081 = sext i32 %3080 to i64
  %result.i.i1415 = call noalias ptr @bump_malloc_inner(i64 noundef %3081, ptr nonnull @current_ptr) #29
  %3082 = load i32, ptr %3078, align 4
  %3083 = icmp sgt i32 %3082, 0
  br i1 %3083, label %.lr.ph.i1416, label %String_c_string_.exit1420

.lr.ph.i1416:                                     ; preds = %String_c_string_.exit
  %3084 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3085 = load ptr, ptr %3076, align 8
  %3086 = zext nneg i32 %3082 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1415, ptr align 1 %3085, i64 %3086, i1 false)
  br label %String_c_string_.exit1420

String_c_string_.exit1420:                        ; preds = %.lr.ph.i1416, %String_c_string_.exit
  %3087 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3088 = sext i32 %3082 to i64
  %3089 = getelementptr i8, ptr %result.i.i1415, i64 %3088
  store i8 0, ptr %3089, align 1
  %puts.i479 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1415)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i155 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nonnull @current_ptr) #29
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %result.i155, align 32
  %result.i156 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3090 = getelementptr inbounds i8, ptr %134, i64 8
  %3091 = getelementptr inbounds i8, ptr %134, i64 24
  store ptr @String, ptr %134, align 8
  store ptr %result.i156, ptr %3090, align 8
  store i32 9, ptr %3091, align 8
  %3092 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %134)
  store ptr %result.i155, ptr %result.i156, align 8
  %3093 = getelementptr i8, ptr %result.i156, i64 8
  store i32 27, ptr %3093, align 4
  %3094 = getelementptr i8, ptr %result.i156, i64 12
  store i32 28, ptr %3094, align 4
  %3095 = load i160, ptr %3090, align 8
  %3096 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i483 = trunc i160 %3095 to i64
  %3097 = inttoptr i64 %.sroa.3.8.extract.trunc.i483 to ptr
  %3098 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3099 = getelementptr i8, ptr %3097, i64 8
  %3100 = load i32, ptr %3099, align 4
  %3101 = add i32 %3100, 1
  %3102 = sext i32 %3101 to i64
  %result.i.i1435 = call noalias ptr @bump_malloc_inner(i64 noundef %3102, ptr nonnull @current_ptr) #29
  %3103 = load i32, ptr %3099, align 4
  %3104 = icmp sgt i32 %3103, 0
  br i1 %3104, label %.lr.ph.i1436, label %String_c_string_.exit1440

.lr.ph.i1436:                                     ; preds = %String_c_string_.exit1420
  %3105 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3106 = load ptr, ptr %3097, align 8
  %3107 = zext nneg i32 %3103 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1435, ptr align 1 %3106, i64 %3107, i1 false)
  br label %String_c_string_.exit1440

String_c_string_.exit1440:                        ; preds = %.lr.ph.i1436, %String_c_string_.exit1420
  %3108 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3109 = sext i32 %3103 to i64
  %3110 = getelementptr i8, ptr %result.i.i1435, i64 %3109
  store i8 0, ptr %3110, align 1
  %puts.i499 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1435)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3111 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %3041)
  %result.i193 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nonnull @current_ptr) #29
  store <1 x i8> <i8 41>, ptr %result.i193, align 1
  %result.i194 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3112 = getelementptr inbounds i8, ptr %135, i64 8
  %3113 = getelementptr inbounds i8, ptr %135, i64 24
  store ptr @String, ptr %135, align 8
  store ptr %result.i194, ptr %3112, align 8
  store i32 9, ptr %3113, align 8
  %3114 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %135)
  store ptr %result.i193, ptr %result.i194, align 8
  %3115 = getelementptr i8, ptr %result.i194, i64 8
  store i32 1, ptr %3115, align 4
  %3116 = getelementptr i8, ptr %result.i194, i64 12
  store i32 2, ptr %3116, align 4
  %3117 = load i160, ptr %3112, align 8
  %3118 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i504 = trunc i160 %3117 to i64
  %3119 = inttoptr i64 %.sroa.3.8.extract.trunc.i504 to ptr
  %3120 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3121 = getelementptr i8, ptr %3119, i64 8
  %3122 = load i32, ptr %3121, align 4
  %3123 = add i32 %3122, 1
  %3124 = sext i32 %3123 to i64
  %result.i.i1455 = call noalias ptr @bump_malloc_inner(i64 noundef %3124, ptr nonnull @current_ptr) #29
  %3125 = load i32, ptr %3121, align 4
  %3126 = icmp sgt i32 %3125, 0
  br i1 %3126, label %.lr.ph.i1456, label %String_c_string_.exit1460

.lr.ph.i1456:                                     ; preds = %String_c_string_.exit1440
  %3127 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3128 = load ptr, ptr %3119, align 8
  %3129 = zext nneg i32 %3125 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1455, ptr align 1 %3128, i64 %3129, i1 false)
  br label %String_c_string_.exit1460

String_c_string_.exit1460:                        ; preds = %.lr.ph.i1456, %String_c_string_.exit1440
  %3130 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3131 = sext i32 %3125 to i64
  %3132 = getelementptr i8, ptr %result.i.i1455, i64 %3131
  store i8 0, ptr %3132, align 1
  %puts.i520 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1455)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %.sroa.0680.i644 = alloca ptr, align 8
  %16 = alloca i64, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [2 x ptr], align 8
  %20 = alloca { ptr, ptr }, align 8
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %.sroa.0.i646 = alloca ptr, align 8
  %24 = alloca i64, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  %30 = alloca { ptr, ptr, ptr, i32 }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [2 x ptr], align 8
  %34 = alloca { ptr, ptr }, align 8
  %35 = alloca i32, align 4
  %36 = alloca i32, align 4
  %37 = alloca i32, align 4
  %.sroa.0680.i = alloca ptr, align 8
  %38 = alloca i64, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [2 x ptr], align 8
  %42 = alloca { ptr, ptr }, align 8
  %43 = alloca i32, align 4
  %44 = alloca i32, align 4
  %45 = alloca i32, align 4
  %.sroa.0.i436 = alloca ptr, align 8
  %46 = alloca i64, align 8
  %47 = alloca { ptr, ptr, ptr, i32 }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.sroa.0271.i = alloca ptr, align 8
  %.sroa.1.i = alloca i160, align 8
  %.sroa.0.i = alloca ptr, align 8
  %.sroa.2.i = alloca i160, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %.sroa.0123.i = alloca ptr, align 8
  %.sroa.2124.i = alloca i160, align 8
  %.sroa.0115.i = alloca ptr, align 8
  %.sroa.2116.i = alloca i160, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca { ptr, ptr, ptr, i32 }, align 8
  %59 = alloca [2 x ptr], align 8
  %60 = alloca { ptr, ptr }, align 8
  %61 = alloca [1 x ptr], align 8
  %62 = alloca { ptr }, align 8
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  %64 = alloca [2 x ptr], align 8
  %65 = alloca { ptr, ptr }, align 8
  %66 = alloca { ptr, ptr, ptr, i32 }, align 8
  %67 = alloca [1 x ptr], align 8
  %68 = alloca { ptr }, align 8
  %oldProtect.i37 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %69 = alloca { ptr, ptr, ptr, i32 }, align 8
  %70 = alloca { ptr, ptr, ptr, i32 }, align 8
  %71 = alloca { ptr, ptr, ptr, i32 }, align 8
  %72 = alloca { ptr, ptr, ptr, i32 }, align 8
  %result.i = tail call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i, align 8
  %73 = getelementptr i8, ptr %result.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %73, align 8
  %74 = getelementptr i8, ptr %result.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %74, align 8
  %75 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i)
  %result.i34 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i35 = call i32 @VirtualProtect(ptr %result.i34, i64 16, i32 64, ptr nonnull %oldProtect.i) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr %result.i34, ptr nonnull @zbizpytnsl, ptr nonnull @i32_hasher)
  %ret.i = call ptr @llvm.adjust.trampoline(ptr readonly %result.i34) #31
  %76 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i34)
  %result.i36 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i37)
  %result.i38 = call i32 @VirtualProtect(ptr %result.i36, i64 16, i32 64, ptr nonnull %oldProtect.i37) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i37)
  call void @llvm.init.trampoline(ptr %result.i36, ptr nonnull @budgehkxgp, ptr nonnull @i32_eq)
  %ret.i39 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i36) #31
  %77 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i36)
  %78 = getelementptr i8, ptr %result.i, i64 96
  store ptr %ret.i, ptr %78, align 8
  %79 = getelementptr i8, ptr %result.i, i64 104
  store ptr %ret.i39, ptr %79, align 8
  %result.i.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %80 = getelementptr i8, ptr %result.i.i, i64 16
  store ptr @_parameterization_Nil, ptr %80, align 8
  %result.i4.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %81 = getelementptr i8, ptr %result.i4.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %81, align 8
  %82 = getelementptr i8, ptr %result.i4.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i)
  store ptr @Entry, ptr %result.i4.i, align 8
  %84 = getelementptr i8, ptr %result.i.i, i64 8
  store ptr %result.i4.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i)
  store ptr @union_typ, ptr %result.i.i, align 8
  %result.i5.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i, ptr %result.i5.i, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i)
  %87 = getelementptr i8, ptr %result.i5.i, i64 16
  store i32 8, ptr %87, align 4
  %88 = getelementptr i8, ptr %result.i5.i, i64 20
  store i32 8, ptr %88, align 4
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %89 = getelementptr i8, ptr %result.i5.i, i64 8
  store ptr %result.i.i.i, ptr %89, align 8
  %90 = getelementptr i8, ptr %result.i, i64 24
  store ptr @Array, ptr %90, align 8
  %91 = getelementptr i8, ptr %result.i, i64 32
  store ptr %result.i5.i, ptr %91, align 8
  %92 = getelementptr i8, ptr %result.i, i64 40
  %93 = getelementptr i8, ptr %result.i, i64 48
  store i32 9, ptr %93, align 4
  %result.i20.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %94 = getelementptr i8, ptr %result.i20.i, i64 16
  store ptr @_parameterization_Nil, ptr %94, align 8
  %result.i21.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %95 = getelementptr i8, ptr %result.i21.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %95, align 8
  %96 = getelementptr i8, ptr %result.i21.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %96, align 8
  %97 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i)
  store ptr @Entry, ptr %result.i21.i, align 8
  %98 = getelementptr i8, ptr %result.i20.i, i64 8
  store ptr %result.i21.i, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i)
  store ptr @union_typ, ptr %result.i20.i, align 8
  %result.i22.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i, ptr %result.i22.i, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i)
  %101 = getelementptr i8, ptr %result.i22.i, i64 16
  store i32 8, ptr %101, align 4
  %102 = getelementptr i8, ptr %result.i22.i, i64 20
  store i32 8, ptr %102, align 4
  %result.i.i97.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %103 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %104 = getelementptr i8, ptr %result.i22.i, i64 8
  store ptr %result.i.i97.i, ptr %104, align 8
  %105 = getelementptr i8, ptr %result.i, i64 56
  store ptr @Array, ptr %105, align 8
  %106 = getelementptr i8, ptr %result.i, i64 64
  store ptr %result.i22.i, ptr %106, align 8
  %107 = getelementptr i8, ptr %result.i, i64 72
  %108 = getelementptr i8, ptr %result.i, i64 80
  store i32 9, ptr %108, align 4
  %109 = getelementptr i8, ptr %result.i, i64 88
  %110 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %111 = getelementptr i8, ptr %result.i, i64 112
  store i32 100, ptr %111, align 4
  %112 = icmp sgt i32 %0, 0
  br i1 %112, label %.lr.ph.preheader, label %._crit_edge.thread

.lr.ph.preheader:                                 ; preds = %1
  %113 = getelementptr inbounds i8, ptr %66, i64 8
  %114 = getelementptr inbounds i8, ptr %66, i64 24
  %115 = getelementptr inbounds i8, ptr %66, i64 16
  %116 = getelementptr inbounds i8, ptr %63, i64 8
  %117 = getelementptr inbounds i8, ptr %63, i64 24
  %118 = getelementptr inbounds i8, ptr %63, i64 16
  %119 = getelementptr inbounds i8, ptr %64, i64 8
  %120 = getelementptr inbounds i8, ptr %65, i64 8
  %121 = getelementptr inbounds i8, ptr %58, i64 8
  %122 = getelementptr inbounds i8, ptr %58, i64 24
  %123 = getelementptr inbounds i8, ptr %58, i64 16
  %124 = getelementptr inbounds i8, ptr %59, i64 8
  %125 = getelementptr inbounds i8, ptr %60, i64 8
  %126 = getelementptr inbounds i8, ptr %52, i64 8
  %127 = getelementptr inbounds i8, ptr %52, i64 24
  %128 = getelementptr inbounds i8, ptr %52, i64 16
  %129 = getelementptr inbounds i8, ptr %53, i64 8
  %130 = getelementptr inbounds i8, ptr %53, i64 24
  %131 = getelementptr inbounds i8, ptr %53, i64 16
  %132 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %133 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr undef, 2
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, i32 9, 3
  %135 = getelementptr inbounds i8, ptr %47, i64 8
  %136 = getelementptr inbounds i8, ptr %47, i64 16
  %137 = getelementptr inbounds i8, ptr %47, i64 24
  %138 = getelementptr inbounds i8, ptr %41, i64 8
  %139 = getelementptr inbounds i8, ptr %42, i64 8
  %140 = getelementptr inbounds i8, ptr %33, i64 8
  %141 = getelementptr inbounds i8, ptr %34, i64 8
  %142 = getelementptr inbounds i8, ptr %29, i64 8
  %143 = getelementptr inbounds i8, ptr %29, i64 24
  %144 = getelementptr inbounds i8, ptr %29, i64 16
  %145 = getelementptr inbounds i8, ptr %30, i64 8
  %146 = getelementptr inbounds i8, ptr %30, i64 24
  %147 = getelementptr inbounds i8, ptr %30, i64 16
  %148 = getelementptr inbounds i8, ptr %19, i64 8
  %149 = getelementptr inbounds i8, ptr %20, i64 8
  %150 = getelementptr inbounds i8, ptr %11, i64 8
  %151 = getelementptr inbounds i8, ptr %12, i64 8
  %152 = getelementptr inbounds i8, ptr %7, i64 8
  %153 = getelementptr inbounds i8, ptr %7, i64 24
  %154 = getelementptr inbounds i8, ptr %7, i64 16
  %155 = getelementptr inbounds i8, ptr %8, i64 8
  %156 = getelementptr inbounds i8, ptr %8, i64 24
  %157 = getelementptr inbounds i8, ptr %8, i64 16
  br label %.lr.ph

._crit_edge.thread:                               ; preds = %1
  %158 = call i64 @clock()
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit81

.lr.ph:                                           ; preds = %.lr.ph.preheader, %HashMap_insert_keyK_valueV.exit
  %.reg2mem92.0134 = phi i64 [ %1420, %HashMap_insert_keyK_valueV.exit ], [ 0, %.lr.ph.preheader ]
  %.reg2mem90.0133 = phi i32 [ %159, %HashMap_insert_keyK_valueV.exit ], [ 0, %.lr.ph.preheader ]
  %159 = add nuw nsw i32 %.reg2mem90.0133, 1
  %160 = zext nneg i32 %159 to i64
  %.sroa.030.0.insert.ext = zext nneg i32 %.reg2mem90.0133 to i160
  %161 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.030.0.insert.ext, 1
  %.sroa.027.0.insert.ext = zext nneg i32 %159 to i160
  %162 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.027.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %59)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %60)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %62)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %63)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %64)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %65)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %66)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %68)
  %163 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %164 = load ptr, ptr %78, align 8
  %165 = call i32 %164({ ptr, i160 } %161)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %166 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %167 = load ptr, ptr %90, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %167, 0
  %169 = load ptr, ptr %91, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %169, 1
  %171 = load ptr, ptr %92, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, ptr %171, 2
  %173 = load i32, ptr %93, align 4
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, i32 %173, 3
  %hash_coef_ptr.i.i10.i = getelementptr i8, ptr %167, i64 8
  %tbl_size_ptr.i.i11.i = getelementptr i8, ptr %167, i64 16
  %offset_tbl_ptr.i.i12.i = getelementptr i8, ptr %167, i64 40
  %hash_coef.i.i13.i = load i64, ptr %hash_coef_ptr.i.i10.i, align 4
  %tbl_size.i.i14.i = load i64, ptr %tbl_size_ptr.i.i11.i, align 4
  %offset_tbl.i.i15.i = load ptr, ptr %offset_tbl_ptr.i.i12.i, align 8
  %product.i.i.i16.i = mul i64 %hash_coef.i.i13.i, -5261542750394134544
  %shifted.i.i.i17.i = lshr i64 %product.i.i.i16.i, 32
  %xored.i.i.i18.i = xor i64 %shifted.i.i.i17.i, %product.i.i.i16.i
  %hash.i.i.i19.i = and i64 %xored.i.i.i18.i, %tbl_size.i.i14.i
  %offset_ptr.i.i20.i = getelementptr i32, ptr %offset_tbl.i.i15.i, i64 %hash.i.i.i19.i
  %offset.i.i21.i = load i32, ptr %offset_ptr.i.i20.i, align 4
  %eq.i.i383 = icmp eq i32 %173, %offset.i.i21.i
  call void @llvm.assume(i1 %eq.i.i383) #30
  %175 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %176 = call ptr @llvm.invariant.start.p0(i64 600, ptr %167)
  %177 = sext i32 %173 to i64
  %178 = getelementptr ptr, ptr %167, i64 %177
  %179 = getelementptr i8, ptr %178, i64 64
  %180 = load ptr, ptr %179, align 8
  %181 = call ptr %180({ ptr, ptr, ptr, i32 } %174, ptr nonnull %2)
  %182 = call i32 %181({ ptr, ptr, ptr, i32 } %174, { ptr, ptr, ptr, i32 } %174, ptr nonnull %2)
  %183 = add i32 %182, -1
  %184 = and i32 %183, %165
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %185 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %186 = load ptr, ptr %90, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %186, 0
  %188 = load ptr, ptr %91, align 8
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, ptr %188, 1
  %190 = load ptr, ptr %92, align 8
  %191 = insertvalue { ptr, ptr, ptr, i32 } %189, ptr %190, 2
  %192 = load i32, ptr %93, align 4
  %193 = insertvalue { ptr, ptr, ptr, i32 } %191, i32 %192, 3
  %hash_coef_ptr.i.i162.i = getelementptr i8, ptr %186, i64 8
  %tbl_size_ptr.i.i163.i = getelementptr i8, ptr %186, i64 16
  %offset_tbl_ptr.i.i164.i = getelementptr i8, ptr %186, i64 40
  %hash_coef.i.i165.i = load i64, ptr %hash_coef_ptr.i.i162.i, align 4
  %tbl_size.i.i166.i = load i64, ptr %tbl_size_ptr.i.i163.i, align 4
  %offset_tbl.i.i167.i = load ptr, ptr %offset_tbl_ptr.i.i164.i, align 8
  %product.i.i.i168.i = mul i64 %hash_coef.i.i165.i, -5261542750394134544
  %shifted.i.i.i169.i = lshr i64 %product.i.i.i168.i, 32
  %xored.i.i.i170.i = xor i64 %shifted.i.i.i169.i, %product.i.i.i168.i
  %hash.i.i.i171.i = and i64 %xored.i.i.i170.i, %tbl_size.i.i166.i
  %offset_ptr.i.i172.i = getelementptr i32, ptr %offset_tbl.i.i167.i, i64 %hash.i.i.i171.i
  %offset.i.i173.i = load i32, ptr %offset_ptr.i.i172.i, align 4
  %eq.i.i = icmp eq i32 %192, %offset.i.i173.i
  call void @llvm.assume(i1 %eq.i.i) #30
  store ptr @_parameterization_Ptri32, ptr %67, align 8
  %194 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %67)
  %195 = call ptr @llvm.invariant.start.p0(i64 600, ptr %186)
  %196 = sext i32 %192 to i64
  %197 = getelementptr ptr, ptr %186, i64 %196
  %198 = getelementptr i8, ptr %197, i64 120
  %199 = load ptr, ptr %198, align 8
  store ptr @i32_typ, ptr %68, align 8
  %200 = call ptr %199({ ptr, ptr, ptr, i32 } %193, ptr nonnull %68)
  %201 = call { ptr, i160 } %200({ ptr, ptr, ptr, i32 } %193, { ptr, ptr, ptr, i32 } %193, ptr nonnull %67, i32 %184)
  %.fca.0.extract.i = extractvalue { ptr, i160 } %201, 0
  %202 = icmp ne ptr %.fca.0.extract.i, @nil_typ
  %203 = icmp ne ptr %.fca.0.extract.i, null
  %.not149.i = and i1 %202, %203
  br i1 %.not149.i, label %204, label %.critedge.i

204:                                              ; preds = %.lr.ph
  %.fca.1.extract.i = extractvalue { ptr, i160 } %201, 1
  %.sroa.4520.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i64
  %205 = inttoptr i64 %.sroa.4520.8.extract.trunc.i to ptr
  %.sroa.7522.8.extract.shift.i = lshr i160 %.fca.1.extract.i, 64
  %.sroa.7522.8.extract.trunc.i = trunc i160 %.sroa.7522.8.extract.shift.i to i64
  %206 = inttoptr i64 %.sroa.7522.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract.i, i64 8
  %tbl_size_ptr.i.i177.i = getelementptr i8, ptr %.fca.0.extract.i, i64 16
  %offset_tbl_ptr.i.i178.i = getelementptr i8, ptr %.fca.0.extract.i, i64 40
  %hash_coef.i.i179.i = load i64, ptr %hash_coef_ptr.i.i176.i, align 4
  %tbl_size.i.i180.i = load i64, ptr %tbl_size_ptr.i.i177.i, align 4
  %offset_tbl.i.i181.i = load ptr, ptr %offset_tbl_ptr.i.i178.i, align 8
  %product.i.i.i182.i = mul i64 %hash_coef.i.i179.i, 4015701072841558310
  %shifted.i.i.i183.i = lshr i64 %product.i.i.i182.i, 32
  %xored.i.i.i184.i = xor i64 %shifted.i.i.i183.i, %product.i.i.i182.i
  %hash.i.i.i185.i = and i64 %xored.i.i.i184.i, %tbl_size.i.i180.i
  %offset_ptr.i.i186.i = getelementptr i32, ptr %offset_tbl.i.i181.i, i64 %hash.i.i.i185.i
  %offset.i.i187.i = load i32, ptr %offset_ptr.i.i186.i, align 4
  %207 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i, 0
  %208 = insertvalue { ptr, ptr, ptr, i32 } %207, ptr %205, 1
  %209 = insertvalue { ptr, ptr, ptr, i32 } %208, ptr %206, 2
  %210 = insertvalue { ptr, ptr, ptr, i32 } %209, i32 %offset.i.i187.i, 3
  %211 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %212 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %213 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i)
  %214 = sext i32 %offset.i.i187.i to i64
  %215 = getelementptr ptr, ptr %.fca.0.extract.i, i64 %214
  %216 = getelementptr i8, ptr %215, i64 64
  %217 = load ptr, ptr %216, align 8
  %218 = call ptr %217({ ptr, ptr, ptr, i32 } %210, ptr nonnull %2)
  %219 = call i32 %218({ ptr, ptr, ptr, i32 } %210, { ptr, ptr, ptr, i32 } %210, ptr nonnull %2)
  %220 = icmp eq i32 %219, %165
  %221 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %222 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %223 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i)
  %224 = getelementptr i8, ptr %215, i64 48
  %225 = load ptr, ptr %224, align 8
  %226 = call ptr %225({ ptr, ptr, ptr, i32 } %210, ptr nonnull %2)
  %227 = call { ptr, i160 } %226({ ptr, ptr, ptr, i32 } %210, { ptr, ptr, ptr, i32 } %210, ptr nonnull %2)
  %228 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %229 = load ptr, ptr %79, align 8
  %230 = call i1 %229({ ptr, i160 } %227, { ptr, i160 } %161)
  %231 = and i1 %220, %230
  br i1 %231, label %232, label %.critedge.i

232:                                              ; preds = %204
  %233 = load ptr, ptr %result.i, align 8
  %234 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %235 = load ptr, ptr %73, align 8
  %236 = load ptr, ptr %233, align 8
  %237 = getelementptr i8, ptr %236, i64 48
  %238 = load ptr, ptr %237, align 8
  %239 = call { i64, i64 } %238(ptr nonnull %233)
  %240 = extractvalue { i64, i64 } %239, 0
  %241 = extractvalue { i64, i64 } %239, 1
  %242 = urem i64 20, %241
  %243 = icmp eq i64 %242, 0
  %244 = sub i64 %241, %242
  %245 = select i1 %243, i64 0, i64 %244
  %246 = add i64 %240, 20
  %247 = add i64 %246, %245
  %248 = load ptr, ptr %235, align 8
  %249 = getelementptr i8, ptr %248, i64 48
  %250 = load ptr, ptr %249, align 8
  %251 = call { i64, i64 } %250(ptr nonnull %235)
  %252 = extractvalue { i64, i64 } %251, 0
  %253 = extractvalue { i64, i64 } %251, 1
  %254 = call i64 @llvm.umax.i64(i64 %241, i64 %253)
  %255 = call i64 @llvm.umax.i64(i64 %254, i64 8)
  %256 = urem i64 %247, %253
  %257 = icmp eq i64 %256, 0
  %258 = sub i64 %253, %256
  %259 = select i1 %257, i64 0, i64 %258
  %260 = add i64 %252, %247
  %261 = add i64 %260, %259
  %262 = urem i64 %261, %255
  %263 = icmp eq i64 %262, 0
  %264 = sub i64 %255, %262
  %265 = select i1 %263, i64 0, i64 %264
  %266 = add i64 %265, %261
  %result.i.i243 = call noalias ptr @bump_malloc_inner(i64 noundef %266, ptr nonnull @current_ptr) #29
  store ptr %233, ptr %result.i.i243, align 8
  %267 = getelementptr i8, ptr %result.i.i243, i64 8
  store ptr %235, ptr %267, align 8
  %268 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i243)
  store ptr @Entry, ptr %58, align 8
  store ptr %result.i.i243, ptr %121, align 8
  store i32 9, ptr %122, align 8
  %269 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %58)
  %270 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %271 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %272 = load ptr, ptr %233, align 8
  %273 = getelementptr i8, ptr %272, i64 48
  %274 = load ptr, ptr %273, align 8
  %275 = call { i64, i64 } %274(ptr nonnull %233)
  %276 = extractvalue { i64, i64 } %275, 1
  %277 = urem i64 20, %276
  %278 = icmp eq i64 %277, 0
  %reass.sub1531 = sub i64 %276, %277
  %279 = add i64 %reass.sub1531, 20
  %280 = select i1 %278, i64 20, i64 %279
  %281 = getelementptr i8, ptr %result.i.i243, i64 %280
  %282 = load ptr, ptr %result.i.i243, align 8
  %283 = load ptr, ptr %282, align 8
  %284 = getelementptr i8, ptr %283, i64 64
  %285 = load ptr, ptr %284, align 8
  call void %285({ ptr, i160 } %161, ptr nonnull %282, ptr %281)
  %286 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %287 = load ptr, ptr %result.i.i243, align 8
  %288 = load ptr, ptr %287, align 8
  %289 = getelementptr i8, ptr %288, i64 48
  %290 = load ptr, ptr %289, align 8
  %291 = call { i64, i64 } %290(ptr nonnull %287)
  %292 = extractvalue { i64, i64 } %291, 0
  %293 = extractvalue { i64, i64 } %291, 1
  %294 = urem i64 20, %293
  %295 = icmp eq i64 %294, 0
  %296 = sub i64 %293, %294
  %297 = select i1 %295, i64 0, i64 %296
  %298 = add i64 %292, 20
  %299 = add i64 %298, %297
  %300 = load ptr, ptr %267, align 8
  %301 = load ptr, ptr %300, align 8
  %302 = getelementptr i8, ptr %301, i64 48
  %303 = load ptr, ptr %302, align 8
  %304 = call { i64, i64 } %303(ptr nonnull %300)
  %305 = extractvalue { i64, i64 } %304, 1
  %306 = urem i64 %299, %305
  %307 = icmp eq i64 %306, 0
  %308 = sub i64 %305, %306
  %309 = select i1 %307, i64 0, i64 %308
  %310 = getelementptr i8, ptr %result.i.i243, i64 %299
  %311 = getelementptr i8, ptr %310, i64 %309
  %312 = load ptr, ptr %267, align 8
  %313 = load ptr, ptr %312, align 8
  %314 = getelementptr i8, ptr %313, i64 64
  %315 = load ptr, ptr %314, align 8
  call void %315({ ptr, i160 } %162, ptr nonnull %312, ptr %311)
  %316 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %317 = getelementptr i8, ptr %result.i.i243, i64 16
  store i32 %165, ptr %317, align 4
  %318 = load ptr, ptr %123, align 8
  %319 = ptrtoint ptr %result.i.i243 to i64
  %320 = ptrtoint ptr %318 to i64
  %.sroa.2127.0.insert.ext.i = zext i64 %320 to i160
  %.sroa.2127.0.insert.shift.i = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i, 64
  %.sroa.0126.0.insert.ext.i = zext i64 %319 to i160
  %.sroa.2127.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.shift.i, %.sroa.0126.0.insert.ext.i
  %.sroa.0126.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.insert.i, 3062541302288446171170371466885913903104
  %321 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i, 1
  %322 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %323 = load ptr, ptr %90, align 8
  %324 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %323, 0
  %325 = load ptr, ptr %91, align 8
  %326 = insertvalue { ptr, ptr, ptr, i32 } %324, ptr %325, 1
  %327 = load ptr, ptr %92, align 8
  %328 = insertvalue { ptr, ptr, ptr, i32 } %326, ptr %327, 2
  %329 = load i32, ptr %93, align 4
  %330 = insertvalue { ptr, ptr, ptr, i32 } %328, i32 %329, 3
  %hash_coef_ptr.i.i204.i = getelementptr i8, ptr %323, i64 8
  %tbl_size_ptr.i.i205.i = getelementptr i8, ptr %323, i64 16
  %offset_tbl_ptr.i.i206.i = getelementptr i8, ptr %323, i64 40
  %hash_coef.i.i207.i = load i64, ptr %hash_coef_ptr.i.i204.i, align 4
  %tbl_size.i.i208.i = load i64, ptr %tbl_size_ptr.i.i205.i, align 4
  %offset_tbl.i.i209.i = load ptr, ptr %offset_tbl_ptr.i.i206.i, align 8
  %product.i.i.i210.i = mul i64 %hash_coef.i.i207.i, -5261542750394134544
  %shifted.i.i.i211.i = lshr i64 %product.i.i.i210.i, 32
  %xored.i.i.i212.i = xor i64 %shifted.i.i.i211.i, %product.i.i.i210.i
  %hash.i.i.i213.i = and i64 %xored.i.i.i212.i, %tbl_size.i.i208.i
  %offset_ptr.i.i214.i = getelementptr i32, ptr %offset_tbl.i.i209.i, i64 %hash.i.i.i213.i
  %offset.i.i215.i = load i32, ptr %offset_ptr.i.i214.i, align 4
  %eq.i218.i = icmp eq i32 %329, %offset.i.i215.i
  call void @llvm.assume(i1 %eq.i218.i) #30
  %331 = load ptr, ptr %result.i, align 8
  %332 = load ptr, ptr %73, align 8
  %result.i219.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %333 = getelementptr i8, ptr %result.i219.i, i64 16
  store ptr %332, ptr %333, align 8
  %334 = getelementptr i8, ptr %result.i219.i, i64 8
  store ptr %331, ptr %334, align 8
  %335 = getelementptr i8, ptr %result.i219.i, i64 24
  store ptr null, ptr %335, align 8
  %336 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i)
  store ptr @Entry, ptr %result.i219.i, align 8
  store ptr @_parameterization_Ptri32, ptr %59, align 8
  store ptr %result.i219.i, ptr %124, align 8
  %337 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %59)
  %338 = call ptr @llvm.invariant.start.p0(i64 600, ptr %323)
  %339 = sext i32 %329 to i64
  %340 = getelementptr ptr, ptr %323, i64 %339
  %341 = getelementptr i8, ptr %340, i64 128
  %342 = load ptr, ptr %341, align 8
  store ptr @i32_typ, ptr %60, align 8
  store ptr @Entry, ptr %125, align 8
  %343 = call ptr %342({ ptr, ptr, ptr, i32 } %330, ptr nonnull %60)
  call void %343({ ptr, ptr, ptr, i32 } %330, { ptr, ptr, ptr, i32 } %330, ptr nonnull %59, i32 %184, { ptr, i160 } %321)
  br label %HashMap_insert_keyK_valueV.exit

.critedge.i:                                      ; preds = %204, %.lr.ph
  %344 = add i32 %165, 2127912214
  %345 = shl i32 %165, 12
  %346 = add i32 %344, %345
  %347 = ashr i32 %346, 19
  %348 = xor i32 %346, %347
  %349 = xor i32 %348, -949894596
  %350 = add i32 %349, 374761393
  %351 = shl i32 %349, 5
  %352 = add i32 %350, %351
  %353 = add i32 %352, -744332180
  %354 = shl i32 %352, 9
  %355 = xor i32 %353, %354
  %356 = add i32 %355, -42973499
  %357 = shl i32 %355, 3
  %358 = add i32 %356, %357
  %359 = ashr i32 %358, 16
  %360 = xor i32 %358, %359
  %361 = xor i32 %360, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %362 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %363 = load ptr, ptr %105, align 8
  %364 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %363, 0
  %365 = load ptr, ptr %106, align 8
  %366 = insertvalue { ptr, ptr, ptr, i32 } %364, ptr %365, 1
  %367 = load ptr, ptr %107, align 8
  %368 = insertvalue { ptr, ptr, ptr, i32 } %366, ptr %367, 2
  %369 = load i32, ptr %108, align 4
  %370 = insertvalue { ptr, ptr, ptr, i32 } %368, i32 %369, 3
  %hash_coef_ptr.i.i10.i401 = getelementptr i8, ptr %363, i64 8
  %tbl_size_ptr.i.i11.i402 = getelementptr i8, ptr %363, i64 16
  %offset_tbl_ptr.i.i12.i403 = getelementptr i8, ptr %363, i64 40
  %hash_coef.i.i13.i404 = load i64, ptr %hash_coef_ptr.i.i10.i401, align 4
  %tbl_size.i.i14.i405 = load i64, ptr %tbl_size_ptr.i.i11.i402, align 4
  %offset_tbl.i.i15.i406 = load ptr, ptr %offset_tbl_ptr.i.i12.i403, align 8
  %product.i.i.i16.i407 = mul i64 %hash_coef.i.i13.i404, -5261542750394134544
  %shifted.i.i.i17.i408 = lshr i64 %product.i.i.i16.i407, 32
  %xored.i.i.i18.i409 = xor i64 %shifted.i.i.i17.i408, %product.i.i.i16.i407
  %hash.i.i.i19.i410 = and i64 %xored.i.i.i18.i409, %tbl_size.i.i14.i405
  %offset_ptr.i.i20.i411 = getelementptr i32, ptr %offset_tbl.i.i15.i406, i64 %hash.i.i.i19.i410
  %offset.i.i21.i412 = load i32, ptr %offset_ptr.i.i20.i411, align 4
  %eq.i.i413 = icmp eq i32 %369, %offset.i.i21.i412
  call void @llvm.assume(i1 %eq.i.i413) #30
  %371 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %372 = call ptr @llvm.invariant.start.p0(i64 600, ptr %363)
  %373 = sext i32 %369 to i64
  %374 = getelementptr ptr, ptr %363, i64 %373
  %375 = getelementptr i8, ptr %374, i64 64
  %376 = load ptr, ptr %375, align 8
  %377 = call ptr %376({ ptr, ptr, ptr, i32 } %370, ptr nonnull %2)
  %378 = call i32 %377({ ptr, ptr, ptr, i32 } %370, { ptr, ptr, ptr, i32 } %370, ptr nonnull %2)
  %379 = add i32 %378, -1
  %380 = and i32 %379, %361
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %381 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %382 = load ptr, ptr %105, align 8
  %383 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %382, 0
  %384 = load ptr, ptr %106, align 8
  %385 = insertvalue { ptr, ptr, ptr, i32 } %383, ptr %384, 1
  %386 = load ptr, ptr %107, align 8
  %387 = insertvalue { ptr, ptr, ptr, i32 } %385, ptr %386, 2
  %388 = load i32, ptr %108, align 4
  %389 = insertvalue { ptr, ptr, ptr, i32 } %387, i32 %388, 3
  %hash_coef_ptr.i.i221.i = getelementptr i8, ptr %382, i64 8
  %tbl_size_ptr.i.i222.i = getelementptr i8, ptr %382, i64 16
  %offset_tbl_ptr.i.i223.i = getelementptr i8, ptr %382, i64 40
  %hash_coef.i.i224.i = load i64, ptr %hash_coef_ptr.i.i221.i, align 4
  %tbl_size.i.i225.i = load i64, ptr %tbl_size_ptr.i.i222.i, align 4
  %offset_tbl.i.i226.i = load ptr, ptr %offset_tbl_ptr.i.i223.i, align 8
  %product.i.i.i227.i = mul i64 %hash_coef.i.i224.i, -5261542750394134544
  %shifted.i.i.i228.i = lshr i64 %product.i.i.i227.i, 32
  %xored.i.i.i229.i = xor i64 %shifted.i.i.i228.i, %product.i.i.i227.i
  %hash.i.i.i230.i = and i64 %xored.i.i.i229.i, %tbl_size.i.i225.i
  %offset_ptr.i.i231.i = getelementptr i32, ptr %offset_tbl.i.i226.i, i64 %hash.i.i.i230.i
  %offset.i.i232.i = load i32, ptr %offset_ptr.i.i231.i, align 4
  %eq.i235.i = icmp eq i32 %388, %offset.i.i232.i
  call void @llvm.assume(i1 %eq.i235.i) #30
  store ptr @_parameterization_Ptri32, ptr %61, align 8
  %390 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %61)
  %391 = call ptr @llvm.invariant.start.p0(i64 600, ptr %382)
  %392 = sext i32 %388 to i64
  %393 = getelementptr ptr, ptr %382, i64 %392
  %394 = getelementptr i8, ptr %393, i64 120
  %395 = load ptr, ptr %394, align 8
  store ptr @i32_typ, ptr %62, align 8
  %396 = call ptr %395({ ptr, ptr, ptr, i32 } %389, ptr nonnull %62)
  %397 = call { ptr, i160 } %396({ ptr, ptr, ptr, i32 } %389, { ptr, ptr, ptr, i32 } %389, ptr nonnull %61, i32 %380)
  %.fca.0.extract102.i = extractvalue { ptr, i160 } %397, 0
  %398 = icmp ne ptr %.fca.0.extract102.i, @nil_typ
  %399 = icmp ne ptr %.fca.0.extract102.i, null
  %.not151.i = and i1 %398, %399
  br i1 %.not151.i, label %400, label %.critedge158.i

400:                                              ; preds = %.critedge.i
  %.fca.1.extract104.i = extractvalue { ptr, i160 } %397, 1
  %.sroa.4.8.extract.trunc.i = trunc i160 %.fca.1.extract104.i to i64
  %401 = inttoptr i64 %.sroa.4.8.extract.trunc.i to ptr
  %.sroa.7508.8.extract.shift.i = lshr i160 %.fca.1.extract104.i, 64
  %.sroa.7508.8.extract.trunc.i = trunc i160 %.sroa.7508.8.extract.shift.i to i64
  %402 = inttoptr i64 %.sroa.7508.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i237.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 8
  %tbl_size_ptr.i.i238.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 16
  %offset_tbl_ptr.i.i239.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 40
  %hash_coef.i.i240.i = load i64, ptr %hash_coef_ptr.i.i237.i, align 4
  %tbl_size.i.i241.i = load i64, ptr %tbl_size_ptr.i.i238.i, align 4
  %offset_tbl.i.i242.i = load ptr, ptr %offset_tbl_ptr.i.i239.i, align 8
  %product.i.i.i243.i = mul i64 %hash_coef.i.i240.i, 4015701072841558310
  %shifted.i.i.i244.i = lshr i64 %product.i.i.i243.i, 32
  %xored.i.i.i245.i = xor i64 %shifted.i.i.i244.i, %product.i.i.i243.i
  %hash.i.i.i246.i = and i64 %xored.i.i.i245.i, %tbl_size.i.i241.i
  %offset_ptr.i.i247.i = getelementptr i32, ptr %offset_tbl.i.i242.i, i64 %hash.i.i.i246.i
  %offset.i.i248.i = load i32, ptr %offset_ptr.i.i247.i, align 4
  %403 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i, 0
  %404 = insertvalue { ptr, ptr, ptr, i32 } %403, ptr %401, 1
  %405 = insertvalue { ptr, ptr, ptr, i32 } %404, ptr %402, 2
  %406 = insertvalue { ptr, ptr, ptr, i32 } %405, i32 %offset.i.i248.i, 3
  %407 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %408 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %409 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %410 = sext i32 %offset.i.i248.i to i64
  %411 = getelementptr ptr, ptr %.fca.0.extract102.i, i64 %410
  %412 = getelementptr i8, ptr %411, i64 64
  %413 = load ptr, ptr %412, align 8
  %414 = call ptr %413({ ptr, ptr, ptr, i32 } %406, ptr nonnull %2)
  %415 = call i32 %414({ ptr, ptr, ptr, i32 } %406, { ptr, ptr, ptr, i32 } %406, ptr nonnull %2)
  %416 = icmp eq i32 %415, %165
  %417 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %418 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %419 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %420 = getelementptr i8, ptr %411, i64 48
  %421 = load ptr, ptr %420, align 8
  %422 = call ptr %421({ ptr, ptr, ptr, i32 } %406, ptr nonnull %2)
  %423 = call { ptr, i160 } %422({ ptr, ptr, ptr, i32 } %406, { ptr, ptr, ptr, i32 } %406, ptr nonnull %2)
  %424 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %425 = load ptr, ptr %79, align 8
  %426 = call i1 %425({ ptr, i160 } %423, { ptr, i160 } %161)
  %427 = and i1 %416, %426
  br i1 %427, label %428, label %.critedge158.i

428:                                              ; preds = %400
  %429 = load ptr, ptr %result.i, align 8
  %430 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %431 = load ptr, ptr %73, align 8
  %432 = load ptr, ptr %429, align 8
  %433 = getelementptr i8, ptr %432, i64 48
  %434 = load ptr, ptr %433, align 8
  %435 = call { i64, i64 } %434(ptr nonnull %429)
  %436 = extractvalue { i64, i64 } %435, 0
  %437 = extractvalue { i64, i64 } %435, 1
  %438 = urem i64 20, %437
  %439 = icmp eq i64 %438, 0
  %440 = sub i64 %437, %438
  %441 = select i1 %439, i64 0, i64 %440
  %442 = add i64 %436, 20
  %443 = add i64 %442, %441
  %444 = load ptr, ptr %431, align 8
  %445 = getelementptr i8, ptr %444, i64 48
  %446 = load ptr, ptr %445, align 8
  %447 = call { i64, i64 } %446(ptr nonnull %431)
  %448 = extractvalue { i64, i64 } %447, 0
  %449 = extractvalue { i64, i64 } %447, 1
  %450 = call i64 @llvm.umax.i64(i64 %437, i64 %449)
  %451 = call i64 @llvm.umax.i64(i64 %450, i64 8)
  %452 = urem i64 %443, %449
  %453 = icmp eq i64 %452, 0
  %454 = sub i64 %449, %452
  %455 = select i1 %453, i64 0, i64 %454
  %456 = add i64 %448, %443
  %457 = add i64 %456, %455
  %458 = urem i64 %457, %451
  %459 = icmp eq i64 %458, 0
  %460 = sub i64 %451, %458
  %461 = select i1 %459, i64 0, i64 %460
  %462 = add i64 %461, %457
  %result.i250.i = call noalias ptr @bump_malloc_inner(i64 noundef %462, ptr nonnull @current_ptr) #29
  store ptr %429, ptr %result.i250.i, align 8
  %463 = getelementptr i8, ptr %result.i250.i, i64 8
  store ptr %431, ptr %463, align 8
  %464 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i)
  store ptr @Entry, ptr %63, align 8
  store ptr %result.i250.i, ptr %116, align 8
  store i32 9, ptr %117, align 8
  %465 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %63)
  %466 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %467 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %468 = load ptr, ptr %429, align 8
  %469 = getelementptr i8, ptr %468, i64 48
  %470 = load ptr, ptr %469, align 8
  %471 = call { i64, i64 } %470(ptr nonnull %429)
  %472 = extractvalue { i64, i64 } %471, 1
  %473 = urem i64 20, %472
  %474 = icmp eq i64 %473, 0
  %reass.sub = sub i64 %472, %473
  %475 = add i64 %reass.sub, 20
  %476 = select i1 %474, i64 20, i64 %475
  %477 = getelementptr i8, ptr %result.i250.i, i64 %476
  %478 = load ptr, ptr %result.i250.i, align 8
  %479 = load ptr, ptr %478, align 8
  %480 = getelementptr i8, ptr %479, i64 64
  %481 = load ptr, ptr %480, align 8
  call void %481({ ptr, i160 } %161, ptr nonnull %478, ptr %477)
  %482 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %483 = load ptr, ptr %result.i250.i, align 8
  %484 = load ptr, ptr %483, align 8
  %485 = getelementptr i8, ptr %484, i64 48
  %486 = load ptr, ptr %485, align 8
  %487 = call { i64, i64 } %486(ptr nonnull %483)
  %488 = extractvalue { i64, i64 } %487, 0
  %489 = extractvalue { i64, i64 } %487, 1
  %490 = urem i64 20, %489
  %491 = icmp eq i64 %490, 0
  %492 = sub i64 %489, %490
  %493 = select i1 %491, i64 0, i64 %492
  %494 = add i64 %488, 20
  %495 = add i64 %494, %493
  %496 = load ptr, ptr %463, align 8
  %497 = load ptr, ptr %496, align 8
  %498 = getelementptr i8, ptr %497, i64 48
  %499 = load ptr, ptr %498, align 8
  %500 = call { i64, i64 } %499(ptr nonnull %496)
  %501 = extractvalue { i64, i64 } %500, 1
  %502 = urem i64 %495, %501
  %503 = icmp eq i64 %502, 0
  %504 = sub i64 %501, %502
  %505 = select i1 %503, i64 0, i64 %504
  %506 = getelementptr i8, ptr %result.i250.i, i64 %495
  %507 = getelementptr i8, ptr %506, i64 %505
  %508 = load ptr, ptr %463, align 8
  %509 = load ptr, ptr %508, align 8
  %510 = getelementptr i8, ptr %509, i64 64
  %511 = load ptr, ptr %510, align 8
  call void %511({ ptr, i160 } %162, ptr nonnull %508, ptr %507)
  %512 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %513 = getelementptr i8, ptr %result.i250.i, i64 16
  store i32 %165, ptr %513, align 4
  %514 = load ptr, ptr %118, align 8
  %515 = ptrtoint ptr %result.i250.i to i64
  %516 = ptrtoint ptr %514 to i64
  %.sroa.282.0.insert.ext.i = zext i64 %516 to i160
  %.sroa.282.0.insert.shift.i = shl nuw nsw i160 %.sroa.282.0.insert.ext.i, 64
  %.sroa.081.0.insert.ext.i = zext i64 %515 to i160
  %.sroa.282.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.shift.i, %.sroa.081.0.insert.ext.i
  %.sroa.081.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.insert.i, 3062541302288446171170371466885913903104
  %517 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i, 1
  %518 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %519 = load ptr, ptr %105, align 8
  %520 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %519, 0
  %521 = load ptr, ptr %106, align 8
  %522 = insertvalue { ptr, ptr, ptr, i32 } %520, ptr %521, 1
  %523 = load ptr, ptr %107, align 8
  %524 = insertvalue { ptr, ptr, ptr, i32 } %522, ptr %523, 2
  %525 = load i32, ptr %108, align 4
  %526 = insertvalue { ptr, ptr, ptr, i32 } %524, i32 %525, 3
  %hash_coef_ptr.i.i266.i = getelementptr i8, ptr %519, i64 8
  %tbl_size_ptr.i.i267.i = getelementptr i8, ptr %519, i64 16
  %offset_tbl_ptr.i.i268.i = getelementptr i8, ptr %519, i64 40
  %hash_coef.i.i269.i = load i64, ptr %hash_coef_ptr.i.i266.i, align 4
  %tbl_size.i.i270.i = load i64, ptr %tbl_size_ptr.i.i267.i, align 4
  %offset_tbl.i.i271.i = load ptr, ptr %offset_tbl_ptr.i.i268.i, align 8
  %product.i.i.i272.i = mul i64 %hash_coef.i.i269.i, -5261542750394134544
  %shifted.i.i.i273.i = lshr i64 %product.i.i.i272.i, 32
  %xored.i.i.i274.i = xor i64 %shifted.i.i.i273.i, %product.i.i.i272.i
  %hash.i.i.i275.i = and i64 %xored.i.i.i274.i, %tbl_size.i.i270.i
  %offset_ptr.i.i276.i = getelementptr i32, ptr %offset_tbl.i.i271.i, i64 %hash.i.i.i275.i
  %offset.i.i277.i = load i32, ptr %offset_ptr.i.i276.i, align 4
  %eq.i280.i = icmp eq i32 %525, %offset.i.i277.i
  call void @llvm.assume(i1 %eq.i280.i) #30
  %527 = load ptr, ptr %result.i, align 8
  %528 = load ptr, ptr %73, align 8
  %result.i281.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %529 = getelementptr i8, ptr %result.i281.i, i64 16
  store ptr %528, ptr %529, align 8
  %530 = getelementptr i8, ptr %result.i281.i, i64 8
  store ptr %527, ptr %530, align 8
  %531 = getelementptr i8, ptr %result.i281.i, i64 24
  store ptr null, ptr %531, align 8
  %532 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i)
  store ptr @Entry, ptr %result.i281.i, align 8
  store ptr @_parameterization_Ptri32, ptr %64, align 8
  store ptr %result.i281.i, ptr %119, align 8
  %533 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %64)
  %534 = call ptr @llvm.invariant.start.p0(i64 600, ptr %519)
  %535 = sext i32 %525 to i64
  %536 = getelementptr ptr, ptr %519, i64 %535
  %537 = getelementptr i8, ptr %536, i64 128
  %538 = load ptr, ptr %537, align 8
  store ptr @i32_typ, ptr %65, align 8
  store ptr @Entry, ptr %120, align 8
  %539 = call ptr %538({ ptr, ptr, ptr, i32 } %526, ptr nonnull %65)
  call void %539({ ptr, ptr, ptr, i32 } %526, { ptr, ptr, ptr, i32 } %526, ptr nonnull %64, i32 %380, { ptr, i160 } %517)
  br label %HashMap_insert_keyK_valueV.exit

.critedge158.i:                                   ; preds = %400, %.critedge.i
  %540 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %541 = load ptr, ptr %90, align 8
  %542 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %541, 0
  %543 = load ptr, ptr %91, align 8
  %544 = insertvalue { ptr, ptr, ptr, i32 } %542, ptr %543, 1
  %545 = load ptr, ptr %92, align 8
  %546 = insertvalue { ptr, ptr, ptr, i32 } %544, ptr %545, 2
  %547 = load i32, ptr %93, align 4
  %548 = insertvalue { ptr, ptr, ptr, i32 } %546, i32 %547, 3
  %hash_coef_ptr.i.i283.i = getelementptr i8, ptr %541, i64 8
  %tbl_size_ptr.i.i284.i = getelementptr i8, ptr %541, i64 16
  %offset_tbl_ptr.i.i285.i = getelementptr i8, ptr %541, i64 40
  %hash_coef.i.i286.i = load i64, ptr %hash_coef_ptr.i.i283.i, align 4
  %tbl_size.i.i287.i = load i64, ptr %tbl_size_ptr.i.i284.i, align 4
  %offset_tbl.i.i288.i = load ptr, ptr %offset_tbl_ptr.i.i285.i, align 8
  %product.i.i.i289.i = mul i64 %hash_coef.i.i286.i, -5261542750394134544
  %shifted.i.i.i290.i = lshr i64 %product.i.i.i289.i, 32
  %xored.i.i.i291.i = xor i64 %shifted.i.i.i290.i, %product.i.i.i289.i
  %hash.i.i.i292.i = and i64 %xored.i.i.i291.i, %tbl_size.i.i287.i
  %offset_ptr.i.i293.i = getelementptr i32, ptr %offset_tbl.i.i288.i, i64 %hash.i.i.i292.i
  %offset.i.i294.i = load i32, ptr %offset_ptr.i.i293.i, align 4
  %eq.i297.i = icmp eq i32 %547, %offset.i.i294.i
  call void @llvm.assume(i1 %eq.i297.i) #30
  %549 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %550 = call ptr @llvm.invariant.start.p0(i64 600, ptr %541)
  %551 = sext i32 %547 to i64
  %552 = getelementptr ptr, ptr %541, i64 %551
  %553 = getelementptr i8, ptr %552, i64 64
  %554 = load ptr, ptr %553, align 8
  %555 = call ptr %554({ ptr, ptr, ptr, i32 } %548, ptr nonnull %2)
  %556 = call i32 %555({ ptr, ptr, ptr, i32 } %548, { ptr, ptr, ptr, i32 } %548, ptr nonnull %2)
  %557 = load i32, ptr %109, align 4
  %.not.i = icmp slt i32 %557, %556
  br i1 %.not.i, label %._crit_edge.i, label %558

558:                                              ; preds = %.critedge158.i
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %53)
  %559 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %560 = load ptr, ptr %90, align 8
  %561 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %560, 0
  %562 = load ptr, ptr %91, align 8
  %563 = insertvalue { ptr, ptr, ptr, i32 } %561, ptr %562, 1
  %564 = load ptr, ptr %92, align 8
  %565 = insertvalue { ptr, ptr, ptr, i32 } %563, ptr %564, 2
  %566 = load i32, ptr %93, align 4
  %567 = insertvalue { ptr, ptr, ptr, i32 } %565, i32 %566, 3
  %hash_coef_ptr.i.i64.i = getelementptr i8, ptr %560, i64 8
  %tbl_size_ptr.i.i65.i = getelementptr i8, ptr %560, i64 16
  %offset_tbl_ptr.i.i66.i = getelementptr i8, ptr %560, i64 40
  %hash_coef.i.i67.i = load i64, ptr %hash_coef_ptr.i.i64.i, align 4
  %tbl_size.i.i68.i = load i64, ptr %tbl_size_ptr.i.i65.i, align 4
  %offset_tbl.i.i69.i = load ptr, ptr %offset_tbl_ptr.i.i66.i, align 8
  %product.i.i.i70.i = mul i64 %hash_coef.i.i67.i, -5261542750394134544
  %shifted.i.i.i71.i = lshr i64 %product.i.i.i70.i, 32
  %xored.i.i.i72.i = xor i64 %shifted.i.i.i71.i, %product.i.i.i70.i
  %hash.i.i.i73.i = and i64 %xored.i.i.i72.i, %tbl_size.i.i68.i
  %offset_ptr.i.i74.i = getelementptr i32, ptr %offset_tbl.i.i69.i, i64 %hash.i.i.i73.i
  %offset.i.i75.i = load i32, ptr %offset_ptr.i.i74.i, align 4
  %eq.i.i427 = icmp eq i32 %566, %offset.i.i75.i
  call void @llvm.assume(i1 %eq.i.i427) #30
  %568 = load ptr, ptr %105, align 8
  %569 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %568, 0
  %570 = load ptr, ptr %106, align 8
  %571 = insertvalue { ptr, ptr, ptr, i32 } %569, ptr %570, 1
  %572 = load ptr, ptr %107, align 8
  %573 = insertvalue { ptr, ptr, ptr, i32 } %571, ptr %572, 2
  %574 = load i32, ptr %108, align 4
  %575 = insertvalue { ptr, ptr, ptr, i32 } %573, i32 %574, 3
  %hash_coef_ptr.i.i92.i = getelementptr i8, ptr %568, i64 8
  %tbl_size_ptr.i.i93.i = getelementptr i8, ptr %568, i64 16
  %offset_tbl_ptr.i.i94.i = getelementptr i8, ptr %568, i64 40
  %hash_coef.i.i95.i = load i64, ptr %hash_coef_ptr.i.i92.i, align 4
  %tbl_size.i.i96.i = load i64, ptr %tbl_size_ptr.i.i93.i, align 4
  %offset_tbl.i.i97.i = load ptr, ptr %offset_tbl_ptr.i.i94.i, align 8
  %product.i.i.i98.i = mul i64 %hash_coef.i.i95.i, -5261542750394134544
  %shifted.i.i.i99.i = lshr i64 %product.i.i.i98.i, 32
  %xored.i.i.i100.i = xor i64 %shifted.i.i.i99.i, %product.i.i.i98.i
  %hash.i.i.i101.i = and i64 %xored.i.i.i100.i, %tbl_size.i.i96.i
  %offset_ptr.i.i102.i = getelementptr i32, ptr %offset_tbl.i.i97.i, i64 %hash.i.i.i101.i
  %offset.i.i103.i = load i32, ptr %offset_ptr.i.i102.i, align 4
  %eq.i106.i = icmp eq i32 %574, %offset.i.i103.i
  call void @llvm.assume(i1 %eq.i106.i) #30
  %576 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %577 = call ptr @llvm.invariant.start.p0(i64 600, ptr %560)
  %578 = sext i32 %566 to i64
  %579 = getelementptr ptr, ptr %560, i64 %578
  %580 = getelementptr i8, ptr %579, i64 64
  %581 = load ptr, ptr %580, align 8
  %582 = call ptr %581({ ptr, ptr, ptr, i32 } %567, ptr nonnull %2)
  %583 = call i32 %582({ ptr, ptr, ptr, i32 } %567, { ptr, ptr, ptr, i32 } %567, ptr nonnull %2)
  %584 = shl i32 %583, 1
  %585 = load i32, ptr %109, align 4
  %586 = load ptr, ptr %result.i, align 8
  %587 = load ptr, ptr %73, align 8
  %588 = sext i32 %585 to i64
  %589 = shl nsw i64 %588, 5
  %result.i.i.i433 = call noalias ptr @bump_malloc_inner(i64 noundef %589, ptr nonnull @current_ptr) #29
  %590 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %591 = icmp sgt i32 %583, 0
  br i1 %591, label %.lr.ph434.i, label %._crit_edge395.i

.lr.ph434.i:                                      ; preds = %558
  %invariant.gep.i = getelementptr i8, ptr %560, i64 120
  %592 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i = getelementptr ptr, ptr %invariant.gep.i, i64 %578
  br label %593

593:                                              ; preds = %615, %.lr.ph434.i
  %.reg2mem105.0432.i = phi i32 [ 0, %.lr.ph434.i ], [ %.reg2mem101.0.i, %615 ]
  %.reg2mem103.0431.i = phi i32 [ 0, %.lr.ph434.i ], [ %616, %615 ]
  store ptr @_parameterization_Ptri32, ptr %48, align 8
  %594 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %48)
  %595 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %560)
  %596 = load ptr, ptr %gep.i, align 8
  store ptr @i32_typ, ptr %49, align 8
  %597 = call ptr %596({ ptr, ptr, ptr, i32 } %567, ptr nonnull %49)
  %598 = call { ptr, i160 } %597({ ptr, ptr, ptr, i32 } %567, { ptr, ptr, ptr, i32 } %567, ptr nonnull %48, i32 %.reg2mem103.0431.i)
  %.fca.0.extract52.i = extractvalue { ptr, i160 } %598, 0
  %599 = icmp ne ptr %.fca.0.extract52.i, @nil_typ
  %600 = icmp ne ptr %.fca.0.extract52.i, null
  %.not60.i = and i1 %599, %600
  br i1 %.not60.i, label %601, label %615

601:                                              ; preds = %593
  %hash_coef_ptr.i.i137.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 8
  %tbl_size_ptr.i.i138.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 16
  %offset_tbl_ptr.i.i139.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 40
  %hash_coef.i.i140.i = load i64, ptr %hash_coef_ptr.i.i137.i, align 4
  %tbl_size.i.i141.i = load i64, ptr %tbl_size_ptr.i.i138.i, align 4
  %offset_tbl.i.i142.i = load ptr, ptr %offset_tbl_ptr.i.i139.i, align 8
  %product.i.i.i143.i = mul i64 %hash_coef.i.i140.i, 4015701072841558310
  %shifted.i.i.i144.i = lshr i64 %product.i.i.i143.i, 32
  %xored.i.i.i145.i = xor i64 %shifted.i.i.i144.i, %product.i.i.i143.i
  %hash.i.i.i146.i = and i64 %xored.i.i.i145.i, %tbl_size.i.i141.i
  %offset_ptr.i.i147.i = getelementptr i32, ptr %offset_tbl.i.i142.i, i64 %hash.i.i.i146.i
  %offset.i.i148.i = load i32, ptr %offset_ptr.i.i147.i, align 4
  %602 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %603 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %604 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %605 = icmp slt i32 %.reg2mem105.0432.i, %585
  br i1 %605, label %606, label %._crit_edge.i435

606:                                              ; preds = %601
  %.fca.1.extract54.i = extractvalue { ptr, i160 } %598, 1
  %.sroa.351.0.insert.ext.i = zext i32 %offset.i.i148.i to i160
  %.sroa.351.0.insert.shift.i = shl nuw i160 %.sroa.351.0.insert.ext.i, 128
  %607 = and i160 %.fca.1.extract54.i, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i = or disjoint i160 %.sroa.351.0.insert.shift.i, %607
  %608 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %609 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %610 = sext i32 %.reg2mem105.0432.i to i64
  %611 = shl nsw i64 %610, 5
  %612 = getelementptr i8, ptr %result.i.i.i433, i64 %611
  store ptr %.fca.0.extract52.i, ptr %612, align 8
  %613 = getelementptr i8, ptr %612, i64 8
  store i160 %.sroa.049.0.insert.insert.i, ptr %613, align 4
  br label %._crit_edge.i435

._crit_edge.i435:                                 ; preds = %606, %601
  %614 = add i32 %.reg2mem105.0432.i, 1
  br label %615

615:                                              ; preds = %._crit_edge.i435, %593
  %.reg2mem101.0.i = phi i32 [ %614, %._crit_edge.i435 ], [ %.reg2mem105.0432.i, %593 ]
  %616 = add nuw nsw i32 %.reg2mem103.0431.i, 1
  %617 = icmp slt i32 %616, %583
  br i1 %617, label %593, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %615
  %invariant.gep396.i = getelementptr i8, ptr %568, i64 120
  %618 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %619 = sext i32 %574 to i64
  %gep397.i = getelementptr ptr, ptr %invariant.gep396.i, i64 %619
  br label %620

620:                                              ; preds = %642, %.lr.ph.i
  %.reg2mem91.0394.i = phi i32 [ %.reg2mem101.0.i, %.lr.ph.i ], [ %.reg2mem87.0.i, %642 ]
  %.reg2mem89.0393.i = phi i32 [ 0, %.lr.ph.i ], [ %643, %642 ]
  store ptr @_parameterization_Ptri32, ptr %50, align 8
  %621 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %50)
  %622 = call ptr @llvm.invariant.start.p0(i64 600, ptr %568)
  %623 = load ptr, ptr %gep397.i, align 8
  store ptr @i32_typ, ptr %51, align 8
  %624 = call ptr %623({ ptr, ptr, ptr, i32 } %575, ptr nonnull %51)
  %625 = call { ptr, i160 } %624({ ptr, ptr, ptr, i32 } %575, { ptr, ptr, ptr, i32 } %575, ptr nonnull %50, i32 %.reg2mem89.0393.i)
  %.fca.0.extract42.i = extractvalue { ptr, i160 } %625, 0
  %626 = icmp ne ptr %.fca.0.extract42.i, @nil_typ
  %627 = icmp ne ptr %.fca.0.extract42.i, null
  %.not62.i = and i1 %626, %627
  br i1 %.not62.i, label %628, label %642

628:                                              ; preds = %620
  %hash_coef_ptr.i.i152.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 8
  %tbl_size_ptr.i.i153.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 16
  %offset_tbl_ptr.i.i154.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 40
  %hash_coef.i.i155.i = load i64, ptr %hash_coef_ptr.i.i152.i, align 4
  %tbl_size.i.i156.i = load i64, ptr %tbl_size_ptr.i.i153.i, align 4
  %offset_tbl.i.i157.i = load ptr, ptr %offset_tbl_ptr.i.i154.i, align 8
  %product.i.i.i158.i = mul i64 %hash_coef.i.i155.i, 4015701072841558310
  %shifted.i.i.i159.i = lshr i64 %product.i.i.i158.i, 32
  %xored.i.i.i160.i = xor i64 %shifted.i.i.i159.i, %product.i.i.i158.i
  %hash.i.i.i161.i = and i64 %xored.i.i.i160.i, %tbl_size.i.i156.i
  %offset_ptr.i.i162.i = getelementptr i32, ptr %offset_tbl.i.i157.i, i64 %hash.i.i.i161.i
  %offset.i.i163.i = load i32, ptr %offset_ptr.i.i162.i, align 4
  %629 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %630 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %631 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %632 = icmp slt i32 %.reg2mem91.0394.i, %585
  br i1 %632, label %633, label %._crit_edge1.i434

633:                                              ; preds = %628
  %.fca.1.extract44.i = extractvalue { ptr, i160 } %625, 1
  %.sroa.3.0.insert.ext.i = zext i32 %offset.i.i163.i to i160
  %.sroa.3.0.insert.shift.i = shl nuw i160 %.sroa.3.0.insert.ext.i, 128
  %634 = and i160 %.fca.1.extract44.i, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i = or disjoint i160 %.sroa.3.0.insert.shift.i, %634
  %635 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %636 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %637 = sext i32 %.reg2mem91.0394.i to i64
  %638 = shl nsw i64 %637, 5
  %639 = getelementptr i8, ptr %result.i.i.i433, i64 %638
  store ptr %.fca.0.extract42.i, ptr %639, align 8
  %640 = getelementptr i8, ptr %639, i64 8
  store i160 %.sroa.040.0.insert.insert.i, ptr %640, align 4
  br label %._crit_edge1.i434

._crit_edge1.i434:                                ; preds = %633, %628
  %641 = add i32 %.reg2mem91.0394.i, 1
  br label %642

642:                                              ; preds = %._crit_edge1.i434, %620
  %.reg2mem87.0.i = phi i32 [ %641, %._crit_edge1.i434 ], [ %.reg2mem91.0394.i, %620 ]
  %643 = add nuw nsw i32 %.reg2mem89.0393.i, 1
  %644 = icmp slt i32 %643, %583
  br i1 %644, label %620, label %._crit_edge395.i.loopexit

._crit_edge395.i.loopexit:                        ; preds = %642
  %.pre = load ptr, ptr %result.i, align 8
  %.pre1183 = load ptr, ptr %73, align 8
  br label %._crit_edge395.i

._crit_edge395.i:                                 ; preds = %._crit_edge395.i.loopexit, %558
  %645 = phi ptr [ %587, %558 ], [ %.pre1183, %._crit_edge395.i.loopexit ]
  %646 = phi ptr [ %586, %558 ], [ %.pre, %._crit_edge395.i.loopexit ]
  %.reg2mem91.0.lcssa.i = phi i32 [ 0, %558 ], [ %.reg2mem87.0.i, %._crit_edge395.i.loopexit ]
  %647 = call i32 @llvm.smax.i32(i32 %584, i32 16)
  %result.i166.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %648 = getelementptr i8, ptr %result.i166.i, i64 16
  store ptr @_parameterization_Nil, ptr %648, align 8
  %result.i167.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %649 = getelementptr i8, ptr %result.i167.i, i64 16
  store ptr %645, ptr %649, align 8
  %650 = getelementptr i8, ptr %result.i167.i, i64 8
  store ptr %646, ptr %650, align 8
  %651 = getelementptr i8, ptr %result.i167.i, i64 24
  store ptr null, ptr %651, align 8
  %652 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i)
  store ptr @Entry, ptr %result.i167.i, align 8
  %653 = getelementptr i8, ptr %result.i166.i, i64 8
  store ptr %result.i167.i, ptr %653, align 8
  %654 = getelementptr i8, ptr %result.i166.i, i64 24
  store ptr null, ptr %654, align 8
  %655 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i)
  store ptr @union_typ, ptr %result.i166.i, align 8
  %result.i168.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i, ptr %result.i168.i, align 8
  %656 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i)
  store ptr @Array, ptr %52, align 8
  store ptr %result.i168.i, ptr %126, align 8
  store i32 9, ptr %127, align 8
  %657 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %52)
  %658 = getelementptr i8, ptr %result.i168.i, i64 16
  store i32 %647, ptr %658, align 4
  %659 = getelementptr i8, ptr %result.i168.i, i64 20
  store i32 %647, ptr %659, align 4
  %660 = zext nneg i32 %647 to i64
  %661 = shl nuw nsw i64 %660, 5
  %result.i.i416.i = call noalias ptr @bump_malloc_inner(i64 noundef %661, ptr nonnull @current_ptr) #29
  %662 = getelementptr i8, ptr %result.i168.i, i64 8
  store ptr %result.i.i416.i, ptr %662, align 8
  %663 = load ptr, ptr %128, align 8
  store ptr @Array, ptr %90, align 8
  store ptr %result.i168.i, ptr %91, align 8
  store ptr %663, ptr %92, align 8
  store i32 9, ptr %93, align 4
  %664 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %665 = getelementptr i8, ptr %result.i183.i, i64 16
  store ptr @_parameterization_Nil, ptr %665, align 8
  %result.i184.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %666 = getelementptr i8, ptr %result.i184.i, i64 16
  store ptr %645, ptr %666, align 8
  %667 = getelementptr i8, ptr %result.i184.i, i64 8
  store ptr %646, ptr %667, align 8
  %668 = getelementptr i8, ptr %result.i184.i, i64 24
  store ptr null, ptr %668, align 8
  %669 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i)
  store ptr @Entry, ptr %result.i184.i, align 8
  %670 = getelementptr i8, ptr %result.i183.i, i64 8
  store ptr %result.i184.i, ptr %670, align 8
  %671 = getelementptr i8, ptr %result.i183.i, i64 24
  store ptr null, ptr %671, align 8
  %672 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i)
  store ptr @union_typ, ptr %result.i183.i, align 8
  %result.i185.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i, ptr %result.i185.i, align 8
  %673 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i)
  store ptr @Array, ptr %53, align 8
  store ptr %result.i185.i, ptr %129, align 8
  store i32 9, ptr %130, align 8
  %674 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %53)
  %675 = getelementptr i8, ptr %result.i185.i, i64 16
  store i32 %647, ptr %675, align 4
  %676 = getelementptr i8, ptr %result.i185.i, i64 20
  store i32 %647, ptr %676, align 4
  %result.i.i430.i = call noalias ptr @bump_malloc_inner(i64 noundef %661, ptr nonnull @current_ptr) #29
  %677 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %678 = getelementptr i8, ptr %result.i185.i, i64 8
  store ptr %result.i.i430.i, ptr %678, align 8
  %679 = load ptr, ptr %131, align 8
  store ptr @Array, ptr %105, align 8
  store ptr %result.i185.i, ptr %106, align 8
  store ptr %679, ptr %107, align 8
  store i32 9, ptr %108, align 4
  store i32 0, ptr %109, align 4
  %680 = icmp sgt i32 %.reg2mem91.0.lcssa.i, 0
  br i1 %680, label %.lr.ph400.i, label %HashMap_resize_.exit

.lr.ph400.i:                                      ; preds = %._crit_edge395.i
  %681 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %682 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %683 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %._crit_edge2.i, %.lr.ph400.i
  %.reg2mem77.0398.i = phi i32 [ 0, %.lr.ph400.i ], [ %697, %._crit_edge2.i ]
  %684 = zext nneg i32 %.reg2mem77.0398.i to i64
  %685 = shl nuw nsw i64 %684, 5
  %686 = getelementptr i8, ptr %result.i.i.i433, i64 %685
  %687 = load ptr, ptr %686, align 8
  %688 = getelementptr i8, ptr %686, i64 8
  %689 = load i160, ptr %688, align 4
  %.sroa.3362.8.extract.trunc.i = trunc i160 %689 to i64
  %690 = inttoptr i64 %.sroa.3362.8.extract.trunc.i to ptr
  %.sroa.5363.8.extract.shift.i = lshr i160 %689, 64
  %.sroa.5363.8.extract.trunc.i = trunc i160 %.sroa.5363.8.extract.shift.i to i64
  %691 = inttoptr i64 %.sroa.5363.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i201.i = getelementptr i8, ptr %687, i64 8
  %tbl_size_ptr.i.i202.i = getelementptr i8, ptr %687, i64 16
  %offset_tbl_ptr.i.i203.i = getelementptr i8, ptr %687, i64 40
  %hash_coef.i.i232.i = load i64, ptr %hash_coef_ptr.i.i201.i, align 4
  %tbl_size.i.i233.i = load i64, ptr %tbl_size_ptr.i.i202.i, align 4
  %offset_tbl.i.i234.i = load ptr, ptr %offset_tbl_ptr.i.i203.i, align 8
  %product.i.i.i235.i = mul i64 %hash_coef.i.i232.i, 4015701072841558310
  %shifted.i.i.i236.i = lshr i64 %product.i.i.i235.i, 32
  %xored.i.i.i237.i = xor i64 %shifted.i.i.i236.i, %product.i.i.i235.i
  %hash.i.i.i238.i = and i64 %xored.i.i.i237.i, %tbl_size.i.i233.i
  %offset_ptr.i.i239.i = getelementptr i32, ptr %offset_tbl.i.i234.i, i64 %hash.i.i.i238.i
  %offset.i.i240.i = load i32, ptr %offset_ptr.i.i239.i, align 4
  %692 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %687, 0
  %693 = insertvalue { ptr, ptr, ptr, i32 } %692, ptr %690, 1
  %694 = insertvalue { ptr, ptr, ptr, i32 } %693, ptr %691, 2
  %695 = insertvalue { ptr, ptr, ptr, i32 } %694, i32 %offset.i.i240.i, 3
  %696 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %695)
  %697 = add nuw nsw i32 %.reg2mem77.0398.i, 1
  %698 = icmp slt i32 %697, %.reg2mem91.0.lcssa.i
  br i1 %698, label %._crit_edge2.i, label %HashMap_resize_.exit

HashMap_resize_.exit:                             ; preds = %._crit_edge2.i, %._crit_edge395.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %53)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %HashMap_resize_.exit, %.critedge158.i
  %699 = load ptr, ptr %result.i, align 8
  %700 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %701 = load ptr, ptr %73, align 8
  %702 = load ptr, ptr %699, align 8
  %703 = getelementptr i8, ptr %702, i64 48
  %704 = load ptr, ptr %703, align 8
  %705 = call { i64, i64 } %704(ptr nonnull %699)
  %706 = extractvalue { i64, i64 } %705, 0
  %707 = extractvalue { i64, i64 } %705, 1
  %708 = urem i64 20, %707
  %709 = icmp eq i64 %708, 0
  %710 = sub i64 %707, %708
  %711 = select i1 %709, i64 0, i64 %710
  %712 = add i64 %706, 20
  %713 = add i64 %712, %711
  %714 = load ptr, ptr %701, align 8
  %715 = getelementptr i8, ptr %714, i64 48
  %716 = load ptr, ptr %715, align 8
  %717 = call { i64, i64 } %716(ptr nonnull %701)
  %718 = extractvalue { i64, i64 } %717, 0
  %719 = extractvalue { i64, i64 } %717, 1
  %720 = call i64 @llvm.umax.i64(i64 %707, i64 %719)
  %721 = call i64 @llvm.umax.i64(i64 %720, i64 8)
  %722 = urem i64 %713, %719
  %723 = icmp eq i64 %722, 0
  %724 = sub i64 %719, %722
  %725 = select i1 %723, i64 0, i64 %724
  %726 = add i64 %718, %713
  %727 = add i64 %726, %725
  %728 = urem i64 %727, %721
  %729 = icmp eq i64 %728, 0
  %730 = sub i64 %721, %728
  %731 = select i1 %729, i64 0, i64 %730
  %732 = add i64 %731, %727
  %result.i298.i = call noalias ptr @bump_malloc_inner(i64 noundef %732, ptr nonnull @current_ptr) #29
  store ptr %699, ptr %result.i298.i, align 8
  %733 = getelementptr i8, ptr %result.i298.i, i64 8
  store ptr %701, ptr %733, align 8
  %734 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i)
  store ptr @Entry, ptr %66, align 8
  store ptr %result.i298.i, ptr %113, align 8
  store i32 9, ptr %114, align 8
  %735 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %66)
  %736 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %737 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %738 = load ptr, ptr %699, align 8
  %739 = getelementptr i8, ptr %738, i64 48
  %740 = load ptr, ptr %739, align 8
  %741 = call { i64, i64 } %740(ptr nonnull %699)
  %742 = extractvalue { i64, i64 } %741, 1
  %743 = urem i64 20, %742
  %744 = icmp eq i64 %743, 0
  %reass.sub1530 = sub i64 %742, %743
  %745 = add i64 %reass.sub1530, 20
  %746 = select i1 %744, i64 20, i64 %745
  %747 = getelementptr i8, ptr %result.i298.i, i64 %746
  %748 = load ptr, ptr %result.i298.i, align 8
  %749 = load ptr, ptr %748, align 8
  %750 = getelementptr i8, ptr %749, i64 64
  %751 = load ptr, ptr %750, align 8
  call void %751({ ptr, i160 } %161, ptr nonnull %748, ptr %747)
  %752 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %753 = load ptr, ptr %result.i298.i, align 8
  %754 = load ptr, ptr %753, align 8
  %755 = getelementptr i8, ptr %754, i64 48
  %756 = load ptr, ptr %755, align 8
  %757 = call { i64, i64 } %756(ptr nonnull %753)
  %758 = extractvalue { i64, i64 } %757, 0
  %759 = extractvalue { i64, i64 } %757, 1
  %760 = urem i64 20, %759
  %761 = icmp eq i64 %760, 0
  %762 = sub i64 %759, %760
  %763 = select i1 %761, i64 0, i64 %762
  %764 = add i64 %758, 20
  %765 = add i64 %764, %763
  %766 = load ptr, ptr %733, align 8
  %767 = load ptr, ptr %766, align 8
  %768 = getelementptr i8, ptr %767, i64 48
  %769 = load ptr, ptr %768, align 8
  %770 = call { i64, i64 } %769(ptr nonnull %766)
  %771 = extractvalue { i64, i64 } %770, 1
  %772 = urem i64 %765, %771
  %773 = icmp eq i64 %772, 0
  %774 = sub i64 %771, %772
  %775 = select i1 %773, i64 0, i64 %774
  %776 = getelementptr i8, ptr %result.i298.i, i64 %765
  %777 = getelementptr i8, ptr %776, i64 %775
  %778 = load ptr, ptr %733, align 8
  %779 = load ptr, ptr %778, align 8
  %780 = getelementptr i8, ptr %779, i64 64
  %781 = load ptr, ptr %780, align 8
  call void %781({ ptr, i160 } %162, ptr nonnull %778, ptr %777)
  %782 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %783 = getelementptr i8, ptr %result.i298.i, i64 16
  store i32 %165, ptr %783, align 4
  %784 = load ptr, ptr %115, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i436)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %47)
  store ptr @Entry, ptr %47, align 8
  store ptr %result.i298.i, ptr %135, align 8
  store ptr %784, ptr %136, align 8
  store i32 9, ptr %137, align 8
  %785 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %47)
  %786 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %787 = load i32, ptr %111, align 4
  %788 = icmp sgt i32 %787, 0
  br i1 %788, label %.lr.ph.i466, label %._crit_edge1.i

.lr.ph.i466:                                      ; preds = %._crit_edge.i
  %789 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %790 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %791

791:                                              ; preds = %.cont.cont.i, %.lr.ph.i466
  %offset.i.i260.i1127 = phi i32 [ 9, %.lr.ph.i466 ], [ %offset.i.i260.i, %.cont.cont.i ]
  %.sroa.speculated346.i1125 = phi ptr [ %784, %.lr.ph.i466 ], [ %.sroa.speculated346.i, %.cont.cont.i ]
  %.sroa.speculated352.i1123 = phi ptr [ %result.i298.i, %.lr.ph.i466 ], [ %.sroa.speculated352.i, %.cont.cont.i ]
  %.reg2mem195.0678.i = phi i32 [ 1, %.lr.ph.i466 ], [ %947, %.cont.cont.i ]
  %.reg2mem193.0677.i = phi i32 [ 0, %.lr.ph.i466 ], [ %948, %.cont.cont.i ]
  %792 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i1123, 1
  %793 = insertvalue { ptr, ptr, ptr, i32 } %792, ptr %.sroa.speculated346.i1125, 2
  %794 = insertvalue { ptr, ptr, ptr, i32 } %793, i32 %offset.i.i260.i1127, 3
  %795 = sext i32 %offset.i.i260.i1127 to i64
  %gep = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %795
  %796 = load ptr, ptr %gep, align 8
  %797 = call ptr %796({ ptr, ptr, ptr, i32 } %794, ptr nonnull %2)
  %798 = call i32 %797({ ptr, ptr, ptr, i32 } %794, { ptr, ptr, ptr, i32 } %794, ptr nonnull %2)
  %799 = icmp eq i32 %.reg2mem195.0678.i, 1
  %800 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %799, label %801, label %865

801:                                              ; preds = %791
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %802 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %803 = load ptr, ptr %90, align 8
  %804 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %803, 0
  %805 = load ptr, ptr %91, align 8
  %806 = insertvalue { ptr, ptr, ptr, i32 } %804, ptr %805, 1
  %807 = load ptr, ptr %92, align 8
  %808 = insertvalue { ptr, ptr, ptr, i32 } %806, ptr %807, 2
  %809 = load i32, ptr %93, align 4
  %810 = insertvalue { ptr, ptr, ptr, i32 } %808, i32 %809, 3
  %hash_coef_ptr.i.i10.i1262 = getelementptr i8, ptr %803, i64 8
  %tbl_size_ptr.i.i11.i1263 = getelementptr i8, ptr %803, i64 16
  %offset_tbl_ptr.i.i12.i1264 = getelementptr i8, ptr %803, i64 40
  %hash_coef.i.i13.i1265 = load i64, ptr %hash_coef_ptr.i.i10.i1262, align 4
  %tbl_size.i.i14.i1266 = load i64, ptr %tbl_size_ptr.i.i11.i1263, align 4
  %offset_tbl.i.i15.i1267 = load ptr, ptr %offset_tbl_ptr.i.i12.i1264, align 8
  %product.i.i.i16.i1268 = mul i64 %hash_coef.i.i13.i1265, -5261542750394134544
  %shifted.i.i.i17.i1269 = lshr i64 %product.i.i.i16.i1268, 32
  %xored.i.i.i18.i1270 = xor i64 %shifted.i.i.i17.i1269, %product.i.i.i16.i1268
  %hash.i.i.i19.i1271 = and i64 %xored.i.i.i18.i1270, %tbl_size.i.i14.i1266
  %offset_ptr.i.i20.i1272 = getelementptr i32, ptr %offset_tbl.i.i15.i1267, i64 %hash.i.i.i19.i1271
  %offset.i.i21.i1273 = load i32, ptr %offset_ptr.i.i20.i1272, align 4
  %eq.i.i1274 = icmp eq i32 %809, %offset.i.i21.i1273
  call void @llvm.assume(i1 %eq.i.i1274) #30
  %811 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %812 = call ptr @llvm.invariant.start.p0(i64 600, ptr %803)
  %813 = sext i32 %809 to i64
  %814 = getelementptr ptr, ptr %803, i64 %813
  %815 = getelementptr i8, ptr %814, i64 64
  %816 = load ptr, ptr %815, align 8
  %817 = call ptr %816({ ptr, ptr, ptr, i32 } %810, ptr nonnull %2)
  %818 = call i32 %817({ ptr, ptr, ptr, i32 } %810, { ptr, ptr, ptr, i32 } %810, ptr nonnull %2)
  %819 = add i32 %818, -1
  %820 = and i32 %819, %798
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %821 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %822 = load ptr, ptr %90, align 8
  %823 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %822, 0
  %824 = load ptr, ptr %91, align 8
  %825 = insertvalue { ptr, ptr, ptr, i32 } %823, ptr %824, 1
  %826 = load ptr, ptr %92, align 8
  %827 = insertvalue { ptr, ptr, ptr, i32 } %825, ptr %826, 2
  %828 = load i32, ptr %93, align 4
  %829 = insertvalue { ptr, ptr, ptr, i32 } %827, i32 %828, 3
  %hash_coef_ptr.i.i172.i = getelementptr i8, ptr %822, i64 8
  %tbl_size_ptr.i.i173.i = getelementptr i8, ptr %822, i64 16
  %offset_tbl_ptr.i.i174.i = getelementptr i8, ptr %822, i64 40
  %hash_coef.i.i175.i = load i64, ptr %hash_coef_ptr.i.i172.i, align 4
  %tbl_size.i.i176.i = load i64, ptr %tbl_size_ptr.i.i173.i, align 4
  %offset_tbl.i.i177.i = load ptr, ptr %offset_tbl_ptr.i.i174.i, align 8
  %product.i.i.i178.i = mul i64 %hash_coef.i.i175.i, -5261542750394134544
  %shifted.i.i.i179.i = lshr i64 %product.i.i.i178.i, 32
  %xored.i.i.i180.i = xor i64 %shifted.i.i.i179.i, %product.i.i.i178.i
  %hash.i.i.i181.i = and i64 %xored.i.i.i180.i, %tbl_size.i.i176.i
  %offset_ptr.i.i182.i = getelementptr i32, ptr %offset_tbl.i.i177.i, i64 %hash.i.i.i181.i
  %offset.i.i183.i = load i32, ptr %offset_ptr.i.i182.i, align 4
  %eq.i.i469 = icmp eq i32 %828, %offset.i.i183.i
  call void @llvm.assume(i1 %eq.i.i469) #30
  store ptr @_parameterization_Ptri32, ptr %31, align 8
  %830 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %31)
  %831 = call ptr @llvm.invariant.start.p0(i64 600, ptr %822)
  %832 = sext i32 %828 to i64
  %833 = getelementptr ptr, ptr %822, i64 %832
  %834 = getelementptr i8, ptr %833, i64 120
  %835 = load ptr, ptr %834, align 8
  store ptr @i32_typ, ptr %32, align 8
  %836 = call ptr %835({ ptr, ptr, ptr, i32 } %829, ptr nonnull %32)
  %837 = call { ptr, i160 } %836({ ptr, ptr, ptr, i32 } %829, { ptr, ptr, ptr, i32 } %829, ptr nonnull %31, i32 %820)
  %.fca.0.extract112.i = extractvalue { ptr, i160 } %837, 0
  %838 = ptrtoint ptr %.sroa.speculated352.i1123 to i64
  %839 = ptrtoint ptr %.sroa.speculated346.i1125 to i64
  %.sroa.3111.0.insert.ext.i = zext i32 %offset.i.i260.i1127 to i160
  %.sroa.3111.0.insert.shift.i = shl nuw i160 %.sroa.3111.0.insert.ext.i, 128
  %.sroa.2110.0.insert.ext.i = zext i64 %839 to i160
  %.sroa.2110.0.insert.shift.i = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i, 64
  %.sroa.2110.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.shift.i, %.sroa.3111.0.insert.shift.i
  %.sroa.0109.0.insert.ext.i = zext i64 %838 to i160
  %.sroa.0109.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.insert.i, %.sroa.0109.0.insert.ext.i
  %840 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i, 1
  %841 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %842 = load ptr, ptr %90, align 8
  %843 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %842, 0
  %844 = load ptr, ptr %91, align 8
  %845 = insertvalue { ptr, ptr, ptr, i32 } %843, ptr %844, 1
  %846 = load ptr, ptr %92, align 8
  %847 = insertvalue { ptr, ptr, ptr, i32 } %845, ptr %846, 2
  %848 = load i32, ptr %93, align 4
  %849 = insertvalue { ptr, ptr, ptr, i32 } %847, i32 %848, 3
  %hash_coef_ptr.i.i186.i = getelementptr i8, ptr %842, i64 8
  %tbl_size_ptr.i.i187.i = getelementptr i8, ptr %842, i64 16
  %offset_tbl_ptr.i.i188.i = getelementptr i8, ptr %842, i64 40
  %hash_coef.i.i189.i = load i64, ptr %hash_coef_ptr.i.i186.i, align 4
  %tbl_size.i.i190.i = load i64, ptr %tbl_size_ptr.i.i187.i, align 4
  %offset_tbl.i.i191.i = load ptr, ptr %offset_tbl_ptr.i.i188.i, align 8
  %product.i.i.i192.i = mul i64 %hash_coef.i.i189.i, -5261542750394134544
  %shifted.i.i.i193.i = lshr i64 %product.i.i.i192.i, 32
  %xored.i.i.i194.i = xor i64 %shifted.i.i.i193.i, %product.i.i.i192.i
  %hash.i.i.i195.i = and i64 %xored.i.i.i194.i, %tbl_size.i.i190.i
  %offset_ptr.i.i196.i = getelementptr i32, ptr %offset_tbl.i.i191.i, i64 %hash.i.i.i195.i
  %offset.i.i197.i = load i32, ptr %offset_ptr.i.i196.i, align 4
  %eq.i200.i = icmp eq i32 %848, %offset.i.i197.i
  call void @llvm.assume(i1 %eq.i200.i) #30
  %850 = load ptr, ptr %result.i, align 8
  %851 = load ptr, ptr %73, align 8
  %result.i.i470 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %852 = getelementptr i8, ptr %result.i.i470, i64 16
  store ptr %851, ptr %852, align 8
  %853 = getelementptr i8, ptr %result.i.i470, i64 8
  store ptr %850, ptr %853, align 8
  %854 = getelementptr i8, ptr %result.i.i470, i64 24
  store ptr null, ptr %854, align 8
  %855 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i470)
  store ptr @Entry, ptr %result.i.i470, align 8
  store ptr @_parameterization_Ptri32, ptr %33, align 8
  store ptr %result.i.i470, ptr %140, align 8
  %856 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %33)
  %857 = call ptr @llvm.invariant.start.p0(i64 600, ptr %842)
  %858 = sext i32 %848 to i64
  %859 = getelementptr ptr, ptr %842, i64 %858
  %860 = getelementptr i8, ptr %859, i64 128
  %861 = load ptr, ptr %860, align 8
  store ptr @i32_typ, ptr %34, align 8
  store ptr @Entry, ptr %141, align 8
  %862 = call ptr %861({ ptr, ptr, ptr, i32 } %849, ptr nonnull %34)
  call void %862({ ptr, ptr, ptr, i32 } %849, { ptr, ptr, ptr, i32 } %849, ptr nonnull %33, i32 %820, { ptr, i160 } %840)
  %863 = icmp ne ptr %.fca.0.extract112.i, @nil_typ
  %864 = icmp ne ptr %.fca.0.extract112.i, null
  %.not140.i = and i1 %863, %864
  br i1 %.not140.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

865:                                              ; preds = %791
  %866 = add i32 %798, 2127912214
  %867 = shl i32 %798, 12
  %868 = add i32 %866, %867
  %869 = ashr i32 %868, 19
  %870 = xor i32 %868, %869
  %871 = xor i32 %870, -949894596
  %872 = add i32 %871, 374761393
  %873 = shl i32 %871, 5
  %874 = add i32 %872, %873
  %875 = add i32 %874, -744332180
  %876 = shl i32 %874, 9
  %877 = xor i32 %875, %876
  %878 = add i32 %877, -42973499
  %879 = shl i32 %877, 3
  %880 = add i32 %878, %879
  %881 = ashr i32 %880, 16
  %882 = xor i32 %880, %881
  %883 = xor i32 %882, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %884 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %885 = load ptr, ptr %105, align 8
  %886 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %885, 0
  %887 = load ptr, ptr %106, align 8
  %888 = insertvalue { ptr, ptr, ptr, i32 } %886, ptr %887, 1
  %889 = load ptr, ptr %107, align 8
  %890 = insertvalue { ptr, ptr, ptr, i32 } %888, ptr %889, 2
  %891 = load i32, ptr %108, align 4
  %892 = insertvalue { ptr, ptr, ptr, i32 } %890, i32 %891, 3
  %hash_coef_ptr.i.i10.i1292 = getelementptr i8, ptr %885, i64 8
  %tbl_size_ptr.i.i11.i1293 = getelementptr i8, ptr %885, i64 16
  %offset_tbl_ptr.i.i12.i1294 = getelementptr i8, ptr %885, i64 40
  %hash_coef.i.i13.i1295 = load i64, ptr %hash_coef_ptr.i.i10.i1292, align 4
  %tbl_size.i.i14.i1296 = load i64, ptr %tbl_size_ptr.i.i11.i1293, align 4
  %offset_tbl.i.i15.i1297 = load ptr, ptr %offset_tbl_ptr.i.i12.i1294, align 8
  %product.i.i.i16.i1298 = mul i64 %hash_coef.i.i13.i1295, -5261542750394134544
  %shifted.i.i.i17.i1299 = lshr i64 %product.i.i.i16.i1298, 32
  %xored.i.i.i18.i1300 = xor i64 %shifted.i.i.i17.i1299, %product.i.i.i16.i1298
  %hash.i.i.i19.i1301 = and i64 %xored.i.i.i18.i1300, %tbl_size.i.i14.i1296
  %offset_ptr.i.i20.i1302 = getelementptr i32, ptr %offset_tbl.i.i15.i1297, i64 %hash.i.i.i19.i1301
  %offset.i.i21.i1303 = load i32, ptr %offset_ptr.i.i20.i1302, align 4
  %eq.i.i1304 = icmp eq i32 %891, %offset.i.i21.i1303
  call void @llvm.assume(i1 %eq.i.i1304) #30
  %893 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %894 = call ptr @llvm.invariant.start.p0(i64 600, ptr %885)
  %895 = sext i32 %891 to i64
  %896 = getelementptr ptr, ptr %885, i64 %895
  %897 = getelementptr i8, ptr %896, i64 64
  %898 = load ptr, ptr %897, align 8
  %899 = call ptr %898({ ptr, ptr, ptr, i32 } %892, ptr nonnull %2)
  %900 = call i32 %899({ ptr, ptr, ptr, i32 } %892, { ptr, ptr, ptr, i32 } %892, ptr nonnull %2)
  %901 = add i32 %900, -1
  %902 = and i32 %901, %883
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %903 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %904 = load ptr, ptr %105, align 8
  %905 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %904, 0
  %906 = load ptr, ptr %106, align 8
  %907 = insertvalue { ptr, ptr, ptr, i32 } %905, ptr %906, 1
  %908 = load ptr, ptr %107, align 8
  %909 = insertvalue { ptr, ptr, ptr, i32 } %907, ptr %908, 2
  %910 = load i32, ptr %108, align 4
  %911 = insertvalue { ptr, ptr, ptr, i32 } %909, i32 %910, 3
  %hash_coef_ptr.i.i202.i = getelementptr i8, ptr %904, i64 8
  %tbl_size_ptr.i.i203.i = getelementptr i8, ptr %904, i64 16
  %offset_tbl_ptr.i.i204.i = getelementptr i8, ptr %904, i64 40
  %hash_coef.i.i205.i = load i64, ptr %hash_coef_ptr.i.i202.i, align 4
  %tbl_size.i.i206.i = load i64, ptr %tbl_size_ptr.i.i203.i, align 4
  %offset_tbl.i.i207.i = load ptr, ptr %offset_tbl_ptr.i.i204.i, align 8
  %product.i.i.i208.i = mul i64 %hash_coef.i.i205.i, -5261542750394134544
  %shifted.i.i.i209.i = lshr i64 %product.i.i.i208.i, 32
  %xored.i.i.i210.i = xor i64 %shifted.i.i.i209.i, %product.i.i.i208.i
  %hash.i.i.i211.i = and i64 %xored.i.i.i210.i, %tbl_size.i.i206.i
  %offset_ptr.i.i212.i = getelementptr i32, ptr %offset_tbl.i.i207.i, i64 %hash.i.i.i211.i
  %offset.i.i213.i = load i32, ptr %offset_ptr.i.i212.i, align 4
  %eq.i216.i = icmp eq i32 %910, %offset.i.i213.i
  call void @llvm.assume(i1 %eq.i216.i) #30
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %912 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %39)
  %913 = call ptr @llvm.invariant.start.p0(i64 600, ptr %904)
  %914 = sext i32 %910 to i64
  %915 = getelementptr ptr, ptr %904, i64 %914
  %916 = getelementptr i8, ptr %915, i64 120
  %917 = load ptr, ptr %916, align 8
  store ptr @i32_typ, ptr %40, align 8
  %918 = call ptr %917({ ptr, ptr, ptr, i32 } %911, ptr nonnull %40)
  %919 = call { ptr, i160 } %918({ ptr, ptr, ptr, i32 } %911, { ptr, ptr, ptr, i32 } %911, ptr nonnull %39, i32 %902)
  %.fca.0.extract87.i = extractvalue { ptr, i160 } %919, 0
  %920 = ptrtoint ptr %.sroa.speculated352.i1123 to i64
  %921 = ptrtoint ptr %.sroa.speculated346.i1125 to i64
  %.sroa.3.0.insert.ext.i467 = zext i32 %offset.i.i260.i1127 to i160
  %.sroa.3.0.insert.shift.i468 = shl nuw i160 %.sroa.3.0.insert.ext.i467, 128
  %.sroa.2.0.insert.ext.i = zext i64 %921 to i160
  %.sroa.2.0.insert.shift.i = shl nuw nsw i160 %.sroa.2.0.insert.ext.i, 64
  %.sroa.2.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.shift.i, %.sroa.3.0.insert.shift.i468
  %.sroa.0.0.insert.ext.i = zext i64 %920 to i160
  %.sroa.0.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.insert.i, %.sroa.0.0.insert.ext.i
  %922 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i, 1
  %923 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %924 = load ptr, ptr %105, align 8
  %925 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %924, 0
  %926 = load ptr, ptr %106, align 8
  %927 = insertvalue { ptr, ptr, ptr, i32 } %925, ptr %926, 1
  %928 = load ptr, ptr %107, align 8
  %929 = insertvalue { ptr, ptr, ptr, i32 } %927, ptr %928, 2
  %930 = load i32, ptr %108, align 4
  %931 = insertvalue { ptr, ptr, ptr, i32 } %929, i32 %930, 3
  %hash_coef_ptr.i.i218.i = getelementptr i8, ptr %924, i64 8
  %tbl_size_ptr.i.i219.i = getelementptr i8, ptr %924, i64 16
  %offset_tbl_ptr.i.i220.i = getelementptr i8, ptr %924, i64 40
  %hash_coef.i.i221.i = load i64, ptr %hash_coef_ptr.i.i218.i, align 4
  %tbl_size.i.i222.i = load i64, ptr %tbl_size_ptr.i.i219.i, align 4
  %offset_tbl.i.i223.i = load ptr, ptr %offset_tbl_ptr.i.i220.i, align 8
  %product.i.i.i224.i = mul i64 %hash_coef.i.i221.i, -5261542750394134544
  %shifted.i.i.i225.i = lshr i64 %product.i.i.i224.i, 32
  %xored.i.i.i226.i = xor i64 %shifted.i.i.i225.i, %product.i.i.i224.i
  %hash.i.i.i227.i = and i64 %xored.i.i.i226.i, %tbl_size.i.i222.i
  %offset_ptr.i.i228.i = getelementptr i32, ptr %offset_tbl.i.i223.i, i64 %hash.i.i.i227.i
  %offset.i.i229.i = load i32, ptr %offset_ptr.i.i228.i, align 4
  %eq.i232.i = icmp eq i32 %930, %offset.i.i229.i
  call void @llvm.assume(i1 %eq.i232.i) #30
  %932 = load ptr, ptr %result.i, align 8
  %933 = load ptr, ptr %73, align 8
  %result.i233.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %934 = getelementptr i8, ptr %result.i233.i, i64 16
  store ptr %933, ptr %934, align 8
  %935 = getelementptr i8, ptr %result.i233.i, i64 8
  store ptr %932, ptr %935, align 8
  %936 = getelementptr i8, ptr %result.i233.i, i64 24
  store ptr null, ptr %936, align 8
  %937 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i)
  store ptr @Entry, ptr %result.i233.i, align 8
  store ptr @_parameterization_Ptri32, ptr %41, align 8
  store ptr %result.i233.i, ptr %138, align 8
  %938 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %41)
  %939 = call ptr @llvm.invariant.start.p0(i64 600, ptr %924)
  %940 = sext i32 %930 to i64
  %941 = getelementptr ptr, ptr %924, i64 %940
  %942 = getelementptr i8, ptr %941, i64 128
  %943 = load ptr, ptr %942, align 8
  store ptr @i32_typ, ptr %42, align 8
  store ptr @Entry, ptr %139, align 8
  %944 = call ptr %943({ ptr, ptr, ptr, i32 } %931, ptr nonnull %42)
  call void %944({ ptr, ptr, ptr, i32 } %931, { ptr, ptr, ptr, i32 } %931, ptr nonnull %41, i32 %902, { ptr, i160 } %922)
  %945 = icmp ne ptr %.fca.0.extract87.i, @nil_typ
  %946 = icmp ne ptr %.fca.0.extract87.i, null
  %.not138.i = and i1 %945, %946
  br i1 %.not138.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %865, %801
  %.sink = phi { ptr, i160 } [ %837, %801 ], [ %919, %865 ]
  %947 = phi i32 [ 2, %801 ], [ 1, %865 ]
  %vptr.i248.sroa.speculated.i = phi ptr [ %.fca.0.extract112.i, %801 ], [ %.fca.0.extract87.i, %865 ]
  %.fca.1.extract89.i = extractvalue { ptr, i160 } %.sink, 1
  %.sroa.3407.sroa.4.0.extract.shift.i = lshr i160 %.fca.1.extract89.i, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i = trunc i160 %.fca.1.extract89.i to i64
  %.sroa.speculated352.i = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i to ptr
  %.sroa.speculated346.i = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i to ptr
  %hash_coef_ptr.i.i249.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i250.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i251.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 40
  %hash_coef.i.i252.i = load i64, ptr %hash_coef_ptr.i.i249.i, align 4
  %tbl_size.i.i253.i = load i64, ptr %tbl_size_ptr.i.i250.i, align 4
  %offset_tbl.i.i254.i = load ptr, ptr %offset_tbl_ptr.i.i251.i, align 8
  %product.i.i.i255.i = mul i64 %hash_coef.i.i252.i, 4015701072841558310
  %shifted.i.i.i256.i = lshr i64 %product.i.i.i255.i, 32
  %xored.i.i.i257.i = xor i64 %shifted.i.i.i256.i, %product.i.i.i255.i
  %hash.i.i.i258.i = and i64 %xored.i.i.i257.i, %tbl_size.i.i253.i
  %offset_ptr.i.i259.i = getelementptr i32, ptr %offset_tbl.i.i254.i, i64 %hash.i.i.i258.i
  %offset.i.i260.i = load i32, ptr %offset_ptr.i.i259.i, align 4
  store ptr %vptr.i248.sroa.speculated.i, ptr %47, align 8
  store ptr %.sroa.speculated352.i, ptr %135, align 8
  store ptr %.sroa.speculated346.i, ptr %136, align 8
  store i32 %offset.i.i260.i, ptr %137, align 8
  %948 = add nuw nsw i32 %.reg2mem193.0677.i, 1
  %949 = load i32, ptr %111, align 4
  %950 = icmp slt i32 %948, %949
  br i1 %950, label %791, label %._crit_edge1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %801, %865
  %951 = phi ptr [ %43, %865 ], [ %35, %801 ]
  %952 = phi ptr [ %44, %865 ], [ %36, %801 ]
  %953 = phi ptr [ %45, %865 ], [ %37, %801 ]
  %954 = phi ptr [ %.sroa.0.i436, %865 ], [ %.sroa.0680.i, %801 ]
  %955 = phi ptr [ %46, %865 ], [ %38, %801 ]
  %956 = load i32, ptr %109, align 4
  store i32 %956, ptr %951, align 4
  store i32 1, ptr %952, align 4
  %957 = add i32 %956, 1
  store i32 %957, ptr %953, align 4
  %958 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %957, ptr %109, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %955, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %954, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i436)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.i:                                   ; preds = %.cont.cont.i, %._crit_edge.i
  %959 = load i160, ptr %135, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i436)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %30)
  %960 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %961 = load ptr, ptr %90, align 8
  %962 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %961, 0
  %963 = load ptr, ptr %91, align 8
  %964 = insertvalue { ptr, ptr, ptr, i32 } %962, ptr %963, 1
  %965 = load ptr, ptr %92, align 8
  %966 = insertvalue { ptr, ptr, ptr, i32 } %964, ptr %965, 2
  %967 = load i32, ptr %93, align 4
  %968 = insertvalue { ptr, ptr, ptr, i32 } %966, i32 %967, 3
  %hash_coef_ptr.i.i64.i490 = getelementptr i8, ptr %961, i64 8
  %tbl_size_ptr.i.i65.i491 = getelementptr i8, ptr %961, i64 16
  %offset_tbl_ptr.i.i66.i492 = getelementptr i8, ptr %961, i64 40
  %hash_coef.i.i67.i493 = load i64, ptr %hash_coef_ptr.i.i64.i490, align 4
  %tbl_size.i.i68.i494 = load i64, ptr %tbl_size_ptr.i.i65.i491, align 4
  %offset_tbl.i.i69.i495 = load ptr, ptr %offset_tbl_ptr.i.i66.i492, align 8
  %product.i.i.i70.i496 = mul i64 %hash_coef.i.i67.i493, -5261542750394134544
  %shifted.i.i.i71.i497 = lshr i64 %product.i.i.i70.i496, 32
  %xored.i.i.i72.i498 = xor i64 %shifted.i.i.i71.i497, %product.i.i.i70.i496
  %hash.i.i.i73.i499 = and i64 %xored.i.i.i72.i498, %tbl_size.i.i68.i494
  %offset_ptr.i.i74.i500 = getelementptr i32, ptr %offset_tbl.i.i69.i495, i64 %hash.i.i.i73.i499
  %offset.i.i75.i501 = load i32, ptr %offset_ptr.i.i74.i500, align 4
  %eq.i.i502 = icmp eq i32 %967, %offset.i.i75.i501
  call void @llvm.assume(i1 %eq.i.i502) #30
  %969 = load ptr, ptr %105, align 8
  %970 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %969, 0
  %971 = load ptr, ptr %106, align 8
  %972 = insertvalue { ptr, ptr, ptr, i32 } %970, ptr %971, 1
  %973 = load ptr, ptr %107, align 8
  %974 = insertvalue { ptr, ptr, ptr, i32 } %972, ptr %973, 2
  %975 = load i32, ptr %108, align 4
  %976 = insertvalue { ptr, ptr, ptr, i32 } %974, i32 %975, 3
  %hash_coef_ptr.i.i92.i507 = getelementptr i8, ptr %969, i64 8
  %tbl_size_ptr.i.i93.i508 = getelementptr i8, ptr %969, i64 16
  %offset_tbl_ptr.i.i94.i509 = getelementptr i8, ptr %969, i64 40
  %hash_coef.i.i95.i510 = load i64, ptr %hash_coef_ptr.i.i92.i507, align 4
  %tbl_size.i.i96.i511 = load i64, ptr %tbl_size_ptr.i.i93.i508, align 4
  %offset_tbl.i.i97.i512 = load ptr, ptr %offset_tbl_ptr.i.i94.i509, align 8
  %product.i.i.i98.i513 = mul i64 %hash_coef.i.i95.i510, -5261542750394134544
  %shifted.i.i.i99.i514 = lshr i64 %product.i.i.i98.i513, 32
  %xored.i.i.i100.i515 = xor i64 %shifted.i.i.i99.i514, %product.i.i.i98.i513
  %hash.i.i.i101.i516 = and i64 %xored.i.i.i100.i515, %tbl_size.i.i96.i511
  %offset_ptr.i.i102.i517 = getelementptr i32, ptr %offset_tbl.i.i97.i512, i64 %hash.i.i.i101.i516
  %offset.i.i103.i518 = load i32, ptr %offset_ptr.i.i102.i517, align 4
  %eq.i106.i519 = icmp eq i32 %975, %offset.i.i103.i518
  call void @llvm.assume(i1 %eq.i106.i519) #30
  %977 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %978 = call ptr @llvm.invariant.start.p0(i64 600, ptr %961)
  %979 = sext i32 %967 to i64
  %980 = getelementptr ptr, ptr %961, i64 %979
  %981 = getelementptr i8, ptr %980, i64 64
  %982 = load ptr, ptr %981, align 8
  %983 = call ptr %982({ ptr, ptr, ptr, i32 } %968, ptr nonnull %2)
  %984 = call i32 %983({ ptr, ptr, ptr, i32 } %968, { ptr, ptr, ptr, i32 } %968, ptr nonnull %2)
  %985 = shl i32 %984, 1
  %986 = load i32, ptr %109, align 4
  %987 = load ptr, ptr %result.i, align 8
  %988 = load ptr, ptr %73, align 8
  %989 = sext i32 %986 to i64
  %990 = shl nsw i64 %989, 5
  %result.i.i.i522 = call noalias ptr @bump_malloc_inner(i64 noundef %990, ptr nonnull @current_ptr) #29
  %991 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %992 = icmp sgt i32 %984, 0
  br i1 %992, label %.lr.ph434.i592, label %._crit_edge395.i536

.lr.ph434.i592:                                   ; preds = %._crit_edge1.i
  %invariant.gep.i535 = getelementptr i8, ptr %961, i64 120
  %993 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i595 = getelementptr ptr, ptr %invariant.gep.i535, i64 %979
  br label %994

994:                                              ; preds = %1016, %.lr.ph434.i592
  %.reg2mem105.0432.i593 = phi i32 [ 0, %.lr.ph434.i592 ], [ %.reg2mem101.0.i598, %1016 ]
  %.reg2mem103.0431.i594 = phi i32 [ 0, %.lr.ph434.i592 ], [ %1017, %1016 ]
  store ptr @_parameterization_Ptri32, ptr %25, align 8
  %995 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %25)
  %996 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %961)
  %997 = load ptr, ptr %gep.i595, align 8
  store ptr @i32_typ, ptr %26, align 8
  %998 = call ptr %997({ ptr, ptr, ptr, i32 } %968, ptr nonnull %26)
  %999 = call { ptr, i160 } %998({ ptr, ptr, ptr, i32 } %968, { ptr, ptr, ptr, i32 } %968, ptr nonnull %25, i32 %.reg2mem103.0431.i594)
  %.fca.0.extract52.i596 = extractvalue { ptr, i160 } %999, 0
  %1000 = icmp ne ptr %.fca.0.extract52.i596, @nil_typ
  %1001 = icmp ne ptr %.fca.0.extract52.i596, null
  %.not60.i597 = and i1 %1000, %1001
  br i1 %.not60.i597, label %1002, label %1016

1002:                                             ; preds = %994
  %hash_coef_ptr.i.i137.i625 = getelementptr i8, ptr %.fca.0.extract52.i596, i64 8
  %tbl_size_ptr.i.i138.i626 = getelementptr i8, ptr %.fca.0.extract52.i596, i64 16
  %offset_tbl_ptr.i.i139.i627 = getelementptr i8, ptr %.fca.0.extract52.i596, i64 40
  %hash_coef.i.i140.i628 = load i64, ptr %hash_coef_ptr.i.i137.i625, align 4
  %tbl_size.i.i141.i629 = load i64, ptr %tbl_size_ptr.i.i138.i626, align 4
  %offset_tbl.i.i142.i630 = load ptr, ptr %offset_tbl_ptr.i.i139.i627, align 8
  %product.i.i.i143.i631 = mul i64 %hash_coef.i.i140.i628, 4015701072841558310
  %shifted.i.i.i144.i632 = lshr i64 %product.i.i.i143.i631, 32
  %xored.i.i.i145.i633 = xor i64 %shifted.i.i.i144.i632, %product.i.i.i143.i631
  %hash.i.i.i146.i634 = and i64 %xored.i.i.i145.i633, %tbl_size.i.i141.i629
  %offset_ptr.i.i147.i635 = getelementptr i32, ptr %offset_tbl.i.i142.i630, i64 %hash.i.i.i146.i634
  %offset.i.i148.i636 = load i32, ptr %offset_ptr.i.i147.i635, align 4
  %1003 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1004 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1005 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1006 = icmp slt i32 %.reg2mem105.0432.i593, %986
  br i1 %1006, label %1007, label %._crit_edge.i637

1007:                                             ; preds = %1002
  %.fca.1.extract54.i638 = extractvalue { ptr, i160 } %999, 1
  %.sroa.351.0.insert.ext.i639 = zext i32 %offset.i.i148.i636 to i160
  %.sroa.351.0.insert.shift.i640 = shl nuw i160 %.sroa.351.0.insert.ext.i639, 128
  %1008 = and i160 %.fca.1.extract54.i638, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i641 = or disjoint i160 %.sroa.351.0.insert.shift.i640, %1008
  %1009 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1010 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1011 = sext i32 %.reg2mem105.0432.i593 to i64
  %1012 = shl nsw i64 %1011, 5
  %1013 = getelementptr i8, ptr %result.i.i.i522, i64 %1012
  store ptr %.fca.0.extract52.i596, ptr %1013, align 8
  %1014 = getelementptr i8, ptr %1013, i64 8
  store i160 %.sroa.049.0.insert.insert.i641, ptr %1014, align 4
  br label %._crit_edge.i637

._crit_edge.i637:                                 ; preds = %1007, %1002
  %1015 = add i32 %.reg2mem105.0432.i593, 1
  br label %1016

1016:                                             ; preds = %._crit_edge.i637, %994
  %.reg2mem101.0.i598 = phi i32 [ %1015, %._crit_edge.i637 ], [ %.reg2mem105.0432.i593, %994 ]
  %1017 = add nuw nsw i32 %.reg2mem103.0431.i594, 1
  %1018 = icmp slt i32 %1017, %984
  br i1 %1018, label %994, label %.lr.ph.i599

.lr.ph.i599:                                      ; preds = %1016
  %invariant.gep396.i600 = getelementptr i8, ptr %969, i64 120
  %1019 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1020 = sext i32 %975 to i64
  %gep397.i603 = getelementptr ptr, ptr %invariant.gep396.i600, i64 %1020
  br label %1021

1021:                                             ; preds = %1043, %.lr.ph.i599
  %.reg2mem91.0394.i601 = phi i32 [ %.reg2mem101.0.i598, %.lr.ph.i599 ], [ %.reg2mem87.0.i606, %1043 ]
  %.reg2mem89.0393.i602 = phi i32 [ 0, %.lr.ph.i599 ], [ %1044, %1043 ]
  store ptr @_parameterization_Ptri32, ptr %27, align 8
  %1022 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %27)
  %1023 = call ptr @llvm.invariant.start.p0(i64 600, ptr %969)
  %1024 = load ptr, ptr %gep397.i603, align 8
  store ptr @i32_typ, ptr %28, align 8
  %1025 = call ptr %1024({ ptr, ptr, ptr, i32 } %976, ptr nonnull %28)
  %1026 = call { ptr, i160 } %1025({ ptr, ptr, ptr, i32 } %976, { ptr, ptr, ptr, i32 } %976, ptr nonnull %27, i32 %.reg2mem89.0393.i602)
  %.fca.0.extract42.i604 = extractvalue { ptr, i160 } %1026, 0
  %1027 = icmp ne ptr %.fca.0.extract42.i604, @nil_typ
  %1028 = icmp ne ptr %.fca.0.extract42.i604, null
  %.not62.i605 = and i1 %1027, %1028
  br i1 %.not62.i605, label %1029, label %1043

1029:                                             ; preds = %1021
  %hash_coef_ptr.i.i152.i607 = getelementptr i8, ptr %.fca.0.extract42.i604, i64 8
  %tbl_size_ptr.i.i153.i608 = getelementptr i8, ptr %.fca.0.extract42.i604, i64 16
  %offset_tbl_ptr.i.i154.i609 = getelementptr i8, ptr %.fca.0.extract42.i604, i64 40
  %hash_coef.i.i155.i610 = load i64, ptr %hash_coef_ptr.i.i152.i607, align 4
  %tbl_size.i.i156.i611 = load i64, ptr %tbl_size_ptr.i.i153.i608, align 4
  %offset_tbl.i.i157.i612 = load ptr, ptr %offset_tbl_ptr.i.i154.i609, align 8
  %product.i.i.i158.i613 = mul i64 %hash_coef.i.i155.i610, 4015701072841558310
  %shifted.i.i.i159.i614 = lshr i64 %product.i.i.i158.i613, 32
  %xored.i.i.i160.i615 = xor i64 %shifted.i.i.i159.i614, %product.i.i.i158.i613
  %hash.i.i.i161.i616 = and i64 %xored.i.i.i160.i615, %tbl_size.i.i156.i611
  %offset_ptr.i.i162.i617 = getelementptr i32, ptr %offset_tbl.i.i157.i612, i64 %hash.i.i.i161.i616
  %offset.i.i163.i618 = load i32, ptr %offset_ptr.i.i162.i617, align 4
  %1030 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1031 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1032 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1033 = icmp slt i32 %.reg2mem91.0394.i601, %986
  br i1 %1033, label %1034, label %._crit_edge1.i619

1034:                                             ; preds = %1029
  %.fca.1.extract44.i620 = extractvalue { ptr, i160 } %1026, 1
  %.sroa.3.0.insert.ext.i621 = zext i32 %offset.i.i163.i618 to i160
  %.sroa.3.0.insert.shift.i622 = shl nuw i160 %.sroa.3.0.insert.ext.i621, 128
  %1035 = and i160 %.fca.1.extract44.i620, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i623 = or disjoint i160 %.sroa.3.0.insert.shift.i622, %1035
  %1036 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1037 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1038 = sext i32 %.reg2mem91.0394.i601 to i64
  %1039 = shl nsw i64 %1038, 5
  %1040 = getelementptr i8, ptr %result.i.i.i522, i64 %1039
  store ptr %.fca.0.extract42.i604, ptr %1040, align 8
  %1041 = getelementptr i8, ptr %1040, i64 8
  store i160 %.sroa.040.0.insert.insert.i623, ptr %1041, align 4
  br label %._crit_edge1.i619

._crit_edge1.i619:                                ; preds = %1034, %1029
  %1042 = add i32 %.reg2mem91.0394.i601, 1
  br label %1043

1043:                                             ; preds = %._crit_edge1.i619, %1021
  %.reg2mem87.0.i606 = phi i32 [ %1042, %._crit_edge1.i619 ], [ %.reg2mem91.0394.i601, %1021 ]
  %1044 = add nuw nsw i32 %.reg2mem89.0393.i602, 1
  %1045 = icmp slt i32 %1044, %984
  br i1 %1045, label %1021, label %._crit_edge395.i536.loopexit

._crit_edge395.i536.loopexit:                     ; preds = %1043
  %.pre1184 = load ptr, ptr %result.i, align 8
  %.pre1185 = load ptr, ptr %73, align 8
  br label %._crit_edge395.i536

._crit_edge395.i536:                              ; preds = %._crit_edge395.i536.loopexit, %._crit_edge1.i
  %1046 = phi ptr [ %988, %._crit_edge1.i ], [ %.pre1185, %._crit_edge395.i536.loopexit ]
  %1047 = phi ptr [ %987, %._crit_edge1.i ], [ %.pre1184, %._crit_edge395.i536.loopexit ]
  %.reg2mem91.0.lcssa.i537 = phi i32 [ 0, %._crit_edge1.i ], [ %.reg2mem87.0.i606, %._crit_edge395.i536.loopexit ]
  %1048 = call i32 @llvm.smax.i32(i32 %985, i32 16)
  %result.i166.i538 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1049 = getelementptr i8, ptr %result.i166.i538, i64 16
  store ptr @_parameterization_Nil, ptr %1049, align 8
  %result.i167.i539 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1050 = getelementptr i8, ptr %result.i167.i539, i64 16
  store ptr %1046, ptr %1050, align 8
  %1051 = getelementptr i8, ptr %result.i167.i539, i64 8
  store ptr %1047, ptr %1051, align 8
  %1052 = getelementptr i8, ptr %result.i167.i539, i64 24
  store ptr null, ptr %1052, align 8
  %1053 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i539)
  store ptr @Entry, ptr %result.i167.i539, align 8
  %1054 = getelementptr i8, ptr %result.i166.i538, i64 8
  store ptr %result.i167.i539, ptr %1054, align 8
  %1055 = getelementptr i8, ptr %result.i166.i538, i64 24
  store ptr null, ptr %1055, align 8
  %1056 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i538)
  store ptr @union_typ, ptr %result.i166.i538, align 8
  %result.i168.i540 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i538, ptr %result.i168.i540, align 8
  %1057 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i540)
  store ptr @Array, ptr %29, align 8
  store ptr %result.i168.i540, ptr %142, align 8
  store i32 9, ptr %143, align 8
  %1058 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %29)
  %1059 = getelementptr i8, ptr %result.i168.i540, i64 16
  store i32 %1048, ptr %1059, align 4
  %1060 = getelementptr i8, ptr %result.i168.i540, i64 20
  store i32 %1048, ptr %1060, align 4
  %1061 = zext nneg i32 %1048 to i64
  %1062 = shl nuw nsw i64 %1061, 5
  %result.i.i416.i541 = call noalias ptr @bump_malloc_inner(i64 noundef %1062, ptr nonnull @current_ptr) #29
  %1063 = getelementptr i8, ptr %result.i168.i540, i64 8
  store ptr %result.i.i416.i541, ptr %1063, align 8
  %1064 = load ptr, ptr %144, align 8
  store ptr @Array, ptr %90, align 8
  store ptr %result.i168.i540, ptr %91, align 8
  store ptr %1064, ptr %92, align 8
  store i32 9, ptr %93, align 4
  %1065 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i554 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1066 = getelementptr i8, ptr %result.i183.i554, i64 16
  store ptr @_parameterization_Nil, ptr %1066, align 8
  %result.i184.i555 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1067 = getelementptr i8, ptr %result.i184.i555, i64 16
  store ptr %1046, ptr %1067, align 8
  %1068 = getelementptr i8, ptr %result.i184.i555, i64 8
  store ptr %1047, ptr %1068, align 8
  %1069 = getelementptr i8, ptr %result.i184.i555, i64 24
  store ptr null, ptr %1069, align 8
  %1070 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i555)
  store ptr @Entry, ptr %result.i184.i555, align 8
  %1071 = getelementptr i8, ptr %result.i183.i554, i64 8
  store ptr %result.i184.i555, ptr %1071, align 8
  %1072 = getelementptr i8, ptr %result.i183.i554, i64 24
  store ptr null, ptr %1072, align 8
  %1073 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i554)
  store ptr @union_typ, ptr %result.i183.i554, align 8
  %result.i185.i556 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i554, ptr %result.i185.i556, align 8
  %1074 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i556)
  store ptr @Array, ptr %30, align 8
  store ptr %result.i185.i556, ptr %145, align 8
  store i32 9, ptr %146, align 8
  %1075 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %30)
  %1076 = getelementptr i8, ptr %result.i185.i556, i64 16
  store i32 %1048, ptr %1076, align 4
  %1077 = getelementptr i8, ptr %result.i185.i556, i64 20
  store i32 %1048, ptr %1077, align 4
  %result.i.i430.i557 = call noalias ptr @bump_malloc_inner(i64 noundef %1062, ptr nonnull @current_ptr) #29
  %1078 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1079 = getelementptr i8, ptr %result.i185.i556, i64 8
  store ptr %result.i.i430.i557, ptr %1079, align 8
  %1080 = load ptr, ptr %147, align 8
  store ptr @Array, ptr %105, align 8
  store ptr %result.i185.i556, ptr %106, align 8
  store ptr %1080, ptr %107, align 8
  store i32 9, ptr %108, align 4
  store i32 0, ptr %109, align 4
  %1081 = icmp sgt i32 %.reg2mem91.0.lcssa.i537, 0
  br i1 %1081, label %.lr.ph400.i570, label %HashMap_resize_.exit643

.lr.ph400.i570:                                   ; preds = %._crit_edge395.i536
  %1082 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1083 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1084 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i572

._crit_edge2.i572:                                ; preds = %._crit_edge2.i572, %.lr.ph400.i570
  %.reg2mem77.0398.i573 = phi i32 [ 0, %.lr.ph400.i570 ], [ %1098, %._crit_edge2.i572 ]
  %1085 = zext nneg i32 %.reg2mem77.0398.i573 to i64
  %1086 = shl nuw nsw i64 %1085, 5
  %1087 = getelementptr i8, ptr %result.i.i.i522, i64 %1086
  %1088 = load ptr, ptr %1087, align 8
  %1089 = getelementptr i8, ptr %1087, i64 8
  %1090 = load i160, ptr %1089, align 4
  %.sroa.3362.8.extract.trunc.i576 = trunc i160 %1090 to i64
  %1091 = inttoptr i64 %.sroa.3362.8.extract.trunc.i576 to ptr
  %.sroa.5363.8.extract.shift.i577 = lshr i160 %1090, 64
  %.sroa.5363.8.extract.trunc.i578 = trunc i160 %.sroa.5363.8.extract.shift.i577 to i64
  %1092 = inttoptr i64 %.sroa.5363.8.extract.trunc.i578 to ptr
  %hash_coef_ptr.i.i201.i579 = getelementptr i8, ptr %1088, i64 8
  %tbl_size_ptr.i.i202.i580 = getelementptr i8, ptr %1088, i64 16
  %offset_tbl_ptr.i.i203.i581 = getelementptr i8, ptr %1088, i64 40
  %hash_coef.i.i232.i582 = load i64, ptr %hash_coef_ptr.i.i201.i579, align 4
  %tbl_size.i.i233.i583 = load i64, ptr %tbl_size_ptr.i.i202.i580, align 4
  %offset_tbl.i.i234.i584 = load ptr, ptr %offset_tbl_ptr.i.i203.i581, align 8
  %product.i.i.i235.i585 = mul i64 %hash_coef.i.i232.i582, 4015701072841558310
  %shifted.i.i.i236.i586 = lshr i64 %product.i.i.i235.i585, 32
  %xored.i.i.i237.i587 = xor i64 %shifted.i.i.i236.i586, %product.i.i.i235.i585
  %hash.i.i.i238.i588 = and i64 %xored.i.i.i237.i587, %tbl_size.i.i233.i583
  %offset_ptr.i.i239.i589 = getelementptr i32, ptr %offset_tbl.i.i234.i584, i64 %hash.i.i.i238.i588
  %offset.i.i240.i590 = load i32, ptr %offset_ptr.i.i239.i589, align 4
  %1093 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1088, 0
  %1094 = insertvalue { ptr, ptr, ptr, i32 } %1093, ptr %1091, 1
  %1095 = insertvalue { ptr, ptr, ptr, i32 } %1094, ptr %1092, 2
  %1096 = insertvalue { ptr, ptr, ptr, i32 } %1095, i32 %offset.i.i240.i590, 3
  %1097 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1096)
  %1098 = add nuw nsw i32 %.reg2mem77.0398.i573, 1
  %1099 = icmp slt i32 %1098, %.reg2mem91.0.lcssa.i537
  br i1 %1099, label %._crit_edge2.i572, label %HashMap_resize_.exit643

HashMap_resize_.exit643:                          ; preds = %._crit_edge2.i572, %._crit_edge395.i536
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %30)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i644)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i646)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %24)
  %1100 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1101 = load i32, ptr %111, align 4
  %1102 = icmp sgt i32 %1101, 0
  br i1 %1102, label %.lr.ph.i681, label %._crit_edge1.1.i

.lr.ph.i681:                                      ; preds = %HashMap_resize_.exit643
  %1103 = lshr i160 %959, 64
  %1104 = insertelement <2 x i160> poison, i160 %1103, i64 0
  %1105 = insertelement <2 x i160> %1104, i160 %959, i64 1
  %1106 = trunc <2 x i160> %1105 to <2 x i64>
  %1107 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1108 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1109

1109:                                             ; preds = %.cont.cont.i735, %.lr.ph.i681
  %offset.i.i260.i7521135 = phi i32 [ 9, %.lr.ph.i681 ], [ %offset.i.i260.i752, %.cont.cont.i735 ]
  %.reg2mem195.0678.i683 = phi i32 [ 1, %.lr.ph.i681 ], [ %1264, %.cont.cont.i735 ]
  %.reg2mem193.0677.i684 = phi i32 [ 0, %.lr.ph.i681 ], [ %1269, %.cont.cont.i735 ]
  %1110 = phi <2 x i64> [ %1106, %.lr.ph.i681 ], [ %1268, %.cont.cont.i735 ]
  %1111 = extractelement <2 x i64> %1110, i64 1
  %.sroa.speculated352.i7391131 = inttoptr i64 %1111 to ptr
  %1112 = extractelement <2 x i64> %1110, i64 0
  %.sroa.speculated346.i7401133 = inttoptr i64 %1112 to ptr
  %1113 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i7391131, 1
  %1114 = insertvalue { ptr, ptr, ptr, i32 } %1113, ptr %.sroa.speculated346.i7401133, 2
  %1115 = insertvalue { ptr, ptr, ptr, i32 } %1114, i32 %offset.i.i260.i7521135, 3
  %1116 = sext i32 %offset.i.i260.i7521135 to i64
  %gep1129 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1116
  %1117 = load ptr, ptr %gep1129, align 8
  %1118 = call ptr %1117({ ptr, ptr, ptr, i32 } %1115, ptr nonnull %2)
  %1119 = call i32 %1118({ ptr, ptr, ptr, i32 } %1115, { ptr, ptr, ptr, i32 } %1115, ptr nonnull %2)
  %1120 = icmp eq i32 %.reg2mem195.0678.i683, 1
  %1121 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1120, label %1122, label %1184

1122:                                             ; preds = %1109
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1123 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1124 = load ptr, ptr %90, align 8
  %1125 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1124, 0
  %1126 = load ptr, ptr %91, align 8
  %1127 = insertvalue { ptr, ptr, ptr, i32 } %1125, ptr %1126, 1
  %1128 = load ptr, ptr %92, align 8
  %1129 = insertvalue { ptr, ptr, ptr, i32 } %1127, ptr %1128, 2
  %1130 = load i32, ptr %93, align 4
  %1131 = insertvalue { ptr, ptr, ptr, i32 } %1129, i32 %1130, 3
  %hash_coef_ptr.i.i10.i1395 = getelementptr i8, ptr %1124, i64 8
  %tbl_size_ptr.i.i11.i1396 = getelementptr i8, ptr %1124, i64 16
  %offset_tbl_ptr.i.i12.i1397 = getelementptr i8, ptr %1124, i64 40
  %hash_coef.i.i13.i1398 = load i64, ptr %hash_coef_ptr.i.i10.i1395, align 4
  %tbl_size.i.i14.i1399 = load i64, ptr %tbl_size_ptr.i.i11.i1396, align 4
  %offset_tbl.i.i15.i1400 = load ptr, ptr %offset_tbl_ptr.i.i12.i1397, align 8
  %product.i.i.i16.i1401 = mul i64 %hash_coef.i.i13.i1398, -5261542750394134544
  %shifted.i.i.i17.i1402 = lshr i64 %product.i.i.i16.i1401, 32
  %xored.i.i.i18.i1403 = xor i64 %shifted.i.i.i17.i1402, %product.i.i.i16.i1401
  %hash.i.i.i19.i1404 = and i64 %xored.i.i.i18.i1403, %tbl_size.i.i14.i1399
  %offset_ptr.i.i20.i1405 = getelementptr i32, ptr %offset_tbl.i.i15.i1400, i64 %hash.i.i.i19.i1404
  %offset.i.i21.i1406 = load i32, ptr %offset_ptr.i.i20.i1405, align 4
  %eq.i.i1407 = icmp eq i32 %1130, %offset.i.i21.i1406
  call void @llvm.assume(i1 %eq.i.i1407) #30
  %1132 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1133 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1124)
  %1134 = sext i32 %1130 to i64
  %1135 = getelementptr ptr, ptr %1124, i64 %1134
  %1136 = getelementptr i8, ptr %1135, i64 64
  %1137 = load ptr, ptr %1136, align 8
  %1138 = call ptr %1137({ ptr, ptr, ptr, i32 } %1131, ptr nonnull %2)
  %1139 = call i32 %1138({ ptr, ptr, ptr, i32 } %1131, { ptr, ptr, ptr, i32 } %1131, ptr nonnull %2)
  %1140 = add i32 %1139, -1
  %1141 = and i32 %1140, %1119
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1142 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1143 = load ptr, ptr %90, align 8
  %1144 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1143, 0
  %1145 = load ptr, ptr %91, align 8
  %1146 = insertvalue { ptr, ptr, ptr, i32 } %1144, ptr %1145, 1
  %1147 = load ptr, ptr %92, align 8
  %1148 = insertvalue { ptr, ptr, ptr, i32 } %1146, ptr %1147, 2
  %1149 = load i32, ptr %93, align 4
  %1150 = insertvalue { ptr, ptr, ptr, i32 } %1148, i32 %1149, 3
  %hash_coef_ptr.i.i172.i757 = getelementptr i8, ptr %1143, i64 8
  %tbl_size_ptr.i.i173.i758 = getelementptr i8, ptr %1143, i64 16
  %offset_tbl_ptr.i.i174.i759 = getelementptr i8, ptr %1143, i64 40
  %hash_coef.i.i175.i760 = load i64, ptr %hash_coef_ptr.i.i172.i757, align 4
  %tbl_size.i.i176.i761 = load i64, ptr %tbl_size_ptr.i.i173.i758, align 4
  %offset_tbl.i.i177.i762 = load ptr, ptr %offset_tbl_ptr.i.i174.i759, align 8
  %product.i.i.i178.i763 = mul i64 %hash_coef.i.i175.i760, -5261542750394134544
  %shifted.i.i.i179.i764 = lshr i64 %product.i.i.i178.i763, 32
  %xored.i.i.i180.i765 = xor i64 %shifted.i.i.i179.i764, %product.i.i.i178.i763
  %hash.i.i.i181.i766 = and i64 %xored.i.i.i180.i765, %tbl_size.i.i176.i761
  %offset_ptr.i.i182.i767 = getelementptr i32, ptr %offset_tbl.i.i177.i762, i64 %hash.i.i.i181.i766
  %offset.i.i183.i768 = load i32, ptr %offset_ptr.i.i182.i767, align 4
  %eq.i.i769 = icmp eq i32 %1149, %offset.i.i183.i768
  call void @llvm.assume(i1 %eq.i.i769) #30
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  %1151 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %9)
  %1152 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1143)
  %1153 = sext i32 %1149 to i64
  %1154 = getelementptr ptr, ptr %1143, i64 %1153
  %1155 = getelementptr i8, ptr %1154, i64 120
  %1156 = load ptr, ptr %1155, align 8
  store ptr @i32_typ, ptr %10, align 8
  %1157 = call ptr %1156({ ptr, ptr, ptr, i32 } %1150, ptr nonnull %10)
  %1158 = call { ptr, i160 } %1157({ ptr, ptr, ptr, i32 } %1150, { ptr, ptr, ptr, i32 } %1150, ptr nonnull %9, i32 %1141)
  %.fca.0.extract112.i770 = extractvalue { ptr, i160 } %1158, 0
  %.sroa.3111.0.insert.ext.i771 = zext i32 %offset.i.i260.i7521135 to i160
  %.sroa.3111.0.insert.shift.i772 = shl nuw i160 %.sroa.3111.0.insert.ext.i771, 128
  %.sroa.2110.0.insert.ext.i773 = zext i64 %1112 to i160
  %.sroa.2110.0.insert.shift.i774 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i773, 64
  %.sroa.2110.0.insert.insert.i775 = or disjoint i160 %.sroa.2110.0.insert.shift.i774, %.sroa.3111.0.insert.shift.i772
  %.sroa.0109.0.insert.ext.i776 = zext i64 %1111 to i160
  %.sroa.0109.0.insert.insert.i777 = or disjoint i160 %.sroa.2110.0.insert.insert.i775, %.sroa.0109.0.insert.ext.i776
  %1159 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i777, 1
  %1160 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1161 = load ptr, ptr %90, align 8
  %1162 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1161, 0
  %1163 = load ptr, ptr %91, align 8
  %1164 = insertvalue { ptr, ptr, ptr, i32 } %1162, ptr %1163, 1
  %1165 = load ptr, ptr %92, align 8
  %1166 = insertvalue { ptr, ptr, ptr, i32 } %1164, ptr %1165, 2
  %1167 = load i32, ptr %93, align 4
  %1168 = insertvalue { ptr, ptr, ptr, i32 } %1166, i32 %1167, 3
  %hash_coef_ptr.i.i186.i782 = getelementptr i8, ptr %1161, i64 8
  %tbl_size_ptr.i.i187.i783 = getelementptr i8, ptr %1161, i64 16
  %offset_tbl_ptr.i.i188.i784 = getelementptr i8, ptr %1161, i64 40
  %hash_coef.i.i189.i785 = load i64, ptr %hash_coef_ptr.i.i186.i782, align 4
  %tbl_size.i.i190.i786 = load i64, ptr %tbl_size_ptr.i.i187.i783, align 4
  %offset_tbl.i.i191.i787 = load ptr, ptr %offset_tbl_ptr.i.i188.i784, align 8
  %product.i.i.i192.i788 = mul i64 %hash_coef.i.i189.i785, -5261542750394134544
  %shifted.i.i.i193.i789 = lshr i64 %product.i.i.i192.i788, 32
  %xored.i.i.i194.i790 = xor i64 %shifted.i.i.i193.i789, %product.i.i.i192.i788
  %hash.i.i.i195.i791 = and i64 %xored.i.i.i194.i790, %tbl_size.i.i190.i786
  %offset_ptr.i.i196.i792 = getelementptr i32, ptr %offset_tbl.i.i191.i787, i64 %hash.i.i.i195.i791
  %offset.i.i197.i793 = load i32, ptr %offset_ptr.i.i196.i792, align 4
  %eq.i200.i794 = icmp eq i32 %1167, %offset.i.i197.i793
  call void @llvm.assume(i1 %eq.i200.i794) #30
  %1169 = load ptr, ptr %result.i, align 8
  %1170 = load ptr, ptr %73, align 8
  %result.i.i795 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1171 = getelementptr i8, ptr %result.i.i795, i64 16
  store ptr %1170, ptr %1171, align 8
  %1172 = getelementptr i8, ptr %result.i.i795, i64 8
  store ptr %1169, ptr %1172, align 8
  %1173 = getelementptr i8, ptr %result.i.i795, i64 24
  store ptr null, ptr %1173, align 8
  %1174 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i795)
  store ptr @Entry, ptr %result.i.i795, align 8
  store ptr @_parameterization_Ptri32, ptr %11, align 8
  store ptr %result.i.i795, ptr %150, align 8
  %1175 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %11)
  %1176 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1161)
  %1177 = sext i32 %1167 to i64
  %1178 = getelementptr ptr, ptr %1161, i64 %1177
  %1179 = getelementptr i8, ptr %1178, i64 128
  %1180 = load ptr, ptr %1179, align 8
  store ptr @i32_typ, ptr %12, align 8
  store ptr @Entry, ptr %151, align 8
  %1181 = call ptr %1180({ ptr, ptr, ptr, i32 } %1168, ptr nonnull %12)
  call void %1181({ ptr, ptr, ptr, i32 } %1168, { ptr, ptr, ptr, i32 } %1168, ptr nonnull %11, i32 %1141, { ptr, i160 } %1159)
  %1182 = icmp ne ptr %.fca.0.extract112.i770, @nil_typ
  %1183 = icmp ne ptr %.fca.0.extract112.i770, null
  %.not140.i796 = and i1 %1182, %1183
  br i1 %.not140.i796, label %.cont.cont.i735, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit802.thread

1184:                                             ; preds = %1109
  %1185 = add i32 %1119, 2127912214
  %1186 = shl i32 %1119, 12
  %1187 = add i32 %1185, %1186
  %1188 = ashr i32 %1187, 19
  %1189 = xor i32 %1187, %1188
  %1190 = xor i32 %1189, -949894596
  %1191 = add i32 %1190, 374761393
  %1192 = shl i32 %1190, 5
  %1193 = add i32 %1191, %1192
  %1194 = add i32 %1193, -744332180
  %1195 = shl i32 %1193, 9
  %1196 = xor i32 %1194, %1195
  %1197 = add i32 %1196, -42973499
  %1198 = shl i32 %1196, 3
  %1199 = add i32 %1197, %1198
  %1200 = ashr i32 %1199, 16
  %1201 = xor i32 %1199, %1200
  %1202 = xor i32 %1201, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1203 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1204 = load ptr, ptr %105, align 8
  %1205 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1204, 0
  %1206 = load ptr, ptr %106, align 8
  %1207 = insertvalue { ptr, ptr, ptr, i32 } %1205, ptr %1206, 1
  %1208 = load ptr, ptr %107, align 8
  %1209 = insertvalue { ptr, ptr, ptr, i32 } %1207, ptr %1208, 2
  %1210 = load i32, ptr %108, align 4
  %1211 = insertvalue { ptr, ptr, ptr, i32 } %1209, i32 %1210, 3
  %hash_coef_ptr.i.i10.i1425 = getelementptr i8, ptr %1204, i64 8
  %tbl_size_ptr.i.i11.i1426 = getelementptr i8, ptr %1204, i64 16
  %offset_tbl_ptr.i.i12.i1427 = getelementptr i8, ptr %1204, i64 40
  %hash_coef.i.i13.i1428 = load i64, ptr %hash_coef_ptr.i.i10.i1425, align 4
  %tbl_size.i.i14.i1429 = load i64, ptr %tbl_size_ptr.i.i11.i1426, align 4
  %offset_tbl.i.i15.i1430 = load ptr, ptr %offset_tbl_ptr.i.i12.i1427, align 8
  %product.i.i.i16.i1431 = mul i64 %hash_coef.i.i13.i1428, -5261542750394134544
  %shifted.i.i.i17.i1432 = lshr i64 %product.i.i.i16.i1431, 32
  %xored.i.i.i18.i1433 = xor i64 %shifted.i.i.i17.i1432, %product.i.i.i16.i1431
  %hash.i.i.i19.i1434 = and i64 %xored.i.i.i18.i1433, %tbl_size.i.i14.i1429
  %offset_ptr.i.i20.i1435 = getelementptr i32, ptr %offset_tbl.i.i15.i1430, i64 %hash.i.i.i19.i1434
  %offset.i.i21.i1436 = load i32, ptr %offset_ptr.i.i20.i1435, align 4
  %eq.i.i1437 = icmp eq i32 %1210, %offset.i.i21.i1436
  call void @llvm.assume(i1 %eq.i.i1437) #30
  %1212 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1213 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1204)
  %1214 = sext i32 %1210 to i64
  %1215 = getelementptr ptr, ptr %1204, i64 %1214
  %1216 = getelementptr i8, ptr %1215, i64 64
  %1217 = load ptr, ptr %1216, align 8
  %1218 = call ptr %1217({ ptr, ptr, ptr, i32 } %1211, ptr nonnull %2)
  %1219 = call i32 %1218({ ptr, ptr, ptr, i32 } %1211, { ptr, ptr, ptr, i32 } %1211, ptr nonnull %2)
  %1220 = add i32 %1219, -1
  %1221 = and i32 %1220, %1202
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1222 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1223 = load ptr, ptr %105, align 8
  %1224 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1223, 0
  %1225 = load ptr, ptr %106, align 8
  %1226 = insertvalue { ptr, ptr, ptr, i32 } %1224, ptr %1225, 1
  %1227 = load ptr, ptr %107, align 8
  %1228 = insertvalue { ptr, ptr, ptr, i32 } %1226, ptr %1227, 2
  %1229 = load i32, ptr %108, align 4
  %1230 = insertvalue { ptr, ptr, ptr, i32 } %1228, i32 %1229, 3
  %hash_coef_ptr.i.i202.i689 = getelementptr i8, ptr %1223, i64 8
  %tbl_size_ptr.i.i203.i690 = getelementptr i8, ptr %1223, i64 16
  %offset_tbl_ptr.i.i204.i691 = getelementptr i8, ptr %1223, i64 40
  %hash_coef.i.i205.i692 = load i64, ptr %hash_coef_ptr.i.i202.i689, align 4
  %tbl_size.i.i206.i693 = load i64, ptr %tbl_size_ptr.i.i203.i690, align 4
  %offset_tbl.i.i207.i694 = load ptr, ptr %offset_tbl_ptr.i.i204.i691, align 8
  %product.i.i.i208.i695 = mul i64 %hash_coef.i.i205.i692, -5261542750394134544
  %shifted.i.i.i209.i696 = lshr i64 %product.i.i.i208.i695, 32
  %xored.i.i.i210.i697 = xor i64 %shifted.i.i.i209.i696, %product.i.i.i208.i695
  %hash.i.i.i211.i698 = and i64 %xored.i.i.i210.i697, %tbl_size.i.i206.i693
  %offset_ptr.i.i212.i699 = getelementptr i32, ptr %offset_tbl.i.i207.i694, i64 %hash.i.i.i211.i698
  %offset.i.i213.i700 = load i32, ptr %offset_ptr.i.i212.i699, align 4
  %eq.i216.i701 = icmp eq i32 %1229, %offset.i.i213.i700
  call void @llvm.assume(i1 %eq.i216.i701) #30
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %1231 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %17)
  %1232 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1223)
  %1233 = sext i32 %1229 to i64
  %1234 = getelementptr ptr, ptr %1223, i64 %1233
  %1235 = getelementptr i8, ptr %1234, i64 120
  %1236 = load ptr, ptr %1235, align 8
  store ptr @i32_typ, ptr %18, align 8
  %1237 = call ptr %1236({ ptr, ptr, ptr, i32 } %1230, ptr nonnull %18)
  %1238 = call { ptr, i160 } %1237({ ptr, ptr, ptr, i32 } %1230, { ptr, ptr, ptr, i32 } %1230, ptr nonnull %17, i32 %1221)
  %.fca.0.extract87.i702 = extractvalue { ptr, i160 } %1238, 0
  %.sroa.3.0.insert.ext.i703 = zext i32 %offset.i.i260.i7521135 to i160
  %.sroa.3.0.insert.shift.i704 = shl nuw i160 %.sroa.3.0.insert.ext.i703, 128
  %.sroa.2.0.insert.ext.i705 = zext i64 %1112 to i160
  %.sroa.2.0.insert.shift.i706 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i705, 64
  %.sroa.2.0.insert.insert.i707 = or disjoint i160 %.sroa.2.0.insert.shift.i706, %.sroa.3.0.insert.shift.i704
  %.sroa.0.0.insert.ext.i708 = zext i64 %1111 to i160
  %.sroa.0.0.insert.insert.i709 = or disjoint i160 %.sroa.2.0.insert.insert.i707, %.sroa.0.0.insert.ext.i708
  %1239 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i709, 1
  %1240 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1241 = load ptr, ptr %105, align 8
  %1242 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1241, 0
  %1243 = load ptr, ptr %106, align 8
  %1244 = insertvalue { ptr, ptr, ptr, i32 } %1242, ptr %1243, 1
  %1245 = load ptr, ptr %107, align 8
  %1246 = insertvalue { ptr, ptr, ptr, i32 } %1244, ptr %1245, 2
  %1247 = load i32, ptr %108, align 4
  %1248 = insertvalue { ptr, ptr, ptr, i32 } %1246, i32 %1247, 3
  %hash_coef_ptr.i.i218.i714 = getelementptr i8, ptr %1241, i64 8
  %tbl_size_ptr.i.i219.i715 = getelementptr i8, ptr %1241, i64 16
  %offset_tbl_ptr.i.i220.i716 = getelementptr i8, ptr %1241, i64 40
  %hash_coef.i.i221.i717 = load i64, ptr %hash_coef_ptr.i.i218.i714, align 4
  %tbl_size.i.i222.i718 = load i64, ptr %tbl_size_ptr.i.i219.i715, align 4
  %offset_tbl.i.i223.i719 = load ptr, ptr %offset_tbl_ptr.i.i220.i716, align 8
  %product.i.i.i224.i720 = mul i64 %hash_coef.i.i221.i717, -5261542750394134544
  %shifted.i.i.i225.i721 = lshr i64 %product.i.i.i224.i720, 32
  %xored.i.i.i226.i722 = xor i64 %shifted.i.i.i225.i721, %product.i.i.i224.i720
  %hash.i.i.i227.i723 = and i64 %xored.i.i.i226.i722, %tbl_size.i.i222.i718
  %offset_ptr.i.i228.i724 = getelementptr i32, ptr %offset_tbl.i.i223.i719, i64 %hash.i.i.i227.i723
  %offset.i.i229.i725 = load i32, ptr %offset_ptr.i.i228.i724, align 4
  %eq.i232.i726 = icmp eq i32 %1247, %offset.i.i229.i725
  call void @llvm.assume(i1 %eq.i232.i726) #30
  %1249 = load ptr, ptr %result.i, align 8
  %1250 = load ptr, ptr %73, align 8
  %result.i233.i727 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1251 = getelementptr i8, ptr %result.i233.i727, i64 16
  store ptr %1250, ptr %1251, align 8
  %1252 = getelementptr i8, ptr %result.i233.i727, i64 8
  store ptr %1249, ptr %1252, align 8
  %1253 = getelementptr i8, ptr %result.i233.i727, i64 24
  store ptr null, ptr %1253, align 8
  %1254 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i727)
  store ptr @Entry, ptr %result.i233.i727, align 8
  store ptr @_parameterization_Ptri32, ptr %19, align 8
  store ptr %result.i233.i727, ptr %148, align 8
  %1255 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %19)
  %1256 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1241)
  %1257 = sext i32 %1247 to i64
  %1258 = getelementptr ptr, ptr %1241, i64 %1257
  %1259 = getelementptr i8, ptr %1258, i64 128
  %1260 = load ptr, ptr %1259, align 8
  store ptr @i32_typ, ptr %20, align 8
  store ptr @Entry, ptr %149, align 8
  %1261 = call ptr %1260({ ptr, ptr, ptr, i32 } %1248, ptr nonnull %20)
  call void %1261({ ptr, ptr, ptr, i32 } %1248, { ptr, ptr, ptr, i32 } %1248, ptr nonnull %19, i32 %1221, { ptr, i160 } %1239)
  %1262 = icmp ne ptr %.fca.0.extract87.i702, @nil_typ
  %1263 = icmp ne ptr %.fca.0.extract87.i702, null
  %.not138.i728 = and i1 %1262, %1263
  br i1 %.not138.i728, label %.cont.cont.i735, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit802.thread

.cont.cont.i735:                                  ; preds = %1184, %1122
  %.sink1145 = phi { ptr, i160 } [ %1158, %1122 ], [ %1238, %1184 ]
  %1264 = phi i32 [ 2, %1122 ], [ 1, %1184 ]
  %vptr.i248.sroa.speculated.i738 = phi ptr [ %.fca.0.extract112.i770, %1122 ], [ %.fca.0.extract87.i702, %1184 ]
  %.fca.1.extract89.i731 = extractvalue { ptr, i160 } %.sink1145, 1
  %.sroa.3407.sroa.4.0.extract.shift.i732 = lshr i160 %.fca.1.extract89.i731, 64
  %1265 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i732 to i64
  %1266 = insertelement <2 x i64> poison, i64 %1265, i64 0
  %1267 = trunc i160 %.fca.1.extract89.i731 to i64
  %1268 = insertelement <2 x i64> %1266, i64 %1267, i64 1
  %hash_coef_ptr.i.i249.i741 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i738, i64 8
  %tbl_size_ptr.i.i250.i742 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i738, i64 16
  %offset_tbl_ptr.i.i251.i743 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i738, i64 40
  %hash_coef.i.i252.i744 = load i64, ptr %hash_coef_ptr.i.i249.i741, align 4
  %tbl_size.i.i253.i745 = load i64, ptr %tbl_size_ptr.i.i250.i742, align 4
  %offset_tbl.i.i254.i746 = load ptr, ptr %offset_tbl_ptr.i.i251.i743, align 8
  %product.i.i.i255.i747 = mul i64 %hash_coef.i.i252.i744, 4015701072841558310
  %shifted.i.i.i256.i748 = lshr i64 %product.i.i.i255.i747, 32
  %xored.i.i.i257.i749 = xor i64 %shifted.i.i.i256.i748, %product.i.i.i255.i747
  %hash.i.i.i258.i750 = and i64 %xored.i.i.i257.i749, %tbl_size.i.i253.i745
  %offset_ptr.i.i259.i751 = getelementptr i32, ptr %offset_tbl.i.i254.i746, i64 %hash.i.i.i258.i750
  %offset.i.i260.i752 = load i32, ptr %offset_ptr.i.i259.i751, align 4
  %1269 = add nuw nsw i32 %.reg2mem193.0677.i684, 1
  %1270 = load i32, ptr %111, align 4
  %1271 = icmp slt i32 %1269, %1270
  br i1 %1271, label %1109, label %._crit_edge1.1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit802.thread: ; preds = %1122, %1184
  %1272 = phi ptr [ %21, %1184 ], [ %13, %1122 ]
  %1273 = phi ptr [ %22, %1184 ], [ %14, %1122 ]
  %1274 = phi ptr [ %23, %1184 ], [ %15, %1122 ]
  %1275 = phi ptr [ %.sroa.0.i646, %1184 ], [ %.sroa.0680.i644, %1122 ]
  %1276 = phi ptr [ %24, %1184 ], [ %16, %1122 ]
  %1277 = load i32, ptr %109, align 4
  store i32 %1277, ptr %1272, align 4
  store i32 1, ptr %1273, align 4
  %1278 = add i32 %1277, 1
  store i32 %1278, ptr %1274, align 4
  %1279 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1278, ptr %109, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1276, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1275, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i644)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i646)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.1.i:                                 ; preds = %.cont.cont.i735, %HashMap_resize_.exit643
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i644)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i646)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %8)
  %1280 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1281 = load ptr, ptr %90, align 8
  %1282 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1281, 0
  %1283 = load ptr, ptr %91, align 8
  %1284 = insertvalue { ptr, ptr, ptr, i32 } %1282, ptr %1283, 1
  %1285 = load ptr, ptr %92, align 8
  %1286 = insertvalue { ptr, ptr, ptr, i32 } %1284, ptr %1285, 2
  %1287 = load i32, ptr %93, align 4
  %1288 = insertvalue { ptr, ptr, ptr, i32 } %1286, i32 %1287, 3
  %hash_coef_ptr.i.i64.i820 = getelementptr i8, ptr %1281, i64 8
  %tbl_size_ptr.i.i65.i821 = getelementptr i8, ptr %1281, i64 16
  %offset_tbl_ptr.i.i66.i822 = getelementptr i8, ptr %1281, i64 40
  %hash_coef.i.i67.i823 = load i64, ptr %hash_coef_ptr.i.i64.i820, align 4
  %tbl_size.i.i68.i824 = load i64, ptr %tbl_size_ptr.i.i65.i821, align 4
  %offset_tbl.i.i69.i825 = load ptr, ptr %offset_tbl_ptr.i.i66.i822, align 8
  %product.i.i.i70.i826 = mul i64 %hash_coef.i.i67.i823, -5261542750394134544
  %shifted.i.i.i71.i827 = lshr i64 %product.i.i.i70.i826, 32
  %xored.i.i.i72.i828 = xor i64 %shifted.i.i.i71.i827, %product.i.i.i70.i826
  %hash.i.i.i73.i829 = and i64 %xored.i.i.i72.i828, %tbl_size.i.i68.i824
  %offset_ptr.i.i74.i830 = getelementptr i32, ptr %offset_tbl.i.i69.i825, i64 %hash.i.i.i73.i829
  %offset.i.i75.i831 = load i32, ptr %offset_ptr.i.i74.i830, align 4
  %eq.i.i832 = icmp eq i32 %1287, %offset.i.i75.i831
  call void @llvm.assume(i1 %eq.i.i832) #30
  %1289 = load ptr, ptr %105, align 8
  %1290 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1289, 0
  %1291 = load ptr, ptr %106, align 8
  %1292 = insertvalue { ptr, ptr, ptr, i32 } %1290, ptr %1291, 1
  %1293 = load ptr, ptr %107, align 8
  %1294 = insertvalue { ptr, ptr, ptr, i32 } %1292, ptr %1293, 2
  %1295 = load i32, ptr %108, align 4
  %1296 = insertvalue { ptr, ptr, ptr, i32 } %1294, i32 %1295, 3
  %hash_coef_ptr.i.i92.i837 = getelementptr i8, ptr %1289, i64 8
  %tbl_size_ptr.i.i93.i838 = getelementptr i8, ptr %1289, i64 16
  %offset_tbl_ptr.i.i94.i839 = getelementptr i8, ptr %1289, i64 40
  %hash_coef.i.i95.i840 = load i64, ptr %hash_coef_ptr.i.i92.i837, align 4
  %tbl_size.i.i96.i841 = load i64, ptr %tbl_size_ptr.i.i93.i838, align 4
  %offset_tbl.i.i97.i842 = load ptr, ptr %offset_tbl_ptr.i.i94.i839, align 8
  %product.i.i.i98.i843 = mul i64 %hash_coef.i.i95.i840, -5261542750394134544
  %shifted.i.i.i99.i844 = lshr i64 %product.i.i.i98.i843, 32
  %xored.i.i.i100.i845 = xor i64 %shifted.i.i.i99.i844, %product.i.i.i98.i843
  %hash.i.i.i101.i846 = and i64 %xored.i.i.i100.i845, %tbl_size.i.i96.i841
  %offset_ptr.i.i102.i847 = getelementptr i32, ptr %offset_tbl.i.i97.i842, i64 %hash.i.i.i101.i846
  %offset.i.i103.i848 = load i32, ptr %offset_ptr.i.i102.i847, align 4
  %eq.i106.i849 = icmp eq i32 %1295, %offset.i.i103.i848
  call void @llvm.assume(i1 %eq.i106.i849) #30
  %1297 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1298 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1281)
  %1299 = sext i32 %1287 to i64
  %1300 = getelementptr ptr, ptr %1281, i64 %1299
  %1301 = getelementptr i8, ptr %1300, i64 64
  %1302 = load ptr, ptr %1301, align 8
  %1303 = call ptr %1302({ ptr, ptr, ptr, i32 } %1288, ptr nonnull %2)
  %1304 = call i32 %1303({ ptr, ptr, ptr, i32 } %1288, { ptr, ptr, ptr, i32 } %1288, ptr nonnull %2)
  %1305 = shl i32 %1304, 1
  %1306 = load i32, ptr %109, align 4
  %1307 = load ptr, ptr %result.i, align 8
  %1308 = load ptr, ptr %73, align 8
  %1309 = sext i32 %1306 to i64
  %1310 = shl nsw i64 %1309, 5
  %result.i.i.i852 = call noalias ptr @bump_malloc_inner(i64 noundef %1310, ptr nonnull @current_ptr) #29
  %1311 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1312 = icmp sgt i32 %1304, 0
  br i1 %1312, label %.lr.ph434.i922, label %._crit_edge395.i866

.lr.ph434.i922:                                   ; preds = %._crit_edge1.1.i
  %invariant.gep.i865 = getelementptr i8, ptr %1281, i64 120
  %1313 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i925 = getelementptr ptr, ptr %invariant.gep.i865, i64 %1299
  br label %1314

1314:                                             ; preds = %1336, %.lr.ph434.i922
  %.reg2mem105.0432.i923 = phi i32 [ 0, %.lr.ph434.i922 ], [ %.reg2mem101.0.i928, %1336 ]
  %.reg2mem103.0431.i924 = phi i32 [ 0, %.lr.ph434.i922 ], [ %1337, %1336 ]
  store ptr @_parameterization_Ptri32, ptr %3, align 8
  %1315 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %3)
  %1316 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1281)
  %1317 = load ptr, ptr %gep.i925, align 8
  store ptr @i32_typ, ptr %4, align 8
  %1318 = call ptr %1317({ ptr, ptr, ptr, i32 } %1288, ptr nonnull %4)
  %1319 = call { ptr, i160 } %1318({ ptr, ptr, ptr, i32 } %1288, { ptr, ptr, ptr, i32 } %1288, ptr nonnull %3, i32 %.reg2mem103.0431.i924)
  %.fca.0.extract52.i926 = extractvalue { ptr, i160 } %1319, 0
  %1320 = icmp ne ptr %.fca.0.extract52.i926, @nil_typ
  %1321 = icmp ne ptr %.fca.0.extract52.i926, null
  %.not60.i927 = and i1 %1320, %1321
  br i1 %.not60.i927, label %1322, label %1336

1322:                                             ; preds = %1314
  %hash_coef_ptr.i.i137.i955 = getelementptr i8, ptr %.fca.0.extract52.i926, i64 8
  %tbl_size_ptr.i.i138.i956 = getelementptr i8, ptr %.fca.0.extract52.i926, i64 16
  %offset_tbl_ptr.i.i139.i957 = getelementptr i8, ptr %.fca.0.extract52.i926, i64 40
  %hash_coef.i.i140.i958 = load i64, ptr %hash_coef_ptr.i.i137.i955, align 4
  %tbl_size.i.i141.i959 = load i64, ptr %tbl_size_ptr.i.i138.i956, align 4
  %offset_tbl.i.i142.i960 = load ptr, ptr %offset_tbl_ptr.i.i139.i957, align 8
  %product.i.i.i143.i961 = mul i64 %hash_coef.i.i140.i958, 4015701072841558310
  %shifted.i.i.i144.i962 = lshr i64 %product.i.i.i143.i961, 32
  %xored.i.i.i145.i963 = xor i64 %shifted.i.i.i144.i962, %product.i.i.i143.i961
  %hash.i.i.i146.i964 = and i64 %xored.i.i.i145.i963, %tbl_size.i.i141.i959
  %offset_ptr.i.i147.i965 = getelementptr i32, ptr %offset_tbl.i.i142.i960, i64 %hash.i.i.i146.i964
  %offset.i.i148.i966 = load i32, ptr %offset_ptr.i.i147.i965, align 4
  %1323 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1324 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1325 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1326 = icmp slt i32 %.reg2mem105.0432.i923, %1306
  br i1 %1326, label %1327, label %._crit_edge.i967

1327:                                             ; preds = %1322
  %.fca.1.extract54.i968 = extractvalue { ptr, i160 } %1319, 1
  %.sroa.351.0.insert.ext.i969 = zext i32 %offset.i.i148.i966 to i160
  %.sroa.351.0.insert.shift.i970 = shl nuw i160 %.sroa.351.0.insert.ext.i969, 128
  %1328 = and i160 %.fca.1.extract54.i968, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i971 = or disjoint i160 %.sroa.351.0.insert.shift.i970, %1328
  %1329 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1330 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1331 = sext i32 %.reg2mem105.0432.i923 to i64
  %1332 = shl nsw i64 %1331, 5
  %1333 = getelementptr i8, ptr %result.i.i.i852, i64 %1332
  store ptr %.fca.0.extract52.i926, ptr %1333, align 8
  %1334 = getelementptr i8, ptr %1333, i64 8
  store i160 %.sroa.049.0.insert.insert.i971, ptr %1334, align 4
  br label %._crit_edge.i967

._crit_edge.i967:                                 ; preds = %1327, %1322
  %1335 = add i32 %.reg2mem105.0432.i923, 1
  br label %1336

1336:                                             ; preds = %._crit_edge.i967, %1314
  %.reg2mem101.0.i928 = phi i32 [ %1335, %._crit_edge.i967 ], [ %.reg2mem105.0432.i923, %1314 ]
  %1337 = add nuw nsw i32 %.reg2mem103.0431.i924, 1
  %1338 = icmp slt i32 %1337, %1304
  br i1 %1338, label %1314, label %.lr.ph.i929

.lr.ph.i929:                                      ; preds = %1336
  %invariant.gep396.i930 = getelementptr i8, ptr %1289, i64 120
  %1339 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1340 = sext i32 %1295 to i64
  %gep397.i933 = getelementptr ptr, ptr %invariant.gep396.i930, i64 %1340
  br label %1341

1341:                                             ; preds = %1363, %.lr.ph.i929
  %.reg2mem91.0394.i931 = phi i32 [ %.reg2mem101.0.i928, %.lr.ph.i929 ], [ %.reg2mem87.0.i936, %1363 ]
  %.reg2mem89.0393.i932 = phi i32 [ 0, %.lr.ph.i929 ], [ %1364, %1363 ]
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %1342 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %1343 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1289)
  %1344 = load ptr, ptr %gep397.i933, align 8
  store ptr @i32_typ, ptr %6, align 8
  %1345 = call ptr %1344({ ptr, ptr, ptr, i32 } %1296, ptr nonnull %6)
  %1346 = call { ptr, i160 } %1345({ ptr, ptr, ptr, i32 } %1296, { ptr, ptr, ptr, i32 } %1296, ptr nonnull %5, i32 %.reg2mem89.0393.i932)
  %.fca.0.extract42.i934 = extractvalue { ptr, i160 } %1346, 0
  %1347 = icmp ne ptr %.fca.0.extract42.i934, @nil_typ
  %1348 = icmp ne ptr %.fca.0.extract42.i934, null
  %.not62.i935 = and i1 %1347, %1348
  br i1 %.not62.i935, label %1349, label %1363

1349:                                             ; preds = %1341
  %hash_coef_ptr.i.i152.i937 = getelementptr i8, ptr %.fca.0.extract42.i934, i64 8
  %tbl_size_ptr.i.i153.i938 = getelementptr i8, ptr %.fca.0.extract42.i934, i64 16
  %offset_tbl_ptr.i.i154.i939 = getelementptr i8, ptr %.fca.0.extract42.i934, i64 40
  %hash_coef.i.i155.i940 = load i64, ptr %hash_coef_ptr.i.i152.i937, align 4
  %tbl_size.i.i156.i941 = load i64, ptr %tbl_size_ptr.i.i153.i938, align 4
  %offset_tbl.i.i157.i942 = load ptr, ptr %offset_tbl_ptr.i.i154.i939, align 8
  %product.i.i.i158.i943 = mul i64 %hash_coef.i.i155.i940, 4015701072841558310
  %shifted.i.i.i159.i944 = lshr i64 %product.i.i.i158.i943, 32
  %xored.i.i.i160.i945 = xor i64 %shifted.i.i.i159.i944, %product.i.i.i158.i943
  %hash.i.i.i161.i946 = and i64 %xored.i.i.i160.i945, %tbl_size.i.i156.i941
  %offset_ptr.i.i162.i947 = getelementptr i32, ptr %offset_tbl.i.i157.i942, i64 %hash.i.i.i161.i946
  %offset.i.i163.i948 = load i32, ptr %offset_ptr.i.i162.i947, align 4
  %1350 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1351 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1352 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1353 = icmp slt i32 %.reg2mem91.0394.i931, %1306
  br i1 %1353, label %1354, label %._crit_edge1.i949

1354:                                             ; preds = %1349
  %.fca.1.extract44.i950 = extractvalue { ptr, i160 } %1346, 1
  %.sroa.3.0.insert.ext.i951 = zext i32 %offset.i.i163.i948 to i160
  %.sroa.3.0.insert.shift.i952 = shl nuw i160 %.sroa.3.0.insert.ext.i951, 128
  %1355 = and i160 %.fca.1.extract44.i950, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i953 = or disjoint i160 %.sroa.3.0.insert.shift.i952, %1355
  %1356 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1357 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1358 = sext i32 %.reg2mem91.0394.i931 to i64
  %1359 = shl nsw i64 %1358, 5
  %1360 = getelementptr i8, ptr %result.i.i.i852, i64 %1359
  store ptr %.fca.0.extract42.i934, ptr %1360, align 8
  %1361 = getelementptr i8, ptr %1360, i64 8
  store i160 %.sroa.040.0.insert.insert.i953, ptr %1361, align 4
  br label %._crit_edge1.i949

._crit_edge1.i949:                                ; preds = %1354, %1349
  %1362 = add i32 %.reg2mem91.0394.i931, 1
  br label %1363

1363:                                             ; preds = %._crit_edge1.i949, %1341
  %.reg2mem87.0.i936 = phi i32 [ %1362, %._crit_edge1.i949 ], [ %.reg2mem91.0394.i931, %1341 ]
  %1364 = add nuw nsw i32 %.reg2mem89.0393.i932, 1
  %1365 = icmp slt i32 %1364, %1304
  br i1 %1365, label %1341, label %._crit_edge395.i866.loopexit

._crit_edge395.i866.loopexit:                     ; preds = %1363
  %.pre1186 = load ptr, ptr %result.i, align 8
  %.pre1187 = load ptr, ptr %73, align 8
  br label %._crit_edge395.i866

._crit_edge395.i866:                              ; preds = %._crit_edge395.i866.loopexit, %._crit_edge1.1.i
  %1366 = phi ptr [ %1308, %._crit_edge1.1.i ], [ %.pre1187, %._crit_edge395.i866.loopexit ]
  %1367 = phi ptr [ %1307, %._crit_edge1.1.i ], [ %.pre1186, %._crit_edge395.i866.loopexit ]
  %.reg2mem91.0.lcssa.i867 = phi i32 [ 0, %._crit_edge1.1.i ], [ %.reg2mem87.0.i936, %._crit_edge395.i866.loopexit ]
  %1368 = call i32 @llvm.smax.i32(i32 %1305, i32 16)
  %result.i166.i868 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1369 = getelementptr i8, ptr %result.i166.i868, i64 16
  store ptr @_parameterization_Nil, ptr %1369, align 8
  %result.i167.i869 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1370 = getelementptr i8, ptr %result.i167.i869, i64 16
  store ptr %1366, ptr %1370, align 8
  %1371 = getelementptr i8, ptr %result.i167.i869, i64 8
  store ptr %1367, ptr %1371, align 8
  %1372 = getelementptr i8, ptr %result.i167.i869, i64 24
  store ptr null, ptr %1372, align 8
  %1373 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i869)
  store ptr @Entry, ptr %result.i167.i869, align 8
  %1374 = getelementptr i8, ptr %result.i166.i868, i64 8
  store ptr %result.i167.i869, ptr %1374, align 8
  %1375 = getelementptr i8, ptr %result.i166.i868, i64 24
  store ptr null, ptr %1375, align 8
  %1376 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i868)
  store ptr @union_typ, ptr %result.i166.i868, align 8
  %result.i168.i870 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i868, ptr %result.i168.i870, align 8
  %1377 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i870)
  store ptr @Array, ptr %7, align 8
  store ptr %result.i168.i870, ptr %152, align 8
  store i32 9, ptr %153, align 8
  %1378 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %7)
  %1379 = getelementptr i8, ptr %result.i168.i870, i64 16
  store i32 %1368, ptr %1379, align 4
  %1380 = getelementptr i8, ptr %result.i168.i870, i64 20
  store i32 %1368, ptr %1380, align 4
  %1381 = zext nneg i32 %1368 to i64
  %1382 = shl nuw nsw i64 %1381, 5
  %result.i.i416.i871 = call noalias ptr @bump_malloc_inner(i64 noundef %1382, ptr nonnull @current_ptr) #29
  %1383 = getelementptr i8, ptr %result.i168.i870, i64 8
  store ptr %result.i.i416.i871, ptr %1383, align 8
  %1384 = load ptr, ptr %154, align 8
  store ptr @Array, ptr %90, align 8
  store ptr %result.i168.i870, ptr %91, align 8
  store ptr %1384, ptr %92, align 8
  store i32 9, ptr %93, align 4
  %result.i183.i884 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1385 = getelementptr i8, ptr %result.i183.i884, i64 16
  store ptr @_parameterization_Nil, ptr %1385, align 8
  %result.i184.i885 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1386 = getelementptr i8, ptr %result.i184.i885, i64 16
  store ptr %1366, ptr %1386, align 8
  %1387 = getelementptr i8, ptr %result.i184.i885, i64 8
  store ptr %1367, ptr %1387, align 8
  %1388 = getelementptr i8, ptr %result.i184.i885, i64 24
  store ptr null, ptr %1388, align 8
  %1389 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i885)
  store ptr @Entry, ptr %result.i184.i885, align 8
  %1390 = getelementptr i8, ptr %result.i183.i884, i64 8
  store ptr %result.i184.i885, ptr %1390, align 8
  %1391 = getelementptr i8, ptr %result.i183.i884, i64 24
  store ptr null, ptr %1391, align 8
  %1392 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i884)
  store ptr @union_typ, ptr %result.i183.i884, align 8
  %result.i185.i886 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i884, ptr %result.i185.i886, align 8
  %1393 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i886)
  store ptr @Array, ptr %8, align 8
  store ptr %result.i185.i886, ptr %155, align 8
  store i32 9, ptr %156, align 8
  %1394 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %8)
  %1395 = getelementptr i8, ptr %result.i185.i886, i64 16
  store i32 %1368, ptr %1395, align 4
  %1396 = getelementptr i8, ptr %result.i185.i886, i64 20
  store i32 %1368, ptr %1396, align 4
  %result.i.i430.i887 = call noalias ptr @bump_malloc_inner(i64 noundef %1382, ptr nonnull @current_ptr) #29
  %1397 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1398 = getelementptr i8, ptr %result.i185.i886, i64 8
  store ptr %result.i.i430.i887, ptr %1398, align 8
  %1399 = load ptr, ptr %157, align 8
  store ptr @Array, ptr %105, align 8
  store ptr %result.i185.i886, ptr %106, align 8
  store ptr %1399, ptr %107, align 8
  store i32 9, ptr %108, align 4
  %1400 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 0, ptr %109, align 4
  %1401 = icmp sgt i32 %.reg2mem91.0.lcssa.i867, 0
  br i1 %1401, label %.lr.ph400.i900, label %HashMap_resize_.exit973

.lr.ph400.i900:                                   ; preds = %._crit_edge395.i866
  %1402 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1403 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1404 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i902

._crit_edge2.i902:                                ; preds = %._crit_edge2.i902, %.lr.ph400.i900
  %.reg2mem77.0398.i903 = phi i32 [ 0, %.lr.ph400.i900 ], [ %1418, %._crit_edge2.i902 ]
  %1405 = zext nneg i32 %.reg2mem77.0398.i903 to i64
  %1406 = shl nuw nsw i64 %1405, 5
  %1407 = getelementptr i8, ptr %result.i.i.i852, i64 %1406
  %1408 = load ptr, ptr %1407, align 8
  %1409 = getelementptr i8, ptr %1407, i64 8
  %1410 = load i160, ptr %1409, align 4
  %.sroa.3362.8.extract.trunc.i906 = trunc i160 %1410 to i64
  %1411 = inttoptr i64 %.sroa.3362.8.extract.trunc.i906 to ptr
  %.sroa.5363.8.extract.shift.i907 = lshr i160 %1410, 64
  %.sroa.5363.8.extract.trunc.i908 = trunc i160 %.sroa.5363.8.extract.shift.i907 to i64
  %1412 = inttoptr i64 %.sroa.5363.8.extract.trunc.i908 to ptr
  %hash_coef_ptr.i.i201.i909 = getelementptr i8, ptr %1408, i64 8
  %tbl_size_ptr.i.i202.i910 = getelementptr i8, ptr %1408, i64 16
  %offset_tbl_ptr.i.i203.i911 = getelementptr i8, ptr %1408, i64 40
  %hash_coef.i.i232.i912 = load i64, ptr %hash_coef_ptr.i.i201.i909, align 4
  %tbl_size.i.i233.i913 = load i64, ptr %tbl_size_ptr.i.i202.i910, align 4
  %offset_tbl.i.i234.i914 = load ptr, ptr %offset_tbl_ptr.i.i203.i911, align 8
  %product.i.i.i235.i915 = mul i64 %hash_coef.i.i232.i912, 4015701072841558310
  %shifted.i.i.i236.i916 = lshr i64 %product.i.i.i235.i915, 32
  %xored.i.i.i237.i917 = xor i64 %shifted.i.i.i236.i916, %product.i.i.i235.i915
  %hash.i.i.i238.i918 = and i64 %xored.i.i.i237.i917, %tbl_size.i.i233.i913
  %offset_ptr.i.i239.i919 = getelementptr i32, ptr %offset_tbl.i.i234.i914, i64 %hash.i.i.i238.i918
  %offset.i.i240.i920 = load i32, ptr %offset_ptr.i.i239.i919, align 4
  %1413 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1408, 0
  %1414 = insertvalue { ptr, ptr, ptr, i32 } %1413, ptr %1411, 1
  %1415 = insertvalue { ptr, ptr, ptr, i32 } %1414, ptr %1412, 2
  %1416 = insertvalue { ptr, ptr, ptr, i32 } %1415, i32 %offset.i.i240.i920, 3
  %1417 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1416)
  %1418 = add nuw nsw i32 %.reg2mem77.0398.i903, 1
  %1419 = icmp slt i32 %1418, %.reg2mem91.0.lcssa.i867
  br i1 %1419, label %._crit_edge2.i902, label %HashMap_resize_.exit973

HashMap_resize_.exit973:                          ; preds = %._crit_edge2.i902, %._crit_edge395.i866
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %8)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit802.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %232, %428, %HashMap_resize_.exit973
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %59)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  %1420 = add i64 %.reg2mem92.0134, %160
  %1421 = icmp slt i32 %159, %0
  br i1 %1421, label %.lr.ph, label %.lr.ph140

.lr.ph140:                                        ; preds = %HashMap_insert_keyK_valueV.exit
  %1422 = call i64 @clock()
  %1423 = getelementptr inbounds i8, ptr %69, i64 8
  %1424 = getelementptr inbounds i8, ptr %69, i64 24
  br label %1425

1425:                                             ; preds = %.lr.ph140, %1615
  %.reg2mem80.0138 = phi i64 [ 0, %.lr.ph140 ], [ %.reg2mem74.0, %1615 ]
  %.reg2mem78.0137 = phi i1 [ true, %.lr.ph140 ], [ %1616, %1615 ]
  %.reg2mem76.0136 = phi i32 [ 0, %.lr.ph140 ], [ %1617, %1615 ]
  %.sroa.024.0.insert.ext = zext nneg i32 %.reg2mem76.0136 to i160
  %1426 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.024.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %57)
  %1427 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1428 = load ptr, ptr %78, align 8
  %1429 = call i32 %1428({ ptr, i160 } %1426)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1430 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1431 = load ptr, ptr %90, align 8
  %1432 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1431, 0
  %1433 = load ptr, ptr %91, align 8
  %1434 = insertvalue { ptr, ptr, ptr, i32 } %1432, ptr %1433, 1
  %1435 = load ptr, ptr %92, align 8
  %1436 = insertvalue { ptr, ptr, ptr, i32 } %1434, ptr %1435, 2
  %1437 = load i32, ptr %93, align 4
  %1438 = insertvalue { ptr, ptr, ptr, i32 } %1436, i32 %1437, 3
  %hash_coef_ptr.i.i10.i1006 = getelementptr i8, ptr %1431, i64 8
  %tbl_size_ptr.i.i11.i1007 = getelementptr i8, ptr %1431, i64 16
  %offset_tbl_ptr.i.i12.i1008 = getelementptr i8, ptr %1431, i64 40
  %hash_coef.i.i13.i1009 = load i64, ptr %hash_coef_ptr.i.i10.i1006, align 4
  %tbl_size.i.i14.i1010 = load i64, ptr %tbl_size_ptr.i.i11.i1007, align 4
  %offset_tbl.i.i15.i1011 = load ptr, ptr %offset_tbl_ptr.i.i12.i1008, align 8
  %product.i.i.i16.i1012 = mul i64 %hash_coef.i.i13.i1009, -5261542750394134544
  %shifted.i.i.i17.i1013 = lshr i64 %product.i.i.i16.i1012, 32
  %xored.i.i.i18.i1014 = xor i64 %shifted.i.i.i17.i1013, %product.i.i.i16.i1012
  %hash.i.i.i19.i1015 = and i64 %xored.i.i.i18.i1014, %tbl_size.i.i14.i1010
  %offset_ptr.i.i20.i1016 = getelementptr i32, ptr %offset_tbl.i.i15.i1011, i64 %hash.i.i.i19.i1015
  %offset.i.i21.i1017 = load i32, ptr %offset_ptr.i.i20.i1016, align 4
  %eq.i.i1018 = icmp eq i32 %1437, %offset.i.i21.i1017
  call void @llvm.assume(i1 %eq.i.i1018) #30
  %1439 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1440 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1431)
  %1441 = sext i32 %1437 to i64
  %1442 = getelementptr ptr, ptr %1431, i64 %1441
  %1443 = getelementptr i8, ptr %1442, i64 64
  %1444 = load ptr, ptr %1443, align 8
  %1445 = call ptr %1444({ ptr, ptr, ptr, i32 } %1438, ptr nonnull %2)
  %1446 = call i32 %1445({ ptr, ptr, ptr, i32 } %1438, { ptr, ptr, ptr, i32 } %1438, ptr nonnull %2)
  %1447 = add i32 %1446, -1
  %1448 = and i32 %1447, %1429
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1449 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1450 = load ptr, ptr %90, align 8
  %1451 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1450, 0
  %1452 = load ptr, ptr %91, align 8
  %1453 = insertvalue { ptr, ptr, ptr, i32 } %1451, ptr %1452, 1
  %1454 = load ptr, ptr %92, align 8
  %1455 = insertvalue { ptr, ptr, ptr, i32 } %1453, ptr %1454, 2
  %1456 = load i32, ptr %93, align 4
  %1457 = insertvalue { ptr, ptr, ptr, i32 } %1455, i32 %1456, 3
  %hash_coef_ptr.i.i130.i = getelementptr i8, ptr %1450, i64 8
  %tbl_size_ptr.i.i131.i = getelementptr i8, ptr %1450, i64 16
  %offset_tbl_ptr.i.i132.i = getelementptr i8, ptr %1450, i64 40
  %hash_coef.i.i133.i = load i64, ptr %hash_coef_ptr.i.i130.i, align 4
  %tbl_size.i.i134.i = load i64, ptr %tbl_size_ptr.i.i131.i, align 4
  %offset_tbl.i.i135.i = load ptr, ptr %offset_tbl_ptr.i.i132.i, align 8
  %product.i.i.i136.i = mul i64 %hash_coef.i.i133.i, -5261542750394134544
  %shifted.i.i.i137.i = lshr i64 %product.i.i.i136.i, 32
  %xored.i.i.i138.i = xor i64 %shifted.i.i.i137.i, %product.i.i.i136.i
  %hash.i.i.i139.i = and i64 %xored.i.i.i138.i, %tbl_size.i.i134.i
  %offset_ptr.i.i140.i = getelementptr i32, ptr %offset_tbl.i.i135.i, i64 %hash.i.i.i139.i
  %offset.i.i141.i = load i32, ptr %offset_ptr.i.i140.i, align 4
  %eq.i.i258 = icmp eq i32 %1456, %offset.i.i141.i
  call void @llvm.assume(i1 %eq.i.i258) #30
  store ptr @_parameterization_Ptri32, ptr %56, align 8
  %1458 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %56)
  %1459 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1450)
  %1460 = sext i32 %1456 to i64
  %1461 = getelementptr ptr, ptr %1450, i64 %1460
  %1462 = getelementptr i8, ptr %1461, i64 120
  %1463 = load ptr, ptr %1462, align 8
  store ptr @i32_typ, ptr %57, align 8
  %1464 = call ptr %1463({ ptr, ptr, ptr, i32 } %1457, ptr nonnull %57)
  %1465 = call { ptr, i160 } %1464({ ptr, ptr, ptr, i32 } %1457, { ptr, ptr, ptr, i32 } %1457, ptr nonnull %56, i32 %1448)
  %.fca.0.extract.i259 = extractvalue { ptr, i160 } %1465, 0
  %1466 = icmp ne ptr %.fca.0.extract.i259, @nil_typ
  %1467 = icmp ne ptr %.fca.0.extract.i259, null
  %.not126.i = and i1 %1466, %1467
  br i1 %.not126.i, label %1468, label %.critedge.i260

1468:                                             ; preds = %1425
  %.fca.1.extract.i265 = extractvalue { ptr, i160 } %1465, 1
  %.sroa.5.8.extract.trunc.i = trunc i160 %.fca.1.extract.i265 to i64
  %1469 = inttoptr i64 %.sroa.5.8.extract.trunc.i to ptr
  %.sroa.9.8.extract.shift.i = lshr i160 %.fca.1.extract.i265, 64
  %.sroa.9.8.extract.trunc.i = trunc i160 %.sroa.9.8.extract.shift.i to i64
  %1470 = inttoptr i64 %.sroa.9.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i144.i = getelementptr i8, ptr %.fca.0.extract.i259, i64 8
  %tbl_size_ptr.i.i145.i = getelementptr i8, ptr %.fca.0.extract.i259, i64 16
  %offset_tbl_ptr.i.i146.i = getelementptr i8, ptr %.fca.0.extract.i259, i64 40
  %hash_coef.i.i147.i = load i64, ptr %hash_coef_ptr.i.i144.i, align 4
  %tbl_size.i.i148.i = load i64, ptr %tbl_size_ptr.i.i145.i, align 4
  %offset_tbl.i.i149.i = load ptr, ptr %offset_tbl_ptr.i.i146.i, align 8
  %product.i.i.i150.i = mul i64 %hash_coef.i.i147.i, 4015701072841558310
  %shifted.i.i.i151.i = lshr i64 %product.i.i.i150.i, 32
  %xored.i.i.i152.i = xor i64 %shifted.i.i.i151.i, %product.i.i.i150.i
  %hash.i.i.i153.i = and i64 %xored.i.i.i152.i, %tbl_size.i.i148.i
  %offset_ptr.i.i154.i = getelementptr i32, ptr %offset_tbl.i.i149.i, i64 %hash.i.i.i153.i
  %offset.i.i155.i = load i32, ptr %offset_ptr.i.i154.i, align 4
  %1471 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i259, 0
  %1472 = insertvalue { ptr, ptr, ptr, i32 } %1471, ptr %1469, 1
  %1473 = insertvalue { ptr, ptr, ptr, i32 } %1472, ptr %1470, 2
  %1474 = insertvalue { ptr, ptr, ptr, i32 } %1473, i32 %offset.i.i155.i, 3
  %1475 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1476 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1477 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i259)
  %1478 = sext i32 %offset.i.i155.i to i64
  %1479 = getelementptr ptr, ptr %.fca.0.extract.i259, i64 %1478
  %1480 = getelementptr i8, ptr %1479, i64 64
  %1481 = load ptr, ptr %1480, align 8
  %1482 = call ptr %1481({ ptr, ptr, ptr, i32 } %1474, ptr nonnull %2)
  %1483 = call i32 %1482({ ptr, ptr, ptr, i32 } %1474, { ptr, ptr, ptr, i32 } %1474, ptr nonnull %2)
  %1484 = icmp eq i32 %1483, %1429
  %1485 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1486 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1487 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i259)
  %1488 = getelementptr i8, ptr %1479, i64 48
  %1489 = load ptr, ptr %1488, align 8
  %1490 = call ptr %1489({ ptr, ptr, ptr, i32 } %1474, ptr nonnull %2)
  %1491 = call { ptr, i160 } %1490({ ptr, ptr, ptr, i32 } %1474, { ptr, ptr, ptr, i32 } %1474, ptr nonnull %2)
  %1492 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1493 = load ptr, ptr %79, align 8
  %1494 = call i1 %1493({ ptr, i160 } %1491, { ptr, i160 } %1426)
  %1495 = and i1 %1484, %1494
  br i1 %1495, label %HashMap_get_keyK.exit, label %.critedge.i260

.critedge.i260:                                   ; preds = %1468, %1425
  %1496 = add i32 %1429, 2127912214
  %1497 = shl i32 %1429, 12
  %1498 = add i32 %1496, %1497
  %1499 = ashr i32 %1498, 19
  %1500 = xor i32 %1498, %1499
  %1501 = xor i32 %1500, -949894596
  %1502 = add i32 %1501, 374761393
  %1503 = shl i32 %1501, 5
  %1504 = add i32 %1502, %1503
  %1505 = add i32 %1504, -744332180
  %1506 = shl i32 %1504, 9
  %1507 = xor i32 %1505, %1506
  %1508 = add i32 %1507, -42973499
  %1509 = shl i32 %1507, 3
  %1510 = add i32 %1508, %1509
  %1511 = ashr i32 %1510, 16
  %1512 = xor i32 %1510, %1511
  %1513 = xor i32 %1512, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1514 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1515 = load ptr, ptr %105, align 8
  %1516 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1515, 0
  %1517 = load ptr, ptr %106, align 8
  %1518 = insertvalue { ptr, ptr, ptr, i32 } %1516, ptr %1517, 1
  %1519 = load ptr, ptr %107, align 8
  %1520 = insertvalue { ptr, ptr, ptr, i32 } %1518, ptr %1519, 2
  %1521 = load i32, ptr %108, align 4
  %1522 = insertvalue { ptr, ptr, ptr, i32 } %1520, i32 %1521, 3
  %hash_coef_ptr.i.i10.i1037 = getelementptr i8, ptr %1515, i64 8
  %tbl_size_ptr.i.i11.i1038 = getelementptr i8, ptr %1515, i64 16
  %offset_tbl_ptr.i.i12.i1039 = getelementptr i8, ptr %1515, i64 40
  %hash_coef.i.i13.i1040 = load i64, ptr %hash_coef_ptr.i.i10.i1037, align 4
  %tbl_size.i.i14.i1041 = load i64, ptr %tbl_size_ptr.i.i11.i1038, align 4
  %offset_tbl.i.i15.i1042 = load ptr, ptr %offset_tbl_ptr.i.i12.i1039, align 8
  %product.i.i.i16.i1043 = mul i64 %hash_coef.i.i13.i1040, -5261542750394134544
  %shifted.i.i.i17.i1044 = lshr i64 %product.i.i.i16.i1043, 32
  %xored.i.i.i18.i1045 = xor i64 %shifted.i.i.i17.i1044, %product.i.i.i16.i1043
  %hash.i.i.i19.i1046 = and i64 %xored.i.i.i18.i1045, %tbl_size.i.i14.i1041
  %offset_ptr.i.i20.i1047 = getelementptr i32, ptr %offset_tbl.i.i15.i1042, i64 %hash.i.i.i19.i1046
  %offset.i.i21.i1048 = load i32, ptr %offset_ptr.i.i20.i1047, align 4
  %eq.i.i1049 = icmp eq i32 %1521, %offset.i.i21.i1048
  call void @llvm.assume(i1 %eq.i.i1049) #30
  %1523 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1524 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1515)
  %1525 = sext i32 %1521 to i64
  %1526 = getelementptr ptr, ptr %1515, i64 %1525
  %1527 = getelementptr i8, ptr %1526, i64 64
  %1528 = load ptr, ptr %1527, align 8
  %1529 = call ptr %1528({ ptr, ptr, ptr, i32 } %1522, ptr nonnull %2)
  %1530 = call i32 %1529({ ptr, ptr, ptr, i32 } %1522, { ptr, ptr, ptr, i32 } %1522, ptr nonnull %2)
  %1531 = add i32 %1530, -1
  %1532 = and i32 %1531, %1513
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1533 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1534 = load ptr, ptr %105, align 8
  %1535 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1534, 0
  %1536 = load ptr, ptr %106, align 8
  %1537 = insertvalue { ptr, ptr, ptr, i32 } %1535, ptr %1536, 1
  %1538 = load ptr, ptr %107, align 8
  %1539 = insertvalue { ptr, ptr, ptr, i32 } %1537, ptr %1538, 2
  %1540 = load i32, ptr %108, align 4
  %1541 = insertvalue { ptr, ptr, ptr, i32 } %1539, i32 %1540, 3
  %hash_coef_ptr.i.i158.i = getelementptr i8, ptr %1534, i64 8
  %tbl_size_ptr.i.i159.i = getelementptr i8, ptr %1534, i64 16
  %offset_tbl_ptr.i.i160.i = getelementptr i8, ptr %1534, i64 40
  %hash_coef.i.i161.i = load i64, ptr %hash_coef_ptr.i.i158.i, align 4
  %tbl_size.i.i162.i = load i64, ptr %tbl_size_ptr.i.i159.i, align 4
  %offset_tbl.i.i163.i = load ptr, ptr %offset_tbl_ptr.i.i160.i, align 8
  %product.i.i.i164.i = mul i64 %hash_coef.i.i161.i, -5261542750394134544
  %shifted.i.i.i165.i = lshr i64 %product.i.i.i164.i, 32
  %xored.i.i.i166.i = xor i64 %shifted.i.i.i165.i, %product.i.i.i164.i
  %hash.i.i.i167.i = and i64 %xored.i.i.i166.i, %tbl_size.i.i162.i
  %offset_ptr.i.i168.i = getelementptr i32, ptr %offset_tbl.i.i163.i, i64 %hash.i.i.i167.i
  %offset.i.i169.i = load i32, ptr %offset_ptr.i.i168.i, align 4
  %eq.i172.i = icmp eq i32 %1540, %offset.i.i169.i
  call void @llvm.assume(i1 %eq.i172.i) #30
  store ptr @_parameterization_Ptri32, ptr %54, align 8
  %1542 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %54)
  %1543 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1534)
  %1544 = sext i32 %1540 to i64
  %1545 = getelementptr ptr, ptr %1534, i64 %1544
  %1546 = getelementptr i8, ptr %1545, i64 120
  %1547 = load ptr, ptr %1546, align 8
  store ptr @i32_typ, ptr %55, align 8
  %1548 = call ptr %1547({ ptr, ptr, ptr, i32 } %1541, ptr nonnull %55)
  %1549 = call { ptr, i160 } %1548({ ptr, ptr, ptr, i32 } %1541, { ptr, ptr, ptr, i32 } %1541, ptr nonnull %54, i32 %1532)
  %.fca.0.extract57.i = extractvalue { ptr, i160 } %1549, 0
  %1550 = icmp ne ptr %.fca.0.extract57.i, @nil_typ
  %1551 = icmp ne ptr %.fca.0.extract57.i, null
  %.not128.i = and i1 %1550, %1551
  br i1 %.not128.i, label %1552, label %HashMap_get_keyK.exit.thread

1552:                                             ; preds = %.critedge.i260
  %.fca.1.extract59.i = extractvalue { ptr, i160 } %1549, 1
  %.sroa.6.8.extract.trunc.i = trunc i160 %.fca.1.extract59.i to i64
  %1553 = inttoptr i64 %.sroa.6.8.extract.trunc.i to ptr
  %.sroa.11.8.extract.shift.i = lshr i160 %.fca.1.extract59.i, 64
  %.sroa.11.8.extract.trunc.i = trunc i160 %.sroa.11.8.extract.shift.i to i64
  %1554 = inttoptr i64 %.sroa.11.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i174.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 8
  %tbl_size_ptr.i.i175.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 16
  %offset_tbl_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 40
  %hash_coef.i.i177.i = load i64, ptr %hash_coef_ptr.i.i174.i, align 4
  %tbl_size.i.i178.i = load i64, ptr %tbl_size_ptr.i.i175.i, align 4
  %offset_tbl.i.i179.i = load ptr, ptr %offset_tbl_ptr.i.i176.i, align 8
  %product.i.i.i180.i = mul i64 %hash_coef.i.i177.i, 4015701072841558310
  %shifted.i.i.i181.i = lshr i64 %product.i.i.i180.i, 32
  %xored.i.i.i182.i = xor i64 %shifted.i.i.i181.i, %product.i.i.i180.i
  %hash.i.i.i183.i = and i64 %xored.i.i.i182.i, %tbl_size.i.i178.i
  %offset_ptr.i.i184.i = getelementptr i32, ptr %offset_tbl.i.i179.i, i64 %hash.i.i.i183.i
  %offset.i.i185.i = load i32, ptr %offset_ptr.i.i184.i, align 4
  %1555 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i, 0
  %1556 = insertvalue { ptr, ptr, ptr, i32 } %1555, ptr %1553, 1
  %1557 = insertvalue { ptr, ptr, ptr, i32 } %1556, ptr %1554, 2
  %1558 = insertvalue { ptr, ptr, ptr, i32 } %1557, i32 %offset.i.i185.i, 3
  %1559 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1560 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1561 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %1562 = sext i32 %offset.i.i185.i to i64
  %1563 = getelementptr ptr, ptr %.fca.0.extract57.i, i64 %1562
  %1564 = getelementptr i8, ptr %1563, i64 64
  %1565 = load ptr, ptr %1564, align 8
  %1566 = call ptr %1565({ ptr, ptr, ptr, i32 } %1558, ptr nonnull %2)
  %1567 = call i32 %1566({ ptr, ptr, ptr, i32 } %1558, { ptr, ptr, ptr, i32 } %1558, ptr nonnull %2)
  %1568 = icmp eq i32 %1567, %1429
  %1569 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1570 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1571 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %1572 = getelementptr i8, ptr %1563, i64 48
  %1573 = load ptr, ptr %1572, align 8
  %1574 = call ptr %1573({ ptr, ptr, ptr, i32 } %1558, ptr nonnull %2)
  %1575 = call { ptr, i160 } %1574({ ptr, ptr, ptr, i32 } %1558, { ptr, ptr, ptr, i32 } %1558, ptr nonnull %2)
  %1576 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1577 = load ptr, ptr %79, align 8
  %1578 = call i1 %1577({ ptr, i160 } %1575, { ptr, i160 } %1426)
  %1579 = and i1 %1568, %1578
  br i1 %1579, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %1552, %.critedge.i260
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %57)
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

HashMap_get_keyK.exit:                            ; preds = %1468, %1552
  %.pre-phi313.i = phi i64 [ %1478, %1468 ], [ %1562, %1552 ]
  %.pre-phi312.i = phi { ptr, ptr, ptr, i32 } [ %1474, %1468 ], [ %1558, %1552 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i = phi ptr [ %.fca.0.extract.i259, %1468 ], [ %.fca.0.extract57.i, %1552 ]
  %.reg2mem59.0.sroa.phi120289.i = phi ptr [ %.sroa.1.i, %1468 ], [ %.sroa.2124.i, %1552 ]
  %.reg2mem59.0.sroa.phi117288.i = phi ptr [ %.sroa.0271.i, %1468 ], [ %.sroa.0123.i, %1552 ]
  %.reg2mem57.0.sroa.phi94287.i = phi ptr [ %.sroa.2.i, %1468 ], [ %.sroa.2116.i, %1552 ]
  %.reg2mem57.0.sroa.phi91286.i = phi ptr [ %.sroa.0.i, %1468 ], [ %.sroa.0115.i, %1552 ]
  %1580 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1581 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1582 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i)
  %1583 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i, i64 %.pre-phi313.i
  %1584 = getelementptr i8, ptr %1583, i64 56
  %1585 = load ptr, ptr %1584, align 8
  %1586 = call ptr %1585({ ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %1587 = call { ptr, i160 } %1586({ ptr, ptr, ptr, i32 } %.pre-phi312.i, { ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %.fca.0.extract97.i = extractvalue { ptr, i160 } %1587, 0
  store ptr %.fca.0.extract97.i, ptr %.reg2mem59.0.sroa.phi117288.i, align 8
  %.fca.1.extract99.i = extractvalue { ptr, i160 } %1587, 1
  store i160 %.fca.1.extract99.i, ptr %.reg2mem59.0.sroa.phi120289.i, align 8
  store ptr %.fca.0.extract97.i, ptr %.reg2mem57.0.sroa.phi91286.i, align 8
  store i160 %.fca.1.extract99.i, ptr %.reg2mem57.0.sroa.phi94287.i, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %57)
  %1588 = icmp ne ptr %.fca.0.extract97.i, @nil_typ
  %1589 = icmp ne ptr %.fca.0.extract97.i, null
  %.not33 = and i1 %1588, %1589
  br i1 %.not33, label %1590, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

1590:                                             ; preds = %HashMap_get_keyK.exit
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract99.i to i32
  %1591 = sext i32 %.sroa.2.8.extract.trunc to i64
  %1592 = add i64 %.reg2mem80.0138, %1591
  br label %1615

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit: ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit
  %result.i40 = call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nonnull @current_ptr) #29
  %1593 = load <55 x i8>, ptr @vucqs_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  store <55 x i8> %1593, ptr %result.i40, align 64
  %result.i41 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  store ptr @String, ptr %69, align 8
  store ptr %result.i41, ptr %1423, align 8
  store i32 9, ptr %1424, align 8
  %1594 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %69)
  store ptr %result.i40, ptr %result.i41, align 8
  %1595 = getelementptr i8, ptr %result.i41, i64 8
  store i32 55, ptr %1595, align 4
  %1596 = getelementptr i8, ptr %result.i41, i64 12
  store i32 56, ptr %1596, align 4
  %1597 = load i160, ptr %1423, align 8
  %1598 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i = trunc i160 %1597 to i64
  %1599 = inttoptr i64 %.sroa.3.8.extract.trunc.i to ptr
  %1600 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1601 = getelementptr i8, ptr %1599, i64 8
  %1602 = load i32, ptr %1601, align 4
  %1603 = add i32 %1602, 1
  %1604 = sext i32 %1603 to i64
  %result.i.i1064 = call noalias ptr @bump_malloc_inner(i64 noundef %1604, ptr nonnull @current_ptr) #29
  %1605 = load i32, ptr %1601, align 4
  %1606 = icmp sgt i32 %1605, 0
  br i1 %1606, label %.lr.ph.i1065, label %String_c_string_.exit

.lr.ph.i1065:                                     ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %1607 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1608 = load ptr, ptr %1599, align 8
  %1609 = zext nneg i32 %1605 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1064, ptr align 1 %1608, i64 %1609, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %.lr.ph.i1065, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %1610 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1611 = sext i32 %1605 to i64
  %1612 = getelementptr i8, ptr %result.i.i1064, i64 %1611
  store i8 0, ptr %1612, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1064)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1613 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %1614 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %.reg2mem76.0136)
  br label %1615

1615:                                             ; preds = %1590, %String_c_string_.exit
  %1616 = phi i1 [ %.reg2mem78.0137, %1590 ], [ false, %String_c_string_.exit ]
  %.reg2mem74.0 = phi i64 [ %1592, %1590 ], [ %.reg2mem80.0138, %String_c_string_.exit ]
  %1617 = add nuw nsw i32 %.reg2mem76.0136, 1
  %1618 = icmp slt i32 %1617, %0
  br i1 %1618, label %1425, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit81

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit81: ; preds = %1615, %._crit_edge.thread
  %1619 = phi i64 [ %158, %._crit_edge.thread ], [ %1422, %1615 ]
  %.reg2mem92.0.lcssa158 = phi i64 [ 0, %._crit_edge.thread ], [ %1420, %1615 ]
  %.reg2mem78.0.lcssa = phi i1 [ true, %._crit_edge.thread ], [ %1616, %1615 ]
  %.reg2mem80.0.lcssa = phi i64 [ 0, %._crit_edge.thread ], [ %.reg2mem74.0, %1615 ]
  %1620 = call i64 @clock()
  %.not = icmp eq i64 %.reg2mem80.0.lcssa, %.reg2mem92.0.lcssa158
  %1621 = select i1 %.not, i1 %.reg2mem78.0.lcssa, i1 false
  %result.i60 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nonnull @current_ptr) #29
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i60, align 32
  %result.i61 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %1622 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i61, 1
  %1623 = insertvalue { ptr, ptr, ptr, i32 } %1622, ptr undef, 2
  %1624 = insertvalue { ptr, ptr, ptr, i32 } %1623, i32 9, 3
  store ptr %result.i60, ptr %result.i61, align 8
  %1625 = getelementptr i8, ptr %result.i61, i64 8
  store i32 18, ptr %1625, align 4
  %1626 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1627 = getelementptr i8, ptr %result.i61, i64 12
  store i32 19, ptr %1627, align 4
  %1628 = sub i64 %1620, %1619
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %1624, i32 %0, i64 %1628)
  %result.i62 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nonnull @current_ptr) #29
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i62, align 32
  %result.i63 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %1629 = getelementptr inbounds i8, ptr %70, i64 8
  %1630 = getelementptr inbounds i8, ptr %70, i64 24
  store ptr @String, ptr %70, align 8
  store ptr %result.i63, ptr %1629, align 8
  store i32 9, ptr %1630, align 8
  %1631 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %70)
  store ptr %result.i62, ptr %result.i63, align 8
  %1632 = getelementptr i8, ptr %result.i63, i64 8
  store i32 18, ptr %1632, align 4
  %1633 = getelementptr i8, ptr %result.i63, i64 12
  store i32 19, ptr %1633, align 4
  %1634 = load i160, ptr %1629, align 8
  %1635 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i288 = trunc i160 %1634 to i64
  %1636 = inttoptr i64 %.sroa.3.8.extract.trunc.i288 to ptr
  %1637 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1638 = getelementptr i8, ptr %1636, i64 8
  %1639 = load i32, ptr %1638, align 4
  %1640 = add i32 %1639, 1
  %1641 = sext i32 %1640 to i64
  %result.i.i1081 = call noalias ptr @bump_malloc_inner(i64 noundef %1641, ptr nonnull @current_ptr) #29
  %1642 = load i32, ptr %1638, align 4
  %1643 = icmp sgt i32 %1642, 0
  br i1 %1643, label %.lr.ph.i1082, label %String_c_string_.exit1086

.lr.ph.i1082:                                     ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit81
  %1644 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1645 = load ptr, ptr %1636, align 8
  %1646 = zext nneg i32 %1642 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1081, ptr align 1 %1645, i64 %1646, i1 false)
  br label %String_c_string_.exit1086

String_c_string_.exit1086:                        ; preds = %.lr.ph.i1082, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit81
  %1647 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1648 = sext i32 %1642 to i64
  %1649 = getelementptr i8, ptr %result.i.i1081, i64 %1648
  store i8 0, ptr %1649, align 1
  %puts.i304 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1081)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i82 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nonnull @current_ptr) #29
  %. = select i1 %1621, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.228 = select i1 %1621, ptr %71, ptr %72
  store <4 x i8> %., ptr %result.i82, align 4
  %result.i103 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %.228.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %1621, ptr %71, ptr %72
  %.228.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.228.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  %.228.sroa.sel328.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %1621, ptr %71, ptr %72
  %.228.sroa.sel328.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.228.sroa.sel328.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 24
  store ptr @String, ptr %.228, align 8
  store ptr %result.i103, ptr %.228.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store i32 9, ptr %.228.sroa.sel328.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1650 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %.228)
  store ptr %result.i82, ptr %result.i103, align 8
  %1651 = getelementptr i8, ptr %result.i103, i64 8
  store i32 4, ptr %1651, align 4
  %1652 = getelementptr i8, ptr %result.i103, i64 12
  store i32 5, ptr %1652, align 4
  %1653 = load i160, ptr %.228.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %1654 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i308 = trunc i160 %1653 to i64
  %1655 = inttoptr i64 %.sroa.3.8.extract.trunc.i308 to ptr
  %1656 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1657 = getelementptr i8, ptr %1655, i64 8
  %1658 = load i32, ptr %1657, align 4
  %1659 = add i32 %1658, 1
  %1660 = sext i32 %1659 to i64
  %result.i.i1101 = call noalias ptr @bump_malloc_inner(i64 noundef %1660, ptr nonnull @current_ptr) #29
  %1661 = load i32, ptr %1657, align 4
  %1662 = icmp sgt i32 %1661, 0
  br i1 %1662, label %.lr.ph.i1102, label %String_c_string_.exit1106

.lr.ph.i1102:                                     ; preds = %String_c_string_.exit1086
  %1663 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1664 = load ptr, ptr %1655, align 8
  %1665 = zext nneg i32 %1661 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1101, ptr align 1 %1664, i64 %1665, i1 false)
  br label %String_c_string_.exit1106

String_c_string_.exit1106:                        ; preds = %.lr.ph.i1102, %String_c_string_.exit1086
  %1666 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %1667 = sext i32 %1661 to i64
  %1668 = getelementptr i8, ptr %result.i.i1101, i64 %1667
  store i8 0, ptr %1668, align 1
  %puts.i324 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1101)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %.sroa.0680.i2120 = alloca ptr, align 8
  %16 = alloca i64, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [2 x ptr], align 8
  %20 = alloca { ptr, ptr }, align 8
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %.sroa.0.i2122 = alloca ptr, align 8
  %24 = alloca i64, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  %30 = alloca { ptr, ptr, ptr, i32 }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [2 x ptr], align 8
  %34 = alloca { ptr, ptr }, align 8
  %35 = alloca i32, align 4
  %36 = alloca i32, align 4
  %37 = alloca i32, align 4
  %.sroa.0680.i1805 = alloca ptr, align 8
  %38 = alloca i64, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [2 x ptr], align 8
  %42 = alloca { ptr, ptr }, align 8
  %43 = alloca i32, align 4
  %44 = alloca i32, align 4
  %45 = alloca i32, align 4
  %.sroa.0.i1806 = alloca ptr, align 8
  %46 = alloca i64, align 8
  %47 = alloca { ptr, ptr, ptr, i32 }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = alloca { ptr, ptr, ptr, i32 }, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca { ptr, ptr, ptr, i32 }, align 8
  %59 = alloca { ptr, ptr, ptr, i32 }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [2 x ptr], align 8
  %63 = alloca { ptr, ptr }, align 8
  %64 = alloca i32, align 4
  %65 = alloca i32, align 4
  %66 = alloca i32, align 4
  %.sroa.0680.i1179 = alloca ptr, align 8
  %67 = alloca i64, align 8
  %68 = alloca [1 x ptr], align 8
  %69 = alloca { ptr }, align 8
  %70 = alloca [2 x ptr], align 8
  %71 = alloca { ptr, ptr }, align 8
  %72 = alloca i32, align 4
  %73 = alloca i32, align 4
  %74 = alloca i32, align 4
  %.sroa.0.i1181 = alloca ptr, align 8
  %75 = alloca i64, align 8
  %76 = alloca [1 x ptr], align 8
  %77 = alloca { ptr }, align 8
  %78 = alloca [1 x ptr], align 8
  %79 = alloca { ptr }, align 8
  %80 = alloca { ptr, ptr, ptr, i32 }, align 8
  %81 = alloca { ptr, ptr, ptr, i32 }, align 8
  %82 = alloca [1 x ptr], align 8
  %83 = alloca { ptr }, align 8
  %84 = alloca [2 x ptr], align 8
  %85 = alloca { ptr, ptr }, align 8
  %86 = alloca i32, align 4
  %87 = alloca i32, align 4
  %88 = alloca i32, align 4
  %.sroa.0680.i = alloca ptr, align 8
  %89 = alloca i64, align 8
  %90 = alloca [1 x ptr], align 8
  %91 = alloca { ptr }, align 8
  %92 = alloca [2 x ptr], align 8
  %93 = alloca { ptr, ptr }, align 8
  %94 = alloca i32, align 4
  %95 = alloca i32, align 4
  %96 = alloca i32, align 4
  %.sroa.0.i971 = alloca ptr, align 8
  %97 = alloca i64, align 8
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  %99 = alloca [1 x ptr], align 8
  %100 = alloca { ptr }, align 8
  %101 = alloca [1 x ptr], align 8
  %102 = alloca { ptr }, align 8
  %103 = alloca { ptr, ptr, ptr, i32 }, align 8
  %104 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.sroa.0271.i706 = alloca ptr, align 8
  %.sroa.1.i707 = alloca i160, align 8
  %.sroa.0.i708 = alloca ptr, align 8
  %.sroa.2.i709 = alloca i160, align 8
  %105 = alloca [1 x ptr], align 8
  %106 = alloca { ptr }, align 8
  %.sroa.0123.i710 = alloca ptr, align 8
  %.sroa.2124.i711 = alloca i160, align 8
  %.sroa.0115.i712 = alloca ptr, align 8
  %.sroa.2116.i713 = alloca i160, align 8
  %107 = alloca [1 x ptr], align 8
  %108 = alloca { ptr }, align 8
  %109 = alloca { ptr, ptr, ptr, i32 }, align 8
  %110 = alloca [2 x ptr], align 8
  %111 = alloca { ptr, ptr }, align 8
  %112 = alloca [1 x ptr], align 8
  %113 = alloca { ptr }, align 8
  %114 = alloca { ptr, ptr, ptr, i32 }, align 8
  %115 = alloca [2 x ptr], align 8
  %116 = alloca { ptr, ptr }, align 8
  %117 = alloca { ptr, ptr, ptr, i32 }, align 8
  %118 = alloca [1 x ptr], align 8
  %119 = alloca { ptr }, align 8
  %120 = alloca { ptr, ptr, ptr, i32 }, align 8
  %121 = alloca [2 x ptr], align 8
  %122 = alloca { ptr, ptr }, align 8
  %123 = alloca [1 x ptr], align 8
  %124 = alloca { ptr }, align 8
  %125 = alloca { ptr, ptr, ptr, i32 }, align 8
  %126 = alloca [2 x ptr], align 8
  %127 = alloca { ptr, ptr }, align 8
  %128 = alloca { ptr, ptr, ptr, i32 }, align 8
  %129 = alloca [1 x ptr], align 8
  %130 = alloca { ptr }, align 8
  %.sroa.0271.i = alloca ptr, align 8
  %.sroa.1.i = alloca i160, align 8
  %.sroa.0.i = alloca ptr, align 8
  %.sroa.2.i = alloca i160, align 8
  %131 = alloca [1 x ptr], align 8
  %132 = alloca { ptr }, align 8
  %.sroa.0123.i = alloca ptr, align 8
  %.sroa.2124.i = alloca i160, align 8
  %.sroa.0115.i = alloca ptr, align 8
  %.sroa.2116.i = alloca i160, align 8
  %133 = alloca [1 x ptr], align 8
  %134 = alloca { ptr }, align 8
  %oldProtect.i111 = alloca i32, align 4
  %oldProtect.i107 = alloca i32, align 4
  %oldProtect.i72 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.042.sroa.0 = alloca i8, align 8
  %135 = alloca { ptr, ptr, ptr, i32 }, align 8
  %136 = alloca { ptr, ptr, ptr, i32 }, align 8
  %137 = alloca { ptr, ptr, ptr, i32 }, align 8
  %138 = alloca { ptr, ptr, ptr, i32 }, align 8
  %result.i = tail call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i, align 8
  %139 = getelementptr i8, ptr %result.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %139, align 8
  %140 = getelementptr i8, ptr %result.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %140, align 8
  %141 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i)
  %result.i69 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i70 = call i32 @VirtualProtect(ptr %result.i69, i64 16, i32 64, ptr nonnull %oldProtect.i) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr %result.i69, ptr nonnull @idwoghntmh, ptr nonnull @i32_hasher)
  %ret.i = call ptr @llvm.adjust.trampoline(ptr readonly %result.i69) #31
  %142 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i69)
  %result.i71 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i72)
  %result.i73 = call i32 @VirtualProtect(ptr %result.i71, i64 16, i32 64, ptr nonnull %oldProtect.i72) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i72)
  call void @llvm.init.trampoline(ptr %result.i71, ptr nonnull @wwhoiocwxr, ptr nonnull @i32_eq)
  %ret.i74 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i71) #31
  %143 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i71)
  %144 = getelementptr i8, ptr %result.i, i64 96
  store ptr %ret.i, ptr %144, align 8
  %145 = getelementptr i8, ptr %result.i, i64 104
  store ptr %ret.i74, ptr %145, align 8
  %result.i.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %146 = getelementptr i8, ptr %result.i.i, i64 16
  store ptr @_parameterization_Nil, ptr %146, align 8
  %result.i4.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %147 = getelementptr i8, ptr %result.i4.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %147, align 8
  %148 = getelementptr i8, ptr %result.i4.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %148, align 8
  %149 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i)
  store ptr @Entry, ptr %result.i4.i, align 8
  %150 = getelementptr i8, ptr %result.i.i, i64 8
  store ptr %result.i4.i, ptr %150, align 8
  %151 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i)
  store ptr @union_typ, ptr %result.i.i, align 8
  %result.i5.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i, ptr %result.i5.i, align 8
  %152 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i)
  %153 = getelementptr i8, ptr %result.i5.i, i64 16
  store i32 8, ptr %153, align 4
  %154 = getelementptr i8, ptr %result.i5.i, i64 20
  store i32 8, ptr %154, align 4
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %155 = getelementptr i8, ptr %result.i5.i, i64 8
  store ptr %result.i.i.i, ptr %155, align 8
  %156 = getelementptr i8, ptr %result.i, i64 24
  store ptr @Array, ptr %156, align 8
  %157 = getelementptr i8, ptr %result.i, i64 32
  store ptr %result.i5.i, ptr %157, align 8
  %158 = getelementptr i8, ptr %result.i, i64 48
  store i32 9, ptr %158, align 4
  %result.i20.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %159 = getelementptr i8, ptr %result.i20.i, i64 16
  store ptr @_parameterization_Nil, ptr %159, align 8
  %result.i21.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %160 = getelementptr i8, ptr %result.i21.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %160, align 8
  %161 = getelementptr i8, ptr %result.i21.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %161, align 8
  %162 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i)
  store ptr @Entry, ptr %result.i21.i, align 8
  %163 = getelementptr i8, ptr %result.i20.i, i64 8
  store ptr %result.i21.i, ptr %163, align 8
  %164 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i)
  store ptr @union_typ, ptr %result.i20.i, align 8
  %result.i22.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i, ptr %result.i22.i, align 8
  %165 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i)
  %166 = getelementptr i8, ptr %result.i22.i, i64 16
  store i32 8, ptr %166, align 4
  %167 = getelementptr i8, ptr %result.i22.i, i64 20
  store i32 8, ptr %167, align 4
  %result.i.i97.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %168 = getelementptr i8, ptr %result.i22.i, i64 8
  store ptr %result.i.i97.i, ptr %168, align 8
  %169 = getelementptr i8, ptr %result.i, i64 56
  store ptr @Array, ptr %169, align 8
  %170 = getelementptr i8, ptr %result.i, i64 64
  store ptr %result.i22.i, ptr %170, align 8
  %171 = getelementptr i8, ptr %result.i, i64 80
  store i32 9, ptr %171, align 4
  %172 = getelementptr i8, ptr %result.i, i64 112
  store i32 100, ptr %172, align 4
  %result.i75 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  %173 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  store i32 456, ptr %result.i75, align 4
  %result.i90 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i90, align 8
  %174 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i90)
  %175 = getelementptr i8, ptr %result.i90, i64 20
  store i32 %0, ptr %175, align 4
  %176 = sext i32 %0 to i64
  %177 = shl nsw i64 %176, 5
  %result.i.i274 = call noalias ptr @bump_malloc_inner(i64 noundef %177, ptr nonnull @current_ptr) #29
  %178 = getelementptr i8, ptr %result.i90, i64 8
  store ptr %result.i.i274, ptr %178, align 8
  %result.i105 = call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i105, align 8
  %179 = getelementptr i8, ptr %result.i105, i64 8
  store ptr @_parameterization_Ptri1, ptr %179, align 8
  %180 = getelementptr i8, ptr %result.i105, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %180, align 8
  %181 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i105)
  %result.i106 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i107)
  %result.i108 = call i32 @VirtualProtect(ptr %result.i106, i64 16, i32 64, ptr nonnull %oldProtect.i107) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i107)
  call void @llvm.init.trampoline(ptr %result.i106, ptr nonnull @ytwimdyqgw, ptr nonnull @i32_hasher)
  %ret.i109 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i106) #31
  %182 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i106)
  %result.i110 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i111)
  %result.i112 = call i32 @VirtualProtect(ptr %result.i110, i64 16, i32 64, ptr nonnull %oldProtect.i111) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i111)
  call void @llvm.init.trampoline(ptr %result.i110, ptr nonnull @uuudsaoyum, ptr nonnull @i32_eq)
  %ret.i113 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i110) #31
  %183 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i110)
  %184 = getelementptr i8, ptr %result.i105, i64 96
  store ptr %ret.i109, ptr %184, align 8
  %185 = getelementptr i8, ptr %result.i105, i64 104
  store ptr %ret.i113, ptr %185, align 8
  %result.i.i375 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %186 = getelementptr i8, ptr %result.i.i375, i64 16
  store ptr @_parameterization_Nil, ptr %186, align 8
  %result.i4.i376 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %187 = getelementptr i8, ptr %result.i4.i376, i64 16
  store ptr @_parameterization_Ptri1, ptr %187, align 8
  %188 = getelementptr i8, ptr %result.i4.i376, i64 8
  store ptr @_parameterization_Ptri32, ptr %188, align 8
  %189 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i376)
  store ptr @Entry, ptr %result.i4.i376, align 8
  %190 = getelementptr i8, ptr %result.i.i375, i64 8
  store ptr %result.i4.i376, ptr %190, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i375)
  store ptr @union_typ, ptr %result.i.i375, align 8
  %result.i5.i377 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i375, ptr %result.i5.i377, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i377)
  %193 = getelementptr i8, ptr %result.i5.i377, i64 16
  store i32 8, ptr %193, align 4
  %194 = getelementptr i8, ptr %result.i5.i377, i64 20
  store i32 8, ptr %194, align 4
  %result.i.i.i378 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %195 = getelementptr i8, ptr %result.i5.i377, i64 8
  store ptr %result.i.i.i378, ptr %195, align 8
  %196 = getelementptr i8, ptr %result.i105, i64 24
  store ptr @Array, ptr %196, align 8
  %197 = getelementptr i8, ptr %result.i105, i64 32
  store ptr %result.i5.i377, ptr %197, align 8
  %198 = getelementptr i8, ptr %result.i105, i64 40
  %199 = getelementptr i8, ptr %result.i105, i64 48
  store i32 9, ptr %199, align 4
  %result.i20.i379 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %200 = getelementptr i8, ptr %result.i20.i379, i64 16
  store ptr @_parameterization_Nil, ptr %200, align 8
  %result.i21.i380 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %201 = getelementptr i8, ptr %result.i21.i380, i64 16
  store ptr @_parameterization_Ptri1, ptr %201, align 8
  %202 = getelementptr i8, ptr %result.i21.i380, i64 8
  store ptr @_parameterization_Ptri32, ptr %202, align 8
  %203 = getelementptr i8, ptr %result.i21.i380, i64 24
  store ptr null, ptr %203, align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i380)
  store ptr @Entry, ptr %result.i21.i380, align 8
  %205 = getelementptr i8, ptr %result.i20.i379, i64 8
  store ptr %result.i21.i380, ptr %205, align 8
  %206 = getelementptr i8, ptr %result.i20.i379, i64 24
  store ptr null, ptr %206, align 8
  %207 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i379)
  store ptr @union_typ, ptr %result.i20.i379, align 8
  %result.i22.i381 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i379, ptr %result.i22.i381, align 8
  %208 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i381)
  %209 = getelementptr i8, ptr %result.i22.i381, i64 16
  store i32 8, ptr %209, align 4
  %210 = getelementptr i8, ptr %result.i22.i381, i64 20
  store i32 8, ptr %210, align 4
  %result.i.i97.i382 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %211 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %212 = getelementptr i8, ptr %result.i22.i381, i64 8
  store ptr %result.i.i97.i382, ptr %212, align 8
  %213 = getelementptr i8, ptr %result.i105, i64 56
  store ptr @Array, ptr %213, align 8
  %214 = getelementptr i8, ptr %result.i105, i64 64
  store ptr %result.i22.i381, ptr %214, align 8
  %215 = getelementptr i8, ptr %result.i105, i64 72
  %216 = getelementptr i8, ptr %result.i105, i64 80
  store i32 9, ptr %216, align 4
  %217 = getelementptr i8, ptr %result.i105, i64 88
  store i32 0, ptr %217, align 4
  %218 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %219 = getelementptr i8, ptr %result.i105, i64 112
  store i32 100, ptr %219, align 4
  %220 = mul i32 %0, 10
  %221 = icmp sgt i32 %0, 0
  %222 = icmp sgt i32 %220, 0
  %223 = and i1 %221, %222
  br i1 %223, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %1
  %224 = getelementptr inbounds i8, ptr %128, i64 8
  %225 = getelementptr inbounds i8, ptr %128, i64 24
  %226 = getelementptr inbounds i8, ptr %128, i64 16
  %227 = getelementptr inbounds i8, ptr %125, i64 8
  %228 = getelementptr inbounds i8, ptr %125, i64 24
  %229 = getelementptr inbounds i8, ptr %125, i64 16
  %230 = getelementptr inbounds i8, ptr %126, i64 8
  %231 = getelementptr inbounds i8, ptr %127, i64 8
  %232 = getelementptr inbounds i8, ptr %120, i64 8
  %233 = getelementptr inbounds i8, ptr %120, i64 24
  %234 = getelementptr inbounds i8, ptr %120, i64 16
  %235 = getelementptr inbounds i8, ptr %121, i64 8
  %236 = getelementptr inbounds i8, ptr %122, i64 8
  %237 = getelementptr inbounds i8, ptr %117, i64 8
  %238 = getelementptr inbounds i8, ptr %117, i64 24
  %239 = getelementptr inbounds i8, ptr %117, i64 16
  %240 = getelementptr inbounds i8, ptr %114, i64 8
  %241 = getelementptr inbounds i8, ptr %114, i64 24
  %242 = getelementptr inbounds i8, ptr %114, i64 16
  %243 = getelementptr inbounds i8, ptr %115, i64 8
  %244 = getelementptr inbounds i8, ptr %116, i64 8
  %245 = getelementptr inbounds i8, ptr %109, i64 8
  %246 = getelementptr inbounds i8, ptr %109, i64 24
  %247 = getelementptr inbounds i8, ptr %109, i64 16
  %248 = getelementptr inbounds i8, ptr %110, i64 8
  %249 = getelementptr inbounds i8, ptr %111, i64 8
  %250 = getelementptr i8, ptr %result.i, i64 40
  %251 = getelementptr i8, ptr %result.i, i64 72
  %252 = getelementptr i8, ptr %result.i, i64 88
  %253 = getelementptr inbounds i8, ptr %103, i64 8
  %254 = getelementptr inbounds i8, ptr %103, i64 24
  %255 = getelementptr inbounds i8, ptr %103, i64 16
  %256 = getelementptr inbounds i8, ptr %104, i64 8
  %257 = getelementptr inbounds i8, ptr %104, i64 24
  %258 = getelementptr inbounds i8, ptr %104, i64 16
  %259 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i105, 1
  %260 = insertvalue { ptr, ptr, ptr, i32 } %259, ptr undef, 2
  %261 = insertvalue { ptr, ptr, ptr, i32 } %260, i32 9, 3
  %262 = getelementptr inbounds i8, ptr %98, i64 8
  %263 = getelementptr inbounds i8, ptr %98, i64 16
  %264 = getelementptr inbounds i8, ptr %98, i64 24
  %265 = getelementptr inbounds i8, ptr %92, i64 8
  %266 = getelementptr inbounds i8, ptr %93, i64 8
  %267 = getelementptr inbounds i8, ptr %84, i64 8
  %268 = getelementptr inbounds i8, ptr %85, i64 8
  %269 = getelementptr inbounds i8, ptr %80, i64 8
  %270 = getelementptr inbounds i8, ptr %80, i64 24
  %271 = getelementptr inbounds i8, ptr %80, i64 16
  %272 = getelementptr inbounds i8, ptr %81, i64 8
  %273 = getelementptr inbounds i8, ptr %81, i64 24
  %274 = getelementptr inbounds i8, ptr %81, i64 16
  %275 = getelementptr inbounds i8, ptr %70, i64 8
  %276 = getelementptr inbounds i8, ptr %71, i64 8
  %277 = getelementptr inbounds i8, ptr %62, i64 8
  %278 = getelementptr inbounds i8, ptr %63, i64 8
  %279 = getelementptr inbounds i8, ptr %58, i64 8
  %280 = getelementptr inbounds i8, ptr %58, i64 24
  %281 = getelementptr inbounds i8, ptr %58, i64 16
  %282 = getelementptr inbounds i8, ptr %59, i64 8
  %283 = getelementptr inbounds i8, ptr %59, i64 24
  %284 = getelementptr inbounds i8, ptr %59, i64 16
  %285 = getelementptr inbounds i8, ptr %52, i64 8
  %286 = getelementptr inbounds i8, ptr %52, i64 24
  %287 = getelementptr inbounds i8, ptr %52, i64 16
  %288 = getelementptr inbounds i8, ptr %53, i64 8
  %289 = getelementptr inbounds i8, ptr %53, i64 24
  %290 = getelementptr inbounds i8, ptr %53, i64 16
  %291 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %292 = insertvalue { ptr, ptr, ptr, i32 } %291, ptr undef, 2
  %293 = insertvalue { ptr, ptr, ptr, i32 } %292, i32 9, 3
  %294 = getelementptr inbounds i8, ptr %47, i64 8
  %295 = getelementptr inbounds i8, ptr %47, i64 16
  %296 = getelementptr inbounds i8, ptr %47, i64 24
  %297 = getelementptr inbounds i8, ptr %41, i64 8
  %298 = getelementptr inbounds i8, ptr %42, i64 8
  %299 = getelementptr inbounds i8, ptr %33, i64 8
  %300 = getelementptr inbounds i8, ptr %34, i64 8
  %301 = getelementptr inbounds i8, ptr %29, i64 8
  %302 = getelementptr inbounds i8, ptr %29, i64 24
  %303 = getelementptr inbounds i8, ptr %29, i64 16
  %304 = getelementptr inbounds i8, ptr %30, i64 8
  %305 = getelementptr inbounds i8, ptr %30, i64 24
  %306 = getelementptr inbounds i8, ptr %30, i64 16
  %307 = getelementptr inbounds i8, ptr %19, i64 8
  %308 = getelementptr inbounds i8, ptr %20, i64 8
  %309 = getelementptr inbounds i8, ptr %11, i64 8
  %310 = getelementptr inbounds i8, ptr %12, i64 8
  %311 = getelementptr inbounds i8, ptr %7, i64 8
  %312 = getelementptr inbounds i8, ptr %7, i64 24
  %313 = getelementptr inbounds i8, ptr %7, i64 16
  %314 = getelementptr inbounds i8, ptr %8, i64 8
  %315 = getelementptr inbounds i8, ptr %8, i64 24
  %316 = getelementptr inbounds i8, ptr %8, i64 16
  br label %317

317:                                              ; preds = %.lr.ph, %3015
  %.reg2mem132.0238 = phi i64 [ 0, %.lr.ph ], [ %.reg2mem126.0, %3015 ]
  %.reg2mem130.0237 = phi i32 [ 0, %.lr.ph ], [ %.reg2mem124.0, %3015 ]
  %.reg2mem128.0236 = phi i32 [ 0, %.lr.ph ], [ %3016, %3015 ]
  %318 = load i32, ptr %result.i75, align 4
  %319 = mul i32 %318, 1103515245
  %320 = add i32 %319, 12345
  %321 = and i32 %320, 2147483647
  store i32 %321, ptr %result.i75, align 4
  %322 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  %.sroa.065.0.insert.ext = zext nneg i32 %321 to i160
  %323 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.065.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %131)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %132)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %133)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %134)
  %324 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %325 = load ptr, ptr %184, align 8
  %326 = call i32 %325({ ptr, i160 } %323)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %327 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %328 = load ptr, ptr %196, align 8
  %329 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %328, 0
  %330 = load ptr, ptr %197, align 8
  %331 = insertvalue { ptr, ptr, ptr, i32 } %329, ptr %330, 1
  %332 = load ptr, ptr %198, align 8
  %333 = insertvalue { ptr, ptr, ptr, i32 } %331, ptr %332, 2
  %334 = load i32, ptr %199, align 4
  %335 = insertvalue { ptr, ptr, ptr, i32 } %333, i32 %334, 3
  %hash_coef_ptr.i.i10.i = getelementptr i8, ptr %328, i64 8
  %tbl_size_ptr.i.i11.i = getelementptr i8, ptr %328, i64 16
  %offset_tbl_ptr.i.i12.i = getelementptr i8, ptr %328, i64 40
  %hash_coef.i.i13.i = load i64, ptr %hash_coef_ptr.i.i10.i, align 4
  %tbl_size.i.i14.i = load i64, ptr %tbl_size_ptr.i.i11.i, align 4
  %offset_tbl.i.i15.i = load ptr, ptr %offset_tbl_ptr.i.i12.i, align 8
  %product.i.i.i16.i = mul i64 %hash_coef.i.i13.i, -5261542750394134544
  %shifted.i.i.i17.i = lshr i64 %product.i.i.i16.i, 32
  %xored.i.i.i18.i = xor i64 %shifted.i.i.i17.i, %product.i.i.i16.i
  %hash.i.i.i19.i = and i64 %xored.i.i.i18.i, %tbl_size.i.i14.i
  %offset_ptr.i.i20.i = getelementptr i32, ptr %offset_tbl.i.i15.i, i64 %hash.i.i.i19.i
  %offset.i.i21.i = load i32, ptr %offset_ptr.i.i20.i, align 4
  %eq.i.i844 = icmp eq i32 %334, %offset.i.i21.i
  call void @llvm.assume(i1 %eq.i.i844) #30
  %336 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %337 = call ptr @llvm.invariant.start.p0(i64 600, ptr %328)
  %338 = sext i32 %334 to i64
  %339 = getelementptr ptr, ptr %328, i64 %338
  %340 = getelementptr i8, ptr %339, i64 64
  %341 = load ptr, ptr %340, align 8
  %342 = call ptr %341({ ptr, ptr, ptr, i32 } %335, ptr nonnull %2)
  %343 = call i32 %342({ ptr, ptr, ptr, i32 } %335, { ptr, ptr, ptr, i32 } %335, ptr nonnull %2)
  %344 = add i32 %343, -1
  %345 = and i32 %344, %326
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %346 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %347 = load ptr, ptr %196, align 8
  %348 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %347, 0
  %349 = load ptr, ptr %197, align 8
  %350 = insertvalue { ptr, ptr, ptr, i32 } %348, ptr %349, 1
  %351 = load ptr, ptr %198, align 8
  %352 = insertvalue { ptr, ptr, ptr, i32 } %350, ptr %351, 2
  %353 = load i32, ptr %199, align 4
  %354 = insertvalue { ptr, ptr, ptr, i32 } %352, i32 %353, 3
  %hash_coef_ptr.i.i130.i = getelementptr i8, ptr %347, i64 8
  %tbl_size_ptr.i.i131.i = getelementptr i8, ptr %347, i64 16
  %offset_tbl_ptr.i.i132.i = getelementptr i8, ptr %347, i64 40
  %hash_coef.i.i133.i = load i64, ptr %hash_coef_ptr.i.i130.i, align 4
  %tbl_size.i.i134.i = load i64, ptr %tbl_size_ptr.i.i131.i, align 4
  %offset_tbl.i.i135.i = load ptr, ptr %offset_tbl_ptr.i.i132.i, align 8
  %product.i.i.i136.i = mul i64 %hash_coef.i.i133.i, -5261542750394134544
  %shifted.i.i.i137.i = lshr i64 %product.i.i.i136.i, 32
  %xored.i.i.i138.i = xor i64 %shifted.i.i.i137.i, %product.i.i.i136.i
  %hash.i.i.i139.i = and i64 %xored.i.i.i138.i, %tbl_size.i.i134.i
  %offset_ptr.i.i140.i = getelementptr i32, ptr %offset_tbl.i.i135.i, i64 %hash.i.i.i139.i
  %offset.i.i141.i = load i32, ptr %offset_ptr.i.i140.i, align 4
  %eq.i.i = icmp eq i32 %353, %offset.i.i141.i
  call void @llvm.assume(i1 %eq.i.i) #30
  store ptr @_parameterization_Ptri32, ptr %133, align 8
  %355 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %133)
  %356 = call ptr @llvm.invariant.start.p0(i64 600, ptr %347)
  %357 = sext i32 %353 to i64
  %358 = getelementptr ptr, ptr %347, i64 %357
  %359 = getelementptr i8, ptr %358, i64 120
  %360 = load ptr, ptr %359, align 8
  store ptr @i32_typ, ptr %134, align 8
  %361 = call ptr %360({ ptr, ptr, ptr, i32 } %354, ptr nonnull %134)
  %362 = call { ptr, i160 } %361({ ptr, ptr, ptr, i32 } %354, { ptr, ptr, ptr, i32 } %354, ptr nonnull %133, i32 %345)
  %.fca.0.extract.i407 = extractvalue { ptr, i160 } %362, 0
  %363 = icmp ne ptr %.fca.0.extract.i407, @nil_typ
  %364 = icmp ne ptr %.fca.0.extract.i407, null
  %.not126.i = and i1 %363, %364
  br i1 %.not126.i, label %365, label %.critedge.i

365:                                              ; preds = %317
  %.fca.1.extract.i = extractvalue { ptr, i160 } %362, 1
  %.sroa.5.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i64
  %366 = inttoptr i64 %.sroa.5.8.extract.trunc.i to ptr
  %.sroa.9.8.extract.shift.i = lshr i160 %.fca.1.extract.i, 64
  %.sroa.9.8.extract.trunc.i = trunc i160 %.sroa.9.8.extract.shift.i to i64
  %367 = inttoptr i64 %.sroa.9.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i144.i = getelementptr i8, ptr %.fca.0.extract.i407, i64 8
  %tbl_size_ptr.i.i145.i = getelementptr i8, ptr %.fca.0.extract.i407, i64 16
  %offset_tbl_ptr.i.i146.i = getelementptr i8, ptr %.fca.0.extract.i407, i64 40
  %hash_coef.i.i147.i = load i64, ptr %hash_coef_ptr.i.i144.i, align 4
  %tbl_size.i.i148.i = load i64, ptr %tbl_size_ptr.i.i145.i, align 4
  %offset_tbl.i.i149.i = load ptr, ptr %offset_tbl_ptr.i.i146.i, align 8
  %product.i.i.i150.i = mul i64 %hash_coef.i.i147.i, 4015701072841558310
  %shifted.i.i.i151.i = lshr i64 %product.i.i.i150.i, 32
  %xored.i.i.i152.i = xor i64 %shifted.i.i.i151.i, %product.i.i.i150.i
  %hash.i.i.i153.i = and i64 %xored.i.i.i152.i, %tbl_size.i.i148.i
  %offset_ptr.i.i154.i = getelementptr i32, ptr %offset_tbl.i.i149.i, i64 %hash.i.i.i153.i
  %offset.i.i155.i = load i32, ptr %offset_ptr.i.i154.i, align 4
  %368 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i407, 0
  %369 = insertvalue { ptr, ptr, ptr, i32 } %368, ptr %366, 1
  %370 = insertvalue { ptr, ptr, ptr, i32 } %369, ptr %367, 2
  %371 = insertvalue { ptr, ptr, ptr, i32 } %370, i32 %offset.i.i155.i, 3
  %372 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %373 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %374 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i407)
  %375 = sext i32 %offset.i.i155.i to i64
  %376 = getelementptr ptr, ptr %.fca.0.extract.i407, i64 %375
  %377 = getelementptr i8, ptr %376, i64 64
  %378 = load ptr, ptr %377, align 8
  %379 = call ptr %378({ ptr, ptr, ptr, i32 } %371, ptr nonnull %2)
  %380 = call i32 %379({ ptr, ptr, ptr, i32 } %371, { ptr, ptr, ptr, i32 } %371, ptr nonnull %2)
  %381 = icmp eq i32 %380, %326
  %382 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %383 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %384 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i407)
  %385 = getelementptr i8, ptr %376, i64 48
  %386 = load ptr, ptr %385, align 8
  %387 = call ptr %386({ ptr, ptr, ptr, i32 } %371, ptr nonnull %2)
  %388 = call { ptr, i160 } %387({ ptr, ptr, ptr, i32 } %371, { ptr, ptr, ptr, i32 } %371, ptr nonnull %2)
  %389 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %390 = load ptr, ptr %185, align 8
  %391 = call i1 %390({ ptr, i160 } %388, { ptr, i160 } %323)
  %392 = and i1 %381, %391
  br i1 %392, label %HashMap_get_keyK.exit, label %.critedge.i

.critedge.i:                                      ; preds = %365, %317
  %393 = add i32 %326, 2127912214
  %394 = shl i32 %326, 12
  %395 = add i32 %393, %394
  %396 = ashr i32 %395, 19
  %397 = xor i32 %395, %396
  %398 = xor i32 %397, -949894596
  %399 = add i32 %398, 374761393
  %400 = shl i32 %398, 5
  %401 = add i32 %399, %400
  %402 = add i32 %401, -744332180
  %403 = shl i32 %401, 9
  %404 = xor i32 %402, %403
  %405 = add i32 %404, -42973499
  %406 = shl i32 %404, 3
  %407 = add i32 %405, %406
  %408 = ashr i32 %407, 16
  %409 = xor i32 %407, %408
  %410 = xor i32 %409, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %411 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %412 = load ptr, ptr %213, align 8
  %413 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %412, 0
  %414 = load ptr, ptr %214, align 8
  %415 = insertvalue { ptr, ptr, ptr, i32 } %413, ptr %414, 1
  %416 = load ptr, ptr %215, align 8
  %417 = insertvalue { ptr, ptr, ptr, i32 } %415, ptr %416, 2
  %418 = load i32, ptr %216, align 4
  %419 = insertvalue { ptr, ptr, ptr, i32 } %417, i32 %418, 3
  %hash_coef_ptr.i.i10.i862 = getelementptr i8, ptr %412, i64 8
  %tbl_size_ptr.i.i11.i863 = getelementptr i8, ptr %412, i64 16
  %offset_tbl_ptr.i.i12.i864 = getelementptr i8, ptr %412, i64 40
  %hash_coef.i.i13.i865 = load i64, ptr %hash_coef_ptr.i.i10.i862, align 4
  %tbl_size.i.i14.i866 = load i64, ptr %tbl_size_ptr.i.i11.i863, align 4
  %offset_tbl.i.i15.i867 = load ptr, ptr %offset_tbl_ptr.i.i12.i864, align 8
  %product.i.i.i16.i868 = mul i64 %hash_coef.i.i13.i865, -5261542750394134544
  %shifted.i.i.i17.i869 = lshr i64 %product.i.i.i16.i868, 32
  %xored.i.i.i18.i870 = xor i64 %shifted.i.i.i17.i869, %product.i.i.i16.i868
  %hash.i.i.i19.i871 = and i64 %xored.i.i.i18.i870, %tbl_size.i.i14.i866
  %offset_ptr.i.i20.i872 = getelementptr i32, ptr %offset_tbl.i.i15.i867, i64 %hash.i.i.i19.i871
  %offset.i.i21.i873 = load i32, ptr %offset_ptr.i.i20.i872, align 4
  %eq.i.i874 = icmp eq i32 %418, %offset.i.i21.i873
  call void @llvm.assume(i1 %eq.i.i874) #30
  %420 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %421 = call ptr @llvm.invariant.start.p0(i64 600, ptr %412)
  %422 = sext i32 %418 to i64
  %423 = getelementptr ptr, ptr %412, i64 %422
  %424 = getelementptr i8, ptr %423, i64 64
  %425 = load ptr, ptr %424, align 8
  %426 = call ptr %425({ ptr, ptr, ptr, i32 } %419, ptr nonnull %2)
  %427 = call i32 %426({ ptr, ptr, ptr, i32 } %419, { ptr, ptr, ptr, i32 } %419, ptr nonnull %2)
  %428 = add i32 %427, -1
  %429 = and i32 %428, %410
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %430 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %431 = load ptr, ptr %213, align 8
  %432 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %431, 0
  %433 = load ptr, ptr %214, align 8
  %434 = insertvalue { ptr, ptr, ptr, i32 } %432, ptr %433, 1
  %435 = load ptr, ptr %215, align 8
  %436 = insertvalue { ptr, ptr, ptr, i32 } %434, ptr %435, 2
  %437 = load i32, ptr %216, align 4
  %438 = insertvalue { ptr, ptr, ptr, i32 } %436, i32 %437, 3
  %hash_coef_ptr.i.i158.i = getelementptr i8, ptr %431, i64 8
  %tbl_size_ptr.i.i159.i = getelementptr i8, ptr %431, i64 16
  %offset_tbl_ptr.i.i160.i = getelementptr i8, ptr %431, i64 40
  %hash_coef.i.i161.i = load i64, ptr %hash_coef_ptr.i.i158.i, align 4
  %tbl_size.i.i162.i = load i64, ptr %tbl_size_ptr.i.i159.i, align 4
  %offset_tbl.i.i163.i = load ptr, ptr %offset_tbl_ptr.i.i160.i, align 8
  %product.i.i.i164.i = mul i64 %hash_coef.i.i161.i, -5261542750394134544
  %shifted.i.i.i165.i = lshr i64 %product.i.i.i164.i, 32
  %xored.i.i.i166.i = xor i64 %shifted.i.i.i165.i, %product.i.i.i164.i
  %hash.i.i.i167.i = and i64 %xored.i.i.i166.i, %tbl_size.i.i162.i
  %offset_ptr.i.i168.i = getelementptr i32, ptr %offset_tbl.i.i163.i, i64 %hash.i.i.i167.i
  %offset.i.i169.i = load i32, ptr %offset_ptr.i.i168.i, align 4
  %eq.i172.i = icmp eq i32 %437, %offset.i.i169.i
  call void @llvm.assume(i1 %eq.i172.i) #30
  store ptr @_parameterization_Ptri32, ptr %131, align 8
  %439 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %131)
  %440 = call ptr @llvm.invariant.start.p0(i64 600, ptr %431)
  %441 = sext i32 %437 to i64
  %442 = getelementptr ptr, ptr %431, i64 %441
  %443 = getelementptr i8, ptr %442, i64 120
  %444 = load ptr, ptr %443, align 8
  store ptr @i32_typ, ptr %132, align 8
  %445 = call ptr %444({ ptr, ptr, ptr, i32 } %438, ptr nonnull %132)
  %446 = call { ptr, i160 } %445({ ptr, ptr, ptr, i32 } %438, { ptr, ptr, ptr, i32 } %438, ptr nonnull %131, i32 %429)
  %.fca.0.extract57.i = extractvalue { ptr, i160 } %446, 0
  %447 = icmp ne ptr %.fca.0.extract57.i, @nil_typ
  %448 = icmp ne ptr %.fca.0.extract57.i, null
  %.not128.i = and i1 %447, %448
  br i1 %.not128.i, label %449, label %HashMap_get_keyK.exit.thread

449:                                              ; preds = %.critedge.i
  %.fca.1.extract59.i = extractvalue { ptr, i160 } %446, 1
  %.sroa.6.8.extract.trunc.i = trunc i160 %.fca.1.extract59.i to i64
  %450 = inttoptr i64 %.sroa.6.8.extract.trunc.i to ptr
  %.sroa.11.8.extract.shift.i = lshr i160 %.fca.1.extract59.i, 64
  %.sroa.11.8.extract.trunc.i = trunc i160 %.sroa.11.8.extract.shift.i to i64
  %451 = inttoptr i64 %.sroa.11.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i174.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 8
  %tbl_size_ptr.i.i175.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 16
  %offset_tbl_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 40
  %hash_coef.i.i177.i = load i64, ptr %hash_coef_ptr.i.i174.i, align 4
  %tbl_size.i.i178.i = load i64, ptr %tbl_size_ptr.i.i175.i, align 4
  %offset_tbl.i.i179.i = load ptr, ptr %offset_tbl_ptr.i.i176.i, align 8
  %product.i.i.i180.i = mul i64 %hash_coef.i.i177.i, 4015701072841558310
  %shifted.i.i.i181.i = lshr i64 %product.i.i.i180.i, 32
  %xored.i.i.i182.i = xor i64 %shifted.i.i.i181.i, %product.i.i.i180.i
  %hash.i.i.i183.i = and i64 %xored.i.i.i182.i, %tbl_size.i.i178.i
  %offset_ptr.i.i184.i = getelementptr i32, ptr %offset_tbl.i.i179.i, i64 %hash.i.i.i183.i
  %offset.i.i185.i = load i32, ptr %offset_ptr.i.i184.i, align 4
  %452 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i, 0
  %453 = insertvalue { ptr, ptr, ptr, i32 } %452, ptr %450, 1
  %454 = insertvalue { ptr, ptr, ptr, i32 } %453, ptr %451, 2
  %455 = insertvalue { ptr, ptr, ptr, i32 } %454, i32 %offset.i.i185.i, 3
  %456 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %457 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %458 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %459 = sext i32 %offset.i.i185.i to i64
  %460 = getelementptr ptr, ptr %.fca.0.extract57.i, i64 %459
  %461 = getelementptr i8, ptr %460, i64 64
  %462 = load ptr, ptr %461, align 8
  %463 = call ptr %462({ ptr, ptr, ptr, i32 } %455, ptr nonnull %2)
  %464 = call i32 %463({ ptr, ptr, ptr, i32 } %455, { ptr, ptr, ptr, i32 } %455, ptr nonnull %2)
  %465 = icmp eq i32 %464, %326
  %466 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %467 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %468 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %469 = getelementptr i8, ptr %460, i64 48
  %470 = load ptr, ptr %469, align 8
  %471 = call ptr %470({ ptr, ptr, ptr, i32 } %455, ptr nonnull %2)
  %472 = call { ptr, i160 } %471({ ptr, ptr, ptr, i32 } %455, { ptr, ptr, ptr, i32 } %455, ptr nonnull %2)
  %473 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %474 = load ptr, ptr %185, align 8
  %475 = call i1 %474({ ptr, i160 } %472, { ptr, i160 } %323)
  %476 = and i1 %465, %475
  br i1 %476, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %449, %.critedge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %131)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %132)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %133)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %134)
  br label %488

HashMap_get_keyK.exit:                            ; preds = %365, %449
  %.pre-phi313.i = phi i64 [ %375, %365 ], [ %459, %449 ]
  %.pre-phi312.i = phi { ptr, ptr, ptr, i32 } [ %371, %365 ], [ %455, %449 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i = phi ptr [ %.fca.0.extract.i407, %365 ], [ %.fca.0.extract57.i, %449 ]
  %.reg2mem59.0.sroa.phi120289.i = phi ptr [ %.sroa.1.i, %365 ], [ %.sroa.2124.i, %449 ]
  %.reg2mem59.0.sroa.phi117288.i = phi ptr [ %.sroa.0271.i, %365 ], [ %.sroa.0123.i, %449 ]
  %.reg2mem57.0.sroa.phi94287.i = phi ptr [ %.sroa.2.i, %365 ], [ %.sroa.2116.i, %449 ]
  %.reg2mem57.0.sroa.phi91286.i = phi ptr [ %.sroa.0.i, %365 ], [ %.sroa.0115.i, %449 ]
  %477 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %478 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %479 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i)
  %480 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i, i64 %.pre-phi313.i
  %481 = getelementptr i8, ptr %480, i64 56
  %482 = load ptr, ptr %481, align 8
  %483 = call ptr %482({ ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %484 = call { ptr, i160 } %483({ ptr, ptr, ptr, i32 } %.pre-phi312.i, { ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %.fca.0.extract97.i = extractvalue { ptr, i160 } %484, 0
  store ptr %.fca.0.extract97.i, ptr %.reg2mem59.0.sroa.phi117288.i, align 8
  %.fca.1.extract99.i = extractvalue { ptr, i160 } %484, 1
  store i160 %.fca.1.extract99.i, ptr %.reg2mem59.0.sroa.phi120289.i, align 8
  store ptr %.fca.0.extract97.i, ptr %.reg2mem57.0.sroa.phi91286.i, align 8
  store i160 %.fca.1.extract99.i, ptr %.reg2mem57.0.sroa.phi94287.i, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %131)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %132)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %133)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %134)
  %485 = icmp eq ptr %.fca.0.extract97.i, @nil_typ
  %486 = icmp eq ptr %.fca.0.extract97.i, null
  %487 = or i1 %485, %486
  br i1 %487, label %488, label %3015

488:                                              ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit
  %489 = add nuw i32 %321, 1
  %.sroa.051.0.insert.ext = zext i32 %489 to i160
  %490 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.051.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %109)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %111)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %113)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %114)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %115)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %116)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %117)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %118)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %119)
  %491 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %492 = load ptr, ptr %144, align 8
  %493 = call i32 %492({ ptr, i160 } %323)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %494 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %495 = load ptr, ptr %156, align 8
  %496 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %495, 0
  %497 = load ptr, ptr %157, align 8
  %498 = insertvalue { ptr, ptr, ptr, i32 } %496, ptr %497, 1
  %499 = load ptr, ptr %250, align 8
  %500 = insertvalue { ptr, ptr, ptr, i32 } %498, ptr %499, 2
  %501 = load i32, ptr %158, align 4
  %502 = insertvalue { ptr, ptr, ptr, i32 } %500, i32 %501, 3
  %hash_coef_ptr.i.i10.i1628 = getelementptr i8, ptr %495, i64 8
  %tbl_size_ptr.i.i11.i1629 = getelementptr i8, ptr %495, i64 16
  %offset_tbl_ptr.i.i12.i1630 = getelementptr i8, ptr %495, i64 40
  %hash_coef.i.i13.i1631 = load i64, ptr %hash_coef_ptr.i.i10.i1628, align 4
  %tbl_size.i.i14.i1632 = load i64, ptr %tbl_size_ptr.i.i11.i1629, align 4
  %offset_tbl.i.i15.i1633 = load ptr, ptr %offset_tbl_ptr.i.i12.i1630, align 8
  %product.i.i.i16.i1634 = mul i64 %hash_coef.i.i13.i1631, -5261542750394134544
  %shifted.i.i.i17.i1635 = lshr i64 %product.i.i.i16.i1634, 32
  %xored.i.i.i18.i1636 = xor i64 %shifted.i.i.i17.i1635, %product.i.i.i16.i1634
  %hash.i.i.i19.i1637 = and i64 %xored.i.i.i18.i1636, %tbl_size.i.i14.i1632
  %offset_ptr.i.i20.i1638 = getelementptr i32, ptr %offset_tbl.i.i15.i1633, i64 %hash.i.i.i19.i1637
  %offset.i.i21.i1639 = load i32, ptr %offset_ptr.i.i20.i1638, align 4
  %eq.i.i1640 = icmp eq i32 %501, %offset.i.i21.i1639
  call void @llvm.assume(i1 %eq.i.i1640) #30
  %503 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %504 = call ptr @llvm.invariant.start.p0(i64 600, ptr %495)
  %505 = sext i32 %501 to i64
  %506 = getelementptr ptr, ptr %495, i64 %505
  %507 = getelementptr i8, ptr %506, i64 64
  %508 = load ptr, ptr %507, align 8
  %509 = call ptr %508({ ptr, ptr, ptr, i32 } %502, ptr nonnull %2)
  %510 = call i32 %509({ ptr, ptr, ptr, i32 } %502, { ptr, ptr, ptr, i32 } %502, ptr nonnull %2)
  %511 = add i32 %510, -1
  %512 = and i32 %511, %493
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %513 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %514 = load ptr, ptr %156, align 8
  %515 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %514, 0
  %516 = load ptr, ptr %157, align 8
  %517 = insertvalue { ptr, ptr, ptr, i32 } %515, ptr %516, 1
  %518 = load ptr, ptr %250, align 8
  %519 = insertvalue { ptr, ptr, ptr, i32 } %517, ptr %518, 2
  %520 = load i32, ptr %158, align 4
  %521 = insertvalue { ptr, ptr, ptr, i32 } %519, i32 %520, 3
  %hash_coef_ptr.i.i162.i556 = getelementptr i8, ptr %514, i64 8
  %tbl_size_ptr.i.i163.i557 = getelementptr i8, ptr %514, i64 16
  %offset_tbl_ptr.i.i164.i558 = getelementptr i8, ptr %514, i64 40
  %hash_coef.i.i165.i559 = load i64, ptr %hash_coef_ptr.i.i162.i556, align 4
  %tbl_size.i.i166.i560 = load i64, ptr %tbl_size_ptr.i.i163.i557, align 4
  %offset_tbl.i.i167.i561 = load ptr, ptr %offset_tbl_ptr.i.i164.i558, align 8
  %product.i.i.i168.i562 = mul i64 %hash_coef.i.i165.i559, -5261542750394134544
  %shifted.i.i.i169.i563 = lshr i64 %product.i.i.i168.i562, 32
  %xored.i.i.i170.i564 = xor i64 %shifted.i.i.i169.i563, %product.i.i.i168.i562
  %hash.i.i.i171.i565 = and i64 %xored.i.i.i170.i564, %tbl_size.i.i166.i560
  %offset_ptr.i.i172.i566 = getelementptr i32, ptr %offset_tbl.i.i167.i561, i64 %hash.i.i.i171.i565
  %offset.i.i173.i567 = load i32, ptr %offset_ptr.i.i172.i566, align 4
  %eq.i.i568 = icmp eq i32 %520, %offset.i.i173.i567
  call void @llvm.assume(i1 %eq.i.i568) #30
  store ptr @_parameterization_Ptri32, ptr %118, align 8
  %522 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %118)
  %523 = call ptr @llvm.invariant.start.p0(i64 600, ptr %514)
  %524 = sext i32 %520 to i64
  %525 = getelementptr ptr, ptr %514, i64 %524
  %526 = getelementptr i8, ptr %525, i64 120
  %527 = load ptr, ptr %526, align 8
  store ptr @i32_typ, ptr %119, align 8
  %528 = call ptr %527({ ptr, ptr, ptr, i32 } %521, ptr nonnull %119)
  %529 = call { ptr, i160 } %528({ ptr, ptr, ptr, i32 } %521, { ptr, ptr, ptr, i32 } %521, ptr nonnull %118, i32 %512)
  %.fca.0.extract.i569 = extractvalue { ptr, i160 } %529, 0
  %530 = icmp ne ptr %.fca.0.extract.i569, @nil_typ
  %531 = icmp ne ptr %.fca.0.extract.i569, null
  %.not149.i570 = and i1 %530, %531
  br i1 %.not149.i570, label %532, label %.critedge.i571

532:                                              ; preds = %488
  %.fca.1.extract.i664 = extractvalue { ptr, i160 } %529, 1
  %.sroa.4520.8.extract.trunc.i665 = trunc i160 %.fca.1.extract.i664 to i64
  %533 = inttoptr i64 %.sroa.4520.8.extract.trunc.i665 to ptr
  %.sroa.7522.8.extract.shift.i666 = lshr i160 %.fca.1.extract.i664, 64
  %.sroa.7522.8.extract.trunc.i667 = trunc i160 %.sroa.7522.8.extract.shift.i666 to i64
  %534 = inttoptr i64 %.sroa.7522.8.extract.trunc.i667 to ptr
  %hash_coef_ptr.i.i176.i668 = getelementptr i8, ptr %.fca.0.extract.i569, i64 8
  %tbl_size_ptr.i.i177.i669 = getelementptr i8, ptr %.fca.0.extract.i569, i64 16
  %offset_tbl_ptr.i.i178.i670 = getelementptr i8, ptr %.fca.0.extract.i569, i64 40
  %hash_coef.i.i179.i671 = load i64, ptr %hash_coef_ptr.i.i176.i668, align 4
  %tbl_size.i.i180.i672 = load i64, ptr %tbl_size_ptr.i.i177.i669, align 4
  %offset_tbl.i.i181.i673 = load ptr, ptr %offset_tbl_ptr.i.i178.i670, align 8
  %product.i.i.i182.i674 = mul i64 %hash_coef.i.i179.i671, 4015701072841558310
  %shifted.i.i.i183.i675 = lshr i64 %product.i.i.i182.i674, 32
  %xored.i.i.i184.i676 = xor i64 %shifted.i.i.i183.i675, %product.i.i.i182.i674
  %hash.i.i.i185.i677 = and i64 %xored.i.i.i184.i676, %tbl_size.i.i180.i672
  %offset_ptr.i.i186.i678 = getelementptr i32, ptr %offset_tbl.i.i181.i673, i64 %hash.i.i.i185.i677
  %offset.i.i187.i679 = load i32, ptr %offset_ptr.i.i186.i678, align 4
  %535 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i569, 0
  %536 = insertvalue { ptr, ptr, ptr, i32 } %535, ptr %533, 1
  %537 = insertvalue { ptr, ptr, ptr, i32 } %536, ptr %534, 2
  %538 = insertvalue { ptr, ptr, ptr, i32 } %537, i32 %offset.i.i187.i679, 3
  %539 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %540 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %541 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i569)
  %542 = sext i32 %offset.i.i187.i679 to i64
  %543 = getelementptr ptr, ptr %.fca.0.extract.i569, i64 %542
  %544 = getelementptr i8, ptr %543, i64 64
  %545 = load ptr, ptr %544, align 8
  %546 = call ptr %545({ ptr, ptr, ptr, i32 } %538, ptr nonnull %2)
  %547 = call i32 %546({ ptr, ptr, ptr, i32 } %538, { ptr, ptr, ptr, i32 } %538, ptr nonnull %2)
  %548 = icmp eq i32 %547, %493
  %549 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %550 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %551 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i569)
  %552 = getelementptr i8, ptr %543, i64 48
  %553 = load ptr, ptr %552, align 8
  %554 = call ptr %553({ ptr, ptr, ptr, i32 } %538, ptr nonnull %2)
  %555 = call { ptr, i160 } %554({ ptr, ptr, ptr, i32 } %538, { ptr, ptr, ptr, i32 } %538, ptr nonnull %2)
  %556 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %557 = load ptr, ptr %145, align 8
  %558 = call i1 %557({ ptr, i160 } %555, { ptr, i160 } %323)
  %559 = and i1 %548, %558
  br i1 %559, label %560, label %.critedge.i571

560:                                              ; preds = %532
  %561 = load ptr, ptr %result.i, align 8
  %562 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %563 = load ptr, ptr %139, align 8
  %564 = load ptr, ptr %561, align 8
  %565 = getelementptr i8, ptr %564, i64 48
  %566 = load ptr, ptr %565, align 8
  %567 = call { i64, i64 } %566(ptr nonnull %561)
  %568 = extractvalue { i64, i64 } %567, 0
  %569 = extractvalue { i64, i64 } %567, 1
  %570 = urem i64 20, %569
  %571 = icmp eq i64 %570, 0
  %572 = sub i64 %569, %570
  %573 = select i1 %571, i64 0, i64 %572
  %574 = add i64 %568, 20
  %575 = add i64 %574, %573
  %576 = load ptr, ptr %563, align 8
  %577 = getelementptr i8, ptr %576, i64 48
  %578 = load ptr, ptr %577, align 8
  %579 = call { i64, i64 } %578(ptr nonnull %563)
  %580 = extractvalue { i64, i64 } %579, 0
  %581 = extractvalue { i64, i64 } %579, 1
  %582 = call i64 @llvm.umax.i64(i64 %569, i64 %581)
  %583 = call i64 @llvm.umax.i64(i64 %582, i64 8)
  %584 = urem i64 %575, %581
  %585 = icmp eq i64 %584, 0
  %586 = sub i64 %581, %584
  %587 = select i1 %585, i64 0, i64 %586
  %588 = add i64 %580, %575
  %589 = add i64 %588, %587
  %590 = urem i64 %589, %583
  %591 = icmp eq i64 %590, 0
  %592 = sub i64 %583, %590
  %593 = select i1 %591, i64 0, i64 %592
  %594 = add i64 %593, %589
  %result.i.i681 = call noalias ptr @bump_malloc_inner(i64 noundef %594, ptr nonnull @current_ptr) #29
  store ptr %561, ptr %result.i.i681, align 8
  %595 = getelementptr i8, ptr %result.i.i681, i64 8
  store ptr %563, ptr %595, align 8
  %596 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i681)
  store ptr @Entry, ptr %109, align 8
  store ptr %result.i.i681, ptr %245, align 8
  store i32 9, ptr %246, align 8
  %597 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %109)
  %598 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %599 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %600 = load ptr, ptr %561, align 8
  %601 = getelementptr i8, ptr %600, i64 48
  %602 = load ptr, ptr %601, align 8
  %603 = call { i64, i64 } %602(ptr nonnull %561)
  %604 = extractvalue { i64, i64 } %603, 1
  %605 = urem i64 20, %604
  %606 = icmp eq i64 %605, 0
  %reass.sub = sub i64 %604, %605
  %607 = add i64 %reass.sub, 20
  %608 = select i1 %606, i64 20, i64 %607
  %609 = getelementptr i8, ptr %result.i.i681, i64 %608
  %610 = load ptr, ptr %result.i.i681, align 8
  %611 = load ptr, ptr %610, align 8
  %612 = getelementptr i8, ptr %611, i64 64
  %613 = load ptr, ptr %612, align 8
  call void %613({ ptr, i160 } %323, ptr nonnull %610, ptr %609)
  %614 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %615 = load ptr, ptr %result.i.i681, align 8
  %616 = load ptr, ptr %615, align 8
  %617 = getelementptr i8, ptr %616, i64 48
  %618 = load ptr, ptr %617, align 8
  %619 = call { i64, i64 } %618(ptr nonnull %615)
  %620 = extractvalue { i64, i64 } %619, 0
  %621 = extractvalue { i64, i64 } %619, 1
  %622 = urem i64 20, %621
  %623 = icmp eq i64 %622, 0
  %624 = sub i64 %621, %622
  %625 = select i1 %623, i64 0, i64 %624
  %626 = add i64 %620, 20
  %627 = add i64 %626, %625
  %628 = load ptr, ptr %595, align 8
  %629 = load ptr, ptr %628, align 8
  %630 = getelementptr i8, ptr %629, i64 48
  %631 = load ptr, ptr %630, align 8
  %632 = call { i64, i64 } %631(ptr nonnull %628)
  %633 = extractvalue { i64, i64 } %632, 1
  %634 = urem i64 %627, %633
  %635 = icmp eq i64 %634, 0
  %636 = sub i64 %633, %634
  %637 = select i1 %635, i64 0, i64 %636
  %638 = getelementptr i8, ptr %result.i.i681, i64 %627
  %639 = getelementptr i8, ptr %638, i64 %637
  %640 = load ptr, ptr %595, align 8
  %641 = load ptr, ptr %640, align 8
  %642 = getelementptr i8, ptr %641, i64 64
  %643 = load ptr, ptr %642, align 8
  call void %643({ ptr, i160 } %490, ptr nonnull %640, ptr %639)
  %644 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %645 = getelementptr i8, ptr %result.i.i681, i64 16
  store i32 %493, ptr %645, align 4
  %646 = load ptr, ptr %247, align 8
  %647 = ptrtoint ptr %result.i.i681 to i64
  %648 = ptrtoint ptr %646 to i64
  %.sroa.2127.0.insert.ext.i682 = zext i64 %648 to i160
  %.sroa.2127.0.insert.shift.i683 = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i682, 64
  %.sroa.0126.0.insert.ext.i685 = zext i64 %647 to i160
  %.sroa.2127.0.insert.insert.i684 = or disjoint i160 %.sroa.2127.0.insert.shift.i683, %.sroa.0126.0.insert.ext.i685
  %.sroa.0126.0.insert.insert.i686 = or disjoint i160 %.sroa.2127.0.insert.insert.i684, 3062541302288446171170371466885913903104
  %649 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i686, 1
  %650 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %651 = load ptr, ptr %156, align 8
  %652 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %651, 0
  %653 = load ptr, ptr %157, align 8
  %654 = insertvalue { ptr, ptr, ptr, i32 } %652, ptr %653, 1
  %655 = load ptr, ptr %250, align 8
  %656 = insertvalue { ptr, ptr, ptr, i32 } %654, ptr %655, 2
  %657 = load i32, ptr %158, align 4
  %658 = insertvalue { ptr, ptr, ptr, i32 } %656, i32 %657, 3
  %hash_coef_ptr.i.i204.i691 = getelementptr i8, ptr %651, i64 8
  %tbl_size_ptr.i.i205.i692 = getelementptr i8, ptr %651, i64 16
  %offset_tbl_ptr.i.i206.i693 = getelementptr i8, ptr %651, i64 40
  %hash_coef.i.i207.i694 = load i64, ptr %hash_coef_ptr.i.i204.i691, align 4
  %tbl_size.i.i208.i695 = load i64, ptr %tbl_size_ptr.i.i205.i692, align 4
  %offset_tbl.i.i209.i696 = load ptr, ptr %offset_tbl_ptr.i.i206.i693, align 8
  %product.i.i.i210.i697 = mul i64 %hash_coef.i.i207.i694, -5261542750394134544
  %shifted.i.i.i211.i698 = lshr i64 %product.i.i.i210.i697, 32
  %xored.i.i.i212.i699 = xor i64 %shifted.i.i.i211.i698, %product.i.i.i210.i697
  %hash.i.i.i213.i700 = and i64 %xored.i.i.i212.i699, %tbl_size.i.i208.i695
  %offset_ptr.i.i214.i701 = getelementptr i32, ptr %offset_tbl.i.i209.i696, i64 %hash.i.i.i213.i700
  %offset.i.i215.i702 = load i32, ptr %offset_ptr.i.i214.i701, align 4
  %eq.i218.i703 = icmp eq i32 %657, %offset.i.i215.i702
  call void @llvm.assume(i1 %eq.i218.i703) #30
  %659 = load ptr, ptr %result.i, align 8
  %660 = load ptr, ptr %139, align 8
  %result.i219.i704 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %661 = getelementptr i8, ptr %result.i219.i704, i64 16
  store ptr %660, ptr %661, align 8
  %662 = getelementptr i8, ptr %result.i219.i704, i64 8
  store ptr %659, ptr %662, align 8
  %663 = getelementptr i8, ptr %result.i219.i704, i64 24
  store ptr null, ptr %663, align 8
  %664 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i704)
  store ptr @Entry, ptr %result.i219.i704, align 8
  store ptr @_parameterization_Ptri32, ptr %110, align 8
  store ptr %result.i219.i704, ptr %248, align 8
  %665 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %110)
  %666 = call ptr @llvm.invariant.start.p0(i64 600, ptr %651)
  %667 = sext i32 %657 to i64
  %668 = getelementptr ptr, ptr %651, i64 %667
  %669 = getelementptr i8, ptr %668, i64 128
  %670 = load ptr, ptr %669, align 8
  store ptr @i32_typ, ptr %111, align 8
  store ptr @Entry, ptr %249, align 8
  %671 = call ptr %670({ ptr, ptr, ptr, i32 } %658, ptr nonnull %111)
  call void %671({ ptr, ptr, ptr, i32 } %658, { ptr, ptr, ptr, i32 } %658, ptr nonnull %110, i32 %512, { ptr, i160 } %649)
  br label %HashMap_insert_keyK_valueV.exit705

.critedge.i571:                                   ; preds = %532, %488
  %672 = add i32 %493, 2127912214
  %673 = shl i32 %493, 12
  %674 = add i32 %672, %673
  %675 = ashr i32 %674, 19
  %676 = xor i32 %674, %675
  %677 = xor i32 %676, -949894596
  %678 = add i32 %677, 374761393
  %679 = shl i32 %677, 5
  %680 = add i32 %678, %679
  %681 = add i32 %680, -744332180
  %682 = shl i32 %680, 9
  %683 = xor i32 %681, %682
  %684 = add i32 %683, -42973499
  %685 = shl i32 %683, 3
  %686 = add i32 %684, %685
  %687 = ashr i32 %686, 16
  %688 = xor i32 %686, %687
  %689 = xor i32 %688, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %690 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %691 = load ptr, ptr %169, align 8
  %692 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %691, 0
  %693 = load ptr, ptr %170, align 8
  %694 = insertvalue { ptr, ptr, ptr, i32 } %692, ptr %693, 1
  %695 = load ptr, ptr %251, align 8
  %696 = insertvalue { ptr, ptr, ptr, i32 } %694, ptr %695, 2
  %697 = load i32, ptr %171, align 4
  %698 = insertvalue { ptr, ptr, ptr, i32 } %696, i32 %697, 3
  %hash_coef_ptr.i.i10.i1659 = getelementptr i8, ptr %691, i64 8
  %tbl_size_ptr.i.i11.i1660 = getelementptr i8, ptr %691, i64 16
  %offset_tbl_ptr.i.i12.i1661 = getelementptr i8, ptr %691, i64 40
  %hash_coef.i.i13.i1662 = load i64, ptr %hash_coef_ptr.i.i10.i1659, align 4
  %tbl_size.i.i14.i1663 = load i64, ptr %tbl_size_ptr.i.i11.i1660, align 4
  %offset_tbl.i.i15.i1664 = load ptr, ptr %offset_tbl_ptr.i.i12.i1661, align 8
  %product.i.i.i16.i1665 = mul i64 %hash_coef.i.i13.i1662, -5261542750394134544
  %shifted.i.i.i17.i1666 = lshr i64 %product.i.i.i16.i1665, 32
  %xored.i.i.i18.i1667 = xor i64 %shifted.i.i.i17.i1666, %product.i.i.i16.i1665
  %hash.i.i.i19.i1668 = and i64 %xored.i.i.i18.i1667, %tbl_size.i.i14.i1663
  %offset_ptr.i.i20.i1669 = getelementptr i32, ptr %offset_tbl.i.i15.i1664, i64 %hash.i.i.i19.i1668
  %offset.i.i21.i1670 = load i32, ptr %offset_ptr.i.i20.i1669, align 4
  %eq.i.i1671 = icmp eq i32 %697, %offset.i.i21.i1670
  call void @llvm.assume(i1 %eq.i.i1671) #30
  %699 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %700 = call ptr @llvm.invariant.start.p0(i64 600, ptr %691)
  %701 = sext i32 %697 to i64
  %702 = getelementptr ptr, ptr %691, i64 %701
  %703 = getelementptr i8, ptr %702, i64 64
  %704 = load ptr, ptr %703, align 8
  %705 = call ptr %704({ ptr, ptr, ptr, i32 } %698, ptr nonnull %2)
  %706 = call i32 %705({ ptr, ptr, ptr, i32 } %698, { ptr, ptr, ptr, i32 } %698, ptr nonnull %2)
  %707 = add i32 %706, -1
  %708 = and i32 %707, %689
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %709 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %710 = load ptr, ptr %169, align 8
  %711 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %710, 0
  %712 = load ptr, ptr %170, align 8
  %713 = insertvalue { ptr, ptr, ptr, i32 } %711, ptr %712, 1
  %714 = load ptr, ptr %251, align 8
  %715 = insertvalue { ptr, ptr, ptr, i32 } %713, ptr %714, 2
  %716 = load i32, ptr %171, align 4
  %717 = insertvalue { ptr, ptr, ptr, i32 } %715, i32 %716, 3
  %hash_coef_ptr.i.i221.i576 = getelementptr i8, ptr %710, i64 8
  %tbl_size_ptr.i.i222.i577 = getelementptr i8, ptr %710, i64 16
  %offset_tbl_ptr.i.i223.i578 = getelementptr i8, ptr %710, i64 40
  %hash_coef.i.i224.i579 = load i64, ptr %hash_coef_ptr.i.i221.i576, align 4
  %tbl_size.i.i225.i580 = load i64, ptr %tbl_size_ptr.i.i222.i577, align 4
  %offset_tbl.i.i226.i581 = load ptr, ptr %offset_tbl_ptr.i.i223.i578, align 8
  %product.i.i.i227.i582 = mul i64 %hash_coef.i.i224.i579, -5261542750394134544
  %shifted.i.i.i228.i583 = lshr i64 %product.i.i.i227.i582, 32
  %xored.i.i.i229.i584 = xor i64 %shifted.i.i.i228.i583, %product.i.i.i227.i582
  %hash.i.i.i230.i585 = and i64 %xored.i.i.i229.i584, %tbl_size.i.i225.i580
  %offset_ptr.i.i231.i586 = getelementptr i32, ptr %offset_tbl.i.i226.i581, i64 %hash.i.i.i230.i585
  %offset.i.i232.i587 = load i32, ptr %offset_ptr.i.i231.i586, align 4
  %eq.i235.i588 = icmp eq i32 %716, %offset.i.i232.i587
  call void @llvm.assume(i1 %eq.i235.i588) #30
  store ptr @_parameterization_Ptri32, ptr %112, align 8
  %718 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %112)
  %719 = call ptr @llvm.invariant.start.p0(i64 600, ptr %710)
  %720 = sext i32 %716 to i64
  %721 = getelementptr ptr, ptr %710, i64 %720
  %722 = getelementptr i8, ptr %721, i64 120
  %723 = load ptr, ptr %722, align 8
  store ptr @i32_typ, ptr %113, align 8
  %724 = call ptr %723({ ptr, ptr, ptr, i32 } %717, ptr nonnull %113)
  %725 = call { ptr, i160 } %724({ ptr, ptr, ptr, i32 } %717, { ptr, ptr, ptr, i32 } %717, ptr nonnull %112, i32 %708)
  %.fca.0.extract102.i589 = extractvalue { ptr, i160 } %725, 0
  %726 = icmp ne ptr %.fca.0.extract102.i589, @nil_typ
  %727 = icmp ne ptr %.fca.0.extract102.i589, null
  %.not151.i590 = and i1 %726, %727
  br i1 %.not151.i590, label %728, label %.critedge158.i591

728:                                              ; preds = %.critedge.i571
  %.fca.1.extract104.i623 = extractvalue { ptr, i160 } %725, 1
  %.sroa.4.8.extract.trunc.i624 = trunc i160 %.fca.1.extract104.i623 to i64
  %729 = inttoptr i64 %.sroa.4.8.extract.trunc.i624 to ptr
  %.sroa.7508.8.extract.shift.i625 = lshr i160 %.fca.1.extract104.i623, 64
  %.sroa.7508.8.extract.trunc.i626 = trunc i160 %.sroa.7508.8.extract.shift.i625 to i64
  %730 = inttoptr i64 %.sroa.7508.8.extract.trunc.i626 to ptr
  %hash_coef_ptr.i.i237.i627 = getelementptr i8, ptr %.fca.0.extract102.i589, i64 8
  %tbl_size_ptr.i.i238.i628 = getelementptr i8, ptr %.fca.0.extract102.i589, i64 16
  %offset_tbl_ptr.i.i239.i629 = getelementptr i8, ptr %.fca.0.extract102.i589, i64 40
  %hash_coef.i.i240.i630 = load i64, ptr %hash_coef_ptr.i.i237.i627, align 4
  %tbl_size.i.i241.i631 = load i64, ptr %tbl_size_ptr.i.i238.i628, align 4
  %offset_tbl.i.i242.i632 = load ptr, ptr %offset_tbl_ptr.i.i239.i629, align 8
  %product.i.i.i243.i633 = mul i64 %hash_coef.i.i240.i630, 4015701072841558310
  %shifted.i.i.i244.i634 = lshr i64 %product.i.i.i243.i633, 32
  %xored.i.i.i245.i635 = xor i64 %shifted.i.i.i244.i634, %product.i.i.i243.i633
  %hash.i.i.i246.i636 = and i64 %xored.i.i.i245.i635, %tbl_size.i.i241.i631
  %offset_ptr.i.i247.i637 = getelementptr i32, ptr %offset_tbl.i.i242.i632, i64 %hash.i.i.i246.i636
  %offset.i.i248.i638 = load i32, ptr %offset_ptr.i.i247.i637, align 4
  %731 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i589, 0
  %732 = insertvalue { ptr, ptr, ptr, i32 } %731, ptr %729, 1
  %733 = insertvalue { ptr, ptr, ptr, i32 } %732, ptr %730, 2
  %734 = insertvalue { ptr, ptr, ptr, i32 } %733, i32 %offset.i.i248.i638, 3
  %735 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %736 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %737 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i589)
  %738 = sext i32 %offset.i.i248.i638 to i64
  %739 = getelementptr ptr, ptr %.fca.0.extract102.i589, i64 %738
  %740 = getelementptr i8, ptr %739, i64 64
  %741 = load ptr, ptr %740, align 8
  %742 = call ptr %741({ ptr, ptr, ptr, i32 } %734, ptr nonnull %2)
  %743 = call i32 %742({ ptr, ptr, ptr, i32 } %734, { ptr, ptr, ptr, i32 } %734, ptr nonnull %2)
  %744 = icmp eq i32 %743, %493
  %745 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %746 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %747 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i589)
  %748 = getelementptr i8, ptr %739, i64 48
  %749 = load ptr, ptr %748, align 8
  %750 = call ptr %749({ ptr, ptr, ptr, i32 } %734, ptr nonnull %2)
  %751 = call { ptr, i160 } %750({ ptr, ptr, ptr, i32 } %734, { ptr, ptr, ptr, i32 } %734, ptr nonnull %2)
  %752 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %753 = load ptr, ptr %145, align 8
  %754 = call i1 %753({ ptr, i160 } %751, { ptr, i160 } %323)
  %755 = and i1 %744, %754
  br i1 %755, label %756, label %.critedge158.i591

756:                                              ; preds = %728
  %757 = load ptr, ptr %result.i, align 8
  %758 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %759 = load ptr, ptr %139, align 8
  %760 = load ptr, ptr %757, align 8
  %761 = getelementptr i8, ptr %760, i64 48
  %762 = load ptr, ptr %761, align 8
  %763 = call { i64, i64 } %762(ptr nonnull %757)
  %764 = extractvalue { i64, i64 } %763, 0
  %765 = extractvalue { i64, i64 } %763, 1
  %766 = urem i64 20, %765
  %767 = icmp eq i64 %766, 0
  %768 = sub i64 %765, %766
  %769 = select i1 %767, i64 0, i64 %768
  %770 = add i64 %764, 20
  %771 = add i64 %770, %769
  %772 = load ptr, ptr %759, align 8
  %773 = getelementptr i8, ptr %772, i64 48
  %774 = load ptr, ptr %773, align 8
  %775 = call { i64, i64 } %774(ptr nonnull %759)
  %776 = extractvalue { i64, i64 } %775, 0
  %777 = extractvalue { i64, i64 } %775, 1
  %778 = call i64 @llvm.umax.i64(i64 %765, i64 %777)
  %779 = call i64 @llvm.umax.i64(i64 %778, i64 8)
  %780 = urem i64 %771, %777
  %781 = icmp eq i64 %780, 0
  %782 = sub i64 %777, %780
  %783 = select i1 %781, i64 0, i64 %782
  %784 = add i64 %776, %771
  %785 = add i64 %784, %783
  %786 = urem i64 %785, %779
  %787 = icmp eq i64 %786, 0
  %788 = sub i64 %779, %786
  %789 = select i1 %787, i64 0, i64 %788
  %790 = add i64 %789, %785
  %result.i250.i640 = call noalias ptr @bump_malloc_inner(i64 noundef %790, ptr nonnull @current_ptr) #29
  store ptr %757, ptr %result.i250.i640, align 8
  %791 = getelementptr i8, ptr %result.i250.i640, i64 8
  store ptr %759, ptr %791, align 8
  %792 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i640)
  store ptr @Entry, ptr %114, align 8
  store ptr %result.i250.i640, ptr %240, align 8
  store i32 9, ptr %241, align 8
  %793 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %114)
  %794 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %795 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %796 = load ptr, ptr %757, align 8
  %797 = getelementptr i8, ptr %796, i64 48
  %798 = load ptr, ptr %797, align 8
  %799 = call { i64, i64 } %798(ptr nonnull %757)
  %800 = extractvalue { i64, i64 } %799, 1
  %801 = urem i64 20, %800
  %802 = icmp eq i64 %801, 0
  %reass.sub3305 = sub i64 %800, %801
  %803 = add i64 %reass.sub3305, 20
  %804 = select i1 %802, i64 20, i64 %803
  %805 = getelementptr i8, ptr %result.i250.i640, i64 %804
  %806 = load ptr, ptr %result.i250.i640, align 8
  %807 = load ptr, ptr %806, align 8
  %808 = getelementptr i8, ptr %807, i64 64
  %809 = load ptr, ptr %808, align 8
  call void %809({ ptr, i160 } %323, ptr nonnull %806, ptr %805)
  %810 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %811 = load ptr, ptr %result.i250.i640, align 8
  %812 = load ptr, ptr %811, align 8
  %813 = getelementptr i8, ptr %812, i64 48
  %814 = load ptr, ptr %813, align 8
  %815 = call { i64, i64 } %814(ptr nonnull %811)
  %816 = extractvalue { i64, i64 } %815, 0
  %817 = extractvalue { i64, i64 } %815, 1
  %818 = urem i64 20, %817
  %819 = icmp eq i64 %818, 0
  %820 = sub i64 %817, %818
  %821 = select i1 %819, i64 0, i64 %820
  %822 = add i64 %816, 20
  %823 = add i64 %822, %821
  %824 = load ptr, ptr %791, align 8
  %825 = load ptr, ptr %824, align 8
  %826 = getelementptr i8, ptr %825, i64 48
  %827 = load ptr, ptr %826, align 8
  %828 = call { i64, i64 } %827(ptr nonnull %824)
  %829 = extractvalue { i64, i64 } %828, 1
  %830 = urem i64 %823, %829
  %831 = icmp eq i64 %830, 0
  %832 = sub i64 %829, %830
  %833 = select i1 %831, i64 0, i64 %832
  %834 = getelementptr i8, ptr %result.i250.i640, i64 %823
  %835 = getelementptr i8, ptr %834, i64 %833
  %836 = load ptr, ptr %791, align 8
  %837 = load ptr, ptr %836, align 8
  %838 = getelementptr i8, ptr %837, i64 64
  %839 = load ptr, ptr %838, align 8
  call void %839({ ptr, i160 } %490, ptr nonnull %836, ptr %835)
  %840 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %841 = getelementptr i8, ptr %result.i250.i640, i64 16
  store i32 %493, ptr %841, align 4
  %842 = load ptr, ptr %242, align 8
  %843 = ptrtoint ptr %result.i250.i640 to i64
  %844 = ptrtoint ptr %842 to i64
  %.sroa.282.0.insert.ext.i641 = zext i64 %844 to i160
  %.sroa.282.0.insert.shift.i642 = shl nuw nsw i160 %.sroa.282.0.insert.ext.i641, 64
  %.sroa.081.0.insert.ext.i644 = zext i64 %843 to i160
  %.sroa.282.0.insert.insert.i643 = or disjoint i160 %.sroa.282.0.insert.shift.i642, %.sroa.081.0.insert.ext.i644
  %.sroa.081.0.insert.insert.i645 = or disjoint i160 %.sroa.282.0.insert.insert.i643, 3062541302288446171170371466885913903104
  %845 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i645, 1
  %846 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %847 = load ptr, ptr %169, align 8
  %848 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %847, 0
  %849 = load ptr, ptr %170, align 8
  %850 = insertvalue { ptr, ptr, ptr, i32 } %848, ptr %849, 1
  %851 = load ptr, ptr %251, align 8
  %852 = insertvalue { ptr, ptr, ptr, i32 } %850, ptr %851, 2
  %853 = load i32, ptr %171, align 4
  %854 = insertvalue { ptr, ptr, ptr, i32 } %852, i32 %853, 3
  %hash_coef_ptr.i.i266.i650 = getelementptr i8, ptr %847, i64 8
  %tbl_size_ptr.i.i267.i651 = getelementptr i8, ptr %847, i64 16
  %offset_tbl_ptr.i.i268.i652 = getelementptr i8, ptr %847, i64 40
  %hash_coef.i.i269.i653 = load i64, ptr %hash_coef_ptr.i.i266.i650, align 4
  %tbl_size.i.i270.i654 = load i64, ptr %tbl_size_ptr.i.i267.i651, align 4
  %offset_tbl.i.i271.i655 = load ptr, ptr %offset_tbl_ptr.i.i268.i652, align 8
  %product.i.i.i272.i656 = mul i64 %hash_coef.i.i269.i653, -5261542750394134544
  %shifted.i.i.i273.i657 = lshr i64 %product.i.i.i272.i656, 32
  %xored.i.i.i274.i658 = xor i64 %shifted.i.i.i273.i657, %product.i.i.i272.i656
  %hash.i.i.i275.i659 = and i64 %xored.i.i.i274.i658, %tbl_size.i.i270.i654
  %offset_ptr.i.i276.i660 = getelementptr i32, ptr %offset_tbl.i.i271.i655, i64 %hash.i.i.i275.i659
  %offset.i.i277.i661 = load i32, ptr %offset_ptr.i.i276.i660, align 4
  %eq.i280.i662 = icmp eq i32 %853, %offset.i.i277.i661
  call void @llvm.assume(i1 %eq.i280.i662) #30
  %855 = load ptr, ptr %result.i, align 8
  %856 = load ptr, ptr %139, align 8
  %result.i281.i663 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %857 = getelementptr i8, ptr %result.i281.i663, i64 16
  store ptr %856, ptr %857, align 8
  %858 = getelementptr i8, ptr %result.i281.i663, i64 8
  store ptr %855, ptr %858, align 8
  %859 = getelementptr i8, ptr %result.i281.i663, i64 24
  store ptr null, ptr %859, align 8
  %860 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i663)
  store ptr @Entry, ptr %result.i281.i663, align 8
  store ptr @_parameterization_Ptri32, ptr %115, align 8
  store ptr %result.i281.i663, ptr %243, align 8
  %861 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %115)
  %862 = call ptr @llvm.invariant.start.p0(i64 600, ptr %847)
  %863 = sext i32 %853 to i64
  %864 = getelementptr ptr, ptr %847, i64 %863
  %865 = getelementptr i8, ptr %864, i64 128
  %866 = load ptr, ptr %865, align 8
  store ptr @i32_typ, ptr %116, align 8
  store ptr @Entry, ptr %244, align 8
  %867 = call ptr %866({ ptr, ptr, ptr, i32 } %854, ptr nonnull %116)
  call void %867({ ptr, ptr, ptr, i32 } %854, { ptr, ptr, ptr, i32 } %854, ptr nonnull %115, i32 %708, { ptr, i160 } %845)
  br label %HashMap_insert_keyK_valueV.exit705

.critedge158.i591:                                ; preds = %728, %.critedge.i571
  %868 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %869 = load ptr, ptr %156, align 8
  %870 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %869, 0
  %871 = load ptr, ptr %157, align 8
  %872 = insertvalue { ptr, ptr, ptr, i32 } %870, ptr %871, 1
  %873 = load ptr, ptr %250, align 8
  %874 = insertvalue { ptr, ptr, ptr, i32 } %872, ptr %873, 2
  %875 = load i32, ptr %158, align 4
  %876 = insertvalue { ptr, ptr, ptr, i32 } %874, i32 %875, 3
  %hash_coef_ptr.i.i283.i596 = getelementptr i8, ptr %869, i64 8
  %tbl_size_ptr.i.i284.i597 = getelementptr i8, ptr %869, i64 16
  %offset_tbl_ptr.i.i285.i598 = getelementptr i8, ptr %869, i64 40
  %hash_coef.i.i286.i599 = load i64, ptr %hash_coef_ptr.i.i283.i596, align 4
  %tbl_size.i.i287.i600 = load i64, ptr %tbl_size_ptr.i.i284.i597, align 4
  %offset_tbl.i.i288.i601 = load ptr, ptr %offset_tbl_ptr.i.i285.i598, align 8
  %product.i.i.i289.i602 = mul i64 %hash_coef.i.i286.i599, -5261542750394134544
  %shifted.i.i.i290.i603 = lshr i64 %product.i.i.i289.i602, 32
  %xored.i.i.i291.i604 = xor i64 %shifted.i.i.i290.i603, %product.i.i.i289.i602
  %hash.i.i.i292.i605 = and i64 %xored.i.i.i291.i604, %tbl_size.i.i287.i600
  %offset_ptr.i.i293.i606 = getelementptr i32, ptr %offset_tbl.i.i288.i601, i64 %hash.i.i.i292.i605
  %offset.i.i294.i607 = load i32, ptr %offset_ptr.i.i293.i606, align 4
  %eq.i297.i608 = icmp eq i32 %875, %offset.i.i294.i607
  call void @llvm.assume(i1 %eq.i297.i608) #30
  %877 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %878 = call ptr @llvm.invariant.start.p0(i64 600, ptr %869)
  %879 = sext i32 %875 to i64
  %880 = getelementptr ptr, ptr %869, i64 %879
  %881 = getelementptr i8, ptr %880, i64 64
  %882 = load ptr, ptr %881, align 8
  %883 = call ptr %882({ ptr, ptr, ptr, i32 } %876, ptr nonnull %2)
  %884 = call i32 %883({ ptr, ptr, ptr, i32 } %876, { ptr, ptr, ptr, i32 } %876, ptr nonnull %2)
  %885 = load i32, ptr %252, align 4
  %.not.i609 = icmp slt i32 %885, %884
  br i1 %.not.i609, label %._crit_edge.i610, label %886

886:                                              ; preds = %.critedge158.i591
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %53)
  %887 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %888 = load ptr, ptr %156, align 8
  %889 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %888, 0
  %890 = load ptr, ptr %157, align 8
  %891 = insertvalue { ptr, ptr, ptr, i32 } %889, ptr %890, 1
  %892 = load ptr, ptr %250, align 8
  %893 = insertvalue { ptr, ptr, ptr, i32 } %891, ptr %892, 2
  %894 = load i32, ptr %158, align 4
  %895 = insertvalue { ptr, ptr, ptr, i32 } %893, i32 %894, 3
  %hash_coef_ptr.i.i64.i1688 = getelementptr i8, ptr %888, i64 8
  %tbl_size_ptr.i.i65.i1689 = getelementptr i8, ptr %888, i64 16
  %offset_tbl_ptr.i.i66.i1690 = getelementptr i8, ptr %888, i64 40
  %hash_coef.i.i67.i1691 = load i64, ptr %hash_coef_ptr.i.i64.i1688, align 4
  %tbl_size.i.i68.i1692 = load i64, ptr %tbl_size_ptr.i.i65.i1689, align 4
  %offset_tbl.i.i69.i1693 = load ptr, ptr %offset_tbl_ptr.i.i66.i1690, align 8
  %product.i.i.i70.i1694 = mul i64 %hash_coef.i.i67.i1691, -5261542750394134544
  %shifted.i.i.i71.i1695 = lshr i64 %product.i.i.i70.i1694, 32
  %xored.i.i.i72.i1696 = xor i64 %shifted.i.i.i71.i1695, %product.i.i.i70.i1694
  %hash.i.i.i73.i1697 = and i64 %xored.i.i.i72.i1696, %tbl_size.i.i68.i1692
  %offset_ptr.i.i74.i1698 = getelementptr i32, ptr %offset_tbl.i.i69.i1693, i64 %hash.i.i.i73.i1697
  %offset.i.i75.i1699 = load i32, ptr %offset_ptr.i.i74.i1698, align 4
  %eq.i.i1700 = icmp eq i32 %894, %offset.i.i75.i1699
  call void @llvm.assume(i1 %eq.i.i1700) #30
  %896 = load ptr, ptr %169, align 8
  %897 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %896, 0
  %898 = load ptr, ptr %170, align 8
  %899 = insertvalue { ptr, ptr, ptr, i32 } %897, ptr %898, 1
  %900 = load ptr, ptr %251, align 8
  %901 = insertvalue { ptr, ptr, ptr, i32 } %899, ptr %900, 2
  %902 = load i32, ptr %171, align 4
  %903 = insertvalue { ptr, ptr, ptr, i32 } %901, i32 %902, 3
  %hash_coef_ptr.i.i92.i1705 = getelementptr i8, ptr %896, i64 8
  %tbl_size_ptr.i.i93.i1706 = getelementptr i8, ptr %896, i64 16
  %offset_tbl_ptr.i.i94.i1707 = getelementptr i8, ptr %896, i64 40
  %hash_coef.i.i95.i1708 = load i64, ptr %hash_coef_ptr.i.i92.i1705, align 4
  %tbl_size.i.i96.i1709 = load i64, ptr %tbl_size_ptr.i.i93.i1706, align 4
  %offset_tbl.i.i97.i1710 = load ptr, ptr %offset_tbl_ptr.i.i94.i1707, align 8
  %product.i.i.i98.i1711 = mul i64 %hash_coef.i.i95.i1708, -5261542750394134544
  %shifted.i.i.i99.i1712 = lshr i64 %product.i.i.i98.i1711, 32
  %xored.i.i.i100.i1713 = xor i64 %shifted.i.i.i99.i1712, %product.i.i.i98.i1711
  %hash.i.i.i101.i1714 = and i64 %xored.i.i.i100.i1713, %tbl_size.i.i96.i1709
  %offset_ptr.i.i102.i1715 = getelementptr i32, ptr %offset_tbl.i.i97.i1710, i64 %hash.i.i.i101.i1714
  %offset.i.i103.i1716 = load i32, ptr %offset_ptr.i.i102.i1715, align 4
  %eq.i106.i1717 = icmp eq i32 %902, %offset.i.i103.i1716
  call void @llvm.assume(i1 %eq.i106.i1717) #30
  %904 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %905 = call ptr @llvm.invariant.start.p0(i64 600, ptr %888)
  %906 = sext i32 %894 to i64
  %907 = getelementptr ptr, ptr %888, i64 %906
  %908 = getelementptr i8, ptr %907, i64 64
  %909 = load ptr, ptr %908, align 8
  %910 = call ptr %909({ ptr, ptr, ptr, i32 } %895, ptr nonnull %2)
  %911 = call i32 %910({ ptr, ptr, ptr, i32 } %895, { ptr, ptr, ptr, i32 } %895, ptr nonnull %2)
  %912 = shl i32 %911, 1
  %913 = load i32, ptr %252, align 4
  %914 = load ptr, ptr %result.i, align 8
  %915 = load ptr, ptr %139, align 8
  %916 = sext i32 %913 to i64
  %917 = shl nsw i64 %916, 5
  %result.i.i.i1720 = call noalias ptr @bump_malloc_inner(i64 noundef %917, ptr nonnull @current_ptr) #29
  %918 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %919 = icmp sgt i32 %911, 0
  br i1 %919, label %.lr.ph434.i1753, label %._crit_edge395.i1722

.lr.ph434.i1753:                                  ; preds = %886
  %invariant.gep.i1721 = getelementptr i8, ptr %888, i64 120
  %920 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1756 = getelementptr ptr, ptr %invariant.gep.i1721, i64 %906
  br label %921

921:                                              ; preds = %943, %.lr.ph434.i1753
  %.reg2mem105.0432.i1754 = phi i32 [ 0, %.lr.ph434.i1753 ], [ %.reg2mem101.0.i1759, %943 ]
  %.reg2mem103.0431.i1755 = phi i32 [ 0, %.lr.ph434.i1753 ], [ %944, %943 ]
  store ptr @_parameterization_Ptri32, ptr %48, align 8
  %922 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %48)
  %923 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %888)
  %924 = load ptr, ptr %gep.i1756, align 8
  store ptr @i32_typ, ptr %49, align 8
  %925 = call ptr %924({ ptr, ptr, ptr, i32 } %895, ptr nonnull %49)
  %926 = call { ptr, i160 } %925({ ptr, ptr, ptr, i32 } %895, { ptr, ptr, ptr, i32 } %895, ptr nonnull %48, i32 %.reg2mem103.0431.i1755)
  %.fca.0.extract52.i1757 = extractvalue { ptr, i160 } %926, 0
  %927 = icmp ne ptr %.fca.0.extract52.i1757, @nil_typ
  %928 = icmp ne ptr %.fca.0.extract52.i1757, null
  %.not60.i1758 = and i1 %927, %928
  br i1 %.not60.i1758, label %929, label %943

929:                                              ; preds = %921
  %hash_coef_ptr.i.i137.i1786 = getelementptr i8, ptr %.fca.0.extract52.i1757, i64 8
  %tbl_size_ptr.i.i138.i1787 = getelementptr i8, ptr %.fca.0.extract52.i1757, i64 16
  %offset_tbl_ptr.i.i139.i1788 = getelementptr i8, ptr %.fca.0.extract52.i1757, i64 40
  %hash_coef.i.i140.i1789 = load i64, ptr %hash_coef_ptr.i.i137.i1786, align 4
  %tbl_size.i.i141.i1790 = load i64, ptr %tbl_size_ptr.i.i138.i1787, align 4
  %offset_tbl.i.i142.i1791 = load ptr, ptr %offset_tbl_ptr.i.i139.i1788, align 8
  %product.i.i.i143.i1792 = mul i64 %hash_coef.i.i140.i1789, 4015701072841558310
  %shifted.i.i.i144.i1793 = lshr i64 %product.i.i.i143.i1792, 32
  %xored.i.i.i145.i1794 = xor i64 %shifted.i.i.i144.i1793, %product.i.i.i143.i1792
  %hash.i.i.i146.i1795 = and i64 %xored.i.i.i145.i1794, %tbl_size.i.i141.i1790
  %offset_ptr.i.i147.i1796 = getelementptr i32, ptr %offset_tbl.i.i142.i1791, i64 %hash.i.i.i146.i1795
  %offset.i.i148.i1797 = load i32, ptr %offset_ptr.i.i147.i1796, align 4
  %930 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %931 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %932 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %933 = icmp slt i32 %.reg2mem105.0432.i1754, %913
  br i1 %933, label %934, label %._crit_edge.i1798

934:                                              ; preds = %929
  %.fca.1.extract54.i1799 = extractvalue { ptr, i160 } %926, 1
  %.sroa.351.0.insert.ext.i1800 = zext i32 %offset.i.i148.i1797 to i160
  %.sroa.351.0.insert.shift.i1801 = shl nuw i160 %.sroa.351.0.insert.ext.i1800, 128
  %935 = and i160 %.fca.1.extract54.i1799, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1802 = or disjoint i160 %.sroa.351.0.insert.shift.i1801, %935
  %936 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %937 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %938 = sext i32 %.reg2mem105.0432.i1754 to i64
  %939 = shl nsw i64 %938, 5
  %940 = getelementptr i8, ptr %result.i.i.i1720, i64 %939
  store ptr %.fca.0.extract52.i1757, ptr %940, align 8
  %941 = getelementptr i8, ptr %940, i64 8
  store i160 %.sroa.049.0.insert.insert.i1802, ptr %941, align 4
  br label %._crit_edge.i1798

._crit_edge.i1798:                                ; preds = %934, %929
  %942 = add i32 %.reg2mem105.0432.i1754, 1
  br label %943

943:                                              ; preds = %._crit_edge.i1798, %921
  %.reg2mem101.0.i1759 = phi i32 [ %942, %._crit_edge.i1798 ], [ %.reg2mem105.0432.i1754, %921 ]
  %944 = add nuw nsw i32 %.reg2mem103.0431.i1755, 1
  %945 = icmp slt i32 %944, %911
  br i1 %945, label %921, label %.lr.ph.i1760

.lr.ph.i1760:                                     ; preds = %943
  %invariant.gep396.i1761 = getelementptr i8, ptr %896, i64 120
  %946 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %947 = sext i32 %902 to i64
  %gep397.i1764 = getelementptr ptr, ptr %invariant.gep396.i1761, i64 %947
  br label %948

948:                                              ; preds = %970, %.lr.ph.i1760
  %.reg2mem91.0394.i1762 = phi i32 [ %.reg2mem101.0.i1759, %.lr.ph.i1760 ], [ %.reg2mem87.0.i1767, %970 ]
  %.reg2mem89.0393.i1763 = phi i32 [ 0, %.lr.ph.i1760 ], [ %971, %970 ]
  store ptr @_parameterization_Ptri32, ptr %50, align 8
  %949 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %50)
  %950 = call ptr @llvm.invariant.start.p0(i64 600, ptr %896)
  %951 = load ptr, ptr %gep397.i1764, align 8
  store ptr @i32_typ, ptr %51, align 8
  %952 = call ptr %951({ ptr, ptr, ptr, i32 } %903, ptr nonnull %51)
  %953 = call { ptr, i160 } %952({ ptr, ptr, ptr, i32 } %903, { ptr, ptr, ptr, i32 } %903, ptr nonnull %50, i32 %.reg2mem89.0393.i1763)
  %.fca.0.extract42.i1765 = extractvalue { ptr, i160 } %953, 0
  %954 = icmp ne ptr %.fca.0.extract42.i1765, @nil_typ
  %955 = icmp ne ptr %.fca.0.extract42.i1765, null
  %.not62.i1766 = and i1 %954, %955
  br i1 %.not62.i1766, label %956, label %970

956:                                              ; preds = %948
  %hash_coef_ptr.i.i152.i1768 = getelementptr i8, ptr %.fca.0.extract42.i1765, i64 8
  %tbl_size_ptr.i.i153.i1769 = getelementptr i8, ptr %.fca.0.extract42.i1765, i64 16
  %offset_tbl_ptr.i.i154.i1770 = getelementptr i8, ptr %.fca.0.extract42.i1765, i64 40
  %hash_coef.i.i155.i1771 = load i64, ptr %hash_coef_ptr.i.i152.i1768, align 4
  %tbl_size.i.i156.i1772 = load i64, ptr %tbl_size_ptr.i.i153.i1769, align 4
  %offset_tbl.i.i157.i1773 = load ptr, ptr %offset_tbl_ptr.i.i154.i1770, align 8
  %product.i.i.i158.i1774 = mul i64 %hash_coef.i.i155.i1771, 4015701072841558310
  %shifted.i.i.i159.i1775 = lshr i64 %product.i.i.i158.i1774, 32
  %xored.i.i.i160.i1776 = xor i64 %shifted.i.i.i159.i1775, %product.i.i.i158.i1774
  %hash.i.i.i161.i1777 = and i64 %xored.i.i.i160.i1776, %tbl_size.i.i156.i1772
  %offset_ptr.i.i162.i1778 = getelementptr i32, ptr %offset_tbl.i.i157.i1773, i64 %hash.i.i.i161.i1777
  %offset.i.i163.i1779 = load i32, ptr %offset_ptr.i.i162.i1778, align 4
  %957 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %958 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %959 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %960 = icmp slt i32 %.reg2mem91.0394.i1762, %913
  br i1 %960, label %961, label %._crit_edge1.i1780

961:                                              ; preds = %956
  %.fca.1.extract44.i1781 = extractvalue { ptr, i160 } %953, 1
  %.sroa.3.0.insert.ext.i1782 = zext i32 %offset.i.i163.i1779 to i160
  %.sroa.3.0.insert.shift.i1783 = shl nuw i160 %.sroa.3.0.insert.ext.i1782, 128
  %962 = and i160 %.fca.1.extract44.i1781, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1784 = or disjoint i160 %.sroa.3.0.insert.shift.i1783, %962
  %963 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %964 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %965 = sext i32 %.reg2mem91.0394.i1762 to i64
  %966 = shl nsw i64 %965, 5
  %967 = getelementptr i8, ptr %result.i.i.i1720, i64 %966
  store ptr %.fca.0.extract42.i1765, ptr %967, align 8
  %968 = getelementptr i8, ptr %967, i64 8
  store i160 %.sroa.040.0.insert.insert.i1784, ptr %968, align 4
  br label %._crit_edge1.i1780

._crit_edge1.i1780:                               ; preds = %961, %956
  %969 = add i32 %.reg2mem91.0394.i1762, 1
  br label %970

970:                                              ; preds = %._crit_edge1.i1780, %948
  %.reg2mem87.0.i1767 = phi i32 [ %969, %._crit_edge1.i1780 ], [ %.reg2mem91.0394.i1762, %948 ]
  %971 = add nuw nsw i32 %.reg2mem89.0393.i1763, 1
  %972 = icmp slt i32 %971, %911
  br i1 %972, label %948, label %._crit_edge395.i1722.loopexit

._crit_edge395.i1722.loopexit:                    ; preds = %970
  %.pre2951 = load ptr, ptr %result.i, align 8
  %.pre2952 = load ptr, ptr %139, align 8
  br label %._crit_edge395.i1722

._crit_edge395.i1722:                             ; preds = %._crit_edge395.i1722.loopexit, %886
  %973 = phi ptr [ %915, %886 ], [ %.pre2952, %._crit_edge395.i1722.loopexit ]
  %974 = phi ptr [ %914, %886 ], [ %.pre2951, %._crit_edge395.i1722.loopexit ]
  %.reg2mem91.0.lcssa.i1723 = phi i32 [ 0, %886 ], [ %.reg2mem87.0.i1767, %._crit_edge395.i1722.loopexit ]
  %975 = call i32 @llvm.smax.i32(i32 %912, i32 16)
  %result.i166.i1724 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %976 = getelementptr i8, ptr %result.i166.i1724, i64 16
  store ptr @_parameterization_Nil, ptr %976, align 8
  %result.i167.i1725 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %977 = getelementptr i8, ptr %result.i167.i1725, i64 16
  store ptr %973, ptr %977, align 8
  %978 = getelementptr i8, ptr %result.i167.i1725, i64 8
  store ptr %974, ptr %978, align 8
  %979 = getelementptr i8, ptr %result.i167.i1725, i64 24
  store ptr null, ptr %979, align 8
  %980 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1725)
  store ptr @Entry, ptr %result.i167.i1725, align 8
  %981 = getelementptr i8, ptr %result.i166.i1724, i64 8
  store ptr %result.i167.i1725, ptr %981, align 8
  %982 = getelementptr i8, ptr %result.i166.i1724, i64 24
  store ptr null, ptr %982, align 8
  %983 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1724)
  store ptr @union_typ, ptr %result.i166.i1724, align 8
  %result.i168.i1726 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1724, ptr %result.i168.i1726, align 8
  %984 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1726)
  store ptr @Array, ptr %52, align 8
  store ptr %result.i168.i1726, ptr %285, align 8
  store i32 9, ptr %286, align 8
  %985 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %52)
  %986 = getelementptr i8, ptr %result.i168.i1726, i64 16
  store i32 %975, ptr %986, align 4
  %987 = getelementptr i8, ptr %result.i168.i1726, i64 20
  store i32 %975, ptr %987, align 4
  %988 = zext nneg i32 %975 to i64
  %989 = shl nuw nsw i64 %988, 5
  %result.i.i416.i1727 = call noalias ptr @bump_malloc_inner(i64 noundef %989, ptr nonnull @current_ptr) #29
  %990 = getelementptr i8, ptr %result.i168.i1726, i64 8
  store ptr %result.i.i416.i1727, ptr %990, align 8
  %991 = load ptr, ptr %287, align 8
  store ptr @Array, ptr %156, align 8
  store ptr %result.i168.i1726, ptr %157, align 8
  store ptr %991, ptr %250, align 8
  store i32 9, ptr %158, align 4
  %992 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i1728 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %993 = getelementptr i8, ptr %result.i183.i1728, i64 16
  store ptr @_parameterization_Nil, ptr %993, align 8
  %result.i184.i1729 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %994 = getelementptr i8, ptr %result.i184.i1729, i64 16
  store ptr %973, ptr %994, align 8
  %995 = getelementptr i8, ptr %result.i184.i1729, i64 8
  store ptr %974, ptr %995, align 8
  %996 = getelementptr i8, ptr %result.i184.i1729, i64 24
  store ptr null, ptr %996, align 8
  %997 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1729)
  store ptr @Entry, ptr %result.i184.i1729, align 8
  %998 = getelementptr i8, ptr %result.i183.i1728, i64 8
  store ptr %result.i184.i1729, ptr %998, align 8
  %999 = getelementptr i8, ptr %result.i183.i1728, i64 24
  store ptr null, ptr %999, align 8
  %1000 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1728)
  store ptr @union_typ, ptr %result.i183.i1728, align 8
  %result.i185.i1730 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1728, ptr %result.i185.i1730, align 8
  %1001 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1730)
  store ptr @Array, ptr %53, align 8
  store ptr %result.i185.i1730, ptr %288, align 8
  store i32 9, ptr %289, align 8
  %1002 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %53)
  %1003 = getelementptr i8, ptr %result.i185.i1730, i64 16
  store i32 %975, ptr %1003, align 4
  %1004 = getelementptr i8, ptr %result.i185.i1730, i64 20
  store i32 %975, ptr %1004, align 4
  %result.i.i430.i1731 = call noalias ptr @bump_malloc_inner(i64 noundef %989, ptr nonnull @current_ptr) #29
  %1005 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1006 = getelementptr i8, ptr %result.i185.i1730, i64 8
  store ptr %result.i.i430.i1731, ptr %1006, align 8
  %1007 = load ptr, ptr %290, align 8
  store ptr @Array, ptr %169, align 8
  store ptr %result.i185.i1730, ptr %170, align 8
  store ptr %1007, ptr %251, align 8
  store i32 9, ptr %171, align 4
  store i32 0, ptr %252, align 4
  %1008 = icmp sgt i32 %.reg2mem91.0.lcssa.i1723, 0
  br i1 %1008, label %.lr.ph400.i1732, label %HashMap_resize_.exit1804

.lr.ph400.i1732:                                  ; preds = %._crit_edge395.i1722
  %1009 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1010 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1011 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1733

._crit_edge2.i1733:                               ; preds = %._crit_edge2.i1733, %.lr.ph400.i1732
  %.reg2mem77.0398.i1734 = phi i32 [ 0, %.lr.ph400.i1732 ], [ %1025, %._crit_edge2.i1733 ]
  %1012 = zext nneg i32 %.reg2mem77.0398.i1734 to i64
  %1013 = shl nuw nsw i64 %1012, 5
  %1014 = getelementptr i8, ptr %result.i.i.i1720, i64 %1013
  %1015 = load ptr, ptr %1014, align 8
  %1016 = getelementptr i8, ptr %1014, i64 8
  %1017 = load i160, ptr %1016, align 4
  %.sroa.3362.8.extract.trunc.i1737 = trunc i160 %1017 to i64
  %1018 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1737 to ptr
  %.sroa.5363.8.extract.shift.i1738 = lshr i160 %1017, 64
  %.sroa.5363.8.extract.trunc.i1739 = trunc i160 %.sroa.5363.8.extract.shift.i1738 to i64
  %1019 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1739 to ptr
  %hash_coef_ptr.i.i201.i1740 = getelementptr i8, ptr %1015, i64 8
  %tbl_size_ptr.i.i202.i1741 = getelementptr i8, ptr %1015, i64 16
  %offset_tbl_ptr.i.i203.i1742 = getelementptr i8, ptr %1015, i64 40
  %hash_coef.i.i232.i1743 = load i64, ptr %hash_coef_ptr.i.i201.i1740, align 4
  %tbl_size.i.i233.i1744 = load i64, ptr %tbl_size_ptr.i.i202.i1741, align 4
  %offset_tbl.i.i234.i1745 = load ptr, ptr %offset_tbl_ptr.i.i203.i1742, align 8
  %product.i.i.i235.i1746 = mul i64 %hash_coef.i.i232.i1743, 4015701072841558310
  %shifted.i.i.i236.i1747 = lshr i64 %product.i.i.i235.i1746, 32
  %xored.i.i.i237.i1748 = xor i64 %shifted.i.i.i236.i1747, %product.i.i.i235.i1746
  %hash.i.i.i238.i1749 = and i64 %xored.i.i.i237.i1748, %tbl_size.i.i233.i1744
  %offset_ptr.i.i239.i1750 = getelementptr i32, ptr %offset_tbl.i.i234.i1745, i64 %hash.i.i.i238.i1749
  %offset.i.i240.i1751 = load i32, ptr %offset_ptr.i.i239.i1750, align 4
  %1020 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1015, 0
  %1021 = insertvalue { ptr, ptr, ptr, i32 } %1020, ptr %1018, 1
  %1022 = insertvalue { ptr, ptr, ptr, i32 } %1021, ptr %1019, 2
  %1023 = insertvalue { ptr, ptr, ptr, i32 } %1022, i32 %offset.i.i240.i1751, 3
  %1024 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %293, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1023)
  %1025 = add nuw nsw i32 %.reg2mem77.0398.i1734, 1
  %1026 = icmp slt i32 %1025, %.reg2mem91.0.lcssa.i1723
  br i1 %1026, label %._crit_edge2.i1733, label %HashMap_resize_.exit1804

HashMap_resize_.exit1804:                         ; preds = %._crit_edge2.i1733, %._crit_edge395.i1722
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %53)
  br label %._crit_edge.i610

._crit_edge.i610:                                 ; preds = %HashMap_resize_.exit1804, %.critedge158.i591
  %1027 = load ptr, ptr %result.i, align 8
  %1028 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1029 = load ptr, ptr %139, align 8
  %1030 = load ptr, ptr %1027, align 8
  %1031 = getelementptr i8, ptr %1030, i64 48
  %1032 = load ptr, ptr %1031, align 8
  %1033 = call { i64, i64 } %1032(ptr nonnull %1027)
  %1034 = extractvalue { i64, i64 } %1033, 0
  %1035 = extractvalue { i64, i64 } %1033, 1
  %1036 = urem i64 20, %1035
  %1037 = icmp eq i64 %1036, 0
  %1038 = sub i64 %1035, %1036
  %1039 = select i1 %1037, i64 0, i64 %1038
  %1040 = add i64 %1034, 20
  %1041 = add i64 %1040, %1039
  %1042 = load ptr, ptr %1029, align 8
  %1043 = getelementptr i8, ptr %1042, i64 48
  %1044 = load ptr, ptr %1043, align 8
  %1045 = call { i64, i64 } %1044(ptr nonnull %1029)
  %1046 = extractvalue { i64, i64 } %1045, 0
  %1047 = extractvalue { i64, i64 } %1045, 1
  %1048 = call i64 @llvm.umax.i64(i64 %1035, i64 %1047)
  %1049 = call i64 @llvm.umax.i64(i64 %1048, i64 8)
  %1050 = urem i64 %1041, %1047
  %1051 = icmp eq i64 %1050, 0
  %1052 = sub i64 %1047, %1050
  %1053 = select i1 %1051, i64 0, i64 %1052
  %1054 = add i64 %1046, %1041
  %1055 = add i64 %1054, %1053
  %1056 = urem i64 %1055, %1049
  %1057 = icmp eq i64 %1056, 0
  %1058 = sub i64 %1049, %1056
  %1059 = select i1 %1057, i64 0, i64 %1058
  %1060 = add i64 %1059, %1055
  %result.i298.i611 = call noalias ptr @bump_malloc_inner(i64 noundef %1060, ptr nonnull @current_ptr) #29
  store ptr %1027, ptr %result.i298.i611, align 8
  %1061 = getelementptr i8, ptr %result.i298.i611, i64 8
  store ptr %1029, ptr %1061, align 8
  %1062 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i611)
  store ptr @Entry, ptr %117, align 8
  store ptr %result.i298.i611, ptr %237, align 8
  store i32 9, ptr %238, align 8
  %1063 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %117)
  %1064 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1065 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1066 = load ptr, ptr %1027, align 8
  %1067 = getelementptr i8, ptr %1066, i64 48
  %1068 = load ptr, ptr %1067, align 8
  %1069 = call { i64, i64 } %1068(ptr nonnull %1027)
  %1070 = extractvalue { i64, i64 } %1069, 1
  %1071 = urem i64 20, %1070
  %1072 = icmp eq i64 %1071, 0
  %reass.sub3304 = sub i64 %1070, %1071
  %1073 = add i64 %reass.sub3304, 20
  %1074 = select i1 %1072, i64 20, i64 %1073
  %1075 = getelementptr i8, ptr %result.i298.i611, i64 %1074
  %1076 = load ptr, ptr %result.i298.i611, align 8
  %1077 = load ptr, ptr %1076, align 8
  %1078 = getelementptr i8, ptr %1077, i64 64
  %1079 = load ptr, ptr %1078, align 8
  call void %1079({ ptr, i160 } %323, ptr nonnull %1076, ptr %1075)
  %1080 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1081 = load ptr, ptr %result.i298.i611, align 8
  %1082 = load ptr, ptr %1081, align 8
  %1083 = getelementptr i8, ptr %1082, i64 48
  %1084 = load ptr, ptr %1083, align 8
  %1085 = call { i64, i64 } %1084(ptr nonnull %1081)
  %1086 = extractvalue { i64, i64 } %1085, 0
  %1087 = extractvalue { i64, i64 } %1085, 1
  %1088 = urem i64 20, %1087
  %1089 = icmp eq i64 %1088, 0
  %1090 = sub i64 %1087, %1088
  %1091 = select i1 %1089, i64 0, i64 %1090
  %1092 = add i64 %1086, 20
  %1093 = add i64 %1092, %1091
  %1094 = load ptr, ptr %1061, align 8
  %1095 = load ptr, ptr %1094, align 8
  %1096 = getelementptr i8, ptr %1095, i64 48
  %1097 = load ptr, ptr %1096, align 8
  %1098 = call { i64, i64 } %1097(ptr nonnull %1094)
  %1099 = extractvalue { i64, i64 } %1098, 1
  %1100 = urem i64 %1093, %1099
  %1101 = icmp eq i64 %1100, 0
  %1102 = sub i64 %1099, %1100
  %1103 = select i1 %1101, i64 0, i64 %1102
  %1104 = getelementptr i8, ptr %result.i298.i611, i64 %1093
  %1105 = getelementptr i8, ptr %1104, i64 %1103
  %1106 = load ptr, ptr %1061, align 8
  %1107 = load ptr, ptr %1106, align 8
  %1108 = getelementptr i8, ptr %1107, i64 64
  %1109 = load ptr, ptr %1108, align 8
  call void %1109({ ptr, i160 } %490, ptr nonnull %1106, ptr %1105)
  %1110 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1111 = getelementptr i8, ptr %result.i298.i611, i64 16
  store i32 %493, ptr %1111, align 4
  %1112 = load ptr, ptr %239, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i1805)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1806)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %47)
  store ptr @Entry, ptr %47, align 8
  store ptr %result.i298.i611, ptr %294, align 8
  store ptr %1112, ptr %295, align 8
  store i32 9, ptr %296, align 8
  %1113 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %47)
  %1114 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1115 = load i32, ptr %172, align 4
  %1116 = icmp sgt i32 %1115, 0
  br i1 %1116, label %.lr.ph.i1836, label %._crit_edge1.i616

.lr.ph.i1836:                                     ; preds = %._crit_edge.i610
  %1117 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1118 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1119

1119:                                             ; preds = %.cont.cont.i1887, %.lr.ph.i1836
  %offset.i.i260.i19022575 = phi i32 [ 9, %.lr.ph.i1836 ], [ %offset.i.i260.i1902, %.cont.cont.i1887 ]
  %.sroa.speculated346.i18902573 = phi ptr [ %1112, %.lr.ph.i1836 ], [ %.sroa.speculated346.i1890, %.cont.cont.i1887 ]
  %.sroa.speculated352.i18892571 = phi ptr [ %result.i298.i611, %.lr.ph.i1836 ], [ %.sroa.speculated352.i1889, %.cont.cont.i1887 ]
  %.reg2mem195.0678.i1837 = phi i32 [ 1, %.lr.ph.i1836 ], [ %1275, %.cont.cont.i1887 ]
  %.reg2mem193.0677.i1838 = phi i32 [ 0, %.lr.ph.i1836 ], [ %1276, %.cont.cont.i1887 ]
  %1120 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i18892571, 1
  %1121 = insertvalue { ptr, ptr, ptr, i32 } %1120, ptr %.sroa.speculated346.i18902573, 2
  %1122 = insertvalue { ptr, ptr, ptr, i32 } %1121, i32 %offset.i.i260.i19022575, 3
  %1123 = sext i32 %offset.i.i260.i19022575 to i64
  %gep2570 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1123
  %1124 = load ptr, ptr %gep2570, align 8
  %1125 = call ptr %1124({ ptr, ptr, ptr, i32 } %1122, ptr nonnull %2)
  %1126 = call i32 %1125({ ptr, ptr, ptr, i32 } %1122, { ptr, ptr, ptr, i32 } %1122, ptr nonnull %2)
  %1127 = icmp eq i32 %.reg2mem195.0678.i1837, 1
  %1128 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1127, label %1129, label %1193

1129:                                             ; preds = %1119
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1130 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1131 = load ptr, ptr %156, align 8
  %1132 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1131, 0
  %1133 = load ptr, ptr %157, align 8
  %1134 = insertvalue { ptr, ptr, ptr, i32 } %1132, ptr %1133, 1
  %1135 = load ptr, ptr %250, align 8
  %1136 = insertvalue { ptr, ptr, ptr, i32 } %1134, ptr %1135, 2
  %1137 = load i32, ptr %158, align 4
  %1138 = insertvalue { ptr, ptr, ptr, i32 } %1136, i32 %1137, 3
  %hash_coef_ptr.i.i10.i3031 = getelementptr i8, ptr %1131, i64 8
  %tbl_size_ptr.i.i11.i3032 = getelementptr i8, ptr %1131, i64 16
  %offset_tbl_ptr.i.i12.i3033 = getelementptr i8, ptr %1131, i64 40
  %hash_coef.i.i13.i3034 = load i64, ptr %hash_coef_ptr.i.i10.i3031, align 4
  %tbl_size.i.i14.i3035 = load i64, ptr %tbl_size_ptr.i.i11.i3032, align 4
  %offset_tbl.i.i15.i3036 = load ptr, ptr %offset_tbl_ptr.i.i12.i3033, align 8
  %product.i.i.i16.i3037 = mul i64 %hash_coef.i.i13.i3034, -5261542750394134544
  %shifted.i.i.i17.i3038 = lshr i64 %product.i.i.i16.i3037, 32
  %xored.i.i.i18.i3039 = xor i64 %shifted.i.i.i17.i3038, %product.i.i.i16.i3037
  %hash.i.i.i19.i3040 = and i64 %xored.i.i.i18.i3039, %tbl_size.i.i14.i3035
  %offset_ptr.i.i20.i3041 = getelementptr i32, ptr %offset_tbl.i.i15.i3036, i64 %hash.i.i.i19.i3040
  %offset.i.i21.i3042 = load i32, ptr %offset_ptr.i.i20.i3041, align 4
  %eq.i.i3043 = icmp eq i32 %1137, %offset.i.i21.i3042
  call void @llvm.assume(i1 %eq.i.i3043) #30
  %1139 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1140 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1131)
  %1141 = sext i32 %1137 to i64
  %1142 = getelementptr ptr, ptr %1131, i64 %1141
  %1143 = getelementptr i8, ptr %1142, i64 64
  %1144 = load ptr, ptr %1143, align 8
  %1145 = call ptr %1144({ ptr, ptr, ptr, i32 } %1138, ptr nonnull %2)
  %1146 = call i32 %1145({ ptr, ptr, ptr, i32 } %1138, { ptr, ptr, ptr, i32 } %1138, ptr nonnull %2)
  %1147 = add i32 %1146, -1
  %1148 = and i32 %1147, %1126
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1149 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1150 = load ptr, ptr %156, align 8
  %1151 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1150, 0
  %1152 = load ptr, ptr %157, align 8
  %1153 = insertvalue { ptr, ptr, ptr, i32 } %1151, ptr %1152, 1
  %1154 = load ptr, ptr %250, align 8
  %1155 = insertvalue { ptr, ptr, ptr, i32 } %1153, ptr %1154, 2
  %1156 = load i32, ptr %158, align 4
  %1157 = insertvalue { ptr, ptr, ptr, i32 } %1155, i32 %1156, 3
  %hash_coef_ptr.i.i172.i1907 = getelementptr i8, ptr %1150, i64 8
  %tbl_size_ptr.i.i173.i1908 = getelementptr i8, ptr %1150, i64 16
  %offset_tbl_ptr.i.i174.i1909 = getelementptr i8, ptr %1150, i64 40
  %hash_coef.i.i175.i1910 = load i64, ptr %hash_coef_ptr.i.i172.i1907, align 4
  %tbl_size.i.i176.i1911 = load i64, ptr %tbl_size_ptr.i.i173.i1908, align 4
  %offset_tbl.i.i177.i1912 = load ptr, ptr %offset_tbl_ptr.i.i174.i1909, align 8
  %product.i.i.i178.i1913 = mul i64 %hash_coef.i.i175.i1910, -5261542750394134544
  %shifted.i.i.i179.i1914 = lshr i64 %product.i.i.i178.i1913, 32
  %xored.i.i.i180.i1915 = xor i64 %shifted.i.i.i179.i1914, %product.i.i.i178.i1913
  %hash.i.i.i181.i1916 = and i64 %xored.i.i.i180.i1915, %tbl_size.i.i176.i1911
  %offset_ptr.i.i182.i1917 = getelementptr i32, ptr %offset_tbl.i.i177.i1912, i64 %hash.i.i.i181.i1916
  %offset.i.i183.i1918 = load i32, ptr %offset_ptr.i.i182.i1917, align 4
  %eq.i.i1919 = icmp eq i32 %1156, %offset.i.i183.i1918
  call void @llvm.assume(i1 %eq.i.i1919) #30
  store ptr @_parameterization_Ptri32, ptr %31, align 8
  %1158 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %31)
  %1159 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1150)
  %1160 = sext i32 %1156 to i64
  %1161 = getelementptr ptr, ptr %1150, i64 %1160
  %1162 = getelementptr i8, ptr %1161, i64 120
  %1163 = load ptr, ptr %1162, align 8
  store ptr @i32_typ, ptr %32, align 8
  %1164 = call ptr %1163({ ptr, ptr, ptr, i32 } %1157, ptr nonnull %32)
  %1165 = call { ptr, i160 } %1164({ ptr, ptr, ptr, i32 } %1157, { ptr, ptr, ptr, i32 } %1157, ptr nonnull %31, i32 %1148)
  %.fca.0.extract112.i1920 = extractvalue { ptr, i160 } %1165, 0
  %1166 = ptrtoint ptr %.sroa.speculated352.i18892571 to i64
  %1167 = ptrtoint ptr %.sroa.speculated346.i18902573 to i64
  %.sroa.3111.0.insert.ext.i1921 = zext i32 %offset.i.i260.i19022575 to i160
  %.sroa.3111.0.insert.shift.i1922 = shl nuw i160 %.sroa.3111.0.insert.ext.i1921, 128
  %.sroa.2110.0.insert.ext.i1923 = zext i64 %1167 to i160
  %.sroa.2110.0.insert.shift.i1924 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i1923, 64
  %.sroa.2110.0.insert.insert.i1925 = or disjoint i160 %.sroa.2110.0.insert.shift.i1924, %.sroa.3111.0.insert.shift.i1922
  %.sroa.0109.0.insert.ext.i1926 = zext i64 %1166 to i160
  %.sroa.0109.0.insert.insert.i1927 = or disjoint i160 %.sroa.2110.0.insert.insert.i1925, %.sroa.0109.0.insert.ext.i1926
  %1168 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i1927, 1
  %1169 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1170 = load ptr, ptr %156, align 8
  %1171 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1170, 0
  %1172 = load ptr, ptr %157, align 8
  %1173 = insertvalue { ptr, ptr, ptr, i32 } %1171, ptr %1172, 1
  %1174 = load ptr, ptr %250, align 8
  %1175 = insertvalue { ptr, ptr, ptr, i32 } %1173, ptr %1174, 2
  %1176 = load i32, ptr %158, align 4
  %1177 = insertvalue { ptr, ptr, ptr, i32 } %1175, i32 %1176, 3
  %hash_coef_ptr.i.i186.i1932 = getelementptr i8, ptr %1170, i64 8
  %tbl_size_ptr.i.i187.i1933 = getelementptr i8, ptr %1170, i64 16
  %offset_tbl_ptr.i.i188.i1934 = getelementptr i8, ptr %1170, i64 40
  %hash_coef.i.i189.i1935 = load i64, ptr %hash_coef_ptr.i.i186.i1932, align 4
  %tbl_size.i.i190.i1936 = load i64, ptr %tbl_size_ptr.i.i187.i1933, align 4
  %offset_tbl.i.i191.i1937 = load ptr, ptr %offset_tbl_ptr.i.i188.i1934, align 8
  %product.i.i.i192.i1938 = mul i64 %hash_coef.i.i189.i1935, -5261542750394134544
  %shifted.i.i.i193.i1939 = lshr i64 %product.i.i.i192.i1938, 32
  %xored.i.i.i194.i1940 = xor i64 %shifted.i.i.i193.i1939, %product.i.i.i192.i1938
  %hash.i.i.i195.i1941 = and i64 %xored.i.i.i194.i1940, %tbl_size.i.i190.i1936
  %offset_ptr.i.i196.i1942 = getelementptr i32, ptr %offset_tbl.i.i191.i1937, i64 %hash.i.i.i195.i1941
  %offset.i.i197.i1943 = load i32, ptr %offset_ptr.i.i196.i1942, align 4
  %eq.i200.i1944 = icmp eq i32 %1176, %offset.i.i197.i1943
  call void @llvm.assume(i1 %eq.i200.i1944) #30
  %1178 = load ptr, ptr %result.i, align 8
  %1179 = load ptr, ptr %139, align 8
  %result.i.i1945 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1180 = getelementptr i8, ptr %result.i.i1945, i64 16
  store ptr %1179, ptr %1180, align 8
  %1181 = getelementptr i8, ptr %result.i.i1945, i64 8
  store ptr %1178, ptr %1181, align 8
  %1182 = getelementptr i8, ptr %result.i.i1945, i64 24
  store ptr null, ptr %1182, align 8
  %1183 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1945)
  store ptr @Entry, ptr %result.i.i1945, align 8
  store ptr @_parameterization_Ptri32, ptr %33, align 8
  store ptr %result.i.i1945, ptr %299, align 8
  %1184 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %33)
  %1185 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1170)
  %1186 = sext i32 %1176 to i64
  %1187 = getelementptr ptr, ptr %1170, i64 %1186
  %1188 = getelementptr i8, ptr %1187, i64 128
  %1189 = load ptr, ptr %1188, align 8
  store ptr @i32_typ, ptr %34, align 8
  store ptr @Entry, ptr %300, align 8
  %1190 = call ptr %1189({ ptr, ptr, ptr, i32 } %1177, ptr nonnull %34)
  call void %1190({ ptr, ptr, ptr, i32 } %1177, { ptr, ptr, ptr, i32 } %1177, ptr nonnull %33, i32 %1148, { ptr, i160 } %1168)
  %1191 = icmp ne ptr %.fca.0.extract112.i1920, @nil_typ
  %1192 = icmp ne ptr %.fca.0.extract112.i1920, null
  %.not140.i1946 = and i1 %1191, %1192
  br i1 %.not140.i1946, label %.cont.cont.i1887, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2553

1193:                                             ; preds = %1119
  %1194 = add i32 %1126, 2127912214
  %1195 = shl i32 %1126, 12
  %1196 = add i32 %1194, %1195
  %1197 = ashr i32 %1196, 19
  %1198 = xor i32 %1196, %1197
  %1199 = xor i32 %1198, -949894596
  %1200 = add i32 %1199, 374761393
  %1201 = shl i32 %1199, 5
  %1202 = add i32 %1200, %1201
  %1203 = add i32 %1202, -744332180
  %1204 = shl i32 %1202, 9
  %1205 = xor i32 %1203, %1204
  %1206 = add i32 %1205, -42973499
  %1207 = shl i32 %1205, 3
  %1208 = add i32 %1206, %1207
  %1209 = ashr i32 %1208, 16
  %1210 = xor i32 %1208, %1209
  %1211 = xor i32 %1210, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1212 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1213 = load ptr, ptr %169, align 8
  %1214 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1213, 0
  %1215 = load ptr, ptr %170, align 8
  %1216 = insertvalue { ptr, ptr, ptr, i32 } %1214, ptr %1215, 1
  %1217 = load ptr, ptr %251, align 8
  %1218 = insertvalue { ptr, ptr, ptr, i32 } %1216, ptr %1217, 2
  %1219 = load i32, ptr %171, align 4
  %1220 = insertvalue { ptr, ptr, ptr, i32 } %1218, i32 %1219, 3
  %hash_coef_ptr.i.i10.i3061 = getelementptr i8, ptr %1213, i64 8
  %tbl_size_ptr.i.i11.i3062 = getelementptr i8, ptr %1213, i64 16
  %offset_tbl_ptr.i.i12.i3063 = getelementptr i8, ptr %1213, i64 40
  %hash_coef.i.i13.i3064 = load i64, ptr %hash_coef_ptr.i.i10.i3061, align 4
  %tbl_size.i.i14.i3065 = load i64, ptr %tbl_size_ptr.i.i11.i3062, align 4
  %offset_tbl.i.i15.i3066 = load ptr, ptr %offset_tbl_ptr.i.i12.i3063, align 8
  %product.i.i.i16.i3067 = mul i64 %hash_coef.i.i13.i3064, -5261542750394134544
  %shifted.i.i.i17.i3068 = lshr i64 %product.i.i.i16.i3067, 32
  %xored.i.i.i18.i3069 = xor i64 %shifted.i.i.i17.i3068, %product.i.i.i16.i3067
  %hash.i.i.i19.i3070 = and i64 %xored.i.i.i18.i3069, %tbl_size.i.i14.i3065
  %offset_ptr.i.i20.i3071 = getelementptr i32, ptr %offset_tbl.i.i15.i3066, i64 %hash.i.i.i19.i3070
  %offset.i.i21.i3072 = load i32, ptr %offset_ptr.i.i20.i3071, align 4
  %eq.i.i3073 = icmp eq i32 %1219, %offset.i.i21.i3072
  call void @llvm.assume(i1 %eq.i.i3073) #30
  %1221 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1222 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1213)
  %1223 = sext i32 %1219 to i64
  %1224 = getelementptr ptr, ptr %1213, i64 %1223
  %1225 = getelementptr i8, ptr %1224, i64 64
  %1226 = load ptr, ptr %1225, align 8
  %1227 = call ptr %1226({ ptr, ptr, ptr, i32 } %1220, ptr nonnull %2)
  %1228 = call i32 %1227({ ptr, ptr, ptr, i32 } %1220, { ptr, ptr, ptr, i32 } %1220, ptr nonnull %2)
  %1229 = add i32 %1228, -1
  %1230 = and i32 %1229, %1211
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1231 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1232 = load ptr, ptr %169, align 8
  %1233 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1232, 0
  %1234 = load ptr, ptr %170, align 8
  %1235 = insertvalue { ptr, ptr, ptr, i32 } %1233, ptr %1234, 1
  %1236 = load ptr, ptr %251, align 8
  %1237 = insertvalue { ptr, ptr, ptr, i32 } %1235, ptr %1236, 2
  %1238 = load i32, ptr %171, align 4
  %1239 = insertvalue { ptr, ptr, ptr, i32 } %1237, i32 %1238, 3
  %hash_coef_ptr.i.i202.i1843 = getelementptr i8, ptr %1232, i64 8
  %tbl_size_ptr.i.i203.i1844 = getelementptr i8, ptr %1232, i64 16
  %offset_tbl_ptr.i.i204.i1845 = getelementptr i8, ptr %1232, i64 40
  %hash_coef.i.i205.i1846 = load i64, ptr %hash_coef_ptr.i.i202.i1843, align 4
  %tbl_size.i.i206.i1847 = load i64, ptr %tbl_size_ptr.i.i203.i1844, align 4
  %offset_tbl.i.i207.i1848 = load ptr, ptr %offset_tbl_ptr.i.i204.i1845, align 8
  %product.i.i.i208.i1849 = mul i64 %hash_coef.i.i205.i1846, -5261542750394134544
  %shifted.i.i.i209.i1850 = lshr i64 %product.i.i.i208.i1849, 32
  %xored.i.i.i210.i1851 = xor i64 %shifted.i.i.i209.i1850, %product.i.i.i208.i1849
  %hash.i.i.i211.i1852 = and i64 %xored.i.i.i210.i1851, %tbl_size.i.i206.i1847
  %offset_ptr.i.i212.i1853 = getelementptr i32, ptr %offset_tbl.i.i207.i1848, i64 %hash.i.i.i211.i1852
  %offset.i.i213.i1854 = load i32, ptr %offset_ptr.i.i212.i1853, align 4
  %eq.i216.i1855 = icmp eq i32 %1238, %offset.i.i213.i1854
  call void @llvm.assume(i1 %eq.i216.i1855) #30
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %1240 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %39)
  %1241 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1232)
  %1242 = sext i32 %1238 to i64
  %1243 = getelementptr ptr, ptr %1232, i64 %1242
  %1244 = getelementptr i8, ptr %1243, i64 120
  %1245 = load ptr, ptr %1244, align 8
  store ptr @i32_typ, ptr %40, align 8
  %1246 = call ptr %1245({ ptr, ptr, ptr, i32 } %1239, ptr nonnull %40)
  %1247 = call { ptr, i160 } %1246({ ptr, ptr, ptr, i32 } %1239, { ptr, ptr, ptr, i32 } %1239, ptr nonnull %39, i32 %1230)
  %.fca.0.extract87.i1856 = extractvalue { ptr, i160 } %1247, 0
  %1248 = ptrtoint ptr %.sroa.speculated352.i18892571 to i64
  %1249 = ptrtoint ptr %.sroa.speculated346.i18902573 to i64
  %.sroa.3.0.insert.ext.i1857 = zext i32 %offset.i.i260.i19022575 to i160
  %.sroa.3.0.insert.shift.i1858 = shl nuw i160 %.sroa.3.0.insert.ext.i1857, 128
  %.sroa.2.0.insert.ext.i1859 = zext i64 %1249 to i160
  %.sroa.2.0.insert.shift.i1860 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i1859, 64
  %.sroa.2.0.insert.insert.i1861 = or disjoint i160 %.sroa.2.0.insert.shift.i1860, %.sroa.3.0.insert.shift.i1858
  %.sroa.0.0.insert.ext.i1862 = zext i64 %1248 to i160
  %.sroa.0.0.insert.insert.i1863 = or disjoint i160 %.sroa.2.0.insert.insert.i1861, %.sroa.0.0.insert.ext.i1862
  %1250 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i1863, 1
  %1251 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1252 = load ptr, ptr %169, align 8
  %1253 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1252, 0
  %1254 = load ptr, ptr %170, align 8
  %1255 = insertvalue { ptr, ptr, ptr, i32 } %1253, ptr %1254, 1
  %1256 = load ptr, ptr %251, align 8
  %1257 = insertvalue { ptr, ptr, ptr, i32 } %1255, ptr %1256, 2
  %1258 = load i32, ptr %171, align 4
  %1259 = insertvalue { ptr, ptr, ptr, i32 } %1257, i32 %1258, 3
  %hash_coef_ptr.i.i218.i1868 = getelementptr i8, ptr %1252, i64 8
  %tbl_size_ptr.i.i219.i1869 = getelementptr i8, ptr %1252, i64 16
  %offset_tbl_ptr.i.i220.i1870 = getelementptr i8, ptr %1252, i64 40
  %hash_coef.i.i221.i1871 = load i64, ptr %hash_coef_ptr.i.i218.i1868, align 4
  %tbl_size.i.i222.i1872 = load i64, ptr %tbl_size_ptr.i.i219.i1869, align 4
  %offset_tbl.i.i223.i1873 = load ptr, ptr %offset_tbl_ptr.i.i220.i1870, align 8
  %product.i.i.i224.i1874 = mul i64 %hash_coef.i.i221.i1871, -5261542750394134544
  %shifted.i.i.i225.i1875 = lshr i64 %product.i.i.i224.i1874, 32
  %xored.i.i.i226.i1876 = xor i64 %shifted.i.i.i225.i1875, %product.i.i.i224.i1874
  %hash.i.i.i227.i1877 = and i64 %xored.i.i.i226.i1876, %tbl_size.i.i222.i1872
  %offset_ptr.i.i228.i1878 = getelementptr i32, ptr %offset_tbl.i.i223.i1873, i64 %hash.i.i.i227.i1877
  %offset.i.i229.i1879 = load i32, ptr %offset_ptr.i.i228.i1878, align 4
  %eq.i232.i1880 = icmp eq i32 %1258, %offset.i.i229.i1879
  call void @llvm.assume(i1 %eq.i232.i1880) #30
  %1260 = load ptr, ptr %result.i, align 8
  %1261 = load ptr, ptr %139, align 8
  %result.i233.i1881 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1262 = getelementptr i8, ptr %result.i233.i1881, i64 16
  store ptr %1261, ptr %1262, align 8
  %1263 = getelementptr i8, ptr %result.i233.i1881, i64 8
  store ptr %1260, ptr %1263, align 8
  %1264 = getelementptr i8, ptr %result.i233.i1881, i64 24
  store ptr null, ptr %1264, align 8
  %1265 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i1881)
  store ptr @Entry, ptr %result.i233.i1881, align 8
  store ptr @_parameterization_Ptri32, ptr %41, align 8
  store ptr %result.i233.i1881, ptr %297, align 8
  %1266 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %41)
  %1267 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1252)
  %1268 = sext i32 %1258 to i64
  %1269 = getelementptr ptr, ptr %1252, i64 %1268
  %1270 = getelementptr i8, ptr %1269, i64 128
  %1271 = load ptr, ptr %1270, align 8
  store ptr @i32_typ, ptr %42, align 8
  store ptr @Entry, ptr %298, align 8
  %1272 = call ptr %1271({ ptr, ptr, ptr, i32 } %1259, ptr nonnull %42)
  call void %1272({ ptr, ptr, ptr, i32 } %1259, { ptr, ptr, ptr, i32 } %1259, ptr nonnull %41, i32 %1230, { ptr, i160 } %1250)
  %1273 = icmp ne ptr %.fca.0.extract87.i1856, @nil_typ
  %1274 = icmp ne ptr %.fca.0.extract87.i1856, null
  %.not138.i1882 = and i1 %1273, %1274
  br i1 %.not138.i1882, label %.cont.cont.i1887, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2553

.cont.cont.i1887:                                 ; preds = %1193, %1129
  %.sink2599 = phi { ptr, i160 } [ %1165, %1129 ], [ %1247, %1193 ]
  %1275 = phi i32 [ 2, %1129 ], [ 1, %1193 ]
  %vptr.i248.sroa.speculated.i1888 = phi ptr [ %.fca.0.extract112.i1920, %1129 ], [ %.fca.0.extract87.i1856, %1193 ]
  %.fca.1.extract89.i1883 = extractvalue { ptr, i160 } %.sink2599, 1
  %.sroa.3407.sroa.4.0.extract.shift.i1884 = lshr i160 %.fca.1.extract89.i1883, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i1885 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i1884 to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i1886 = trunc i160 %.fca.1.extract89.i1883 to i64
  %.sroa.speculated352.i1889 = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i1886 to ptr
  %.sroa.speculated346.i1890 = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i1885 to ptr
  %hash_coef_ptr.i.i249.i1891 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1888, i64 8
  %tbl_size_ptr.i.i250.i1892 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1888, i64 16
  %offset_tbl_ptr.i.i251.i1893 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1888, i64 40
  %hash_coef.i.i252.i1894 = load i64, ptr %hash_coef_ptr.i.i249.i1891, align 4
  %tbl_size.i.i253.i1895 = load i64, ptr %tbl_size_ptr.i.i250.i1892, align 4
  %offset_tbl.i.i254.i1896 = load ptr, ptr %offset_tbl_ptr.i.i251.i1893, align 8
  %product.i.i.i255.i1897 = mul i64 %hash_coef.i.i252.i1894, 4015701072841558310
  %shifted.i.i.i256.i1898 = lshr i64 %product.i.i.i255.i1897, 32
  %xored.i.i.i257.i1899 = xor i64 %shifted.i.i.i256.i1898, %product.i.i.i255.i1897
  %hash.i.i.i258.i1900 = and i64 %xored.i.i.i257.i1899, %tbl_size.i.i253.i1895
  %offset_ptr.i.i259.i1901 = getelementptr i32, ptr %offset_tbl.i.i254.i1896, i64 %hash.i.i.i258.i1900
  %offset.i.i260.i1902 = load i32, ptr %offset_ptr.i.i259.i1901, align 4
  store ptr %vptr.i248.sroa.speculated.i1888, ptr %47, align 8
  store ptr %.sroa.speculated352.i1889, ptr %294, align 8
  store ptr %.sroa.speculated346.i1890, ptr %295, align 8
  store i32 %offset.i.i260.i1902, ptr %296, align 8
  %1276 = add nuw nsw i32 %.reg2mem193.0677.i1838, 1
  %1277 = load i32, ptr %172, align 4
  %1278 = icmp slt i32 %1276, %1277
  br i1 %1278, label %1119, label %._crit_edge1.i616

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2553: ; preds = %1129, %1193
  %1279 = phi ptr [ %43, %1193 ], [ %35, %1129 ]
  %1280 = phi ptr [ %44, %1193 ], [ %36, %1129 ]
  %1281 = phi ptr [ %45, %1193 ], [ %37, %1129 ]
  %1282 = phi ptr [ %.sroa.0.i1806, %1193 ], [ %.sroa.0680.i1805, %1129 ]
  %1283 = phi ptr [ %46, %1193 ], [ %38, %1129 ]
  %1284 = load i32, ptr %252, align 4
  store i32 %1284, ptr %1279, align 4
  store i32 1, ptr %1280, align 4
  %1285 = add i32 %1284, 1
  store i32 %1285, ptr %1281, align 4
  %1286 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1285, ptr %252, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1283, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1282, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1805)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1806)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  br label %HashMap_insert_keyK_valueV.exit705

._crit_edge1.i616:                                ; preds = %.cont.cont.i1887, %._crit_edge.i610
  %1287 = load i160, ptr %294, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1805)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1806)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %30)
  %1288 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1289 = load ptr, ptr %156, align 8
  %1290 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1289, 0
  %1291 = load ptr, ptr %157, align 8
  %1292 = insertvalue { ptr, ptr, ptr, i32 } %1290, ptr %1291, 1
  %1293 = load ptr, ptr %250, align 8
  %1294 = insertvalue { ptr, ptr, ptr, i32 } %1292, ptr %1293, 2
  %1295 = load i32, ptr %158, align 4
  %1296 = insertvalue { ptr, ptr, ptr, i32 } %1294, i32 %1295, 3
  %hash_coef_ptr.i.i64.i1966 = getelementptr i8, ptr %1289, i64 8
  %tbl_size_ptr.i.i65.i1967 = getelementptr i8, ptr %1289, i64 16
  %offset_tbl_ptr.i.i66.i1968 = getelementptr i8, ptr %1289, i64 40
  %hash_coef.i.i67.i1969 = load i64, ptr %hash_coef_ptr.i.i64.i1966, align 4
  %tbl_size.i.i68.i1970 = load i64, ptr %tbl_size_ptr.i.i65.i1967, align 4
  %offset_tbl.i.i69.i1971 = load ptr, ptr %offset_tbl_ptr.i.i66.i1968, align 8
  %product.i.i.i70.i1972 = mul i64 %hash_coef.i.i67.i1969, -5261542750394134544
  %shifted.i.i.i71.i1973 = lshr i64 %product.i.i.i70.i1972, 32
  %xored.i.i.i72.i1974 = xor i64 %shifted.i.i.i71.i1973, %product.i.i.i70.i1972
  %hash.i.i.i73.i1975 = and i64 %xored.i.i.i72.i1974, %tbl_size.i.i68.i1970
  %offset_ptr.i.i74.i1976 = getelementptr i32, ptr %offset_tbl.i.i69.i1971, i64 %hash.i.i.i73.i1975
  %offset.i.i75.i1977 = load i32, ptr %offset_ptr.i.i74.i1976, align 4
  %eq.i.i1978 = icmp eq i32 %1295, %offset.i.i75.i1977
  call void @llvm.assume(i1 %eq.i.i1978) #30
  %1297 = load ptr, ptr %169, align 8
  %1298 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1297, 0
  %1299 = load ptr, ptr %170, align 8
  %1300 = insertvalue { ptr, ptr, ptr, i32 } %1298, ptr %1299, 1
  %1301 = load ptr, ptr %251, align 8
  %1302 = insertvalue { ptr, ptr, ptr, i32 } %1300, ptr %1301, 2
  %1303 = load i32, ptr %171, align 4
  %1304 = insertvalue { ptr, ptr, ptr, i32 } %1302, i32 %1303, 3
  %hash_coef_ptr.i.i92.i1983 = getelementptr i8, ptr %1297, i64 8
  %tbl_size_ptr.i.i93.i1984 = getelementptr i8, ptr %1297, i64 16
  %offset_tbl_ptr.i.i94.i1985 = getelementptr i8, ptr %1297, i64 40
  %hash_coef.i.i95.i1986 = load i64, ptr %hash_coef_ptr.i.i92.i1983, align 4
  %tbl_size.i.i96.i1987 = load i64, ptr %tbl_size_ptr.i.i93.i1984, align 4
  %offset_tbl.i.i97.i1988 = load ptr, ptr %offset_tbl_ptr.i.i94.i1985, align 8
  %product.i.i.i98.i1989 = mul i64 %hash_coef.i.i95.i1986, -5261542750394134544
  %shifted.i.i.i99.i1990 = lshr i64 %product.i.i.i98.i1989, 32
  %xored.i.i.i100.i1991 = xor i64 %shifted.i.i.i99.i1990, %product.i.i.i98.i1989
  %hash.i.i.i101.i1992 = and i64 %xored.i.i.i100.i1991, %tbl_size.i.i96.i1987
  %offset_ptr.i.i102.i1993 = getelementptr i32, ptr %offset_tbl.i.i97.i1988, i64 %hash.i.i.i101.i1992
  %offset.i.i103.i1994 = load i32, ptr %offset_ptr.i.i102.i1993, align 4
  %eq.i106.i1995 = icmp eq i32 %1303, %offset.i.i103.i1994
  call void @llvm.assume(i1 %eq.i106.i1995) #30
  %1305 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1306 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1289)
  %1307 = sext i32 %1295 to i64
  %1308 = getelementptr ptr, ptr %1289, i64 %1307
  %1309 = getelementptr i8, ptr %1308, i64 64
  %1310 = load ptr, ptr %1309, align 8
  %1311 = call ptr %1310({ ptr, ptr, ptr, i32 } %1296, ptr nonnull %2)
  %1312 = call i32 %1311({ ptr, ptr, ptr, i32 } %1296, { ptr, ptr, ptr, i32 } %1296, ptr nonnull %2)
  %1313 = shl i32 %1312, 1
  %1314 = load i32, ptr %252, align 4
  %1315 = load ptr, ptr %result.i, align 8
  %1316 = load ptr, ptr %139, align 8
  %1317 = sext i32 %1314 to i64
  %1318 = shl nsw i64 %1317, 5
  %result.i.i.i1998 = call noalias ptr @bump_malloc_inner(i64 noundef %1318, ptr nonnull @current_ptr) #29
  %1319 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1320 = icmp sgt i32 %1312, 0
  br i1 %1320, label %.lr.ph434.i2068, label %._crit_edge395.i2012

.lr.ph434.i2068:                                  ; preds = %._crit_edge1.i616
  %invariant.gep.i2011 = getelementptr i8, ptr %1289, i64 120
  %1321 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i2071 = getelementptr ptr, ptr %invariant.gep.i2011, i64 %1307
  br label %1322

1322:                                             ; preds = %1344, %.lr.ph434.i2068
  %.reg2mem105.0432.i2069 = phi i32 [ 0, %.lr.ph434.i2068 ], [ %.reg2mem101.0.i2074, %1344 ]
  %.reg2mem103.0431.i2070 = phi i32 [ 0, %.lr.ph434.i2068 ], [ %1345, %1344 ]
  store ptr @_parameterization_Ptri32, ptr %25, align 8
  %1323 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %25)
  %1324 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1289)
  %1325 = load ptr, ptr %gep.i2071, align 8
  store ptr @i32_typ, ptr %26, align 8
  %1326 = call ptr %1325({ ptr, ptr, ptr, i32 } %1296, ptr nonnull %26)
  %1327 = call { ptr, i160 } %1326({ ptr, ptr, ptr, i32 } %1296, { ptr, ptr, ptr, i32 } %1296, ptr nonnull %25, i32 %.reg2mem103.0431.i2070)
  %.fca.0.extract52.i2072 = extractvalue { ptr, i160 } %1327, 0
  %1328 = icmp ne ptr %.fca.0.extract52.i2072, @nil_typ
  %1329 = icmp ne ptr %.fca.0.extract52.i2072, null
  %.not60.i2073 = and i1 %1328, %1329
  br i1 %.not60.i2073, label %1330, label %1344

1330:                                             ; preds = %1322
  %hash_coef_ptr.i.i137.i2101 = getelementptr i8, ptr %.fca.0.extract52.i2072, i64 8
  %tbl_size_ptr.i.i138.i2102 = getelementptr i8, ptr %.fca.0.extract52.i2072, i64 16
  %offset_tbl_ptr.i.i139.i2103 = getelementptr i8, ptr %.fca.0.extract52.i2072, i64 40
  %hash_coef.i.i140.i2104 = load i64, ptr %hash_coef_ptr.i.i137.i2101, align 4
  %tbl_size.i.i141.i2105 = load i64, ptr %tbl_size_ptr.i.i138.i2102, align 4
  %offset_tbl.i.i142.i2106 = load ptr, ptr %offset_tbl_ptr.i.i139.i2103, align 8
  %product.i.i.i143.i2107 = mul i64 %hash_coef.i.i140.i2104, 4015701072841558310
  %shifted.i.i.i144.i2108 = lshr i64 %product.i.i.i143.i2107, 32
  %xored.i.i.i145.i2109 = xor i64 %shifted.i.i.i144.i2108, %product.i.i.i143.i2107
  %hash.i.i.i146.i2110 = and i64 %xored.i.i.i145.i2109, %tbl_size.i.i141.i2105
  %offset_ptr.i.i147.i2111 = getelementptr i32, ptr %offset_tbl.i.i142.i2106, i64 %hash.i.i.i146.i2110
  %offset.i.i148.i2112 = load i32, ptr %offset_ptr.i.i147.i2111, align 4
  %1331 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1332 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1333 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1334 = icmp slt i32 %.reg2mem105.0432.i2069, %1314
  br i1 %1334, label %1335, label %._crit_edge.i2113

1335:                                             ; preds = %1330
  %.fca.1.extract54.i2114 = extractvalue { ptr, i160 } %1327, 1
  %.sroa.351.0.insert.ext.i2115 = zext i32 %offset.i.i148.i2112 to i160
  %.sroa.351.0.insert.shift.i2116 = shl nuw i160 %.sroa.351.0.insert.ext.i2115, 128
  %1336 = and i160 %.fca.1.extract54.i2114, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2117 = or disjoint i160 %.sroa.351.0.insert.shift.i2116, %1336
  %1337 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1338 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1339 = sext i32 %.reg2mem105.0432.i2069 to i64
  %1340 = shl nsw i64 %1339, 5
  %1341 = getelementptr i8, ptr %result.i.i.i1998, i64 %1340
  store ptr %.fca.0.extract52.i2072, ptr %1341, align 8
  %1342 = getelementptr i8, ptr %1341, i64 8
  store i160 %.sroa.049.0.insert.insert.i2117, ptr %1342, align 4
  br label %._crit_edge.i2113

._crit_edge.i2113:                                ; preds = %1335, %1330
  %1343 = add i32 %.reg2mem105.0432.i2069, 1
  br label %1344

1344:                                             ; preds = %._crit_edge.i2113, %1322
  %.reg2mem101.0.i2074 = phi i32 [ %1343, %._crit_edge.i2113 ], [ %.reg2mem105.0432.i2069, %1322 ]
  %1345 = add nuw nsw i32 %.reg2mem103.0431.i2070, 1
  %1346 = icmp slt i32 %1345, %1312
  br i1 %1346, label %1322, label %.lr.ph.i2075

.lr.ph.i2075:                                     ; preds = %1344
  %invariant.gep396.i2076 = getelementptr i8, ptr %1297, i64 120
  %1347 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1348 = sext i32 %1303 to i64
  %gep397.i2079 = getelementptr ptr, ptr %invariant.gep396.i2076, i64 %1348
  br label %1349

1349:                                             ; preds = %1371, %.lr.ph.i2075
  %.reg2mem91.0394.i2077 = phi i32 [ %.reg2mem101.0.i2074, %.lr.ph.i2075 ], [ %.reg2mem87.0.i2082, %1371 ]
  %.reg2mem89.0393.i2078 = phi i32 [ 0, %.lr.ph.i2075 ], [ %1372, %1371 ]
  store ptr @_parameterization_Ptri32, ptr %27, align 8
  %1350 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %27)
  %1351 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1297)
  %1352 = load ptr, ptr %gep397.i2079, align 8
  store ptr @i32_typ, ptr %28, align 8
  %1353 = call ptr %1352({ ptr, ptr, ptr, i32 } %1304, ptr nonnull %28)
  %1354 = call { ptr, i160 } %1353({ ptr, ptr, ptr, i32 } %1304, { ptr, ptr, ptr, i32 } %1304, ptr nonnull %27, i32 %.reg2mem89.0393.i2078)
  %.fca.0.extract42.i2080 = extractvalue { ptr, i160 } %1354, 0
  %1355 = icmp ne ptr %.fca.0.extract42.i2080, @nil_typ
  %1356 = icmp ne ptr %.fca.0.extract42.i2080, null
  %.not62.i2081 = and i1 %1355, %1356
  br i1 %.not62.i2081, label %1357, label %1371

1357:                                             ; preds = %1349
  %hash_coef_ptr.i.i152.i2083 = getelementptr i8, ptr %.fca.0.extract42.i2080, i64 8
  %tbl_size_ptr.i.i153.i2084 = getelementptr i8, ptr %.fca.0.extract42.i2080, i64 16
  %offset_tbl_ptr.i.i154.i2085 = getelementptr i8, ptr %.fca.0.extract42.i2080, i64 40
  %hash_coef.i.i155.i2086 = load i64, ptr %hash_coef_ptr.i.i152.i2083, align 4
  %tbl_size.i.i156.i2087 = load i64, ptr %tbl_size_ptr.i.i153.i2084, align 4
  %offset_tbl.i.i157.i2088 = load ptr, ptr %offset_tbl_ptr.i.i154.i2085, align 8
  %product.i.i.i158.i2089 = mul i64 %hash_coef.i.i155.i2086, 4015701072841558310
  %shifted.i.i.i159.i2090 = lshr i64 %product.i.i.i158.i2089, 32
  %xored.i.i.i160.i2091 = xor i64 %shifted.i.i.i159.i2090, %product.i.i.i158.i2089
  %hash.i.i.i161.i2092 = and i64 %xored.i.i.i160.i2091, %tbl_size.i.i156.i2087
  %offset_ptr.i.i162.i2093 = getelementptr i32, ptr %offset_tbl.i.i157.i2088, i64 %hash.i.i.i161.i2092
  %offset.i.i163.i2094 = load i32, ptr %offset_ptr.i.i162.i2093, align 4
  %1358 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1359 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1360 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1361 = icmp slt i32 %.reg2mem91.0394.i2077, %1314
  br i1 %1361, label %1362, label %._crit_edge1.i2095

1362:                                             ; preds = %1357
  %.fca.1.extract44.i2096 = extractvalue { ptr, i160 } %1354, 1
  %.sroa.3.0.insert.ext.i2097 = zext i32 %offset.i.i163.i2094 to i160
  %.sroa.3.0.insert.shift.i2098 = shl nuw i160 %.sroa.3.0.insert.ext.i2097, 128
  %1363 = and i160 %.fca.1.extract44.i2096, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2099 = or disjoint i160 %.sroa.3.0.insert.shift.i2098, %1363
  %1364 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1365 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1366 = sext i32 %.reg2mem91.0394.i2077 to i64
  %1367 = shl nsw i64 %1366, 5
  %1368 = getelementptr i8, ptr %result.i.i.i1998, i64 %1367
  store ptr %.fca.0.extract42.i2080, ptr %1368, align 8
  %1369 = getelementptr i8, ptr %1368, i64 8
  store i160 %.sroa.040.0.insert.insert.i2099, ptr %1369, align 4
  br label %._crit_edge1.i2095

._crit_edge1.i2095:                               ; preds = %1362, %1357
  %1370 = add i32 %.reg2mem91.0394.i2077, 1
  br label %1371

1371:                                             ; preds = %._crit_edge1.i2095, %1349
  %.reg2mem87.0.i2082 = phi i32 [ %1370, %._crit_edge1.i2095 ], [ %.reg2mem91.0394.i2077, %1349 ]
  %1372 = add nuw nsw i32 %.reg2mem89.0393.i2078, 1
  %1373 = icmp slt i32 %1372, %1312
  br i1 %1373, label %1349, label %._crit_edge395.i2012.loopexit

._crit_edge395.i2012.loopexit:                    ; preds = %1371
  %.pre2953 = load ptr, ptr %result.i, align 8
  %.pre2954 = load ptr, ptr %139, align 8
  br label %._crit_edge395.i2012

._crit_edge395.i2012:                             ; preds = %._crit_edge395.i2012.loopexit, %._crit_edge1.i616
  %1374 = phi ptr [ %1316, %._crit_edge1.i616 ], [ %.pre2954, %._crit_edge395.i2012.loopexit ]
  %1375 = phi ptr [ %1315, %._crit_edge1.i616 ], [ %.pre2953, %._crit_edge395.i2012.loopexit ]
  %.reg2mem91.0.lcssa.i2013 = phi i32 [ 0, %._crit_edge1.i616 ], [ %.reg2mem87.0.i2082, %._crit_edge395.i2012.loopexit ]
  %1376 = call i32 @llvm.smax.i32(i32 %1313, i32 16)
  %result.i166.i2014 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1377 = getelementptr i8, ptr %result.i166.i2014, i64 16
  store ptr @_parameterization_Nil, ptr %1377, align 8
  %result.i167.i2015 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1378 = getelementptr i8, ptr %result.i167.i2015, i64 16
  store ptr %1374, ptr %1378, align 8
  %1379 = getelementptr i8, ptr %result.i167.i2015, i64 8
  store ptr %1375, ptr %1379, align 8
  %1380 = getelementptr i8, ptr %result.i167.i2015, i64 24
  store ptr null, ptr %1380, align 8
  %1381 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i2015)
  store ptr @Entry, ptr %result.i167.i2015, align 8
  %1382 = getelementptr i8, ptr %result.i166.i2014, i64 8
  store ptr %result.i167.i2015, ptr %1382, align 8
  %1383 = getelementptr i8, ptr %result.i166.i2014, i64 24
  store ptr null, ptr %1383, align 8
  %1384 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i2014)
  store ptr @union_typ, ptr %result.i166.i2014, align 8
  %result.i168.i2016 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i2014, ptr %result.i168.i2016, align 8
  %1385 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i2016)
  store ptr @Array, ptr %29, align 8
  store ptr %result.i168.i2016, ptr %301, align 8
  store i32 9, ptr %302, align 8
  %1386 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %29)
  %1387 = getelementptr i8, ptr %result.i168.i2016, i64 16
  store i32 %1376, ptr %1387, align 4
  %1388 = getelementptr i8, ptr %result.i168.i2016, i64 20
  store i32 %1376, ptr %1388, align 4
  %1389 = zext nneg i32 %1376 to i64
  %1390 = shl nuw nsw i64 %1389, 5
  %result.i.i416.i2017 = call noalias ptr @bump_malloc_inner(i64 noundef %1390, ptr nonnull @current_ptr) #29
  %1391 = getelementptr i8, ptr %result.i168.i2016, i64 8
  store ptr %result.i.i416.i2017, ptr %1391, align 8
  %1392 = load ptr, ptr %303, align 8
  store ptr @Array, ptr %156, align 8
  store ptr %result.i168.i2016, ptr %157, align 8
  store ptr %1392, ptr %250, align 8
  store i32 9, ptr %158, align 4
  %1393 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i2030 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1394 = getelementptr i8, ptr %result.i183.i2030, i64 16
  store ptr @_parameterization_Nil, ptr %1394, align 8
  %result.i184.i2031 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1395 = getelementptr i8, ptr %result.i184.i2031, i64 16
  store ptr %1374, ptr %1395, align 8
  %1396 = getelementptr i8, ptr %result.i184.i2031, i64 8
  store ptr %1375, ptr %1396, align 8
  %1397 = getelementptr i8, ptr %result.i184.i2031, i64 24
  store ptr null, ptr %1397, align 8
  %1398 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i2031)
  store ptr @Entry, ptr %result.i184.i2031, align 8
  %1399 = getelementptr i8, ptr %result.i183.i2030, i64 8
  store ptr %result.i184.i2031, ptr %1399, align 8
  %1400 = getelementptr i8, ptr %result.i183.i2030, i64 24
  store ptr null, ptr %1400, align 8
  %1401 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i2030)
  store ptr @union_typ, ptr %result.i183.i2030, align 8
  %result.i185.i2032 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i2030, ptr %result.i185.i2032, align 8
  %1402 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i2032)
  store ptr @Array, ptr %30, align 8
  store ptr %result.i185.i2032, ptr %304, align 8
  store i32 9, ptr %305, align 8
  %1403 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %30)
  %1404 = getelementptr i8, ptr %result.i185.i2032, i64 16
  store i32 %1376, ptr %1404, align 4
  %1405 = getelementptr i8, ptr %result.i185.i2032, i64 20
  store i32 %1376, ptr %1405, align 4
  %result.i.i430.i2033 = call noalias ptr @bump_malloc_inner(i64 noundef %1390, ptr nonnull @current_ptr) #29
  %1406 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1407 = getelementptr i8, ptr %result.i185.i2032, i64 8
  store ptr %result.i.i430.i2033, ptr %1407, align 8
  %1408 = load ptr, ptr %306, align 8
  store ptr @Array, ptr %169, align 8
  store ptr %result.i185.i2032, ptr %170, align 8
  store ptr %1408, ptr %251, align 8
  store i32 9, ptr %171, align 4
  store i32 0, ptr %252, align 4
  %1409 = icmp sgt i32 %.reg2mem91.0.lcssa.i2013, 0
  br i1 %1409, label %.lr.ph400.i2046, label %HashMap_resize_.exit2119

.lr.ph400.i2046:                                  ; preds = %._crit_edge395.i2012
  %1410 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1411 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1412 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i2048

._crit_edge2.i2048:                               ; preds = %._crit_edge2.i2048, %.lr.ph400.i2046
  %.reg2mem77.0398.i2049 = phi i32 [ 0, %.lr.ph400.i2046 ], [ %1426, %._crit_edge2.i2048 ]
  %1413 = zext nneg i32 %.reg2mem77.0398.i2049 to i64
  %1414 = shl nuw nsw i64 %1413, 5
  %1415 = getelementptr i8, ptr %result.i.i.i1998, i64 %1414
  %1416 = load ptr, ptr %1415, align 8
  %1417 = getelementptr i8, ptr %1415, i64 8
  %1418 = load i160, ptr %1417, align 4
  %.sroa.3362.8.extract.trunc.i2052 = trunc i160 %1418 to i64
  %1419 = inttoptr i64 %.sroa.3362.8.extract.trunc.i2052 to ptr
  %.sroa.5363.8.extract.shift.i2053 = lshr i160 %1418, 64
  %.sroa.5363.8.extract.trunc.i2054 = trunc i160 %.sroa.5363.8.extract.shift.i2053 to i64
  %1420 = inttoptr i64 %.sroa.5363.8.extract.trunc.i2054 to ptr
  %hash_coef_ptr.i.i201.i2055 = getelementptr i8, ptr %1416, i64 8
  %tbl_size_ptr.i.i202.i2056 = getelementptr i8, ptr %1416, i64 16
  %offset_tbl_ptr.i.i203.i2057 = getelementptr i8, ptr %1416, i64 40
  %hash_coef.i.i232.i2058 = load i64, ptr %hash_coef_ptr.i.i201.i2055, align 4
  %tbl_size.i.i233.i2059 = load i64, ptr %tbl_size_ptr.i.i202.i2056, align 4
  %offset_tbl.i.i234.i2060 = load ptr, ptr %offset_tbl_ptr.i.i203.i2057, align 8
  %product.i.i.i235.i2061 = mul i64 %hash_coef.i.i232.i2058, 4015701072841558310
  %shifted.i.i.i236.i2062 = lshr i64 %product.i.i.i235.i2061, 32
  %xored.i.i.i237.i2063 = xor i64 %shifted.i.i.i236.i2062, %product.i.i.i235.i2061
  %hash.i.i.i238.i2064 = and i64 %xored.i.i.i237.i2063, %tbl_size.i.i233.i2059
  %offset_ptr.i.i239.i2065 = getelementptr i32, ptr %offset_tbl.i.i234.i2060, i64 %hash.i.i.i238.i2064
  %offset.i.i240.i2066 = load i32, ptr %offset_ptr.i.i239.i2065, align 4
  %1421 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1416, 0
  %1422 = insertvalue { ptr, ptr, ptr, i32 } %1421, ptr %1419, 1
  %1423 = insertvalue { ptr, ptr, ptr, i32 } %1422, ptr %1420, 2
  %1424 = insertvalue { ptr, ptr, ptr, i32 } %1423, i32 %offset.i.i240.i2066, 3
  %1425 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %293, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1424)
  %1426 = add nuw nsw i32 %.reg2mem77.0398.i2049, 1
  %1427 = icmp slt i32 %1426, %.reg2mem91.0.lcssa.i2013
  br i1 %1427, label %._crit_edge2.i2048, label %HashMap_resize_.exit2119

HashMap_resize_.exit2119:                         ; preds = %._crit_edge2.i2048, %._crit_edge395.i2012
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %30)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i2120)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i2122)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %24)
  %1428 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1429 = load i32, ptr %172, align 4
  %1430 = icmp sgt i32 %1429, 0
  br i1 %1430, label %.lr.ph.i2157, label %._crit_edge1.1.i622

.lr.ph.i2157:                                     ; preds = %HashMap_resize_.exit2119
  %1431 = lshr i160 %1287, 64
  %1432 = insertelement <2 x i160> poison, i160 %1431, i64 0
  %1433 = insertelement <2 x i160> %1432, i160 %1287, i64 1
  %1434 = trunc <2 x i160> %1433 to <2 x i64>
  %1435 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1436 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1437

1437:                                             ; preds = %.cont.cont.i2211, %.lr.ph.i2157
  %offset.i.i260.i22282583 = phi i32 [ 9, %.lr.ph.i2157 ], [ %offset.i.i260.i2228, %.cont.cont.i2211 ]
  %.reg2mem195.0678.i2159 = phi i32 [ 1, %.lr.ph.i2157 ], [ %1592, %.cont.cont.i2211 ]
  %.reg2mem193.0677.i2160 = phi i32 [ 0, %.lr.ph.i2157 ], [ %1597, %.cont.cont.i2211 ]
  %1438 = phi <2 x i64> [ %1434, %.lr.ph.i2157 ], [ %1596, %.cont.cont.i2211 ]
  %1439 = extractelement <2 x i64> %1438, i64 1
  %.sroa.speculated352.i22152579 = inttoptr i64 %1439 to ptr
  %1440 = extractelement <2 x i64> %1438, i64 0
  %.sroa.speculated346.i22162581 = inttoptr i64 %1440 to ptr
  %1441 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i22152579, 1
  %1442 = insertvalue { ptr, ptr, ptr, i32 } %1441, ptr %.sroa.speculated346.i22162581, 2
  %1443 = insertvalue { ptr, ptr, ptr, i32 } %1442, i32 %offset.i.i260.i22282583, 3
  %1444 = sext i32 %offset.i.i260.i22282583 to i64
  %gep2577 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1444
  %1445 = load ptr, ptr %gep2577, align 8
  %1446 = call ptr %1445({ ptr, ptr, ptr, i32 } %1443, ptr nonnull %2)
  %1447 = call i32 %1446({ ptr, ptr, ptr, i32 } %1443, { ptr, ptr, ptr, i32 } %1443, ptr nonnull %2)
  %1448 = icmp eq i32 %.reg2mem195.0678.i2159, 1
  %1449 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1448, label %1450, label %1512

1450:                                             ; preds = %1437
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1451 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1452 = load ptr, ptr %156, align 8
  %1453 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1452, 0
  %1454 = load ptr, ptr %157, align 8
  %1455 = insertvalue { ptr, ptr, ptr, i32 } %1453, ptr %1454, 1
  %1456 = load ptr, ptr %250, align 8
  %1457 = insertvalue { ptr, ptr, ptr, i32 } %1455, ptr %1456, 2
  %1458 = load i32, ptr %158, align 4
  %1459 = insertvalue { ptr, ptr, ptr, i32 } %1457, i32 %1458, 3
  %hash_coef_ptr.i.i10.i3164 = getelementptr i8, ptr %1452, i64 8
  %tbl_size_ptr.i.i11.i3165 = getelementptr i8, ptr %1452, i64 16
  %offset_tbl_ptr.i.i12.i3166 = getelementptr i8, ptr %1452, i64 40
  %hash_coef.i.i13.i3167 = load i64, ptr %hash_coef_ptr.i.i10.i3164, align 4
  %tbl_size.i.i14.i3168 = load i64, ptr %tbl_size_ptr.i.i11.i3165, align 4
  %offset_tbl.i.i15.i3169 = load ptr, ptr %offset_tbl_ptr.i.i12.i3166, align 8
  %product.i.i.i16.i3170 = mul i64 %hash_coef.i.i13.i3167, -5261542750394134544
  %shifted.i.i.i17.i3171 = lshr i64 %product.i.i.i16.i3170, 32
  %xored.i.i.i18.i3172 = xor i64 %shifted.i.i.i17.i3171, %product.i.i.i16.i3170
  %hash.i.i.i19.i3173 = and i64 %xored.i.i.i18.i3172, %tbl_size.i.i14.i3168
  %offset_ptr.i.i20.i3174 = getelementptr i32, ptr %offset_tbl.i.i15.i3169, i64 %hash.i.i.i19.i3173
  %offset.i.i21.i3175 = load i32, ptr %offset_ptr.i.i20.i3174, align 4
  %eq.i.i3176 = icmp eq i32 %1458, %offset.i.i21.i3175
  call void @llvm.assume(i1 %eq.i.i3176) #30
  %1460 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1461 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1452)
  %1462 = sext i32 %1458 to i64
  %1463 = getelementptr ptr, ptr %1452, i64 %1462
  %1464 = getelementptr i8, ptr %1463, i64 64
  %1465 = load ptr, ptr %1464, align 8
  %1466 = call ptr %1465({ ptr, ptr, ptr, i32 } %1459, ptr nonnull %2)
  %1467 = call i32 %1466({ ptr, ptr, ptr, i32 } %1459, { ptr, ptr, ptr, i32 } %1459, ptr nonnull %2)
  %1468 = add i32 %1467, -1
  %1469 = and i32 %1468, %1447
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1470 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1471 = load ptr, ptr %156, align 8
  %1472 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1471, 0
  %1473 = load ptr, ptr %157, align 8
  %1474 = insertvalue { ptr, ptr, ptr, i32 } %1472, ptr %1473, 1
  %1475 = load ptr, ptr %250, align 8
  %1476 = insertvalue { ptr, ptr, ptr, i32 } %1474, ptr %1475, 2
  %1477 = load i32, ptr %158, align 4
  %1478 = insertvalue { ptr, ptr, ptr, i32 } %1476, i32 %1477, 3
  %hash_coef_ptr.i.i172.i2233 = getelementptr i8, ptr %1471, i64 8
  %tbl_size_ptr.i.i173.i2234 = getelementptr i8, ptr %1471, i64 16
  %offset_tbl_ptr.i.i174.i2235 = getelementptr i8, ptr %1471, i64 40
  %hash_coef.i.i175.i2236 = load i64, ptr %hash_coef_ptr.i.i172.i2233, align 4
  %tbl_size.i.i176.i2237 = load i64, ptr %tbl_size_ptr.i.i173.i2234, align 4
  %offset_tbl.i.i177.i2238 = load ptr, ptr %offset_tbl_ptr.i.i174.i2235, align 8
  %product.i.i.i178.i2239 = mul i64 %hash_coef.i.i175.i2236, -5261542750394134544
  %shifted.i.i.i179.i2240 = lshr i64 %product.i.i.i178.i2239, 32
  %xored.i.i.i180.i2241 = xor i64 %shifted.i.i.i179.i2240, %product.i.i.i178.i2239
  %hash.i.i.i181.i2242 = and i64 %xored.i.i.i180.i2241, %tbl_size.i.i176.i2237
  %offset_ptr.i.i182.i2243 = getelementptr i32, ptr %offset_tbl.i.i177.i2238, i64 %hash.i.i.i181.i2242
  %offset.i.i183.i2244 = load i32, ptr %offset_ptr.i.i182.i2243, align 4
  %eq.i.i2245 = icmp eq i32 %1477, %offset.i.i183.i2244
  call void @llvm.assume(i1 %eq.i.i2245) #30
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  %1479 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %9)
  %1480 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1471)
  %1481 = sext i32 %1477 to i64
  %1482 = getelementptr ptr, ptr %1471, i64 %1481
  %1483 = getelementptr i8, ptr %1482, i64 120
  %1484 = load ptr, ptr %1483, align 8
  store ptr @i32_typ, ptr %10, align 8
  %1485 = call ptr %1484({ ptr, ptr, ptr, i32 } %1478, ptr nonnull %10)
  %1486 = call { ptr, i160 } %1485({ ptr, ptr, ptr, i32 } %1478, { ptr, ptr, ptr, i32 } %1478, ptr nonnull %9, i32 %1469)
  %.fca.0.extract112.i2246 = extractvalue { ptr, i160 } %1486, 0
  %.sroa.3111.0.insert.ext.i2247 = zext i32 %offset.i.i260.i22282583 to i160
  %.sroa.3111.0.insert.shift.i2248 = shl nuw i160 %.sroa.3111.0.insert.ext.i2247, 128
  %.sroa.2110.0.insert.ext.i2249 = zext i64 %1440 to i160
  %.sroa.2110.0.insert.shift.i2250 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i2249, 64
  %.sroa.2110.0.insert.insert.i2251 = or disjoint i160 %.sroa.2110.0.insert.shift.i2250, %.sroa.3111.0.insert.shift.i2248
  %.sroa.0109.0.insert.ext.i2252 = zext i64 %1439 to i160
  %.sroa.0109.0.insert.insert.i2253 = or disjoint i160 %.sroa.2110.0.insert.insert.i2251, %.sroa.0109.0.insert.ext.i2252
  %1487 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i2253, 1
  %1488 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1489 = load ptr, ptr %156, align 8
  %1490 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1489, 0
  %1491 = load ptr, ptr %157, align 8
  %1492 = insertvalue { ptr, ptr, ptr, i32 } %1490, ptr %1491, 1
  %1493 = load ptr, ptr %250, align 8
  %1494 = insertvalue { ptr, ptr, ptr, i32 } %1492, ptr %1493, 2
  %1495 = load i32, ptr %158, align 4
  %1496 = insertvalue { ptr, ptr, ptr, i32 } %1494, i32 %1495, 3
  %hash_coef_ptr.i.i186.i2258 = getelementptr i8, ptr %1489, i64 8
  %tbl_size_ptr.i.i187.i2259 = getelementptr i8, ptr %1489, i64 16
  %offset_tbl_ptr.i.i188.i2260 = getelementptr i8, ptr %1489, i64 40
  %hash_coef.i.i189.i2261 = load i64, ptr %hash_coef_ptr.i.i186.i2258, align 4
  %tbl_size.i.i190.i2262 = load i64, ptr %tbl_size_ptr.i.i187.i2259, align 4
  %offset_tbl.i.i191.i2263 = load ptr, ptr %offset_tbl_ptr.i.i188.i2260, align 8
  %product.i.i.i192.i2264 = mul i64 %hash_coef.i.i189.i2261, -5261542750394134544
  %shifted.i.i.i193.i2265 = lshr i64 %product.i.i.i192.i2264, 32
  %xored.i.i.i194.i2266 = xor i64 %shifted.i.i.i193.i2265, %product.i.i.i192.i2264
  %hash.i.i.i195.i2267 = and i64 %xored.i.i.i194.i2266, %tbl_size.i.i190.i2262
  %offset_ptr.i.i196.i2268 = getelementptr i32, ptr %offset_tbl.i.i191.i2263, i64 %hash.i.i.i195.i2267
  %offset.i.i197.i2269 = load i32, ptr %offset_ptr.i.i196.i2268, align 4
  %eq.i200.i2270 = icmp eq i32 %1495, %offset.i.i197.i2269
  call void @llvm.assume(i1 %eq.i200.i2270) #30
  %1497 = load ptr, ptr %result.i, align 8
  %1498 = load ptr, ptr %139, align 8
  %result.i.i2271 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1499 = getelementptr i8, ptr %result.i.i2271, i64 16
  store ptr %1498, ptr %1499, align 8
  %1500 = getelementptr i8, ptr %result.i.i2271, i64 8
  store ptr %1497, ptr %1500, align 8
  %1501 = getelementptr i8, ptr %result.i.i2271, i64 24
  store ptr null, ptr %1501, align 8
  %1502 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i2271)
  store ptr @Entry, ptr %result.i.i2271, align 8
  store ptr @_parameterization_Ptri32, ptr %11, align 8
  store ptr %result.i.i2271, ptr %309, align 8
  %1503 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %11)
  %1504 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1489)
  %1505 = sext i32 %1495 to i64
  %1506 = getelementptr ptr, ptr %1489, i64 %1505
  %1507 = getelementptr i8, ptr %1506, i64 128
  %1508 = load ptr, ptr %1507, align 8
  store ptr @i32_typ, ptr %12, align 8
  store ptr @Entry, ptr %310, align 8
  %1509 = call ptr %1508({ ptr, ptr, ptr, i32 } %1496, ptr nonnull %12)
  call void %1509({ ptr, ptr, ptr, i32 } %1496, { ptr, ptr, ptr, i32 } %1496, ptr nonnull %11, i32 %1469, { ptr, i160 } %1487)
  %1510 = icmp ne ptr %.fca.0.extract112.i2246, @nil_typ
  %1511 = icmp ne ptr %.fca.0.extract112.i2246, null
  %.not140.i2272 = and i1 %1510, %1511
  br i1 %.not140.i2272, label %.cont.cont.i2211, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2278.thread

1512:                                             ; preds = %1437
  %1513 = add i32 %1447, 2127912214
  %1514 = shl i32 %1447, 12
  %1515 = add i32 %1513, %1514
  %1516 = ashr i32 %1515, 19
  %1517 = xor i32 %1515, %1516
  %1518 = xor i32 %1517, -949894596
  %1519 = add i32 %1518, 374761393
  %1520 = shl i32 %1518, 5
  %1521 = add i32 %1519, %1520
  %1522 = add i32 %1521, -744332180
  %1523 = shl i32 %1521, 9
  %1524 = xor i32 %1522, %1523
  %1525 = add i32 %1524, -42973499
  %1526 = shl i32 %1524, 3
  %1527 = add i32 %1525, %1526
  %1528 = ashr i32 %1527, 16
  %1529 = xor i32 %1527, %1528
  %1530 = xor i32 %1529, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1531 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1532 = load ptr, ptr %169, align 8
  %1533 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1532, 0
  %1534 = load ptr, ptr %170, align 8
  %1535 = insertvalue { ptr, ptr, ptr, i32 } %1533, ptr %1534, 1
  %1536 = load ptr, ptr %251, align 8
  %1537 = insertvalue { ptr, ptr, ptr, i32 } %1535, ptr %1536, 2
  %1538 = load i32, ptr %171, align 4
  %1539 = insertvalue { ptr, ptr, ptr, i32 } %1537, i32 %1538, 3
  %hash_coef_ptr.i.i10.i3194 = getelementptr i8, ptr %1532, i64 8
  %tbl_size_ptr.i.i11.i3195 = getelementptr i8, ptr %1532, i64 16
  %offset_tbl_ptr.i.i12.i3196 = getelementptr i8, ptr %1532, i64 40
  %hash_coef.i.i13.i3197 = load i64, ptr %hash_coef_ptr.i.i10.i3194, align 4
  %tbl_size.i.i14.i3198 = load i64, ptr %tbl_size_ptr.i.i11.i3195, align 4
  %offset_tbl.i.i15.i3199 = load ptr, ptr %offset_tbl_ptr.i.i12.i3196, align 8
  %product.i.i.i16.i3200 = mul i64 %hash_coef.i.i13.i3197, -5261542750394134544
  %shifted.i.i.i17.i3201 = lshr i64 %product.i.i.i16.i3200, 32
  %xored.i.i.i18.i3202 = xor i64 %shifted.i.i.i17.i3201, %product.i.i.i16.i3200
  %hash.i.i.i19.i3203 = and i64 %xored.i.i.i18.i3202, %tbl_size.i.i14.i3198
  %offset_ptr.i.i20.i3204 = getelementptr i32, ptr %offset_tbl.i.i15.i3199, i64 %hash.i.i.i19.i3203
  %offset.i.i21.i3205 = load i32, ptr %offset_ptr.i.i20.i3204, align 4
  %eq.i.i3206 = icmp eq i32 %1538, %offset.i.i21.i3205
  call void @llvm.assume(i1 %eq.i.i3206) #30
  %1540 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1541 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1532)
  %1542 = sext i32 %1538 to i64
  %1543 = getelementptr ptr, ptr %1532, i64 %1542
  %1544 = getelementptr i8, ptr %1543, i64 64
  %1545 = load ptr, ptr %1544, align 8
  %1546 = call ptr %1545({ ptr, ptr, ptr, i32 } %1539, ptr nonnull %2)
  %1547 = call i32 %1546({ ptr, ptr, ptr, i32 } %1539, { ptr, ptr, ptr, i32 } %1539, ptr nonnull %2)
  %1548 = add i32 %1547, -1
  %1549 = and i32 %1548, %1530
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1550 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1551 = load ptr, ptr %169, align 8
  %1552 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1551, 0
  %1553 = load ptr, ptr %170, align 8
  %1554 = insertvalue { ptr, ptr, ptr, i32 } %1552, ptr %1553, 1
  %1555 = load ptr, ptr %251, align 8
  %1556 = insertvalue { ptr, ptr, ptr, i32 } %1554, ptr %1555, 2
  %1557 = load i32, ptr %171, align 4
  %1558 = insertvalue { ptr, ptr, ptr, i32 } %1556, i32 %1557, 3
  %hash_coef_ptr.i.i202.i2165 = getelementptr i8, ptr %1551, i64 8
  %tbl_size_ptr.i.i203.i2166 = getelementptr i8, ptr %1551, i64 16
  %offset_tbl_ptr.i.i204.i2167 = getelementptr i8, ptr %1551, i64 40
  %hash_coef.i.i205.i2168 = load i64, ptr %hash_coef_ptr.i.i202.i2165, align 4
  %tbl_size.i.i206.i2169 = load i64, ptr %tbl_size_ptr.i.i203.i2166, align 4
  %offset_tbl.i.i207.i2170 = load ptr, ptr %offset_tbl_ptr.i.i204.i2167, align 8
  %product.i.i.i208.i2171 = mul i64 %hash_coef.i.i205.i2168, -5261542750394134544
  %shifted.i.i.i209.i2172 = lshr i64 %product.i.i.i208.i2171, 32
  %xored.i.i.i210.i2173 = xor i64 %shifted.i.i.i209.i2172, %product.i.i.i208.i2171
  %hash.i.i.i211.i2174 = and i64 %xored.i.i.i210.i2173, %tbl_size.i.i206.i2169
  %offset_ptr.i.i212.i2175 = getelementptr i32, ptr %offset_tbl.i.i207.i2170, i64 %hash.i.i.i211.i2174
  %offset.i.i213.i2176 = load i32, ptr %offset_ptr.i.i212.i2175, align 4
  %eq.i216.i2177 = icmp eq i32 %1557, %offset.i.i213.i2176
  call void @llvm.assume(i1 %eq.i216.i2177) #30
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %1559 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %17)
  %1560 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1551)
  %1561 = sext i32 %1557 to i64
  %1562 = getelementptr ptr, ptr %1551, i64 %1561
  %1563 = getelementptr i8, ptr %1562, i64 120
  %1564 = load ptr, ptr %1563, align 8
  store ptr @i32_typ, ptr %18, align 8
  %1565 = call ptr %1564({ ptr, ptr, ptr, i32 } %1558, ptr nonnull %18)
  %1566 = call { ptr, i160 } %1565({ ptr, ptr, ptr, i32 } %1558, { ptr, ptr, ptr, i32 } %1558, ptr nonnull %17, i32 %1549)
  %.fca.0.extract87.i2178 = extractvalue { ptr, i160 } %1566, 0
  %.sroa.3.0.insert.ext.i2179 = zext i32 %offset.i.i260.i22282583 to i160
  %.sroa.3.0.insert.shift.i2180 = shl nuw i160 %.sroa.3.0.insert.ext.i2179, 128
  %.sroa.2.0.insert.ext.i2181 = zext i64 %1440 to i160
  %.sroa.2.0.insert.shift.i2182 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i2181, 64
  %.sroa.2.0.insert.insert.i2183 = or disjoint i160 %.sroa.2.0.insert.shift.i2182, %.sroa.3.0.insert.shift.i2180
  %.sroa.0.0.insert.ext.i2184 = zext i64 %1439 to i160
  %.sroa.0.0.insert.insert.i2185 = or disjoint i160 %.sroa.2.0.insert.insert.i2183, %.sroa.0.0.insert.ext.i2184
  %1567 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i2185, 1
  %1568 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1569 = load ptr, ptr %169, align 8
  %1570 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1569, 0
  %1571 = load ptr, ptr %170, align 8
  %1572 = insertvalue { ptr, ptr, ptr, i32 } %1570, ptr %1571, 1
  %1573 = load ptr, ptr %251, align 8
  %1574 = insertvalue { ptr, ptr, ptr, i32 } %1572, ptr %1573, 2
  %1575 = load i32, ptr %171, align 4
  %1576 = insertvalue { ptr, ptr, ptr, i32 } %1574, i32 %1575, 3
  %hash_coef_ptr.i.i218.i2190 = getelementptr i8, ptr %1569, i64 8
  %tbl_size_ptr.i.i219.i2191 = getelementptr i8, ptr %1569, i64 16
  %offset_tbl_ptr.i.i220.i2192 = getelementptr i8, ptr %1569, i64 40
  %hash_coef.i.i221.i2193 = load i64, ptr %hash_coef_ptr.i.i218.i2190, align 4
  %tbl_size.i.i222.i2194 = load i64, ptr %tbl_size_ptr.i.i219.i2191, align 4
  %offset_tbl.i.i223.i2195 = load ptr, ptr %offset_tbl_ptr.i.i220.i2192, align 8
  %product.i.i.i224.i2196 = mul i64 %hash_coef.i.i221.i2193, -5261542750394134544
  %shifted.i.i.i225.i2197 = lshr i64 %product.i.i.i224.i2196, 32
  %xored.i.i.i226.i2198 = xor i64 %shifted.i.i.i225.i2197, %product.i.i.i224.i2196
  %hash.i.i.i227.i2199 = and i64 %xored.i.i.i226.i2198, %tbl_size.i.i222.i2194
  %offset_ptr.i.i228.i2200 = getelementptr i32, ptr %offset_tbl.i.i223.i2195, i64 %hash.i.i.i227.i2199
  %offset.i.i229.i2201 = load i32, ptr %offset_ptr.i.i228.i2200, align 4
  %eq.i232.i2202 = icmp eq i32 %1575, %offset.i.i229.i2201
  call void @llvm.assume(i1 %eq.i232.i2202) #30
  %1577 = load ptr, ptr %result.i, align 8
  %1578 = load ptr, ptr %139, align 8
  %result.i233.i2203 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1579 = getelementptr i8, ptr %result.i233.i2203, i64 16
  store ptr %1578, ptr %1579, align 8
  %1580 = getelementptr i8, ptr %result.i233.i2203, i64 8
  store ptr %1577, ptr %1580, align 8
  %1581 = getelementptr i8, ptr %result.i233.i2203, i64 24
  store ptr null, ptr %1581, align 8
  %1582 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i2203)
  store ptr @Entry, ptr %result.i233.i2203, align 8
  store ptr @_parameterization_Ptri32, ptr %19, align 8
  store ptr %result.i233.i2203, ptr %307, align 8
  %1583 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %19)
  %1584 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1569)
  %1585 = sext i32 %1575 to i64
  %1586 = getelementptr ptr, ptr %1569, i64 %1585
  %1587 = getelementptr i8, ptr %1586, i64 128
  %1588 = load ptr, ptr %1587, align 8
  store ptr @i32_typ, ptr %20, align 8
  store ptr @Entry, ptr %308, align 8
  %1589 = call ptr %1588({ ptr, ptr, ptr, i32 } %1576, ptr nonnull %20)
  call void %1589({ ptr, ptr, ptr, i32 } %1576, { ptr, ptr, ptr, i32 } %1576, ptr nonnull %19, i32 %1549, { ptr, i160 } %1567)
  %1590 = icmp ne ptr %.fca.0.extract87.i2178, @nil_typ
  %1591 = icmp ne ptr %.fca.0.extract87.i2178, null
  %.not138.i2204 = and i1 %1590, %1591
  br i1 %.not138.i2204, label %.cont.cont.i2211, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2278.thread

.cont.cont.i2211:                                 ; preds = %1512, %1450
  %.sink2601 = phi { ptr, i160 } [ %1486, %1450 ], [ %1566, %1512 ]
  %1592 = phi i32 [ 2, %1450 ], [ 1, %1512 ]
  %vptr.i248.sroa.speculated.i2214 = phi ptr [ %.fca.0.extract112.i2246, %1450 ], [ %.fca.0.extract87.i2178, %1512 ]
  %.fca.1.extract89.i2207 = extractvalue { ptr, i160 } %.sink2601, 1
  %.sroa.3407.sroa.4.0.extract.shift.i2208 = lshr i160 %.fca.1.extract89.i2207, 64
  %1593 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i2208 to i64
  %1594 = insertelement <2 x i64> poison, i64 %1593, i64 0
  %1595 = trunc i160 %.fca.1.extract89.i2207 to i64
  %1596 = insertelement <2 x i64> %1594, i64 %1595, i64 1
  %hash_coef_ptr.i.i249.i2217 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2214, i64 8
  %tbl_size_ptr.i.i250.i2218 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2214, i64 16
  %offset_tbl_ptr.i.i251.i2219 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2214, i64 40
  %hash_coef.i.i252.i2220 = load i64, ptr %hash_coef_ptr.i.i249.i2217, align 4
  %tbl_size.i.i253.i2221 = load i64, ptr %tbl_size_ptr.i.i250.i2218, align 4
  %offset_tbl.i.i254.i2222 = load ptr, ptr %offset_tbl_ptr.i.i251.i2219, align 8
  %product.i.i.i255.i2223 = mul i64 %hash_coef.i.i252.i2220, 4015701072841558310
  %shifted.i.i.i256.i2224 = lshr i64 %product.i.i.i255.i2223, 32
  %xored.i.i.i257.i2225 = xor i64 %shifted.i.i.i256.i2224, %product.i.i.i255.i2223
  %hash.i.i.i258.i2226 = and i64 %xored.i.i.i257.i2225, %tbl_size.i.i253.i2221
  %offset_ptr.i.i259.i2227 = getelementptr i32, ptr %offset_tbl.i.i254.i2222, i64 %hash.i.i.i258.i2226
  %offset.i.i260.i2228 = load i32, ptr %offset_ptr.i.i259.i2227, align 4
  %1597 = add nuw nsw i32 %.reg2mem193.0677.i2160, 1
  %1598 = load i32, ptr %172, align 4
  %1599 = icmp slt i32 %1597, %1598
  br i1 %1599, label %1437, label %._crit_edge1.1.i622

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2278.thread: ; preds = %1450, %1512
  %1600 = phi ptr [ %21, %1512 ], [ %13, %1450 ]
  %1601 = phi ptr [ %22, %1512 ], [ %14, %1450 ]
  %1602 = phi ptr [ %23, %1512 ], [ %15, %1450 ]
  %1603 = phi ptr [ %.sroa.0.i2122, %1512 ], [ %.sroa.0680.i2120, %1450 ]
  %1604 = phi ptr [ %24, %1512 ], [ %16, %1450 ]
  %1605 = load i32, ptr %252, align 4
  store i32 %1605, ptr %1600, align 4
  store i32 1, ptr %1601, align 4
  %1606 = add i32 %1605, 1
  store i32 %1606, ptr %1602, align 4
  %1607 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1606, ptr %252, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1604, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1603, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2120)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2122)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  br label %HashMap_insert_keyK_valueV.exit705

._crit_edge1.1.i622:                              ; preds = %.cont.cont.i2211, %HashMap_resize_.exit2119
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2120)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2122)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %8)
  %1608 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1609 = load ptr, ptr %156, align 8
  %1610 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1609, 0
  %1611 = load ptr, ptr %157, align 8
  %1612 = insertvalue { ptr, ptr, ptr, i32 } %1610, ptr %1611, 1
  %1613 = load ptr, ptr %250, align 8
  %1614 = insertvalue { ptr, ptr, ptr, i32 } %1612, ptr %1613, 2
  %1615 = load i32, ptr %158, align 4
  %1616 = insertvalue { ptr, ptr, ptr, i32 } %1614, i32 %1615, 3
  %hash_coef_ptr.i.i64.i2296 = getelementptr i8, ptr %1609, i64 8
  %tbl_size_ptr.i.i65.i2297 = getelementptr i8, ptr %1609, i64 16
  %offset_tbl_ptr.i.i66.i2298 = getelementptr i8, ptr %1609, i64 40
  %hash_coef.i.i67.i2299 = load i64, ptr %hash_coef_ptr.i.i64.i2296, align 4
  %tbl_size.i.i68.i2300 = load i64, ptr %tbl_size_ptr.i.i65.i2297, align 4
  %offset_tbl.i.i69.i2301 = load ptr, ptr %offset_tbl_ptr.i.i66.i2298, align 8
  %product.i.i.i70.i2302 = mul i64 %hash_coef.i.i67.i2299, -5261542750394134544
  %shifted.i.i.i71.i2303 = lshr i64 %product.i.i.i70.i2302, 32
  %xored.i.i.i72.i2304 = xor i64 %shifted.i.i.i71.i2303, %product.i.i.i70.i2302
  %hash.i.i.i73.i2305 = and i64 %xored.i.i.i72.i2304, %tbl_size.i.i68.i2300
  %offset_ptr.i.i74.i2306 = getelementptr i32, ptr %offset_tbl.i.i69.i2301, i64 %hash.i.i.i73.i2305
  %offset.i.i75.i2307 = load i32, ptr %offset_ptr.i.i74.i2306, align 4
  %eq.i.i2308 = icmp eq i32 %1615, %offset.i.i75.i2307
  call void @llvm.assume(i1 %eq.i.i2308) #30
  %1617 = load ptr, ptr %169, align 8
  %1618 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1617, 0
  %1619 = load ptr, ptr %170, align 8
  %1620 = insertvalue { ptr, ptr, ptr, i32 } %1618, ptr %1619, 1
  %1621 = load ptr, ptr %251, align 8
  %1622 = insertvalue { ptr, ptr, ptr, i32 } %1620, ptr %1621, 2
  %1623 = load i32, ptr %171, align 4
  %1624 = insertvalue { ptr, ptr, ptr, i32 } %1622, i32 %1623, 3
  %hash_coef_ptr.i.i92.i2313 = getelementptr i8, ptr %1617, i64 8
  %tbl_size_ptr.i.i93.i2314 = getelementptr i8, ptr %1617, i64 16
  %offset_tbl_ptr.i.i94.i2315 = getelementptr i8, ptr %1617, i64 40
  %hash_coef.i.i95.i2316 = load i64, ptr %hash_coef_ptr.i.i92.i2313, align 4
  %tbl_size.i.i96.i2317 = load i64, ptr %tbl_size_ptr.i.i93.i2314, align 4
  %offset_tbl.i.i97.i2318 = load ptr, ptr %offset_tbl_ptr.i.i94.i2315, align 8
  %product.i.i.i98.i2319 = mul i64 %hash_coef.i.i95.i2316, -5261542750394134544
  %shifted.i.i.i99.i2320 = lshr i64 %product.i.i.i98.i2319, 32
  %xored.i.i.i100.i2321 = xor i64 %shifted.i.i.i99.i2320, %product.i.i.i98.i2319
  %hash.i.i.i101.i2322 = and i64 %xored.i.i.i100.i2321, %tbl_size.i.i96.i2317
  %offset_ptr.i.i102.i2323 = getelementptr i32, ptr %offset_tbl.i.i97.i2318, i64 %hash.i.i.i101.i2322
  %offset.i.i103.i2324 = load i32, ptr %offset_ptr.i.i102.i2323, align 4
  %eq.i106.i2325 = icmp eq i32 %1623, %offset.i.i103.i2324
  call void @llvm.assume(i1 %eq.i106.i2325) #30
  %1625 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1626 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1609)
  %1627 = sext i32 %1615 to i64
  %1628 = getelementptr ptr, ptr %1609, i64 %1627
  %1629 = getelementptr i8, ptr %1628, i64 64
  %1630 = load ptr, ptr %1629, align 8
  %1631 = call ptr %1630({ ptr, ptr, ptr, i32 } %1616, ptr nonnull %2)
  %1632 = call i32 %1631({ ptr, ptr, ptr, i32 } %1616, { ptr, ptr, ptr, i32 } %1616, ptr nonnull %2)
  %1633 = shl i32 %1632, 1
  %1634 = load i32, ptr %252, align 4
  %1635 = load ptr, ptr %result.i, align 8
  %1636 = load ptr, ptr %139, align 8
  %1637 = sext i32 %1634 to i64
  %1638 = shl nsw i64 %1637, 5
  %result.i.i.i2328 = call noalias ptr @bump_malloc_inner(i64 noundef %1638, ptr nonnull @current_ptr) #29
  %1639 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1640 = icmp sgt i32 %1632, 0
  br i1 %1640, label %.lr.ph434.i2398, label %._crit_edge395.i2342

.lr.ph434.i2398:                                  ; preds = %._crit_edge1.1.i622
  %invariant.gep.i2341 = getelementptr i8, ptr %1609, i64 120
  %1641 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i2401 = getelementptr ptr, ptr %invariant.gep.i2341, i64 %1627
  br label %1642

1642:                                             ; preds = %1664, %.lr.ph434.i2398
  %.reg2mem105.0432.i2399 = phi i32 [ 0, %.lr.ph434.i2398 ], [ %.reg2mem101.0.i2404, %1664 ]
  %.reg2mem103.0431.i2400 = phi i32 [ 0, %.lr.ph434.i2398 ], [ %1665, %1664 ]
  store ptr @_parameterization_Ptri32, ptr %3, align 8
  %1643 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %3)
  %1644 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1609)
  %1645 = load ptr, ptr %gep.i2401, align 8
  store ptr @i32_typ, ptr %4, align 8
  %1646 = call ptr %1645({ ptr, ptr, ptr, i32 } %1616, ptr nonnull %4)
  %1647 = call { ptr, i160 } %1646({ ptr, ptr, ptr, i32 } %1616, { ptr, ptr, ptr, i32 } %1616, ptr nonnull %3, i32 %.reg2mem103.0431.i2400)
  %.fca.0.extract52.i2402 = extractvalue { ptr, i160 } %1647, 0
  %1648 = icmp ne ptr %.fca.0.extract52.i2402, @nil_typ
  %1649 = icmp ne ptr %.fca.0.extract52.i2402, null
  %.not60.i2403 = and i1 %1648, %1649
  br i1 %.not60.i2403, label %1650, label %1664

1650:                                             ; preds = %1642
  %hash_coef_ptr.i.i137.i2431 = getelementptr i8, ptr %.fca.0.extract52.i2402, i64 8
  %tbl_size_ptr.i.i138.i2432 = getelementptr i8, ptr %.fca.0.extract52.i2402, i64 16
  %offset_tbl_ptr.i.i139.i2433 = getelementptr i8, ptr %.fca.0.extract52.i2402, i64 40
  %hash_coef.i.i140.i2434 = load i64, ptr %hash_coef_ptr.i.i137.i2431, align 4
  %tbl_size.i.i141.i2435 = load i64, ptr %tbl_size_ptr.i.i138.i2432, align 4
  %offset_tbl.i.i142.i2436 = load ptr, ptr %offset_tbl_ptr.i.i139.i2433, align 8
  %product.i.i.i143.i2437 = mul i64 %hash_coef.i.i140.i2434, 4015701072841558310
  %shifted.i.i.i144.i2438 = lshr i64 %product.i.i.i143.i2437, 32
  %xored.i.i.i145.i2439 = xor i64 %shifted.i.i.i144.i2438, %product.i.i.i143.i2437
  %hash.i.i.i146.i2440 = and i64 %xored.i.i.i145.i2439, %tbl_size.i.i141.i2435
  %offset_ptr.i.i147.i2441 = getelementptr i32, ptr %offset_tbl.i.i142.i2436, i64 %hash.i.i.i146.i2440
  %offset.i.i148.i2442 = load i32, ptr %offset_ptr.i.i147.i2441, align 4
  %1651 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1652 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1653 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1654 = icmp slt i32 %.reg2mem105.0432.i2399, %1634
  br i1 %1654, label %1655, label %._crit_edge.i2443

1655:                                             ; preds = %1650
  %.fca.1.extract54.i2444 = extractvalue { ptr, i160 } %1647, 1
  %.sroa.351.0.insert.ext.i2445 = zext i32 %offset.i.i148.i2442 to i160
  %.sroa.351.0.insert.shift.i2446 = shl nuw i160 %.sroa.351.0.insert.ext.i2445, 128
  %1656 = and i160 %.fca.1.extract54.i2444, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2447 = or disjoint i160 %.sroa.351.0.insert.shift.i2446, %1656
  %1657 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1658 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1659 = sext i32 %.reg2mem105.0432.i2399 to i64
  %1660 = shl nsw i64 %1659, 5
  %1661 = getelementptr i8, ptr %result.i.i.i2328, i64 %1660
  store ptr %.fca.0.extract52.i2402, ptr %1661, align 8
  %1662 = getelementptr i8, ptr %1661, i64 8
  store i160 %.sroa.049.0.insert.insert.i2447, ptr %1662, align 4
  br label %._crit_edge.i2443

._crit_edge.i2443:                                ; preds = %1655, %1650
  %1663 = add i32 %.reg2mem105.0432.i2399, 1
  br label %1664

1664:                                             ; preds = %._crit_edge.i2443, %1642
  %.reg2mem101.0.i2404 = phi i32 [ %1663, %._crit_edge.i2443 ], [ %.reg2mem105.0432.i2399, %1642 ]
  %1665 = add nuw nsw i32 %.reg2mem103.0431.i2400, 1
  %1666 = icmp slt i32 %1665, %1632
  br i1 %1666, label %1642, label %.lr.ph.i2405

.lr.ph.i2405:                                     ; preds = %1664
  %invariant.gep396.i2406 = getelementptr i8, ptr %1617, i64 120
  %1667 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1668 = sext i32 %1623 to i64
  %gep397.i2409 = getelementptr ptr, ptr %invariant.gep396.i2406, i64 %1668
  br label %1669

1669:                                             ; preds = %1691, %.lr.ph.i2405
  %.reg2mem91.0394.i2407 = phi i32 [ %.reg2mem101.0.i2404, %.lr.ph.i2405 ], [ %.reg2mem87.0.i2412, %1691 ]
  %.reg2mem89.0393.i2408 = phi i32 [ 0, %.lr.ph.i2405 ], [ %1692, %1691 ]
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %1670 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %1671 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1617)
  %1672 = load ptr, ptr %gep397.i2409, align 8
  store ptr @i32_typ, ptr %6, align 8
  %1673 = call ptr %1672({ ptr, ptr, ptr, i32 } %1624, ptr nonnull %6)
  %1674 = call { ptr, i160 } %1673({ ptr, ptr, ptr, i32 } %1624, { ptr, ptr, ptr, i32 } %1624, ptr nonnull %5, i32 %.reg2mem89.0393.i2408)
  %.fca.0.extract42.i2410 = extractvalue { ptr, i160 } %1674, 0
  %1675 = icmp ne ptr %.fca.0.extract42.i2410, @nil_typ
  %1676 = icmp ne ptr %.fca.0.extract42.i2410, null
  %.not62.i2411 = and i1 %1675, %1676
  br i1 %.not62.i2411, label %1677, label %1691

1677:                                             ; preds = %1669
  %hash_coef_ptr.i.i152.i2413 = getelementptr i8, ptr %.fca.0.extract42.i2410, i64 8
  %tbl_size_ptr.i.i153.i2414 = getelementptr i8, ptr %.fca.0.extract42.i2410, i64 16
  %offset_tbl_ptr.i.i154.i2415 = getelementptr i8, ptr %.fca.0.extract42.i2410, i64 40
  %hash_coef.i.i155.i2416 = load i64, ptr %hash_coef_ptr.i.i152.i2413, align 4
  %tbl_size.i.i156.i2417 = load i64, ptr %tbl_size_ptr.i.i153.i2414, align 4
  %offset_tbl.i.i157.i2418 = load ptr, ptr %offset_tbl_ptr.i.i154.i2415, align 8
  %product.i.i.i158.i2419 = mul i64 %hash_coef.i.i155.i2416, 4015701072841558310
  %shifted.i.i.i159.i2420 = lshr i64 %product.i.i.i158.i2419, 32
  %xored.i.i.i160.i2421 = xor i64 %shifted.i.i.i159.i2420, %product.i.i.i158.i2419
  %hash.i.i.i161.i2422 = and i64 %xored.i.i.i160.i2421, %tbl_size.i.i156.i2417
  %offset_ptr.i.i162.i2423 = getelementptr i32, ptr %offset_tbl.i.i157.i2418, i64 %hash.i.i.i161.i2422
  %offset.i.i163.i2424 = load i32, ptr %offset_ptr.i.i162.i2423, align 4
  %1678 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1679 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1680 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1681 = icmp slt i32 %.reg2mem91.0394.i2407, %1634
  br i1 %1681, label %1682, label %._crit_edge1.i2425

1682:                                             ; preds = %1677
  %.fca.1.extract44.i2426 = extractvalue { ptr, i160 } %1674, 1
  %.sroa.3.0.insert.ext.i2427 = zext i32 %offset.i.i163.i2424 to i160
  %.sroa.3.0.insert.shift.i2428 = shl nuw i160 %.sroa.3.0.insert.ext.i2427, 128
  %1683 = and i160 %.fca.1.extract44.i2426, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2429 = or disjoint i160 %.sroa.3.0.insert.shift.i2428, %1683
  %1684 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1685 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1686 = sext i32 %.reg2mem91.0394.i2407 to i64
  %1687 = shl nsw i64 %1686, 5
  %1688 = getelementptr i8, ptr %result.i.i.i2328, i64 %1687
  store ptr %.fca.0.extract42.i2410, ptr %1688, align 8
  %1689 = getelementptr i8, ptr %1688, i64 8
  store i160 %.sroa.040.0.insert.insert.i2429, ptr %1689, align 4
  br label %._crit_edge1.i2425

._crit_edge1.i2425:                               ; preds = %1682, %1677
  %1690 = add i32 %.reg2mem91.0394.i2407, 1
  br label %1691

1691:                                             ; preds = %._crit_edge1.i2425, %1669
  %.reg2mem87.0.i2412 = phi i32 [ %1690, %._crit_edge1.i2425 ], [ %.reg2mem91.0394.i2407, %1669 ]
  %1692 = add nuw nsw i32 %.reg2mem89.0393.i2408, 1
  %1693 = icmp slt i32 %1692, %1632
  br i1 %1693, label %1669, label %._crit_edge395.i2342.loopexit

._crit_edge395.i2342.loopexit:                    ; preds = %1691
  %.pre2955 = load ptr, ptr %result.i, align 8
  %.pre2956 = load ptr, ptr %139, align 8
  br label %._crit_edge395.i2342

._crit_edge395.i2342:                             ; preds = %._crit_edge395.i2342.loopexit, %._crit_edge1.1.i622
  %1694 = phi ptr [ %1636, %._crit_edge1.1.i622 ], [ %.pre2956, %._crit_edge395.i2342.loopexit ]
  %1695 = phi ptr [ %1635, %._crit_edge1.1.i622 ], [ %.pre2955, %._crit_edge395.i2342.loopexit ]
  %.reg2mem91.0.lcssa.i2343 = phi i32 [ 0, %._crit_edge1.1.i622 ], [ %.reg2mem87.0.i2412, %._crit_edge395.i2342.loopexit ]
  %1696 = call i32 @llvm.smax.i32(i32 %1633, i32 16)
  %result.i166.i2344 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1697 = getelementptr i8, ptr %result.i166.i2344, i64 16
  store ptr @_parameterization_Nil, ptr %1697, align 8
  %result.i167.i2345 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1698 = getelementptr i8, ptr %result.i167.i2345, i64 16
  store ptr %1694, ptr %1698, align 8
  %1699 = getelementptr i8, ptr %result.i167.i2345, i64 8
  store ptr %1695, ptr %1699, align 8
  %1700 = getelementptr i8, ptr %result.i167.i2345, i64 24
  store ptr null, ptr %1700, align 8
  %1701 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i2345)
  store ptr @Entry, ptr %result.i167.i2345, align 8
  %1702 = getelementptr i8, ptr %result.i166.i2344, i64 8
  store ptr %result.i167.i2345, ptr %1702, align 8
  %1703 = getelementptr i8, ptr %result.i166.i2344, i64 24
  store ptr null, ptr %1703, align 8
  %1704 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i2344)
  store ptr @union_typ, ptr %result.i166.i2344, align 8
  %result.i168.i2346 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i2344, ptr %result.i168.i2346, align 8
  %1705 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i2346)
  store ptr @Array, ptr %7, align 8
  store ptr %result.i168.i2346, ptr %311, align 8
  store i32 9, ptr %312, align 8
  %1706 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %7)
  %1707 = getelementptr i8, ptr %result.i168.i2346, i64 16
  store i32 %1696, ptr %1707, align 4
  %1708 = getelementptr i8, ptr %result.i168.i2346, i64 20
  store i32 %1696, ptr %1708, align 4
  %1709 = zext nneg i32 %1696 to i64
  %1710 = shl nuw nsw i64 %1709, 5
  %result.i.i416.i2347 = call noalias ptr @bump_malloc_inner(i64 noundef %1710, ptr nonnull @current_ptr) #29
  %1711 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1712 = getelementptr i8, ptr %result.i168.i2346, i64 8
  store ptr %result.i.i416.i2347, ptr %1712, align 8
  %1713 = load ptr, ptr %313, align 8
  store ptr @Array, ptr %156, align 8
  store ptr %result.i168.i2346, ptr %157, align 8
  store ptr %1713, ptr %250, align 8
  store i32 9, ptr %158, align 4
  %1714 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i2360 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1715 = getelementptr i8, ptr %result.i183.i2360, i64 16
  store ptr @_parameterization_Nil, ptr %1715, align 8
  %result.i184.i2361 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1716 = getelementptr i8, ptr %result.i184.i2361, i64 16
  store ptr %1694, ptr %1716, align 8
  %1717 = getelementptr i8, ptr %result.i184.i2361, i64 8
  store ptr %1695, ptr %1717, align 8
  %1718 = getelementptr i8, ptr %result.i184.i2361, i64 24
  store ptr null, ptr %1718, align 8
  %1719 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i2361)
  store ptr @Entry, ptr %result.i184.i2361, align 8
  %1720 = getelementptr i8, ptr %result.i183.i2360, i64 8
  store ptr %result.i184.i2361, ptr %1720, align 8
  %1721 = getelementptr i8, ptr %result.i183.i2360, i64 24
  store ptr null, ptr %1721, align 8
  %1722 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i2360)
  store ptr @union_typ, ptr %result.i183.i2360, align 8
  %result.i185.i2362 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i2360, ptr %result.i185.i2362, align 8
  %1723 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i2362)
  store ptr @Array, ptr %8, align 8
  store ptr %result.i185.i2362, ptr %314, align 8
  store i32 9, ptr %315, align 8
  %1724 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %8)
  %1725 = getelementptr i8, ptr %result.i185.i2362, i64 16
  store i32 %1696, ptr %1725, align 4
  %1726 = getelementptr i8, ptr %result.i185.i2362, i64 20
  store i32 %1696, ptr %1726, align 4
  %result.i.i430.i2363 = call noalias ptr @bump_malloc_inner(i64 noundef %1710, ptr nonnull @current_ptr) #29
  %1727 = getelementptr i8, ptr %result.i185.i2362, i64 8
  store ptr %result.i.i430.i2363, ptr %1727, align 8
  %1728 = load ptr, ptr %316, align 8
  store ptr @Array, ptr %169, align 8
  store ptr %result.i185.i2362, ptr %170, align 8
  store ptr %1728, ptr %251, align 8
  store i32 9, ptr %171, align 4
  store i32 0, ptr %252, align 4
  %1729 = icmp sgt i32 %.reg2mem91.0.lcssa.i2343, 0
  br i1 %1729, label %.lr.ph400.i2376, label %HashMap_resize_.exit2449

.lr.ph400.i2376:                                  ; preds = %._crit_edge395.i2342
  %1730 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1731 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1732 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i2378

._crit_edge2.i2378:                               ; preds = %._crit_edge2.i2378, %.lr.ph400.i2376
  %.reg2mem77.0398.i2379 = phi i32 [ 0, %.lr.ph400.i2376 ], [ %1746, %._crit_edge2.i2378 ]
  %1733 = zext nneg i32 %.reg2mem77.0398.i2379 to i64
  %1734 = shl nuw nsw i64 %1733, 5
  %1735 = getelementptr i8, ptr %result.i.i.i2328, i64 %1734
  %1736 = load ptr, ptr %1735, align 8
  %1737 = getelementptr i8, ptr %1735, i64 8
  %1738 = load i160, ptr %1737, align 4
  %.sroa.3362.8.extract.trunc.i2382 = trunc i160 %1738 to i64
  %1739 = inttoptr i64 %.sroa.3362.8.extract.trunc.i2382 to ptr
  %.sroa.5363.8.extract.shift.i2383 = lshr i160 %1738, 64
  %.sroa.5363.8.extract.trunc.i2384 = trunc i160 %.sroa.5363.8.extract.shift.i2383 to i64
  %1740 = inttoptr i64 %.sroa.5363.8.extract.trunc.i2384 to ptr
  %hash_coef_ptr.i.i201.i2385 = getelementptr i8, ptr %1736, i64 8
  %tbl_size_ptr.i.i202.i2386 = getelementptr i8, ptr %1736, i64 16
  %offset_tbl_ptr.i.i203.i2387 = getelementptr i8, ptr %1736, i64 40
  %hash_coef.i.i232.i2388 = load i64, ptr %hash_coef_ptr.i.i201.i2385, align 4
  %tbl_size.i.i233.i2389 = load i64, ptr %tbl_size_ptr.i.i202.i2386, align 4
  %offset_tbl.i.i234.i2390 = load ptr, ptr %offset_tbl_ptr.i.i203.i2387, align 8
  %product.i.i.i235.i2391 = mul i64 %hash_coef.i.i232.i2388, 4015701072841558310
  %shifted.i.i.i236.i2392 = lshr i64 %product.i.i.i235.i2391, 32
  %xored.i.i.i237.i2393 = xor i64 %shifted.i.i.i236.i2392, %product.i.i.i235.i2391
  %hash.i.i.i238.i2394 = and i64 %xored.i.i.i237.i2393, %tbl_size.i.i233.i2389
  %offset_ptr.i.i239.i2395 = getelementptr i32, ptr %offset_tbl.i.i234.i2390, i64 %hash.i.i.i238.i2394
  %offset.i.i240.i2396 = load i32, ptr %offset_ptr.i.i239.i2395, align 4
  %1741 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1736, 0
  %1742 = insertvalue { ptr, ptr, ptr, i32 } %1741, ptr %1739, 1
  %1743 = insertvalue { ptr, ptr, ptr, i32 } %1742, ptr %1740, 2
  %1744 = insertvalue { ptr, ptr, ptr, i32 } %1743, i32 %offset.i.i240.i2396, 3
  %1745 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %293, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1744)
  %1746 = add nuw nsw i32 %.reg2mem77.0398.i2379, 1
  %1747 = icmp slt i32 %1746, %.reg2mem91.0.lcssa.i2343
  br i1 %1747, label %._crit_edge2.i2378, label %HashMap_resize_.exit2449

HashMap_resize_.exit2449:                         ; preds = %._crit_edge2.i2378, %._crit_edge395.i2342
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %8)
  br label %HashMap_insert_keyK_valueV.exit705

HashMap_insert_keyK_valueV.exit705:               ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2278.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2553, %560, %756, %HashMap_resize_.exit2449
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %109)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %111)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %113)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %114)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %115)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %116)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %117)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %118)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %119)
  %1748 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1749 = load ptr, ptr %178, align 8
  %1750 = sext i32 %.reg2mem130.0237 to i64
  %1751 = shl nsw i64 %1750, 5
  %1752 = getelementptr i8, ptr %1749, i64 %1751
  store ptr @i32_typ, ptr %1752, align 8
  %1753 = getelementptr i8, ptr %1752, i64 8
  store i160 %.sroa.065.0.insert.ext, ptr %1753, align 4
  store i1 true, ptr %.sroa.042.sroa.0, align 8
  %.sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.0. = load i8, ptr %.sroa.042.sroa.0, align 8
  %.sroa.042.0.insert.ext = zext i8 %.sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.sroa.0.0..sroa.042.0. to i160
  %1754 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.042.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %120)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %121)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %122)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %123)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %124)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %125)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %126)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %127)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %128)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %129)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %130)
  %1755 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1756 = load ptr, ptr %184, align 8
  %1757 = call i32 %1756({ ptr, i160 } %323)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1758 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1759 = load ptr, ptr %196, align 8
  %1760 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1759, 0
  %1761 = load ptr, ptr %197, align 8
  %1762 = insertvalue { ptr, ptr, ptr, i32 } %1760, ptr %1761, 1
  %1763 = load ptr, ptr %198, align 8
  %1764 = insertvalue { ptr, ptr, ptr, i32 } %1762, ptr %1763, 2
  %1765 = load i32, ptr %199, align 4
  %1766 = insertvalue { ptr, ptr, ptr, i32 } %1764, i32 %1765, 3
  %hash_coef_ptr.i.i10.i906 = getelementptr i8, ptr %1759, i64 8
  %tbl_size_ptr.i.i11.i907 = getelementptr i8, ptr %1759, i64 16
  %offset_tbl_ptr.i.i12.i908 = getelementptr i8, ptr %1759, i64 40
  %hash_coef.i.i13.i909 = load i64, ptr %hash_coef_ptr.i.i10.i906, align 4
  %tbl_size.i.i14.i910 = load i64, ptr %tbl_size_ptr.i.i11.i907, align 4
  %offset_tbl.i.i15.i911 = load ptr, ptr %offset_tbl_ptr.i.i12.i908, align 8
  %product.i.i.i16.i912 = mul i64 %hash_coef.i.i13.i909, -5261542750394134544
  %shifted.i.i.i17.i913 = lshr i64 %product.i.i.i16.i912, 32
  %xored.i.i.i18.i914 = xor i64 %shifted.i.i.i17.i913, %product.i.i.i16.i912
  %hash.i.i.i19.i915 = and i64 %xored.i.i.i18.i914, %tbl_size.i.i14.i910
  %offset_ptr.i.i20.i916 = getelementptr i32, ptr %offset_tbl.i.i15.i911, i64 %hash.i.i.i19.i915
  %offset.i.i21.i917 = load i32, ptr %offset_ptr.i.i20.i916, align 4
  %eq.i.i918 = icmp eq i32 %1765, %offset.i.i21.i917
  call void @llvm.assume(i1 %eq.i.i918) #30
  %1767 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1768 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1759)
  %1769 = sext i32 %1765 to i64
  %1770 = getelementptr ptr, ptr %1759, i64 %1769
  %1771 = getelementptr i8, ptr %1770, i64 64
  %1772 = load ptr, ptr %1771, align 8
  %1773 = call ptr %1772({ ptr, ptr, ptr, i32 } %1766, ptr nonnull %2)
  %1774 = call i32 %1773({ ptr, ptr, ptr, i32 } %1766, { ptr, ptr, ptr, i32 } %1766, ptr nonnull %2)
  %1775 = add i32 %1774, -1
  %1776 = and i32 %1775, %1757
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1777 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1778 = load ptr, ptr %196, align 8
  %1779 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1778, 0
  %1780 = load ptr, ptr %197, align 8
  %1781 = insertvalue { ptr, ptr, ptr, i32 } %1779, ptr %1780, 1
  %1782 = load ptr, ptr %198, align 8
  %1783 = insertvalue { ptr, ptr, ptr, i32 } %1781, ptr %1782, 2
  %1784 = load i32, ptr %199, align 4
  %1785 = insertvalue { ptr, ptr, ptr, i32 } %1783, i32 %1784, 3
  %hash_coef_ptr.i.i162.i = getelementptr i8, ptr %1778, i64 8
  %tbl_size_ptr.i.i163.i = getelementptr i8, ptr %1778, i64 16
  %offset_tbl_ptr.i.i164.i = getelementptr i8, ptr %1778, i64 40
  %hash_coef.i.i165.i = load i64, ptr %hash_coef_ptr.i.i162.i, align 4
  %tbl_size.i.i166.i = load i64, ptr %tbl_size_ptr.i.i163.i, align 4
  %offset_tbl.i.i167.i = load ptr, ptr %offset_tbl_ptr.i.i164.i, align 8
  %product.i.i.i168.i = mul i64 %hash_coef.i.i165.i, -5261542750394134544
  %shifted.i.i.i169.i = lshr i64 %product.i.i.i168.i, 32
  %xored.i.i.i170.i = xor i64 %shifted.i.i.i169.i, %product.i.i.i168.i
  %hash.i.i.i171.i = and i64 %xored.i.i.i170.i, %tbl_size.i.i166.i
  %offset_ptr.i.i172.i = getelementptr i32, ptr %offset_tbl.i.i167.i, i64 %hash.i.i.i171.i
  %offset.i.i173.i = load i32, ptr %offset_ptr.i.i172.i, align 4
  %eq.i.i438 = icmp eq i32 %1784, %offset.i.i173.i
  call void @llvm.assume(i1 %eq.i.i438) #30
  store ptr @_parameterization_Ptri32, ptr %129, align 8
  %1786 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %129)
  %1787 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1778)
  %1788 = sext i32 %1784 to i64
  %1789 = getelementptr ptr, ptr %1778, i64 %1788
  %1790 = getelementptr i8, ptr %1789, i64 120
  %1791 = load ptr, ptr %1790, align 8
  store ptr @i32_typ, ptr %130, align 8
  %1792 = call ptr %1791({ ptr, ptr, ptr, i32 } %1785, ptr nonnull %130)
  %1793 = call { ptr, i160 } %1792({ ptr, ptr, ptr, i32 } %1785, { ptr, ptr, ptr, i32 } %1785, ptr nonnull %129, i32 %1776)
  %.fca.0.extract.i439 = extractvalue { ptr, i160 } %1793, 0
  %1794 = icmp ne ptr %.fca.0.extract.i439, @nil_typ
  %1795 = icmp ne ptr %.fca.0.extract.i439, null
  %.not149.i = and i1 %1794, %1795
  br i1 %.not149.i, label %1796, label %.critedge.i440

1796:                                             ; preds = %HashMap_insert_keyK_valueV.exit705
  %.fca.1.extract.i447 = extractvalue { ptr, i160 } %1793, 1
  %.sroa.4520.8.extract.trunc.i = trunc i160 %.fca.1.extract.i447 to i64
  %1797 = inttoptr i64 %.sroa.4520.8.extract.trunc.i to ptr
  %.sroa.7522.8.extract.shift.i = lshr i160 %.fca.1.extract.i447, 64
  %.sroa.7522.8.extract.trunc.i = trunc i160 %.sroa.7522.8.extract.shift.i to i64
  %1798 = inttoptr i64 %.sroa.7522.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract.i439, i64 8
  %tbl_size_ptr.i.i177.i = getelementptr i8, ptr %.fca.0.extract.i439, i64 16
  %offset_tbl_ptr.i.i178.i = getelementptr i8, ptr %.fca.0.extract.i439, i64 40
  %hash_coef.i.i179.i = load i64, ptr %hash_coef_ptr.i.i176.i, align 4
  %tbl_size.i.i180.i = load i64, ptr %tbl_size_ptr.i.i177.i, align 4
  %offset_tbl.i.i181.i = load ptr, ptr %offset_tbl_ptr.i.i178.i, align 8
  %product.i.i.i182.i = mul i64 %hash_coef.i.i179.i, 4015701072841558310
  %shifted.i.i.i183.i = lshr i64 %product.i.i.i182.i, 32
  %xored.i.i.i184.i = xor i64 %shifted.i.i.i183.i, %product.i.i.i182.i
  %hash.i.i.i185.i = and i64 %xored.i.i.i184.i, %tbl_size.i.i180.i
  %offset_ptr.i.i186.i = getelementptr i32, ptr %offset_tbl.i.i181.i, i64 %hash.i.i.i185.i
  %offset.i.i187.i = load i32, ptr %offset_ptr.i.i186.i, align 4
  %1799 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i439, 0
  %1800 = insertvalue { ptr, ptr, ptr, i32 } %1799, ptr %1797, 1
  %1801 = insertvalue { ptr, ptr, ptr, i32 } %1800, ptr %1798, 2
  %1802 = insertvalue { ptr, ptr, ptr, i32 } %1801, i32 %offset.i.i187.i, 3
  %1803 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1804 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1805 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i439)
  %1806 = sext i32 %offset.i.i187.i to i64
  %1807 = getelementptr ptr, ptr %.fca.0.extract.i439, i64 %1806
  %1808 = getelementptr i8, ptr %1807, i64 64
  %1809 = load ptr, ptr %1808, align 8
  %1810 = call ptr %1809({ ptr, ptr, ptr, i32 } %1802, ptr nonnull %2)
  %1811 = call i32 %1810({ ptr, ptr, ptr, i32 } %1802, { ptr, ptr, ptr, i32 } %1802, ptr nonnull %2)
  %1812 = icmp eq i32 %1811, %1757
  %1813 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1814 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1815 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i439)
  %1816 = getelementptr i8, ptr %1807, i64 48
  %1817 = load ptr, ptr %1816, align 8
  %1818 = call ptr %1817({ ptr, ptr, ptr, i32 } %1802, ptr nonnull %2)
  %1819 = call { ptr, i160 } %1818({ ptr, ptr, ptr, i32 } %1802, { ptr, ptr, ptr, i32 } %1802, ptr nonnull %2)
  %1820 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1821 = load ptr, ptr %185, align 8
  %1822 = call i1 %1821({ ptr, i160 } %1819, { ptr, i160 } %323)
  %1823 = and i1 %1812, %1822
  br i1 %1823, label %1824, label %.critedge.i440

1824:                                             ; preds = %1796
  %1825 = load ptr, ptr %result.i105, align 8
  %1826 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1827 = load ptr, ptr %179, align 8
  %1828 = load ptr, ptr %1825, align 8
  %1829 = getelementptr i8, ptr %1828, i64 48
  %1830 = load ptr, ptr %1829, align 8
  %1831 = call { i64, i64 } %1830(ptr nonnull %1825)
  %1832 = extractvalue { i64, i64 } %1831, 0
  %1833 = extractvalue { i64, i64 } %1831, 1
  %1834 = urem i64 20, %1833
  %1835 = icmp eq i64 %1834, 0
  %1836 = sub i64 %1833, %1834
  %1837 = select i1 %1835, i64 0, i64 %1836
  %1838 = add i64 %1832, 20
  %1839 = add i64 %1838, %1837
  %1840 = load ptr, ptr %1827, align 8
  %1841 = getelementptr i8, ptr %1840, i64 48
  %1842 = load ptr, ptr %1841, align 8
  %1843 = call { i64, i64 } %1842(ptr nonnull %1827)
  %1844 = extractvalue { i64, i64 } %1843, 0
  %1845 = extractvalue { i64, i64 } %1843, 1
  %1846 = call i64 @llvm.umax.i64(i64 %1833, i64 %1845)
  %1847 = call i64 @llvm.umax.i64(i64 %1846, i64 8)
  %1848 = urem i64 %1839, %1845
  %1849 = icmp eq i64 %1848, 0
  %1850 = sub i64 %1845, %1848
  %1851 = select i1 %1849, i64 0, i64 %1850
  %1852 = add i64 %1844, %1839
  %1853 = add i64 %1852, %1851
  %1854 = urem i64 %1853, %1847
  %1855 = icmp eq i64 %1854, 0
  %1856 = sub i64 %1847, %1854
  %1857 = select i1 %1855, i64 0, i64 %1856
  %1858 = add i64 %1857, %1853
  %result.i.i448 = call noalias ptr @bump_malloc_inner(i64 noundef %1858, ptr nonnull @current_ptr) #29
  store ptr %1825, ptr %result.i.i448, align 8
  %1859 = getelementptr i8, ptr %result.i.i448, i64 8
  store ptr %1827, ptr %1859, align 8
  %1860 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i448)
  store ptr @Entry, ptr %120, align 8
  store ptr %result.i.i448, ptr %232, align 8
  store i32 9, ptr %233, align 8
  %1861 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %120)
  %1862 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1863 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1864 = load ptr, ptr %1825, align 8
  %1865 = getelementptr i8, ptr %1864, i64 48
  %1866 = load ptr, ptr %1865, align 8
  %1867 = call { i64, i64 } %1866(ptr nonnull %1825)
  %1868 = extractvalue { i64, i64 } %1867, 1
  %1869 = urem i64 20, %1868
  %1870 = icmp eq i64 %1869, 0
  %reass.sub3308 = sub i64 %1868, %1869
  %1871 = add i64 %reass.sub3308, 20
  %1872 = select i1 %1870, i64 20, i64 %1871
  %1873 = getelementptr i8, ptr %result.i.i448, i64 %1872
  %1874 = load ptr, ptr %result.i.i448, align 8
  %1875 = load ptr, ptr %1874, align 8
  %1876 = getelementptr i8, ptr %1875, i64 64
  %1877 = load ptr, ptr %1876, align 8
  call void %1877({ ptr, i160 } %323, ptr nonnull %1874, ptr %1873)
  %1878 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1879 = load ptr, ptr %result.i.i448, align 8
  %1880 = load ptr, ptr %1879, align 8
  %1881 = getelementptr i8, ptr %1880, i64 48
  %1882 = load ptr, ptr %1881, align 8
  %1883 = call { i64, i64 } %1882(ptr nonnull %1879)
  %1884 = extractvalue { i64, i64 } %1883, 0
  %1885 = extractvalue { i64, i64 } %1883, 1
  %1886 = urem i64 20, %1885
  %1887 = icmp eq i64 %1886, 0
  %1888 = sub i64 %1885, %1886
  %1889 = select i1 %1887, i64 0, i64 %1888
  %1890 = add i64 %1884, 20
  %1891 = add i64 %1890, %1889
  %1892 = load ptr, ptr %1859, align 8
  %1893 = load ptr, ptr %1892, align 8
  %1894 = getelementptr i8, ptr %1893, i64 48
  %1895 = load ptr, ptr %1894, align 8
  %1896 = call { i64, i64 } %1895(ptr nonnull %1892)
  %1897 = extractvalue { i64, i64 } %1896, 1
  %1898 = urem i64 %1891, %1897
  %1899 = icmp eq i64 %1898, 0
  %1900 = sub i64 %1897, %1898
  %1901 = select i1 %1899, i64 0, i64 %1900
  %1902 = getelementptr i8, ptr %result.i.i448, i64 %1891
  %1903 = getelementptr i8, ptr %1902, i64 %1901
  %1904 = load ptr, ptr %1859, align 8
  %1905 = load ptr, ptr %1904, align 8
  %1906 = getelementptr i8, ptr %1905, i64 64
  %1907 = load ptr, ptr %1906, align 8
  call void %1907({ ptr, i160 } %1754, ptr nonnull %1904, ptr %1903)
  %1908 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1909 = getelementptr i8, ptr %result.i.i448, i64 16
  store i32 %1757, ptr %1909, align 4
  %1910 = load ptr, ptr %234, align 8
  %1911 = ptrtoint ptr %result.i.i448 to i64
  %1912 = ptrtoint ptr %1910 to i64
  %.sroa.2127.0.insert.ext.i = zext i64 %1912 to i160
  %.sroa.2127.0.insert.shift.i = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i, 64
  %.sroa.0126.0.insert.ext.i = zext i64 %1911 to i160
  %.sroa.2127.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.shift.i, %.sroa.0126.0.insert.ext.i
  %.sroa.0126.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.insert.i, 3062541302288446171170371466885913903104
  %1913 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i, 1
  %1914 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1915 = load ptr, ptr %196, align 8
  %1916 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1915, 0
  %1917 = load ptr, ptr %197, align 8
  %1918 = insertvalue { ptr, ptr, ptr, i32 } %1916, ptr %1917, 1
  %1919 = load ptr, ptr %198, align 8
  %1920 = insertvalue { ptr, ptr, ptr, i32 } %1918, ptr %1919, 2
  %1921 = load i32, ptr %199, align 4
  %1922 = insertvalue { ptr, ptr, ptr, i32 } %1920, i32 %1921, 3
  %hash_coef_ptr.i.i204.i = getelementptr i8, ptr %1915, i64 8
  %tbl_size_ptr.i.i205.i = getelementptr i8, ptr %1915, i64 16
  %offset_tbl_ptr.i.i206.i = getelementptr i8, ptr %1915, i64 40
  %hash_coef.i.i207.i = load i64, ptr %hash_coef_ptr.i.i204.i, align 4
  %tbl_size.i.i208.i = load i64, ptr %tbl_size_ptr.i.i205.i, align 4
  %offset_tbl.i.i209.i = load ptr, ptr %offset_tbl_ptr.i.i206.i, align 8
  %product.i.i.i210.i = mul i64 %hash_coef.i.i207.i, -5261542750394134544
  %shifted.i.i.i211.i = lshr i64 %product.i.i.i210.i, 32
  %xored.i.i.i212.i = xor i64 %shifted.i.i.i211.i, %product.i.i.i210.i
  %hash.i.i.i213.i = and i64 %xored.i.i.i212.i, %tbl_size.i.i208.i
  %offset_ptr.i.i214.i = getelementptr i32, ptr %offset_tbl.i.i209.i, i64 %hash.i.i.i213.i
  %offset.i.i215.i = load i32, ptr %offset_ptr.i.i214.i, align 4
  %eq.i218.i = icmp eq i32 %1921, %offset.i.i215.i
  call void @llvm.assume(i1 %eq.i218.i) #30
  %1923 = load ptr, ptr %result.i105, align 8
  %1924 = load ptr, ptr %179, align 8
  %result.i219.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1925 = getelementptr i8, ptr %result.i219.i, i64 16
  store ptr %1924, ptr %1925, align 8
  %1926 = getelementptr i8, ptr %result.i219.i, i64 8
  store ptr %1923, ptr %1926, align 8
  %1927 = getelementptr i8, ptr %result.i219.i, i64 24
  store ptr null, ptr %1927, align 8
  %1928 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i)
  store ptr @Entry, ptr %result.i219.i, align 8
  store ptr @_parameterization_Ptri32, ptr %121, align 8
  store ptr %result.i219.i, ptr %235, align 8
  %1929 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %121)
  %1930 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1915)
  %1931 = sext i32 %1921 to i64
  %1932 = getelementptr ptr, ptr %1915, i64 %1931
  %1933 = getelementptr i8, ptr %1932, i64 128
  %1934 = load ptr, ptr %1933, align 8
  store ptr @i32_typ, ptr %122, align 8
  store ptr @Entry, ptr %236, align 8
  %1935 = call ptr %1934({ ptr, ptr, ptr, i32 } %1922, ptr nonnull %122)
  call void %1935({ ptr, ptr, ptr, i32 } %1922, { ptr, ptr, ptr, i32 } %1922, ptr nonnull %121, i32 %1776, { ptr, i160 } %1913)
  br label %HashMap_insert_keyK_valueV.exit

.critedge.i440:                                   ; preds = %1796, %HashMap_insert_keyK_valueV.exit705
  %1936 = add i32 %1757, 2127912214
  %1937 = shl i32 %1757, 12
  %1938 = add i32 %1936, %1937
  %1939 = ashr i32 %1938, 19
  %1940 = xor i32 %1938, %1939
  %1941 = xor i32 %1940, -949894596
  %1942 = add i32 %1941, 374761393
  %1943 = shl i32 %1941, 5
  %1944 = add i32 %1942, %1943
  %1945 = add i32 %1944, -744332180
  %1946 = shl i32 %1944, 9
  %1947 = xor i32 %1945, %1946
  %1948 = add i32 %1947, -42973499
  %1949 = shl i32 %1947, 3
  %1950 = add i32 %1948, %1949
  %1951 = ashr i32 %1950, 16
  %1952 = xor i32 %1950, %1951
  %1953 = xor i32 %1952, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1954 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1955 = load ptr, ptr %213, align 8
  %1956 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1955, 0
  %1957 = load ptr, ptr %214, align 8
  %1958 = insertvalue { ptr, ptr, ptr, i32 } %1956, ptr %1957, 1
  %1959 = load ptr, ptr %215, align 8
  %1960 = insertvalue { ptr, ptr, ptr, i32 } %1958, ptr %1959, 2
  %1961 = load i32, ptr %216, align 4
  %1962 = insertvalue { ptr, ptr, ptr, i32 } %1960, i32 %1961, 3
  %hash_coef_ptr.i.i10.i936 = getelementptr i8, ptr %1955, i64 8
  %tbl_size_ptr.i.i11.i937 = getelementptr i8, ptr %1955, i64 16
  %offset_tbl_ptr.i.i12.i938 = getelementptr i8, ptr %1955, i64 40
  %hash_coef.i.i13.i939 = load i64, ptr %hash_coef_ptr.i.i10.i936, align 4
  %tbl_size.i.i14.i940 = load i64, ptr %tbl_size_ptr.i.i11.i937, align 4
  %offset_tbl.i.i15.i941 = load ptr, ptr %offset_tbl_ptr.i.i12.i938, align 8
  %product.i.i.i16.i942 = mul i64 %hash_coef.i.i13.i939, -5261542750394134544
  %shifted.i.i.i17.i943 = lshr i64 %product.i.i.i16.i942, 32
  %xored.i.i.i18.i944 = xor i64 %shifted.i.i.i17.i943, %product.i.i.i16.i942
  %hash.i.i.i19.i945 = and i64 %xored.i.i.i18.i944, %tbl_size.i.i14.i940
  %offset_ptr.i.i20.i946 = getelementptr i32, ptr %offset_tbl.i.i15.i941, i64 %hash.i.i.i19.i945
  %offset.i.i21.i947 = load i32, ptr %offset_ptr.i.i20.i946, align 4
  %eq.i.i948 = icmp eq i32 %1961, %offset.i.i21.i947
  call void @llvm.assume(i1 %eq.i.i948) #30
  %1963 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1964 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1955)
  %1965 = sext i32 %1961 to i64
  %1966 = getelementptr ptr, ptr %1955, i64 %1965
  %1967 = getelementptr i8, ptr %1966, i64 64
  %1968 = load ptr, ptr %1967, align 8
  %1969 = call ptr %1968({ ptr, ptr, ptr, i32 } %1962, ptr nonnull %2)
  %1970 = call i32 %1969({ ptr, ptr, ptr, i32 } %1962, { ptr, ptr, ptr, i32 } %1962, ptr nonnull %2)
  %1971 = add i32 %1970, -1
  %1972 = and i32 %1971, %1953
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1973 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1974 = load ptr, ptr %213, align 8
  %1975 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1974, 0
  %1976 = load ptr, ptr %214, align 8
  %1977 = insertvalue { ptr, ptr, ptr, i32 } %1975, ptr %1976, 1
  %1978 = load ptr, ptr %215, align 8
  %1979 = insertvalue { ptr, ptr, ptr, i32 } %1977, ptr %1978, 2
  %1980 = load i32, ptr %216, align 4
  %1981 = insertvalue { ptr, ptr, ptr, i32 } %1979, i32 %1980, 3
  %hash_coef_ptr.i.i221.i = getelementptr i8, ptr %1974, i64 8
  %tbl_size_ptr.i.i222.i = getelementptr i8, ptr %1974, i64 16
  %offset_tbl_ptr.i.i223.i = getelementptr i8, ptr %1974, i64 40
  %hash_coef.i.i224.i = load i64, ptr %hash_coef_ptr.i.i221.i, align 4
  %tbl_size.i.i225.i = load i64, ptr %tbl_size_ptr.i.i222.i, align 4
  %offset_tbl.i.i226.i = load ptr, ptr %offset_tbl_ptr.i.i223.i, align 8
  %product.i.i.i227.i = mul i64 %hash_coef.i.i224.i, -5261542750394134544
  %shifted.i.i.i228.i = lshr i64 %product.i.i.i227.i, 32
  %xored.i.i.i229.i = xor i64 %shifted.i.i.i228.i, %product.i.i.i227.i
  %hash.i.i.i230.i = and i64 %xored.i.i.i229.i, %tbl_size.i.i225.i
  %offset_ptr.i.i231.i = getelementptr i32, ptr %offset_tbl.i.i226.i, i64 %hash.i.i.i230.i
  %offset.i.i232.i = load i32, ptr %offset_ptr.i.i231.i, align 4
  %eq.i235.i = icmp eq i32 %1980, %offset.i.i232.i
  call void @llvm.assume(i1 %eq.i235.i) #30
  store ptr @_parameterization_Ptri32, ptr %123, align 8
  %1982 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %123)
  %1983 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1974)
  %1984 = sext i32 %1980 to i64
  %1985 = getelementptr ptr, ptr %1974, i64 %1984
  %1986 = getelementptr i8, ptr %1985, i64 120
  %1987 = load ptr, ptr %1986, align 8
  store ptr @i32_typ, ptr %124, align 8
  %1988 = call ptr %1987({ ptr, ptr, ptr, i32 } %1981, ptr nonnull %124)
  %1989 = call { ptr, i160 } %1988({ ptr, ptr, ptr, i32 } %1981, { ptr, ptr, ptr, i32 } %1981, ptr nonnull %123, i32 %1972)
  %.fca.0.extract102.i = extractvalue { ptr, i160 } %1989, 0
  %1990 = icmp ne ptr %.fca.0.extract102.i, @nil_typ
  %1991 = icmp ne ptr %.fca.0.extract102.i, null
  %.not151.i = and i1 %1990, %1991
  br i1 %.not151.i, label %1992, label %.critedge158.i

1992:                                             ; preds = %.critedge.i440
  %.fca.1.extract104.i = extractvalue { ptr, i160 } %1989, 1
  %.sroa.4.8.extract.trunc.i = trunc i160 %.fca.1.extract104.i to i64
  %1993 = inttoptr i64 %.sroa.4.8.extract.trunc.i to ptr
  %.sroa.7508.8.extract.shift.i = lshr i160 %.fca.1.extract104.i, 64
  %.sroa.7508.8.extract.trunc.i = trunc i160 %.sroa.7508.8.extract.shift.i to i64
  %1994 = inttoptr i64 %.sroa.7508.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i237.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 8
  %tbl_size_ptr.i.i238.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 16
  %offset_tbl_ptr.i.i239.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 40
  %hash_coef.i.i240.i = load i64, ptr %hash_coef_ptr.i.i237.i, align 4
  %tbl_size.i.i241.i = load i64, ptr %tbl_size_ptr.i.i238.i, align 4
  %offset_tbl.i.i242.i = load ptr, ptr %offset_tbl_ptr.i.i239.i, align 8
  %product.i.i.i243.i = mul i64 %hash_coef.i.i240.i, 4015701072841558310
  %shifted.i.i.i244.i = lshr i64 %product.i.i.i243.i, 32
  %xored.i.i.i245.i = xor i64 %shifted.i.i.i244.i, %product.i.i.i243.i
  %hash.i.i.i246.i = and i64 %xored.i.i.i245.i, %tbl_size.i.i241.i
  %offset_ptr.i.i247.i = getelementptr i32, ptr %offset_tbl.i.i242.i, i64 %hash.i.i.i246.i
  %offset.i.i248.i = load i32, ptr %offset_ptr.i.i247.i, align 4
  %1995 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i, 0
  %1996 = insertvalue { ptr, ptr, ptr, i32 } %1995, ptr %1993, 1
  %1997 = insertvalue { ptr, ptr, ptr, i32 } %1996, ptr %1994, 2
  %1998 = insertvalue { ptr, ptr, ptr, i32 } %1997, i32 %offset.i.i248.i, 3
  %1999 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2000 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2001 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %2002 = sext i32 %offset.i.i248.i to i64
  %2003 = getelementptr ptr, ptr %.fca.0.extract102.i, i64 %2002
  %2004 = getelementptr i8, ptr %2003, i64 64
  %2005 = load ptr, ptr %2004, align 8
  %2006 = call ptr %2005({ ptr, ptr, ptr, i32 } %1998, ptr nonnull %2)
  %2007 = call i32 %2006({ ptr, ptr, ptr, i32 } %1998, { ptr, ptr, ptr, i32 } %1998, ptr nonnull %2)
  %2008 = icmp eq i32 %2007, %1757
  %2009 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2010 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2011 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %2012 = getelementptr i8, ptr %2003, i64 48
  %2013 = load ptr, ptr %2012, align 8
  %2014 = call ptr %2013({ ptr, ptr, ptr, i32 } %1998, ptr nonnull %2)
  %2015 = call { ptr, i160 } %2014({ ptr, ptr, ptr, i32 } %1998, { ptr, ptr, ptr, i32 } %1998, ptr nonnull %2)
  %2016 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2017 = load ptr, ptr %185, align 8
  %2018 = call i1 %2017({ ptr, i160 } %2015, { ptr, i160 } %323)
  %2019 = and i1 %2008, %2018
  br i1 %2019, label %2020, label %.critedge158.i

2020:                                             ; preds = %1992
  %2021 = load ptr, ptr %result.i105, align 8
  %2022 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2023 = load ptr, ptr %179, align 8
  %2024 = load ptr, ptr %2021, align 8
  %2025 = getelementptr i8, ptr %2024, i64 48
  %2026 = load ptr, ptr %2025, align 8
  %2027 = call { i64, i64 } %2026(ptr nonnull %2021)
  %2028 = extractvalue { i64, i64 } %2027, 0
  %2029 = extractvalue { i64, i64 } %2027, 1
  %2030 = urem i64 20, %2029
  %2031 = icmp eq i64 %2030, 0
  %2032 = sub i64 %2029, %2030
  %2033 = select i1 %2031, i64 0, i64 %2032
  %2034 = add i64 %2028, 20
  %2035 = add i64 %2034, %2033
  %2036 = load ptr, ptr %2023, align 8
  %2037 = getelementptr i8, ptr %2036, i64 48
  %2038 = load ptr, ptr %2037, align 8
  %2039 = call { i64, i64 } %2038(ptr nonnull %2023)
  %2040 = extractvalue { i64, i64 } %2039, 0
  %2041 = extractvalue { i64, i64 } %2039, 1
  %2042 = call i64 @llvm.umax.i64(i64 %2029, i64 %2041)
  %2043 = call i64 @llvm.umax.i64(i64 %2042, i64 8)
  %2044 = urem i64 %2035, %2041
  %2045 = icmp eq i64 %2044, 0
  %2046 = sub i64 %2041, %2044
  %2047 = select i1 %2045, i64 0, i64 %2046
  %2048 = add i64 %2040, %2035
  %2049 = add i64 %2048, %2047
  %2050 = urem i64 %2049, %2043
  %2051 = icmp eq i64 %2050, 0
  %2052 = sub i64 %2043, %2050
  %2053 = select i1 %2051, i64 0, i64 %2052
  %2054 = add i64 %2053, %2049
  %result.i250.i = call noalias ptr @bump_malloc_inner(i64 noundef %2054, ptr nonnull @current_ptr) #29
  store ptr %2021, ptr %result.i250.i, align 8
  %2055 = getelementptr i8, ptr %result.i250.i, i64 8
  store ptr %2023, ptr %2055, align 8
  %2056 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i)
  store ptr @Entry, ptr %125, align 8
  store ptr %result.i250.i, ptr %227, align 8
  store i32 9, ptr %228, align 8
  %2057 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %125)
  %2058 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2059 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2060 = load ptr, ptr %2021, align 8
  %2061 = getelementptr i8, ptr %2060, i64 48
  %2062 = load ptr, ptr %2061, align 8
  %2063 = call { i64, i64 } %2062(ptr nonnull %2021)
  %2064 = extractvalue { i64, i64 } %2063, 1
  %2065 = urem i64 20, %2064
  %2066 = icmp eq i64 %2065, 0
  %reass.sub3307 = sub i64 %2064, %2065
  %2067 = add i64 %reass.sub3307, 20
  %2068 = select i1 %2066, i64 20, i64 %2067
  %2069 = getelementptr i8, ptr %result.i250.i, i64 %2068
  %2070 = load ptr, ptr %result.i250.i, align 8
  %2071 = load ptr, ptr %2070, align 8
  %2072 = getelementptr i8, ptr %2071, i64 64
  %2073 = load ptr, ptr %2072, align 8
  call void %2073({ ptr, i160 } %323, ptr nonnull %2070, ptr %2069)
  %2074 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2075 = load ptr, ptr %result.i250.i, align 8
  %2076 = load ptr, ptr %2075, align 8
  %2077 = getelementptr i8, ptr %2076, i64 48
  %2078 = load ptr, ptr %2077, align 8
  %2079 = call { i64, i64 } %2078(ptr nonnull %2075)
  %2080 = extractvalue { i64, i64 } %2079, 0
  %2081 = extractvalue { i64, i64 } %2079, 1
  %2082 = urem i64 20, %2081
  %2083 = icmp eq i64 %2082, 0
  %2084 = sub i64 %2081, %2082
  %2085 = select i1 %2083, i64 0, i64 %2084
  %2086 = add i64 %2080, 20
  %2087 = add i64 %2086, %2085
  %2088 = load ptr, ptr %2055, align 8
  %2089 = load ptr, ptr %2088, align 8
  %2090 = getelementptr i8, ptr %2089, i64 48
  %2091 = load ptr, ptr %2090, align 8
  %2092 = call { i64, i64 } %2091(ptr nonnull %2088)
  %2093 = extractvalue { i64, i64 } %2092, 1
  %2094 = urem i64 %2087, %2093
  %2095 = icmp eq i64 %2094, 0
  %2096 = sub i64 %2093, %2094
  %2097 = select i1 %2095, i64 0, i64 %2096
  %2098 = getelementptr i8, ptr %result.i250.i, i64 %2087
  %2099 = getelementptr i8, ptr %2098, i64 %2097
  %2100 = load ptr, ptr %2055, align 8
  %2101 = load ptr, ptr %2100, align 8
  %2102 = getelementptr i8, ptr %2101, i64 64
  %2103 = load ptr, ptr %2102, align 8
  call void %2103({ ptr, i160 } %1754, ptr nonnull %2100, ptr %2099)
  %2104 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2105 = getelementptr i8, ptr %result.i250.i, i64 16
  store i32 %1757, ptr %2105, align 4
  %2106 = load ptr, ptr %229, align 8
  %2107 = ptrtoint ptr %result.i250.i to i64
  %2108 = ptrtoint ptr %2106 to i64
  %.sroa.282.0.insert.ext.i = zext i64 %2108 to i160
  %.sroa.282.0.insert.shift.i = shl nuw nsw i160 %.sroa.282.0.insert.ext.i, 64
  %.sroa.081.0.insert.ext.i = zext i64 %2107 to i160
  %.sroa.282.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.shift.i, %.sroa.081.0.insert.ext.i
  %.sroa.081.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.insert.i, 3062541302288446171170371466885913903104
  %2109 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i, 1
  %2110 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2111 = load ptr, ptr %213, align 8
  %2112 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2111, 0
  %2113 = load ptr, ptr %214, align 8
  %2114 = insertvalue { ptr, ptr, ptr, i32 } %2112, ptr %2113, 1
  %2115 = load ptr, ptr %215, align 8
  %2116 = insertvalue { ptr, ptr, ptr, i32 } %2114, ptr %2115, 2
  %2117 = load i32, ptr %216, align 4
  %2118 = insertvalue { ptr, ptr, ptr, i32 } %2116, i32 %2117, 3
  %hash_coef_ptr.i.i266.i = getelementptr i8, ptr %2111, i64 8
  %tbl_size_ptr.i.i267.i = getelementptr i8, ptr %2111, i64 16
  %offset_tbl_ptr.i.i268.i = getelementptr i8, ptr %2111, i64 40
  %hash_coef.i.i269.i = load i64, ptr %hash_coef_ptr.i.i266.i, align 4
  %tbl_size.i.i270.i = load i64, ptr %tbl_size_ptr.i.i267.i, align 4
  %offset_tbl.i.i271.i = load ptr, ptr %offset_tbl_ptr.i.i268.i, align 8
  %product.i.i.i272.i = mul i64 %hash_coef.i.i269.i, -5261542750394134544
  %shifted.i.i.i273.i = lshr i64 %product.i.i.i272.i, 32
  %xored.i.i.i274.i = xor i64 %shifted.i.i.i273.i, %product.i.i.i272.i
  %hash.i.i.i275.i = and i64 %xored.i.i.i274.i, %tbl_size.i.i270.i
  %offset_ptr.i.i276.i = getelementptr i32, ptr %offset_tbl.i.i271.i, i64 %hash.i.i.i275.i
  %offset.i.i277.i = load i32, ptr %offset_ptr.i.i276.i, align 4
  %eq.i280.i = icmp eq i32 %2117, %offset.i.i277.i
  call void @llvm.assume(i1 %eq.i280.i) #30
  %2119 = load ptr, ptr %result.i105, align 8
  %2120 = load ptr, ptr %179, align 8
  %result.i281.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2121 = getelementptr i8, ptr %result.i281.i, i64 16
  store ptr %2120, ptr %2121, align 8
  %2122 = getelementptr i8, ptr %result.i281.i, i64 8
  store ptr %2119, ptr %2122, align 8
  %2123 = getelementptr i8, ptr %result.i281.i, i64 24
  store ptr null, ptr %2123, align 8
  %2124 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i)
  store ptr @Entry, ptr %result.i281.i, align 8
  store ptr @_parameterization_Ptri32, ptr %126, align 8
  store ptr %result.i281.i, ptr %230, align 8
  %2125 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %126)
  %2126 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2111)
  %2127 = sext i32 %2117 to i64
  %2128 = getelementptr ptr, ptr %2111, i64 %2127
  %2129 = getelementptr i8, ptr %2128, i64 128
  %2130 = load ptr, ptr %2129, align 8
  store ptr @i32_typ, ptr %127, align 8
  store ptr @Entry, ptr %231, align 8
  %2131 = call ptr %2130({ ptr, ptr, ptr, i32 } %2118, ptr nonnull %127)
  call void %2131({ ptr, ptr, ptr, i32 } %2118, { ptr, ptr, ptr, i32 } %2118, ptr nonnull %126, i32 %1972, { ptr, i160 } %2109)
  br label %HashMap_insert_keyK_valueV.exit

.critedge158.i:                                   ; preds = %1992, %.critedge.i440
  %2132 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2133 = load ptr, ptr %196, align 8
  %2134 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2133, 0
  %2135 = load ptr, ptr %197, align 8
  %2136 = insertvalue { ptr, ptr, ptr, i32 } %2134, ptr %2135, 1
  %2137 = load ptr, ptr %198, align 8
  %2138 = insertvalue { ptr, ptr, ptr, i32 } %2136, ptr %2137, 2
  %2139 = load i32, ptr %199, align 4
  %2140 = insertvalue { ptr, ptr, ptr, i32 } %2138, i32 %2139, 3
  %hash_coef_ptr.i.i283.i = getelementptr i8, ptr %2133, i64 8
  %tbl_size_ptr.i.i284.i = getelementptr i8, ptr %2133, i64 16
  %offset_tbl_ptr.i.i285.i = getelementptr i8, ptr %2133, i64 40
  %hash_coef.i.i286.i = load i64, ptr %hash_coef_ptr.i.i283.i, align 4
  %tbl_size.i.i287.i = load i64, ptr %tbl_size_ptr.i.i284.i, align 4
  %offset_tbl.i.i288.i = load ptr, ptr %offset_tbl_ptr.i.i285.i, align 8
  %product.i.i.i289.i = mul i64 %hash_coef.i.i286.i, -5261542750394134544
  %shifted.i.i.i290.i = lshr i64 %product.i.i.i289.i, 32
  %xored.i.i.i291.i = xor i64 %shifted.i.i.i290.i, %product.i.i.i289.i
  %hash.i.i.i292.i = and i64 %xored.i.i.i291.i, %tbl_size.i.i287.i
  %offset_ptr.i.i293.i = getelementptr i32, ptr %offset_tbl.i.i288.i, i64 %hash.i.i.i292.i
  %offset.i.i294.i = load i32, ptr %offset_ptr.i.i293.i, align 4
  %eq.i297.i = icmp eq i32 %2139, %offset.i.i294.i
  call void @llvm.assume(i1 %eq.i297.i) #30
  %2141 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2142 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2133)
  %2143 = sext i32 %2139 to i64
  %2144 = getelementptr ptr, ptr %2133, i64 %2143
  %2145 = getelementptr i8, ptr %2144, i64 64
  %2146 = load ptr, ptr %2145, align 8
  %2147 = call ptr %2146({ ptr, ptr, ptr, i32 } %2140, ptr nonnull %2)
  %2148 = call i32 %2147({ ptr, ptr, ptr, i32 } %2140, { ptr, ptr, ptr, i32 } %2140, ptr nonnull %2)
  %2149 = load i32, ptr %217, align 4
  %.not.i = icmp slt i32 %2149, %2148
  br i1 %.not.i, label %._crit_edge.i, label %2150

2150:                                             ; preds = %.critedge158.i
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %99)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %100)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %101)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %102)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %103)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %104)
  %2151 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2152 = load ptr, ptr %196, align 8
  %2153 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2152, 0
  %2154 = load ptr, ptr %197, align 8
  %2155 = insertvalue { ptr, ptr, ptr, i32 } %2153, ptr %2154, 1
  %2156 = load ptr, ptr %198, align 8
  %2157 = insertvalue { ptr, ptr, ptr, i32 } %2155, ptr %2156, 2
  %2158 = load i32, ptr %199, align 4
  %2159 = insertvalue { ptr, ptr, ptr, i32 } %2157, i32 %2158, 3
  %hash_coef_ptr.i.i64.i = getelementptr i8, ptr %2152, i64 8
  %tbl_size_ptr.i.i65.i = getelementptr i8, ptr %2152, i64 16
  %offset_tbl_ptr.i.i66.i = getelementptr i8, ptr %2152, i64 40
  %hash_coef.i.i67.i = load i64, ptr %hash_coef_ptr.i.i64.i, align 4
  %tbl_size.i.i68.i = load i64, ptr %tbl_size_ptr.i.i65.i, align 4
  %offset_tbl.i.i69.i = load ptr, ptr %offset_tbl_ptr.i.i66.i, align 8
  %product.i.i.i70.i = mul i64 %hash_coef.i.i67.i, -5261542750394134544
  %shifted.i.i.i71.i = lshr i64 %product.i.i.i70.i, 32
  %xored.i.i.i72.i = xor i64 %shifted.i.i.i71.i, %product.i.i.i70.i
  %hash.i.i.i73.i = and i64 %xored.i.i.i72.i, %tbl_size.i.i68.i
  %offset_ptr.i.i74.i = getelementptr i32, ptr %offset_tbl.i.i69.i, i64 %hash.i.i.i73.i
  %offset.i.i75.i = load i32, ptr %offset_ptr.i.i74.i, align 4
  %eq.i.i962 = icmp eq i32 %2158, %offset.i.i75.i
  call void @llvm.assume(i1 %eq.i.i962) #30
  %2160 = load ptr, ptr %213, align 8
  %2161 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2160, 0
  %2162 = load ptr, ptr %214, align 8
  %2163 = insertvalue { ptr, ptr, ptr, i32 } %2161, ptr %2162, 1
  %2164 = load ptr, ptr %215, align 8
  %2165 = insertvalue { ptr, ptr, ptr, i32 } %2163, ptr %2164, 2
  %2166 = load i32, ptr %216, align 4
  %2167 = insertvalue { ptr, ptr, ptr, i32 } %2165, i32 %2166, 3
  %hash_coef_ptr.i.i92.i = getelementptr i8, ptr %2160, i64 8
  %tbl_size_ptr.i.i93.i = getelementptr i8, ptr %2160, i64 16
  %offset_tbl_ptr.i.i94.i = getelementptr i8, ptr %2160, i64 40
  %hash_coef.i.i95.i = load i64, ptr %hash_coef_ptr.i.i92.i, align 4
  %tbl_size.i.i96.i = load i64, ptr %tbl_size_ptr.i.i93.i, align 4
  %offset_tbl.i.i97.i = load ptr, ptr %offset_tbl_ptr.i.i94.i, align 8
  %product.i.i.i98.i = mul i64 %hash_coef.i.i95.i, -5261542750394134544
  %shifted.i.i.i99.i = lshr i64 %product.i.i.i98.i, 32
  %xored.i.i.i100.i = xor i64 %shifted.i.i.i99.i, %product.i.i.i98.i
  %hash.i.i.i101.i = and i64 %xored.i.i.i100.i, %tbl_size.i.i96.i
  %offset_ptr.i.i102.i = getelementptr i32, ptr %offset_tbl.i.i97.i, i64 %hash.i.i.i101.i
  %offset.i.i103.i = load i32, ptr %offset_ptr.i.i102.i, align 4
  %eq.i106.i = icmp eq i32 %2166, %offset.i.i103.i
  call void @llvm.assume(i1 %eq.i106.i) #30
  %2168 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2169 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2152)
  %2170 = sext i32 %2158 to i64
  %2171 = getelementptr ptr, ptr %2152, i64 %2170
  %2172 = getelementptr i8, ptr %2171, i64 64
  %2173 = load ptr, ptr %2172, align 8
  %2174 = call ptr %2173({ ptr, ptr, ptr, i32 } %2159, ptr nonnull %2)
  %2175 = call i32 %2174({ ptr, ptr, ptr, i32 } %2159, { ptr, ptr, ptr, i32 } %2159, ptr nonnull %2)
  %2176 = shl i32 %2175, 1
  %2177 = load i32, ptr %217, align 4
  %2178 = load ptr, ptr %result.i105, align 8
  %2179 = load ptr, ptr %179, align 8
  %2180 = sext i32 %2177 to i64
  %2181 = shl nsw i64 %2180, 5
  %result.i.i.i968 = call noalias ptr @bump_malloc_inner(i64 noundef %2181, ptr nonnull @current_ptr) #29
  %2182 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2183 = icmp sgt i32 %2175, 0
  br i1 %2183, label %.lr.ph434.i, label %._crit_edge395.i

.lr.ph434.i:                                      ; preds = %2150
  %invariant.gep.i = getelementptr i8, ptr %2152, i64 120
  %2184 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i = getelementptr ptr, ptr %invariant.gep.i, i64 %2170
  br label %2185

2185:                                             ; preds = %2207, %.lr.ph434.i
  %.reg2mem105.0432.i = phi i32 [ 0, %.lr.ph434.i ], [ %.reg2mem101.0.i, %2207 ]
  %.reg2mem103.0431.i = phi i32 [ 0, %.lr.ph434.i ], [ %2208, %2207 ]
  store ptr @_parameterization_Ptri32, ptr %99, align 8
  %2186 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %99)
  %2187 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2152)
  %2188 = load ptr, ptr %gep.i, align 8
  store ptr @i32_typ, ptr %100, align 8
  %2189 = call ptr %2188({ ptr, ptr, ptr, i32 } %2159, ptr nonnull %100)
  %2190 = call { ptr, i160 } %2189({ ptr, ptr, ptr, i32 } %2159, { ptr, ptr, ptr, i32 } %2159, ptr nonnull %99, i32 %.reg2mem103.0431.i)
  %.fca.0.extract52.i = extractvalue { ptr, i160 } %2190, 0
  %2191 = icmp ne ptr %.fca.0.extract52.i, @nil_typ
  %2192 = icmp ne ptr %.fca.0.extract52.i, null
  %.not60.i = and i1 %2191, %2192
  br i1 %.not60.i, label %2193, label %2207

2193:                                             ; preds = %2185
  %hash_coef_ptr.i.i137.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 8
  %tbl_size_ptr.i.i138.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 16
  %offset_tbl_ptr.i.i139.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 40
  %hash_coef.i.i140.i = load i64, ptr %hash_coef_ptr.i.i137.i, align 4
  %tbl_size.i.i141.i = load i64, ptr %tbl_size_ptr.i.i138.i, align 4
  %offset_tbl.i.i142.i = load ptr, ptr %offset_tbl_ptr.i.i139.i, align 8
  %product.i.i.i143.i = mul i64 %hash_coef.i.i140.i, 4015701072841558310
  %shifted.i.i.i144.i = lshr i64 %product.i.i.i143.i, 32
  %xored.i.i.i145.i = xor i64 %shifted.i.i.i144.i, %product.i.i.i143.i
  %hash.i.i.i146.i = and i64 %xored.i.i.i145.i, %tbl_size.i.i141.i
  %offset_ptr.i.i147.i = getelementptr i32, ptr %offset_tbl.i.i142.i, i64 %hash.i.i.i146.i
  %offset.i.i148.i = load i32, ptr %offset_ptr.i.i147.i, align 4
  %2194 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2195 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2196 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2197 = icmp slt i32 %.reg2mem105.0432.i, %2177
  br i1 %2197, label %2198, label %._crit_edge.i970

2198:                                             ; preds = %2193
  %.fca.1.extract54.i = extractvalue { ptr, i160 } %2190, 1
  %.sroa.351.0.insert.ext.i = zext i32 %offset.i.i148.i to i160
  %.sroa.351.0.insert.shift.i = shl nuw i160 %.sroa.351.0.insert.ext.i, 128
  %2199 = and i160 %.fca.1.extract54.i, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i = or disjoint i160 %.sroa.351.0.insert.shift.i, %2199
  %2200 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2201 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2202 = sext i32 %.reg2mem105.0432.i to i64
  %2203 = shl nsw i64 %2202, 5
  %2204 = getelementptr i8, ptr %result.i.i.i968, i64 %2203
  store ptr %.fca.0.extract52.i, ptr %2204, align 8
  %2205 = getelementptr i8, ptr %2204, i64 8
  store i160 %.sroa.049.0.insert.insert.i, ptr %2205, align 4
  br label %._crit_edge.i970

._crit_edge.i970:                                 ; preds = %2198, %2193
  %2206 = add i32 %.reg2mem105.0432.i, 1
  br label %2207

2207:                                             ; preds = %._crit_edge.i970, %2185
  %.reg2mem101.0.i = phi i32 [ %2206, %._crit_edge.i970 ], [ %.reg2mem105.0432.i, %2185 ]
  %2208 = add nuw nsw i32 %.reg2mem103.0431.i, 1
  %2209 = icmp slt i32 %2208, %2175
  br i1 %2209, label %2185, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2207
  %invariant.gep396.i = getelementptr i8, ptr %2160, i64 120
  %2210 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2211 = sext i32 %2166 to i64
  %gep397.i = getelementptr ptr, ptr %invariant.gep396.i, i64 %2211
  br label %2212

2212:                                             ; preds = %2234, %.lr.ph.i
  %.reg2mem91.0394.i = phi i32 [ %.reg2mem101.0.i, %.lr.ph.i ], [ %.reg2mem87.0.i, %2234 ]
  %.reg2mem89.0393.i = phi i32 [ 0, %.lr.ph.i ], [ %2235, %2234 ]
  store ptr @_parameterization_Ptri32, ptr %101, align 8
  %2213 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %101)
  %2214 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2160)
  %2215 = load ptr, ptr %gep397.i, align 8
  store ptr @i32_typ, ptr %102, align 8
  %2216 = call ptr %2215({ ptr, ptr, ptr, i32 } %2167, ptr nonnull %102)
  %2217 = call { ptr, i160 } %2216({ ptr, ptr, ptr, i32 } %2167, { ptr, ptr, ptr, i32 } %2167, ptr nonnull %101, i32 %.reg2mem89.0393.i)
  %.fca.0.extract42.i = extractvalue { ptr, i160 } %2217, 0
  %2218 = icmp ne ptr %.fca.0.extract42.i, @nil_typ
  %2219 = icmp ne ptr %.fca.0.extract42.i, null
  %.not62.i = and i1 %2218, %2219
  br i1 %.not62.i, label %2220, label %2234

2220:                                             ; preds = %2212
  %hash_coef_ptr.i.i152.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 8
  %tbl_size_ptr.i.i153.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 16
  %offset_tbl_ptr.i.i154.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 40
  %hash_coef.i.i155.i = load i64, ptr %hash_coef_ptr.i.i152.i, align 4
  %tbl_size.i.i156.i = load i64, ptr %tbl_size_ptr.i.i153.i, align 4
  %offset_tbl.i.i157.i = load ptr, ptr %offset_tbl_ptr.i.i154.i, align 8
  %product.i.i.i158.i = mul i64 %hash_coef.i.i155.i, 4015701072841558310
  %shifted.i.i.i159.i = lshr i64 %product.i.i.i158.i, 32
  %xored.i.i.i160.i = xor i64 %shifted.i.i.i159.i, %product.i.i.i158.i
  %hash.i.i.i161.i = and i64 %xored.i.i.i160.i, %tbl_size.i.i156.i
  %offset_ptr.i.i162.i = getelementptr i32, ptr %offset_tbl.i.i157.i, i64 %hash.i.i.i161.i
  %offset.i.i163.i = load i32, ptr %offset_ptr.i.i162.i, align 4
  %2221 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2222 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2223 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2224 = icmp slt i32 %.reg2mem91.0394.i, %2177
  br i1 %2224, label %2225, label %._crit_edge1.i969

2225:                                             ; preds = %2220
  %.fca.1.extract44.i = extractvalue { ptr, i160 } %2217, 1
  %.sroa.3.0.insert.ext.i = zext i32 %offset.i.i163.i to i160
  %.sroa.3.0.insert.shift.i = shl nuw i160 %.sroa.3.0.insert.ext.i, 128
  %2226 = and i160 %.fca.1.extract44.i, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i = or disjoint i160 %.sroa.3.0.insert.shift.i, %2226
  %2227 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2228 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2229 = sext i32 %.reg2mem91.0394.i to i64
  %2230 = shl nsw i64 %2229, 5
  %2231 = getelementptr i8, ptr %result.i.i.i968, i64 %2230
  store ptr %.fca.0.extract42.i, ptr %2231, align 8
  %2232 = getelementptr i8, ptr %2231, i64 8
  store i160 %.sroa.040.0.insert.insert.i, ptr %2232, align 4
  br label %._crit_edge1.i969

._crit_edge1.i969:                                ; preds = %2225, %2220
  %2233 = add i32 %.reg2mem91.0394.i, 1
  br label %2234

2234:                                             ; preds = %._crit_edge1.i969, %2212
  %.reg2mem87.0.i = phi i32 [ %2233, %._crit_edge1.i969 ], [ %.reg2mem91.0394.i, %2212 ]
  %2235 = add nuw nsw i32 %.reg2mem89.0393.i, 1
  %2236 = icmp slt i32 %2235, %2175
  br i1 %2236, label %2212, label %._crit_edge395.i.loopexit

._crit_edge395.i.loopexit:                        ; preds = %2234
  %.pre = load ptr, ptr %result.i105, align 8
  %.pre2593 = load ptr, ptr %179, align 8
  br label %._crit_edge395.i

._crit_edge395.i:                                 ; preds = %._crit_edge395.i.loopexit, %2150
  %2237 = phi ptr [ %2179, %2150 ], [ %.pre2593, %._crit_edge395.i.loopexit ]
  %2238 = phi ptr [ %2178, %2150 ], [ %.pre, %._crit_edge395.i.loopexit ]
  %.reg2mem91.0.lcssa.i = phi i32 [ 0, %2150 ], [ %.reg2mem87.0.i, %._crit_edge395.i.loopexit ]
  %2239 = call i32 @llvm.smax.i32(i32 %2176, i32 16)
  %result.i166.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2240 = getelementptr i8, ptr %result.i166.i, i64 16
  store ptr @_parameterization_Nil, ptr %2240, align 8
  %result.i167.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2241 = getelementptr i8, ptr %result.i167.i, i64 16
  store ptr %2237, ptr %2241, align 8
  %2242 = getelementptr i8, ptr %result.i167.i, i64 8
  store ptr %2238, ptr %2242, align 8
  %2243 = getelementptr i8, ptr %result.i167.i, i64 24
  store ptr null, ptr %2243, align 8
  %2244 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i)
  store ptr @Entry, ptr %result.i167.i, align 8
  %2245 = getelementptr i8, ptr %result.i166.i, i64 8
  store ptr %result.i167.i, ptr %2245, align 8
  %2246 = getelementptr i8, ptr %result.i166.i, i64 24
  store ptr null, ptr %2246, align 8
  %2247 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i)
  store ptr @union_typ, ptr %result.i166.i, align 8
  %result.i168.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i, ptr %result.i168.i, align 8
  %2248 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i)
  store ptr @Array, ptr %103, align 8
  store ptr %result.i168.i, ptr %253, align 8
  store i32 9, ptr %254, align 8
  %2249 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %103)
  %2250 = getelementptr i8, ptr %result.i168.i, i64 16
  store i32 %2239, ptr %2250, align 4
  %2251 = getelementptr i8, ptr %result.i168.i, i64 20
  store i32 %2239, ptr %2251, align 4
  %2252 = zext nneg i32 %2239 to i64
  %2253 = shl nuw nsw i64 %2252, 5
  %result.i.i416.i = call noalias ptr @bump_malloc_inner(i64 noundef %2253, ptr nonnull @current_ptr) #29
  %2254 = getelementptr i8, ptr %result.i168.i, i64 8
  store ptr %result.i.i416.i, ptr %2254, align 8
  %2255 = load ptr, ptr %255, align 8
  store ptr @Array, ptr %196, align 8
  store ptr %result.i168.i, ptr %197, align 8
  store ptr %2255, ptr %198, align 8
  store i32 9, ptr %199, align 4
  %2256 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2257 = getelementptr i8, ptr %result.i183.i, i64 16
  store ptr @_parameterization_Nil, ptr %2257, align 8
  %result.i184.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2258 = getelementptr i8, ptr %result.i184.i, i64 16
  store ptr %2237, ptr %2258, align 8
  %2259 = getelementptr i8, ptr %result.i184.i, i64 8
  store ptr %2238, ptr %2259, align 8
  %2260 = getelementptr i8, ptr %result.i184.i, i64 24
  store ptr null, ptr %2260, align 8
  %2261 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i)
  store ptr @Entry, ptr %result.i184.i, align 8
  %2262 = getelementptr i8, ptr %result.i183.i, i64 8
  store ptr %result.i184.i, ptr %2262, align 8
  %2263 = getelementptr i8, ptr %result.i183.i, i64 24
  store ptr null, ptr %2263, align 8
  %2264 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i)
  store ptr @union_typ, ptr %result.i183.i, align 8
  %result.i185.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i, ptr %result.i185.i, align 8
  %2265 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i)
  store ptr @Array, ptr %104, align 8
  store ptr %result.i185.i, ptr %256, align 8
  store i32 9, ptr %257, align 8
  %2266 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %104)
  %2267 = getelementptr i8, ptr %result.i185.i, i64 16
  store i32 %2239, ptr %2267, align 4
  %2268 = getelementptr i8, ptr %result.i185.i, i64 20
  store i32 %2239, ptr %2268, align 4
  %result.i.i430.i = call noalias ptr @bump_malloc_inner(i64 noundef %2253, ptr nonnull @current_ptr) #29
  %2269 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2270 = getelementptr i8, ptr %result.i185.i, i64 8
  store ptr %result.i.i430.i, ptr %2270, align 8
  %2271 = load ptr, ptr %258, align 8
  store ptr @Array, ptr %213, align 8
  store ptr %result.i185.i, ptr %214, align 8
  store ptr %2271, ptr %215, align 8
  store i32 9, ptr %216, align 4
  store i32 0, ptr %217, align 4
  %2272 = icmp sgt i32 %.reg2mem91.0.lcssa.i, 0
  br i1 %2272, label %.lr.ph400.i, label %HashMap_resize_.exit

.lr.ph400.i:                                      ; preds = %._crit_edge395.i
  %2273 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2274 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2275 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %._crit_edge2.i, %.lr.ph400.i
  %.reg2mem77.0398.i = phi i32 [ 0, %.lr.ph400.i ], [ %2289, %._crit_edge2.i ]
  %2276 = zext nneg i32 %.reg2mem77.0398.i to i64
  %2277 = shl nuw nsw i64 %2276, 5
  %2278 = getelementptr i8, ptr %result.i.i.i968, i64 %2277
  %2279 = load ptr, ptr %2278, align 8
  %2280 = getelementptr i8, ptr %2278, i64 8
  %2281 = load i160, ptr %2280, align 4
  %.sroa.3362.8.extract.trunc.i = trunc i160 %2281 to i64
  %2282 = inttoptr i64 %.sroa.3362.8.extract.trunc.i to ptr
  %.sroa.5363.8.extract.shift.i = lshr i160 %2281, 64
  %.sroa.5363.8.extract.trunc.i = trunc i160 %.sroa.5363.8.extract.shift.i to i64
  %2283 = inttoptr i64 %.sroa.5363.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i201.i = getelementptr i8, ptr %2279, i64 8
  %tbl_size_ptr.i.i202.i = getelementptr i8, ptr %2279, i64 16
  %offset_tbl_ptr.i.i203.i = getelementptr i8, ptr %2279, i64 40
  %hash_coef.i.i232.i = load i64, ptr %hash_coef_ptr.i.i201.i, align 4
  %tbl_size.i.i233.i = load i64, ptr %tbl_size_ptr.i.i202.i, align 4
  %offset_tbl.i.i234.i = load ptr, ptr %offset_tbl_ptr.i.i203.i, align 8
  %product.i.i.i235.i = mul i64 %hash_coef.i.i232.i, 4015701072841558310
  %shifted.i.i.i236.i = lshr i64 %product.i.i.i235.i, 32
  %xored.i.i.i237.i = xor i64 %shifted.i.i.i236.i, %product.i.i.i235.i
  %hash.i.i.i238.i = and i64 %xored.i.i.i237.i, %tbl_size.i.i233.i
  %offset_ptr.i.i239.i = getelementptr i32, ptr %offset_tbl.i.i234.i, i64 %hash.i.i.i238.i
  %offset.i.i240.i = load i32, ptr %offset_ptr.i.i239.i, align 4
  %2284 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2279, 0
  %2285 = insertvalue { ptr, ptr, ptr, i32 } %2284, ptr %2282, 1
  %2286 = insertvalue { ptr, ptr, ptr, i32 } %2285, ptr %2283, 2
  %2287 = insertvalue { ptr, ptr, ptr, i32 } %2286, i32 %offset.i.i240.i, 3
  %2288 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %261, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2287)
  %2289 = add nuw nsw i32 %.reg2mem77.0398.i, 1
  %2290 = icmp slt i32 %2289, %.reg2mem91.0.lcssa.i
  br i1 %2290, label %._crit_edge2.i, label %HashMap_resize_.exit

HashMap_resize_.exit:                             ; preds = %._crit_edge2.i, %._crit_edge395.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %99)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %100)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %101)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %102)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %103)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %104)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %HashMap_resize_.exit, %.critedge158.i
  %2291 = load ptr, ptr %result.i105, align 8
  %2292 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2293 = load ptr, ptr %179, align 8
  %2294 = load ptr, ptr %2291, align 8
  %2295 = getelementptr i8, ptr %2294, i64 48
  %2296 = load ptr, ptr %2295, align 8
  %2297 = call { i64, i64 } %2296(ptr nonnull %2291)
  %2298 = extractvalue { i64, i64 } %2297, 0
  %2299 = extractvalue { i64, i64 } %2297, 1
  %2300 = urem i64 20, %2299
  %2301 = icmp eq i64 %2300, 0
  %2302 = sub i64 %2299, %2300
  %2303 = select i1 %2301, i64 0, i64 %2302
  %2304 = add i64 %2298, 20
  %2305 = add i64 %2304, %2303
  %2306 = load ptr, ptr %2293, align 8
  %2307 = getelementptr i8, ptr %2306, i64 48
  %2308 = load ptr, ptr %2307, align 8
  %2309 = call { i64, i64 } %2308(ptr nonnull %2293)
  %2310 = extractvalue { i64, i64 } %2309, 0
  %2311 = extractvalue { i64, i64 } %2309, 1
  %2312 = call i64 @llvm.umax.i64(i64 %2299, i64 %2311)
  %2313 = call i64 @llvm.umax.i64(i64 %2312, i64 8)
  %2314 = urem i64 %2305, %2311
  %2315 = icmp eq i64 %2314, 0
  %2316 = sub i64 %2311, %2314
  %2317 = select i1 %2315, i64 0, i64 %2316
  %2318 = add i64 %2310, %2305
  %2319 = add i64 %2318, %2317
  %2320 = urem i64 %2319, %2313
  %2321 = icmp eq i64 %2320, 0
  %2322 = sub i64 %2313, %2320
  %2323 = select i1 %2321, i64 0, i64 %2322
  %2324 = add i64 %2323, %2319
  %result.i298.i = call noalias ptr @bump_malloc_inner(i64 noundef %2324, ptr nonnull @current_ptr) #29
  store ptr %2291, ptr %result.i298.i, align 8
  %2325 = getelementptr i8, ptr %result.i298.i, i64 8
  store ptr %2293, ptr %2325, align 8
  %2326 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i)
  store ptr @Entry, ptr %128, align 8
  store ptr %result.i298.i, ptr %224, align 8
  store i32 9, ptr %225, align 8
  %2327 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %128)
  %2328 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2329 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2330 = load ptr, ptr %2291, align 8
  %2331 = getelementptr i8, ptr %2330, i64 48
  %2332 = load ptr, ptr %2331, align 8
  %2333 = call { i64, i64 } %2332(ptr nonnull %2291)
  %2334 = extractvalue { i64, i64 } %2333, 1
  %2335 = urem i64 20, %2334
  %2336 = icmp eq i64 %2335, 0
  %reass.sub3306 = sub i64 %2334, %2335
  %2337 = add i64 %reass.sub3306, 20
  %2338 = select i1 %2336, i64 20, i64 %2337
  %2339 = getelementptr i8, ptr %result.i298.i, i64 %2338
  %2340 = load ptr, ptr %result.i298.i, align 8
  %2341 = load ptr, ptr %2340, align 8
  %2342 = getelementptr i8, ptr %2341, i64 64
  %2343 = load ptr, ptr %2342, align 8
  call void %2343({ ptr, i160 } %323, ptr nonnull %2340, ptr %2339)
  %2344 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2345 = load ptr, ptr %result.i298.i, align 8
  %2346 = load ptr, ptr %2345, align 8
  %2347 = getelementptr i8, ptr %2346, i64 48
  %2348 = load ptr, ptr %2347, align 8
  %2349 = call { i64, i64 } %2348(ptr nonnull %2345)
  %2350 = extractvalue { i64, i64 } %2349, 0
  %2351 = extractvalue { i64, i64 } %2349, 1
  %2352 = urem i64 20, %2351
  %2353 = icmp eq i64 %2352, 0
  %2354 = sub i64 %2351, %2352
  %2355 = select i1 %2353, i64 0, i64 %2354
  %2356 = add i64 %2350, 20
  %2357 = add i64 %2356, %2355
  %2358 = load ptr, ptr %2325, align 8
  %2359 = load ptr, ptr %2358, align 8
  %2360 = getelementptr i8, ptr %2359, i64 48
  %2361 = load ptr, ptr %2360, align 8
  %2362 = call { i64, i64 } %2361(ptr nonnull %2358)
  %2363 = extractvalue { i64, i64 } %2362, 1
  %2364 = urem i64 %2357, %2363
  %2365 = icmp eq i64 %2364, 0
  %2366 = sub i64 %2363, %2364
  %2367 = select i1 %2365, i64 0, i64 %2366
  %2368 = getelementptr i8, ptr %result.i298.i, i64 %2357
  %2369 = getelementptr i8, ptr %2368, i64 %2367
  %2370 = load ptr, ptr %2325, align 8
  %2371 = load ptr, ptr %2370, align 8
  %2372 = getelementptr i8, ptr %2371, i64 64
  %2373 = load ptr, ptr %2372, align 8
  call void %2373({ ptr, i160 } %1754, ptr nonnull %2370, ptr %2369)
  %2374 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2375 = getelementptr i8, ptr %result.i298.i, i64 16
  store i32 %1757, ptr %2375, align 4
  %2376 = load ptr, ptr %226, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i971)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %98)
  store ptr @Entry, ptr %98, align 8
  store ptr %result.i298.i, ptr %262, align 8
  store ptr %2376, ptr %263, align 8
  store i32 9, ptr %264, align 8
  %2377 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %98)
  %2378 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2379 = load i32, ptr %219, align 4
  %2380 = icmp sgt i32 %2379, 0
  br i1 %2380, label %.lr.ph.i1001, label %._crit_edge1.i

.lr.ph.i1001:                                     ; preds = %._crit_edge.i
  %2381 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2382 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %2383

2383:                                             ; preds = %.cont.cont.i, %.lr.ph.i1001
  %offset.i.i260.i1590 = phi i32 [ 9, %.lr.ph.i1001 ], [ %offset.i.i260.i, %.cont.cont.i ]
  %.sroa.speculated346.i1588 = phi ptr [ %2376, %.lr.ph.i1001 ], [ %.sroa.speculated346.i, %.cont.cont.i ]
  %.sroa.speculated352.i1586 = phi ptr [ %result.i298.i, %.lr.ph.i1001 ], [ %.sroa.speculated352.i, %.cont.cont.i ]
  %.reg2mem195.0678.i = phi i32 [ 1, %.lr.ph.i1001 ], [ %2539, %.cont.cont.i ]
  %.reg2mem193.0677.i = phi i32 [ 0, %.lr.ph.i1001 ], [ %2540, %.cont.cont.i ]
  %2384 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i1586, 1
  %2385 = insertvalue { ptr, ptr, ptr, i32 } %2384, ptr %.sroa.speculated346.i1588, 2
  %2386 = insertvalue { ptr, ptr, ptr, i32 } %2385, i32 %offset.i.i260.i1590, 3
  %2387 = sext i32 %offset.i.i260.i1590 to i64
  %gep1585 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %2387
  %2388 = load ptr, ptr %gep1585, align 8
  %2389 = call ptr %2388({ ptr, ptr, ptr, i32 } %2386, ptr nonnull %2)
  %2390 = call i32 %2389({ ptr, ptr, ptr, i32 } %2386, { ptr, ptr, ptr, i32 } %2386, ptr nonnull %2)
  %2391 = icmp eq i32 %.reg2mem195.0678.i, 1
  %2392 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %2391, label %2393, label %2457

2393:                                             ; preds = %2383
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2394 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2395 = load ptr, ptr %196, align 8
  %2396 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2395, 0
  %2397 = load ptr, ptr %197, align 8
  %2398 = insertvalue { ptr, ptr, ptr, i32 } %2396, ptr %2397, 1
  %2399 = load ptr, ptr %198, align 8
  %2400 = insertvalue { ptr, ptr, ptr, i32 } %2398, ptr %2399, 2
  %2401 = load i32, ptr %199, align 4
  %2402 = insertvalue { ptr, ptr, ptr, i32 } %2400, i32 %2401, 3
  %hash_coef_ptr.i.i10.i2686 = getelementptr i8, ptr %2395, i64 8
  %tbl_size_ptr.i.i11.i2687 = getelementptr i8, ptr %2395, i64 16
  %offset_tbl_ptr.i.i12.i2688 = getelementptr i8, ptr %2395, i64 40
  %hash_coef.i.i13.i2689 = load i64, ptr %hash_coef_ptr.i.i10.i2686, align 4
  %tbl_size.i.i14.i2690 = load i64, ptr %tbl_size_ptr.i.i11.i2687, align 4
  %offset_tbl.i.i15.i2691 = load ptr, ptr %offset_tbl_ptr.i.i12.i2688, align 8
  %product.i.i.i16.i2692 = mul i64 %hash_coef.i.i13.i2689, -5261542750394134544
  %shifted.i.i.i17.i2693 = lshr i64 %product.i.i.i16.i2692, 32
  %xored.i.i.i18.i2694 = xor i64 %shifted.i.i.i17.i2693, %product.i.i.i16.i2692
  %hash.i.i.i19.i2695 = and i64 %xored.i.i.i18.i2694, %tbl_size.i.i14.i2690
  %offset_ptr.i.i20.i2696 = getelementptr i32, ptr %offset_tbl.i.i15.i2691, i64 %hash.i.i.i19.i2695
  %offset.i.i21.i2697 = load i32, ptr %offset_ptr.i.i20.i2696, align 4
  %eq.i.i2698 = icmp eq i32 %2401, %offset.i.i21.i2697
  call void @llvm.assume(i1 %eq.i.i2698) #30
  %2403 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2404 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2395)
  %2405 = sext i32 %2401 to i64
  %2406 = getelementptr ptr, ptr %2395, i64 %2405
  %2407 = getelementptr i8, ptr %2406, i64 64
  %2408 = load ptr, ptr %2407, align 8
  %2409 = call ptr %2408({ ptr, ptr, ptr, i32 } %2402, ptr nonnull %2)
  %2410 = call i32 %2409({ ptr, ptr, ptr, i32 } %2402, { ptr, ptr, ptr, i32 } %2402, ptr nonnull %2)
  %2411 = add i32 %2410, -1
  %2412 = and i32 %2411, %2390
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2413 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2414 = load ptr, ptr %196, align 8
  %2415 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2414, 0
  %2416 = load ptr, ptr %197, align 8
  %2417 = insertvalue { ptr, ptr, ptr, i32 } %2415, ptr %2416, 1
  %2418 = load ptr, ptr %198, align 8
  %2419 = insertvalue { ptr, ptr, ptr, i32 } %2417, ptr %2418, 2
  %2420 = load i32, ptr %199, align 4
  %2421 = insertvalue { ptr, ptr, ptr, i32 } %2419, i32 %2420, 3
  %hash_coef_ptr.i.i172.i = getelementptr i8, ptr %2414, i64 8
  %tbl_size_ptr.i.i173.i = getelementptr i8, ptr %2414, i64 16
  %offset_tbl_ptr.i.i174.i = getelementptr i8, ptr %2414, i64 40
  %hash_coef.i.i175.i = load i64, ptr %hash_coef_ptr.i.i172.i, align 4
  %tbl_size.i.i176.i = load i64, ptr %tbl_size_ptr.i.i173.i, align 4
  %offset_tbl.i.i177.i = load ptr, ptr %offset_tbl_ptr.i.i174.i, align 8
  %product.i.i.i178.i = mul i64 %hash_coef.i.i175.i, -5261542750394134544
  %shifted.i.i.i179.i = lshr i64 %product.i.i.i178.i, 32
  %xored.i.i.i180.i = xor i64 %shifted.i.i.i179.i, %product.i.i.i178.i
  %hash.i.i.i181.i = and i64 %xored.i.i.i180.i, %tbl_size.i.i176.i
  %offset_ptr.i.i182.i = getelementptr i32, ptr %offset_tbl.i.i177.i, i64 %hash.i.i.i181.i
  %offset.i.i183.i = load i32, ptr %offset_ptr.i.i182.i, align 4
  %eq.i.i1004 = icmp eq i32 %2420, %offset.i.i183.i
  call void @llvm.assume(i1 %eq.i.i1004) #30
  store ptr @_parameterization_Ptri32, ptr %82, align 8
  %2422 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %82)
  %2423 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2414)
  %2424 = sext i32 %2420 to i64
  %2425 = getelementptr ptr, ptr %2414, i64 %2424
  %2426 = getelementptr i8, ptr %2425, i64 120
  %2427 = load ptr, ptr %2426, align 8
  store ptr @i32_typ, ptr %83, align 8
  %2428 = call ptr %2427({ ptr, ptr, ptr, i32 } %2421, ptr nonnull %83)
  %2429 = call { ptr, i160 } %2428({ ptr, ptr, ptr, i32 } %2421, { ptr, ptr, ptr, i32 } %2421, ptr nonnull %82, i32 %2412)
  %.fca.0.extract112.i = extractvalue { ptr, i160 } %2429, 0
  %2430 = ptrtoint ptr %.sroa.speculated352.i1586 to i64
  %2431 = ptrtoint ptr %.sroa.speculated346.i1588 to i64
  %.sroa.3111.0.insert.ext.i = zext i32 %offset.i.i260.i1590 to i160
  %.sroa.3111.0.insert.shift.i = shl nuw i160 %.sroa.3111.0.insert.ext.i, 128
  %.sroa.2110.0.insert.ext.i = zext i64 %2431 to i160
  %.sroa.2110.0.insert.shift.i = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i, 64
  %.sroa.2110.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.shift.i, %.sroa.3111.0.insert.shift.i
  %.sroa.0109.0.insert.ext.i = zext i64 %2430 to i160
  %.sroa.0109.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.insert.i, %.sroa.0109.0.insert.ext.i
  %2432 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i, 1
  %2433 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2434 = load ptr, ptr %196, align 8
  %2435 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2434, 0
  %2436 = load ptr, ptr %197, align 8
  %2437 = insertvalue { ptr, ptr, ptr, i32 } %2435, ptr %2436, 1
  %2438 = load ptr, ptr %198, align 8
  %2439 = insertvalue { ptr, ptr, ptr, i32 } %2437, ptr %2438, 2
  %2440 = load i32, ptr %199, align 4
  %2441 = insertvalue { ptr, ptr, ptr, i32 } %2439, i32 %2440, 3
  %hash_coef_ptr.i.i186.i = getelementptr i8, ptr %2434, i64 8
  %tbl_size_ptr.i.i187.i = getelementptr i8, ptr %2434, i64 16
  %offset_tbl_ptr.i.i188.i = getelementptr i8, ptr %2434, i64 40
  %hash_coef.i.i189.i = load i64, ptr %hash_coef_ptr.i.i186.i, align 4
  %tbl_size.i.i190.i = load i64, ptr %tbl_size_ptr.i.i187.i, align 4
  %offset_tbl.i.i191.i = load ptr, ptr %offset_tbl_ptr.i.i188.i, align 8
  %product.i.i.i192.i = mul i64 %hash_coef.i.i189.i, -5261542750394134544
  %shifted.i.i.i193.i = lshr i64 %product.i.i.i192.i, 32
  %xored.i.i.i194.i = xor i64 %shifted.i.i.i193.i, %product.i.i.i192.i
  %hash.i.i.i195.i = and i64 %xored.i.i.i194.i, %tbl_size.i.i190.i
  %offset_ptr.i.i196.i = getelementptr i32, ptr %offset_tbl.i.i191.i, i64 %hash.i.i.i195.i
  %offset.i.i197.i = load i32, ptr %offset_ptr.i.i196.i, align 4
  %eq.i200.i = icmp eq i32 %2440, %offset.i.i197.i
  call void @llvm.assume(i1 %eq.i200.i) #30
  %2442 = load ptr, ptr %result.i105, align 8
  %2443 = load ptr, ptr %179, align 8
  %result.i.i1005 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2444 = getelementptr i8, ptr %result.i.i1005, i64 16
  store ptr %2443, ptr %2444, align 8
  %2445 = getelementptr i8, ptr %result.i.i1005, i64 8
  store ptr %2442, ptr %2445, align 8
  %2446 = getelementptr i8, ptr %result.i.i1005, i64 24
  store ptr null, ptr %2446, align 8
  %2447 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1005)
  store ptr @Entry, ptr %result.i.i1005, align 8
  store ptr @_parameterization_Ptri32, ptr %84, align 8
  store ptr %result.i.i1005, ptr %267, align 8
  %2448 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %84)
  %2449 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2434)
  %2450 = sext i32 %2440 to i64
  %2451 = getelementptr ptr, ptr %2434, i64 %2450
  %2452 = getelementptr i8, ptr %2451, i64 128
  %2453 = load ptr, ptr %2452, align 8
  store ptr @i32_typ, ptr %85, align 8
  store ptr @Entry, ptr %268, align 8
  %2454 = call ptr %2453({ ptr, ptr, ptr, i32 } %2441, ptr nonnull %85)
  call void %2454({ ptr, ptr, ptr, i32 } %2441, { ptr, ptr, ptr, i32 } %2441, ptr nonnull %84, i32 %2412, { ptr, i160 } %2432)
  %2455 = icmp ne ptr %.fca.0.extract112.i, @nil_typ
  %2456 = icmp ne ptr %.fca.0.extract112.i, null
  %.not140.i = and i1 %2455, %2456
  br i1 %.not140.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

2457:                                             ; preds = %2383
  %2458 = add i32 %2390, 2127912214
  %2459 = shl i32 %2390, 12
  %2460 = add i32 %2458, %2459
  %2461 = ashr i32 %2460, 19
  %2462 = xor i32 %2460, %2461
  %2463 = xor i32 %2462, -949894596
  %2464 = add i32 %2463, 374761393
  %2465 = shl i32 %2463, 5
  %2466 = add i32 %2464, %2465
  %2467 = add i32 %2466, -744332180
  %2468 = shl i32 %2466, 9
  %2469 = xor i32 %2467, %2468
  %2470 = add i32 %2469, -42973499
  %2471 = shl i32 %2469, 3
  %2472 = add i32 %2470, %2471
  %2473 = ashr i32 %2472, 16
  %2474 = xor i32 %2472, %2473
  %2475 = xor i32 %2474, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2476 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2477 = load ptr, ptr %213, align 8
  %2478 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2477, 0
  %2479 = load ptr, ptr %214, align 8
  %2480 = insertvalue { ptr, ptr, ptr, i32 } %2478, ptr %2479, 1
  %2481 = load ptr, ptr %215, align 8
  %2482 = insertvalue { ptr, ptr, ptr, i32 } %2480, ptr %2481, 2
  %2483 = load i32, ptr %216, align 4
  %2484 = insertvalue { ptr, ptr, ptr, i32 } %2482, i32 %2483, 3
  %hash_coef_ptr.i.i10.i2716 = getelementptr i8, ptr %2477, i64 8
  %tbl_size_ptr.i.i11.i2717 = getelementptr i8, ptr %2477, i64 16
  %offset_tbl_ptr.i.i12.i2718 = getelementptr i8, ptr %2477, i64 40
  %hash_coef.i.i13.i2719 = load i64, ptr %hash_coef_ptr.i.i10.i2716, align 4
  %tbl_size.i.i14.i2720 = load i64, ptr %tbl_size_ptr.i.i11.i2717, align 4
  %offset_tbl.i.i15.i2721 = load ptr, ptr %offset_tbl_ptr.i.i12.i2718, align 8
  %product.i.i.i16.i2722 = mul i64 %hash_coef.i.i13.i2719, -5261542750394134544
  %shifted.i.i.i17.i2723 = lshr i64 %product.i.i.i16.i2722, 32
  %xored.i.i.i18.i2724 = xor i64 %shifted.i.i.i17.i2723, %product.i.i.i16.i2722
  %hash.i.i.i19.i2725 = and i64 %xored.i.i.i18.i2724, %tbl_size.i.i14.i2720
  %offset_ptr.i.i20.i2726 = getelementptr i32, ptr %offset_tbl.i.i15.i2721, i64 %hash.i.i.i19.i2725
  %offset.i.i21.i2727 = load i32, ptr %offset_ptr.i.i20.i2726, align 4
  %eq.i.i2728 = icmp eq i32 %2483, %offset.i.i21.i2727
  call void @llvm.assume(i1 %eq.i.i2728) #30
  %2485 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2486 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2477)
  %2487 = sext i32 %2483 to i64
  %2488 = getelementptr ptr, ptr %2477, i64 %2487
  %2489 = getelementptr i8, ptr %2488, i64 64
  %2490 = load ptr, ptr %2489, align 8
  %2491 = call ptr %2490({ ptr, ptr, ptr, i32 } %2484, ptr nonnull %2)
  %2492 = call i32 %2491({ ptr, ptr, ptr, i32 } %2484, { ptr, ptr, ptr, i32 } %2484, ptr nonnull %2)
  %2493 = add i32 %2492, -1
  %2494 = and i32 %2493, %2475
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2495 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2496 = load ptr, ptr %213, align 8
  %2497 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2496, 0
  %2498 = load ptr, ptr %214, align 8
  %2499 = insertvalue { ptr, ptr, ptr, i32 } %2497, ptr %2498, 1
  %2500 = load ptr, ptr %215, align 8
  %2501 = insertvalue { ptr, ptr, ptr, i32 } %2499, ptr %2500, 2
  %2502 = load i32, ptr %216, align 4
  %2503 = insertvalue { ptr, ptr, ptr, i32 } %2501, i32 %2502, 3
  %hash_coef_ptr.i.i202.i = getelementptr i8, ptr %2496, i64 8
  %tbl_size_ptr.i.i203.i = getelementptr i8, ptr %2496, i64 16
  %offset_tbl_ptr.i.i204.i = getelementptr i8, ptr %2496, i64 40
  %hash_coef.i.i205.i = load i64, ptr %hash_coef_ptr.i.i202.i, align 4
  %tbl_size.i.i206.i = load i64, ptr %tbl_size_ptr.i.i203.i, align 4
  %offset_tbl.i.i207.i = load ptr, ptr %offset_tbl_ptr.i.i204.i, align 8
  %product.i.i.i208.i = mul i64 %hash_coef.i.i205.i, -5261542750394134544
  %shifted.i.i.i209.i = lshr i64 %product.i.i.i208.i, 32
  %xored.i.i.i210.i = xor i64 %shifted.i.i.i209.i, %product.i.i.i208.i
  %hash.i.i.i211.i = and i64 %xored.i.i.i210.i, %tbl_size.i.i206.i
  %offset_ptr.i.i212.i = getelementptr i32, ptr %offset_tbl.i.i207.i, i64 %hash.i.i.i211.i
  %offset.i.i213.i = load i32, ptr %offset_ptr.i.i212.i, align 4
  %eq.i216.i = icmp eq i32 %2502, %offset.i.i213.i
  call void @llvm.assume(i1 %eq.i216.i) #30
  store ptr @_parameterization_Ptri32, ptr %90, align 8
  %2504 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %90)
  %2505 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2496)
  %2506 = sext i32 %2502 to i64
  %2507 = getelementptr ptr, ptr %2496, i64 %2506
  %2508 = getelementptr i8, ptr %2507, i64 120
  %2509 = load ptr, ptr %2508, align 8
  store ptr @i32_typ, ptr %91, align 8
  %2510 = call ptr %2509({ ptr, ptr, ptr, i32 } %2503, ptr nonnull %91)
  %2511 = call { ptr, i160 } %2510({ ptr, ptr, ptr, i32 } %2503, { ptr, ptr, ptr, i32 } %2503, ptr nonnull %90, i32 %2494)
  %.fca.0.extract87.i = extractvalue { ptr, i160 } %2511, 0
  %2512 = ptrtoint ptr %.sroa.speculated352.i1586 to i64
  %2513 = ptrtoint ptr %.sroa.speculated346.i1588 to i64
  %.sroa.3.0.insert.ext.i1002 = zext i32 %offset.i.i260.i1590 to i160
  %.sroa.3.0.insert.shift.i1003 = shl nuw i160 %.sroa.3.0.insert.ext.i1002, 128
  %.sroa.2.0.insert.ext.i = zext i64 %2513 to i160
  %.sroa.2.0.insert.shift.i = shl nuw nsw i160 %.sroa.2.0.insert.ext.i, 64
  %.sroa.2.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.shift.i, %.sroa.3.0.insert.shift.i1003
  %.sroa.0.0.insert.ext.i = zext i64 %2512 to i160
  %.sroa.0.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.insert.i, %.sroa.0.0.insert.ext.i
  %2514 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i, 1
  %2515 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2516 = load ptr, ptr %213, align 8
  %2517 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2516, 0
  %2518 = load ptr, ptr %214, align 8
  %2519 = insertvalue { ptr, ptr, ptr, i32 } %2517, ptr %2518, 1
  %2520 = load ptr, ptr %215, align 8
  %2521 = insertvalue { ptr, ptr, ptr, i32 } %2519, ptr %2520, 2
  %2522 = load i32, ptr %216, align 4
  %2523 = insertvalue { ptr, ptr, ptr, i32 } %2521, i32 %2522, 3
  %hash_coef_ptr.i.i218.i = getelementptr i8, ptr %2516, i64 8
  %tbl_size_ptr.i.i219.i = getelementptr i8, ptr %2516, i64 16
  %offset_tbl_ptr.i.i220.i = getelementptr i8, ptr %2516, i64 40
  %hash_coef.i.i221.i = load i64, ptr %hash_coef_ptr.i.i218.i, align 4
  %tbl_size.i.i222.i = load i64, ptr %tbl_size_ptr.i.i219.i, align 4
  %offset_tbl.i.i223.i = load ptr, ptr %offset_tbl_ptr.i.i220.i, align 8
  %product.i.i.i224.i = mul i64 %hash_coef.i.i221.i, -5261542750394134544
  %shifted.i.i.i225.i = lshr i64 %product.i.i.i224.i, 32
  %xored.i.i.i226.i = xor i64 %shifted.i.i.i225.i, %product.i.i.i224.i
  %hash.i.i.i227.i = and i64 %xored.i.i.i226.i, %tbl_size.i.i222.i
  %offset_ptr.i.i228.i = getelementptr i32, ptr %offset_tbl.i.i223.i, i64 %hash.i.i.i227.i
  %offset.i.i229.i = load i32, ptr %offset_ptr.i.i228.i, align 4
  %eq.i232.i = icmp eq i32 %2522, %offset.i.i229.i
  call void @llvm.assume(i1 %eq.i232.i) #30
  %2524 = load ptr, ptr %result.i105, align 8
  %2525 = load ptr, ptr %179, align 8
  %result.i233.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2526 = getelementptr i8, ptr %result.i233.i, i64 16
  store ptr %2525, ptr %2526, align 8
  %2527 = getelementptr i8, ptr %result.i233.i, i64 8
  store ptr %2524, ptr %2527, align 8
  %2528 = getelementptr i8, ptr %result.i233.i, i64 24
  store ptr null, ptr %2528, align 8
  %2529 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i)
  store ptr @Entry, ptr %result.i233.i, align 8
  store ptr @_parameterization_Ptri32, ptr %92, align 8
  store ptr %result.i233.i, ptr %265, align 8
  %2530 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %92)
  %2531 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2516)
  %2532 = sext i32 %2522 to i64
  %2533 = getelementptr ptr, ptr %2516, i64 %2532
  %2534 = getelementptr i8, ptr %2533, i64 128
  %2535 = load ptr, ptr %2534, align 8
  store ptr @i32_typ, ptr %93, align 8
  store ptr @Entry, ptr %266, align 8
  %2536 = call ptr %2535({ ptr, ptr, ptr, i32 } %2523, ptr nonnull %93)
  call void %2536({ ptr, ptr, ptr, i32 } %2523, { ptr, ptr, ptr, i32 } %2523, ptr nonnull %92, i32 %2494, { ptr, i160 } %2514)
  %2537 = icmp ne ptr %.fca.0.extract87.i, @nil_typ
  %2538 = icmp ne ptr %.fca.0.extract87.i, null
  %.not138.i = and i1 %2537, %2538
  br i1 %.not138.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %2457, %2393
  %.sink = phi { ptr, i160 } [ %2429, %2393 ], [ %2511, %2457 ]
  %2539 = phi i32 [ 2, %2393 ], [ 1, %2457 ]
  %vptr.i248.sroa.speculated.i = phi ptr [ %.fca.0.extract112.i, %2393 ], [ %.fca.0.extract87.i, %2457 ]
  %.fca.1.extract89.i = extractvalue { ptr, i160 } %.sink, 1
  %.sroa.3407.sroa.4.0.extract.shift.i = lshr i160 %.fca.1.extract89.i, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i = trunc i160 %.fca.1.extract89.i to i64
  %.sroa.speculated352.i = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i to ptr
  %.sroa.speculated346.i = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i to ptr
  %hash_coef_ptr.i.i249.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i250.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i251.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 40
  %hash_coef.i.i252.i = load i64, ptr %hash_coef_ptr.i.i249.i, align 4
  %tbl_size.i.i253.i = load i64, ptr %tbl_size_ptr.i.i250.i, align 4
  %offset_tbl.i.i254.i = load ptr, ptr %offset_tbl_ptr.i.i251.i, align 8
  %product.i.i.i255.i = mul i64 %hash_coef.i.i252.i, 4015701072841558310
  %shifted.i.i.i256.i = lshr i64 %product.i.i.i255.i, 32
  %xored.i.i.i257.i = xor i64 %shifted.i.i.i256.i, %product.i.i.i255.i
  %hash.i.i.i258.i = and i64 %xored.i.i.i257.i, %tbl_size.i.i253.i
  %offset_ptr.i.i259.i = getelementptr i32, ptr %offset_tbl.i.i254.i, i64 %hash.i.i.i258.i
  %offset.i.i260.i = load i32, ptr %offset_ptr.i.i259.i, align 4
  store ptr %vptr.i248.sroa.speculated.i, ptr %98, align 8
  store ptr %.sroa.speculated352.i, ptr %262, align 8
  store ptr %.sroa.speculated346.i, ptr %263, align 8
  store i32 %offset.i.i260.i, ptr %264, align 8
  %2540 = add nuw nsw i32 %.reg2mem193.0677.i, 1
  %2541 = load i32, ptr %219, align 4
  %2542 = icmp slt i32 %2540, %2541
  br i1 %2542, label %2383, label %._crit_edge1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %2393, %2457
  %2543 = phi ptr [ %94, %2457 ], [ %86, %2393 ]
  %2544 = phi ptr [ %95, %2457 ], [ %87, %2393 ]
  %2545 = phi ptr [ %96, %2457 ], [ %88, %2393 ]
  %2546 = phi ptr [ %.sroa.0.i971, %2457 ], [ %.sroa.0680.i, %2393 ]
  %2547 = phi ptr [ %97, %2457 ], [ %89, %2393 ]
  %2548 = load i32, ptr %217, align 4
  store i32 %2548, ptr %2543, align 4
  store i32 1, ptr %2544, align 4
  %2549 = add i32 %2548, 1
  store i32 %2549, ptr %2545, align 4
  %2550 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %2549, ptr %217, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2547, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2546, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i971)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %98)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.i:                                   ; preds = %.cont.cont.i, %._crit_edge.i
  %2551 = load i160, ptr %262, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i971)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %98)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %76)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %77)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %78)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %79)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %80)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %81)
  %2552 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2553 = load ptr, ptr %196, align 8
  %2554 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2553, 0
  %2555 = load ptr, ptr %197, align 8
  %2556 = insertvalue { ptr, ptr, ptr, i32 } %2554, ptr %2555, 1
  %2557 = load ptr, ptr %198, align 8
  %2558 = insertvalue { ptr, ptr, ptr, i32 } %2556, ptr %2557, 2
  %2559 = load i32, ptr %199, align 4
  %2560 = insertvalue { ptr, ptr, ptr, i32 } %2558, i32 %2559, 3
  %hash_coef_ptr.i.i64.i1025 = getelementptr i8, ptr %2553, i64 8
  %tbl_size_ptr.i.i65.i1026 = getelementptr i8, ptr %2553, i64 16
  %offset_tbl_ptr.i.i66.i1027 = getelementptr i8, ptr %2553, i64 40
  %hash_coef.i.i67.i1028 = load i64, ptr %hash_coef_ptr.i.i64.i1025, align 4
  %tbl_size.i.i68.i1029 = load i64, ptr %tbl_size_ptr.i.i65.i1026, align 4
  %offset_tbl.i.i69.i1030 = load ptr, ptr %offset_tbl_ptr.i.i66.i1027, align 8
  %product.i.i.i70.i1031 = mul i64 %hash_coef.i.i67.i1028, -5261542750394134544
  %shifted.i.i.i71.i1032 = lshr i64 %product.i.i.i70.i1031, 32
  %xored.i.i.i72.i1033 = xor i64 %shifted.i.i.i71.i1032, %product.i.i.i70.i1031
  %hash.i.i.i73.i1034 = and i64 %xored.i.i.i72.i1033, %tbl_size.i.i68.i1029
  %offset_ptr.i.i74.i1035 = getelementptr i32, ptr %offset_tbl.i.i69.i1030, i64 %hash.i.i.i73.i1034
  %offset.i.i75.i1036 = load i32, ptr %offset_ptr.i.i74.i1035, align 4
  %eq.i.i1037 = icmp eq i32 %2559, %offset.i.i75.i1036
  call void @llvm.assume(i1 %eq.i.i1037) #30
  %2561 = load ptr, ptr %213, align 8
  %2562 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2561, 0
  %2563 = load ptr, ptr %214, align 8
  %2564 = insertvalue { ptr, ptr, ptr, i32 } %2562, ptr %2563, 1
  %2565 = load ptr, ptr %215, align 8
  %2566 = insertvalue { ptr, ptr, ptr, i32 } %2564, ptr %2565, 2
  %2567 = load i32, ptr %216, align 4
  %2568 = insertvalue { ptr, ptr, ptr, i32 } %2566, i32 %2567, 3
  %hash_coef_ptr.i.i92.i1042 = getelementptr i8, ptr %2561, i64 8
  %tbl_size_ptr.i.i93.i1043 = getelementptr i8, ptr %2561, i64 16
  %offset_tbl_ptr.i.i94.i1044 = getelementptr i8, ptr %2561, i64 40
  %hash_coef.i.i95.i1045 = load i64, ptr %hash_coef_ptr.i.i92.i1042, align 4
  %tbl_size.i.i96.i1046 = load i64, ptr %tbl_size_ptr.i.i93.i1043, align 4
  %offset_tbl.i.i97.i1047 = load ptr, ptr %offset_tbl_ptr.i.i94.i1044, align 8
  %product.i.i.i98.i1048 = mul i64 %hash_coef.i.i95.i1045, -5261542750394134544
  %shifted.i.i.i99.i1049 = lshr i64 %product.i.i.i98.i1048, 32
  %xored.i.i.i100.i1050 = xor i64 %shifted.i.i.i99.i1049, %product.i.i.i98.i1048
  %hash.i.i.i101.i1051 = and i64 %xored.i.i.i100.i1050, %tbl_size.i.i96.i1046
  %offset_ptr.i.i102.i1052 = getelementptr i32, ptr %offset_tbl.i.i97.i1047, i64 %hash.i.i.i101.i1051
  %offset.i.i103.i1053 = load i32, ptr %offset_ptr.i.i102.i1052, align 4
  %eq.i106.i1054 = icmp eq i32 %2567, %offset.i.i103.i1053
  call void @llvm.assume(i1 %eq.i106.i1054) #30
  %2569 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2570 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2553)
  %2571 = sext i32 %2559 to i64
  %2572 = getelementptr ptr, ptr %2553, i64 %2571
  %2573 = getelementptr i8, ptr %2572, i64 64
  %2574 = load ptr, ptr %2573, align 8
  %2575 = call ptr %2574({ ptr, ptr, ptr, i32 } %2560, ptr nonnull %2)
  %2576 = call i32 %2575({ ptr, ptr, ptr, i32 } %2560, { ptr, ptr, ptr, i32 } %2560, ptr nonnull %2)
  %2577 = shl i32 %2576, 1
  %2578 = load i32, ptr %217, align 4
  %2579 = load ptr, ptr %result.i105, align 8
  %2580 = load ptr, ptr %179, align 8
  %2581 = sext i32 %2578 to i64
  %2582 = shl nsw i64 %2581, 5
  %result.i.i.i1057 = call noalias ptr @bump_malloc_inner(i64 noundef %2582, ptr nonnull @current_ptr) #29
  %2583 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2584 = icmp sgt i32 %2576, 0
  br i1 %2584, label %.lr.ph434.i1127, label %._crit_edge395.i1071

.lr.ph434.i1127:                                  ; preds = %._crit_edge1.i
  %invariant.gep.i1070 = getelementptr i8, ptr %2553, i64 120
  %2585 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1130 = getelementptr ptr, ptr %invariant.gep.i1070, i64 %2571
  br label %2586

2586:                                             ; preds = %2608, %.lr.ph434.i1127
  %.reg2mem105.0432.i1128 = phi i32 [ 0, %.lr.ph434.i1127 ], [ %.reg2mem101.0.i1133, %2608 ]
  %.reg2mem103.0431.i1129 = phi i32 [ 0, %.lr.ph434.i1127 ], [ %2609, %2608 ]
  store ptr @_parameterization_Ptri32, ptr %76, align 8
  %2587 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %76)
  %2588 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2553)
  %2589 = load ptr, ptr %gep.i1130, align 8
  store ptr @i32_typ, ptr %77, align 8
  %2590 = call ptr %2589({ ptr, ptr, ptr, i32 } %2560, ptr nonnull %77)
  %2591 = call { ptr, i160 } %2590({ ptr, ptr, ptr, i32 } %2560, { ptr, ptr, ptr, i32 } %2560, ptr nonnull %76, i32 %.reg2mem103.0431.i1129)
  %.fca.0.extract52.i1131 = extractvalue { ptr, i160 } %2591, 0
  %2592 = icmp ne ptr %.fca.0.extract52.i1131, @nil_typ
  %2593 = icmp ne ptr %.fca.0.extract52.i1131, null
  %.not60.i1132 = and i1 %2592, %2593
  br i1 %.not60.i1132, label %2594, label %2608

2594:                                             ; preds = %2586
  %hash_coef_ptr.i.i137.i1160 = getelementptr i8, ptr %.fca.0.extract52.i1131, i64 8
  %tbl_size_ptr.i.i138.i1161 = getelementptr i8, ptr %.fca.0.extract52.i1131, i64 16
  %offset_tbl_ptr.i.i139.i1162 = getelementptr i8, ptr %.fca.0.extract52.i1131, i64 40
  %hash_coef.i.i140.i1163 = load i64, ptr %hash_coef_ptr.i.i137.i1160, align 4
  %tbl_size.i.i141.i1164 = load i64, ptr %tbl_size_ptr.i.i138.i1161, align 4
  %offset_tbl.i.i142.i1165 = load ptr, ptr %offset_tbl_ptr.i.i139.i1162, align 8
  %product.i.i.i143.i1166 = mul i64 %hash_coef.i.i140.i1163, 4015701072841558310
  %shifted.i.i.i144.i1167 = lshr i64 %product.i.i.i143.i1166, 32
  %xored.i.i.i145.i1168 = xor i64 %shifted.i.i.i144.i1167, %product.i.i.i143.i1166
  %hash.i.i.i146.i1169 = and i64 %xored.i.i.i145.i1168, %tbl_size.i.i141.i1164
  %offset_ptr.i.i147.i1170 = getelementptr i32, ptr %offset_tbl.i.i142.i1165, i64 %hash.i.i.i146.i1169
  %offset.i.i148.i1171 = load i32, ptr %offset_ptr.i.i147.i1170, align 4
  %2595 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2596 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2597 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2598 = icmp slt i32 %.reg2mem105.0432.i1128, %2578
  br i1 %2598, label %2599, label %._crit_edge.i1172

2599:                                             ; preds = %2594
  %.fca.1.extract54.i1173 = extractvalue { ptr, i160 } %2591, 1
  %.sroa.351.0.insert.ext.i1174 = zext i32 %offset.i.i148.i1171 to i160
  %.sroa.351.0.insert.shift.i1175 = shl nuw i160 %.sroa.351.0.insert.ext.i1174, 128
  %2600 = and i160 %.fca.1.extract54.i1173, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1176 = or disjoint i160 %.sroa.351.0.insert.shift.i1175, %2600
  %2601 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2602 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2603 = sext i32 %.reg2mem105.0432.i1128 to i64
  %2604 = shl nsw i64 %2603, 5
  %2605 = getelementptr i8, ptr %result.i.i.i1057, i64 %2604
  store ptr %.fca.0.extract52.i1131, ptr %2605, align 8
  %2606 = getelementptr i8, ptr %2605, i64 8
  store i160 %.sroa.049.0.insert.insert.i1176, ptr %2606, align 4
  br label %._crit_edge.i1172

._crit_edge.i1172:                                ; preds = %2599, %2594
  %2607 = add i32 %.reg2mem105.0432.i1128, 1
  br label %2608

2608:                                             ; preds = %._crit_edge.i1172, %2586
  %.reg2mem101.0.i1133 = phi i32 [ %2607, %._crit_edge.i1172 ], [ %.reg2mem105.0432.i1128, %2586 ]
  %2609 = add nuw nsw i32 %.reg2mem103.0431.i1129, 1
  %2610 = icmp slt i32 %2609, %2576
  br i1 %2610, label %2586, label %.lr.ph.i1134

.lr.ph.i1134:                                     ; preds = %2608
  %invariant.gep396.i1135 = getelementptr i8, ptr %2561, i64 120
  %2611 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2612 = sext i32 %2567 to i64
  %gep397.i1138 = getelementptr ptr, ptr %invariant.gep396.i1135, i64 %2612
  br label %2613

2613:                                             ; preds = %2635, %.lr.ph.i1134
  %.reg2mem91.0394.i1136 = phi i32 [ %.reg2mem101.0.i1133, %.lr.ph.i1134 ], [ %.reg2mem87.0.i1141, %2635 ]
  %.reg2mem89.0393.i1137 = phi i32 [ 0, %.lr.ph.i1134 ], [ %2636, %2635 ]
  store ptr @_parameterization_Ptri32, ptr %78, align 8
  %2614 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %78)
  %2615 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2561)
  %2616 = load ptr, ptr %gep397.i1138, align 8
  store ptr @i32_typ, ptr %79, align 8
  %2617 = call ptr %2616({ ptr, ptr, ptr, i32 } %2568, ptr nonnull %79)
  %2618 = call { ptr, i160 } %2617({ ptr, ptr, ptr, i32 } %2568, { ptr, ptr, ptr, i32 } %2568, ptr nonnull %78, i32 %.reg2mem89.0393.i1137)
  %.fca.0.extract42.i1139 = extractvalue { ptr, i160 } %2618, 0
  %2619 = icmp ne ptr %.fca.0.extract42.i1139, @nil_typ
  %2620 = icmp ne ptr %.fca.0.extract42.i1139, null
  %.not62.i1140 = and i1 %2619, %2620
  br i1 %.not62.i1140, label %2621, label %2635

2621:                                             ; preds = %2613
  %hash_coef_ptr.i.i152.i1142 = getelementptr i8, ptr %.fca.0.extract42.i1139, i64 8
  %tbl_size_ptr.i.i153.i1143 = getelementptr i8, ptr %.fca.0.extract42.i1139, i64 16
  %offset_tbl_ptr.i.i154.i1144 = getelementptr i8, ptr %.fca.0.extract42.i1139, i64 40
  %hash_coef.i.i155.i1145 = load i64, ptr %hash_coef_ptr.i.i152.i1142, align 4
  %tbl_size.i.i156.i1146 = load i64, ptr %tbl_size_ptr.i.i153.i1143, align 4
  %offset_tbl.i.i157.i1147 = load ptr, ptr %offset_tbl_ptr.i.i154.i1144, align 8
  %product.i.i.i158.i1148 = mul i64 %hash_coef.i.i155.i1145, 4015701072841558310
  %shifted.i.i.i159.i1149 = lshr i64 %product.i.i.i158.i1148, 32
  %xored.i.i.i160.i1150 = xor i64 %shifted.i.i.i159.i1149, %product.i.i.i158.i1148
  %hash.i.i.i161.i1151 = and i64 %xored.i.i.i160.i1150, %tbl_size.i.i156.i1146
  %offset_ptr.i.i162.i1152 = getelementptr i32, ptr %offset_tbl.i.i157.i1147, i64 %hash.i.i.i161.i1151
  %offset.i.i163.i1153 = load i32, ptr %offset_ptr.i.i162.i1152, align 4
  %2622 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2623 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2624 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2625 = icmp slt i32 %.reg2mem91.0394.i1136, %2578
  br i1 %2625, label %2626, label %._crit_edge1.i1154

2626:                                             ; preds = %2621
  %.fca.1.extract44.i1155 = extractvalue { ptr, i160 } %2618, 1
  %.sroa.3.0.insert.ext.i1156 = zext i32 %offset.i.i163.i1153 to i160
  %.sroa.3.0.insert.shift.i1157 = shl nuw i160 %.sroa.3.0.insert.ext.i1156, 128
  %2627 = and i160 %.fca.1.extract44.i1155, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1158 = or disjoint i160 %.sroa.3.0.insert.shift.i1157, %2627
  %2628 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2629 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2630 = sext i32 %.reg2mem91.0394.i1136 to i64
  %2631 = shl nsw i64 %2630, 5
  %2632 = getelementptr i8, ptr %result.i.i.i1057, i64 %2631
  store ptr %.fca.0.extract42.i1139, ptr %2632, align 8
  %2633 = getelementptr i8, ptr %2632, i64 8
  store i160 %.sroa.040.0.insert.insert.i1158, ptr %2633, align 4
  br label %._crit_edge1.i1154

._crit_edge1.i1154:                               ; preds = %2626, %2621
  %2634 = add i32 %.reg2mem91.0394.i1136, 1
  br label %2635

2635:                                             ; preds = %._crit_edge1.i1154, %2613
  %.reg2mem87.0.i1141 = phi i32 [ %2634, %._crit_edge1.i1154 ], [ %.reg2mem91.0394.i1136, %2613 ]
  %2636 = add nuw nsw i32 %.reg2mem89.0393.i1137, 1
  %2637 = icmp slt i32 %2636, %2576
  br i1 %2637, label %2613, label %._crit_edge395.i1071.loopexit

._crit_edge395.i1071.loopexit:                    ; preds = %2635
  %.pre2594 = load ptr, ptr %result.i105, align 8
  %.pre2595 = load ptr, ptr %179, align 8
  br label %._crit_edge395.i1071

._crit_edge395.i1071:                             ; preds = %._crit_edge395.i1071.loopexit, %._crit_edge1.i
  %2638 = phi ptr [ %2580, %._crit_edge1.i ], [ %.pre2595, %._crit_edge395.i1071.loopexit ]
  %2639 = phi ptr [ %2579, %._crit_edge1.i ], [ %.pre2594, %._crit_edge395.i1071.loopexit ]
  %.reg2mem91.0.lcssa.i1072 = phi i32 [ 0, %._crit_edge1.i ], [ %.reg2mem87.0.i1141, %._crit_edge395.i1071.loopexit ]
  %2640 = call i32 @llvm.smax.i32(i32 %2577, i32 16)
  %result.i166.i1073 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2641 = getelementptr i8, ptr %result.i166.i1073, i64 16
  store ptr @_parameterization_Nil, ptr %2641, align 8
  %result.i167.i1074 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2642 = getelementptr i8, ptr %result.i167.i1074, i64 16
  store ptr %2638, ptr %2642, align 8
  %2643 = getelementptr i8, ptr %result.i167.i1074, i64 8
  store ptr %2639, ptr %2643, align 8
  %2644 = getelementptr i8, ptr %result.i167.i1074, i64 24
  store ptr null, ptr %2644, align 8
  %2645 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1074)
  store ptr @Entry, ptr %result.i167.i1074, align 8
  %2646 = getelementptr i8, ptr %result.i166.i1073, i64 8
  store ptr %result.i167.i1074, ptr %2646, align 8
  %2647 = getelementptr i8, ptr %result.i166.i1073, i64 24
  store ptr null, ptr %2647, align 8
  %2648 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1073)
  store ptr @union_typ, ptr %result.i166.i1073, align 8
  %result.i168.i1075 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1073, ptr %result.i168.i1075, align 8
  %2649 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1075)
  store ptr @Array, ptr %80, align 8
  store ptr %result.i168.i1075, ptr %269, align 8
  store i32 9, ptr %270, align 8
  %2650 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %80)
  %2651 = getelementptr i8, ptr %result.i168.i1075, i64 16
  store i32 %2640, ptr %2651, align 4
  %2652 = getelementptr i8, ptr %result.i168.i1075, i64 20
  store i32 %2640, ptr %2652, align 4
  %2653 = zext nneg i32 %2640 to i64
  %2654 = shl nuw nsw i64 %2653, 5
  %result.i.i416.i1076 = call noalias ptr @bump_malloc_inner(i64 noundef %2654, ptr nonnull @current_ptr) #29
  %2655 = getelementptr i8, ptr %result.i168.i1075, i64 8
  store ptr %result.i.i416.i1076, ptr %2655, align 8
  %2656 = load ptr, ptr %271, align 8
  store ptr @Array, ptr %196, align 8
  store ptr %result.i168.i1075, ptr %197, align 8
  store ptr %2656, ptr %198, align 8
  store i32 9, ptr %199, align 4
  %2657 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i1089 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2658 = getelementptr i8, ptr %result.i183.i1089, i64 16
  store ptr @_parameterization_Nil, ptr %2658, align 8
  %result.i184.i1090 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2659 = getelementptr i8, ptr %result.i184.i1090, i64 16
  store ptr %2638, ptr %2659, align 8
  %2660 = getelementptr i8, ptr %result.i184.i1090, i64 8
  store ptr %2639, ptr %2660, align 8
  %2661 = getelementptr i8, ptr %result.i184.i1090, i64 24
  store ptr null, ptr %2661, align 8
  %2662 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1090)
  store ptr @Entry, ptr %result.i184.i1090, align 8
  %2663 = getelementptr i8, ptr %result.i183.i1089, i64 8
  store ptr %result.i184.i1090, ptr %2663, align 8
  %2664 = getelementptr i8, ptr %result.i183.i1089, i64 24
  store ptr null, ptr %2664, align 8
  %2665 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1089)
  store ptr @union_typ, ptr %result.i183.i1089, align 8
  %result.i185.i1091 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1089, ptr %result.i185.i1091, align 8
  %2666 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1091)
  store ptr @Array, ptr %81, align 8
  store ptr %result.i185.i1091, ptr %272, align 8
  store i32 9, ptr %273, align 8
  %2667 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %81)
  %2668 = getelementptr i8, ptr %result.i185.i1091, i64 16
  store i32 %2640, ptr %2668, align 4
  %2669 = getelementptr i8, ptr %result.i185.i1091, i64 20
  store i32 %2640, ptr %2669, align 4
  %result.i.i430.i1092 = call noalias ptr @bump_malloc_inner(i64 noundef %2654, ptr nonnull @current_ptr) #29
  %2670 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2671 = getelementptr i8, ptr %result.i185.i1091, i64 8
  store ptr %result.i.i430.i1092, ptr %2671, align 8
  %2672 = load ptr, ptr %274, align 8
  store ptr @Array, ptr %213, align 8
  store ptr %result.i185.i1091, ptr %214, align 8
  store ptr %2672, ptr %215, align 8
  store i32 9, ptr %216, align 4
  store i32 0, ptr %217, align 4
  %2673 = icmp sgt i32 %.reg2mem91.0.lcssa.i1072, 0
  br i1 %2673, label %.lr.ph400.i1105, label %HashMap_resize_.exit1178

.lr.ph400.i1105:                                  ; preds = %._crit_edge395.i1071
  %2674 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2675 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2676 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1107

._crit_edge2.i1107:                               ; preds = %._crit_edge2.i1107, %.lr.ph400.i1105
  %.reg2mem77.0398.i1108 = phi i32 [ 0, %.lr.ph400.i1105 ], [ %2690, %._crit_edge2.i1107 ]
  %2677 = zext nneg i32 %.reg2mem77.0398.i1108 to i64
  %2678 = shl nuw nsw i64 %2677, 5
  %2679 = getelementptr i8, ptr %result.i.i.i1057, i64 %2678
  %2680 = load ptr, ptr %2679, align 8
  %2681 = getelementptr i8, ptr %2679, i64 8
  %2682 = load i160, ptr %2681, align 4
  %.sroa.3362.8.extract.trunc.i1111 = trunc i160 %2682 to i64
  %2683 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1111 to ptr
  %.sroa.5363.8.extract.shift.i1112 = lshr i160 %2682, 64
  %.sroa.5363.8.extract.trunc.i1113 = trunc i160 %.sroa.5363.8.extract.shift.i1112 to i64
  %2684 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1113 to ptr
  %hash_coef_ptr.i.i201.i1114 = getelementptr i8, ptr %2680, i64 8
  %tbl_size_ptr.i.i202.i1115 = getelementptr i8, ptr %2680, i64 16
  %offset_tbl_ptr.i.i203.i1116 = getelementptr i8, ptr %2680, i64 40
  %hash_coef.i.i232.i1117 = load i64, ptr %hash_coef_ptr.i.i201.i1114, align 4
  %tbl_size.i.i233.i1118 = load i64, ptr %tbl_size_ptr.i.i202.i1115, align 4
  %offset_tbl.i.i234.i1119 = load ptr, ptr %offset_tbl_ptr.i.i203.i1116, align 8
  %product.i.i.i235.i1120 = mul i64 %hash_coef.i.i232.i1117, 4015701072841558310
  %shifted.i.i.i236.i1121 = lshr i64 %product.i.i.i235.i1120, 32
  %xored.i.i.i237.i1122 = xor i64 %shifted.i.i.i236.i1121, %product.i.i.i235.i1120
  %hash.i.i.i238.i1123 = and i64 %xored.i.i.i237.i1122, %tbl_size.i.i233.i1118
  %offset_ptr.i.i239.i1124 = getelementptr i32, ptr %offset_tbl.i.i234.i1119, i64 %hash.i.i.i238.i1123
  %offset.i.i240.i1125 = load i32, ptr %offset_ptr.i.i239.i1124, align 4
  %2685 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2680, 0
  %2686 = insertvalue { ptr, ptr, ptr, i32 } %2685, ptr %2683, 1
  %2687 = insertvalue { ptr, ptr, ptr, i32 } %2686, ptr %2684, 2
  %2688 = insertvalue { ptr, ptr, ptr, i32 } %2687, i32 %offset.i.i240.i1125, 3
  %2689 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %261, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2688)
  %2690 = add nuw nsw i32 %.reg2mem77.0398.i1108, 1
  %2691 = icmp slt i32 %2690, %.reg2mem91.0.lcssa.i1072
  br i1 %2691, label %._crit_edge2.i1107, label %HashMap_resize_.exit1178

HashMap_resize_.exit1178:                         ; preds = %._crit_edge2.i1107, %._crit_edge395.i1071
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %76)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %77)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %78)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %79)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %80)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %81)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i1179)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1181)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %75)
  %2692 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2693 = load i32, ptr %219, align 4
  %2694 = icmp sgt i32 %2693, 0
  br i1 %2694, label %.lr.ph.i1216, label %._crit_edge1.1.i

.lr.ph.i1216:                                     ; preds = %HashMap_resize_.exit1178
  %2695 = lshr i160 %2551, 64
  %2696 = insertelement <2 x i160> poison, i160 %2695, i64 0
  %2697 = insertelement <2 x i160> %2696, i160 %2551, i64 1
  %2698 = trunc <2 x i160> %2697 to <2 x i64>
  %2699 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2700 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %2701

2701:                                             ; preds = %.cont.cont.i1270, %.lr.ph.i1216
  %offset.i.i260.i12871598 = phi i32 [ 9, %.lr.ph.i1216 ], [ %offset.i.i260.i1287, %.cont.cont.i1270 ]
  %.reg2mem195.0678.i1218 = phi i32 [ 1, %.lr.ph.i1216 ], [ %2856, %.cont.cont.i1270 ]
  %.reg2mem193.0677.i1219 = phi i32 [ 0, %.lr.ph.i1216 ], [ %2861, %.cont.cont.i1270 ]
  %2702 = phi <2 x i64> [ %2698, %.lr.ph.i1216 ], [ %2860, %.cont.cont.i1270 ]
  %2703 = extractelement <2 x i64> %2702, i64 1
  %.sroa.speculated352.i12741594 = inttoptr i64 %2703 to ptr
  %2704 = extractelement <2 x i64> %2702, i64 0
  %.sroa.speculated346.i12751596 = inttoptr i64 %2704 to ptr
  %2705 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i12741594, 1
  %2706 = insertvalue { ptr, ptr, ptr, i32 } %2705, ptr %.sroa.speculated346.i12751596, 2
  %2707 = insertvalue { ptr, ptr, ptr, i32 } %2706, i32 %offset.i.i260.i12871598, 3
  %2708 = sext i32 %offset.i.i260.i12871598 to i64
  %gep1592 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %2708
  %2709 = load ptr, ptr %gep1592, align 8
  %2710 = call ptr %2709({ ptr, ptr, ptr, i32 } %2707, ptr nonnull %2)
  %2711 = call i32 %2710({ ptr, ptr, ptr, i32 } %2707, { ptr, ptr, ptr, i32 } %2707, ptr nonnull %2)
  %2712 = icmp eq i32 %.reg2mem195.0678.i1218, 1
  %2713 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %2712, label %2714, label %2776

2714:                                             ; preds = %2701
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2715 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2716 = load ptr, ptr %196, align 8
  %2717 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2716, 0
  %2718 = load ptr, ptr %197, align 8
  %2719 = insertvalue { ptr, ptr, ptr, i32 } %2717, ptr %2718, 1
  %2720 = load ptr, ptr %198, align 8
  %2721 = insertvalue { ptr, ptr, ptr, i32 } %2719, ptr %2720, 2
  %2722 = load i32, ptr %199, align 4
  %2723 = insertvalue { ptr, ptr, ptr, i32 } %2721, i32 %2722, 3
  %hash_coef_ptr.i.i10.i2819 = getelementptr i8, ptr %2716, i64 8
  %tbl_size_ptr.i.i11.i2820 = getelementptr i8, ptr %2716, i64 16
  %offset_tbl_ptr.i.i12.i2821 = getelementptr i8, ptr %2716, i64 40
  %hash_coef.i.i13.i2822 = load i64, ptr %hash_coef_ptr.i.i10.i2819, align 4
  %tbl_size.i.i14.i2823 = load i64, ptr %tbl_size_ptr.i.i11.i2820, align 4
  %offset_tbl.i.i15.i2824 = load ptr, ptr %offset_tbl_ptr.i.i12.i2821, align 8
  %product.i.i.i16.i2825 = mul i64 %hash_coef.i.i13.i2822, -5261542750394134544
  %shifted.i.i.i17.i2826 = lshr i64 %product.i.i.i16.i2825, 32
  %xored.i.i.i18.i2827 = xor i64 %shifted.i.i.i17.i2826, %product.i.i.i16.i2825
  %hash.i.i.i19.i2828 = and i64 %xored.i.i.i18.i2827, %tbl_size.i.i14.i2823
  %offset_ptr.i.i20.i2829 = getelementptr i32, ptr %offset_tbl.i.i15.i2824, i64 %hash.i.i.i19.i2828
  %offset.i.i21.i2830 = load i32, ptr %offset_ptr.i.i20.i2829, align 4
  %eq.i.i2831 = icmp eq i32 %2722, %offset.i.i21.i2830
  call void @llvm.assume(i1 %eq.i.i2831) #30
  %2724 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2725 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2716)
  %2726 = sext i32 %2722 to i64
  %2727 = getelementptr ptr, ptr %2716, i64 %2726
  %2728 = getelementptr i8, ptr %2727, i64 64
  %2729 = load ptr, ptr %2728, align 8
  %2730 = call ptr %2729({ ptr, ptr, ptr, i32 } %2723, ptr nonnull %2)
  %2731 = call i32 %2730({ ptr, ptr, ptr, i32 } %2723, { ptr, ptr, ptr, i32 } %2723, ptr nonnull %2)
  %2732 = add i32 %2731, -1
  %2733 = and i32 %2732, %2711
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2734 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2735 = load ptr, ptr %196, align 8
  %2736 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2735, 0
  %2737 = load ptr, ptr %197, align 8
  %2738 = insertvalue { ptr, ptr, ptr, i32 } %2736, ptr %2737, 1
  %2739 = load ptr, ptr %198, align 8
  %2740 = insertvalue { ptr, ptr, ptr, i32 } %2738, ptr %2739, 2
  %2741 = load i32, ptr %199, align 4
  %2742 = insertvalue { ptr, ptr, ptr, i32 } %2740, i32 %2741, 3
  %hash_coef_ptr.i.i172.i1292 = getelementptr i8, ptr %2735, i64 8
  %tbl_size_ptr.i.i173.i1293 = getelementptr i8, ptr %2735, i64 16
  %offset_tbl_ptr.i.i174.i1294 = getelementptr i8, ptr %2735, i64 40
  %hash_coef.i.i175.i1295 = load i64, ptr %hash_coef_ptr.i.i172.i1292, align 4
  %tbl_size.i.i176.i1296 = load i64, ptr %tbl_size_ptr.i.i173.i1293, align 4
  %offset_tbl.i.i177.i1297 = load ptr, ptr %offset_tbl_ptr.i.i174.i1294, align 8
  %product.i.i.i178.i1298 = mul i64 %hash_coef.i.i175.i1295, -5261542750394134544
  %shifted.i.i.i179.i1299 = lshr i64 %product.i.i.i178.i1298, 32
  %xored.i.i.i180.i1300 = xor i64 %shifted.i.i.i179.i1299, %product.i.i.i178.i1298
  %hash.i.i.i181.i1301 = and i64 %xored.i.i.i180.i1300, %tbl_size.i.i176.i1296
  %offset_ptr.i.i182.i1302 = getelementptr i32, ptr %offset_tbl.i.i177.i1297, i64 %hash.i.i.i181.i1301
  %offset.i.i183.i1303 = load i32, ptr %offset_ptr.i.i182.i1302, align 4
  %eq.i.i1304 = icmp eq i32 %2741, %offset.i.i183.i1303
  call void @llvm.assume(i1 %eq.i.i1304) #30
  store ptr @_parameterization_Ptri32, ptr %60, align 8
  %2743 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %60)
  %2744 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2735)
  %2745 = sext i32 %2741 to i64
  %2746 = getelementptr ptr, ptr %2735, i64 %2745
  %2747 = getelementptr i8, ptr %2746, i64 120
  %2748 = load ptr, ptr %2747, align 8
  store ptr @i32_typ, ptr %61, align 8
  %2749 = call ptr %2748({ ptr, ptr, ptr, i32 } %2742, ptr nonnull %61)
  %2750 = call { ptr, i160 } %2749({ ptr, ptr, ptr, i32 } %2742, { ptr, ptr, ptr, i32 } %2742, ptr nonnull %60, i32 %2733)
  %.fca.0.extract112.i1305 = extractvalue { ptr, i160 } %2750, 0
  %.sroa.3111.0.insert.ext.i1306 = zext i32 %offset.i.i260.i12871598 to i160
  %.sroa.3111.0.insert.shift.i1307 = shl nuw i160 %.sroa.3111.0.insert.ext.i1306, 128
  %.sroa.2110.0.insert.ext.i1308 = zext i64 %2704 to i160
  %.sroa.2110.0.insert.shift.i1309 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i1308, 64
  %.sroa.2110.0.insert.insert.i1310 = or disjoint i160 %.sroa.2110.0.insert.shift.i1309, %.sroa.3111.0.insert.shift.i1307
  %.sroa.0109.0.insert.ext.i1311 = zext i64 %2703 to i160
  %.sroa.0109.0.insert.insert.i1312 = or disjoint i160 %.sroa.2110.0.insert.insert.i1310, %.sroa.0109.0.insert.ext.i1311
  %2751 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i1312, 1
  %2752 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2753 = load ptr, ptr %196, align 8
  %2754 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2753, 0
  %2755 = load ptr, ptr %197, align 8
  %2756 = insertvalue { ptr, ptr, ptr, i32 } %2754, ptr %2755, 1
  %2757 = load ptr, ptr %198, align 8
  %2758 = insertvalue { ptr, ptr, ptr, i32 } %2756, ptr %2757, 2
  %2759 = load i32, ptr %199, align 4
  %2760 = insertvalue { ptr, ptr, ptr, i32 } %2758, i32 %2759, 3
  %hash_coef_ptr.i.i186.i1317 = getelementptr i8, ptr %2753, i64 8
  %tbl_size_ptr.i.i187.i1318 = getelementptr i8, ptr %2753, i64 16
  %offset_tbl_ptr.i.i188.i1319 = getelementptr i8, ptr %2753, i64 40
  %hash_coef.i.i189.i1320 = load i64, ptr %hash_coef_ptr.i.i186.i1317, align 4
  %tbl_size.i.i190.i1321 = load i64, ptr %tbl_size_ptr.i.i187.i1318, align 4
  %offset_tbl.i.i191.i1322 = load ptr, ptr %offset_tbl_ptr.i.i188.i1319, align 8
  %product.i.i.i192.i1323 = mul i64 %hash_coef.i.i189.i1320, -5261542750394134544
  %shifted.i.i.i193.i1324 = lshr i64 %product.i.i.i192.i1323, 32
  %xored.i.i.i194.i1325 = xor i64 %shifted.i.i.i193.i1324, %product.i.i.i192.i1323
  %hash.i.i.i195.i1326 = and i64 %xored.i.i.i194.i1325, %tbl_size.i.i190.i1321
  %offset_ptr.i.i196.i1327 = getelementptr i32, ptr %offset_tbl.i.i191.i1322, i64 %hash.i.i.i195.i1326
  %offset.i.i197.i1328 = load i32, ptr %offset_ptr.i.i196.i1327, align 4
  %eq.i200.i1329 = icmp eq i32 %2759, %offset.i.i197.i1328
  call void @llvm.assume(i1 %eq.i200.i1329) #30
  %2761 = load ptr, ptr %result.i105, align 8
  %2762 = load ptr, ptr %179, align 8
  %result.i.i1330 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2763 = getelementptr i8, ptr %result.i.i1330, i64 16
  store ptr %2762, ptr %2763, align 8
  %2764 = getelementptr i8, ptr %result.i.i1330, i64 8
  store ptr %2761, ptr %2764, align 8
  %2765 = getelementptr i8, ptr %result.i.i1330, i64 24
  store ptr null, ptr %2765, align 8
  %2766 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1330)
  store ptr @Entry, ptr %result.i.i1330, align 8
  store ptr @_parameterization_Ptri32, ptr %62, align 8
  store ptr %result.i.i1330, ptr %277, align 8
  %2767 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %62)
  %2768 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2753)
  %2769 = sext i32 %2759 to i64
  %2770 = getelementptr ptr, ptr %2753, i64 %2769
  %2771 = getelementptr i8, ptr %2770, i64 128
  %2772 = load ptr, ptr %2771, align 8
  store ptr @i32_typ, ptr %63, align 8
  store ptr @Entry, ptr %278, align 8
  %2773 = call ptr %2772({ ptr, ptr, ptr, i32 } %2760, ptr nonnull %63)
  call void %2773({ ptr, ptr, ptr, i32 } %2760, { ptr, ptr, ptr, i32 } %2760, ptr nonnull %62, i32 %2733, { ptr, i160 } %2751)
  %2774 = icmp ne ptr %.fca.0.extract112.i1305, @nil_typ
  %2775 = icmp ne ptr %.fca.0.extract112.i1305, null
  %.not140.i1331 = and i1 %2774, %2775
  br i1 %.not140.i1331, label %.cont.cont.i1270, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1337.thread

2776:                                             ; preds = %2701
  %2777 = add i32 %2711, 2127912214
  %2778 = shl i32 %2711, 12
  %2779 = add i32 %2777, %2778
  %2780 = ashr i32 %2779, 19
  %2781 = xor i32 %2779, %2780
  %2782 = xor i32 %2781, -949894596
  %2783 = add i32 %2782, 374761393
  %2784 = shl i32 %2782, 5
  %2785 = add i32 %2783, %2784
  %2786 = add i32 %2785, -744332180
  %2787 = shl i32 %2785, 9
  %2788 = xor i32 %2786, %2787
  %2789 = add i32 %2788, -42973499
  %2790 = shl i32 %2788, 3
  %2791 = add i32 %2789, %2790
  %2792 = ashr i32 %2791, 16
  %2793 = xor i32 %2791, %2792
  %2794 = xor i32 %2793, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2795 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2796 = load ptr, ptr %213, align 8
  %2797 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2796, 0
  %2798 = load ptr, ptr %214, align 8
  %2799 = insertvalue { ptr, ptr, ptr, i32 } %2797, ptr %2798, 1
  %2800 = load ptr, ptr %215, align 8
  %2801 = insertvalue { ptr, ptr, ptr, i32 } %2799, ptr %2800, 2
  %2802 = load i32, ptr %216, align 4
  %2803 = insertvalue { ptr, ptr, ptr, i32 } %2801, i32 %2802, 3
  %hash_coef_ptr.i.i10.i2849 = getelementptr i8, ptr %2796, i64 8
  %tbl_size_ptr.i.i11.i2850 = getelementptr i8, ptr %2796, i64 16
  %offset_tbl_ptr.i.i12.i2851 = getelementptr i8, ptr %2796, i64 40
  %hash_coef.i.i13.i2852 = load i64, ptr %hash_coef_ptr.i.i10.i2849, align 4
  %tbl_size.i.i14.i2853 = load i64, ptr %tbl_size_ptr.i.i11.i2850, align 4
  %offset_tbl.i.i15.i2854 = load ptr, ptr %offset_tbl_ptr.i.i12.i2851, align 8
  %product.i.i.i16.i2855 = mul i64 %hash_coef.i.i13.i2852, -5261542750394134544
  %shifted.i.i.i17.i2856 = lshr i64 %product.i.i.i16.i2855, 32
  %xored.i.i.i18.i2857 = xor i64 %shifted.i.i.i17.i2856, %product.i.i.i16.i2855
  %hash.i.i.i19.i2858 = and i64 %xored.i.i.i18.i2857, %tbl_size.i.i14.i2853
  %offset_ptr.i.i20.i2859 = getelementptr i32, ptr %offset_tbl.i.i15.i2854, i64 %hash.i.i.i19.i2858
  %offset.i.i21.i2860 = load i32, ptr %offset_ptr.i.i20.i2859, align 4
  %eq.i.i2861 = icmp eq i32 %2802, %offset.i.i21.i2860
  call void @llvm.assume(i1 %eq.i.i2861) #30
  %2804 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2805 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2796)
  %2806 = sext i32 %2802 to i64
  %2807 = getelementptr ptr, ptr %2796, i64 %2806
  %2808 = getelementptr i8, ptr %2807, i64 64
  %2809 = load ptr, ptr %2808, align 8
  %2810 = call ptr %2809({ ptr, ptr, ptr, i32 } %2803, ptr nonnull %2)
  %2811 = call i32 %2810({ ptr, ptr, ptr, i32 } %2803, { ptr, ptr, ptr, i32 } %2803, ptr nonnull %2)
  %2812 = add i32 %2811, -1
  %2813 = and i32 %2812, %2794
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2814 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2815 = load ptr, ptr %213, align 8
  %2816 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2815, 0
  %2817 = load ptr, ptr %214, align 8
  %2818 = insertvalue { ptr, ptr, ptr, i32 } %2816, ptr %2817, 1
  %2819 = load ptr, ptr %215, align 8
  %2820 = insertvalue { ptr, ptr, ptr, i32 } %2818, ptr %2819, 2
  %2821 = load i32, ptr %216, align 4
  %2822 = insertvalue { ptr, ptr, ptr, i32 } %2820, i32 %2821, 3
  %hash_coef_ptr.i.i202.i1224 = getelementptr i8, ptr %2815, i64 8
  %tbl_size_ptr.i.i203.i1225 = getelementptr i8, ptr %2815, i64 16
  %offset_tbl_ptr.i.i204.i1226 = getelementptr i8, ptr %2815, i64 40
  %hash_coef.i.i205.i1227 = load i64, ptr %hash_coef_ptr.i.i202.i1224, align 4
  %tbl_size.i.i206.i1228 = load i64, ptr %tbl_size_ptr.i.i203.i1225, align 4
  %offset_tbl.i.i207.i1229 = load ptr, ptr %offset_tbl_ptr.i.i204.i1226, align 8
  %product.i.i.i208.i1230 = mul i64 %hash_coef.i.i205.i1227, -5261542750394134544
  %shifted.i.i.i209.i1231 = lshr i64 %product.i.i.i208.i1230, 32
  %xored.i.i.i210.i1232 = xor i64 %shifted.i.i.i209.i1231, %product.i.i.i208.i1230
  %hash.i.i.i211.i1233 = and i64 %xored.i.i.i210.i1232, %tbl_size.i.i206.i1228
  %offset_ptr.i.i212.i1234 = getelementptr i32, ptr %offset_tbl.i.i207.i1229, i64 %hash.i.i.i211.i1233
  %offset.i.i213.i1235 = load i32, ptr %offset_ptr.i.i212.i1234, align 4
  %eq.i216.i1236 = icmp eq i32 %2821, %offset.i.i213.i1235
  call void @llvm.assume(i1 %eq.i216.i1236) #30
  store ptr @_parameterization_Ptri32, ptr %68, align 8
  %2823 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %68)
  %2824 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2815)
  %2825 = sext i32 %2821 to i64
  %2826 = getelementptr ptr, ptr %2815, i64 %2825
  %2827 = getelementptr i8, ptr %2826, i64 120
  %2828 = load ptr, ptr %2827, align 8
  store ptr @i32_typ, ptr %69, align 8
  %2829 = call ptr %2828({ ptr, ptr, ptr, i32 } %2822, ptr nonnull %69)
  %2830 = call { ptr, i160 } %2829({ ptr, ptr, ptr, i32 } %2822, { ptr, ptr, ptr, i32 } %2822, ptr nonnull %68, i32 %2813)
  %.fca.0.extract87.i1237 = extractvalue { ptr, i160 } %2830, 0
  %.sroa.3.0.insert.ext.i1238 = zext i32 %offset.i.i260.i12871598 to i160
  %.sroa.3.0.insert.shift.i1239 = shl nuw i160 %.sroa.3.0.insert.ext.i1238, 128
  %.sroa.2.0.insert.ext.i1240 = zext i64 %2704 to i160
  %.sroa.2.0.insert.shift.i1241 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i1240, 64
  %.sroa.2.0.insert.insert.i1242 = or disjoint i160 %.sroa.2.0.insert.shift.i1241, %.sroa.3.0.insert.shift.i1239
  %.sroa.0.0.insert.ext.i1243 = zext i64 %2703 to i160
  %.sroa.0.0.insert.insert.i1244 = or disjoint i160 %.sroa.2.0.insert.insert.i1242, %.sroa.0.0.insert.ext.i1243
  %2831 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i1244, 1
  %2832 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2833 = load ptr, ptr %213, align 8
  %2834 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2833, 0
  %2835 = load ptr, ptr %214, align 8
  %2836 = insertvalue { ptr, ptr, ptr, i32 } %2834, ptr %2835, 1
  %2837 = load ptr, ptr %215, align 8
  %2838 = insertvalue { ptr, ptr, ptr, i32 } %2836, ptr %2837, 2
  %2839 = load i32, ptr %216, align 4
  %2840 = insertvalue { ptr, ptr, ptr, i32 } %2838, i32 %2839, 3
  %hash_coef_ptr.i.i218.i1249 = getelementptr i8, ptr %2833, i64 8
  %tbl_size_ptr.i.i219.i1250 = getelementptr i8, ptr %2833, i64 16
  %offset_tbl_ptr.i.i220.i1251 = getelementptr i8, ptr %2833, i64 40
  %hash_coef.i.i221.i1252 = load i64, ptr %hash_coef_ptr.i.i218.i1249, align 4
  %tbl_size.i.i222.i1253 = load i64, ptr %tbl_size_ptr.i.i219.i1250, align 4
  %offset_tbl.i.i223.i1254 = load ptr, ptr %offset_tbl_ptr.i.i220.i1251, align 8
  %product.i.i.i224.i1255 = mul i64 %hash_coef.i.i221.i1252, -5261542750394134544
  %shifted.i.i.i225.i1256 = lshr i64 %product.i.i.i224.i1255, 32
  %xored.i.i.i226.i1257 = xor i64 %shifted.i.i.i225.i1256, %product.i.i.i224.i1255
  %hash.i.i.i227.i1258 = and i64 %xored.i.i.i226.i1257, %tbl_size.i.i222.i1253
  %offset_ptr.i.i228.i1259 = getelementptr i32, ptr %offset_tbl.i.i223.i1254, i64 %hash.i.i.i227.i1258
  %offset.i.i229.i1260 = load i32, ptr %offset_ptr.i.i228.i1259, align 4
  %eq.i232.i1261 = icmp eq i32 %2839, %offset.i.i229.i1260
  call void @llvm.assume(i1 %eq.i232.i1261) #30
  %2841 = load ptr, ptr %result.i105, align 8
  %2842 = load ptr, ptr %179, align 8
  %result.i233.i1262 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2843 = getelementptr i8, ptr %result.i233.i1262, i64 16
  store ptr %2842, ptr %2843, align 8
  %2844 = getelementptr i8, ptr %result.i233.i1262, i64 8
  store ptr %2841, ptr %2844, align 8
  %2845 = getelementptr i8, ptr %result.i233.i1262, i64 24
  store ptr null, ptr %2845, align 8
  %2846 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i1262)
  store ptr @Entry, ptr %result.i233.i1262, align 8
  store ptr @_parameterization_Ptri32, ptr %70, align 8
  store ptr %result.i233.i1262, ptr %275, align 8
  %2847 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %70)
  %2848 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2833)
  %2849 = sext i32 %2839 to i64
  %2850 = getelementptr ptr, ptr %2833, i64 %2849
  %2851 = getelementptr i8, ptr %2850, i64 128
  %2852 = load ptr, ptr %2851, align 8
  store ptr @i32_typ, ptr %71, align 8
  store ptr @Entry, ptr %276, align 8
  %2853 = call ptr %2852({ ptr, ptr, ptr, i32 } %2840, ptr nonnull %71)
  call void %2853({ ptr, ptr, ptr, i32 } %2840, { ptr, ptr, ptr, i32 } %2840, ptr nonnull %70, i32 %2813, { ptr, i160 } %2831)
  %2854 = icmp ne ptr %.fca.0.extract87.i1237, @nil_typ
  %2855 = icmp ne ptr %.fca.0.extract87.i1237, null
  %.not138.i1263 = and i1 %2854, %2855
  br i1 %.not138.i1263, label %.cont.cont.i1270, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1337.thread

.cont.cont.i1270:                                 ; preds = %2776, %2714
  %.sink1609 = phi { ptr, i160 } [ %2750, %2714 ], [ %2830, %2776 ]
  %2856 = phi i32 [ 2, %2714 ], [ 1, %2776 ]
  %vptr.i248.sroa.speculated.i1273 = phi ptr [ %.fca.0.extract112.i1305, %2714 ], [ %.fca.0.extract87.i1237, %2776 ]
  %.fca.1.extract89.i1266 = extractvalue { ptr, i160 } %.sink1609, 1
  %.sroa.3407.sroa.4.0.extract.shift.i1267 = lshr i160 %.fca.1.extract89.i1266, 64
  %2857 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i1267 to i64
  %2858 = insertelement <2 x i64> poison, i64 %2857, i64 0
  %2859 = trunc i160 %.fca.1.extract89.i1266 to i64
  %2860 = insertelement <2 x i64> %2858, i64 %2859, i64 1
  %hash_coef_ptr.i.i249.i1276 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1273, i64 8
  %tbl_size_ptr.i.i250.i1277 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1273, i64 16
  %offset_tbl_ptr.i.i251.i1278 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1273, i64 40
  %hash_coef.i.i252.i1279 = load i64, ptr %hash_coef_ptr.i.i249.i1276, align 4
  %tbl_size.i.i253.i1280 = load i64, ptr %tbl_size_ptr.i.i250.i1277, align 4
  %offset_tbl.i.i254.i1281 = load ptr, ptr %offset_tbl_ptr.i.i251.i1278, align 8
  %product.i.i.i255.i1282 = mul i64 %hash_coef.i.i252.i1279, 4015701072841558310
  %shifted.i.i.i256.i1283 = lshr i64 %product.i.i.i255.i1282, 32
  %xored.i.i.i257.i1284 = xor i64 %shifted.i.i.i256.i1283, %product.i.i.i255.i1282
  %hash.i.i.i258.i1285 = and i64 %xored.i.i.i257.i1284, %tbl_size.i.i253.i1280
  %offset_ptr.i.i259.i1286 = getelementptr i32, ptr %offset_tbl.i.i254.i1281, i64 %hash.i.i.i258.i1285
  %offset.i.i260.i1287 = load i32, ptr %offset_ptr.i.i259.i1286, align 4
  %2861 = add nuw nsw i32 %.reg2mem193.0677.i1219, 1
  %2862 = load i32, ptr %219, align 4
  %2863 = icmp slt i32 %2861, %2862
  br i1 %2863, label %2701, label %._crit_edge1.1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1337.thread: ; preds = %2714, %2776
  %2864 = phi ptr [ %72, %2776 ], [ %64, %2714 ]
  %2865 = phi ptr [ %73, %2776 ], [ %65, %2714 ]
  %2866 = phi ptr [ %74, %2776 ], [ %66, %2714 ]
  %2867 = phi ptr [ %.sroa.0.i1181, %2776 ], [ %.sroa.0680.i1179, %2714 ]
  %2868 = phi ptr [ %75, %2776 ], [ %67, %2714 ]
  %2869 = load i32, ptr %217, align 4
  store i32 %2869, ptr %2864, align 4
  store i32 1, ptr %2865, align 4
  %2870 = add i32 %2869, 1
  store i32 %2870, ptr %2866, align 4
  %2871 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %2870, ptr %217, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2868, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2867, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1179)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1181)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %75)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.1.i:                                 ; preds = %.cont.cont.i1270, %HashMap_resize_.exit1178
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1179)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1181)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %75)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %57)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %59)
  %2872 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2873 = load ptr, ptr %196, align 8
  %2874 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2873, 0
  %2875 = load ptr, ptr %197, align 8
  %2876 = insertvalue { ptr, ptr, ptr, i32 } %2874, ptr %2875, 1
  %2877 = load ptr, ptr %198, align 8
  %2878 = insertvalue { ptr, ptr, ptr, i32 } %2876, ptr %2877, 2
  %2879 = load i32, ptr %199, align 4
  %2880 = insertvalue { ptr, ptr, ptr, i32 } %2878, i32 %2879, 3
  %hash_coef_ptr.i.i64.i1355 = getelementptr i8, ptr %2873, i64 8
  %tbl_size_ptr.i.i65.i1356 = getelementptr i8, ptr %2873, i64 16
  %offset_tbl_ptr.i.i66.i1357 = getelementptr i8, ptr %2873, i64 40
  %hash_coef.i.i67.i1358 = load i64, ptr %hash_coef_ptr.i.i64.i1355, align 4
  %tbl_size.i.i68.i1359 = load i64, ptr %tbl_size_ptr.i.i65.i1356, align 4
  %offset_tbl.i.i69.i1360 = load ptr, ptr %offset_tbl_ptr.i.i66.i1357, align 8
  %product.i.i.i70.i1361 = mul i64 %hash_coef.i.i67.i1358, -5261542750394134544
  %shifted.i.i.i71.i1362 = lshr i64 %product.i.i.i70.i1361, 32
  %xored.i.i.i72.i1363 = xor i64 %shifted.i.i.i71.i1362, %product.i.i.i70.i1361
  %hash.i.i.i73.i1364 = and i64 %xored.i.i.i72.i1363, %tbl_size.i.i68.i1359
  %offset_ptr.i.i74.i1365 = getelementptr i32, ptr %offset_tbl.i.i69.i1360, i64 %hash.i.i.i73.i1364
  %offset.i.i75.i1366 = load i32, ptr %offset_ptr.i.i74.i1365, align 4
  %eq.i.i1367 = icmp eq i32 %2879, %offset.i.i75.i1366
  call void @llvm.assume(i1 %eq.i.i1367) #30
  %2881 = load ptr, ptr %213, align 8
  %2882 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2881, 0
  %2883 = load ptr, ptr %214, align 8
  %2884 = insertvalue { ptr, ptr, ptr, i32 } %2882, ptr %2883, 1
  %2885 = load ptr, ptr %215, align 8
  %2886 = insertvalue { ptr, ptr, ptr, i32 } %2884, ptr %2885, 2
  %2887 = load i32, ptr %216, align 4
  %2888 = insertvalue { ptr, ptr, ptr, i32 } %2886, i32 %2887, 3
  %hash_coef_ptr.i.i92.i1372 = getelementptr i8, ptr %2881, i64 8
  %tbl_size_ptr.i.i93.i1373 = getelementptr i8, ptr %2881, i64 16
  %offset_tbl_ptr.i.i94.i1374 = getelementptr i8, ptr %2881, i64 40
  %hash_coef.i.i95.i1375 = load i64, ptr %hash_coef_ptr.i.i92.i1372, align 4
  %tbl_size.i.i96.i1376 = load i64, ptr %tbl_size_ptr.i.i93.i1373, align 4
  %offset_tbl.i.i97.i1377 = load ptr, ptr %offset_tbl_ptr.i.i94.i1374, align 8
  %product.i.i.i98.i1378 = mul i64 %hash_coef.i.i95.i1375, -5261542750394134544
  %shifted.i.i.i99.i1379 = lshr i64 %product.i.i.i98.i1378, 32
  %xored.i.i.i100.i1380 = xor i64 %shifted.i.i.i99.i1379, %product.i.i.i98.i1378
  %hash.i.i.i101.i1381 = and i64 %xored.i.i.i100.i1380, %tbl_size.i.i96.i1376
  %offset_ptr.i.i102.i1382 = getelementptr i32, ptr %offset_tbl.i.i97.i1377, i64 %hash.i.i.i101.i1381
  %offset.i.i103.i1383 = load i32, ptr %offset_ptr.i.i102.i1382, align 4
  %eq.i106.i1384 = icmp eq i32 %2887, %offset.i.i103.i1383
  call void @llvm.assume(i1 %eq.i106.i1384) #30
  %2889 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2890 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2873)
  %2891 = sext i32 %2879 to i64
  %2892 = getelementptr ptr, ptr %2873, i64 %2891
  %2893 = getelementptr i8, ptr %2892, i64 64
  %2894 = load ptr, ptr %2893, align 8
  %2895 = call ptr %2894({ ptr, ptr, ptr, i32 } %2880, ptr nonnull %2)
  %2896 = call i32 %2895({ ptr, ptr, ptr, i32 } %2880, { ptr, ptr, ptr, i32 } %2880, ptr nonnull %2)
  %2897 = shl i32 %2896, 1
  %2898 = load i32, ptr %217, align 4
  %2899 = load ptr, ptr %result.i105, align 8
  %2900 = load ptr, ptr %179, align 8
  %2901 = sext i32 %2898 to i64
  %2902 = shl nsw i64 %2901, 5
  %result.i.i.i1387 = call noalias ptr @bump_malloc_inner(i64 noundef %2902, ptr nonnull @current_ptr) #29
  %2903 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2904 = icmp sgt i32 %2896, 0
  br i1 %2904, label %.lr.ph434.i1457, label %._crit_edge395.i1401

.lr.ph434.i1457:                                  ; preds = %._crit_edge1.1.i
  %invariant.gep.i1400 = getelementptr i8, ptr %2873, i64 120
  %2905 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1460 = getelementptr ptr, ptr %invariant.gep.i1400, i64 %2891
  br label %2906

2906:                                             ; preds = %2928, %.lr.ph434.i1457
  %.reg2mem105.0432.i1458 = phi i32 [ 0, %.lr.ph434.i1457 ], [ %.reg2mem101.0.i1463, %2928 ]
  %.reg2mem103.0431.i1459 = phi i32 [ 0, %.lr.ph434.i1457 ], [ %2929, %2928 ]
  store ptr @_parameterization_Ptri32, ptr %54, align 8
  %2907 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %54)
  %2908 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2873)
  %2909 = load ptr, ptr %gep.i1460, align 8
  store ptr @i32_typ, ptr %55, align 8
  %2910 = call ptr %2909({ ptr, ptr, ptr, i32 } %2880, ptr nonnull %55)
  %2911 = call { ptr, i160 } %2910({ ptr, ptr, ptr, i32 } %2880, { ptr, ptr, ptr, i32 } %2880, ptr nonnull %54, i32 %.reg2mem103.0431.i1459)
  %.fca.0.extract52.i1461 = extractvalue { ptr, i160 } %2911, 0
  %2912 = icmp ne ptr %.fca.0.extract52.i1461, @nil_typ
  %2913 = icmp ne ptr %.fca.0.extract52.i1461, null
  %.not60.i1462 = and i1 %2912, %2913
  br i1 %.not60.i1462, label %2914, label %2928

2914:                                             ; preds = %2906
  %hash_coef_ptr.i.i137.i1490 = getelementptr i8, ptr %.fca.0.extract52.i1461, i64 8
  %tbl_size_ptr.i.i138.i1491 = getelementptr i8, ptr %.fca.0.extract52.i1461, i64 16
  %offset_tbl_ptr.i.i139.i1492 = getelementptr i8, ptr %.fca.0.extract52.i1461, i64 40
  %hash_coef.i.i140.i1493 = load i64, ptr %hash_coef_ptr.i.i137.i1490, align 4
  %tbl_size.i.i141.i1494 = load i64, ptr %tbl_size_ptr.i.i138.i1491, align 4
  %offset_tbl.i.i142.i1495 = load ptr, ptr %offset_tbl_ptr.i.i139.i1492, align 8
  %product.i.i.i143.i1496 = mul i64 %hash_coef.i.i140.i1493, 4015701072841558310
  %shifted.i.i.i144.i1497 = lshr i64 %product.i.i.i143.i1496, 32
  %xored.i.i.i145.i1498 = xor i64 %shifted.i.i.i144.i1497, %product.i.i.i143.i1496
  %hash.i.i.i146.i1499 = and i64 %xored.i.i.i145.i1498, %tbl_size.i.i141.i1494
  %offset_ptr.i.i147.i1500 = getelementptr i32, ptr %offset_tbl.i.i142.i1495, i64 %hash.i.i.i146.i1499
  %offset.i.i148.i1501 = load i32, ptr %offset_ptr.i.i147.i1500, align 4
  %2915 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2916 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2917 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2918 = icmp slt i32 %.reg2mem105.0432.i1458, %2898
  br i1 %2918, label %2919, label %._crit_edge.i1502

2919:                                             ; preds = %2914
  %.fca.1.extract54.i1503 = extractvalue { ptr, i160 } %2911, 1
  %.sroa.351.0.insert.ext.i1504 = zext i32 %offset.i.i148.i1501 to i160
  %.sroa.351.0.insert.shift.i1505 = shl nuw i160 %.sroa.351.0.insert.ext.i1504, 128
  %2920 = and i160 %.fca.1.extract54.i1503, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1506 = or disjoint i160 %.sroa.351.0.insert.shift.i1505, %2920
  %2921 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2922 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2923 = sext i32 %.reg2mem105.0432.i1458 to i64
  %2924 = shl nsw i64 %2923, 5
  %2925 = getelementptr i8, ptr %result.i.i.i1387, i64 %2924
  store ptr %.fca.0.extract52.i1461, ptr %2925, align 8
  %2926 = getelementptr i8, ptr %2925, i64 8
  store i160 %.sroa.049.0.insert.insert.i1506, ptr %2926, align 4
  br label %._crit_edge.i1502

._crit_edge.i1502:                                ; preds = %2919, %2914
  %2927 = add i32 %.reg2mem105.0432.i1458, 1
  br label %2928

2928:                                             ; preds = %._crit_edge.i1502, %2906
  %.reg2mem101.0.i1463 = phi i32 [ %2927, %._crit_edge.i1502 ], [ %.reg2mem105.0432.i1458, %2906 ]
  %2929 = add nuw nsw i32 %.reg2mem103.0431.i1459, 1
  %2930 = icmp slt i32 %2929, %2896
  br i1 %2930, label %2906, label %.lr.ph.i1464

.lr.ph.i1464:                                     ; preds = %2928
  %invariant.gep396.i1465 = getelementptr i8, ptr %2881, i64 120
  %2931 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2932 = sext i32 %2887 to i64
  %gep397.i1468 = getelementptr ptr, ptr %invariant.gep396.i1465, i64 %2932
  br label %2933

2933:                                             ; preds = %2955, %.lr.ph.i1464
  %.reg2mem91.0394.i1466 = phi i32 [ %.reg2mem101.0.i1463, %.lr.ph.i1464 ], [ %.reg2mem87.0.i1471, %2955 ]
  %.reg2mem89.0393.i1467 = phi i32 [ 0, %.lr.ph.i1464 ], [ %2956, %2955 ]
  store ptr @_parameterization_Ptri32, ptr %56, align 8
  %2934 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %56)
  %2935 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2881)
  %2936 = load ptr, ptr %gep397.i1468, align 8
  store ptr @i32_typ, ptr %57, align 8
  %2937 = call ptr %2936({ ptr, ptr, ptr, i32 } %2888, ptr nonnull %57)
  %2938 = call { ptr, i160 } %2937({ ptr, ptr, ptr, i32 } %2888, { ptr, ptr, ptr, i32 } %2888, ptr nonnull %56, i32 %.reg2mem89.0393.i1467)
  %.fca.0.extract42.i1469 = extractvalue { ptr, i160 } %2938, 0
  %2939 = icmp ne ptr %.fca.0.extract42.i1469, @nil_typ
  %2940 = icmp ne ptr %.fca.0.extract42.i1469, null
  %.not62.i1470 = and i1 %2939, %2940
  br i1 %.not62.i1470, label %2941, label %2955

2941:                                             ; preds = %2933
  %hash_coef_ptr.i.i152.i1472 = getelementptr i8, ptr %.fca.0.extract42.i1469, i64 8
  %tbl_size_ptr.i.i153.i1473 = getelementptr i8, ptr %.fca.0.extract42.i1469, i64 16
  %offset_tbl_ptr.i.i154.i1474 = getelementptr i8, ptr %.fca.0.extract42.i1469, i64 40
  %hash_coef.i.i155.i1475 = load i64, ptr %hash_coef_ptr.i.i152.i1472, align 4
  %tbl_size.i.i156.i1476 = load i64, ptr %tbl_size_ptr.i.i153.i1473, align 4
  %offset_tbl.i.i157.i1477 = load ptr, ptr %offset_tbl_ptr.i.i154.i1474, align 8
  %product.i.i.i158.i1478 = mul i64 %hash_coef.i.i155.i1475, 4015701072841558310
  %shifted.i.i.i159.i1479 = lshr i64 %product.i.i.i158.i1478, 32
  %xored.i.i.i160.i1480 = xor i64 %shifted.i.i.i159.i1479, %product.i.i.i158.i1478
  %hash.i.i.i161.i1481 = and i64 %xored.i.i.i160.i1480, %tbl_size.i.i156.i1476
  %offset_ptr.i.i162.i1482 = getelementptr i32, ptr %offset_tbl.i.i157.i1477, i64 %hash.i.i.i161.i1481
  %offset.i.i163.i1483 = load i32, ptr %offset_ptr.i.i162.i1482, align 4
  %2942 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2943 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2944 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2945 = icmp slt i32 %.reg2mem91.0394.i1466, %2898
  br i1 %2945, label %2946, label %._crit_edge1.i1484

2946:                                             ; preds = %2941
  %.fca.1.extract44.i1485 = extractvalue { ptr, i160 } %2938, 1
  %.sroa.3.0.insert.ext.i1486 = zext i32 %offset.i.i163.i1483 to i160
  %.sroa.3.0.insert.shift.i1487 = shl nuw i160 %.sroa.3.0.insert.ext.i1486, 128
  %2947 = and i160 %.fca.1.extract44.i1485, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1488 = or disjoint i160 %.sroa.3.0.insert.shift.i1487, %2947
  %2948 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2949 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2950 = sext i32 %.reg2mem91.0394.i1466 to i64
  %2951 = shl nsw i64 %2950, 5
  %2952 = getelementptr i8, ptr %result.i.i.i1387, i64 %2951
  store ptr %.fca.0.extract42.i1469, ptr %2952, align 8
  %2953 = getelementptr i8, ptr %2952, i64 8
  store i160 %.sroa.040.0.insert.insert.i1488, ptr %2953, align 4
  br label %._crit_edge1.i1484

._crit_edge1.i1484:                               ; preds = %2946, %2941
  %2954 = add i32 %.reg2mem91.0394.i1466, 1
  br label %2955

2955:                                             ; preds = %._crit_edge1.i1484, %2933
  %.reg2mem87.0.i1471 = phi i32 [ %2954, %._crit_edge1.i1484 ], [ %.reg2mem91.0394.i1466, %2933 ]
  %2956 = add nuw nsw i32 %.reg2mem89.0393.i1467, 1
  %2957 = icmp slt i32 %2956, %2896
  br i1 %2957, label %2933, label %._crit_edge395.i1401.loopexit

._crit_edge395.i1401.loopexit:                    ; preds = %2955
  %.pre2596 = load ptr, ptr %result.i105, align 8
  %.pre2597 = load ptr, ptr %179, align 8
  br label %._crit_edge395.i1401

._crit_edge395.i1401:                             ; preds = %._crit_edge395.i1401.loopexit, %._crit_edge1.1.i
  %2958 = phi ptr [ %2900, %._crit_edge1.1.i ], [ %.pre2597, %._crit_edge395.i1401.loopexit ]
  %2959 = phi ptr [ %2899, %._crit_edge1.1.i ], [ %.pre2596, %._crit_edge395.i1401.loopexit ]
  %.reg2mem91.0.lcssa.i1402 = phi i32 [ 0, %._crit_edge1.1.i ], [ %.reg2mem87.0.i1471, %._crit_edge395.i1401.loopexit ]
  %2960 = call i32 @llvm.smax.i32(i32 %2897, i32 16)
  %result.i166.i1403 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2961 = getelementptr i8, ptr %result.i166.i1403, i64 16
  store ptr @_parameterization_Nil, ptr %2961, align 8
  %result.i167.i1404 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2962 = getelementptr i8, ptr %result.i167.i1404, i64 16
  store ptr %2958, ptr %2962, align 8
  %2963 = getelementptr i8, ptr %result.i167.i1404, i64 8
  store ptr %2959, ptr %2963, align 8
  %2964 = getelementptr i8, ptr %result.i167.i1404, i64 24
  store ptr null, ptr %2964, align 8
  %2965 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1404)
  store ptr @Entry, ptr %result.i167.i1404, align 8
  %2966 = getelementptr i8, ptr %result.i166.i1403, i64 8
  store ptr %result.i167.i1404, ptr %2966, align 8
  %2967 = getelementptr i8, ptr %result.i166.i1403, i64 24
  store ptr null, ptr %2967, align 8
  %2968 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1403)
  store ptr @union_typ, ptr %result.i166.i1403, align 8
  %result.i168.i1405 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1403, ptr %result.i168.i1405, align 8
  %2969 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1405)
  store ptr @Array, ptr %58, align 8
  store ptr %result.i168.i1405, ptr %279, align 8
  store i32 9, ptr %280, align 8
  %2970 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %58)
  %2971 = getelementptr i8, ptr %result.i168.i1405, i64 16
  store i32 %2960, ptr %2971, align 4
  %2972 = getelementptr i8, ptr %result.i168.i1405, i64 20
  store i32 %2960, ptr %2972, align 4
  %2973 = zext nneg i32 %2960 to i64
  %2974 = shl nuw nsw i64 %2973, 5
  %result.i.i416.i1406 = call noalias ptr @bump_malloc_inner(i64 noundef %2974, ptr nonnull @current_ptr) #29
  %2975 = getelementptr i8, ptr %result.i168.i1405, i64 8
  store ptr %result.i.i416.i1406, ptr %2975, align 8
  %2976 = load ptr, ptr %281, align 8
  store ptr @Array, ptr %196, align 8
  store ptr %result.i168.i1405, ptr %197, align 8
  store ptr %2976, ptr %198, align 8
  store i32 9, ptr %199, align 4
  %result.i183.i1419 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2977 = getelementptr i8, ptr %result.i183.i1419, i64 16
  store ptr @_parameterization_Nil, ptr %2977, align 8
  %result.i184.i1420 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2978 = getelementptr i8, ptr %result.i184.i1420, i64 16
  store ptr %2958, ptr %2978, align 8
  %2979 = getelementptr i8, ptr %result.i184.i1420, i64 8
  store ptr %2959, ptr %2979, align 8
  %2980 = getelementptr i8, ptr %result.i184.i1420, i64 24
  store ptr null, ptr %2980, align 8
  %2981 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1420)
  store ptr @Entry, ptr %result.i184.i1420, align 8
  %2982 = getelementptr i8, ptr %result.i183.i1419, i64 8
  store ptr %result.i184.i1420, ptr %2982, align 8
  %2983 = getelementptr i8, ptr %result.i183.i1419, i64 24
  store ptr null, ptr %2983, align 8
  %2984 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1419)
  store ptr @union_typ, ptr %result.i183.i1419, align 8
  %result.i185.i1421 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1419, ptr %result.i185.i1421, align 8
  %2985 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1421)
  store ptr @Array, ptr %59, align 8
  store ptr %result.i185.i1421, ptr %282, align 8
  store i32 9, ptr %283, align 8
  %2986 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %59)
  %2987 = getelementptr i8, ptr %result.i185.i1421, i64 16
  store i32 %2960, ptr %2987, align 4
  %2988 = getelementptr i8, ptr %result.i185.i1421, i64 20
  store i32 %2960, ptr %2988, align 4
  %result.i.i430.i1422 = call noalias ptr @bump_malloc_inner(i64 noundef %2974, ptr nonnull @current_ptr) #29
  %2989 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2990 = getelementptr i8, ptr %result.i185.i1421, i64 8
  store ptr %result.i.i430.i1422, ptr %2990, align 8
  %2991 = load ptr, ptr %284, align 8
  store ptr @Array, ptr %213, align 8
  store ptr %result.i185.i1421, ptr %214, align 8
  store ptr %2991, ptr %215, align 8
  store i32 9, ptr %216, align 4
  %2992 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 0, ptr %217, align 4
  %2993 = icmp sgt i32 %.reg2mem91.0.lcssa.i1402, 0
  br i1 %2993, label %.lr.ph400.i1435, label %HashMap_resize_.exit1508

.lr.ph400.i1435:                                  ; preds = %._crit_edge395.i1401
  %2994 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2995 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2996 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1437

._crit_edge2.i1437:                               ; preds = %._crit_edge2.i1437, %.lr.ph400.i1435
  %.reg2mem77.0398.i1438 = phi i32 [ 0, %.lr.ph400.i1435 ], [ %3010, %._crit_edge2.i1437 ]
  %2997 = zext nneg i32 %.reg2mem77.0398.i1438 to i64
  %2998 = shl nuw nsw i64 %2997, 5
  %2999 = getelementptr i8, ptr %result.i.i.i1387, i64 %2998
  %3000 = load ptr, ptr %2999, align 8
  %3001 = getelementptr i8, ptr %2999, i64 8
  %3002 = load i160, ptr %3001, align 4
  %.sroa.3362.8.extract.trunc.i1441 = trunc i160 %3002 to i64
  %3003 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1441 to ptr
  %.sroa.5363.8.extract.shift.i1442 = lshr i160 %3002, 64
  %.sroa.5363.8.extract.trunc.i1443 = trunc i160 %.sroa.5363.8.extract.shift.i1442 to i64
  %3004 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1443 to ptr
  %hash_coef_ptr.i.i201.i1444 = getelementptr i8, ptr %3000, i64 8
  %tbl_size_ptr.i.i202.i1445 = getelementptr i8, ptr %3000, i64 16
  %offset_tbl_ptr.i.i203.i1446 = getelementptr i8, ptr %3000, i64 40
  %hash_coef.i.i232.i1447 = load i64, ptr %hash_coef_ptr.i.i201.i1444, align 4
  %tbl_size.i.i233.i1448 = load i64, ptr %tbl_size_ptr.i.i202.i1445, align 4
  %offset_tbl.i.i234.i1449 = load ptr, ptr %offset_tbl_ptr.i.i203.i1446, align 8
  %product.i.i.i235.i1450 = mul i64 %hash_coef.i.i232.i1447, 4015701072841558310
  %shifted.i.i.i236.i1451 = lshr i64 %product.i.i.i235.i1450, 32
  %xored.i.i.i237.i1452 = xor i64 %shifted.i.i.i236.i1451, %product.i.i.i235.i1450
  %hash.i.i.i238.i1453 = and i64 %xored.i.i.i237.i1452, %tbl_size.i.i233.i1448
  %offset_ptr.i.i239.i1454 = getelementptr i32, ptr %offset_tbl.i.i234.i1449, i64 %hash.i.i.i238.i1453
  %offset.i.i240.i1455 = load i32, ptr %offset_ptr.i.i239.i1454, align 4
  %3005 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3000, 0
  %3006 = insertvalue { ptr, ptr, ptr, i32 } %3005, ptr %3003, 1
  %3007 = insertvalue { ptr, ptr, ptr, i32 } %3006, ptr %3004, 2
  %3008 = insertvalue { ptr, ptr, ptr, i32 } %3007, i32 %offset.i.i240.i1455, 3
  %3009 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %261, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %3008)
  %3010 = add nuw nsw i32 %.reg2mem77.0398.i1438, 1
  %3011 = icmp slt i32 %3010, %.reg2mem91.0.lcssa.i1402
  br i1 %3011, label %._crit_edge2.i1437, label %HashMap_resize_.exit1508

HashMap_resize_.exit1508:                         ; preds = %._crit_edge2.i1437, %._crit_edge395.i1401
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %57)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %59)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1337.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %1824, %2020, %HashMap_resize_.exit1508
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %120)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %121)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %122)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %123)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %124)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %125)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %126)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %127)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %128)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %129)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %130)
  %3012 = sext i32 %489 to i64
  %3013 = add i64 %.reg2mem132.0238, %3012
  %3014 = add nsw i32 %.reg2mem130.0237, 1
  br label %3015

3015:                                             ; preds = %HashMap_insert_keyK_valueV.exit, %HashMap_get_keyK.exit
  %.reg2mem124.0 = phi i32 [ %3014, %HashMap_insert_keyK_valueV.exit ], [ %.reg2mem130.0237, %HashMap_get_keyK.exit ]
  %.reg2mem126.0 = phi i64 [ %3013, %HashMap_insert_keyK_valueV.exit ], [ %.reg2mem132.0238, %HashMap_get_keyK.exit ]
  %3016 = add nuw nsw i32 %.reg2mem128.0236, 1
  %3017 = icmp slt i32 %.reg2mem124.0, %0
  %3018 = icmp slt i32 %3016, %220
  %3019 = and i1 %3018, %3017
  br i1 %3019, label %317, label %._crit_edge

._crit_edge:                                      ; preds = %3015, %1
  %.reg2mem130.0.lcssa = phi i32 [ 0, %1 ], [ %.reg2mem124.0, %3015 ]
  %.reg2mem132.0.lcssa = phi i64 [ 0, %1 ], [ %.reg2mem126.0, %3015 ]
  %3020 = call i32 @llvm.smin.i32(i32 %.reg2mem130.0.lcssa, i32 %0)
  %3021 = call i64 @clock()
  %3022 = icmp sgt i32 %3020, 0
  br i1 %3022, label %.lr.ph245, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit169

.lr.ph245:                                        ; preds = %._crit_edge
  %3023 = getelementptr inbounds i8, ptr %135, i64 8
  %3024 = getelementptr inbounds i8, ptr %135, i64 24
  %3025 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %3026 = load ptr, ptr %178, align 8
  %invariant.gep = getelementptr i8, ptr %3026, i64 8
  %3027 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3028 = getelementptr i8, ptr %result.i, i64 40
  %3029 = getelementptr i8, ptr %result.i, i64 72
  br label %3030

3030:                                             ; preds = %.lr.ph245, %3223
  %.reg2mem110.0243 = phi i64 [ 0, %.lr.ph245 ], [ %.reg2mem104.0, %3223 ]
  %.reg2mem108.0242 = phi i1 [ true, %.lr.ph245 ], [ %3224, %3223 ]
  %.reg2mem106.0241 = phi i32 [ 0, %.lr.ph245 ], [ %3225, %3223 ]
  %3031 = zext nneg i32 %.reg2mem106.0241 to i64
  %3032 = shl nuw nsw i64 %3031, 5
  %gep = getelementptr i8, ptr %invariant.gep, i64 %3032
  %3033 = load i160, ptr %gep, align 4
  %.sroa.034.0.insert.ext = and i160 %3033, 4294967295
  %3034 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.034.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i706)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i707)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i708)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i709)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i710)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i711)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i712)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i713)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %108)
  %3035 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3036 = load ptr, ptr %144, align 8
  %3037 = call i32 %3036({ ptr, i160 } %3034)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3038 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3039 = load ptr, ptr %156, align 8
  %3040 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3039, 0
  %3041 = load ptr, ptr %157, align 8
  %3042 = insertvalue { ptr, ptr, ptr, i32 } %3040, ptr %3041, 1
  %3043 = load ptr, ptr %3028, align 8
  %3044 = insertvalue { ptr, ptr, ptr, i32 } %3042, ptr %3043, 2
  %3045 = load i32, ptr %158, align 4
  %3046 = insertvalue { ptr, ptr, ptr, i32 } %3044, i32 %3045, 3
  %hash_coef_ptr.i.i10.i2506 = getelementptr i8, ptr %3039, i64 8
  %tbl_size_ptr.i.i11.i2507 = getelementptr i8, ptr %3039, i64 16
  %offset_tbl_ptr.i.i12.i2508 = getelementptr i8, ptr %3039, i64 40
  %hash_coef.i.i13.i2509 = load i64, ptr %hash_coef_ptr.i.i10.i2506, align 4
  %tbl_size.i.i14.i2510 = load i64, ptr %tbl_size_ptr.i.i11.i2507, align 4
  %offset_tbl.i.i15.i2511 = load ptr, ptr %offset_tbl_ptr.i.i12.i2508, align 8
  %product.i.i.i16.i2512 = mul i64 %hash_coef.i.i13.i2509, -5261542750394134544
  %shifted.i.i.i17.i2513 = lshr i64 %product.i.i.i16.i2512, 32
  %xored.i.i.i18.i2514 = xor i64 %shifted.i.i.i17.i2513, %product.i.i.i16.i2512
  %hash.i.i.i19.i2515 = and i64 %xored.i.i.i18.i2514, %tbl_size.i.i14.i2510
  %offset_ptr.i.i20.i2516 = getelementptr i32, ptr %offset_tbl.i.i15.i2511, i64 %hash.i.i.i19.i2515
  %offset.i.i21.i2517 = load i32, ptr %offset_ptr.i.i20.i2516, align 4
  %eq.i.i2518 = icmp eq i32 %3045, %offset.i.i21.i2517
  call void @llvm.assume(i1 %eq.i.i2518) #30
  %3047 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3048 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3039)
  %3049 = sext i32 %3045 to i64
  %3050 = getelementptr ptr, ptr %3039, i64 %3049
  %3051 = getelementptr i8, ptr %3050, i64 64
  %3052 = load ptr, ptr %3051, align 8
  %3053 = call ptr %3052({ ptr, ptr, ptr, i32 } %3046, ptr nonnull %2)
  %3054 = call i32 %3053({ ptr, ptr, ptr, i32 } %3046, { ptr, ptr, ptr, i32 } %3046, ptr nonnull %2)
  %3055 = add i32 %3054, -1
  %3056 = and i32 %3055, %3037
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3057 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3058 = load ptr, ptr %156, align 8
  %3059 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3058, 0
  %3060 = load ptr, ptr %157, align 8
  %3061 = insertvalue { ptr, ptr, ptr, i32 } %3059, ptr %3060, 1
  %3062 = load ptr, ptr %3028, align 8
  %3063 = insertvalue { ptr, ptr, ptr, i32 } %3061, ptr %3062, 2
  %3064 = load i32, ptr %158, align 4
  %3065 = insertvalue { ptr, ptr, ptr, i32 } %3063, i32 %3064, 3
  %hash_coef_ptr.i.i130.i730 = getelementptr i8, ptr %3058, i64 8
  %tbl_size_ptr.i.i131.i731 = getelementptr i8, ptr %3058, i64 16
  %offset_tbl_ptr.i.i132.i732 = getelementptr i8, ptr %3058, i64 40
  %hash_coef.i.i133.i733 = load i64, ptr %hash_coef_ptr.i.i130.i730, align 4
  %tbl_size.i.i134.i734 = load i64, ptr %tbl_size_ptr.i.i131.i731, align 4
  %offset_tbl.i.i135.i735 = load ptr, ptr %offset_tbl_ptr.i.i132.i732, align 8
  %product.i.i.i136.i736 = mul i64 %hash_coef.i.i133.i733, -5261542750394134544
  %shifted.i.i.i137.i737 = lshr i64 %product.i.i.i136.i736, 32
  %xored.i.i.i138.i738 = xor i64 %shifted.i.i.i137.i737, %product.i.i.i136.i736
  %hash.i.i.i139.i739 = and i64 %xored.i.i.i138.i738, %tbl_size.i.i134.i734
  %offset_ptr.i.i140.i740 = getelementptr i32, ptr %offset_tbl.i.i135.i735, i64 %hash.i.i.i139.i739
  %offset.i.i141.i741 = load i32, ptr %offset_ptr.i.i140.i740, align 4
  %eq.i.i742 = icmp eq i32 %3064, %offset.i.i141.i741
  call void @llvm.assume(i1 %eq.i.i742) #30
  store ptr @_parameterization_Ptri32, ptr %107, align 8
  %3066 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %107)
  %3067 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3058)
  %3068 = sext i32 %3064 to i64
  %3069 = getelementptr ptr, ptr %3058, i64 %3068
  %3070 = getelementptr i8, ptr %3069, i64 120
  %3071 = load ptr, ptr %3070, align 8
  store ptr @i32_typ, ptr %108, align 8
  %3072 = call ptr %3071({ ptr, ptr, ptr, i32 } %3065, ptr nonnull %108)
  %3073 = call { ptr, i160 } %3072({ ptr, ptr, ptr, i32 } %3065, { ptr, ptr, ptr, i32 } %3065, ptr nonnull %107, i32 %3056)
  %.fca.0.extract.i743 = extractvalue { ptr, i160 } %3073, 0
  %3074 = icmp ne ptr %.fca.0.extract.i743, @nil_typ
  %3075 = icmp ne ptr %.fca.0.extract.i743, null
  %.not126.i744 = and i1 %3074, %3075
  br i1 %.not126.i744, label %3076, label %.critedge.i745

3076:                                             ; preds = %3030
  %.fca.1.extract.i791 = extractvalue { ptr, i160 } %3073, 1
  %.sroa.5.8.extract.trunc.i792 = trunc i160 %.fca.1.extract.i791 to i64
  %3077 = inttoptr i64 %.sroa.5.8.extract.trunc.i792 to ptr
  %.sroa.9.8.extract.shift.i793 = lshr i160 %.fca.1.extract.i791, 64
  %.sroa.9.8.extract.trunc.i794 = trunc i160 %.sroa.9.8.extract.shift.i793 to i64
  %3078 = inttoptr i64 %.sroa.9.8.extract.trunc.i794 to ptr
  %hash_coef_ptr.i.i144.i795 = getelementptr i8, ptr %.fca.0.extract.i743, i64 8
  %tbl_size_ptr.i.i145.i796 = getelementptr i8, ptr %.fca.0.extract.i743, i64 16
  %offset_tbl_ptr.i.i146.i797 = getelementptr i8, ptr %.fca.0.extract.i743, i64 40
  %hash_coef.i.i147.i798 = load i64, ptr %hash_coef_ptr.i.i144.i795, align 4
  %tbl_size.i.i148.i799 = load i64, ptr %tbl_size_ptr.i.i145.i796, align 4
  %offset_tbl.i.i149.i800 = load ptr, ptr %offset_tbl_ptr.i.i146.i797, align 8
  %product.i.i.i150.i801 = mul i64 %hash_coef.i.i147.i798, 4015701072841558310
  %shifted.i.i.i151.i802 = lshr i64 %product.i.i.i150.i801, 32
  %xored.i.i.i152.i803 = xor i64 %shifted.i.i.i151.i802, %product.i.i.i150.i801
  %hash.i.i.i153.i804 = and i64 %xored.i.i.i152.i803, %tbl_size.i.i148.i799
  %offset_ptr.i.i154.i805 = getelementptr i32, ptr %offset_tbl.i.i149.i800, i64 %hash.i.i.i153.i804
  %offset.i.i155.i806 = load i32, ptr %offset_ptr.i.i154.i805, align 4
  %3079 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i743, 0
  %3080 = insertvalue { ptr, ptr, ptr, i32 } %3079, ptr %3077, 1
  %3081 = insertvalue { ptr, ptr, ptr, i32 } %3080, ptr %3078, 2
  %3082 = insertvalue { ptr, ptr, ptr, i32 } %3081, i32 %offset.i.i155.i806, 3
  %3083 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3084 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3085 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i743)
  %3086 = sext i32 %offset.i.i155.i806 to i64
  %3087 = getelementptr ptr, ptr %.fca.0.extract.i743, i64 %3086
  %3088 = getelementptr i8, ptr %3087, i64 64
  %3089 = load ptr, ptr %3088, align 8
  %3090 = call ptr %3089({ ptr, ptr, ptr, i32 } %3082, ptr nonnull %2)
  %3091 = call i32 %3090({ ptr, ptr, ptr, i32 } %3082, { ptr, ptr, ptr, i32 } %3082, ptr nonnull %2)
  %3092 = icmp eq i32 %3091, %3037
  %3093 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3094 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3095 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i743)
  %3096 = getelementptr i8, ptr %3087, i64 48
  %3097 = load ptr, ptr %3096, align 8
  %3098 = call ptr %3097({ ptr, ptr, ptr, i32 } %3082, ptr nonnull %2)
  %3099 = call { ptr, i160 } %3098({ ptr, ptr, ptr, i32 } %3082, { ptr, ptr, ptr, i32 } %3082, ptr nonnull %2)
  %3100 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3101 = load ptr, ptr %145, align 8
  %3102 = call i1 %3101({ ptr, i160 } %3099, { ptr, i160 } %3034)
  %3103 = and i1 %3092, %3102
  br i1 %3103, label %HashMap_get_keyK.exit808, label %.critedge.i745

.critedge.i745:                                   ; preds = %3076, %3030
  %3104 = add i32 %3037, 2127912214
  %3105 = shl i32 %3037, 12
  %3106 = add i32 %3104, %3105
  %3107 = ashr i32 %3106, 19
  %3108 = xor i32 %3106, %3107
  %3109 = xor i32 %3108, -949894596
  %3110 = add i32 %3109, 374761393
  %3111 = shl i32 %3109, 5
  %3112 = add i32 %3110, %3111
  %3113 = add i32 %3112, -744332180
  %3114 = shl i32 %3112, 9
  %3115 = xor i32 %3113, %3114
  %3116 = add i32 %3115, -42973499
  %3117 = shl i32 %3115, 3
  %3118 = add i32 %3116, %3117
  %3119 = ashr i32 %3118, 16
  %3120 = xor i32 %3118, %3119
  %3121 = xor i32 %3120, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3122 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3123 = load ptr, ptr %169, align 8
  %3124 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3123, 0
  %3125 = load ptr, ptr %170, align 8
  %3126 = insertvalue { ptr, ptr, ptr, i32 } %3124, ptr %3125, 1
  %3127 = load ptr, ptr %3029, align 8
  %3128 = insertvalue { ptr, ptr, ptr, i32 } %3126, ptr %3127, 2
  %3129 = load i32, ptr %171, align 4
  %3130 = insertvalue { ptr, ptr, ptr, i32 } %3128, i32 %3129, 3
  %hash_coef_ptr.i.i10.i2537 = getelementptr i8, ptr %3123, i64 8
  %tbl_size_ptr.i.i11.i2538 = getelementptr i8, ptr %3123, i64 16
  %offset_tbl_ptr.i.i12.i2539 = getelementptr i8, ptr %3123, i64 40
  %hash_coef.i.i13.i2540 = load i64, ptr %hash_coef_ptr.i.i10.i2537, align 4
  %tbl_size.i.i14.i2541 = load i64, ptr %tbl_size_ptr.i.i11.i2538, align 4
  %offset_tbl.i.i15.i2542 = load ptr, ptr %offset_tbl_ptr.i.i12.i2539, align 8
  %product.i.i.i16.i2543 = mul i64 %hash_coef.i.i13.i2540, -5261542750394134544
  %shifted.i.i.i17.i2544 = lshr i64 %product.i.i.i16.i2543, 32
  %xored.i.i.i18.i2545 = xor i64 %shifted.i.i.i17.i2544, %product.i.i.i16.i2543
  %hash.i.i.i19.i2546 = and i64 %xored.i.i.i18.i2545, %tbl_size.i.i14.i2541
  %offset_ptr.i.i20.i2547 = getelementptr i32, ptr %offset_tbl.i.i15.i2542, i64 %hash.i.i.i19.i2546
  %offset.i.i21.i2548 = load i32, ptr %offset_ptr.i.i20.i2547, align 4
  %eq.i.i2549 = icmp eq i32 %3129, %offset.i.i21.i2548
  call void @llvm.assume(i1 %eq.i.i2549) #30
  %3131 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3132 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3123)
  %3133 = sext i32 %3129 to i64
  %3134 = getelementptr ptr, ptr %3123, i64 %3133
  %3135 = getelementptr i8, ptr %3134, i64 64
  %3136 = load ptr, ptr %3135, align 8
  %3137 = call ptr %3136({ ptr, ptr, ptr, i32 } %3130, ptr nonnull %2)
  %3138 = call i32 %3137({ ptr, ptr, ptr, i32 } %3130, { ptr, ptr, ptr, i32 } %3130, ptr nonnull %2)
  %3139 = add i32 %3138, -1
  %3140 = and i32 %3139, %3121
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3141 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3142 = load ptr, ptr %169, align 8
  %3143 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3142, 0
  %3144 = load ptr, ptr %170, align 8
  %3145 = insertvalue { ptr, ptr, ptr, i32 } %3143, ptr %3144, 1
  %3146 = load ptr, ptr %3029, align 8
  %3147 = insertvalue { ptr, ptr, ptr, i32 } %3145, ptr %3146, 2
  %3148 = load i32, ptr %171, align 4
  %3149 = insertvalue { ptr, ptr, ptr, i32 } %3147, i32 %3148, 3
  %hash_coef_ptr.i.i158.i750 = getelementptr i8, ptr %3142, i64 8
  %tbl_size_ptr.i.i159.i751 = getelementptr i8, ptr %3142, i64 16
  %offset_tbl_ptr.i.i160.i752 = getelementptr i8, ptr %3142, i64 40
  %hash_coef.i.i161.i753 = load i64, ptr %hash_coef_ptr.i.i158.i750, align 4
  %tbl_size.i.i162.i754 = load i64, ptr %tbl_size_ptr.i.i159.i751, align 4
  %offset_tbl.i.i163.i755 = load ptr, ptr %offset_tbl_ptr.i.i160.i752, align 8
  %product.i.i.i164.i756 = mul i64 %hash_coef.i.i161.i753, -5261542750394134544
  %shifted.i.i.i165.i757 = lshr i64 %product.i.i.i164.i756, 32
  %xored.i.i.i166.i758 = xor i64 %shifted.i.i.i165.i757, %product.i.i.i164.i756
  %hash.i.i.i167.i759 = and i64 %xored.i.i.i166.i758, %tbl_size.i.i162.i754
  %offset_ptr.i.i168.i760 = getelementptr i32, ptr %offset_tbl.i.i163.i755, i64 %hash.i.i.i167.i759
  %offset.i.i169.i761 = load i32, ptr %offset_ptr.i.i168.i760, align 4
  %eq.i172.i762 = icmp eq i32 %3148, %offset.i.i169.i761
  call void @llvm.assume(i1 %eq.i172.i762) #30
  store ptr @_parameterization_Ptri32, ptr %105, align 8
  %3150 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %105)
  %3151 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3142)
  %3152 = sext i32 %3148 to i64
  %3153 = getelementptr ptr, ptr %3142, i64 %3152
  %3154 = getelementptr i8, ptr %3153, i64 120
  %3155 = load ptr, ptr %3154, align 8
  store ptr @i32_typ, ptr %106, align 8
  %3156 = call ptr %3155({ ptr, ptr, ptr, i32 } %3149, ptr nonnull %106)
  %3157 = call { ptr, i160 } %3156({ ptr, ptr, ptr, i32 } %3149, { ptr, ptr, ptr, i32 } %3149, ptr nonnull %105, i32 %3140)
  %.fca.0.extract57.i763 = extractvalue { ptr, i160 } %3157, 0
  %3158 = icmp ne ptr %.fca.0.extract57.i763, @nil_typ
  %3159 = icmp ne ptr %.fca.0.extract57.i763, null
  %.not128.i764 = and i1 %3158, %3159
  br i1 %.not128.i764, label %3160, label %HashMap_get_keyK.exit808.thread

3160:                                             ; preds = %.critedge.i745
  %.fca.1.extract59.i765 = extractvalue { ptr, i160 } %3157, 1
  %.sroa.6.8.extract.trunc.i766 = trunc i160 %.fca.1.extract59.i765 to i64
  %3161 = inttoptr i64 %.sroa.6.8.extract.trunc.i766 to ptr
  %.sroa.11.8.extract.shift.i767 = lshr i160 %.fca.1.extract59.i765, 64
  %.sroa.11.8.extract.trunc.i768 = trunc i160 %.sroa.11.8.extract.shift.i767 to i64
  %3162 = inttoptr i64 %.sroa.11.8.extract.trunc.i768 to ptr
  %hash_coef_ptr.i.i174.i769 = getelementptr i8, ptr %.fca.0.extract57.i763, i64 8
  %tbl_size_ptr.i.i175.i770 = getelementptr i8, ptr %.fca.0.extract57.i763, i64 16
  %offset_tbl_ptr.i.i176.i771 = getelementptr i8, ptr %.fca.0.extract57.i763, i64 40
  %hash_coef.i.i177.i772 = load i64, ptr %hash_coef_ptr.i.i174.i769, align 4
  %tbl_size.i.i178.i773 = load i64, ptr %tbl_size_ptr.i.i175.i770, align 4
  %offset_tbl.i.i179.i774 = load ptr, ptr %offset_tbl_ptr.i.i176.i771, align 8
  %product.i.i.i180.i775 = mul i64 %hash_coef.i.i177.i772, 4015701072841558310
  %shifted.i.i.i181.i776 = lshr i64 %product.i.i.i180.i775, 32
  %xored.i.i.i182.i777 = xor i64 %shifted.i.i.i181.i776, %product.i.i.i180.i775
  %hash.i.i.i183.i778 = and i64 %xored.i.i.i182.i777, %tbl_size.i.i178.i773
  %offset_ptr.i.i184.i779 = getelementptr i32, ptr %offset_tbl.i.i179.i774, i64 %hash.i.i.i183.i778
  %offset.i.i185.i780 = load i32, ptr %offset_ptr.i.i184.i779, align 4
  %3163 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i763, 0
  %3164 = insertvalue { ptr, ptr, ptr, i32 } %3163, ptr %3161, 1
  %3165 = insertvalue { ptr, ptr, ptr, i32 } %3164, ptr %3162, 2
  %3166 = insertvalue { ptr, ptr, ptr, i32 } %3165, i32 %offset.i.i185.i780, 3
  %3167 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3168 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3169 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i763)
  %3170 = sext i32 %offset.i.i185.i780 to i64
  %3171 = getelementptr ptr, ptr %.fca.0.extract57.i763, i64 %3170
  %3172 = getelementptr i8, ptr %3171, i64 64
  %3173 = load ptr, ptr %3172, align 8
  %3174 = call ptr %3173({ ptr, ptr, ptr, i32 } %3166, ptr nonnull %2)
  %3175 = call i32 %3174({ ptr, ptr, ptr, i32 } %3166, { ptr, ptr, ptr, i32 } %3166, ptr nonnull %2)
  %3176 = icmp eq i32 %3175, %3037
  %3177 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3178 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3179 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i763)
  %3180 = getelementptr i8, ptr %3171, i64 48
  %3181 = load ptr, ptr %3180, align 8
  %3182 = call ptr %3181({ ptr, ptr, ptr, i32 } %3166, ptr nonnull %2)
  %3183 = call { ptr, i160 } %3182({ ptr, ptr, ptr, i32 } %3166, { ptr, ptr, ptr, i32 } %3166, ptr nonnull %2)
  %3184 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3185 = load ptr, ptr %145, align 8
  %3186 = call i1 %3185({ ptr, i160 } %3183, { ptr, i160 } %3034)
  %3187 = and i1 %3176, %3186
  br i1 %3187, label %HashMap_get_keyK.exit808, label %HashMap_get_keyK.exit808.thread

HashMap_get_keyK.exit808.thread:                  ; preds = %3160, %.critedge.i745
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i706)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i707)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i708)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i709)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i710)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i711)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i712)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i713)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %108)
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

HashMap_get_keyK.exit808:                         ; preds = %3076, %3160
  %.pre-phi313.i782 = phi i64 [ %3086, %3076 ], [ %3170, %3160 ]
  %.pre-phi312.i783 = phi { ptr, ptr, ptr, i32 } [ %3082, %3076 ], [ %3166, %3160 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i784 = phi ptr [ %.fca.0.extract.i743, %3076 ], [ %.fca.0.extract57.i763, %3160 ]
  %.reg2mem59.0.sroa.phi120289.i785 = phi ptr [ %.sroa.1.i707, %3076 ], [ %.sroa.2124.i711, %3160 ]
  %.reg2mem59.0.sroa.phi117288.i786 = phi ptr [ %.sroa.0271.i706, %3076 ], [ %.sroa.0123.i710, %3160 ]
  %.reg2mem57.0.sroa.phi94287.i787 = phi ptr [ %.sroa.2.i709, %3076 ], [ %.sroa.2116.i713, %3160 ]
  %.reg2mem57.0.sroa.phi91286.i788 = phi ptr [ %.sroa.0.i708, %3076 ], [ %.sroa.0115.i712, %3160 ]
  %3188 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3189 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3190 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i784)
  %3191 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i784, i64 %.pre-phi313.i782
  %3192 = getelementptr i8, ptr %3191, i64 56
  %3193 = load ptr, ptr %3192, align 8
  %3194 = call ptr %3193({ ptr, ptr, ptr, i32 } %.pre-phi312.i783, ptr nonnull %2)
  %3195 = call { ptr, i160 } %3194({ ptr, ptr, ptr, i32 } %.pre-phi312.i783, { ptr, ptr, ptr, i32 } %.pre-phi312.i783, ptr nonnull %2)
  %.fca.0.extract97.i789 = extractvalue { ptr, i160 } %3195, 0
  store ptr %.fca.0.extract97.i789, ptr %.reg2mem59.0.sroa.phi117288.i786, align 8
  %.fca.1.extract99.i790 = extractvalue { ptr, i160 } %3195, 1
  store i160 %.fca.1.extract99.i790, ptr %.reg2mem59.0.sroa.phi120289.i785, align 8
  store ptr %.fca.0.extract97.i789, ptr %.reg2mem57.0.sroa.phi91286.i788, align 8
  store i160 %.fca.1.extract99.i790, ptr %.reg2mem57.0.sroa.phi94287.i787, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i706)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i707)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i708)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i709)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i710)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i711)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i712)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i713)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %108)
  %3196 = icmp ne ptr %.fca.0.extract97.i789, @nil_typ
  %3197 = icmp ne ptr %.fca.0.extract97.i789, null
  %.not68 = and i1 %3196, %3197
  br i1 %.not68, label %3198, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

3198:                                             ; preds = %HashMap_get_keyK.exit808
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract99.i790 to i32
  %3199 = sext i32 %.sroa.2.8.extract.trunc to i64
  %3200 = add i64 %.reg2mem110.0243, %3199
  br label %3223

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit: ; preds = %HashMap_get_keyK.exit808.thread, %HashMap_get_keyK.exit808
  %result.i128 = call noalias dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nonnull @current_ptr) #29
  %3201 = load <51 x i8>, ptr @rcqkf_Error_Nil_returned_during_random_hit_test_for_key_, align 64
  store <51 x i8> %3201, ptr %result.i128, align 64
  %result.i129 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  store ptr @String, ptr %135, align 8
  store ptr %result.i129, ptr %3023, align 8
  store i32 9, ptr %3024, align 8
  %3202 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %135)
  store ptr %result.i128, ptr %result.i129, align 8
  %3203 = getelementptr i8, ptr %result.i129, i64 8
  store i32 51, ptr %3203, align 4
  %3204 = getelementptr i8, ptr %result.i129, i64 12
  store i32 52, ptr %3204, align 4
  %3205 = load i160, ptr %3023, align 8
  %3206 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i = trunc i160 %3205 to i64
  %3207 = inttoptr i64 %.sroa.3.8.extract.trunc.i to ptr
  %3208 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3209 = getelementptr i8, ptr %3207, i64 8
  %3210 = load i32, ptr %3209, align 4
  %3211 = add i32 %3210, 1
  %3212 = sext i32 %3211 to i64
  %result.i.i1523 = call noalias ptr @bump_malloc_inner(i64 noundef %3212, ptr nonnull @current_ptr) #29
  %3213 = load i32, ptr %3209, align 4
  %3214 = icmp sgt i32 %3213, 0
  br i1 %3214, label %.lr.ph.i1524, label %String_c_string_.exit

.lr.ph.i1524:                                     ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %3215 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3216 = load ptr, ptr %3207, align 8
  %3217 = zext nneg i32 %3213 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1523, ptr align 1 %3216, i64 %3217, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %.lr.ph.i1524, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %3218 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3219 = sext i32 %3213 to i64
  %3220 = getelementptr i8, ptr %result.i.i1523, i64 %3219
  store i8 0, ptr %3220, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1523)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3221 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %.sroa.1.8.extract.trunc.i = trunc i160 %3033 to i32
  %3222 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %.sroa.1.8.extract.trunc.i)
  br label %3223

3223:                                             ; preds = %3198, %String_c_string_.exit
  %3224 = phi i1 [ %.reg2mem108.0242, %3198 ], [ false, %String_c_string_.exit ]
  %.reg2mem104.0 = phi i64 [ %3200, %3198 ], [ %.reg2mem110.0243, %String_c_string_.exit ]
  %3225 = add nuw nsw i32 %.reg2mem106.0241, 1
  %3226 = icmp slt i32 %3225, %3020
  br i1 %3226, label %3030, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit169

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit169: ; preds = %3223, %._crit_edge
  %.reg2mem108.0.lcssa = phi i1 [ true, %._crit_edge ], [ %3224, %3223 ]
  %.reg2mem110.0.lcssa = phi i64 [ 0, %._crit_edge ], [ %.reg2mem104.0, %3223 ]
  %3227 = call i64 @clock()
  %.not = icmp eq i64 %.reg2mem110.0.lcssa, %.reg2mem132.0.lcssa
  %3228 = select i1 %.not, i1 %.reg2mem108.0.lcssa, i1 false
  %result.i148 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nonnull @current_ptr) #29
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %result.i148, align 16
  %result.i149 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3229 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i149, 1
  %3230 = insertvalue { ptr, ptr, ptr, i32 } %3229, ptr undef, 2
  %3231 = insertvalue { ptr, ptr, ptr, i32 } %3230, i32 9, 3
  store ptr %result.i148, ptr %result.i149, align 8
  %3232 = getelementptr i8, ptr %result.i149, i64 8
  store i32 14, ptr %3232, align 4
  %3233 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3234 = getelementptr i8, ptr %result.i149, i64 12
  store i32 15, ptr %3234, align 4
  %3235 = sub i64 %3227, %3021
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %3231, i32 %3020, i64 %3235)
  %result.i150 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nonnull @current_ptr) #29
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i150, align 32
  %result.i151 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3236 = getelementptr inbounds i8, ptr %136, i64 8
  %3237 = getelementptr inbounds i8, ptr %136, i64 24
  store ptr @String, ptr %136, align 8
  store ptr %result.i151, ptr %3236, align 8
  store i32 9, ptr %3237, align 8
  %3238 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %136)
  store ptr %result.i150, ptr %result.i151, align 8
  %3239 = getelementptr i8, ptr %result.i151, i64 8
  store i32 18, ptr %3239, align 4
  %3240 = getelementptr i8, ptr %result.i151, i64 12
  store i32 19, ptr %3240, align 4
  %3241 = load i160, ptr %3236, align 8
  %3242 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i484 = trunc i160 %3241 to i64
  %3243 = inttoptr i64 %.sroa.3.8.extract.trunc.i484 to ptr
  %3244 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3245 = getelementptr i8, ptr %3243, i64 8
  %3246 = load i32, ptr %3245, align 4
  %3247 = add i32 %3246, 1
  %3248 = sext i32 %3247 to i64
  %result.i.i1540 = call noalias ptr @bump_malloc_inner(i64 noundef %3248, ptr nonnull @current_ptr) #29
  %3249 = load i32, ptr %3245, align 4
  %3250 = icmp sgt i32 %3249, 0
  br i1 %3250, label %.lr.ph.i1541, label %String_c_string_.exit1545

.lr.ph.i1541:                                     ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit169
  %3251 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3252 = load ptr, ptr %3243, align 8
  %3253 = zext nneg i32 %3249 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1540, ptr align 1 %3252, i64 %3253, i1 false)
  br label %String_c_string_.exit1545

String_c_string_.exit1545:                        ; preds = %.lr.ph.i1541, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit169
  %3254 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3255 = sext i32 %3249 to i64
  %3256 = getelementptr i8, ptr %result.i.i1540, i64 %3255
  store i8 0, ptr %3256, align 1
  %puts.i500 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1540)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i170 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nonnull @current_ptr) #29
  %. = select i1 %3228, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.360 = select i1 %3228, ptr %137, ptr %138
  store <4 x i8> %., ptr %result.i170, align 4
  %result.i191 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %.360.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %3228, ptr %137, ptr %138
  %.360.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.360.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  %.360.sroa.sel524.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %3228, ptr %137, ptr %138
  %.360.sroa.sel524.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.360.sroa.sel524.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 24
  store ptr @String, ptr %.360, align 8
  store ptr %result.i191, ptr %.360.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store i32 9, ptr %.360.sroa.sel524.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %3257 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %.360)
  store ptr %result.i170, ptr %result.i191, align 8
  %3258 = getelementptr i8, ptr %result.i191, i64 8
  store i32 4, ptr %3258, align 4
  %3259 = getelementptr i8, ptr %result.i191, i64 12
  store i32 5, ptr %3259, align 4
  %3260 = load i160, ptr %.360.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %3261 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i504 = trunc i160 %3260 to i64
  %3262 = inttoptr i64 %.sroa.3.8.extract.trunc.i504 to ptr
  %3263 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3264 = getelementptr i8, ptr %3262, i64 8
  %3265 = load i32, ptr %3264, align 4
  %3266 = add i32 %3265, 1
  %3267 = sext i32 %3266 to i64
  %result.i.i1560 = call noalias ptr @bump_malloc_inner(i64 noundef %3267, ptr nonnull @current_ptr) #29
  %3268 = load i32, ptr %3264, align 4
  %3269 = icmp sgt i32 %3268, 0
  br i1 %3269, label %.lr.ph.i1561, label %String_c_string_.exit1565

.lr.ph.i1561:                                     ; preds = %String_c_string_.exit1545
  %3270 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3271 = load ptr, ptr %3262, align 8
  %3272 = zext nneg i32 %3268 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1560, ptr align 1 %3271, i64 %3272, i1 false)
  br label %String_c_string_.exit1565

String_c_string_.exit1565:                        ; preds = %.lr.ph.i1561, %String_c_string_.exit1545
  %3273 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3274 = sext i32 %3268 to i64
  %3275 = getelementptr i8, ptr %result.i.i1560, i64 %3274
  store i8 0, ptr %3275, align 1
  %puts.i520 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1560)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %.sroa.0680.i2586 = alloca ptr, align 8
  %16 = alloca i64, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [2 x ptr], align 8
  %20 = alloca { ptr, ptr }, align 8
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %.sroa.0.i2588 = alloca ptr, align 8
  %24 = alloca i64, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  %30 = alloca { ptr, ptr, ptr, i32 }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [2 x ptr], align 8
  %34 = alloca { ptr, ptr }, align 8
  %35 = alloca i32, align 4
  %36 = alloca i32, align 4
  %37 = alloca i32, align 4
  %.sroa.0680.i2271 = alloca ptr, align 8
  %38 = alloca i64, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [2 x ptr], align 8
  %42 = alloca { ptr, ptr }, align 8
  %43 = alloca i32, align 4
  %44 = alloca i32, align 4
  %45 = alloca i32, align 4
  %.sroa.0.i2272 = alloca ptr, align 8
  %46 = alloca i64, align 8
  %47 = alloca { ptr, ptr, ptr, i32 }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = alloca { ptr, ptr, ptr, i32 }, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca { ptr, ptr, ptr, i32 }, align 8
  %59 = alloca { ptr, ptr, ptr, i32 }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [2 x ptr], align 8
  %63 = alloca { ptr, ptr }, align 8
  %64 = alloca i32, align 4
  %65 = alloca i32, align 4
  %66 = alloca i32, align 4
  %.sroa.0680.i1528 = alloca ptr, align 8
  %67 = alloca i64, align 8
  %68 = alloca [1 x ptr], align 8
  %69 = alloca { ptr }, align 8
  %70 = alloca [2 x ptr], align 8
  %71 = alloca { ptr, ptr }, align 8
  %72 = alloca i32, align 4
  %73 = alloca i32, align 4
  %74 = alloca i32, align 4
  %.sroa.0.i1530 = alloca ptr, align 8
  %75 = alloca i64, align 8
  %76 = alloca [1 x ptr], align 8
  %77 = alloca { ptr }, align 8
  %78 = alloca [1 x ptr], align 8
  %79 = alloca { ptr }, align 8
  %80 = alloca { ptr, ptr, ptr, i32 }, align 8
  %81 = alloca { ptr, ptr, ptr, i32 }, align 8
  %82 = alloca [1 x ptr], align 8
  %83 = alloca { ptr }, align 8
  %84 = alloca [2 x ptr], align 8
  %85 = alloca { ptr, ptr }, align 8
  %86 = alloca i32, align 4
  %87 = alloca i32, align 4
  %88 = alloca i32, align 4
  %.sroa.0680.i = alloca ptr, align 8
  %89 = alloca i64, align 8
  %90 = alloca [1 x ptr], align 8
  %91 = alloca { ptr }, align 8
  %92 = alloca [2 x ptr], align 8
  %93 = alloca { ptr, ptr }, align 8
  %94 = alloca i32, align 4
  %95 = alloca i32, align 4
  %96 = alloca i32, align 4
  %.sroa.0.i1320 = alloca ptr, align 8
  %97 = alloca i64, align 8
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  %99 = alloca [1 x ptr], align 8
  %100 = alloca { ptr }, align 8
  %101 = alloca [1 x ptr], align 8
  %102 = alloca { ptr }, align 8
  %103 = alloca { ptr, ptr, ptr, i32 }, align 8
  %104 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.sroa.0271.i1037 = alloca ptr, align 8
  %.sroa.1.i1038 = alloca i160, align 8
  %.sroa.0.i1039 = alloca ptr, align 8
  %.sroa.2.i1040 = alloca i160, align 8
  %105 = alloca [1 x ptr], align 8
  %106 = alloca { ptr }, align 8
  %.sroa.0123.i1041 = alloca ptr, align 8
  %.sroa.2124.i1042 = alloca i160, align 8
  %.sroa.0115.i1043 = alloca ptr, align 8
  %.sroa.2116.i1044 = alloca i160, align 8
  %107 = alloca [1 x ptr], align 8
  %108 = alloca { ptr }, align 8
  %109 = alloca { ptr, ptr, ptr, i32 }, align 8
  %110 = alloca [2 x ptr], align 8
  %111 = alloca { ptr, ptr }, align 8
  %112 = alloca [1 x ptr], align 8
  %113 = alloca { ptr }, align 8
  %114 = alloca { ptr, ptr, ptr, i32 }, align 8
  %115 = alloca [2 x ptr], align 8
  %116 = alloca { ptr, ptr }, align 8
  %117 = alloca { ptr, ptr, ptr, i32 }, align 8
  %118 = alloca [1 x ptr], align 8
  %119 = alloca { ptr }, align 8
  %.sroa.0271.i593 = alloca ptr, align 8
  %.sroa.1.i594 = alloca i160, align 8
  %.sroa.0.i595 = alloca ptr, align 8
  %.sroa.2.i596 = alloca i160, align 8
  %120 = alloca [1 x ptr], align 8
  %121 = alloca { ptr }, align 8
  %.sroa.0123.i597 = alloca ptr, align 8
  %.sroa.2124.i598 = alloca i160, align 8
  %.sroa.0115.i599 = alloca ptr, align 8
  %.sroa.2116.i600 = alloca i160, align 8
  %122 = alloca [1 x ptr], align 8
  %123 = alloca { ptr }, align 8
  %124 = alloca { ptr, ptr, ptr, i32 }, align 8
  %125 = alloca [2 x ptr], align 8
  %126 = alloca { ptr, ptr }, align 8
  %127 = alloca [1 x ptr], align 8
  %128 = alloca { ptr }, align 8
  %129 = alloca { ptr, ptr, ptr, i32 }, align 8
  %130 = alloca [2 x ptr], align 8
  %131 = alloca { ptr, ptr }, align 8
  %132 = alloca { ptr, ptr, ptr, i32 }, align 8
  %133 = alloca [1 x ptr], align 8
  %134 = alloca { ptr }, align 8
  %.sroa.0271.i = alloca ptr, align 8
  %.sroa.1.i = alloca i160, align 8
  %.sroa.0.i = alloca ptr, align 8
  %.sroa.2.i = alloca i160, align 8
  %135 = alloca [1 x ptr], align 8
  %136 = alloca { ptr }, align 8
  %.sroa.0123.i = alloca ptr, align 8
  %.sroa.2124.i = alloca i160, align 8
  %.sroa.0115.i = alloca ptr, align 8
  %.sroa.2116.i = alloca i160, align 8
  %137 = alloca [1 x ptr], align 8
  %138 = alloca { ptr }, align 8
  %oldProtect.i136 = alloca i32, align 4
  %oldProtect.i132 = alloca i32, align 4
  %oldProtect.i97 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.072.sroa.0 = alloca i8, align 8
  %139 = alloca { ptr, ptr, ptr, i32 }, align 8
  %140 = alloca { ptr, ptr, ptr, i32 }, align 8
  %141 = alloca { ptr, ptr, ptr, i32 }, align 8
  %142 = alloca { ptr, ptr, ptr, i32 }, align 8
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  %144 = alloca { ptr, ptr, ptr, i32 }, align 8
  %result.i = tail call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i, align 8
  %145 = getelementptr i8, ptr %result.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %145, align 8
  %146 = getelementptr i8, ptr %result.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %146, align 8
  %147 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i)
  %result.i94 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i95 = call i32 @VirtualProtect(ptr %result.i94, i64 16, i32 64, ptr nonnull %oldProtect.i) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr %result.i94, ptr nonnull @fwebrmudcg, ptr nonnull @i32_hasher)
  %ret.i = call ptr @llvm.adjust.trampoline(ptr readonly %result.i94) #31
  %148 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i94)
  %result.i96 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i97)
  %result.i98 = call i32 @VirtualProtect(ptr %result.i96, i64 16, i32 64, ptr nonnull %oldProtect.i97) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i97)
  call void @llvm.init.trampoline(ptr %result.i96, ptr nonnull @rfbvuqkrge, ptr nonnull @i32_eq)
  %ret.i99 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i96) #31
  %149 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i96)
  %150 = getelementptr i8, ptr %result.i, i64 96
  store ptr %ret.i, ptr %150, align 8
  %151 = getelementptr i8, ptr %result.i, i64 104
  store ptr %ret.i99, ptr %151, align 8
  %result.i.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %152 = getelementptr i8, ptr %result.i.i, i64 16
  store ptr @_parameterization_Nil, ptr %152, align 8
  %result.i4.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %153 = getelementptr i8, ptr %result.i4.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %153, align 8
  %154 = getelementptr i8, ptr %result.i4.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %154, align 8
  %155 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i)
  store ptr @Entry, ptr %result.i4.i, align 8
  %156 = getelementptr i8, ptr %result.i.i, i64 8
  store ptr %result.i4.i, ptr %156, align 8
  %157 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i)
  store ptr @union_typ, ptr %result.i.i, align 8
  %result.i5.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i, ptr %result.i5.i, align 8
  %158 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i)
  %159 = getelementptr i8, ptr %result.i5.i, i64 16
  store i32 8, ptr %159, align 4
  %160 = getelementptr i8, ptr %result.i5.i, i64 20
  store i32 8, ptr %160, align 4
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %161 = getelementptr i8, ptr %result.i5.i, i64 8
  store ptr %result.i.i.i, ptr %161, align 8
  %162 = getelementptr i8, ptr %result.i, i64 24
  store ptr @Array, ptr %162, align 8
  %163 = getelementptr i8, ptr %result.i, i64 32
  store ptr %result.i5.i, ptr %163, align 8
  %164 = getelementptr i8, ptr %result.i, i64 48
  store i32 9, ptr %164, align 4
  %result.i20.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %165 = getelementptr i8, ptr %result.i20.i, i64 16
  store ptr @_parameterization_Nil, ptr %165, align 8
  %result.i21.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %166 = getelementptr i8, ptr %result.i21.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %166, align 8
  %167 = getelementptr i8, ptr %result.i21.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %167, align 8
  %168 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i)
  store ptr @Entry, ptr %result.i21.i, align 8
  %169 = getelementptr i8, ptr %result.i20.i, i64 8
  store ptr %result.i21.i, ptr %169, align 8
  %170 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i)
  store ptr @union_typ, ptr %result.i20.i, align 8
  %result.i22.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i, ptr %result.i22.i, align 8
  %171 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i)
  %172 = getelementptr i8, ptr %result.i22.i, i64 16
  store i32 8, ptr %172, align 4
  %173 = getelementptr i8, ptr %result.i22.i, i64 20
  store i32 8, ptr %173, align 4
  %result.i.i97.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %174 = getelementptr i8, ptr %result.i22.i, i64 8
  store ptr %result.i.i97.i, ptr %174, align 8
  %175 = getelementptr i8, ptr %result.i, i64 56
  store ptr @Array, ptr %175, align 8
  %176 = getelementptr i8, ptr %result.i, i64 64
  store ptr %result.i22.i, ptr %176, align 8
  %177 = getelementptr i8, ptr %result.i, i64 80
  store i32 9, ptr %177, align 4
  %178 = getelementptr i8, ptr %result.i, i64 112
  store i32 100, ptr %178, align 4
  %result.i100 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  store i32 789, ptr %result.i100, align 4
  %result.i115 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  %179 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  store i32 987, ptr %result.i115, align 4
  %result.i130 = call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i130, align 8
  %180 = getelementptr i8, ptr %result.i130, i64 8
  store ptr @_parameterization_Ptri1, ptr %180, align 8
  %181 = getelementptr i8, ptr %result.i130, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %181, align 8
  %182 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i130)
  %result.i131 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i132)
  %result.i133 = call i32 @VirtualProtect(ptr %result.i131, i64 16, i32 64, ptr nonnull %oldProtect.i132) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i132)
  call void @llvm.init.trampoline(ptr %result.i131, ptr nonnull @wllqseuhnd, ptr nonnull @i32_hasher)
  %ret.i134 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i131) #31
  %183 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i131)
  %result.i135 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i136)
  %result.i137 = call i32 @VirtualProtect(ptr %result.i135, i64 16, i32 64, ptr nonnull %oldProtect.i136) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i136)
  call void @llvm.init.trampoline(ptr %result.i135, ptr nonnull @yqpcdritmp, ptr nonnull @i32_eq)
  %ret.i138 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i135) #31
  %184 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i135)
  %185 = getelementptr i8, ptr %result.i130, i64 96
  store ptr %ret.i134, ptr %185, align 8
  %186 = getelementptr i8, ptr %result.i130, i64 104
  store ptr %ret.i138, ptr %186, align 8
  %result.i.i519 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %187 = getelementptr i8, ptr %result.i.i519, i64 16
  store ptr @_parameterization_Nil, ptr %187, align 8
  %result.i4.i520 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %188 = getelementptr i8, ptr %result.i4.i520, i64 16
  store ptr @_parameterization_Ptri1, ptr %188, align 8
  %189 = getelementptr i8, ptr %result.i4.i520, i64 8
  store ptr @_parameterization_Ptri32, ptr %189, align 8
  %190 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i520)
  store ptr @Entry, ptr %result.i4.i520, align 8
  %191 = getelementptr i8, ptr %result.i.i519, i64 8
  store ptr %result.i4.i520, ptr %191, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i519)
  store ptr @union_typ, ptr %result.i.i519, align 8
  %result.i5.i521 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i519, ptr %result.i5.i521, align 8
  %193 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i521)
  %194 = getelementptr i8, ptr %result.i5.i521, i64 16
  store i32 8, ptr %194, align 4
  %195 = getelementptr i8, ptr %result.i5.i521, i64 20
  store i32 8, ptr %195, align 4
  %result.i.i.i522 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %196 = getelementptr i8, ptr %result.i5.i521, i64 8
  store ptr %result.i.i.i522, ptr %196, align 8
  %197 = getelementptr i8, ptr %result.i130, i64 24
  store ptr @Array, ptr %197, align 8
  %198 = getelementptr i8, ptr %result.i130, i64 32
  store ptr %result.i5.i521, ptr %198, align 8
  %199 = getelementptr i8, ptr %result.i130, i64 40
  %200 = getelementptr i8, ptr %result.i130, i64 48
  store i32 9, ptr %200, align 4
  %result.i20.i523 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %201 = getelementptr i8, ptr %result.i20.i523, i64 16
  store ptr @_parameterization_Nil, ptr %201, align 8
  %result.i21.i524 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %202 = getelementptr i8, ptr %result.i21.i524, i64 16
  store ptr @_parameterization_Ptri1, ptr %202, align 8
  %203 = getelementptr i8, ptr %result.i21.i524, i64 8
  store ptr @_parameterization_Ptri32, ptr %203, align 8
  %204 = getelementptr i8, ptr %result.i21.i524, i64 24
  store ptr null, ptr %204, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i524)
  store ptr @Entry, ptr %result.i21.i524, align 8
  %206 = getelementptr i8, ptr %result.i20.i523, i64 8
  store ptr %result.i21.i524, ptr %206, align 8
  %207 = getelementptr i8, ptr %result.i20.i523, i64 24
  store ptr null, ptr %207, align 8
  %208 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i523)
  store ptr @union_typ, ptr %result.i20.i523, align 8
  %result.i22.i525 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i523, ptr %result.i22.i525, align 8
  %209 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i525)
  %210 = getelementptr i8, ptr %result.i22.i525, i64 16
  store i32 8, ptr %210, align 4
  %211 = getelementptr i8, ptr %result.i22.i525, i64 20
  store i32 8, ptr %211, align 4
  %result.i.i97.i526 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %212 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %213 = getelementptr i8, ptr %result.i22.i525, i64 8
  store ptr %result.i.i97.i526, ptr %213, align 8
  %214 = getelementptr i8, ptr %result.i130, i64 56
  store ptr @Array, ptr %214, align 8
  %215 = getelementptr i8, ptr %result.i130, i64 64
  store ptr %result.i22.i525, ptr %215, align 8
  %216 = getelementptr i8, ptr %result.i130, i64 72
  %217 = getelementptr i8, ptr %result.i130, i64 80
  store i32 9, ptr %217, align 4
  %218 = getelementptr i8, ptr %result.i130, i64 88
  store i32 0, ptr %218, align 4
  %219 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %220 = getelementptr i8, ptr %result.i130, i64 112
  store i32 100, ptr %220, align 4
  %221 = mul i32 %0, 10
  %222 = icmp sgt i32 %0, 0
  %223 = icmp sgt i32 %221, 0
  %224 = and i1 %222, %223
  br i1 %224, label %.lr.ph, label %._crit_edge._crit_edge

.lr.ph:                                           ; preds = %1
  %225 = getelementptr inbounds i8, ptr %132, i64 8
  %226 = getelementptr inbounds i8, ptr %132, i64 24
  %227 = getelementptr inbounds i8, ptr %132, i64 16
  %228 = getelementptr inbounds i8, ptr %129, i64 8
  %229 = getelementptr inbounds i8, ptr %129, i64 24
  %230 = getelementptr inbounds i8, ptr %129, i64 16
  %231 = getelementptr inbounds i8, ptr %130, i64 8
  %232 = getelementptr inbounds i8, ptr %131, i64 8
  %233 = getelementptr inbounds i8, ptr %124, i64 8
  %234 = getelementptr inbounds i8, ptr %124, i64 24
  %235 = getelementptr inbounds i8, ptr %124, i64 16
  %236 = getelementptr inbounds i8, ptr %125, i64 8
  %237 = getelementptr inbounds i8, ptr %126, i64 8
  %238 = getelementptr inbounds i8, ptr %117, i64 8
  %239 = getelementptr inbounds i8, ptr %117, i64 24
  %240 = getelementptr inbounds i8, ptr %117, i64 16
  %241 = getelementptr inbounds i8, ptr %114, i64 8
  %242 = getelementptr inbounds i8, ptr %114, i64 24
  %243 = getelementptr inbounds i8, ptr %114, i64 16
  %244 = getelementptr inbounds i8, ptr %115, i64 8
  %245 = getelementptr inbounds i8, ptr %116, i64 8
  %246 = getelementptr inbounds i8, ptr %109, i64 8
  %247 = getelementptr inbounds i8, ptr %109, i64 24
  %248 = getelementptr inbounds i8, ptr %109, i64 16
  %249 = getelementptr inbounds i8, ptr %110, i64 8
  %250 = getelementptr inbounds i8, ptr %111, i64 8
  %251 = getelementptr i8, ptr %result.i, i64 40
  %252 = getelementptr i8, ptr %result.i, i64 72
  %253 = getelementptr i8, ptr %result.i, i64 88
  %254 = getelementptr inbounds i8, ptr %103, i64 8
  %255 = getelementptr inbounds i8, ptr %103, i64 24
  %256 = getelementptr inbounds i8, ptr %103, i64 16
  %257 = getelementptr inbounds i8, ptr %104, i64 8
  %258 = getelementptr inbounds i8, ptr %104, i64 24
  %259 = getelementptr inbounds i8, ptr %104, i64 16
  %260 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i130, 1
  %261 = insertvalue { ptr, ptr, ptr, i32 } %260, ptr undef, 2
  %262 = insertvalue { ptr, ptr, ptr, i32 } %261, i32 9, 3
  %263 = getelementptr inbounds i8, ptr %98, i64 8
  %264 = getelementptr inbounds i8, ptr %98, i64 16
  %265 = getelementptr inbounds i8, ptr %98, i64 24
  %266 = getelementptr inbounds i8, ptr %92, i64 8
  %267 = getelementptr inbounds i8, ptr %93, i64 8
  %268 = getelementptr inbounds i8, ptr %84, i64 8
  %269 = getelementptr inbounds i8, ptr %85, i64 8
  %270 = getelementptr inbounds i8, ptr %80, i64 8
  %271 = getelementptr inbounds i8, ptr %80, i64 24
  %272 = getelementptr inbounds i8, ptr %80, i64 16
  %273 = getelementptr inbounds i8, ptr %81, i64 8
  %274 = getelementptr inbounds i8, ptr %81, i64 24
  %275 = getelementptr inbounds i8, ptr %81, i64 16
  %276 = getelementptr inbounds i8, ptr %70, i64 8
  %277 = getelementptr inbounds i8, ptr %71, i64 8
  %278 = getelementptr inbounds i8, ptr %62, i64 8
  %279 = getelementptr inbounds i8, ptr %63, i64 8
  %280 = getelementptr inbounds i8, ptr %58, i64 8
  %281 = getelementptr inbounds i8, ptr %58, i64 24
  %282 = getelementptr inbounds i8, ptr %58, i64 16
  %283 = getelementptr inbounds i8, ptr %59, i64 8
  %284 = getelementptr inbounds i8, ptr %59, i64 24
  %285 = getelementptr inbounds i8, ptr %59, i64 16
  %286 = getelementptr inbounds i8, ptr %52, i64 8
  %287 = getelementptr inbounds i8, ptr %52, i64 24
  %288 = getelementptr inbounds i8, ptr %52, i64 16
  %289 = getelementptr inbounds i8, ptr %53, i64 8
  %290 = getelementptr inbounds i8, ptr %53, i64 24
  %291 = getelementptr inbounds i8, ptr %53, i64 16
  %292 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %293 = insertvalue { ptr, ptr, ptr, i32 } %292, ptr undef, 2
  %294 = insertvalue { ptr, ptr, ptr, i32 } %293, i32 9, 3
  %295 = getelementptr inbounds i8, ptr %47, i64 8
  %296 = getelementptr inbounds i8, ptr %47, i64 16
  %297 = getelementptr inbounds i8, ptr %47, i64 24
  %298 = getelementptr inbounds i8, ptr %41, i64 8
  %299 = getelementptr inbounds i8, ptr %42, i64 8
  %300 = getelementptr inbounds i8, ptr %33, i64 8
  %301 = getelementptr inbounds i8, ptr %34, i64 8
  %302 = getelementptr inbounds i8, ptr %29, i64 8
  %303 = getelementptr inbounds i8, ptr %29, i64 24
  %304 = getelementptr inbounds i8, ptr %29, i64 16
  %305 = getelementptr inbounds i8, ptr %30, i64 8
  %306 = getelementptr inbounds i8, ptr %30, i64 24
  %307 = getelementptr inbounds i8, ptr %30, i64 16
  %308 = getelementptr inbounds i8, ptr %19, i64 8
  %309 = getelementptr inbounds i8, ptr %20, i64 8
  %310 = getelementptr inbounds i8, ptr %11, i64 8
  %311 = getelementptr inbounds i8, ptr %12, i64 8
  %312 = getelementptr inbounds i8, ptr %7, i64 8
  %313 = getelementptr inbounds i8, ptr %7, i64 24
  %314 = getelementptr inbounds i8, ptr %7, i64 16
  %315 = getelementptr inbounds i8, ptr %8, i64 8
  %316 = getelementptr inbounds i8, ptr %8, i64 24
  %317 = getelementptr inbounds i8, ptr %8, i64 16
  br label %318

318:                                              ; preds = %.lr.ph, %._crit_edge
  %.reg2mem168.0346 = phi i32 [ 0, %.lr.ph ], [ %.reg2mem164.0, %._crit_edge ]
  %.reg2mem166.0345 = phi i32 [ 0, %.lr.ph ], [ %3008, %._crit_edge ]
  %319 = load i32, ptr %result.i100, align 4
  %320 = mul i32 %319, 1103515245
  %321 = add i32 %320, 12345
  %322 = and i32 %321, 2147483647
  store i32 %322, ptr %result.i100, align 4
  %323 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  %.sroa.092.0.insert.ext = zext nneg i32 %322 to i160
  %324 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.092.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %135)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %136)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %137)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %138)
  %325 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %326 = load ptr, ptr %185, align 8
  %327 = call i32 %326({ ptr, i160 } %324)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %328 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %329 = load ptr, ptr %197, align 8
  %330 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %329, 0
  %331 = load ptr, ptr %198, align 8
  %332 = insertvalue { ptr, ptr, ptr, i32 } %330, ptr %331, 1
  %333 = load ptr, ptr %199, align 8
  %334 = insertvalue { ptr, ptr, ptr, i32 } %332, ptr %333, 2
  %335 = load i32, ptr %200, align 4
  %336 = insertvalue { ptr, ptr, ptr, i32 } %334, i32 %335, 3
  %hash_coef_ptr.i.i10.i = getelementptr i8, ptr %329, i64 8
  %tbl_size_ptr.i.i11.i = getelementptr i8, ptr %329, i64 16
  %offset_tbl_ptr.i.i12.i = getelementptr i8, ptr %329, i64 40
  %hash_coef.i.i13.i = load i64, ptr %hash_coef_ptr.i.i10.i, align 4
  %tbl_size.i.i14.i = load i64, ptr %tbl_size_ptr.i.i11.i, align 4
  %offset_tbl.i.i15.i = load ptr, ptr %offset_tbl_ptr.i.i12.i, align 8
  %product.i.i.i16.i = mul i64 %hash_coef.i.i13.i, -5261542750394134544
  %shifted.i.i.i17.i = lshr i64 %product.i.i.i16.i, 32
  %xored.i.i.i18.i = xor i64 %shifted.i.i.i17.i, %product.i.i.i16.i
  %hash.i.i.i19.i = and i64 %xored.i.i.i18.i, %tbl_size.i.i14.i
  %offset_ptr.i.i20.i = getelementptr i32, ptr %offset_tbl.i.i15.i, i64 %hash.i.i.i19.i
  %offset.i.i21.i = load i32, ptr %offset_ptr.i.i20.i, align 4
  %eq.i.i1193 = icmp eq i32 %335, %offset.i.i21.i
  call void @llvm.assume(i1 %eq.i.i1193) #30
  %337 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %338 = call ptr @llvm.invariant.start.p0(i64 600, ptr %329)
  %339 = sext i32 %335 to i64
  %340 = getelementptr ptr, ptr %329, i64 %339
  %341 = getelementptr i8, ptr %340, i64 64
  %342 = load ptr, ptr %341, align 8
  %343 = call ptr %342({ ptr, ptr, ptr, i32 } %336, ptr nonnull %2)
  %344 = call i32 %343({ ptr, ptr, ptr, i32 } %336, { ptr, ptr, ptr, i32 } %336, ptr nonnull %2)
  %345 = add i32 %344, -1
  %346 = and i32 %345, %327
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %347 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %348 = load ptr, ptr %197, align 8
  %349 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %348, 0
  %350 = load ptr, ptr %198, align 8
  %351 = insertvalue { ptr, ptr, ptr, i32 } %349, ptr %350, 1
  %352 = load ptr, ptr %199, align 8
  %353 = insertvalue { ptr, ptr, ptr, i32 } %351, ptr %352, 2
  %354 = load i32, ptr %200, align 4
  %355 = insertvalue { ptr, ptr, ptr, i32 } %353, i32 %354, 3
  %hash_coef_ptr.i.i130.i = getelementptr i8, ptr %348, i64 8
  %tbl_size_ptr.i.i131.i = getelementptr i8, ptr %348, i64 16
  %offset_tbl_ptr.i.i132.i = getelementptr i8, ptr %348, i64 40
  %hash_coef.i.i133.i = load i64, ptr %hash_coef_ptr.i.i130.i, align 4
  %tbl_size.i.i134.i = load i64, ptr %tbl_size_ptr.i.i131.i, align 4
  %offset_tbl.i.i135.i = load ptr, ptr %offset_tbl_ptr.i.i132.i, align 8
  %product.i.i.i136.i = mul i64 %hash_coef.i.i133.i, -5261542750394134544
  %shifted.i.i.i137.i = lshr i64 %product.i.i.i136.i, 32
  %xored.i.i.i138.i = xor i64 %shifted.i.i.i137.i, %product.i.i.i136.i
  %hash.i.i.i139.i = and i64 %xored.i.i.i138.i, %tbl_size.i.i134.i
  %offset_ptr.i.i140.i = getelementptr i32, ptr %offset_tbl.i.i135.i, i64 %hash.i.i.i139.i
  %offset.i.i141.i = load i32, ptr %offset_ptr.i.i140.i, align 4
  %eq.i.i = icmp eq i32 %354, %offset.i.i141.i
  call void @llvm.assume(i1 %eq.i.i) #30
  store ptr @_parameterization_Ptri32, ptr %137, align 8
  %356 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %137)
  %357 = call ptr @llvm.invariant.start.p0(i64 600, ptr %348)
  %358 = sext i32 %354 to i64
  %359 = getelementptr ptr, ptr %348, i64 %358
  %360 = getelementptr i8, ptr %359, i64 120
  %361 = load ptr, ptr %360, align 8
  store ptr @i32_typ, ptr %138, align 8
  %362 = call ptr %361({ ptr, ptr, ptr, i32 } %355, ptr nonnull %138)
  %363 = call { ptr, i160 } %362({ ptr, ptr, ptr, i32 } %355, { ptr, ptr, ptr, i32 } %355, ptr nonnull %137, i32 %346)
  %.fca.0.extract.i551 = extractvalue { ptr, i160 } %363, 0
  %364 = icmp ne ptr %.fca.0.extract.i551, @nil_typ
  %365 = icmp ne ptr %.fca.0.extract.i551, null
  %.not126.i = and i1 %364, %365
  br i1 %.not126.i, label %366, label %.critedge.i

366:                                              ; preds = %318
  %.fca.1.extract.i = extractvalue { ptr, i160 } %363, 1
  %.sroa.5.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i64
  %367 = inttoptr i64 %.sroa.5.8.extract.trunc.i to ptr
  %.sroa.9.8.extract.shift.i = lshr i160 %.fca.1.extract.i, 64
  %.sroa.9.8.extract.trunc.i = trunc i160 %.sroa.9.8.extract.shift.i to i64
  %368 = inttoptr i64 %.sroa.9.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i144.i = getelementptr i8, ptr %.fca.0.extract.i551, i64 8
  %tbl_size_ptr.i.i145.i = getelementptr i8, ptr %.fca.0.extract.i551, i64 16
  %offset_tbl_ptr.i.i146.i = getelementptr i8, ptr %.fca.0.extract.i551, i64 40
  %hash_coef.i.i147.i = load i64, ptr %hash_coef_ptr.i.i144.i, align 4
  %tbl_size.i.i148.i = load i64, ptr %tbl_size_ptr.i.i145.i, align 4
  %offset_tbl.i.i149.i = load ptr, ptr %offset_tbl_ptr.i.i146.i, align 8
  %product.i.i.i150.i = mul i64 %hash_coef.i.i147.i, 4015701072841558310
  %shifted.i.i.i151.i = lshr i64 %product.i.i.i150.i, 32
  %xored.i.i.i152.i = xor i64 %shifted.i.i.i151.i, %product.i.i.i150.i
  %hash.i.i.i153.i = and i64 %xored.i.i.i152.i, %tbl_size.i.i148.i
  %offset_ptr.i.i154.i = getelementptr i32, ptr %offset_tbl.i.i149.i, i64 %hash.i.i.i153.i
  %offset.i.i155.i = load i32, ptr %offset_ptr.i.i154.i, align 4
  %369 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i551, 0
  %370 = insertvalue { ptr, ptr, ptr, i32 } %369, ptr %367, 1
  %371 = insertvalue { ptr, ptr, ptr, i32 } %370, ptr %368, 2
  %372 = insertvalue { ptr, ptr, ptr, i32 } %371, i32 %offset.i.i155.i, 3
  %373 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %374 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %375 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i551)
  %376 = sext i32 %offset.i.i155.i to i64
  %377 = getelementptr ptr, ptr %.fca.0.extract.i551, i64 %376
  %378 = getelementptr i8, ptr %377, i64 64
  %379 = load ptr, ptr %378, align 8
  %380 = call ptr %379({ ptr, ptr, ptr, i32 } %372, ptr nonnull %2)
  %381 = call i32 %380({ ptr, ptr, ptr, i32 } %372, { ptr, ptr, ptr, i32 } %372, ptr nonnull %2)
  %382 = icmp eq i32 %381, %327
  %383 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %384 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %385 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i551)
  %386 = getelementptr i8, ptr %377, i64 48
  %387 = load ptr, ptr %386, align 8
  %388 = call ptr %387({ ptr, ptr, ptr, i32 } %372, ptr nonnull %2)
  %389 = call { ptr, i160 } %388({ ptr, ptr, ptr, i32 } %372, { ptr, ptr, ptr, i32 } %372, ptr nonnull %2)
  %390 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %391 = load ptr, ptr %186, align 8
  %392 = call i1 %391({ ptr, i160 } %389, { ptr, i160 } %324)
  %393 = and i1 %382, %392
  br i1 %393, label %HashMap_get_keyK.exit, label %.critedge.i

.critedge.i:                                      ; preds = %366, %318
  %394 = add i32 %327, 2127912214
  %395 = shl i32 %327, 12
  %396 = add i32 %394, %395
  %397 = ashr i32 %396, 19
  %398 = xor i32 %396, %397
  %399 = xor i32 %398, -949894596
  %400 = add i32 %399, 374761393
  %401 = shl i32 %399, 5
  %402 = add i32 %400, %401
  %403 = add i32 %402, -744332180
  %404 = shl i32 %402, 9
  %405 = xor i32 %403, %404
  %406 = add i32 %405, -42973499
  %407 = shl i32 %405, 3
  %408 = add i32 %406, %407
  %409 = ashr i32 %408, 16
  %410 = xor i32 %408, %409
  %411 = xor i32 %410, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %412 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %413 = load ptr, ptr %214, align 8
  %414 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %413, 0
  %415 = load ptr, ptr %215, align 8
  %416 = insertvalue { ptr, ptr, ptr, i32 } %414, ptr %415, 1
  %417 = load ptr, ptr %216, align 8
  %418 = insertvalue { ptr, ptr, ptr, i32 } %416, ptr %417, 2
  %419 = load i32, ptr %217, align 4
  %420 = insertvalue { ptr, ptr, ptr, i32 } %418, i32 %419, 3
  %hash_coef_ptr.i.i10.i1211 = getelementptr i8, ptr %413, i64 8
  %tbl_size_ptr.i.i11.i1212 = getelementptr i8, ptr %413, i64 16
  %offset_tbl_ptr.i.i12.i1213 = getelementptr i8, ptr %413, i64 40
  %hash_coef.i.i13.i1214 = load i64, ptr %hash_coef_ptr.i.i10.i1211, align 4
  %tbl_size.i.i14.i1215 = load i64, ptr %tbl_size_ptr.i.i11.i1212, align 4
  %offset_tbl.i.i15.i1216 = load ptr, ptr %offset_tbl_ptr.i.i12.i1213, align 8
  %product.i.i.i16.i1217 = mul i64 %hash_coef.i.i13.i1214, -5261542750394134544
  %shifted.i.i.i17.i1218 = lshr i64 %product.i.i.i16.i1217, 32
  %xored.i.i.i18.i1219 = xor i64 %shifted.i.i.i17.i1218, %product.i.i.i16.i1217
  %hash.i.i.i19.i1220 = and i64 %xored.i.i.i18.i1219, %tbl_size.i.i14.i1215
  %offset_ptr.i.i20.i1221 = getelementptr i32, ptr %offset_tbl.i.i15.i1216, i64 %hash.i.i.i19.i1220
  %offset.i.i21.i1222 = load i32, ptr %offset_ptr.i.i20.i1221, align 4
  %eq.i.i1223 = icmp eq i32 %419, %offset.i.i21.i1222
  call void @llvm.assume(i1 %eq.i.i1223) #30
  %421 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %422 = call ptr @llvm.invariant.start.p0(i64 600, ptr %413)
  %423 = sext i32 %419 to i64
  %424 = getelementptr ptr, ptr %413, i64 %423
  %425 = getelementptr i8, ptr %424, i64 64
  %426 = load ptr, ptr %425, align 8
  %427 = call ptr %426({ ptr, ptr, ptr, i32 } %420, ptr nonnull %2)
  %428 = call i32 %427({ ptr, ptr, ptr, i32 } %420, { ptr, ptr, ptr, i32 } %420, ptr nonnull %2)
  %429 = add i32 %428, -1
  %430 = and i32 %429, %411
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %431 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %432 = load ptr, ptr %214, align 8
  %433 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %432, 0
  %434 = load ptr, ptr %215, align 8
  %435 = insertvalue { ptr, ptr, ptr, i32 } %433, ptr %434, 1
  %436 = load ptr, ptr %216, align 8
  %437 = insertvalue { ptr, ptr, ptr, i32 } %435, ptr %436, 2
  %438 = load i32, ptr %217, align 4
  %439 = insertvalue { ptr, ptr, ptr, i32 } %437, i32 %438, 3
  %hash_coef_ptr.i.i158.i = getelementptr i8, ptr %432, i64 8
  %tbl_size_ptr.i.i159.i = getelementptr i8, ptr %432, i64 16
  %offset_tbl_ptr.i.i160.i = getelementptr i8, ptr %432, i64 40
  %hash_coef.i.i161.i = load i64, ptr %hash_coef_ptr.i.i158.i, align 4
  %tbl_size.i.i162.i = load i64, ptr %tbl_size_ptr.i.i159.i, align 4
  %offset_tbl.i.i163.i = load ptr, ptr %offset_tbl_ptr.i.i160.i, align 8
  %product.i.i.i164.i = mul i64 %hash_coef.i.i161.i, -5261542750394134544
  %shifted.i.i.i165.i = lshr i64 %product.i.i.i164.i, 32
  %xored.i.i.i166.i = xor i64 %shifted.i.i.i165.i, %product.i.i.i164.i
  %hash.i.i.i167.i = and i64 %xored.i.i.i166.i, %tbl_size.i.i162.i
  %offset_ptr.i.i168.i = getelementptr i32, ptr %offset_tbl.i.i163.i, i64 %hash.i.i.i167.i
  %offset.i.i169.i = load i32, ptr %offset_ptr.i.i168.i, align 4
  %eq.i172.i = icmp eq i32 %438, %offset.i.i169.i
  call void @llvm.assume(i1 %eq.i172.i) #30
  store ptr @_parameterization_Ptri32, ptr %135, align 8
  %440 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %135)
  %441 = call ptr @llvm.invariant.start.p0(i64 600, ptr %432)
  %442 = sext i32 %438 to i64
  %443 = getelementptr ptr, ptr %432, i64 %442
  %444 = getelementptr i8, ptr %443, i64 120
  %445 = load ptr, ptr %444, align 8
  store ptr @i32_typ, ptr %136, align 8
  %446 = call ptr %445({ ptr, ptr, ptr, i32 } %439, ptr nonnull %136)
  %447 = call { ptr, i160 } %446({ ptr, ptr, ptr, i32 } %439, { ptr, ptr, ptr, i32 } %439, ptr nonnull %135, i32 %430)
  %.fca.0.extract57.i = extractvalue { ptr, i160 } %447, 0
  %448 = icmp ne ptr %.fca.0.extract57.i, @nil_typ
  %449 = icmp ne ptr %.fca.0.extract57.i, null
  %.not128.i = and i1 %448, %449
  br i1 %.not128.i, label %450, label %HashMap_get_keyK.exit.thread

450:                                              ; preds = %.critedge.i
  %.fca.1.extract59.i = extractvalue { ptr, i160 } %447, 1
  %.sroa.6.8.extract.trunc.i = trunc i160 %.fca.1.extract59.i to i64
  %451 = inttoptr i64 %.sroa.6.8.extract.trunc.i to ptr
  %.sroa.11.8.extract.shift.i = lshr i160 %.fca.1.extract59.i, 64
  %.sroa.11.8.extract.trunc.i = trunc i160 %.sroa.11.8.extract.shift.i to i64
  %452 = inttoptr i64 %.sroa.11.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i174.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 8
  %tbl_size_ptr.i.i175.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 16
  %offset_tbl_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 40
  %hash_coef.i.i177.i = load i64, ptr %hash_coef_ptr.i.i174.i, align 4
  %tbl_size.i.i178.i = load i64, ptr %tbl_size_ptr.i.i175.i, align 4
  %offset_tbl.i.i179.i = load ptr, ptr %offset_tbl_ptr.i.i176.i, align 8
  %product.i.i.i180.i = mul i64 %hash_coef.i.i177.i, 4015701072841558310
  %shifted.i.i.i181.i = lshr i64 %product.i.i.i180.i, 32
  %xored.i.i.i182.i = xor i64 %shifted.i.i.i181.i, %product.i.i.i180.i
  %hash.i.i.i183.i = and i64 %xored.i.i.i182.i, %tbl_size.i.i178.i
  %offset_ptr.i.i184.i = getelementptr i32, ptr %offset_tbl.i.i179.i, i64 %hash.i.i.i183.i
  %offset.i.i185.i = load i32, ptr %offset_ptr.i.i184.i, align 4
  %453 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i, 0
  %454 = insertvalue { ptr, ptr, ptr, i32 } %453, ptr %451, 1
  %455 = insertvalue { ptr, ptr, ptr, i32 } %454, ptr %452, 2
  %456 = insertvalue { ptr, ptr, ptr, i32 } %455, i32 %offset.i.i185.i, 3
  %457 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %458 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %459 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %460 = sext i32 %offset.i.i185.i to i64
  %461 = getelementptr ptr, ptr %.fca.0.extract57.i, i64 %460
  %462 = getelementptr i8, ptr %461, i64 64
  %463 = load ptr, ptr %462, align 8
  %464 = call ptr %463({ ptr, ptr, ptr, i32 } %456, ptr nonnull %2)
  %465 = call i32 %464({ ptr, ptr, ptr, i32 } %456, { ptr, ptr, ptr, i32 } %456, ptr nonnull %2)
  %466 = icmp eq i32 %465, %327
  %467 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %468 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %469 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %470 = getelementptr i8, ptr %461, i64 48
  %471 = load ptr, ptr %470, align 8
  %472 = call ptr %471({ ptr, ptr, ptr, i32 } %456, ptr nonnull %2)
  %473 = call { ptr, i160 } %472({ ptr, ptr, ptr, i32 } %456, { ptr, ptr, ptr, i32 } %456, ptr nonnull %2)
  %474 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %475 = load ptr, ptr %186, align 8
  %476 = call i1 %475({ ptr, i160 } %473, { ptr, i160 } %324)
  %477 = and i1 %466, %476
  br i1 %477, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %450, %.critedge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %135)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %136)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %137)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %138)
  br label %489

HashMap_get_keyK.exit:                            ; preds = %366, %450
  %.pre-phi313.i = phi i64 [ %376, %366 ], [ %460, %450 ]
  %.pre-phi312.i = phi { ptr, ptr, ptr, i32 } [ %372, %366 ], [ %456, %450 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i = phi ptr [ %.fca.0.extract.i551, %366 ], [ %.fca.0.extract57.i, %450 ]
  %.reg2mem59.0.sroa.phi120289.i = phi ptr [ %.sroa.1.i, %366 ], [ %.sroa.2124.i, %450 ]
  %.reg2mem59.0.sroa.phi117288.i = phi ptr [ %.sroa.0271.i, %366 ], [ %.sroa.0123.i, %450 ]
  %.reg2mem57.0.sroa.phi94287.i = phi ptr [ %.sroa.2.i, %366 ], [ %.sroa.2116.i, %450 ]
  %.reg2mem57.0.sroa.phi91286.i = phi ptr [ %.sroa.0.i, %366 ], [ %.sroa.0115.i, %450 ]
  %478 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %479 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %480 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i)
  %481 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i, i64 %.pre-phi313.i
  %482 = getelementptr i8, ptr %481, i64 56
  %483 = load ptr, ptr %482, align 8
  %484 = call ptr %483({ ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %485 = call { ptr, i160 } %484({ ptr, ptr, ptr, i32 } %.pre-phi312.i, { ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %.fca.0.extract97.i = extractvalue { ptr, i160 } %485, 0
  store ptr %.fca.0.extract97.i, ptr %.reg2mem59.0.sroa.phi117288.i, align 8
  %.fca.1.extract99.i = extractvalue { ptr, i160 } %485, 1
  store i160 %.fca.1.extract99.i, ptr %.reg2mem59.0.sroa.phi120289.i, align 8
  store ptr %.fca.0.extract97.i, ptr %.reg2mem57.0.sroa.phi91286.i, align 8
  store i160 %.fca.1.extract99.i, ptr %.reg2mem57.0.sroa.phi94287.i, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %135)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %136)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %137)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %138)
  %486 = icmp eq ptr %.fca.0.extract97.i, @nil_typ
  %487 = icmp eq ptr %.fca.0.extract97.i, null
  %488 = or i1 %486, %487
  br i1 %488, label %489, label %._crit_edge

489:                                              ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit
  %490 = add nuw i32 %322, 1
  %.sroa.078.0.insert.ext = zext i32 %490 to i160
  %491 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.078.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %109)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %111)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %113)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %114)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %115)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %116)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %117)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %118)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %119)
  %492 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %493 = load ptr, ptr %150, align 8
  %494 = call i32 %493({ ptr, i160 } %324)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %495 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %496 = load ptr, ptr %162, align 8
  %497 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %496, 0
  %498 = load ptr, ptr %163, align 8
  %499 = insertvalue { ptr, ptr, ptr, i32 } %497, ptr %498, 1
  %500 = load ptr, ptr %251, align 8
  %501 = insertvalue { ptr, ptr, ptr, i32 } %499, ptr %500, 2
  %502 = load i32, ptr %164, align 4
  %503 = insertvalue { ptr, ptr, ptr, i32 } %501, i32 %502, 3
  %hash_coef_ptr.i.i10.i2094 = getelementptr i8, ptr %496, i64 8
  %tbl_size_ptr.i.i11.i2095 = getelementptr i8, ptr %496, i64 16
  %offset_tbl_ptr.i.i12.i2096 = getelementptr i8, ptr %496, i64 40
  %hash_coef.i.i13.i2097 = load i64, ptr %hash_coef_ptr.i.i10.i2094, align 4
  %tbl_size.i.i14.i2098 = load i64, ptr %tbl_size_ptr.i.i11.i2095, align 4
  %offset_tbl.i.i15.i2099 = load ptr, ptr %offset_tbl_ptr.i.i12.i2096, align 8
  %product.i.i.i16.i2100 = mul i64 %hash_coef.i.i13.i2097, -5261542750394134544
  %shifted.i.i.i17.i2101 = lshr i64 %product.i.i.i16.i2100, 32
  %xored.i.i.i18.i2102 = xor i64 %shifted.i.i.i17.i2101, %product.i.i.i16.i2100
  %hash.i.i.i19.i2103 = and i64 %xored.i.i.i18.i2102, %tbl_size.i.i14.i2098
  %offset_ptr.i.i20.i2104 = getelementptr i32, ptr %offset_tbl.i.i15.i2099, i64 %hash.i.i.i19.i2103
  %offset.i.i21.i2105 = load i32, ptr %offset_ptr.i.i20.i2104, align 4
  %eq.i.i2106 = icmp eq i32 %502, %offset.i.i21.i2105
  call void @llvm.assume(i1 %eq.i.i2106) #30
  %504 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %505 = call ptr @llvm.invariant.start.p0(i64 600, ptr %496)
  %506 = sext i32 %502 to i64
  %507 = getelementptr ptr, ptr %496, i64 %506
  %508 = getelementptr i8, ptr %507, i64 64
  %509 = load ptr, ptr %508, align 8
  %510 = call ptr %509({ ptr, ptr, ptr, i32 } %503, ptr nonnull %2)
  %511 = call i32 %510({ ptr, ptr, ptr, i32 } %503, { ptr, ptr, ptr, i32 } %503, ptr nonnull %2)
  %512 = add i32 %511, -1
  %513 = and i32 %512, %494
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %514 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %515 = load ptr, ptr %162, align 8
  %516 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %515, 0
  %517 = load ptr, ptr %163, align 8
  %518 = insertvalue { ptr, ptr, ptr, i32 } %516, ptr %517, 1
  %519 = load ptr, ptr %251, align 8
  %520 = insertvalue { ptr, ptr, ptr, i32 } %518, ptr %519, 2
  %521 = load i32, ptr %164, align 4
  %522 = insertvalue { ptr, ptr, ptr, i32 } %520, i32 %521, 3
  %hash_coef_ptr.i.i162.i887 = getelementptr i8, ptr %515, i64 8
  %tbl_size_ptr.i.i163.i888 = getelementptr i8, ptr %515, i64 16
  %offset_tbl_ptr.i.i164.i889 = getelementptr i8, ptr %515, i64 40
  %hash_coef.i.i165.i890 = load i64, ptr %hash_coef_ptr.i.i162.i887, align 4
  %tbl_size.i.i166.i891 = load i64, ptr %tbl_size_ptr.i.i163.i888, align 4
  %offset_tbl.i.i167.i892 = load ptr, ptr %offset_tbl_ptr.i.i164.i889, align 8
  %product.i.i.i168.i893 = mul i64 %hash_coef.i.i165.i890, -5261542750394134544
  %shifted.i.i.i169.i894 = lshr i64 %product.i.i.i168.i893, 32
  %xored.i.i.i170.i895 = xor i64 %shifted.i.i.i169.i894, %product.i.i.i168.i893
  %hash.i.i.i171.i896 = and i64 %xored.i.i.i170.i895, %tbl_size.i.i166.i891
  %offset_ptr.i.i172.i897 = getelementptr i32, ptr %offset_tbl.i.i167.i892, i64 %hash.i.i.i171.i896
  %offset.i.i173.i898 = load i32, ptr %offset_ptr.i.i172.i897, align 4
  %eq.i.i899 = icmp eq i32 %521, %offset.i.i173.i898
  call void @llvm.assume(i1 %eq.i.i899) #30
  store ptr @_parameterization_Ptri32, ptr %118, align 8
  %523 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %118)
  %524 = call ptr @llvm.invariant.start.p0(i64 600, ptr %515)
  %525 = sext i32 %521 to i64
  %526 = getelementptr ptr, ptr %515, i64 %525
  %527 = getelementptr i8, ptr %526, i64 120
  %528 = load ptr, ptr %527, align 8
  store ptr @i32_typ, ptr %119, align 8
  %529 = call ptr %528({ ptr, ptr, ptr, i32 } %522, ptr nonnull %119)
  %530 = call { ptr, i160 } %529({ ptr, ptr, ptr, i32 } %522, { ptr, ptr, ptr, i32 } %522, ptr nonnull %118, i32 %513)
  %.fca.0.extract.i900 = extractvalue { ptr, i160 } %530, 0
  %531 = icmp ne ptr %.fca.0.extract.i900, @nil_typ
  %532 = icmp ne ptr %.fca.0.extract.i900, null
  %.not149.i901 = and i1 %531, %532
  br i1 %.not149.i901, label %533, label %.critedge.i902

533:                                              ; preds = %489
  %.fca.1.extract.i995 = extractvalue { ptr, i160 } %530, 1
  %.sroa.4520.8.extract.trunc.i996 = trunc i160 %.fca.1.extract.i995 to i64
  %534 = inttoptr i64 %.sroa.4520.8.extract.trunc.i996 to ptr
  %.sroa.7522.8.extract.shift.i997 = lshr i160 %.fca.1.extract.i995, 64
  %.sroa.7522.8.extract.trunc.i998 = trunc i160 %.sroa.7522.8.extract.shift.i997 to i64
  %535 = inttoptr i64 %.sroa.7522.8.extract.trunc.i998 to ptr
  %hash_coef_ptr.i.i176.i999 = getelementptr i8, ptr %.fca.0.extract.i900, i64 8
  %tbl_size_ptr.i.i177.i1000 = getelementptr i8, ptr %.fca.0.extract.i900, i64 16
  %offset_tbl_ptr.i.i178.i1001 = getelementptr i8, ptr %.fca.0.extract.i900, i64 40
  %hash_coef.i.i179.i1002 = load i64, ptr %hash_coef_ptr.i.i176.i999, align 4
  %tbl_size.i.i180.i1003 = load i64, ptr %tbl_size_ptr.i.i177.i1000, align 4
  %offset_tbl.i.i181.i1004 = load ptr, ptr %offset_tbl_ptr.i.i178.i1001, align 8
  %product.i.i.i182.i1005 = mul i64 %hash_coef.i.i179.i1002, 4015701072841558310
  %shifted.i.i.i183.i1006 = lshr i64 %product.i.i.i182.i1005, 32
  %xored.i.i.i184.i1007 = xor i64 %shifted.i.i.i183.i1006, %product.i.i.i182.i1005
  %hash.i.i.i185.i1008 = and i64 %xored.i.i.i184.i1007, %tbl_size.i.i180.i1003
  %offset_ptr.i.i186.i1009 = getelementptr i32, ptr %offset_tbl.i.i181.i1004, i64 %hash.i.i.i185.i1008
  %offset.i.i187.i1010 = load i32, ptr %offset_ptr.i.i186.i1009, align 4
  %536 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i900, 0
  %537 = insertvalue { ptr, ptr, ptr, i32 } %536, ptr %534, 1
  %538 = insertvalue { ptr, ptr, ptr, i32 } %537, ptr %535, 2
  %539 = insertvalue { ptr, ptr, ptr, i32 } %538, i32 %offset.i.i187.i1010, 3
  %540 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %541 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %542 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i900)
  %543 = sext i32 %offset.i.i187.i1010 to i64
  %544 = getelementptr ptr, ptr %.fca.0.extract.i900, i64 %543
  %545 = getelementptr i8, ptr %544, i64 64
  %546 = load ptr, ptr %545, align 8
  %547 = call ptr %546({ ptr, ptr, ptr, i32 } %539, ptr nonnull %2)
  %548 = call i32 %547({ ptr, ptr, ptr, i32 } %539, { ptr, ptr, ptr, i32 } %539, ptr nonnull %2)
  %549 = icmp eq i32 %548, %494
  %550 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %551 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %552 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i900)
  %553 = getelementptr i8, ptr %544, i64 48
  %554 = load ptr, ptr %553, align 8
  %555 = call ptr %554({ ptr, ptr, ptr, i32 } %539, ptr nonnull %2)
  %556 = call { ptr, i160 } %555({ ptr, ptr, ptr, i32 } %539, { ptr, ptr, ptr, i32 } %539, ptr nonnull %2)
  %557 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %558 = load ptr, ptr %151, align 8
  %559 = call i1 %558({ ptr, i160 } %556, { ptr, i160 } %324)
  %560 = and i1 %549, %559
  br i1 %560, label %561, label %.critedge.i902

561:                                              ; preds = %533
  %562 = load ptr, ptr %result.i, align 8
  %563 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %564 = load ptr, ptr %145, align 8
  %565 = load ptr, ptr %562, align 8
  %566 = getelementptr i8, ptr %565, i64 48
  %567 = load ptr, ptr %566, align 8
  %568 = call { i64, i64 } %567(ptr nonnull %562)
  %569 = extractvalue { i64, i64 } %568, 0
  %570 = extractvalue { i64, i64 } %568, 1
  %571 = urem i64 20, %570
  %572 = icmp eq i64 %571, 0
  %573 = sub i64 %570, %571
  %574 = select i1 %572, i64 0, i64 %573
  %575 = add i64 %569, 20
  %576 = add i64 %575, %574
  %577 = load ptr, ptr %564, align 8
  %578 = getelementptr i8, ptr %577, i64 48
  %579 = load ptr, ptr %578, align 8
  %580 = call { i64, i64 } %579(ptr nonnull %564)
  %581 = extractvalue { i64, i64 } %580, 0
  %582 = extractvalue { i64, i64 } %580, 1
  %583 = call i64 @llvm.umax.i64(i64 %570, i64 %582)
  %584 = call i64 @llvm.umax.i64(i64 %583, i64 8)
  %585 = urem i64 %576, %582
  %586 = icmp eq i64 %585, 0
  %587 = sub i64 %582, %585
  %588 = select i1 %586, i64 0, i64 %587
  %589 = add i64 %581, %576
  %590 = add i64 %589, %588
  %591 = urem i64 %590, %584
  %592 = icmp eq i64 %591, 0
  %593 = sub i64 %584, %591
  %594 = select i1 %592, i64 0, i64 %593
  %595 = add i64 %594, %590
  %result.i.i1012 = call noalias ptr @bump_malloc_inner(i64 noundef %595, ptr nonnull @current_ptr) #29
  store ptr %562, ptr %result.i.i1012, align 8
  %596 = getelementptr i8, ptr %result.i.i1012, i64 8
  store ptr %564, ptr %596, align 8
  %597 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i1012)
  store ptr @Entry, ptr %109, align 8
  store ptr %result.i.i1012, ptr %246, align 8
  store i32 9, ptr %247, align 8
  %598 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %109)
  %599 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %600 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %601 = load ptr, ptr %562, align 8
  %602 = getelementptr i8, ptr %601, i64 48
  %603 = load ptr, ptr %602, align 8
  %604 = call { i64, i64 } %603(ptr nonnull %562)
  %605 = extractvalue { i64, i64 } %604, 1
  %606 = urem i64 20, %605
  %607 = icmp eq i64 %606, 0
  %reass.sub = sub i64 %605, %606
  %608 = add i64 %reass.sub, 20
  %609 = select i1 %607, i64 20, i64 %608
  %610 = getelementptr i8, ptr %result.i.i1012, i64 %609
  %611 = load ptr, ptr %result.i.i1012, align 8
  %612 = load ptr, ptr %611, align 8
  %613 = getelementptr i8, ptr %612, i64 64
  %614 = load ptr, ptr %613, align 8
  call void %614({ ptr, i160 } %324, ptr nonnull %611, ptr %610)
  %615 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %616 = load ptr, ptr %result.i.i1012, align 8
  %617 = load ptr, ptr %616, align 8
  %618 = getelementptr i8, ptr %617, i64 48
  %619 = load ptr, ptr %618, align 8
  %620 = call { i64, i64 } %619(ptr nonnull %616)
  %621 = extractvalue { i64, i64 } %620, 0
  %622 = extractvalue { i64, i64 } %620, 1
  %623 = urem i64 20, %622
  %624 = icmp eq i64 %623, 0
  %625 = sub i64 %622, %623
  %626 = select i1 %624, i64 0, i64 %625
  %627 = add i64 %621, 20
  %628 = add i64 %627, %626
  %629 = load ptr, ptr %596, align 8
  %630 = load ptr, ptr %629, align 8
  %631 = getelementptr i8, ptr %630, i64 48
  %632 = load ptr, ptr %631, align 8
  %633 = call { i64, i64 } %632(ptr nonnull %629)
  %634 = extractvalue { i64, i64 } %633, 1
  %635 = urem i64 %628, %634
  %636 = icmp eq i64 %635, 0
  %637 = sub i64 %634, %635
  %638 = select i1 %636, i64 0, i64 %637
  %639 = getelementptr i8, ptr %result.i.i1012, i64 %628
  %640 = getelementptr i8, ptr %639, i64 %638
  %641 = load ptr, ptr %596, align 8
  %642 = load ptr, ptr %641, align 8
  %643 = getelementptr i8, ptr %642, i64 64
  %644 = load ptr, ptr %643, align 8
  call void %644({ ptr, i160 } %491, ptr nonnull %641, ptr %640)
  %645 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %646 = getelementptr i8, ptr %result.i.i1012, i64 16
  store i32 %494, ptr %646, align 4
  %647 = load ptr, ptr %248, align 8
  %648 = ptrtoint ptr %result.i.i1012 to i64
  %649 = ptrtoint ptr %647 to i64
  %.sroa.2127.0.insert.ext.i1013 = zext i64 %649 to i160
  %.sroa.2127.0.insert.shift.i1014 = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i1013, 64
  %.sroa.0126.0.insert.ext.i1016 = zext i64 %648 to i160
  %.sroa.2127.0.insert.insert.i1015 = or disjoint i160 %.sroa.2127.0.insert.shift.i1014, %.sroa.0126.0.insert.ext.i1016
  %.sroa.0126.0.insert.insert.i1017 = or disjoint i160 %.sroa.2127.0.insert.insert.i1015, 3062541302288446171170371466885913903104
  %650 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i1017, 1
  %651 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %652 = load ptr, ptr %162, align 8
  %653 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %652, 0
  %654 = load ptr, ptr %163, align 8
  %655 = insertvalue { ptr, ptr, ptr, i32 } %653, ptr %654, 1
  %656 = load ptr, ptr %251, align 8
  %657 = insertvalue { ptr, ptr, ptr, i32 } %655, ptr %656, 2
  %658 = load i32, ptr %164, align 4
  %659 = insertvalue { ptr, ptr, ptr, i32 } %657, i32 %658, 3
  %hash_coef_ptr.i.i204.i1022 = getelementptr i8, ptr %652, i64 8
  %tbl_size_ptr.i.i205.i1023 = getelementptr i8, ptr %652, i64 16
  %offset_tbl_ptr.i.i206.i1024 = getelementptr i8, ptr %652, i64 40
  %hash_coef.i.i207.i1025 = load i64, ptr %hash_coef_ptr.i.i204.i1022, align 4
  %tbl_size.i.i208.i1026 = load i64, ptr %tbl_size_ptr.i.i205.i1023, align 4
  %offset_tbl.i.i209.i1027 = load ptr, ptr %offset_tbl_ptr.i.i206.i1024, align 8
  %product.i.i.i210.i1028 = mul i64 %hash_coef.i.i207.i1025, -5261542750394134544
  %shifted.i.i.i211.i1029 = lshr i64 %product.i.i.i210.i1028, 32
  %xored.i.i.i212.i1030 = xor i64 %shifted.i.i.i211.i1029, %product.i.i.i210.i1028
  %hash.i.i.i213.i1031 = and i64 %xored.i.i.i212.i1030, %tbl_size.i.i208.i1026
  %offset_ptr.i.i214.i1032 = getelementptr i32, ptr %offset_tbl.i.i209.i1027, i64 %hash.i.i.i213.i1031
  %offset.i.i215.i1033 = load i32, ptr %offset_ptr.i.i214.i1032, align 4
  %eq.i218.i1034 = icmp eq i32 %658, %offset.i.i215.i1033
  call void @llvm.assume(i1 %eq.i218.i1034) #30
  %660 = load ptr, ptr %result.i, align 8
  %661 = load ptr, ptr %145, align 8
  %result.i219.i1035 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %662 = getelementptr i8, ptr %result.i219.i1035, i64 16
  store ptr %661, ptr %662, align 8
  %663 = getelementptr i8, ptr %result.i219.i1035, i64 8
  store ptr %660, ptr %663, align 8
  %664 = getelementptr i8, ptr %result.i219.i1035, i64 24
  store ptr null, ptr %664, align 8
  %665 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i1035)
  store ptr @Entry, ptr %result.i219.i1035, align 8
  store ptr @_parameterization_Ptri32, ptr %110, align 8
  store ptr %result.i219.i1035, ptr %249, align 8
  %666 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %110)
  %667 = call ptr @llvm.invariant.start.p0(i64 600, ptr %652)
  %668 = sext i32 %658 to i64
  %669 = getelementptr ptr, ptr %652, i64 %668
  %670 = getelementptr i8, ptr %669, i64 128
  %671 = load ptr, ptr %670, align 8
  store ptr @i32_typ, ptr %111, align 8
  store ptr @Entry, ptr %250, align 8
  %672 = call ptr %671({ ptr, ptr, ptr, i32 } %659, ptr nonnull %111)
  call void %672({ ptr, ptr, ptr, i32 } %659, { ptr, ptr, ptr, i32 } %659, ptr nonnull %110, i32 %513, { ptr, i160 } %650)
  br label %HashMap_insert_keyK_valueV.exit1036

.critedge.i902:                                   ; preds = %533, %489
  %673 = add i32 %494, 2127912214
  %674 = shl i32 %494, 12
  %675 = add i32 %673, %674
  %676 = ashr i32 %675, 19
  %677 = xor i32 %675, %676
  %678 = xor i32 %677, -949894596
  %679 = add i32 %678, 374761393
  %680 = shl i32 %678, 5
  %681 = add i32 %679, %680
  %682 = add i32 %681, -744332180
  %683 = shl i32 %681, 9
  %684 = xor i32 %682, %683
  %685 = add i32 %684, -42973499
  %686 = shl i32 %684, 3
  %687 = add i32 %685, %686
  %688 = ashr i32 %687, 16
  %689 = xor i32 %687, %688
  %690 = xor i32 %689, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %691 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %692 = load ptr, ptr %175, align 8
  %693 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %692, 0
  %694 = load ptr, ptr %176, align 8
  %695 = insertvalue { ptr, ptr, ptr, i32 } %693, ptr %694, 1
  %696 = load ptr, ptr %252, align 8
  %697 = insertvalue { ptr, ptr, ptr, i32 } %695, ptr %696, 2
  %698 = load i32, ptr %177, align 4
  %699 = insertvalue { ptr, ptr, ptr, i32 } %697, i32 %698, 3
  %hash_coef_ptr.i.i10.i2125 = getelementptr i8, ptr %692, i64 8
  %tbl_size_ptr.i.i11.i2126 = getelementptr i8, ptr %692, i64 16
  %offset_tbl_ptr.i.i12.i2127 = getelementptr i8, ptr %692, i64 40
  %hash_coef.i.i13.i2128 = load i64, ptr %hash_coef_ptr.i.i10.i2125, align 4
  %tbl_size.i.i14.i2129 = load i64, ptr %tbl_size_ptr.i.i11.i2126, align 4
  %offset_tbl.i.i15.i2130 = load ptr, ptr %offset_tbl_ptr.i.i12.i2127, align 8
  %product.i.i.i16.i2131 = mul i64 %hash_coef.i.i13.i2128, -5261542750394134544
  %shifted.i.i.i17.i2132 = lshr i64 %product.i.i.i16.i2131, 32
  %xored.i.i.i18.i2133 = xor i64 %shifted.i.i.i17.i2132, %product.i.i.i16.i2131
  %hash.i.i.i19.i2134 = and i64 %xored.i.i.i18.i2133, %tbl_size.i.i14.i2129
  %offset_ptr.i.i20.i2135 = getelementptr i32, ptr %offset_tbl.i.i15.i2130, i64 %hash.i.i.i19.i2134
  %offset.i.i21.i2136 = load i32, ptr %offset_ptr.i.i20.i2135, align 4
  %eq.i.i2137 = icmp eq i32 %698, %offset.i.i21.i2136
  call void @llvm.assume(i1 %eq.i.i2137) #30
  %700 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %701 = call ptr @llvm.invariant.start.p0(i64 600, ptr %692)
  %702 = sext i32 %698 to i64
  %703 = getelementptr ptr, ptr %692, i64 %702
  %704 = getelementptr i8, ptr %703, i64 64
  %705 = load ptr, ptr %704, align 8
  %706 = call ptr %705({ ptr, ptr, ptr, i32 } %699, ptr nonnull %2)
  %707 = call i32 %706({ ptr, ptr, ptr, i32 } %699, { ptr, ptr, ptr, i32 } %699, ptr nonnull %2)
  %708 = add i32 %707, -1
  %709 = and i32 %708, %690
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %710 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %711 = load ptr, ptr %175, align 8
  %712 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %711, 0
  %713 = load ptr, ptr %176, align 8
  %714 = insertvalue { ptr, ptr, ptr, i32 } %712, ptr %713, 1
  %715 = load ptr, ptr %252, align 8
  %716 = insertvalue { ptr, ptr, ptr, i32 } %714, ptr %715, 2
  %717 = load i32, ptr %177, align 4
  %718 = insertvalue { ptr, ptr, ptr, i32 } %716, i32 %717, 3
  %hash_coef_ptr.i.i221.i907 = getelementptr i8, ptr %711, i64 8
  %tbl_size_ptr.i.i222.i908 = getelementptr i8, ptr %711, i64 16
  %offset_tbl_ptr.i.i223.i909 = getelementptr i8, ptr %711, i64 40
  %hash_coef.i.i224.i910 = load i64, ptr %hash_coef_ptr.i.i221.i907, align 4
  %tbl_size.i.i225.i911 = load i64, ptr %tbl_size_ptr.i.i222.i908, align 4
  %offset_tbl.i.i226.i912 = load ptr, ptr %offset_tbl_ptr.i.i223.i909, align 8
  %product.i.i.i227.i913 = mul i64 %hash_coef.i.i224.i910, -5261542750394134544
  %shifted.i.i.i228.i914 = lshr i64 %product.i.i.i227.i913, 32
  %xored.i.i.i229.i915 = xor i64 %shifted.i.i.i228.i914, %product.i.i.i227.i913
  %hash.i.i.i230.i916 = and i64 %xored.i.i.i229.i915, %tbl_size.i.i225.i911
  %offset_ptr.i.i231.i917 = getelementptr i32, ptr %offset_tbl.i.i226.i912, i64 %hash.i.i.i230.i916
  %offset.i.i232.i918 = load i32, ptr %offset_ptr.i.i231.i917, align 4
  %eq.i235.i919 = icmp eq i32 %717, %offset.i.i232.i918
  call void @llvm.assume(i1 %eq.i235.i919) #30
  store ptr @_parameterization_Ptri32, ptr %112, align 8
  %719 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %112)
  %720 = call ptr @llvm.invariant.start.p0(i64 600, ptr %711)
  %721 = sext i32 %717 to i64
  %722 = getelementptr ptr, ptr %711, i64 %721
  %723 = getelementptr i8, ptr %722, i64 120
  %724 = load ptr, ptr %723, align 8
  store ptr @i32_typ, ptr %113, align 8
  %725 = call ptr %724({ ptr, ptr, ptr, i32 } %718, ptr nonnull %113)
  %726 = call { ptr, i160 } %725({ ptr, ptr, ptr, i32 } %718, { ptr, ptr, ptr, i32 } %718, ptr nonnull %112, i32 %709)
  %.fca.0.extract102.i920 = extractvalue { ptr, i160 } %726, 0
  %727 = icmp ne ptr %.fca.0.extract102.i920, @nil_typ
  %728 = icmp ne ptr %.fca.0.extract102.i920, null
  %.not151.i921 = and i1 %727, %728
  br i1 %.not151.i921, label %729, label %.critedge158.i922

729:                                              ; preds = %.critedge.i902
  %.fca.1.extract104.i954 = extractvalue { ptr, i160 } %726, 1
  %.sroa.4.8.extract.trunc.i955 = trunc i160 %.fca.1.extract104.i954 to i64
  %730 = inttoptr i64 %.sroa.4.8.extract.trunc.i955 to ptr
  %.sroa.7508.8.extract.shift.i956 = lshr i160 %.fca.1.extract104.i954, 64
  %.sroa.7508.8.extract.trunc.i957 = trunc i160 %.sroa.7508.8.extract.shift.i956 to i64
  %731 = inttoptr i64 %.sroa.7508.8.extract.trunc.i957 to ptr
  %hash_coef_ptr.i.i237.i958 = getelementptr i8, ptr %.fca.0.extract102.i920, i64 8
  %tbl_size_ptr.i.i238.i959 = getelementptr i8, ptr %.fca.0.extract102.i920, i64 16
  %offset_tbl_ptr.i.i239.i960 = getelementptr i8, ptr %.fca.0.extract102.i920, i64 40
  %hash_coef.i.i240.i961 = load i64, ptr %hash_coef_ptr.i.i237.i958, align 4
  %tbl_size.i.i241.i962 = load i64, ptr %tbl_size_ptr.i.i238.i959, align 4
  %offset_tbl.i.i242.i963 = load ptr, ptr %offset_tbl_ptr.i.i239.i960, align 8
  %product.i.i.i243.i964 = mul i64 %hash_coef.i.i240.i961, 4015701072841558310
  %shifted.i.i.i244.i965 = lshr i64 %product.i.i.i243.i964, 32
  %xored.i.i.i245.i966 = xor i64 %shifted.i.i.i244.i965, %product.i.i.i243.i964
  %hash.i.i.i246.i967 = and i64 %xored.i.i.i245.i966, %tbl_size.i.i241.i962
  %offset_ptr.i.i247.i968 = getelementptr i32, ptr %offset_tbl.i.i242.i963, i64 %hash.i.i.i246.i967
  %offset.i.i248.i969 = load i32, ptr %offset_ptr.i.i247.i968, align 4
  %732 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i920, 0
  %733 = insertvalue { ptr, ptr, ptr, i32 } %732, ptr %730, 1
  %734 = insertvalue { ptr, ptr, ptr, i32 } %733, ptr %731, 2
  %735 = insertvalue { ptr, ptr, ptr, i32 } %734, i32 %offset.i.i248.i969, 3
  %736 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %737 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %738 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i920)
  %739 = sext i32 %offset.i.i248.i969 to i64
  %740 = getelementptr ptr, ptr %.fca.0.extract102.i920, i64 %739
  %741 = getelementptr i8, ptr %740, i64 64
  %742 = load ptr, ptr %741, align 8
  %743 = call ptr %742({ ptr, ptr, ptr, i32 } %735, ptr nonnull %2)
  %744 = call i32 %743({ ptr, ptr, ptr, i32 } %735, { ptr, ptr, ptr, i32 } %735, ptr nonnull %2)
  %745 = icmp eq i32 %744, %494
  %746 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %747 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %748 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i920)
  %749 = getelementptr i8, ptr %740, i64 48
  %750 = load ptr, ptr %749, align 8
  %751 = call ptr %750({ ptr, ptr, ptr, i32 } %735, ptr nonnull %2)
  %752 = call { ptr, i160 } %751({ ptr, ptr, ptr, i32 } %735, { ptr, ptr, ptr, i32 } %735, ptr nonnull %2)
  %753 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %754 = load ptr, ptr %151, align 8
  %755 = call i1 %754({ ptr, i160 } %752, { ptr, i160 } %324)
  %756 = and i1 %745, %755
  br i1 %756, label %757, label %.critedge158.i922

757:                                              ; preds = %729
  %758 = load ptr, ptr %result.i, align 8
  %759 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %760 = load ptr, ptr %145, align 8
  %761 = load ptr, ptr %758, align 8
  %762 = getelementptr i8, ptr %761, i64 48
  %763 = load ptr, ptr %762, align 8
  %764 = call { i64, i64 } %763(ptr nonnull %758)
  %765 = extractvalue { i64, i64 } %764, 0
  %766 = extractvalue { i64, i64 } %764, 1
  %767 = urem i64 20, %766
  %768 = icmp eq i64 %767, 0
  %769 = sub i64 %766, %767
  %770 = select i1 %768, i64 0, i64 %769
  %771 = add i64 %765, 20
  %772 = add i64 %771, %770
  %773 = load ptr, ptr %760, align 8
  %774 = getelementptr i8, ptr %773, i64 48
  %775 = load ptr, ptr %774, align 8
  %776 = call { i64, i64 } %775(ptr nonnull %760)
  %777 = extractvalue { i64, i64 } %776, 0
  %778 = extractvalue { i64, i64 } %776, 1
  %779 = call i64 @llvm.umax.i64(i64 %766, i64 %778)
  %780 = call i64 @llvm.umax.i64(i64 %779, i64 8)
  %781 = urem i64 %772, %778
  %782 = icmp eq i64 %781, 0
  %783 = sub i64 %778, %781
  %784 = select i1 %782, i64 0, i64 %783
  %785 = add i64 %777, %772
  %786 = add i64 %785, %784
  %787 = urem i64 %786, %780
  %788 = icmp eq i64 %787, 0
  %789 = sub i64 %780, %787
  %790 = select i1 %788, i64 0, i64 %789
  %791 = add i64 %790, %786
  %result.i250.i971 = call noalias ptr @bump_malloc_inner(i64 noundef %791, ptr nonnull @current_ptr) #29
  store ptr %758, ptr %result.i250.i971, align 8
  %792 = getelementptr i8, ptr %result.i250.i971, i64 8
  store ptr %760, ptr %792, align 8
  %793 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i971)
  store ptr @Entry, ptr %114, align 8
  store ptr %result.i250.i971, ptr %241, align 8
  store i32 9, ptr %242, align 8
  %794 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %114)
  %795 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %796 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %797 = load ptr, ptr %758, align 8
  %798 = getelementptr i8, ptr %797, i64 48
  %799 = load ptr, ptr %798, align 8
  %800 = call { i64, i64 } %799(ptr nonnull %758)
  %801 = extractvalue { i64, i64 } %800, 1
  %802 = urem i64 20, %801
  %803 = icmp eq i64 %802, 0
  %reass.sub3771 = sub i64 %801, %802
  %804 = add i64 %reass.sub3771, 20
  %805 = select i1 %803, i64 20, i64 %804
  %806 = getelementptr i8, ptr %result.i250.i971, i64 %805
  %807 = load ptr, ptr %result.i250.i971, align 8
  %808 = load ptr, ptr %807, align 8
  %809 = getelementptr i8, ptr %808, i64 64
  %810 = load ptr, ptr %809, align 8
  call void %810({ ptr, i160 } %324, ptr nonnull %807, ptr %806)
  %811 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %812 = load ptr, ptr %result.i250.i971, align 8
  %813 = load ptr, ptr %812, align 8
  %814 = getelementptr i8, ptr %813, i64 48
  %815 = load ptr, ptr %814, align 8
  %816 = call { i64, i64 } %815(ptr nonnull %812)
  %817 = extractvalue { i64, i64 } %816, 0
  %818 = extractvalue { i64, i64 } %816, 1
  %819 = urem i64 20, %818
  %820 = icmp eq i64 %819, 0
  %821 = sub i64 %818, %819
  %822 = select i1 %820, i64 0, i64 %821
  %823 = add i64 %817, 20
  %824 = add i64 %823, %822
  %825 = load ptr, ptr %792, align 8
  %826 = load ptr, ptr %825, align 8
  %827 = getelementptr i8, ptr %826, i64 48
  %828 = load ptr, ptr %827, align 8
  %829 = call { i64, i64 } %828(ptr nonnull %825)
  %830 = extractvalue { i64, i64 } %829, 1
  %831 = urem i64 %824, %830
  %832 = icmp eq i64 %831, 0
  %833 = sub i64 %830, %831
  %834 = select i1 %832, i64 0, i64 %833
  %835 = getelementptr i8, ptr %result.i250.i971, i64 %824
  %836 = getelementptr i8, ptr %835, i64 %834
  %837 = load ptr, ptr %792, align 8
  %838 = load ptr, ptr %837, align 8
  %839 = getelementptr i8, ptr %838, i64 64
  %840 = load ptr, ptr %839, align 8
  call void %840({ ptr, i160 } %491, ptr nonnull %837, ptr %836)
  %841 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %842 = getelementptr i8, ptr %result.i250.i971, i64 16
  store i32 %494, ptr %842, align 4
  %843 = load ptr, ptr %243, align 8
  %844 = ptrtoint ptr %result.i250.i971 to i64
  %845 = ptrtoint ptr %843 to i64
  %.sroa.282.0.insert.ext.i972 = zext i64 %845 to i160
  %.sroa.282.0.insert.shift.i973 = shl nuw nsw i160 %.sroa.282.0.insert.ext.i972, 64
  %.sroa.081.0.insert.ext.i975 = zext i64 %844 to i160
  %.sroa.282.0.insert.insert.i974 = or disjoint i160 %.sroa.282.0.insert.shift.i973, %.sroa.081.0.insert.ext.i975
  %.sroa.081.0.insert.insert.i976 = or disjoint i160 %.sroa.282.0.insert.insert.i974, 3062541302288446171170371466885913903104
  %846 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i976, 1
  %847 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %848 = load ptr, ptr %175, align 8
  %849 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %848, 0
  %850 = load ptr, ptr %176, align 8
  %851 = insertvalue { ptr, ptr, ptr, i32 } %849, ptr %850, 1
  %852 = load ptr, ptr %252, align 8
  %853 = insertvalue { ptr, ptr, ptr, i32 } %851, ptr %852, 2
  %854 = load i32, ptr %177, align 4
  %855 = insertvalue { ptr, ptr, ptr, i32 } %853, i32 %854, 3
  %hash_coef_ptr.i.i266.i981 = getelementptr i8, ptr %848, i64 8
  %tbl_size_ptr.i.i267.i982 = getelementptr i8, ptr %848, i64 16
  %offset_tbl_ptr.i.i268.i983 = getelementptr i8, ptr %848, i64 40
  %hash_coef.i.i269.i984 = load i64, ptr %hash_coef_ptr.i.i266.i981, align 4
  %tbl_size.i.i270.i985 = load i64, ptr %tbl_size_ptr.i.i267.i982, align 4
  %offset_tbl.i.i271.i986 = load ptr, ptr %offset_tbl_ptr.i.i268.i983, align 8
  %product.i.i.i272.i987 = mul i64 %hash_coef.i.i269.i984, -5261542750394134544
  %shifted.i.i.i273.i988 = lshr i64 %product.i.i.i272.i987, 32
  %xored.i.i.i274.i989 = xor i64 %shifted.i.i.i273.i988, %product.i.i.i272.i987
  %hash.i.i.i275.i990 = and i64 %xored.i.i.i274.i989, %tbl_size.i.i270.i985
  %offset_ptr.i.i276.i991 = getelementptr i32, ptr %offset_tbl.i.i271.i986, i64 %hash.i.i.i275.i990
  %offset.i.i277.i992 = load i32, ptr %offset_ptr.i.i276.i991, align 4
  %eq.i280.i993 = icmp eq i32 %854, %offset.i.i277.i992
  call void @llvm.assume(i1 %eq.i280.i993) #30
  %856 = load ptr, ptr %result.i, align 8
  %857 = load ptr, ptr %145, align 8
  %result.i281.i994 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %858 = getelementptr i8, ptr %result.i281.i994, i64 16
  store ptr %857, ptr %858, align 8
  %859 = getelementptr i8, ptr %result.i281.i994, i64 8
  store ptr %856, ptr %859, align 8
  %860 = getelementptr i8, ptr %result.i281.i994, i64 24
  store ptr null, ptr %860, align 8
  %861 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i994)
  store ptr @Entry, ptr %result.i281.i994, align 8
  store ptr @_parameterization_Ptri32, ptr %115, align 8
  store ptr %result.i281.i994, ptr %244, align 8
  %862 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %115)
  %863 = call ptr @llvm.invariant.start.p0(i64 600, ptr %848)
  %864 = sext i32 %854 to i64
  %865 = getelementptr ptr, ptr %848, i64 %864
  %866 = getelementptr i8, ptr %865, i64 128
  %867 = load ptr, ptr %866, align 8
  store ptr @i32_typ, ptr %116, align 8
  store ptr @Entry, ptr %245, align 8
  %868 = call ptr %867({ ptr, ptr, ptr, i32 } %855, ptr nonnull %116)
  call void %868({ ptr, ptr, ptr, i32 } %855, { ptr, ptr, ptr, i32 } %855, ptr nonnull %115, i32 %709, { ptr, i160 } %846)
  br label %HashMap_insert_keyK_valueV.exit1036

.critedge158.i922:                                ; preds = %729, %.critedge.i902
  %869 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %870 = load ptr, ptr %162, align 8
  %871 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %870, 0
  %872 = load ptr, ptr %163, align 8
  %873 = insertvalue { ptr, ptr, ptr, i32 } %871, ptr %872, 1
  %874 = load ptr, ptr %251, align 8
  %875 = insertvalue { ptr, ptr, ptr, i32 } %873, ptr %874, 2
  %876 = load i32, ptr %164, align 4
  %877 = insertvalue { ptr, ptr, ptr, i32 } %875, i32 %876, 3
  %hash_coef_ptr.i.i283.i927 = getelementptr i8, ptr %870, i64 8
  %tbl_size_ptr.i.i284.i928 = getelementptr i8, ptr %870, i64 16
  %offset_tbl_ptr.i.i285.i929 = getelementptr i8, ptr %870, i64 40
  %hash_coef.i.i286.i930 = load i64, ptr %hash_coef_ptr.i.i283.i927, align 4
  %tbl_size.i.i287.i931 = load i64, ptr %tbl_size_ptr.i.i284.i928, align 4
  %offset_tbl.i.i288.i932 = load ptr, ptr %offset_tbl_ptr.i.i285.i929, align 8
  %product.i.i.i289.i933 = mul i64 %hash_coef.i.i286.i930, -5261542750394134544
  %shifted.i.i.i290.i934 = lshr i64 %product.i.i.i289.i933, 32
  %xored.i.i.i291.i935 = xor i64 %shifted.i.i.i290.i934, %product.i.i.i289.i933
  %hash.i.i.i292.i936 = and i64 %xored.i.i.i291.i935, %tbl_size.i.i287.i931
  %offset_ptr.i.i293.i937 = getelementptr i32, ptr %offset_tbl.i.i288.i932, i64 %hash.i.i.i292.i936
  %offset.i.i294.i938 = load i32, ptr %offset_ptr.i.i293.i937, align 4
  %eq.i297.i939 = icmp eq i32 %876, %offset.i.i294.i938
  call void @llvm.assume(i1 %eq.i297.i939) #30
  %878 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %879 = call ptr @llvm.invariant.start.p0(i64 600, ptr %870)
  %880 = sext i32 %876 to i64
  %881 = getelementptr ptr, ptr %870, i64 %880
  %882 = getelementptr i8, ptr %881, i64 64
  %883 = load ptr, ptr %882, align 8
  %884 = call ptr %883({ ptr, ptr, ptr, i32 } %877, ptr nonnull %2)
  %885 = call i32 %884({ ptr, ptr, ptr, i32 } %877, { ptr, ptr, ptr, i32 } %877, ptr nonnull %2)
  %886 = load i32, ptr %253, align 4
  %.not.i940 = icmp slt i32 %886, %885
  br i1 %.not.i940, label %._crit_edge.i941, label %887

887:                                              ; preds = %.critedge158.i922
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %53)
  %888 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %889 = load ptr, ptr %162, align 8
  %890 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %889, 0
  %891 = load ptr, ptr %163, align 8
  %892 = insertvalue { ptr, ptr, ptr, i32 } %890, ptr %891, 1
  %893 = load ptr, ptr %251, align 8
  %894 = insertvalue { ptr, ptr, ptr, i32 } %892, ptr %893, 2
  %895 = load i32, ptr %164, align 4
  %896 = insertvalue { ptr, ptr, ptr, i32 } %894, i32 %895, 3
  %hash_coef_ptr.i.i64.i2154 = getelementptr i8, ptr %889, i64 8
  %tbl_size_ptr.i.i65.i2155 = getelementptr i8, ptr %889, i64 16
  %offset_tbl_ptr.i.i66.i2156 = getelementptr i8, ptr %889, i64 40
  %hash_coef.i.i67.i2157 = load i64, ptr %hash_coef_ptr.i.i64.i2154, align 4
  %tbl_size.i.i68.i2158 = load i64, ptr %tbl_size_ptr.i.i65.i2155, align 4
  %offset_tbl.i.i69.i2159 = load ptr, ptr %offset_tbl_ptr.i.i66.i2156, align 8
  %product.i.i.i70.i2160 = mul i64 %hash_coef.i.i67.i2157, -5261542750394134544
  %shifted.i.i.i71.i2161 = lshr i64 %product.i.i.i70.i2160, 32
  %xored.i.i.i72.i2162 = xor i64 %shifted.i.i.i71.i2161, %product.i.i.i70.i2160
  %hash.i.i.i73.i2163 = and i64 %xored.i.i.i72.i2162, %tbl_size.i.i68.i2158
  %offset_ptr.i.i74.i2164 = getelementptr i32, ptr %offset_tbl.i.i69.i2159, i64 %hash.i.i.i73.i2163
  %offset.i.i75.i2165 = load i32, ptr %offset_ptr.i.i74.i2164, align 4
  %eq.i.i2166 = icmp eq i32 %895, %offset.i.i75.i2165
  call void @llvm.assume(i1 %eq.i.i2166) #30
  %897 = load ptr, ptr %175, align 8
  %898 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %897, 0
  %899 = load ptr, ptr %176, align 8
  %900 = insertvalue { ptr, ptr, ptr, i32 } %898, ptr %899, 1
  %901 = load ptr, ptr %252, align 8
  %902 = insertvalue { ptr, ptr, ptr, i32 } %900, ptr %901, 2
  %903 = load i32, ptr %177, align 4
  %904 = insertvalue { ptr, ptr, ptr, i32 } %902, i32 %903, 3
  %hash_coef_ptr.i.i92.i2171 = getelementptr i8, ptr %897, i64 8
  %tbl_size_ptr.i.i93.i2172 = getelementptr i8, ptr %897, i64 16
  %offset_tbl_ptr.i.i94.i2173 = getelementptr i8, ptr %897, i64 40
  %hash_coef.i.i95.i2174 = load i64, ptr %hash_coef_ptr.i.i92.i2171, align 4
  %tbl_size.i.i96.i2175 = load i64, ptr %tbl_size_ptr.i.i93.i2172, align 4
  %offset_tbl.i.i97.i2176 = load ptr, ptr %offset_tbl_ptr.i.i94.i2173, align 8
  %product.i.i.i98.i2177 = mul i64 %hash_coef.i.i95.i2174, -5261542750394134544
  %shifted.i.i.i99.i2178 = lshr i64 %product.i.i.i98.i2177, 32
  %xored.i.i.i100.i2179 = xor i64 %shifted.i.i.i99.i2178, %product.i.i.i98.i2177
  %hash.i.i.i101.i2180 = and i64 %xored.i.i.i100.i2179, %tbl_size.i.i96.i2175
  %offset_ptr.i.i102.i2181 = getelementptr i32, ptr %offset_tbl.i.i97.i2176, i64 %hash.i.i.i101.i2180
  %offset.i.i103.i2182 = load i32, ptr %offset_ptr.i.i102.i2181, align 4
  %eq.i106.i2183 = icmp eq i32 %903, %offset.i.i103.i2182
  call void @llvm.assume(i1 %eq.i106.i2183) #30
  %905 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %906 = call ptr @llvm.invariant.start.p0(i64 600, ptr %889)
  %907 = sext i32 %895 to i64
  %908 = getelementptr ptr, ptr %889, i64 %907
  %909 = getelementptr i8, ptr %908, i64 64
  %910 = load ptr, ptr %909, align 8
  %911 = call ptr %910({ ptr, ptr, ptr, i32 } %896, ptr nonnull %2)
  %912 = call i32 %911({ ptr, ptr, ptr, i32 } %896, { ptr, ptr, ptr, i32 } %896, ptr nonnull %2)
  %913 = shl i32 %912, 1
  %914 = load i32, ptr %253, align 4
  %915 = load ptr, ptr %result.i, align 8
  %916 = load ptr, ptr %145, align 8
  %917 = sext i32 %914 to i64
  %918 = shl nsw i64 %917, 5
  %result.i.i.i2186 = call noalias ptr @bump_malloc_inner(i64 noundef %918, ptr nonnull @current_ptr) #29
  %919 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %920 = icmp sgt i32 %912, 0
  br i1 %920, label %.lr.ph434.i2219, label %._crit_edge395.i2188

.lr.ph434.i2219:                                  ; preds = %887
  %invariant.gep.i2187 = getelementptr i8, ptr %889, i64 120
  %921 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i2222 = getelementptr ptr, ptr %invariant.gep.i2187, i64 %907
  br label %922

922:                                              ; preds = %944, %.lr.ph434.i2219
  %.reg2mem105.0432.i2220 = phi i32 [ 0, %.lr.ph434.i2219 ], [ %.reg2mem101.0.i2225, %944 ]
  %.reg2mem103.0431.i2221 = phi i32 [ 0, %.lr.ph434.i2219 ], [ %945, %944 ]
  store ptr @_parameterization_Ptri32, ptr %48, align 8
  %923 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %48)
  %924 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %889)
  %925 = load ptr, ptr %gep.i2222, align 8
  store ptr @i32_typ, ptr %49, align 8
  %926 = call ptr %925({ ptr, ptr, ptr, i32 } %896, ptr nonnull %49)
  %927 = call { ptr, i160 } %926({ ptr, ptr, ptr, i32 } %896, { ptr, ptr, ptr, i32 } %896, ptr nonnull %48, i32 %.reg2mem103.0431.i2221)
  %.fca.0.extract52.i2223 = extractvalue { ptr, i160 } %927, 0
  %928 = icmp ne ptr %.fca.0.extract52.i2223, @nil_typ
  %929 = icmp ne ptr %.fca.0.extract52.i2223, null
  %.not60.i2224 = and i1 %928, %929
  br i1 %.not60.i2224, label %930, label %944

930:                                              ; preds = %922
  %hash_coef_ptr.i.i137.i2252 = getelementptr i8, ptr %.fca.0.extract52.i2223, i64 8
  %tbl_size_ptr.i.i138.i2253 = getelementptr i8, ptr %.fca.0.extract52.i2223, i64 16
  %offset_tbl_ptr.i.i139.i2254 = getelementptr i8, ptr %.fca.0.extract52.i2223, i64 40
  %hash_coef.i.i140.i2255 = load i64, ptr %hash_coef_ptr.i.i137.i2252, align 4
  %tbl_size.i.i141.i2256 = load i64, ptr %tbl_size_ptr.i.i138.i2253, align 4
  %offset_tbl.i.i142.i2257 = load ptr, ptr %offset_tbl_ptr.i.i139.i2254, align 8
  %product.i.i.i143.i2258 = mul i64 %hash_coef.i.i140.i2255, 4015701072841558310
  %shifted.i.i.i144.i2259 = lshr i64 %product.i.i.i143.i2258, 32
  %xored.i.i.i145.i2260 = xor i64 %shifted.i.i.i144.i2259, %product.i.i.i143.i2258
  %hash.i.i.i146.i2261 = and i64 %xored.i.i.i145.i2260, %tbl_size.i.i141.i2256
  %offset_ptr.i.i147.i2262 = getelementptr i32, ptr %offset_tbl.i.i142.i2257, i64 %hash.i.i.i146.i2261
  %offset.i.i148.i2263 = load i32, ptr %offset_ptr.i.i147.i2262, align 4
  %931 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %932 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %933 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %934 = icmp slt i32 %.reg2mem105.0432.i2220, %914
  br i1 %934, label %935, label %._crit_edge.i2264

935:                                              ; preds = %930
  %.fca.1.extract54.i2265 = extractvalue { ptr, i160 } %927, 1
  %.sroa.351.0.insert.ext.i2266 = zext i32 %offset.i.i148.i2263 to i160
  %.sroa.351.0.insert.shift.i2267 = shl nuw i160 %.sroa.351.0.insert.ext.i2266, 128
  %936 = and i160 %.fca.1.extract54.i2265, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2268 = or disjoint i160 %.sroa.351.0.insert.shift.i2267, %936
  %937 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %938 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %939 = sext i32 %.reg2mem105.0432.i2220 to i64
  %940 = shl nsw i64 %939, 5
  %941 = getelementptr i8, ptr %result.i.i.i2186, i64 %940
  store ptr %.fca.0.extract52.i2223, ptr %941, align 8
  %942 = getelementptr i8, ptr %941, i64 8
  store i160 %.sroa.049.0.insert.insert.i2268, ptr %942, align 4
  br label %._crit_edge.i2264

._crit_edge.i2264:                                ; preds = %935, %930
  %943 = add i32 %.reg2mem105.0432.i2220, 1
  br label %944

944:                                              ; preds = %._crit_edge.i2264, %922
  %.reg2mem101.0.i2225 = phi i32 [ %943, %._crit_edge.i2264 ], [ %.reg2mem105.0432.i2220, %922 ]
  %945 = add nuw nsw i32 %.reg2mem103.0431.i2221, 1
  %946 = icmp slt i32 %945, %912
  br i1 %946, label %922, label %.lr.ph.i2226

.lr.ph.i2226:                                     ; preds = %944
  %invariant.gep396.i2227 = getelementptr i8, ptr %897, i64 120
  %947 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %948 = sext i32 %903 to i64
  %gep397.i2230 = getelementptr ptr, ptr %invariant.gep396.i2227, i64 %948
  br label %949

949:                                              ; preds = %971, %.lr.ph.i2226
  %.reg2mem91.0394.i2228 = phi i32 [ %.reg2mem101.0.i2225, %.lr.ph.i2226 ], [ %.reg2mem87.0.i2233, %971 ]
  %.reg2mem89.0393.i2229 = phi i32 [ 0, %.lr.ph.i2226 ], [ %972, %971 ]
  store ptr @_parameterization_Ptri32, ptr %50, align 8
  %950 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %50)
  %951 = call ptr @llvm.invariant.start.p0(i64 600, ptr %897)
  %952 = load ptr, ptr %gep397.i2230, align 8
  store ptr @i32_typ, ptr %51, align 8
  %953 = call ptr %952({ ptr, ptr, ptr, i32 } %904, ptr nonnull %51)
  %954 = call { ptr, i160 } %953({ ptr, ptr, ptr, i32 } %904, { ptr, ptr, ptr, i32 } %904, ptr nonnull %50, i32 %.reg2mem89.0393.i2229)
  %.fca.0.extract42.i2231 = extractvalue { ptr, i160 } %954, 0
  %955 = icmp ne ptr %.fca.0.extract42.i2231, @nil_typ
  %956 = icmp ne ptr %.fca.0.extract42.i2231, null
  %.not62.i2232 = and i1 %955, %956
  br i1 %.not62.i2232, label %957, label %971

957:                                              ; preds = %949
  %hash_coef_ptr.i.i152.i2234 = getelementptr i8, ptr %.fca.0.extract42.i2231, i64 8
  %tbl_size_ptr.i.i153.i2235 = getelementptr i8, ptr %.fca.0.extract42.i2231, i64 16
  %offset_tbl_ptr.i.i154.i2236 = getelementptr i8, ptr %.fca.0.extract42.i2231, i64 40
  %hash_coef.i.i155.i2237 = load i64, ptr %hash_coef_ptr.i.i152.i2234, align 4
  %tbl_size.i.i156.i2238 = load i64, ptr %tbl_size_ptr.i.i153.i2235, align 4
  %offset_tbl.i.i157.i2239 = load ptr, ptr %offset_tbl_ptr.i.i154.i2236, align 8
  %product.i.i.i158.i2240 = mul i64 %hash_coef.i.i155.i2237, 4015701072841558310
  %shifted.i.i.i159.i2241 = lshr i64 %product.i.i.i158.i2240, 32
  %xored.i.i.i160.i2242 = xor i64 %shifted.i.i.i159.i2241, %product.i.i.i158.i2240
  %hash.i.i.i161.i2243 = and i64 %xored.i.i.i160.i2242, %tbl_size.i.i156.i2238
  %offset_ptr.i.i162.i2244 = getelementptr i32, ptr %offset_tbl.i.i157.i2239, i64 %hash.i.i.i161.i2243
  %offset.i.i163.i2245 = load i32, ptr %offset_ptr.i.i162.i2244, align 4
  %958 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %959 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %960 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %961 = icmp slt i32 %.reg2mem91.0394.i2228, %914
  br i1 %961, label %962, label %._crit_edge1.i2246

962:                                              ; preds = %957
  %.fca.1.extract44.i2247 = extractvalue { ptr, i160 } %954, 1
  %.sroa.3.0.insert.ext.i2248 = zext i32 %offset.i.i163.i2245 to i160
  %.sroa.3.0.insert.shift.i2249 = shl nuw i160 %.sroa.3.0.insert.ext.i2248, 128
  %963 = and i160 %.fca.1.extract44.i2247, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2250 = or disjoint i160 %.sroa.3.0.insert.shift.i2249, %963
  %964 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %965 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %966 = sext i32 %.reg2mem91.0394.i2228 to i64
  %967 = shl nsw i64 %966, 5
  %968 = getelementptr i8, ptr %result.i.i.i2186, i64 %967
  store ptr %.fca.0.extract42.i2231, ptr %968, align 8
  %969 = getelementptr i8, ptr %968, i64 8
  store i160 %.sroa.040.0.insert.insert.i2250, ptr %969, align 4
  br label %._crit_edge1.i2246

._crit_edge1.i2246:                               ; preds = %962, %957
  %970 = add i32 %.reg2mem91.0394.i2228, 1
  br label %971

971:                                              ; preds = %._crit_edge1.i2246, %949
  %.reg2mem87.0.i2233 = phi i32 [ %970, %._crit_edge1.i2246 ], [ %.reg2mem91.0394.i2228, %949 ]
  %972 = add nuw nsw i32 %.reg2mem89.0393.i2229, 1
  %973 = icmp slt i32 %972, %912
  br i1 %973, label %949, label %._crit_edge395.i2188.loopexit

._crit_edge395.i2188.loopexit:                    ; preds = %971
  %.pre3417 = load ptr, ptr %result.i, align 8
  %.pre3418 = load ptr, ptr %145, align 8
  br label %._crit_edge395.i2188

._crit_edge395.i2188:                             ; preds = %._crit_edge395.i2188.loopexit, %887
  %974 = phi ptr [ %916, %887 ], [ %.pre3418, %._crit_edge395.i2188.loopexit ]
  %975 = phi ptr [ %915, %887 ], [ %.pre3417, %._crit_edge395.i2188.loopexit ]
  %.reg2mem91.0.lcssa.i2189 = phi i32 [ 0, %887 ], [ %.reg2mem87.0.i2233, %._crit_edge395.i2188.loopexit ]
  %976 = call i32 @llvm.smax.i32(i32 %913, i32 16)
  %result.i166.i2190 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %977 = getelementptr i8, ptr %result.i166.i2190, i64 16
  store ptr @_parameterization_Nil, ptr %977, align 8
  %result.i167.i2191 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %978 = getelementptr i8, ptr %result.i167.i2191, i64 16
  store ptr %974, ptr %978, align 8
  %979 = getelementptr i8, ptr %result.i167.i2191, i64 8
  store ptr %975, ptr %979, align 8
  %980 = getelementptr i8, ptr %result.i167.i2191, i64 24
  store ptr null, ptr %980, align 8
  %981 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i2191)
  store ptr @Entry, ptr %result.i167.i2191, align 8
  %982 = getelementptr i8, ptr %result.i166.i2190, i64 8
  store ptr %result.i167.i2191, ptr %982, align 8
  %983 = getelementptr i8, ptr %result.i166.i2190, i64 24
  store ptr null, ptr %983, align 8
  %984 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i2190)
  store ptr @union_typ, ptr %result.i166.i2190, align 8
  %result.i168.i2192 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i2190, ptr %result.i168.i2192, align 8
  %985 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i2192)
  store ptr @Array, ptr %52, align 8
  store ptr %result.i168.i2192, ptr %286, align 8
  store i32 9, ptr %287, align 8
  %986 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %52)
  %987 = getelementptr i8, ptr %result.i168.i2192, i64 16
  store i32 %976, ptr %987, align 4
  %988 = getelementptr i8, ptr %result.i168.i2192, i64 20
  store i32 %976, ptr %988, align 4
  %989 = zext nneg i32 %976 to i64
  %990 = shl nuw nsw i64 %989, 5
  %result.i.i416.i2193 = call noalias ptr @bump_malloc_inner(i64 noundef %990, ptr nonnull @current_ptr) #29
  %991 = getelementptr i8, ptr %result.i168.i2192, i64 8
  store ptr %result.i.i416.i2193, ptr %991, align 8
  %992 = load ptr, ptr %288, align 8
  store ptr @Array, ptr %162, align 8
  store ptr %result.i168.i2192, ptr %163, align 8
  store ptr %992, ptr %251, align 8
  store i32 9, ptr %164, align 4
  %993 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i2194 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %994 = getelementptr i8, ptr %result.i183.i2194, i64 16
  store ptr @_parameterization_Nil, ptr %994, align 8
  %result.i184.i2195 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %995 = getelementptr i8, ptr %result.i184.i2195, i64 16
  store ptr %974, ptr %995, align 8
  %996 = getelementptr i8, ptr %result.i184.i2195, i64 8
  store ptr %975, ptr %996, align 8
  %997 = getelementptr i8, ptr %result.i184.i2195, i64 24
  store ptr null, ptr %997, align 8
  %998 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i2195)
  store ptr @Entry, ptr %result.i184.i2195, align 8
  %999 = getelementptr i8, ptr %result.i183.i2194, i64 8
  store ptr %result.i184.i2195, ptr %999, align 8
  %1000 = getelementptr i8, ptr %result.i183.i2194, i64 24
  store ptr null, ptr %1000, align 8
  %1001 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i2194)
  store ptr @union_typ, ptr %result.i183.i2194, align 8
  %result.i185.i2196 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i2194, ptr %result.i185.i2196, align 8
  %1002 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i2196)
  store ptr @Array, ptr %53, align 8
  store ptr %result.i185.i2196, ptr %289, align 8
  store i32 9, ptr %290, align 8
  %1003 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %53)
  %1004 = getelementptr i8, ptr %result.i185.i2196, i64 16
  store i32 %976, ptr %1004, align 4
  %1005 = getelementptr i8, ptr %result.i185.i2196, i64 20
  store i32 %976, ptr %1005, align 4
  %result.i.i430.i2197 = call noalias ptr @bump_malloc_inner(i64 noundef %990, ptr nonnull @current_ptr) #29
  %1006 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1007 = getelementptr i8, ptr %result.i185.i2196, i64 8
  store ptr %result.i.i430.i2197, ptr %1007, align 8
  %1008 = load ptr, ptr %291, align 8
  store ptr @Array, ptr %175, align 8
  store ptr %result.i185.i2196, ptr %176, align 8
  store ptr %1008, ptr %252, align 8
  store i32 9, ptr %177, align 4
  store i32 0, ptr %253, align 4
  %1009 = icmp sgt i32 %.reg2mem91.0.lcssa.i2189, 0
  br i1 %1009, label %.lr.ph400.i2198, label %HashMap_resize_.exit2270

.lr.ph400.i2198:                                  ; preds = %._crit_edge395.i2188
  %1010 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1011 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1012 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i2199

._crit_edge2.i2199:                               ; preds = %._crit_edge2.i2199, %.lr.ph400.i2198
  %.reg2mem77.0398.i2200 = phi i32 [ 0, %.lr.ph400.i2198 ], [ %1026, %._crit_edge2.i2199 ]
  %1013 = zext nneg i32 %.reg2mem77.0398.i2200 to i64
  %1014 = shl nuw nsw i64 %1013, 5
  %1015 = getelementptr i8, ptr %result.i.i.i2186, i64 %1014
  %1016 = load ptr, ptr %1015, align 8
  %1017 = getelementptr i8, ptr %1015, i64 8
  %1018 = load i160, ptr %1017, align 4
  %.sroa.3362.8.extract.trunc.i2203 = trunc i160 %1018 to i64
  %1019 = inttoptr i64 %.sroa.3362.8.extract.trunc.i2203 to ptr
  %.sroa.5363.8.extract.shift.i2204 = lshr i160 %1018, 64
  %.sroa.5363.8.extract.trunc.i2205 = trunc i160 %.sroa.5363.8.extract.shift.i2204 to i64
  %1020 = inttoptr i64 %.sroa.5363.8.extract.trunc.i2205 to ptr
  %hash_coef_ptr.i.i201.i2206 = getelementptr i8, ptr %1016, i64 8
  %tbl_size_ptr.i.i202.i2207 = getelementptr i8, ptr %1016, i64 16
  %offset_tbl_ptr.i.i203.i2208 = getelementptr i8, ptr %1016, i64 40
  %hash_coef.i.i232.i2209 = load i64, ptr %hash_coef_ptr.i.i201.i2206, align 4
  %tbl_size.i.i233.i2210 = load i64, ptr %tbl_size_ptr.i.i202.i2207, align 4
  %offset_tbl.i.i234.i2211 = load ptr, ptr %offset_tbl_ptr.i.i203.i2208, align 8
  %product.i.i.i235.i2212 = mul i64 %hash_coef.i.i232.i2209, 4015701072841558310
  %shifted.i.i.i236.i2213 = lshr i64 %product.i.i.i235.i2212, 32
  %xored.i.i.i237.i2214 = xor i64 %shifted.i.i.i236.i2213, %product.i.i.i235.i2212
  %hash.i.i.i238.i2215 = and i64 %xored.i.i.i237.i2214, %tbl_size.i.i233.i2210
  %offset_ptr.i.i239.i2216 = getelementptr i32, ptr %offset_tbl.i.i234.i2211, i64 %hash.i.i.i238.i2215
  %offset.i.i240.i2217 = load i32, ptr %offset_ptr.i.i239.i2216, align 4
  %1021 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1016, 0
  %1022 = insertvalue { ptr, ptr, ptr, i32 } %1021, ptr %1019, 1
  %1023 = insertvalue { ptr, ptr, ptr, i32 } %1022, ptr %1020, 2
  %1024 = insertvalue { ptr, ptr, ptr, i32 } %1023, i32 %offset.i.i240.i2217, 3
  %1025 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %294, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1024)
  %1026 = add nuw nsw i32 %.reg2mem77.0398.i2200, 1
  %1027 = icmp slt i32 %1026, %.reg2mem91.0.lcssa.i2189
  br i1 %1027, label %._crit_edge2.i2199, label %HashMap_resize_.exit2270

HashMap_resize_.exit2270:                         ; preds = %._crit_edge2.i2199, %._crit_edge395.i2188
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %53)
  br label %._crit_edge.i941

._crit_edge.i941:                                 ; preds = %HashMap_resize_.exit2270, %.critedge158.i922
  %1028 = load ptr, ptr %result.i, align 8
  %1029 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1030 = load ptr, ptr %145, align 8
  %1031 = load ptr, ptr %1028, align 8
  %1032 = getelementptr i8, ptr %1031, i64 48
  %1033 = load ptr, ptr %1032, align 8
  %1034 = call { i64, i64 } %1033(ptr nonnull %1028)
  %1035 = extractvalue { i64, i64 } %1034, 0
  %1036 = extractvalue { i64, i64 } %1034, 1
  %1037 = urem i64 20, %1036
  %1038 = icmp eq i64 %1037, 0
  %1039 = sub i64 %1036, %1037
  %1040 = select i1 %1038, i64 0, i64 %1039
  %1041 = add i64 %1035, 20
  %1042 = add i64 %1041, %1040
  %1043 = load ptr, ptr %1030, align 8
  %1044 = getelementptr i8, ptr %1043, i64 48
  %1045 = load ptr, ptr %1044, align 8
  %1046 = call { i64, i64 } %1045(ptr nonnull %1030)
  %1047 = extractvalue { i64, i64 } %1046, 0
  %1048 = extractvalue { i64, i64 } %1046, 1
  %1049 = call i64 @llvm.umax.i64(i64 %1036, i64 %1048)
  %1050 = call i64 @llvm.umax.i64(i64 %1049, i64 8)
  %1051 = urem i64 %1042, %1048
  %1052 = icmp eq i64 %1051, 0
  %1053 = sub i64 %1048, %1051
  %1054 = select i1 %1052, i64 0, i64 %1053
  %1055 = add i64 %1047, %1042
  %1056 = add i64 %1055, %1054
  %1057 = urem i64 %1056, %1050
  %1058 = icmp eq i64 %1057, 0
  %1059 = sub i64 %1050, %1057
  %1060 = select i1 %1058, i64 0, i64 %1059
  %1061 = add i64 %1060, %1056
  %result.i298.i942 = call noalias ptr @bump_malloc_inner(i64 noundef %1061, ptr nonnull @current_ptr) #29
  store ptr %1028, ptr %result.i298.i942, align 8
  %1062 = getelementptr i8, ptr %result.i298.i942, i64 8
  store ptr %1030, ptr %1062, align 8
  %1063 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i942)
  store ptr @Entry, ptr %117, align 8
  store ptr %result.i298.i942, ptr %238, align 8
  store i32 9, ptr %239, align 8
  %1064 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %117)
  %1065 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1066 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1067 = load ptr, ptr %1028, align 8
  %1068 = getelementptr i8, ptr %1067, i64 48
  %1069 = load ptr, ptr %1068, align 8
  %1070 = call { i64, i64 } %1069(ptr nonnull %1028)
  %1071 = extractvalue { i64, i64 } %1070, 1
  %1072 = urem i64 20, %1071
  %1073 = icmp eq i64 %1072, 0
  %reass.sub3770 = sub i64 %1071, %1072
  %1074 = add i64 %reass.sub3770, 20
  %1075 = select i1 %1073, i64 20, i64 %1074
  %1076 = getelementptr i8, ptr %result.i298.i942, i64 %1075
  %1077 = load ptr, ptr %result.i298.i942, align 8
  %1078 = load ptr, ptr %1077, align 8
  %1079 = getelementptr i8, ptr %1078, i64 64
  %1080 = load ptr, ptr %1079, align 8
  call void %1080({ ptr, i160 } %324, ptr nonnull %1077, ptr %1076)
  %1081 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1082 = load ptr, ptr %result.i298.i942, align 8
  %1083 = load ptr, ptr %1082, align 8
  %1084 = getelementptr i8, ptr %1083, i64 48
  %1085 = load ptr, ptr %1084, align 8
  %1086 = call { i64, i64 } %1085(ptr nonnull %1082)
  %1087 = extractvalue { i64, i64 } %1086, 0
  %1088 = extractvalue { i64, i64 } %1086, 1
  %1089 = urem i64 20, %1088
  %1090 = icmp eq i64 %1089, 0
  %1091 = sub i64 %1088, %1089
  %1092 = select i1 %1090, i64 0, i64 %1091
  %1093 = add i64 %1087, 20
  %1094 = add i64 %1093, %1092
  %1095 = load ptr, ptr %1062, align 8
  %1096 = load ptr, ptr %1095, align 8
  %1097 = getelementptr i8, ptr %1096, i64 48
  %1098 = load ptr, ptr %1097, align 8
  %1099 = call { i64, i64 } %1098(ptr nonnull %1095)
  %1100 = extractvalue { i64, i64 } %1099, 1
  %1101 = urem i64 %1094, %1100
  %1102 = icmp eq i64 %1101, 0
  %1103 = sub i64 %1100, %1101
  %1104 = select i1 %1102, i64 0, i64 %1103
  %1105 = getelementptr i8, ptr %result.i298.i942, i64 %1094
  %1106 = getelementptr i8, ptr %1105, i64 %1104
  %1107 = load ptr, ptr %1062, align 8
  %1108 = load ptr, ptr %1107, align 8
  %1109 = getelementptr i8, ptr %1108, i64 64
  %1110 = load ptr, ptr %1109, align 8
  call void %1110({ ptr, i160 } %491, ptr nonnull %1107, ptr %1106)
  %1111 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1112 = getelementptr i8, ptr %result.i298.i942, i64 16
  store i32 %494, ptr %1112, align 4
  %1113 = load ptr, ptr %240, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i2271)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i2272)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %47)
  store ptr @Entry, ptr %47, align 8
  store ptr %result.i298.i942, ptr %295, align 8
  store ptr %1113, ptr %296, align 8
  store i32 9, ptr %297, align 8
  %1114 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %47)
  %1115 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1116 = load i32, ptr %178, align 4
  %1117 = icmp sgt i32 %1116, 0
  br i1 %1117, label %.lr.ph.i2302, label %._crit_edge1.i947

.lr.ph.i2302:                                     ; preds = %._crit_edge.i941
  %1118 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1119 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1120

1120:                                             ; preds = %.cont.cont.i2353, %.lr.ph.i2302
  %offset.i.i260.i23683041 = phi i32 [ 9, %.lr.ph.i2302 ], [ %offset.i.i260.i2368, %.cont.cont.i2353 ]
  %.sroa.speculated346.i23563039 = phi ptr [ %1113, %.lr.ph.i2302 ], [ %.sroa.speculated346.i2356, %.cont.cont.i2353 ]
  %.sroa.speculated352.i23553037 = phi ptr [ %result.i298.i942, %.lr.ph.i2302 ], [ %.sroa.speculated352.i2355, %.cont.cont.i2353 ]
  %.reg2mem195.0678.i2303 = phi i32 [ 1, %.lr.ph.i2302 ], [ %1276, %.cont.cont.i2353 ]
  %.reg2mem193.0677.i2304 = phi i32 [ 0, %.lr.ph.i2302 ], [ %1277, %.cont.cont.i2353 ]
  %1121 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i23553037, 1
  %1122 = insertvalue { ptr, ptr, ptr, i32 } %1121, ptr %.sroa.speculated346.i23563039, 2
  %1123 = insertvalue { ptr, ptr, ptr, i32 } %1122, i32 %offset.i.i260.i23683041, 3
  %1124 = sext i32 %offset.i.i260.i23683041 to i64
  %gep3036 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1124
  %1125 = load ptr, ptr %gep3036, align 8
  %1126 = call ptr %1125({ ptr, ptr, ptr, i32 } %1123, ptr nonnull %2)
  %1127 = call i32 %1126({ ptr, ptr, ptr, i32 } %1123, { ptr, ptr, ptr, i32 } %1123, ptr nonnull %2)
  %1128 = icmp eq i32 %.reg2mem195.0678.i2303, 1
  %1129 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1128, label %1130, label %1194

1130:                                             ; preds = %1120
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1131 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1132 = load ptr, ptr %162, align 8
  %1133 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1132, 0
  %1134 = load ptr, ptr %163, align 8
  %1135 = insertvalue { ptr, ptr, ptr, i32 } %1133, ptr %1134, 1
  %1136 = load ptr, ptr %251, align 8
  %1137 = insertvalue { ptr, ptr, ptr, i32 } %1135, ptr %1136, 2
  %1138 = load i32, ptr %164, align 4
  %1139 = insertvalue { ptr, ptr, ptr, i32 } %1137, i32 %1138, 3
  %hash_coef_ptr.i.i10.i3497 = getelementptr i8, ptr %1132, i64 8
  %tbl_size_ptr.i.i11.i3498 = getelementptr i8, ptr %1132, i64 16
  %offset_tbl_ptr.i.i12.i3499 = getelementptr i8, ptr %1132, i64 40
  %hash_coef.i.i13.i3500 = load i64, ptr %hash_coef_ptr.i.i10.i3497, align 4
  %tbl_size.i.i14.i3501 = load i64, ptr %tbl_size_ptr.i.i11.i3498, align 4
  %offset_tbl.i.i15.i3502 = load ptr, ptr %offset_tbl_ptr.i.i12.i3499, align 8
  %product.i.i.i16.i3503 = mul i64 %hash_coef.i.i13.i3500, -5261542750394134544
  %shifted.i.i.i17.i3504 = lshr i64 %product.i.i.i16.i3503, 32
  %xored.i.i.i18.i3505 = xor i64 %shifted.i.i.i17.i3504, %product.i.i.i16.i3503
  %hash.i.i.i19.i3506 = and i64 %xored.i.i.i18.i3505, %tbl_size.i.i14.i3501
  %offset_ptr.i.i20.i3507 = getelementptr i32, ptr %offset_tbl.i.i15.i3502, i64 %hash.i.i.i19.i3506
  %offset.i.i21.i3508 = load i32, ptr %offset_ptr.i.i20.i3507, align 4
  %eq.i.i3509 = icmp eq i32 %1138, %offset.i.i21.i3508
  call void @llvm.assume(i1 %eq.i.i3509) #30
  %1140 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1141 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1132)
  %1142 = sext i32 %1138 to i64
  %1143 = getelementptr ptr, ptr %1132, i64 %1142
  %1144 = getelementptr i8, ptr %1143, i64 64
  %1145 = load ptr, ptr %1144, align 8
  %1146 = call ptr %1145({ ptr, ptr, ptr, i32 } %1139, ptr nonnull %2)
  %1147 = call i32 %1146({ ptr, ptr, ptr, i32 } %1139, { ptr, ptr, ptr, i32 } %1139, ptr nonnull %2)
  %1148 = add i32 %1147, -1
  %1149 = and i32 %1148, %1127
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1150 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1151 = load ptr, ptr %162, align 8
  %1152 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1151, 0
  %1153 = load ptr, ptr %163, align 8
  %1154 = insertvalue { ptr, ptr, ptr, i32 } %1152, ptr %1153, 1
  %1155 = load ptr, ptr %251, align 8
  %1156 = insertvalue { ptr, ptr, ptr, i32 } %1154, ptr %1155, 2
  %1157 = load i32, ptr %164, align 4
  %1158 = insertvalue { ptr, ptr, ptr, i32 } %1156, i32 %1157, 3
  %hash_coef_ptr.i.i172.i2373 = getelementptr i8, ptr %1151, i64 8
  %tbl_size_ptr.i.i173.i2374 = getelementptr i8, ptr %1151, i64 16
  %offset_tbl_ptr.i.i174.i2375 = getelementptr i8, ptr %1151, i64 40
  %hash_coef.i.i175.i2376 = load i64, ptr %hash_coef_ptr.i.i172.i2373, align 4
  %tbl_size.i.i176.i2377 = load i64, ptr %tbl_size_ptr.i.i173.i2374, align 4
  %offset_tbl.i.i177.i2378 = load ptr, ptr %offset_tbl_ptr.i.i174.i2375, align 8
  %product.i.i.i178.i2379 = mul i64 %hash_coef.i.i175.i2376, -5261542750394134544
  %shifted.i.i.i179.i2380 = lshr i64 %product.i.i.i178.i2379, 32
  %xored.i.i.i180.i2381 = xor i64 %shifted.i.i.i179.i2380, %product.i.i.i178.i2379
  %hash.i.i.i181.i2382 = and i64 %xored.i.i.i180.i2381, %tbl_size.i.i176.i2377
  %offset_ptr.i.i182.i2383 = getelementptr i32, ptr %offset_tbl.i.i177.i2378, i64 %hash.i.i.i181.i2382
  %offset.i.i183.i2384 = load i32, ptr %offset_ptr.i.i182.i2383, align 4
  %eq.i.i2385 = icmp eq i32 %1157, %offset.i.i183.i2384
  call void @llvm.assume(i1 %eq.i.i2385) #30
  store ptr @_parameterization_Ptri32, ptr %31, align 8
  %1159 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %31)
  %1160 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1151)
  %1161 = sext i32 %1157 to i64
  %1162 = getelementptr ptr, ptr %1151, i64 %1161
  %1163 = getelementptr i8, ptr %1162, i64 120
  %1164 = load ptr, ptr %1163, align 8
  store ptr @i32_typ, ptr %32, align 8
  %1165 = call ptr %1164({ ptr, ptr, ptr, i32 } %1158, ptr nonnull %32)
  %1166 = call { ptr, i160 } %1165({ ptr, ptr, ptr, i32 } %1158, { ptr, ptr, ptr, i32 } %1158, ptr nonnull %31, i32 %1149)
  %.fca.0.extract112.i2386 = extractvalue { ptr, i160 } %1166, 0
  %1167 = ptrtoint ptr %.sroa.speculated352.i23553037 to i64
  %1168 = ptrtoint ptr %.sroa.speculated346.i23563039 to i64
  %.sroa.3111.0.insert.ext.i2387 = zext i32 %offset.i.i260.i23683041 to i160
  %.sroa.3111.0.insert.shift.i2388 = shl nuw i160 %.sroa.3111.0.insert.ext.i2387, 128
  %.sroa.2110.0.insert.ext.i2389 = zext i64 %1168 to i160
  %.sroa.2110.0.insert.shift.i2390 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i2389, 64
  %.sroa.2110.0.insert.insert.i2391 = or disjoint i160 %.sroa.2110.0.insert.shift.i2390, %.sroa.3111.0.insert.shift.i2388
  %.sroa.0109.0.insert.ext.i2392 = zext i64 %1167 to i160
  %.sroa.0109.0.insert.insert.i2393 = or disjoint i160 %.sroa.2110.0.insert.insert.i2391, %.sroa.0109.0.insert.ext.i2392
  %1169 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i2393, 1
  %1170 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1171 = load ptr, ptr %162, align 8
  %1172 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1171, 0
  %1173 = load ptr, ptr %163, align 8
  %1174 = insertvalue { ptr, ptr, ptr, i32 } %1172, ptr %1173, 1
  %1175 = load ptr, ptr %251, align 8
  %1176 = insertvalue { ptr, ptr, ptr, i32 } %1174, ptr %1175, 2
  %1177 = load i32, ptr %164, align 4
  %1178 = insertvalue { ptr, ptr, ptr, i32 } %1176, i32 %1177, 3
  %hash_coef_ptr.i.i186.i2398 = getelementptr i8, ptr %1171, i64 8
  %tbl_size_ptr.i.i187.i2399 = getelementptr i8, ptr %1171, i64 16
  %offset_tbl_ptr.i.i188.i2400 = getelementptr i8, ptr %1171, i64 40
  %hash_coef.i.i189.i2401 = load i64, ptr %hash_coef_ptr.i.i186.i2398, align 4
  %tbl_size.i.i190.i2402 = load i64, ptr %tbl_size_ptr.i.i187.i2399, align 4
  %offset_tbl.i.i191.i2403 = load ptr, ptr %offset_tbl_ptr.i.i188.i2400, align 8
  %product.i.i.i192.i2404 = mul i64 %hash_coef.i.i189.i2401, -5261542750394134544
  %shifted.i.i.i193.i2405 = lshr i64 %product.i.i.i192.i2404, 32
  %xored.i.i.i194.i2406 = xor i64 %shifted.i.i.i193.i2405, %product.i.i.i192.i2404
  %hash.i.i.i195.i2407 = and i64 %xored.i.i.i194.i2406, %tbl_size.i.i190.i2402
  %offset_ptr.i.i196.i2408 = getelementptr i32, ptr %offset_tbl.i.i191.i2403, i64 %hash.i.i.i195.i2407
  %offset.i.i197.i2409 = load i32, ptr %offset_ptr.i.i196.i2408, align 4
  %eq.i200.i2410 = icmp eq i32 %1177, %offset.i.i197.i2409
  call void @llvm.assume(i1 %eq.i200.i2410) #30
  %1179 = load ptr, ptr %result.i, align 8
  %1180 = load ptr, ptr %145, align 8
  %result.i.i2411 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1181 = getelementptr i8, ptr %result.i.i2411, i64 16
  store ptr %1180, ptr %1181, align 8
  %1182 = getelementptr i8, ptr %result.i.i2411, i64 8
  store ptr %1179, ptr %1182, align 8
  %1183 = getelementptr i8, ptr %result.i.i2411, i64 24
  store ptr null, ptr %1183, align 8
  %1184 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i2411)
  store ptr @Entry, ptr %result.i.i2411, align 8
  store ptr @_parameterization_Ptri32, ptr %33, align 8
  store ptr %result.i.i2411, ptr %300, align 8
  %1185 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %33)
  %1186 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1171)
  %1187 = sext i32 %1177 to i64
  %1188 = getelementptr ptr, ptr %1171, i64 %1187
  %1189 = getelementptr i8, ptr %1188, i64 128
  %1190 = load ptr, ptr %1189, align 8
  store ptr @i32_typ, ptr %34, align 8
  store ptr @Entry, ptr %301, align 8
  %1191 = call ptr %1190({ ptr, ptr, ptr, i32 } %1178, ptr nonnull %34)
  call void %1191({ ptr, ptr, ptr, i32 } %1178, { ptr, ptr, ptr, i32 } %1178, ptr nonnull %33, i32 %1149, { ptr, i160 } %1169)
  %1192 = icmp ne ptr %.fca.0.extract112.i2386, @nil_typ
  %1193 = icmp ne ptr %.fca.0.extract112.i2386, null
  %.not140.i2412 = and i1 %1192, %1193
  br i1 %.not140.i2412, label %.cont.cont.i2353, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread3019

1194:                                             ; preds = %1120
  %1195 = add i32 %1127, 2127912214
  %1196 = shl i32 %1127, 12
  %1197 = add i32 %1195, %1196
  %1198 = ashr i32 %1197, 19
  %1199 = xor i32 %1197, %1198
  %1200 = xor i32 %1199, -949894596
  %1201 = add i32 %1200, 374761393
  %1202 = shl i32 %1200, 5
  %1203 = add i32 %1201, %1202
  %1204 = add i32 %1203, -744332180
  %1205 = shl i32 %1203, 9
  %1206 = xor i32 %1204, %1205
  %1207 = add i32 %1206, -42973499
  %1208 = shl i32 %1206, 3
  %1209 = add i32 %1207, %1208
  %1210 = ashr i32 %1209, 16
  %1211 = xor i32 %1209, %1210
  %1212 = xor i32 %1211, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1213 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1214 = load ptr, ptr %175, align 8
  %1215 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1214, 0
  %1216 = load ptr, ptr %176, align 8
  %1217 = insertvalue { ptr, ptr, ptr, i32 } %1215, ptr %1216, 1
  %1218 = load ptr, ptr %252, align 8
  %1219 = insertvalue { ptr, ptr, ptr, i32 } %1217, ptr %1218, 2
  %1220 = load i32, ptr %177, align 4
  %1221 = insertvalue { ptr, ptr, ptr, i32 } %1219, i32 %1220, 3
  %hash_coef_ptr.i.i10.i3527 = getelementptr i8, ptr %1214, i64 8
  %tbl_size_ptr.i.i11.i3528 = getelementptr i8, ptr %1214, i64 16
  %offset_tbl_ptr.i.i12.i3529 = getelementptr i8, ptr %1214, i64 40
  %hash_coef.i.i13.i3530 = load i64, ptr %hash_coef_ptr.i.i10.i3527, align 4
  %tbl_size.i.i14.i3531 = load i64, ptr %tbl_size_ptr.i.i11.i3528, align 4
  %offset_tbl.i.i15.i3532 = load ptr, ptr %offset_tbl_ptr.i.i12.i3529, align 8
  %product.i.i.i16.i3533 = mul i64 %hash_coef.i.i13.i3530, -5261542750394134544
  %shifted.i.i.i17.i3534 = lshr i64 %product.i.i.i16.i3533, 32
  %xored.i.i.i18.i3535 = xor i64 %shifted.i.i.i17.i3534, %product.i.i.i16.i3533
  %hash.i.i.i19.i3536 = and i64 %xored.i.i.i18.i3535, %tbl_size.i.i14.i3531
  %offset_ptr.i.i20.i3537 = getelementptr i32, ptr %offset_tbl.i.i15.i3532, i64 %hash.i.i.i19.i3536
  %offset.i.i21.i3538 = load i32, ptr %offset_ptr.i.i20.i3537, align 4
  %eq.i.i3539 = icmp eq i32 %1220, %offset.i.i21.i3538
  call void @llvm.assume(i1 %eq.i.i3539) #30
  %1222 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1223 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1214)
  %1224 = sext i32 %1220 to i64
  %1225 = getelementptr ptr, ptr %1214, i64 %1224
  %1226 = getelementptr i8, ptr %1225, i64 64
  %1227 = load ptr, ptr %1226, align 8
  %1228 = call ptr %1227({ ptr, ptr, ptr, i32 } %1221, ptr nonnull %2)
  %1229 = call i32 %1228({ ptr, ptr, ptr, i32 } %1221, { ptr, ptr, ptr, i32 } %1221, ptr nonnull %2)
  %1230 = add i32 %1229, -1
  %1231 = and i32 %1230, %1212
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1232 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1233 = load ptr, ptr %175, align 8
  %1234 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1233, 0
  %1235 = load ptr, ptr %176, align 8
  %1236 = insertvalue { ptr, ptr, ptr, i32 } %1234, ptr %1235, 1
  %1237 = load ptr, ptr %252, align 8
  %1238 = insertvalue { ptr, ptr, ptr, i32 } %1236, ptr %1237, 2
  %1239 = load i32, ptr %177, align 4
  %1240 = insertvalue { ptr, ptr, ptr, i32 } %1238, i32 %1239, 3
  %hash_coef_ptr.i.i202.i2309 = getelementptr i8, ptr %1233, i64 8
  %tbl_size_ptr.i.i203.i2310 = getelementptr i8, ptr %1233, i64 16
  %offset_tbl_ptr.i.i204.i2311 = getelementptr i8, ptr %1233, i64 40
  %hash_coef.i.i205.i2312 = load i64, ptr %hash_coef_ptr.i.i202.i2309, align 4
  %tbl_size.i.i206.i2313 = load i64, ptr %tbl_size_ptr.i.i203.i2310, align 4
  %offset_tbl.i.i207.i2314 = load ptr, ptr %offset_tbl_ptr.i.i204.i2311, align 8
  %product.i.i.i208.i2315 = mul i64 %hash_coef.i.i205.i2312, -5261542750394134544
  %shifted.i.i.i209.i2316 = lshr i64 %product.i.i.i208.i2315, 32
  %xored.i.i.i210.i2317 = xor i64 %shifted.i.i.i209.i2316, %product.i.i.i208.i2315
  %hash.i.i.i211.i2318 = and i64 %xored.i.i.i210.i2317, %tbl_size.i.i206.i2313
  %offset_ptr.i.i212.i2319 = getelementptr i32, ptr %offset_tbl.i.i207.i2314, i64 %hash.i.i.i211.i2318
  %offset.i.i213.i2320 = load i32, ptr %offset_ptr.i.i212.i2319, align 4
  %eq.i216.i2321 = icmp eq i32 %1239, %offset.i.i213.i2320
  call void @llvm.assume(i1 %eq.i216.i2321) #30
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %1241 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %39)
  %1242 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1233)
  %1243 = sext i32 %1239 to i64
  %1244 = getelementptr ptr, ptr %1233, i64 %1243
  %1245 = getelementptr i8, ptr %1244, i64 120
  %1246 = load ptr, ptr %1245, align 8
  store ptr @i32_typ, ptr %40, align 8
  %1247 = call ptr %1246({ ptr, ptr, ptr, i32 } %1240, ptr nonnull %40)
  %1248 = call { ptr, i160 } %1247({ ptr, ptr, ptr, i32 } %1240, { ptr, ptr, ptr, i32 } %1240, ptr nonnull %39, i32 %1231)
  %.fca.0.extract87.i2322 = extractvalue { ptr, i160 } %1248, 0
  %1249 = ptrtoint ptr %.sroa.speculated352.i23553037 to i64
  %1250 = ptrtoint ptr %.sroa.speculated346.i23563039 to i64
  %.sroa.3.0.insert.ext.i2323 = zext i32 %offset.i.i260.i23683041 to i160
  %.sroa.3.0.insert.shift.i2324 = shl nuw i160 %.sroa.3.0.insert.ext.i2323, 128
  %.sroa.2.0.insert.ext.i2325 = zext i64 %1250 to i160
  %.sroa.2.0.insert.shift.i2326 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i2325, 64
  %.sroa.2.0.insert.insert.i2327 = or disjoint i160 %.sroa.2.0.insert.shift.i2326, %.sroa.3.0.insert.shift.i2324
  %.sroa.0.0.insert.ext.i2328 = zext i64 %1249 to i160
  %.sroa.0.0.insert.insert.i2329 = or disjoint i160 %.sroa.2.0.insert.insert.i2327, %.sroa.0.0.insert.ext.i2328
  %1251 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i2329, 1
  %1252 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1253 = load ptr, ptr %175, align 8
  %1254 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1253, 0
  %1255 = load ptr, ptr %176, align 8
  %1256 = insertvalue { ptr, ptr, ptr, i32 } %1254, ptr %1255, 1
  %1257 = load ptr, ptr %252, align 8
  %1258 = insertvalue { ptr, ptr, ptr, i32 } %1256, ptr %1257, 2
  %1259 = load i32, ptr %177, align 4
  %1260 = insertvalue { ptr, ptr, ptr, i32 } %1258, i32 %1259, 3
  %hash_coef_ptr.i.i218.i2334 = getelementptr i8, ptr %1253, i64 8
  %tbl_size_ptr.i.i219.i2335 = getelementptr i8, ptr %1253, i64 16
  %offset_tbl_ptr.i.i220.i2336 = getelementptr i8, ptr %1253, i64 40
  %hash_coef.i.i221.i2337 = load i64, ptr %hash_coef_ptr.i.i218.i2334, align 4
  %tbl_size.i.i222.i2338 = load i64, ptr %tbl_size_ptr.i.i219.i2335, align 4
  %offset_tbl.i.i223.i2339 = load ptr, ptr %offset_tbl_ptr.i.i220.i2336, align 8
  %product.i.i.i224.i2340 = mul i64 %hash_coef.i.i221.i2337, -5261542750394134544
  %shifted.i.i.i225.i2341 = lshr i64 %product.i.i.i224.i2340, 32
  %xored.i.i.i226.i2342 = xor i64 %shifted.i.i.i225.i2341, %product.i.i.i224.i2340
  %hash.i.i.i227.i2343 = and i64 %xored.i.i.i226.i2342, %tbl_size.i.i222.i2338
  %offset_ptr.i.i228.i2344 = getelementptr i32, ptr %offset_tbl.i.i223.i2339, i64 %hash.i.i.i227.i2343
  %offset.i.i229.i2345 = load i32, ptr %offset_ptr.i.i228.i2344, align 4
  %eq.i232.i2346 = icmp eq i32 %1259, %offset.i.i229.i2345
  call void @llvm.assume(i1 %eq.i232.i2346) #30
  %1261 = load ptr, ptr %result.i, align 8
  %1262 = load ptr, ptr %145, align 8
  %result.i233.i2347 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1263 = getelementptr i8, ptr %result.i233.i2347, i64 16
  store ptr %1262, ptr %1263, align 8
  %1264 = getelementptr i8, ptr %result.i233.i2347, i64 8
  store ptr %1261, ptr %1264, align 8
  %1265 = getelementptr i8, ptr %result.i233.i2347, i64 24
  store ptr null, ptr %1265, align 8
  %1266 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i2347)
  store ptr @Entry, ptr %result.i233.i2347, align 8
  store ptr @_parameterization_Ptri32, ptr %41, align 8
  store ptr %result.i233.i2347, ptr %298, align 8
  %1267 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %41)
  %1268 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1253)
  %1269 = sext i32 %1259 to i64
  %1270 = getelementptr ptr, ptr %1253, i64 %1269
  %1271 = getelementptr i8, ptr %1270, i64 128
  %1272 = load ptr, ptr %1271, align 8
  store ptr @i32_typ, ptr %42, align 8
  store ptr @Entry, ptr %299, align 8
  %1273 = call ptr %1272({ ptr, ptr, ptr, i32 } %1260, ptr nonnull %42)
  call void %1273({ ptr, ptr, ptr, i32 } %1260, { ptr, ptr, ptr, i32 } %1260, ptr nonnull %41, i32 %1231, { ptr, i160 } %1251)
  %1274 = icmp ne ptr %.fca.0.extract87.i2322, @nil_typ
  %1275 = icmp ne ptr %.fca.0.extract87.i2322, null
  %.not138.i2348 = and i1 %1274, %1275
  br i1 %.not138.i2348, label %.cont.cont.i2353, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread3019

.cont.cont.i2353:                                 ; preds = %1194, %1130
  %.sink3065 = phi { ptr, i160 } [ %1166, %1130 ], [ %1248, %1194 ]
  %1276 = phi i32 [ 2, %1130 ], [ 1, %1194 ]
  %vptr.i248.sroa.speculated.i2354 = phi ptr [ %.fca.0.extract112.i2386, %1130 ], [ %.fca.0.extract87.i2322, %1194 ]
  %.fca.1.extract89.i2349 = extractvalue { ptr, i160 } %.sink3065, 1
  %.sroa.3407.sroa.4.0.extract.shift.i2350 = lshr i160 %.fca.1.extract89.i2349, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i2351 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i2350 to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i2352 = trunc i160 %.fca.1.extract89.i2349 to i64
  %.sroa.speculated352.i2355 = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i2352 to ptr
  %.sroa.speculated346.i2356 = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i2351 to ptr
  %hash_coef_ptr.i.i249.i2357 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2354, i64 8
  %tbl_size_ptr.i.i250.i2358 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2354, i64 16
  %offset_tbl_ptr.i.i251.i2359 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2354, i64 40
  %hash_coef.i.i252.i2360 = load i64, ptr %hash_coef_ptr.i.i249.i2357, align 4
  %tbl_size.i.i253.i2361 = load i64, ptr %tbl_size_ptr.i.i250.i2358, align 4
  %offset_tbl.i.i254.i2362 = load ptr, ptr %offset_tbl_ptr.i.i251.i2359, align 8
  %product.i.i.i255.i2363 = mul i64 %hash_coef.i.i252.i2360, 4015701072841558310
  %shifted.i.i.i256.i2364 = lshr i64 %product.i.i.i255.i2363, 32
  %xored.i.i.i257.i2365 = xor i64 %shifted.i.i.i256.i2364, %product.i.i.i255.i2363
  %hash.i.i.i258.i2366 = and i64 %xored.i.i.i257.i2365, %tbl_size.i.i253.i2361
  %offset_ptr.i.i259.i2367 = getelementptr i32, ptr %offset_tbl.i.i254.i2362, i64 %hash.i.i.i258.i2366
  %offset.i.i260.i2368 = load i32, ptr %offset_ptr.i.i259.i2367, align 4
  store ptr %vptr.i248.sroa.speculated.i2354, ptr %47, align 8
  store ptr %.sroa.speculated352.i2355, ptr %295, align 8
  store ptr %.sroa.speculated346.i2356, ptr %296, align 8
  store i32 %offset.i.i260.i2368, ptr %297, align 8
  %1277 = add nuw nsw i32 %.reg2mem193.0677.i2304, 1
  %1278 = load i32, ptr %178, align 4
  %1279 = icmp slt i32 %1277, %1278
  br i1 %1279, label %1120, label %._crit_edge1.i947

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread3019: ; preds = %1130, %1194
  %1280 = phi ptr [ %43, %1194 ], [ %35, %1130 ]
  %1281 = phi ptr [ %44, %1194 ], [ %36, %1130 ]
  %1282 = phi ptr [ %45, %1194 ], [ %37, %1130 ]
  %1283 = phi ptr [ %.sroa.0.i2272, %1194 ], [ %.sroa.0680.i2271, %1130 ]
  %1284 = phi ptr [ %46, %1194 ], [ %38, %1130 ]
  %1285 = load i32, ptr %253, align 4
  store i32 %1285, ptr %1280, align 4
  store i32 1, ptr %1281, align 4
  %1286 = add i32 %1285, 1
  store i32 %1286, ptr %1282, align 4
  %1287 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1286, ptr %253, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1284, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1283, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2271)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2272)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  br label %HashMap_insert_keyK_valueV.exit1036

._crit_edge1.i947:                                ; preds = %.cont.cont.i2353, %._crit_edge.i941
  %1288 = load i160, ptr %295, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2271)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2272)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %30)
  %1289 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1290 = load ptr, ptr %162, align 8
  %1291 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1290, 0
  %1292 = load ptr, ptr %163, align 8
  %1293 = insertvalue { ptr, ptr, ptr, i32 } %1291, ptr %1292, 1
  %1294 = load ptr, ptr %251, align 8
  %1295 = insertvalue { ptr, ptr, ptr, i32 } %1293, ptr %1294, 2
  %1296 = load i32, ptr %164, align 4
  %1297 = insertvalue { ptr, ptr, ptr, i32 } %1295, i32 %1296, 3
  %hash_coef_ptr.i.i64.i2432 = getelementptr i8, ptr %1290, i64 8
  %tbl_size_ptr.i.i65.i2433 = getelementptr i8, ptr %1290, i64 16
  %offset_tbl_ptr.i.i66.i2434 = getelementptr i8, ptr %1290, i64 40
  %hash_coef.i.i67.i2435 = load i64, ptr %hash_coef_ptr.i.i64.i2432, align 4
  %tbl_size.i.i68.i2436 = load i64, ptr %tbl_size_ptr.i.i65.i2433, align 4
  %offset_tbl.i.i69.i2437 = load ptr, ptr %offset_tbl_ptr.i.i66.i2434, align 8
  %product.i.i.i70.i2438 = mul i64 %hash_coef.i.i67.i2435, -5261542750394134544
  %shifted.i.i.i71.i2439 = lshr i64 %product.i.i.i70.i2438, 32
  %xored.i.i.i72.i2440 = xor i64 %shifted.i.i.i71.i2439, %product.i.i.i70.i2438
  %hash.i.i.i73.i2441 = and i64 %xored.i.i.i72.i2440, %tbl_size.i.i68.i2436
  %offset_ptr.i.i74.i2442 = getelementptr i32, ptr %offset_tbl.i.i69.i2437, i64 %hash.i.i.i73.i2441
  %offset.i.i75.i2443 = load i32, ptr %offset_ptr.i.i74.i2442, align 4
  %eq.i.i2444 = icmp eq i32 %1296, %offset.i.i75.i2443
  call void @llvm.assume(i1 %eq.i.i2444) #30
  %1298 = load ptr, ptr %175, align 8
  %1299 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1298, 0
  %1300 = load ptr, ptr %176, align 8
  %1301 = insertvalue { ptr, ptr, ptr, i32 } %1299, ptr %1300, 1
  %1302 = load ptr, ptr %252, align 8
  %1303 = insertvalue { ptr, ptr, ptr, i32 } %1301, ptr %1302, 2
  %1304 = load i32, ptr %177, align 4
  %1305 = insertvalue { ptr, ptr, ptr, i32 } %1303, i32 %1304, 3
  %hash_coef_ptr.i.i92.i2449 = getelementptr i8, ptr %1298, i64 8
  %tbl_size_ptr.i.i93.i2450 = getelementptr i8, ptr %1298, i64 16
  %offset_tbl_ptr.i.i94.i2451 = getelementptr i8, ptr %1298, i64 40
  %hash_coef.i.i95.i2452 = load i64, ptr %hash_coef_ptr.i.i92.i2449, align 4
  %tbl_size.i.i96.i2453 = load i64, ptr %tbl_size_ptr.i.i93.i2450, align 4
  %offset_tbl.i.i97.i2454 = load ptr, ptr %offset_tbl_ptr.i.i94.i2451, align 8
  %product.i.i.i98.i2455 = mul i64 %hash_coef.i.i95.i2452, -5261542750394134544
  %shifted.i.i.i99.i2456 = lshr i64 %product.i.i.i98.i2455, 32
  %xored.i.i.i100.i2457 = xor i64 %shifted.i.i.i99.i2456, %product.i.i.i98.i2455
  %hash.i.i.i101.i2458 = and i64 %xored.i.i.i100.i2457, %tbl_size.i.i96.i2453
  %offset_ptr.i.i102.i2459 = getelementptr i32, ptr %offset_tbl.i.i97.i2454, i64 %hash.i.i.i101.i2458
  %offset.i.i103.i2460 = load i32, ptr %offset_ptr.i.i102.i2459, align 4
  %eq.i106.i2461 = icmp eq i32 %1304, %offset.i.i103.i2460
  call void @llvm.assume(i1 %eq.i106.i2461) #30
  %1306 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1307 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1290)
  %1308 = sext i32 %1296 to i64
  %1309 = getelementptr ptr, ptr %1290, i64 %1308
  %1310 = getelementptr i8, ptr %1309, i64 64
  %1311 = load ptr, ptr %1310, align 8
  %1312 = call ptr %1311({ ptr, ptr, ptr, i32 } %1297, ptr nonnull %2)
  %1313 = call i32 %1312({ ptr, ptr, ptr, i32 } %1297, { ptr, ptr, ptr, i32 } %1297, ptr nonnull %2)
  %1314 = shl i32 %1313, 1
  %1315 = load i32, ptr %253, align 4
  %1316 = load ptr, ptr %result.i, align 8
  %1317 = load ptr, ptr %145, align 8
  %1318 = sext i32 %1315 to i64
  %1319 = shl nsw i64 %1318, 5
  %result.i.i.i2464 = call noalias ptr @bump_malloc_inner(i64 noundef %1319, ptr nonnull @current_ptr) #29
  %1320 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1321 = icmp sgt i32 %1313, 0
  br i1 %1321, label %.lr.ph434.i2534, label %._crit_edge395.i2478

.lr.ph434.i2534:                                  ; preds = %._crit_edge1.i947
  %invariant.gep.i2477 = getelementptr i8, ptr %1290, i64 120
  %1322 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i2537 = getelementptr ptr, ptr %invariant.gep.i2477, i64 %1308
  br label %1323

1323:                                             ; preds = %1345, %.lr.ph434.i2534
  %.reg2mem105.0432.i2535 = phi i32 [ 0, %.lr.ph434.i2534 ], [ %.reg2mem101.0.i2540, %1345 ]
  %.reg2mem103.0431.i2536 = phi i32 [ 0, %.lr.ph434.i2534 ], [ %1346, %1345 ]
  store ptr @_parameterization_Ptri32, ptr %25, align 8
  %1324 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %25)
  %1325 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1290)
  %1326 = load ptr, ptr %gep.i2537, align 8
  store ptr @i32_typ, ptr %26, align 8
  %1327 = call ptr %1326({ ptr, ptr, ptr, i32 } %1297, ptr nonnull %26)
  %1328 = call { ptr, i160 } %1327({ ptr, ptr, ptr, i32 } %1297, { ptr, ptr, ptr, i32 } %1297, ptr nonnull %25, i32 %.reg2mem103.0431.i2536)
  %.fca.0.extract52.i2538 = extractvalue { ptr, i160 } %1328, 0
  %1329 = icmp ne ptr %.fca.0.extract52.i2538, @nil_typ
  %1330 = icmp ne ptr %.fca.0.extract52.i2538, null
  %.not60.i2539 = and i1 %1329, %1330
  br i1 %.not60.i2539, label %1331, label %1345

1331:                                             ; preds = %1323
  %hash_coef_ptr.i.i137.i2567 = getelementptr i8, ptr %.fca.0.extract52.i2538, i64 8
  %tbl_size_ptr.i.i138.i2568 = getelementptr i8, ptr %.fca.0.extract52.i2538, i64 16
  %offset_tbl_ptr.i.i139.i2569 = getelementptr i8, ptr %.fca.0.extract52.i2538, i64 40
  %hash_coef.i.i140.i2570 = load i64, ptr %hash_coef_ptr.i.i137.i2567, align 4
  %tbl_size.i.i141.i2571 = load i64, ptr %tbl_size_ptr.i.i138.i2568, align 4
  %offset_tbl.i.i142.i2572 = load ptr, ptr %offset_tbl_ptr.i.i139.i2569, align 8
  %product.i.i.i143.i2573 = mul i64 %hash_coef.i.i140.i2570, 4015701072841558310
  %shifted.i.i.i144.i2574 = lshr i64 %product.i.i.i143.i2573, 32
  %xored.i.i.i145.i2575 = xor i64 %shifted.i.i.i144.i2574, %product.i.i.i143.i2573
  %hash.i.i.i146.i2576 = and i64 %xored.i.i.i145.i2575, %tbl_size.i.i141.i2571
  %offset_ptr.i.i147.i2577 = getelementptr i32, ptr %offset_tbl.i.i142.i2572, i64 %hash.i.i.i146.i2576
  %offset.i.i148.i2578 = load i32, ptr %offset_ptr.i.i147.i2577, align 4
  %1332 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1333 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1334 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1335 = icmp slt i32 %.reg2mem105.0432.i2535, %1315
  br i1 %1335, label %1336, label %._crit_edge.i2579

1336:                                             ; preds = %1331
  %.fca.1.extract54.i2580 = extractvalue { ptr, i160 } %1328, 1
  %.sroa.351.0.insert.ext.i2581 = zext i32 %offset.i.i148.i2578 to i160
  %.sroa.351.0.insert.shift.i2582 = shl nuw i160 %.sroa.351.0.insert.ext.i2581, 128
  %1337 = and i160 %.fca.1.extract54.i2580, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2583 = or disjoint i160 %.sroa.351.0.insert.shift.i2582, %1337
  %1338 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1339 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1340 = sext i32 %.reg2mem105.0432.i2535 to i64
  %1341 = shl nsw i64 %1340, 5
  %1342 = getelementptr i8, ptr %result.i.i.i2464, i64 %1341
  store ptr %.fca.0.extract52.i2538, ptr %1342, align 8
  %1343 = getelementptr i8, ptr %1342, i64 8
  store i160 %.sroa.049.0.insert.insert.i2583, ptr %1343, align 4
  br label %._crit_edge.i2579

._crit_edge.i2579:                                ; preds = %1336, %1331
  %1344 = add i32 %.reg2mem105.0432.i2535, 1
  br label %1345

1345:                                             ; preds = %._crit_edge.i2579, %1323
  %.reg2mem101.0.i2540 = phi i32 [ %1344, %._crit_edge.i2579 ], [ %.reg2mem105.0432.i2535, %1323 ]
  %1346 = add nuw nsw i32 %.reg2mem103.0431.i2536, 1
  %1347 = icmp slt i32 %1346, %1313
  br i1 %1347, label %1323, label %.lr.ph.i2541

.lr.ph.i2541:                                     ; preds = %1345
  %invariant.gep396.i2542 = getelementptr i8, ptr %1298, i64 120
  %1348 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1349 = sext i32 %1304 to i64
  %gep397.i2545 = getelementptr ptr, ptr %invariant.gep396.i2542, i64 %1349
  br label %1350

1350:                                             ; preds = %1372, %.lr.ph.i2541
  %.reg2mem91.0394.i2543 = phi i32 [ %.reg2mem101.0.i2540, %.lr.ph.i2541 ], [ %.reg2mem87.0.i2548, %1372 ]
  %.reg2mem89.0393.i2544 = phi i32 [ 0, %.lr.ph.i2541 ], [ %1373, %1372 ]
  store ptr @_parameterization_Ptri32, ptr %27, align 8
  %1351 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %27)
  %1352 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1298)
  %1353 = load ptr, ptr %gep397.i2545, align 8
  store ptr @i32_typ, ptr %28, align 8
  %1354 = call ptr %1353({ ptr, ptr, ptr, i32 } %1305, ptr nonnull %28)
  %1355 = call { ptr, i160 } %1354({ ptr, ptr, ptr, i32 } %1305, { ptr, ptr, ptr, i32 } %1305, ptr nonnull %27, i32 %.reg2mem89.0393.i2544)
  %.fca.0.extract42.i2546 = extractvalue { ptr, i160 } %1355, 0
  %1356 = icmp ne ptr %.fca.0.extract42.i2546, @nil_typ
  %1357 = icmp ne ptr %.fca.0.extract42.i2546, null
  %.not62.i2547 = and i1 %1356, %1357
  br i1 %.not62.i2547, label %1358, label %1372

1358:                                             ; preds = %1350
  %hash_coef_ptr.i.i152.i2549 = getelementptr i8, ptr %.fca.0.extract42.i2546, i64 8
  %tbl_size_ptr.i.i153.i2550 = getelementptr i8, ptr %.fca.0.extract42.i2546, i64 16
  %offset_tbl_ptr.i.i154.i2551 = getelementptr i8, ptr %.fca.0.extract42.i2546, i64 40
  %hash_coef.i.i155.i2552 = load i64, ptr %hash_coef_ptr.i.i152.i2549, align 4
  %tbl_size.i.i156.i2553 = load i64, ptr %tbl_size_ptr.i.i153.i2550, align 4
  %offset_tbl.i.i157.i2554 = load ptr, ptr %offset_tbl_ptr.i.i154.i2551, align 8
  %product.i.i.i158.i2555 = mul i64 %hash_coef.i.i155.i2552, 4015701072841558310
  %shifted.i.i.i159.i2556 = lshr i64 %product.i.i.i158.i2555, 32
  %xored.i.i.i160.i2557 = xor i64 %shifted.i.i.i159.i2556, %product.i.i.i158.i2555
  %hash.i.i.i161.i2558 = and i64 %xored.i.i.i160.i2557, %tbl_size.i.i156.i2553
  %offset_ptr.i.i162.i2559 = getelementptr i32, ptr %offset_tbl.i.i157.i2554, i64 %hash.i.i.i161.i2558
  %offset.i.i163.i2560 = load i32, ptr %offset_ptr.i.i162.i2559, align 4
  %1359 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1360 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1361 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1362 = icmp slt i32 %.reg2mem91.0394.i2543, %1315
  br i1 %1362, label %1363, label %._crit_edge1.i2561

1363:                                             ; preds = %1358
  %.fca.1.extract44.i2562 = extractvalue { ptr, i160 } %1355, 1
  %.sroa.3.0.insert.ext.i2563 = zext i32 %offset.i.i163.i2560 to i160
  %.sroa.3.0.insert.shift.i2564 = shl nuw i160 %.sroa.3.0.insert.ext.i2563, 128
  %1364 = and i160 %.fca.1.extract44.i2562, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2565 = or disjoint i160 %.sroa.3.0.insert.shift.i2564, %1364
  %1365 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1366 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1367 = sext i32 %.reg2mem91.0394.i2543 to i64
  %1368 = shl nsw i64 %1367, 5
  %1369 = getelementptr i8, ptr %result.i.i.i2464, i64 %1368
  store ptr %.fca.0.extract42.i2546, ptr %1369, align 8
  %1370 = getelementptr i8, ptr %1369, i64 8
  store i160 %.sroa.040.0.insert.insert.i2565, ptr %1370, align 4
  br label %._crit_edge1.i2561

._crit_edge1.i2561:                               ; preds = %1363, %1358
  %1371 = add i32 %.reg2mem91.0394.i2543, 1
  br label %1372

1372:                                             ; preds = %._crit_edge1.i2561, %1350
  %.reg2mem87.0.i2548 = phi i32 [ %1371, %._crit_edge1.i2561 ], [ %.reg2mem91.0394.i2543, %1350 ]
  %1373 = add nuw nsw i32 %.reg2mem89.0393.i2544, 1
  %1374 = icmp slt i32 %1373, %1313
  br i1 %1374, label %1350, label %._crit_edge395.i2478.loopexit

._crit_edge395.i2478.loopexit:                    ; preds = %1372
  %.pre3419 = load ptr, ptr %result.i, align 8
  %.pre3420 = load ptr, ptr %145, align 8
  br label %._crit_edge395.i2478

._crit_edge395.i2478:                             ; preds = %._crit_edge395.i2478.loopexit, %._crit_edge1.i947
  %1375 = phi ptr [ %1317, %._crit_edge1.i947 ], [ %.pre3420, %._crit_edge395.i2478.loopexit ]
  %1376 = phi ptr [ %1316, %._crit_edge1.i947 ], [ %.pre3419, %._crit_edge395.i2478.loopexit ]
  %.reg2mem91.0.lcssa.i2479 = phi i32 [ 0, %._crit_edge1.i947 ], [ %.reg2mem87.0.i2548, %._crit_edge395.i2478.loopexit ]
  %1377 = call i32 @llvm.smax.i32(i32 %1314, i32 16)
  %result.i166.i2480 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1378 = getelementptr i8, ptr %result.i166.i2480, i64 16
  store ptr @_parameterization_Nil, ptr %1378, align 8
  %result.i167.i2481 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1379 = getelementptr i8, ptr %result.i167.i2481, i64 16
  store ptr %1375, ptr %1379, align 8
  %1380 = getelementptr i8, ptr %result.i167.i2481, i64 8
  store ptr %1376, ptr %1380, align 8
  %1381 = getelementptr i8, ptr %result.i167.i2481, i64 24
  store ptr null, ptr %1381, align 8
  %1382 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i2481)
  store ptr @Entry, ptr %result.i167.i2481, align 8
  %1383 = getelementptr i8, ptr %result.i166.i2480, i64 8
  store ptr %result.i167.i2481, ptr %1383, align 8
  %1384 = getelementptr i8, ptr %result.i166.i2480, i64 24
  store ptr null, ptr %1384, align 8
  %1385 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i2480)
  store ptr @union_typ, ptr %result.i166.i2480, align 8
  %result.i168.i2482 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i2480, ptr %result.i168.i2482, align 8
  %1386 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i2482)
  store ptr @Array, ptr %29, align 8
  store ptr %result.i168.i2482, ptr %302, align 8
  store i32 9, ptr %303, align 8
  %1387 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %29)
  %1388 = getelementptr i8, ptr %result.i168.i2482, i64 16
  store i32 %1377, ptr %1388, align 4
  %1389 = getelementptr i8, ptr %result.i168.i2482, i64 20
  store i32 %1377, ptr %1389, align 4
  %1390 = zext nneg i32 %1377 to i64
  %1391 = shl nuw nsw i64 %1390, 5
  %result.i.i416.i2483 = call noalias ptr @bump_malloc_inner(i64 noundef %1391, ptr nonnull @current_ptr) #29
  %1392 = getelementptr i8, ptr %result.i168.i2482, i64 8
  store ptr %result.i.i416.i2483, ptr %1392, align 8
  %1393 = load ptr, ptr %304, align 8
  store ptr @Array, ptr %162, align 8
  store ptr %result.i168.i2482, ptr %163, align 8
  store ptr %1393, ptr %251, align 8
  store i32 9, ptr %164, align 4
  %1394 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i2496 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1395 = getelementptr i8, ptr %result.i183.i2496, i64 16
  store ptr @_parameterization_Nil, ptr %1395, align 8
  %result.i184.i2497 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1396 = getelementptr i8, ptr %result.i184.i2497, i64 16
  store ptr %1375, ptr %1396, align 8
  %1397 = getelementptr i8, ptr %result.i184.i2497, i64 8
  store ptr %1376, ptr %1397, align 8
  %1398 = getelementptr i8, ptr %result.i184.i2497, i64 24
  store ptr null, ptr %1398, align 8
  %1399 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i2497)
  store ptr @Entry, ptr %result.i184.i2497, align 8
  %1400 = getelementptr i8, ptr %result.i183.i2496, i64 8
  store ptr %result.i184.i2497, ptr %1400, align 8
  %1401 = getelementptr i8, ptr %result.i183.i2496, i64 24
  store ptr null, ptr %1401, align 8
  %1402 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i2496)
  store ptr @union_typ, ptr %result.i183.i2496, align 8
  %result.i185.i2498 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i2496, ptr %result.i185.i2498, align 8
  %1403 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i2498)
  store ptr @Array, ptr %30, align 8
  store ptr %result.i185.i2498, ptr %305, align 8
  store i32 9, ptr %306, align 8
  %1404 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %30)
  %1405 = getelementptr i8, ptr %result.i185.i2498, i64 16
  store i32 %1377, ptr %1405, align 4
  %1406 = getelementptr i8, ptr %result.i185.i2498, i64 20
  store i32 %1377, ptr %1406, align 4
  %result.i.i430.i2499 = call noalias ptr @bump_malloc_inner(i64 noundef %1391, ptr nonnull @current_ptr) #29
  %1407 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1408 = getelementptr i8, ptr %result.i185.i2498, i64 8
  store ptr %result.i.i430.i2499, ptr %1408, align 8
  %1409 = load ptr, ptr %307, align 8
  store ptr @Array, ptr %175, align 8
  store ptr %result.i185.i2498, ptr %176, align 8
  store ptr %1409, ptr %252, align 8
  store i32 9, ptr %177, align 4
  store i32 0, ptr %253, align 4
  %1410 = icmp sgt i32 %.reg2mem91.0.lcssa.i2479, 0
  br i1 %1410, label %.lr.ph400.i2512, label %HashMap_resize_.exit2585

.lr.ph400.i2512:                                  ; preds = %._crit_edge395.i2478
  %1411 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1412 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1413 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i2514

._crit_edge2.i2514:                               ; preds = %._crit_edge2.i2514, %.lr.ph400.i2512
  %.reg2mem77.0398.i2515 = phi i32 [ 0, %.lr.ph400.i2512 ], [ %1427, %._crit_edge2.i2514 ]
  %1414 = zext nneg i32 %.reg2mem77.0398.i2515 to i64
  %1415 = shl nuw nsw i64 %1414, 5
  %1416 = getelementptr i8, ptr %result.i.i.i2464, i64 %1415
  %1417 = load ptr, ptr %1416, align 8
  %1418 = getelementptr i8, ptr %1416, i64 8
  %1419 = load i160, ptr %1418, align 4
  %.sroa.3362.8.extract.trunc.i2518 = trunc i160 %1419 to i64
  %1420 = inttoptr i64 %.sroa.3362.8.extract.trunc.i2518 to ptr
  %.sroa.5363.8.extract.shift.i2519 = lshr i160 %1419, 64
  %.sroa.5363.8.extract.trunc.i2520 = trunc i160 %.sroa.5363.8.extract.shift.i2519 to i64
  %1421 = inttoptr i64 %.sroa.5363.8.extract.trunc.i2520 to ptr
  %hash_coef_ptr.i.i201.i2521 = getelementptr i8, ptr %1417, i64 8
  %tbl_size_ptr.i.i202.i2522 = getelementptr i8, ptr %1417, i64 16
  %offset_tbl_ptr.i.i203.i2523 = getelementptr i8, ptr %1417, i64 40
  %hash_coef.i.i232.i2524 = load i64, ptr %hash_coef_ptr.i.i201.i2521, align 4
  %tbl_size.i.i233.i2525 = load i64, ptr %tbl_size_ptr.i.i202.i2522, align 4
  %offset_tbl.i.i234.i2526 = load ptr, ptr %offset_tbl_ptr.i.i203.i2523, align 8
  %product.i.i.i235.i2527 = mul i64 %hash_coef.i.i232.i2524, 4015701072841558310
  %shifted.i.i.i236.i2528 = lshr i64 %product.i.i.i235.i2527, 32
  %xored.i.i.i237.i2529 = xor i64 %shifted.i.i.i236.i2528, %product.i.i.i235.i2527
  %hash.i.i.i238.i2530 = and i64 %xored.i.i.i237.i2529, %tbl_size.i.i233.i2525
  %offset_ptr.i.i239.i2531 = getelementptr i32, ptr %offset_tbl.i.i234.i2526, i64 %hash.i.i.i238.i2530
  %offset.i.i240.i2532 = load i32, ptr %offset_ptr.i.i239.i2531, align 4
  %1422 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1417, 0
  %1423 = insertvalue { ptr, ptr, ptr, i32 } %1422, ptr %1420, 1
  %1424 = insertvalue { ptr, ptr, ptr, i32 } %1423, ptr %1421, 2
  %1425 = insertvalue { ptr, ptr, ptr, i32 } %1424, i32 %offset.i.i240.i2532, 3
  %1426 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %294, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1425)
  %1427 = add nuw nsw i32 %.reg2mem77.0398.i2515, 1
  %1428 = icmp slt i32 %1427, %.reg2mem91.0.lcssa.i2479
  br i1 %1428, label %._crit_edge2.i2514, label %HashMap_resize_.exit2585

HashMap_resize_.exit2585:                         ; preds = %._crit_edge2.i2514, %._crit_edge395.i2478
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %30)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i2586)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i2588)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %24)
  %1429 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1430 = load i32, ptr %178, align 4
  %1431 = icmp sgt i32 %1430, 0
  br i1 %1431, label %.lr.ph.i2623, label %._crit_edge1.1.i953

.lr.ph.i2623:                                     ; preds = %HashMap_resize_.exit2585
  %1432 = lshr i160 %1288, 64
  %1433 = insertelement <2 x i160> poison, i160 %1432, i64 0
  %1434 = insertelement <2 x i160> %1433, i160 %1288, i64 1
  %1435 = trunc <2 x i160> %1434 to <2 x i64>
  %1436 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1437 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1438

1438:                                             ; preds = %.cont.cont.i2677, %.lr.ph.i2623
  %offset.i.i260.i26943049 = phi i32 [ 9, %.lr.ph.i2623 ], [ %offset.i.i260.i2694, %.cont.cont.i2677 ]
  %.reg2mem195.0678.i2625 = phi i32 [ 1, %.lr.ph.i2623 ], [ %1593, %.cont.cont.i2677 ]
  %.reg2mem193.0677.i2626 = phi i32 [ 0, %.lr.ph.i2623 ], [ %1598, %.cont.cont.i2677 ]
  %1439 = phi <2 x i64> [ %1435, %.lr.ph.i2623 ], [ %1597, %.cont.cont.i2677 ]
  %1440 = extractelement <2 x i64> %1439, i64 1
  %.sroa.speculated352.i26813045 = inttoptr i64 %1440 to ptr
  %1441 = extractelement <2 x i64> %1439, i64 0
  %.sroa.speculated346.i26823047 = inttoptr i64 %1441 to ptr
  %1442 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i26813045, 1
  %1443 = insertvalue { ptr, ptr, ptr, i32 } %1442, ptr %.sroa.speculated346.i26823047, 2
  %1444 = insertvalue { ptr, ptr, ptr, i32 } %1443, i32 %offset.i.i260.i26943049, 3
  %1445 = sext i32 %offset.i.i260.i26943049 to i64
  %gep3043 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1445
  %1446 = load ptr, ptr %gep3043, align 8
  %1447 = call ptr %1446({ ptr, ptr, ptr, i32 } %1444, ptr nonnull %2)
  %1448 = call i32 %1447({ ptr, ptr, ptr, i32 } %1444, { ptr, ptr, ptr, i32 } %1444, ptr nonnull %2)
  %1449 = icmp eq i32 %.reg2mem195.0678.i2625, 1
  %1450 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1449, label %1451, label %1513

1451:                                             ; preds = %1438
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1452 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1453 = load ptr, ptr %162, align 8
  %1454 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1453, 0
  %1455 = load ptr, ptr %163, align 8
  %1456 = insertvalue { ptr, ptr, ptr, i32 } %1454, ptr %1455, 1
  %1457 = load ptr, ptr %251, align 8
  %1458 = insertvalue { ptr, ptr, ptr, i32 } %1456, ptr %1457, 2
  %1459 = load i32, ptr %164, align 4
  %1460 = insertvalue { ptr, ptr, ptr, i32 } %1458, i32 %1459, 3
  %hash_coef_ptr.i.i10.i3630 = getelementptr i8, ptr %1453, i64 8
  %tbl_size_ptr.i.i11.i3631 = getelementptr i8, ptr %1453, i64 16
  %offset_tbl_ptr.i.i12.i3632 = getelementptr i8, ptr %1453, i64 40
  %hash_coef.i.i13.i3633 = load i64, ptr %hash_coef_ptr.i.i10.i3630, align 4
  %tbl_size.i.i14.i3634 = load i64, ptr %tbl_size_ptr.i.i11.i3631, align 4
  %offset_tbl.i.i15.i3635 = load ptr, ptr %offset_tbl_ptr.i.i12.i3632, align 8
  %product.i.i.i16.i3636 = mul i64 %hash_coef.i.i13.i3633, -5261542750394134544
  %shifted.i.i.i17.i3637 = lshr i64 %product.i.i.i16.i3636, 32
  %xored.i.i.i18.i3638 = xor i64 %shifted.i.i.i17.i3637, %product.i.i.i16.i3636
  %hash.i.i.i19.i3639 = and i64 %xored.i.i.i18.i3638, %tbl_size.i.i14.i3634
  %offset_ptr.i.i20.i3640 = getelementptr i32, ptr %offset_tbl.i.i15.i3635, i64 %hash.i.i.i19.i3639
  %offset.i.i21.i3641 = load i32, ptr %offset_ptr.i.i20.i3640, align 4
  %eq.i.i3642 = icmp eq i32 %1459, %offset.i.i21.i3641
  call void @llvm.assume(i1 %eq.i.i3642) #30
  %1461 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1462 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1453)
  %1463 = sext i32 %1459 to i64
  %1464 = getelementptr ptr, ptr %1453, i64 %1463
  %1465 = getelementptr i8, ptr %1464, i64 64
  %1466 = load ptr, ptr %1465, align 8
  %1467 = call ptr %1466({ ptr, ptr, ptr, i32 } %1460, ptr nonnull %2)
  %1468 = call i32 %1467({ ptr, ptr, ptr, i32 } %1460, { ptr, ptr, ptr, i32 } %1460, ptr nonnull %2)
  %1469 = add i32 %1468, -1
  %1470 = and i32 %1469, %1448
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1471 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1472 = load ptr, ptr %162, align 8
  %1473 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1472, 0
  %1474 = load ptr, ptr %163, align 8
  %1475 = insertvalue { ptr, ptr, ptr, i32 } %1473, ptr %1474, 1
  %1476 = load ptr, ptr %251, align 8
  %1477 = insertvalue { ptr, ptr, ptr, i32 } %1475, ptr %1476, 2
  %1478 = load i32, ptr %164, align 4
  %1479 = insertvalue { ptr, ptr, ptr, i32 } %1477, i32 %1478, 3
  %hash_coef_ptr.i.i172.i2699 = getelementptr i8, ptr %1472, i64 8
  %tbl_size_ptr.i.i173.i2700 = getelementptr i8, ptr %1472, i64 16
  %offset_tbl_ptr.i.i174.i2701 = getelementptr i8, ptr %1472, i64 40
  %hash_coef.i.i175.i2702 = load i64, ptr %hash_coef_ptr.i.i172.i2699, align 4
  %tbl_size.i.i176.i2703 = load i64, ptr %tbl_size_ptr.i.i173.i2700, align 4
  %offset_tbl.i.i177.i2704 = load ptr, ptr %offset_tbl_ptr.i.i174.i2701, align 8
  %product.i.i.i178.i2705 = mul i64 %hash_coef.i.i175.i2702, -5261542750394134544
  %shifted.i.i.i179.i2706 = lshr i64 %product.i.i.i178.i2705, 32
  %xored.i.i.i180.i2707 = xor i64 %shifted.i.i.i179.i2706, %product.i.i.i178.i2705
  %hash.i.i.i181.i2708 = and i64 %xored.i.i.i180.i2707, %tbl_size.i.i176.i2703
  %offset_ptr.i.i182.i2709 = getelementptr i32, ptr %offset_tbl.i.i177.i2704, i64 %hash.i.i.i181.i2708
  %offset.i.i183.i2710 = load i32, ptr %offset_ptr.i.i182.i2709, align 4
  %eq.i.i2711 = icmp eq i32 %1478, %offset.i.i183.i2710
  call void @llvm.assume(i1 %eq.i.i2711) #30
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  %1480 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %9)
  %1481 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1472)
  %1482 = sext i32 %1478 to i64
  %1483 = getelementptr ptr, ptr %1472, i64 %1482
  %1484 = getelementptr i8, ptr %1483, i64 120
  %1485 = load ptr, ptr %1484, align 8
  store ptr @i32_typ, ptr %10, align 8
  %1486 = call ptr %1485({ ptr, ptr, ptr, i32 } %1479, ptr nonnull %10)
  %1487 = call { ptr, i160 } %1486({ ptr, ptr, ptr, i32 } %1479, { ptr, ptr, ptr, i32 } %1479, ptr nonnull %9, i32 %1470)
  %.fca.0.extract112.i2712 = extractvalue { ptr, i160 } %1487, 0
  %.sroa.3111.0.insert.ext.i2713 = zext i32 %offset.i.i260.i26943049 to i160
  %.sroa.3111.0.insert.shift.i2714 = shl nuw i160 %.sroa.3111.0.insert.ext.i2713, 128
  %.sroa.2110.0.insert.ext.i2715 = zext i64 %1441 to i160
  %.sroa.2110.0.insert.shift.i2716 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i2715, 64
  %.sroa.2110.0.insert.insert.i2717 = or disjoint i160 %.sroa.2110.0.insert.shift.i2716, %.sroa.3111.0.insert.shift.i2714
  %.sroa.0109.0.insert.ext.i2718 = zext i64 %1440 to i160
  %.sroa.0109.0.insert.insert.i2719 = or disjoint i160 %.sroa.2110.0.insert.insert.i2717, %.sroa.0109.0.insert.ext.i2718
  %1488 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i2719, 1
  %1489 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1490 = load ptr, ptr %162, align 8
  %1491 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1490, 0
  %1492 = load ptr, ptr %163, align 8
  %1493 = insertvalue { ptr, ptr, ptr, i32 } %1491, ptr %1492, 1
  %1494 = load ptr, ptr %251, align 8
  %1495 = insertvalue { ptr, ptr, ptr, i32 } %1493, ptr %1494, 2
  %1496 = load i32, ptr %164, align 4
  %1497 = insertvalue { ptr, ptr, ptr, i32 } %1495, i32 %1496, 3
  %hash_coef_ptr.i.i186.i2724 = getelementptr i8, ptr %1490, i64 8
  %tbl_size_ptr.i.i187.i2725 = getelementptr i8, ptr %1490, i64 16
  %offset_tbl_ptr.i.i188.i2726 = getelementptr i8, ptr %1490, i64 40
  %hash_coef.i.i189.i2727 = load i64, ptr %hash_coef_ptr.i.i186.i2724, align 4
  %tbl_size.i.i190.i2728 = load i64, ptr %tbl_size_ptr.i.i187.i2725, align 4
  %offset_tbl.i.i191.i2729 = load ptr, ptr %offset_tbl_ptr.i.i188.i2726, align 8
  %product.i.i.i192.i2730 = mul i64 %hash_coef.i.i189.i2727, -5261542750394134544
  %shifted.i.i.i193.i2731 = lshr i64 %product.i.i.i192.i2730, 32
  %xored.i.i.i194.i2732 = xor i64 %shifted.i.i.i193.i2731, %product.i.i.i192.i2730
  %hash.i.i.i195.i2733 = and i64 %xored.i.i.i194.i2732, %tbl_size.i.i190.i2728
  %offset_ptr.i.i196.i2734 = getelementptr i32, ptr %offset_tbl.i.i191.i2729, i64 %hash.i.i.i195.i2733
  %offset.i.i197.i2735 = load i32, ptr %offset_ptr.i.i196.i2734, align 4
  %eq.i200.i2736 = icmp eq i32 %1496, %offset.i.i197.i2735
  call void @llvm.assume(i1 %eq.i200.i2736) #30
  %1498 = load ptr, ptr %result.i, align 8
  %1499 = load ptr, ptr %145, align 8
  %result.i.i2737 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1500 = getelementptr i8, ptr %result.i.i2737, i64 16
  store ptr %1499, ptr %1500, align 8
  %1501 = getelementptr i8, ptr %result.i.i2737, i64 8
  store ptr %1498, ptr %1501, align 8
  %1502 = getelementptr i8, ptr %result.i.i2737, i64 24
  store ptr null, ptr %1502, align 8
  %1503 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i2737)
  store ptr @Entry, ptr %result.i.i2737, align 8
  store ptr @_parameterization_Ptri32, ptr %11, align 8
  store ptr %result.i.i2737, ptr %310, align 8
  %1504 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %11)
  %1505 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1490)
  %1506 = sext i32 %1496 to i64
  %1507 = getelementptr ptr, ptr %1490, i64 %1506
  %1508 = getelementptr i8, ptr %1507, i64 128
  %1509 = load ptr, ptr %1508, align 8
  store ptr @i32_typ, ptr %12, align 8
  store ptr @Entry, ptr %311, align 8
  %1510 = call ptr %1509({ ptr, ptr, ptr, i32 } %1497, ptr nonnull %12)
  call void %1510({ ptr, ptr, ptr, i32 } %1497, { ptr, ptr, ptr, i32 } %1497, ptr nonnull %11, i32 %1470, { ptr, i160 } %1488)
  %1511 = icmp ne ptr %.fca.0.extract112.i2712, @nil_typ
  %1512 = icmp ne ptr %.fca.0.extract112.i2712, null
  %.not140.i2738 = and i1 %1511, %1512
  br i1 %.not140.i2738, label %.cont.cont.i2677, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2744.thread

1513:                                             ; preds = %1438
  %1514 = add i32 %1448, 2127912214
  %1515 = shl i32 %1448, 12
  %1516 = add i32 %1514, %1515
  %1517 = ashr i32 %1516, 19
  %1518 = xor i32 %1516, %1517
  %1519 = xor i32 %1518, -949894596
  %1520 = add i32 %1519, 374761393
  %1521 = shl i32 %1519, 5
  %1522 = add i32 %1520, %1521
  %1523 = add i32 %1522, -744332180
  %1524 = shl i32 %1522, 9
  %1525 = xor i32 %1523, %1524
  %1526 = add i32 %1525, -42973499
  %1527 = shl i32 %1525, 3
  %1528 = add i32 %1526, %1527
  %1529 = ashr i32 %1528, 16
  %1530 = xor i32 %1528, %1529
  %1531 = xor i32 %1530, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1532 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1533 = load ptr, ptr %175, align 8
  %1534 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1533, 0
  %1535 = load ptr, ptr %176, align 8
  %1536 = insertvalue { ptr, ptr, ptr, i32 } %1534, ptr %1535, 1
  %1537 = load ptr, ptr %252, align 8
  %1538 = insertvalue { ptr, ptr, ptr, i32 } %1536, ptr %1537, 2
  %1539 = load i32, ptr %177, align 4
  %1540 = insertvalue { ptr, ptr, ptr, i32 } %1538, i32 %1539, 3
  %hash_coef_ptr.i.i10.i3660 = getelementptr i8, ptr %1533, i64 8
  %tbl_size_ptr.i.i11.i3661 = getelementptr i8, ptr %1533, i64 16
  %offset_tbl_ptr.i.i12.i3662 = getelementptr i8, ptr %1533, i64 40
  %hash_coef.i.i13.i3663 = load i64, ptr %hash_coef_ptr.i.i10.i3660, align 4
  %tbl_size.i.i14.i3664 = load i64, ptr %tbl_size_ptr.i.i11.i3661, align 4
  %offset_tbl.i.i15.i3665 = load ptr, ptr %offset_tbl_ptr.i.i12.i3662, align 8
  %product.i.i.i16.i3666 = mul i64 %hash_coef.i.i13.i3663, -5261542750394134544
  %shifted.i.i.i17.i3667 = lshr i64 %product.i.i.i16.i3666, 32
  %xored.i.i.i18.i3668 = xor i64 %shifted.i.i.i17.i3667, %product.i.i.i16.i3666
  %hash.i.i.i19.i3669 = and i64 %xored.i.i.i18.i3668, %tbl_size.i.i14.i3664
  %offset_ptr.i.i20.i3670 = getelementptr i32, ptr %offset_tbl.i.i15.i3665, i64 %hash.i.i.i19.i3669
  %offset.i.i21.i3671 = load i32, ptr %offset_ptr.i.i20.i3670, align 4
  %eq.i.i3672 = icmp eq i32 %1539, %offset.i.i21.i3671
  call void @llvm.assume(i1 %eq.i.i3672) #30
  %1541 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1542 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1533)
  %1543 = sext i32 %1539 to i64
  %1544 = getelementptr ptr, ptr %1533, i64 %1543
  %1545 = getelementptr i8, ptr %1544, i64 64
  %1546 = load ptr, ptr %1545, align 8
  %1547 = call ptr %1546({ ptr, ptr, ptr, i32 } %1540, ptr nonnull %2)
  %1548 = call i32 %1547({ ptr, ptr, ptr, i32 } %1540, { ptr, ptr, ptr, i32 } %1540, ptr nonnull %2)
  %1549 = add i32 %1548, -1
  %1550 = and i32 %1549, %1531
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1551 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1552 = load ptr, ptr %175, align 8
  %1553 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1552, 0
  %1554 = load ptr, ptr %176, align 8
  %1555 = insertvalue { ptr, ptr, ptr, i32 } %1553, ptr %1554, 1
  %1556 = load ptr, ptr %252, align 8
  %1557 = insertvalue { ptr, ptr, ptr, i32 } %1555, ptr %1556, 2
  %1558 = load i32, ptr %177, align 4
  %1559 = insertvalue { ptr, ptr, ptr, i32 } %1557, i32 %1558, 3
  %hash_coef_ptr.i.i202.i2631 = getelementptr i8, ptr %1552, i64 8
  %tbl_size_ptr.i.i203.i2632 = getelementptr i8, ptr %1552, i64 16
  %offset_tbl_ptr.i.i204.i2633 = getelementptr i8, ptr %1552, i64 40
  %hash_coef.i.i205.i2634 = load i64, ptr %hash_coef_ptr.i.i202.i2631, align 4
  %tbl_size.i.i206.i2635 = load i64, ptr %tbl_size_ptr.i.i203.i2632, align 4
  %offset_tbl.i.i207.i2636 = load ptr, ptr %offset_tbl_ptr.i.i204.i2633, align 8
  %product.i.i.i208.i2637 = mul i64 %hash_coef.i.i205.i2634, -5261542750394134544
  %shifted.i.i.i209.i2638 = lshr i64 %product.i.i.i208.i2637, 32
  %xored.i.i.i210.i2639 = xor i64 %shifted.i.i.i209.i2638, %product.i.i.i208.i2637
  %hash.i.i.i211.i2640 = and i64 %xored.i.i.i210.i2639, %tbl_size.i.i206.i2635
  %offset_ptr.i.i212.i2641 = getelementptr i32, ptr %offset_tbl.i.i207.i2636, i64 %hash.i.i.i211.i2640
  %offset.i.i213.i2642 = load i32, ptr %offset_ptr.i.i212.i2641, align 4
  %eq.i216.i2643 = icmp eq i32 %1558, %offset.i.i213.i2642
  call void @llvm.assume(i1 %eq.i216.i2643) #30
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %1560 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %17)
  %1561 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1552)
  %1562 = sext i32 %1558 to i64
  %1563 = getelementptr ptr, ptr %1552, i64 %1562
  %1564 = getelementptr i8, ptr %1563, i64 120
  %1565 = load ptr, ptr %1564, align 8
  store ptr @i32_typ, ptr %18, align 8
  %1566 = call ptr %1565({ ptr, ptr, ptr, i32 } %1559, ptr nonnull %18)
  %1567 = call { ptr, i160 } %1566({ ptr, ptr, ptr, i32 } %1559, { ptr, ptr, ptr, i32 } %1559, ptr nonnull %17, i32 %1550)
  %.fca.0.extract87.i2644 = extractvalue { ptr, i160 } %1567, 0
  %.sroa.3.0.insert.ext.i2645 = zext i32 %offset.i.i260.i26943049 to i160
  %.sroa.3.0.insert.shift.i2646 = shl nuw i160 %.sroa.3.0.insert.ext.i2645, 128
  %.sroa.2.0.insert.ext.i2647 = zext i64 %1441 to i160
  %.sroa.2.0.insert.shift.i2648 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i2647, 64
  %.sroa.2.0.insert.insert.i2649 = or disjoint i160 %.sroa.2.0.insert.shift.i2648, %.sroa.3.0.insert.shift.i2646
  %.sroa.0.0.insert.ext.i2650 = zext i64 %1440 to i160
  %.sroa.0.0.insert.insert.i2651 = or disjoint i160 %.sroa.2.0.insert.insert.i2649, %.sroa.0.0.insert.ext.i2650
  %1568 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i2651, 1
  %1569 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1570 = load ptr, ptr %175, align 8
  %1571 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1570, 0
  %1572 = load ptr, ptr %176, align 8
  %1573 = insertvalue { ptr, ptr, ptr, i32 } %1571, ptr %1572, 1
  %1574 = load ptr, ptr %252, align 8
  %1575 = insertvalue { ptr, ptr, ptr, i32 } %1573, ptr %1574, 2
  %1576 = load i32, ptr %177, align 4
  %1577 = insertvalue { ptr, ptr, ptr, i32 } %1575, i32 %1576, 3
  %hash_coef_ptr.i.i218.i2656 = getelementptr i8, ptr %1570, i64 8
  %tbl_size_ptr.i.i219.i2657 = getelementptr i8, ptr %1570, i64 16
  %offset_tbl_ptr.i.i220.i2658 = getelementptr i8, ptr %1570, i64 40
  %hash_coef.i.i221.i2659 = load i64, ptr %hash_coef_ptr.i.i218.i2656, align 4
  %tbl_size.i.i222.i2660 = load i64, ptr %tbl_size_ptr.i.i219.i2657, align 4
  %offset_tbl.i.i223.i2661 = load ptr, ptr %offset_tbl_ptr.i.i220.i2658, align 8
  %product.i.i.i224.i2662 = mul i64 %hash_coef.i.i221.i2659, -5261542750394134544
  %shifted.i.i.i225.i2663 = lshr i64 %product.i.i.i224.i2662, 32
  %xored.i.i.i226.i2664 = xor i64 %shifted.i.i.i225.i2663, %product.i.i.i224.i2662
  %hash.i.i.i227.i2665 = and i64 %xored.i.i.i226.i2664, %tbl_size.i.i222.i2660
  %offset_ptr.i.i228.i2666 = getelementptr i32, ptr %offset_tbl.i.i223.i2661, i64 %hash.i.i.i227.i2665
  %offset.i.i229.i2667 = load i32, ptr %offset_ptr.i.i228.i2666, align 4
  %eq.i232.i2668 = icmp eq i32 %1576, %offset.i.i229.i2667
  call void @llvm.assume(i1 %eq.i232.i2668) #30
  %1578 = load ptr, ptr %result.i, align 8
  %1579 = load ptr, ptr %145, align 8
  %result.i233.i2669 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1580 = getelementptr i8, ptr %result.i233.i2669, i64 16
  store ptr %1579, ptr %1580, align 8
  %1581 = getelementptr i8, ptr %result.i233.i2669, i64 8
  store ptr %1578, ptr %1581, align 8
  %1582 = getelementptr i8, ptr %result.i233.i2669, i64 24
  store ptr null, ptr %1582, align 8
  %1583 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i2669)
  store ptr @Entry, ptr %result.i233.i2669, align 8
  store ptr @_parameterization_Ptri32, ptr %19, align 8
  store ptr %result.i233.i2669, ptr %308, align 8
  %1584 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %19)
  %1585 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1570)
  %1586 = sext i32 %1576 to i64
  %1587 = getelementptr ptr, ptr %1570, i64 %1586
  %1588 = getelementptr i8, ptr %1587, i64 128
  %1589 = load ptr, ptr %1588, align 8
  store ptr @i32_typ, ptr %20, align 8
  store ptr @Entry, ptr %309, align 8
  %1590 = call ptr %1589({ ptr, ptr, ptr, i32 } %1577, ptr nonnull %20)
  call void %1590({ ptr, ptr, ptr, i32 } %1577, { ptr, ptr, ptr, i32 } %1577, ptr nonnull %19, i32 %1550, { ptr, i160 } %1568)
  %1591 = icmp ne ptr %.fca.0.extract87.i2644, @nil_typ
  %1592 = icmp ne ptr %.fca.0.extract87.i2644, null
  %.not138.i2670 = and i1 %1591, %1592
  br i1 %.not138.i2670, label %.cont.cont.i2677, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2744.thread

.cont.cont.i2677:                                 ; preds = %1513, %1451
  %.sink3067 = phi { ptr, i160 } [ %1487, %1451 ], [ %1567, %1513 ]
  %1593 = phi i32 [ 2, %1451 ], [ 1, %1513 ]
  %vptr.i248.sroa.speculated.i2680 = phi ptr [ %.fca.0.extract112.i2712, %1451 ], [ %.fca.0.extract87.i2644, %1513 ]
  %.fca.1.extract89.i2673 = extractvalue { ptr, i160 } %.sink3067, 1
  %.sroa.3407.sroa.4.0.extract.shift.i2674 = lshr i160 %.fca.1.extract89.i2673, 64
  %1594 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i2674 to i64
  %1595 = insertelement <2 x i64> poison, i64 %1594, i64 0
  %1596 = trunc i160 %.fca.1.extract89.i2673 to i64
  %1597 = insertelement <2 x i64> %1595, i64 %1596, i64 1
  %hash_coef_ptr.i.i249.i2683 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2680, i64 8
  %tbl_size_ptr.i.i250.i2684 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2680, i64 16
  %offset_tbl_ptr.i.i251.i2685 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2680, i64 40
  %hash_coef.i.i252.i2686 = load i64, ptr %hash_coef_ptr.i.i249.i2683, align 4
  %tbl_size.i.i253.i2687 = load i64, ptr %tbl_size_ptr.i.i250.i2684, align 4
  %offset_tbl.i.i254.i2688 = load ptr, ptr %offset_tbl_ptr.i.i251.i2685, align 8
  %product.i.i.i255.i2689 = mul i64 %hash_coef.i.i252.i2686, 4015701072841558310
  %shifted.i.i.i256.i2690 = lshr i64 %product.i.i.i255.i2689, 32
  %xored.i.i.i257.i2691 = xor i64 %shifted.i.i.i256.i2690, %product.i.i.i255.i2689
  %hash.i.i.i258.i2692 = and i64 %xored.i.i.i257.i2691, %tbl_size.i.i253.i2687
  %offset_ptr.i.i259.i2693 = getelementptr i32, ptr %offset_tbl.i.i254.i2688, i64 %hash.i.i.i258.i2692
  %offset.i.i260.i2694 = load i32, ptr %offset_ptr.i.i259.i2693, align 4
  %1598 = add nuw nsw i32 %.reg2mem193.0677.i2626, 1
  %1599 = load i32, ptr %178, align 4
  %1600 = icmp slt i32 %1598, %1599
  br i1 %1600, label %1438, label %._crit_edge1.1.i953

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2744.thread: ; preds = %1451, %1513
  %1601 = phi ptr [ %21, %1513 ], [ %13, %1451 ]
  %1602 = phi ptr [ %22, %1513 ], [ %14, %1451 ]
  %1603 = phi ptr [ %23, %1513 ], [ %15, %1451 ]
  %1604 = phi ptr [ %.sroa.0.i2588, %1513 ], [ %.sroa.0680.i2586, %1451 ]
  %1605 = phi ptr [ %24, %1513 ], [ %16, %1451 ]
  %1606 = load i32, ptr %253, align 4
  store i32 %1606, ptr %1601, align 4
  store i32 1, ptr %1602, align 4
  %1607 = add i32 %1606, 1
  store i32 %1607, ptr %1603, align 4
  %1608 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1607, ptr %253, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1605, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1604, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2586)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2588)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  br label %HashMap_insert_keyK_valueV.exit1036

._crit_edge1.1.i953:                              ; preds = %.cont.cont.i2677, %HashMap_resize_.exit2585
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2586)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2588)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %8)
  %1609 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1610 = load ptr, ptr %162, align 8
  %1611 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1610, 0
  %1612 = load ptr, ptr %163, align 8
  %1613 = insertvalue { ptr, ptr, ptr, i32 } %1611, ptr %1612, 1
  %1614 = load ptr, ptr %251, align 8
  %1615 = insertvalue { ptr, ptr, ptr, i32 } %1613, ptr %1614, 2
  %1616 = load i32, ptr %164, align 4
  %1617 = insertvalue { ptr, ptr, ptr, i32 } %1615, i32 %1616, 3
  %hash_coef_ptr.i.i64.i2762 = getelementptr i8, ptr %1610, i64 8
  %tbl_size_ptr.i.i65.i2763 = getelementptr i8, ptr %1610, i64 16
  %offset_tbl_ptr.i.i66.i2764 = getelementptr i8, ptr %1610, i64 40
  %hash_coef.i.i67.i2765 = load i64, ptr %hash_coef_ptr.i.i64.i2762, align 4
  %tbl_size.i.i68.i2766 = load i64, ptr %tbl_size_ptr.i.i65.i2763, align 4
  %offset_tbl.i.i69.i2767 = load ptr, ptr %offset_tbl_ptr.i.i66.i2764, align 8
  %product.i.i.i70.i2768 = mul i64 %hash_coef.i.i67.i2765, -5261542750394134544
  %shifted.i.i.i71.i2769 = lshr i64 %product.i.i.i70.i2768, 32
  %xored.i.i.i72.i2770 = xor i64 %shifted.i.i.i71.i2769, %product.i.i.i70.i2768
  %hash.i.i.i73.i2771 = and i64 %xored.i.i.i72.i2770, %tbl_size.i.i68.i2766
  %offset_ptr.i.i74.i2772 = getelementptr i32, ptr %offset_tbl.i.i69.i2767, i64 %hash.i.i.i73.i2771
  %offset.i.i75.i2773 = load i32, ptr %offset_ptr.i.i74.i2772, align 4
  %eq.i.i2774 = icmp eq i32 %1616, %offset.i.i75.i2773
  call void @llvm.assume(i1 %eq.i.i2774) #30
  %1618 = load ptr, ptr %175, align 8
  %1619 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1618, 0
  %1620 = load ptr, ptr %176, align 8
  %1621 = insertvalue { ptr, ptr, ptr, i32 } %1619, ptr %1620, 1
  %1622 = load ptr, ptr %252, align 8
  %1623 = insertvalue { ptr, ptr, ptr, i32 } %1621, ptr %1622, 2
  %1624 = load i32, ptr %177, align 4
  %1625 = insertvalue { ptr, ptr, ptr, i32 } %1623, i32 %1624, 3
  %hash_coef_ptr.i.i92.i2779 = getelementptr i8, ptr %1618, i64 8
  %tbl_size_ptr.i.i93.i2780 = getelementptr i8, ptr %1618, i64 16
  %offset_tbl_ptr.i.i94.i2781 = getelementptr i8, ptr %1618, i64 40
  %hash_coef.i.i95.i2782 = load i64, ptr %hash_coef_ptr.i.i92.i2779, align 4
  %tbl_size.i.i96.i2783 = load i64, ptr %tbl_size_ptr.i.i93.i2780, align 4
  %offset_tbl.i.i97.i2784 = load ptr, ptr %offset_tbl_ptr.i.i94.i2781, align 8
  %product.i.i.i98.i2785 = mul i64 %hash_coef.i.i95.i2782, -5261542750394134544
  %shifted.i.i.i99.i2786 = lshr i64 %product.i.i.i98.i2785, 32
  %xored.i.i.i100.i2787 = xor i64 %shifted.i.i.i99.i2786, %product.i.i.i98.i2785
  %hash.i.i.i101.i2788 = and i64 %xored.i.i.i100.i2787, %tbl_size.i.i96.i2783
  %offset_ptr.i.i102.i2789 = getelementptr i32, ptr %offset_tbl.i.i97.i2784, i64 %hash.i.i.i101.i2788
  %offset.i.i103.i2790 = load i32, ptr %offset_ptr.i.i102.i2789, align 4
  %eq.i106.i2791 = icmp eq i32 %1624, %offset.i.i103.i2790
  call void @llvm.assume(i1 %eq.i106.i2791) #30
  %1626 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1627 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1610)
  %1628 = sext i32 %1616 to i64
  %1629 = getelementptr ptr, ptr %1610, i64 %1628
  %1630 = getelementptr i8, ptr %1629, i64 64
  %1631 = load ptr, ptr %1630, align 8
  %1632 = call ptr %1631({ ptr, ptr, ptr, i32 } %1617, ptr nonnull %2)
  %1633 = call i32 %1632({ ptr, ptr, ptr, i32 } %1617, { ptr, ptr, ptr, i32 } %1617, ptr nonnull %2)
  %1634 = shl i32 %1633, 1
  %1635 = load i32, ptr %253, align 4
  %1636 = load ptr, ptr %result.i, align 8
  %1637 = load ptr, ptr %145, align 8
  %1638 = sext i32 %1635 to i64
  %1639 = shl nsw i64 %1638, 5
  %result.i.i.i2794 = call noalias ptr @bump_malloc_inner(i64 noundef %1639, ptr nonnull @current_ptr) #29
  %1640 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1641 = icmp sgt i32 %1633, 0
  br i1 %1641, label %.lr.ph434.i2864, label %._crit_edge395.i2808

.lr.ph434.i2864:                                  ; preds = %._crit_edge1.1.i953
  %invariant.gep.i2807 = getelementptr i8, ptr %1610, i64 120
  %1642 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i2867 = getelementptr ptr, ptr %invariant.gep.i2807, i64 %1628
  br label %1643

1643:                                             ; preds = %1665, %.lr.ph434.i2864
  %.reg2mem105.0432.i2865 = phi i32 [ 0, %.lr.ph434.i2864 ], [ %.reg2mem101.0.i2870, %1665 ]
  %.reg2mem103.0431.i2866 = phi i32 [ 0, %.lr.ph434.i2864 ], [ %1666, %1665 ]
  store ptr @_parameterization_Ptri32, ptr %3, align 8
  %1644 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %3)
  %1645 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1610)
  %1646 = load ptr, ptr %gep.i2867, align 8
  store ptr @i32_typ, ptr %4, align 8
  %1647 = call ptr %1646({ ptr, ptr, ptr, i32 } %1617, ptr nonnull %4)
  %1648 = call { ptr, i160 } %1647({ ptr, ptr, ptr, i32 } %1617, { ptr, ptr, ptr, i32 } %1617, ptr nonnull %3, i32 %.reg2mem103.0431.i2866)
  %.fca.0.extract52.i2868 = extractvalue { ptr, i160 } %1648, 0
  %1649 = icmp ne ptr %.fca.0.extract52.i2868, @nil_typ
  %1650 = icmp ne ptr %.fca.0.extract52.i2868, null
  %.not60.i2869 = and i1 %1649, %1650
  br i1 %.not60.i2869, label %1651, label %1665

1651:                                             ; preds = %1643
  %hash_coef_ptr.i.i137.i2897 = getelementptr i8, ptr %.fca.0.extract52.i2868, i64 8
  %tbl_size_ptr.i.i138.i2898 = getelementptr i8, ptr %.fca.0.extract52.i2868, i64 16
  %offset_tbl_ptr.i.i139.i2899 = getelementptr i8, ptr %.fca.0.extract52.i2868, i64 40
  %hash_coef.i.i140.i2900 = load i64, ptr %hash_coef_ptr.i.i137.i2897, align 4
  %tbl_size.i.i141.i2901 = load i64, ptr %tbl_size_ptr.i.i138.i2898, align 4
  %offset_tbl.i.i142.i2902 = load ptr, ptr %offset_tbl_ptr.i.i139.i2899, align 8
  %product.i.i.i143.i2903 = mul i64 %hash_coef.i.i140.i2900, 4015701072841558310
  %shifted.i.i.i144.i2904 = lshr i64 %product.i.i.i143.i2903, 32
  %xored.i.i.i145.i2905 = xor i64 %shifted.i.i.i144.i2904, %product.i.i.i143.i2903
  %hash.i.i.i146.i2906 = and i64 %xored.i.i.i145.i2905, %tbl_size.i.i141.i2901
  %offset_ptr.i.i147.i2907 = getelementptr i32, ptr %offset_tbl.i.i142.i2902, i64 %hash.i.i.i146.i2906
  %offset.i.i148.i2908 = load i32, ptr %offset_ptr.i.i147.i2907, align 4
  %1652 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1653 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1654 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1655 = icmp slt i32 %.reg2mem105.0432.i2865, %1635
  br i1 %1655, label %1656, label %._crit_edge.i2909

1656:                                             ; preds = %1651
  %.fca.1.extract54.i2910 = extractvalue { ptr, i160 } %1648, 1
  %.sroa.351.0.insert.ext.i2911 = zext i32 %offset.i.i148.i2908 to i160
  %.sroa.351.0.insert.shift.i2912 = shl nuw i160 %.sroa.351.0.insert.ext.i2911, 128
  %1657 = and i160 %.fca.1.extract54.i2910, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2913 = or disjoint i160 %.sroa.351.0.insert.shift.i2912, %1657
  %1658 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1659 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1660 = sext i32 %.reg2mem105.0432.i2865 to i64
  %1661 = shl nsw i64 %1660, 5
  %1662 = getelementptr i8, ptr %result.i.i.i2794, i64 %1661
  store ptr %.fca.0.extract52.i2868, ptr %1662, align 8
  %1663 = getelementptr i8, ptr %1662, i64 8
  store i160 %.sroa.049.0.insert.insert.i2913, ptr %1663, align 4
  br label %._crit_edge.i2909

._crit_edge.i2909:                                ; preds = %1656, %1651
  %1664 = add i32 %.reg2mem105.0432.i2865, 1
  br label %1665

1665:                                             ; preds = %._crit_edge.i2909, %1643
  %.reg2mem101.0.i2870 = phi i32 [ %1664, %._crit_edge.i2909 ], [ %.reg2mem105.0432.i2865, %1643 ]
  %1666 = add nuw nsw i32 %.reg2mem103.0431.i2866, 1
  %1667 = icmp slt i32 %1666, %1633
  br i1 %1667, label %1643, label %.lr.ph.i2871

.lr.ph.i2871:                                     ; preds = %1665
  %invariant.gep396.i2872 = getelementptr i8, ptr %1618, i64 120
  %1668 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1669 = sext i32 %1624 to i64
  %gep397.i2875 = getelementptr ptr, ptr %invariant.gep396.i2872, i64 %1669
  br label %1670

1670:                                             ; preds = %1692, %.lr.ph.i2871
  %.reg2mem91.0394.i2873 = phi i32 [ %.reg2mem101.0.i2870, %.lr.ph.i2871 ], [ %.reg2mem87.0.i2878, %1692 ]
  %.reg2mem89.0393.i2874 = phi i32 [ 0, %.lr.ph.i2871 ], [ %1693, %1692 ]
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %1671 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %1672 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1618)
  %1673 = load ptr, ptr %gep397.i2875, align 8
  store ptr @i32_typ, ptr %6, align 8
  %1674 = call ptr %1673({ ptr, ptr, ptr, i32 } %1625, ptr nonnull %6)
  %1675 = call { ptr, i160 } %1674({ ptr, ptr, ptr, i32 } %1625, { ptr, ptr, ptr, i32 } %1625, ptr nonnull %5, i32 %.reg2mem89.0393.i2874)
  %.fca.0.extract42.i2876 = extractvalue { ptr, i160 } %1675, 0
  %1676 = icmp ne ptr %.fca.0.extract42.i2876, @nil_typ
  %1677 = icmp ne ptr %.fca.0.extract42.i2876, null
  %.not62.i2877 = and i1 %1676, %1677
  br i1 %.not62.i2877, label %1678, label %1692

1678:                                             ; preds = %1670
  %hash_coef_ptr.i.i152.i2879 = getelementptr i8, ptr %.fca.0.extract42.i2876, i64 8
  %tbl_size_ptr.i.i153.i2880 = getelementptr i8, ptr %.fca.0.extract42.i2876, i64 16
  %offset_tbl_ptr.i.i154.i2881 = getelementptr i8, ptr %.fca.0.extract42.i2876, i64 40
  %hash_coef.i.i155.i2882 = load i64, ptr %hash_coef_ptr.i.i152.i2879, align 4
  %tbl_size.i.i156.i2883 = load i64, ptr %tbl_size_ptr.i.i153.i2880, align 4
  %offset_tbl.i.i157.i2884 = load ptr, ptr %offset_tbl_ptr.i.i154.i2881, align 8
  %product.i.i.i158.i2885 = mul i64 %hash_coef.i.i155.i2882, 4015701072841558310
  %shifted.i.i.i159.i2886 = lshr i64 %product.i.i.i158.i2885, 32
  %xored.i.i.i160.i2887 = xor i64 %shifted.i.i.i159.i2886, %product.i.i.i158.i2885
  %hash.i.i.i161.i2888 = and i64 %xored.i.i.i160.i2887, %tbl_size.i.i156.i2883
  %offset_ptr.i.i162.i2889 = getelementptr i32, ptr %offset_tbl.i.i157.i2884, i64 %hash.i.i.i161.i2888
  %offset.i.i163.i2890 = load i32, ptr %offset_ptr.i.i162.i2889, align 4
  %1679 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1680 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1681 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1682 = icmp slt i32 %.reg2mem91.0394.i2873, %1635
  br i1 %1682, label %1683, label %._crit_edge1.i2891

1683:                                             ; preds = %1678
  %.fca.1.extract44.i2892 = extractvalue { ptr, i160 } %1675, 1
  %.sroa.3.0.insert.ext.i2893 = zext i32 %offset.i.i163.i2890 to i160
  %.sroa.3.0.insert.shift.i2894 = shl nuw i160 %.sroa.3.0.insert.ext.i2893, 128
  %1684 = and i160 %.fca.1.extract44.i2892, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2895 = or disjoint i160 %.sroa.3.0.insert.shift.i2894, %1684
  %1685 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1686 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1687 = sext i32 %.reg2mem91.0394.i2873 to i64
  %1688 = shl nsw i64 %1687, 5
  %1689 = getelementptr i8, ptr %result.i.i.i2794, i64 %1688
  store ptr %.fca.0.extract42.i2876, ptr %1689, align 8
  %1690 = getelementptr i8, ptr %1689, i64 8
  store i160 %.sroa.040.0.insert.insert.i2895, ptr %1690, align 4
  br label %._crit_edge1.i2891

._crit_edge1.i2891:                               ; preds = %1683, %1678
  %1691 = add i32 %.reg2mem91.0394.i2873, 1
  br label %1692

1692:                                             ; preds = %._crit_edge1.i2891, %1670
  %.reg2mem87.0.i2878 = phi i32 [ %1691, %._crit_edge1.i2891 ], [ %.reg2mem91.0394.i2873, %1670 ]
  %1693 = add nuw nsw i32 %.reg2mem89.0393.i2874, 1
  %1694 = icmp slt i32 %1693, %1633
  br i1 %1694, label %1670, label %._crit_edge395.i2808.loopexit

._crit_edge395.i2808.loopexit:                    ; preds = %1692
  %.pre3421 = load ptr, ptr %result.i, align 8
  %.pre3422 = load ptr, ptr %145, align 8
  br label %._crit_edge395.i2808

._crit_edge395.i2808:                             ; preds = %._crit_edge395.i2808.loopexit, %._crit_edge1.1.i953
  %1695 = phi ptr [ %1637, %._crit_edge1.1.i953 ], [ %.pre3422, %._crit_edge395.i2808.loopexit ]
  %1696 = phi ptr [ %1636, %._crit_edge1.1.i953 ], [ %.pre3421, %._crit_edge395.i2808.loopexit ]
  %.reg2mem91.0.lcssa.i2809 = phi i32 [ 0, %._crit_edge1.1.i953 ], [ %.reg2mem87.0.i2878, %._crit_edge395.i2808.loopexit ]
  %1697 = call i32 @llvm.smax.i32(i32 %1634, i32 16)
  %result.i166.i2810 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1698 = getelementptr i8, ptr %result.i166.i2810, i64 16
  store ptr @_parameterization_Nil, ptr %1698, align 8
  %result.i167.i2811 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1699 = getelementptr i8, ptr %result.i167.i2811, i64 16
  store ptr %1695, ptr %1699, align 8
  %1700 = getelementptr i8, ptr %result.i167.i2811, i64 8
  store ptr %1696, ptr %1700, align 8
  %1701 = getelementptr i8, ptr %result.i167.i2811, i64 24
  store ptr null, ptr %1701, align 8
  %1702 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i2811)
  store ptr @Entry, ptr %result.i167.i2811, align 8
  %1703 = getelementptr i8, ptr %result.i166.i2810, i64 8
  store ptr %result.i167.i2811, ptr %1703, align 8
  %1704 = getelementptr i8, ptr %result.i166.i2810, i64 24
  store ptr null, ptr %1704, align 8
  %1705 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i2810)
  store ptr @union_typ, ptr %result.i166.i2810, align 8
  %result.i168.i2812 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i2810, ptr %result.i168.i2812, align 8
  %1706 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i2812)
  store ptr @Array, ptr %7, align 8
  store ptr %result.i168.i2812, ptr %312, align 8
  store i32 9, ptr %313, align 8
  %1707 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %7)
  %1708 = getelementptr i8, ptr %result.i168.i2812, i64 16
  store i32 %1697, ptr %1708, align 4
  %1709 = getelementptr i8, ptr %result.i168.i2812, i64 20
  store i32 %1697, ptr %1709, align 4
  %1710 = zext nneg i32 %1697 to i64
  %1711 = shl nuw nsw i64 %1710, 5
  %result.i.i416.i2813 = call noalias ptr @bump_malloc_inner(i64 noundef %1711, ptr nonnull @current_ptr) #29
  %1712 = getelementptr i8, ptr %result.i168.i2812, i64 8
  store ptr %result.i.i416.i2813, ptr %1712, align 8
  %1713 = load ptr, ptr %314, align 8
  store ptr @Array, ptr %162, align 8
  store ptr %result.i168.i2812, ptr %163, align 8
  store ptr %1713, ptr %251, align 8
  store i32 9, ptr %164, align 4
  %1714 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i2826 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1715 = getelementptr i8, ptr %result.i183.i2826, i64 16
  store ptr @_parameterization_Nil, ptr %1715, align 8
  %result.i184.i2827 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1716 = getelementptr i8, ptr %result.i184.i2827, i64 16
  store ptr %1695, ptr %1716, align 8
  %1717 = getelementptr i8, ptr %result.i184.i2827, i64 8
  store ptr %1696, ptr %1717, align 8
  %1718 = getelementptr i8, ptr %result.i184.i2827, i64 24
  store ptr null, ptr %1718, align 8
  %1719 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i2827)
  store ptr @Entry, ptr %result.i184.i2827, align 8
  %1720 = getelementptr i8, ptr %result.i183.i2826, i64 8
  store ptr %result.i184.i2827, ptr %1720, align 8
  %1721 = getelementptr i8, ptr %result.i183.i2826, i64 24
  store ptr null, ptr %1721, align 8
  %1722 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i2826)
  store ptr @union_typ, ptr %result.i183.i2826, align 8
  %result.i185.i2828 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i2826, ptr %result.i185.i2828, align 8
  %1723 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i2828)
  store ptr @Array, ptr %8, align 8
  store ptr %result.i185.i2828, ptr %315, align 8
  store i32 9, ptr %316, align 8
  %1724 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %8)
  %1725 = getelementptr i8, ptr %result.i185.i2828, i64 16
  store i32 %1697, ptr %1725, align 4
  %1726 = getelementptr i8, ptr %result.i185.i2828, i64 20
  store i32 %1697, ptr %1726, align 4
  %result.i.i430.i2829 = call noalias ptr @bump_malloc_inner(i64 noundef %1711, ptr nonnull @current_ptr) #29
  %1727 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1728 = getelementptr i8, ptr %result.i185.i2828, i64 8
  store ptr %result.i.i430.i2829, ptr %1728, align 8
  %1729 = load ptr, ptr %317, align 8
  store ptr @Array, ptr %175, align 8
  store ptr %result.i185.i2828, ptr %176, align 8
  store ptr %1729, ptr %252, align 8
  store i32 9, ptr %177, align 4
  store i32 0, ptr %253, align 4
  %1730 = icmp sgt i32 %.reg2mem91.0.lcssa.i2809, 0
  br i1 %1730, label %.lr.ph400.i2842, label %HashMap_resize_.exit2915

.lr.ph400.i2842:                                  ; preds = %._crit_edge395.i2808
  %1731 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1732 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1733 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i2844

._crit_edge2.i2844:                               ; preds = %._crit_edge2.i2844, %.lr.ph400.i2842
  %.reg2mem77.0398.i2845 = phi i32 [ 0, %.lr.ph400.i2842 ], [ %1747, %._crit_edge2.i2844 ]
  %1734 = zext nneg i32 %.reg2mem77.0398.i2845 to i64
  %1735 = shl nuw nsw i64 %1734, 5
  %1736 = getelementptr i8, ptr %result.i.i.i2794, i64 %1735
  %1737 = load ptr, ptr %1736, align 8
  %1738 = getelementptr i8, ptr %1736, i64 8
  %1739 = load i160, ptr %1738, align 4
  %.sroa.3362.8.extract.trunc.i2848 = trunc i160 %1739 to i64
  %1740 = inttoptr i64 %.sroa.3362.8.extract.trunc.i2848 to ptr
  %.sroa.5363.8.extract.shift.i2849 = lshr i160 %1739, 64
  %.sroa.5363.8.extract.trunc.i2850 = trunc i160 %.sroa.5363.8.extract.shift.i2849 to i64
  %1741 = inttoptr i64 %.sroa.5363.8.extract.trunc.i2850 to ptr
  %hash_coef_ptr.i.i201.i2851 = getelementptr i8, ptr %1737, i64 8
  %tbl_size_ptr.i.i202.i2852 = getelementptr i8, ptr %1737, i64 16
  %offset_tbl_ptr.i.i203.i2853 = getelementptr i8, ptr %1737, i64 40
  %hash_coef.i.i232.i2854 = load i64, ptr %hash_coef_ptr.i.i201.i2851, align 4
  %tbl_size.i.i233.i2855 = load i64, ptr %tbl_size_ptr.i.i202.i2852, align 4
  %offset_tbl.i.i234.i2856 = load ptr, ptr %offset_tbl_ptr.i.i203.i2853, align 8
  %product.i.i.i235.i2857 = mul i64 %hash_coef.i.i232.i2854, 4015701072841558310
  %shifted.i.i.i236.i2858 = lshr i64 %product.i.i.i235.i2857, 32
  %xored.i.i.i237.i2859 = xor i64 %shifted.i.i.i236.i2858, %product.i.i.i235.i2857
  %hash.i.i.i238.i2860 = and i64 %xored.i.i.i237.i2859, %tbl_size.i.i233.i2855
  %offset_ptr.i.i239.i2861 = getelementptr i32, ptr %offset_tbl.i.i234.i2856, i64 %hash.i.i.i238.i2860
  %offset.i.i240.i2862 = load i32, ptr %offset_ptr.i.i239.i2861, align 4
  %1742 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1737, 0
  %1743 = insertvalue { ptr, ptr, ptr, i32 } %1742, ptr %1740, 1
  %1744 = insertvalue { ptr, ptr, ptr, i32 } %1743, ptr %1741, 2
  %1745 = insertvalue { ptr, ptr, ptr, i32 } %1744, i32 %offset.i.i240.i2862, 3
  %1746 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %294, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1745)
  %1747 = add nuw nsw i32 %.reg2mem77.0398.i2845, 1
  %1748 = icmp slt i32 %1747, %.reg2mem91.0.lcssa.i2809
  br i1 %1748, label %._crit_edge2.i2844, label %HashMap_resize_.exit2915

HashMap_resize_.exit2915:                         ; preds = %._crit_edge2.i2844, %._crit_edge395.i2808
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %8)
  br label %HashMap_insert_keyK_valueV.exit1036

HashMap_insert_keyK_valueV.exit1036:              ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2744.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread3019, %561, %757, %HashMap_resize_.exit2915
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %109)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %111)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %113)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %114)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %115)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %116)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %117)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %118)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %119)
  store i1 true, ptr %.sroa.072.sroa.0, align 8
  %.sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.0. = load i8, ptr %.sroa.072.sroa.0, align 8
  %.sroa.072.0.insert.ext = zext i8 %.sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.sroa.0.0..sroa.072.0. to i160
  %1749 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.072.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %124)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %125)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %126)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %127)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %128)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %129)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %130)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %131)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %132)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %133)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %134)
  %1750 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1751 = load ptr, ptr %185, align 8
  %1752 = call i32 %1751({ ptr, i160 } %324)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1753 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1754 = load ptr, ptr %197, align 8
  %1755 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1754, 0
  %1756 = load ptr, ptr %198, align 8
  %1757 = insertvalue { ptr, ptr, ptr, i32 } %1755, ptr %1756, 1
  %1758 = load ptr, ptr %199, align 8
  %1759 = insertvalue { ptr, ptr, ptr, i32 } %1757, ptr %1758, 2
  %1760 = load i32, ptr %200, align 4
  %1761 = insertvalue { ptr, ptr, ptr, i32 } %1759, i32 %1760, 3
  %hash_coef_ptr.i.i10.i1255 = getelementptr i8, ptr %1754, i64 8
  %tbl_size_ptr.i.i11.i1256 = getelementptr i8, ptr %1754, i64 16
  %offset_tbl_ptr.i.i12.i1257 = getelementptr i8, ptr %1754, i64 40
  %hash_coef.i.i13.i1258 = load i64, ptr %hash_coef_ptr.i.i10.i1255, align 4
  %tbl_size.i.i14.i1259 = load i64, ptr %tbl_size_ptr.i.i11.i1256, align 4
  %offset_tbl.i.i15.i1260 = load ptr, ptr %offset_tbl_ptr.i.i12.i1257, align 8
  %product.i.i.i16.i1261 = mul i64 %hash_coef.i.i13.i1258, -5261542750394134544
  %shifted.i.i.i17.i1262 = lshr i64 %product.i.i.i16.i1261, 32
  %xored.i.i.i18.i1263 = xor i64 %shifted.i.i.i17.i1262, %product.i.i.i16.i1261
  %hash.i.i.i19.i1264 = and i64 %xored.i.i.i18.i1263, %tbl_size.i.i14.i1259
  %offset_ptr.i.i20.i1265 = getelementptr i32, ptr %offset_tbl.i.i15.i1260, i64 %hash.i.i.i19.i1264
  %offset.i.i21.i1266 = load i32, ptr %offset_ptr.i.i20.i1265, align 4
  %eq.i.i1267 = icmp eq i32 %1760, %offset.i.i21.i1266
  call void @llvm.assume(i1 %eq.i.i1267) #30
  %1762 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1763 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1754)
  %1764 = sext i32 %1760 to i64
  %1765 = getelementptr ptr, ptr %1754, i64 %1764
  %1766 = getelementptr i8, ptr %1765, i64 64
  %1767 = load ptr, ptr %1766, align 8
  %1768 = call ptr %1767({ ptr, ptr, ptr, i32 } %1761, ptr nonnull %2)
  %1769 = call i32 %1768({ ptr, ptr, ptr, i32 } %1761, { ptr, ptr, ptr, i32 } %1761, ptr nonnull %2)
  %1770 = add i32 %1769, -1
  %1771 = and i32 %1770, %1752
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1772 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1773 = load ptr, ptr %197, align 8
  %1774 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1773, 0
  %1775 = load ptr, ptr %198, align 8
  %1776 = insertvalue { ptr, ptr, ptr, i32 } %1774, ptr %1775, 1
  %1777 = load ptr, ptr %199, align 8
  %1778 = insertvalue { ptr, ptr, ptr, i32 } %1776, ptr %1777, 2
  %1779 = load i32, ptr %200, align 4
  %1780 = insertvalue { ptr, ptr, ptr, i32 } %1778, i32 %1779, 3
  %hash_coef_ptr.i.i162.i = getelementptr i8, ptr %1773, i64 8
  %tbl_size_ptr.i.i163.i = getelementptr i8, ptr %1773, i64 16
  %offset_tbl_ptr.i.i164.i = getelementptr i8, ptr %1773, i64 40
  %hash_coef.i.i165.i = load i64, ptr %hash_coef_ptr.i.i162.i, align 4
  %tbl_size.i.i166.i = load i64, ptr %tbl_size_ptr.i.i163.i, align 4
  %offset_tbl.i.i167.i = load ptr, ptr %offset_tbl_ptr.i.i164.i, align 8
  %product.i.i.i168.i = mul i64 %hash_coef.i.i165.i, -5261542750394134544
  %shifted.i.i.i169.i = lshr i64 %product.i.i.i168.i, 32
  %xored.i.i.i170.i = xor i64 %shifted.i.i.i169.i, %product.i.i.i168.i
  %hash.i.i.i171.i = and i64 %xored.i.i.i170.i, %tbl_size.i.i166.i
  %offset_ptr.i.i172.i = getelementptr i32, ptr %offset_tbl.i.i167.i, i64 %hash.i.i.i171.i
  %offset.i.i173.i = load i32, ptr %offset_ptr.i.i172.i, align 4
  %eq.i.i567 = icmp eq i32 %1779, %offset.i.i173.i
  call void @llvm.assume(i1 %eq.i.i567) #30
  store ptr @_parameterization_Ptri32, ptr %133, align 8
  %1781 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %133)
  %1782 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1773)
  %1783 = sext i32 %1779 to i64
  %1784 = getelementptr ptr, ptr %1773, i64 %1783
  %1785 = getelementptr i8, ptr %1784, i64 120
  %1786 = load ptr, ptr %1785, align 8
  store ptr @i32_typ, ptr %134, align 8
  %1787 = call ptr %1786({ ptr, ptr, ptr, i32 } %1780, ptr nonnull %134)
  %1788 = call { ptr, i160 } %1787({ ptr, ptr, ptr, i32 } %1780, { ptr, ptr, ptr, i32 } %1780, ptr nonnull %133, i32 %1771)
  %.fca.0.extract.i568 = extractvalue { ptr, i160 } %1788, 0
  %1789 = icmp ne ptr %.fca.0.extract.i568, @nil_typ
  %1790 = icmp ne ptr %.fca.0.extract.i568, null
  %.not149.i = and i1 %1789, %1790
  br i1 %.not149.i, label %1791, label %.critedge.i569

1791:                                             ; preds = %HashMap_insert_keyK_valueV.exit1036
  %.fca.1.extract.i576 = extractvalue { ptr, i160 } %1788, 1
  %.sroa.4520.8.extract.trunc.i = trunc i160 %.fca.1.extract.i576 to i64
  %1792 = inttoptr i64 %.sroa.4520.8.extract.trunc.i to ptr
  %.sroa.7522.8.extract.shift.i = lshr i160 %.fca.1.extract.i576, 64
  %.sroa.7522.8.extract.trunc.i = trunc i160 %.sroa.7522.8.extract.shift.i to i64
  %1793 = inttoptr i64 %.sroa.7522.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract.i568, i64 8
  %tbl_size_ptr.i.i177.i = getelementptr i8, ptr %.fca.0.extract.i568, i64 16
  %offset_tbl_ptr.i.i178.i = getelementptr i8, ptr %.fca.0.extract.i568, i64 40
  %hash_coef.i.i179.i = load i64, ptr %hash_coef_ptr.i.i176.i, align 4
  %tbl_size.i.i180.i = load i64, ptr %tbl_size_ptr.i.i177.i, align 4
  %offset_tbl.i.i181.i = load ptr, ptr %offset_tbl_ptr.i.i178.i, align 8
  %product.i.i.i182.i = mul i64 %hash_coef.i.i179.i, 4015701072841558310
  %shifted.i.i.i183.i = lshr i64 %product.i.i.i182.i, 32
  %xored.i.i.i184.i = xor i64 %shifted.i.i.i183.i, %product.i.i.i182.i
  %hash.i.i.i185.i = and i64 %xored.i.i.i184.i, %tbl_size.i.i180.i
  %offset_ptr.i.i186.i = getelementptr i32, ptr %offset_tbl.i.i181.i, i64 %hash.i.i.i185.i
  %offset.i.i187.i = load i32, ptr %offset_ptr.i.i186.i, align 4
  %1794 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i568, 0
  %1795 = insertvalue { ptr, ptr, ptr, i32 } %1794, ptr %1792, 1
  %1796 = insertvalue { ptr, ptr, ptr, i32 } %1795, ptr %1793, 2
  %1797 = insertvalue { ptr, ptr, ptr, i32 } %1796, i32 %offset.i.i187.i, 3
  %1798 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1799 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1800 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i568)
  %1801 = sext i32 %offset.i.i187.i to i64
  %1802 = getelementptr ptr, ptr %.fca.0.extract.i568, i64 %1801
  %1803 = getelementptr i8, ptr %1802, i64 64
  %1804 = load ptr, ptr %1803, align 8
  %1805 = call ptr %1804({ ptr, ptr, ptr, i32 } %1797, ptr nonnull %2)
  %1806 = call i32 %1805({ ptr, ptr, ptr, i32 } %1797, { ptr, ptr, ptr, i32 } %1797, ptr nonnull %2)
  %1807 = icmp eq i32 %1806, %1752
  %1808 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1809 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1810 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i568)
  %1811 = getelementptr i8, ptr %1802, i64 48
  %1812 = load ptr, ptr %1811, align 8
  %1813 = call ptr %1812({ ptr, ptr, ptr, i32 } %1797, ptr nonnull %2)
  %1814 = call { ptr, i160 } %1813({ ptr, ptr, ptr, i32 } %1797, { ptr, ptr, ptr, i32 } %1797, ptr nonnull %2)
  %1815 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1816 = load ptr, ptr %186, align 8
  %1817 = call i1 %1816({ ptr, i160 } %1814, { ptr, i160 } %324)
  %1818 = and i1 %1807, %1817
  br i1 %1818, label %1819, label %.critedge.i569

1819:                                             ; preds = %1791
  %1820 = load ptr, ptr %result.i130, align 8
  %1821 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1822 = load ptr, ptr %180, align 8
  %1823 = load ptr, ptr %1820, align 8
  %1824 = getelementptr i8, ptr %1823, i64 48
  %1825 = load ptr, ptr %1824, align 8
  %1826 = call { i64, i64 } %1825(ptr nonnull %1820)
  %1827 = extractvalue { i64, i64 } %1826, 0
  %1828 = extractvalue { i64, i64 } %1826, 1
  %1829 = urem i64 20, %1828
  %1830 = icmp eq i64 %1829, 0
  %1831 = sub i64 %1828, %1829
  %1832 = select i1 %1830, i64 0, i64 %1831
  %1833 = add i64 %1827, 20
  %1834 = add i64 %1833, %1832
  %1835 = load ptr, ptr %1822, align 8
  %1836 = getelementptr i8, ptr %1835, i64 48
  %1837 = load ptr, ptr %1836, align 8
  %1838 = call { i64, i64 } %1837(ptr nonnull %1822)
  %1839 = extractvalue { i64, i64 } %1838, 0
  %1840 = extractvalue { i64, i64 } %1838, 1
  %1841 = call i64 @llvm.umax.i64(i64 %1828, i64 %1840)
  %1842 = call i64 @llvm.umax.i64(i64 %1841, i64 8)
  %1843 = urem i64 %1834, %1840
  %1844 = icmp eq i64 %1843, 0
  %1845 = sub i64 %1840, %1843
  %1846 = select i1 %1844, i64 0, i64 %1845
  %1847 = add i64 %1839, %1834
  %1848 = add i64 %1847, %1846
  %1849 = urem i64 %1848, %1842
  %1850 = icmp eq i64 %1849, 0
  %1851 = sub i64 %1842, %1849
  %1852 = select i1 %1850, i64 0, i64 %1851
  %1853 = add i64 %1852, %1848
  %result.i.i577 = call noalias ptr @bump_malloc_inner(i64 noundef %1853, ptr nonnull @current_ptr) #29
  store ptr %1820, ptr %result.i.i577, align 8
  %1854 = getelementptr i8, ptr %result.i.i577, i64 8
  store ptr %1822, ptr %1854, align 8
  %1855 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i577)
  store ptr @Entry, ptr %124, align 8
  store ptr %result.i.i577, ptr %233, align 8
  store i32 9, ptr %234, align 8
  %1856 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %124)
  %1857 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1858 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1859 = load ptr, ptr %1820, align 8
  %1860 = getelementptr i8, ptr %1859, i64 48
  %1861 = load ptr, ptr %1860, align 8
  %1862 = call { i64, i64 } %1861(ptr nonnull %1820)
  %1863 = extractvalue { i64, i64 } %1862, 1
  %1864 = urem i64 20, %1863
  %1865 = icmp eq i64 %1864, 0
  %reass.sub3774 = sub i64 %1863, %1864
  %1866 = add i64 %reass.sub3774, 20
  %1867 = select i1 %1865, i64 20, i64 %1866
  %1868 = getelementptr i8, ptr %result.i.i577, i64 %1867
  %1869 = load ptr, ptr %result.i.i577, align 8
  %1870 = load ptr, ptr %1869, align 8
  %1871 = getelementptr i8, ptr %1870, i64 64
  %1872 = load ptr, ptr %1871, align 8
  call void %1872({ ptr, i160 } %324, ptr nonnull %1869, ptr %1868)
  %1873 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1874 = load ptr, ptr %result.i.i577, align 8
  %1875 = load ptr, ptr %1874, align 8
  %1876 = getelementptr i8, ptr %1875, i64 48
  %1877 = load ptr, ptr %1876, align 8
  %1878 = call { i64, i64 } %1877(ptr nonnull %1874)
  %1879 = extractvalue { i64, i64 } %1878, 0
  %1880 = extractvalue { i64, i64 } %1878, 1
  %1881 = urem i64 20, %1880
  %1882 = icmp eq i64 %1881, 0
  %1883 = sub i64 %1880, %1881
  %1884 = select i1 %1882, i64 0, i64 %1883
  %1885 = add i64 %1879, 20
  %1886 = add i64 %1885, %1884
  %1887 = load ptr, ptr %1854, align 8
  %1888 = load ptr, ptr %1887, align 8
  %1889 = getelementptr i8, ptr %1888, i64 48
  %1890 = load ptr, ptr %1889, align 8
  %1891 = call { i64, i64 } %1890(ptr nonnull %1887)
  %1892 = extractvalue { i64, i64 } %1891, 1
  %1893 = urem i64 %1886, %1892
  %1894 = icmp eq i64 %1893, 0
  %1895 = sub i64 %1892, %1893
  %1896 = select i1 %1894, i64 0, i64 %1895
  %1897 = getelementptr i8, ptr %result.i.i577, i64 %1886
  %1898 = getelementptr i8, ptr %1897, i64 %1896
  %1899 = load ptr, ptr %1854, align 8
  %1900 = load ptr, ptr %1899, align 8
  %1901 = getelementptr i8, ptr %1900, i64 64
  %1902 = load ptr, ptr %1901, align 8
  call void %1902({ ptr, i160 } %1749, ptr nonnull %1899, ptr %1898)
  %1903 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1904 = getelementptr i8, ptr %result.i.i577, i64 16
  store i32 %1752, ptr %1904, align 4
  %1905 = load ptr, ptr %235, align 8
  %1906 = ptrtoint ptr %result.i.i577 to i64
  %1907 = ptrtoint ptr %1905 to i64
  %.sroa.2127.0.insert.ext.i = zext i64 %1907 to i160
  %.sroa.2127.0.insert.shift.i = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i, 64
  %.sroa.0126.0.insert.ext.i = zext i64 %1906 to i160
  %.sroa.2127.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.shift.i, %.sroa.0126.0.insert.ext.i
  %.sroa.0126.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.insert.i, 3062541302288446171170371466885913903104
  %1908 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i, 1
  %1909 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1910 = load ptr, ptr %197, align 8
  %1911 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1910, 0
  %1912 = load ptr, ptr %198, align 8
  %1913 = insertvalue { ptr, ptr, ptr, i32 } %1911, ptr %1912, 1
  %1914 = load ptr, ptr %199, align 8
  %1915 = insertvalue { ptr, ptr, ptr, i32 } %1913, ptr %1914, 2
  %1916 = load i32, ptr %200, align 4
  %1917 = insertvalue { ptr, ptr, ptr, i32 } %1915, i32 %1916, 3
  %hash_coef_ptr.i.i204.i = getelementptr i8, ptr %1910, i64 8
  %tbl_size_ptr.i.i205.i = getelementptr i8, ptr %1910, i64 16
  %offset_tbl_ptr.i.i206.i = getelementptr i8, ptr %1910, i64 40
  %hash_coef.i.i207.i = load i64, ptr %hash_coef_ptr.i.i204.i, align 4
  %tbl_size.i.i208.i = load i64, ptr %tbl_size_ptr.i.i205.i, align 4
  %offset_tbl.i.i209.i = load ptr, ptr %offset_tbl_ptr.i.i206.i, align 8
  %product.i.i.i210.i = mul i64 %hash_coef.i.i207.i, -5261542750394134544
  %shifted.i.i.i211.i = lshr i64 %product.i.i.i210.i, 32
  %xored.i.i.i212.i = xor i64 %shifted.i.i.i211.i, %product.i.i.i210.i
  %hash.i.i.i213.i = and i64 %xored.i.i.i212.i, %tbl_size.i.i208.i
  %offset_ptr.i.i214.i = getelementptr i32, ptr %offset_tbl.i.i209.i, i64 %hash.i.i.i213.i
  %offset.i.i215.i = load i32, ptr %offset_ptr.i.i214.i, align 4
  %eq.i218.i = icmp eq i32 %1916, %offset.i.i215.i
  call void @llvm.assume(i1 %eq.i218.i) #30
  %1918 = load ptr, ptr %result.i130, align 8
  %1919 = load ptr, ptr %180, align 8
  %result.i219.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1920 = getelementptr i8, ptr %result.i219.i, i64 16
  store ptr %1919, ptr %1920, align 8
  %1921 = getelementptr i8, ptr %result.i219.i, i64 8
  store ptr %1918, ptr %1921, align 8
  %1922 = getelementptr i8, ptr %result.i219.i, i64 24
  store ptr null, ptr %1922, align 8
  %1923 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i)
  store ptr @Entry, ptr %result.i219.i, align 8
  store ptr @_parameterization_Ptri32, ptr %125, align 8
  store ptr %result.i219.i, ptr %236, align 8
  %1924 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %125)
  %1925 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1910)
  %1926 = sext i32 %1916 to i64
  %1927 = getelementptr ptr, ptr %1910, i64 %1926
  %1928 = getelementptr i8, ptr %1927, i64 128
  %1929 = load ptr, ptr %1928, align 8
  store ptr @i32_typ, ptr %126, align 8
  store ptr @Entry, ptr %237, align 8
  %1930 = call ptr %1929({ ptr, ptr, ptr, i32 } %1917, ptr nonnull %126)
  call void %1930({ ptr, ptr, ptr, i32 } %1917, { ptr, ptr, ptr, i32 } %1917, ptr nonnull %125, i32 %1771, { ptr, i160 } %1908)
  br label %HashMap_insert_keyK_valueV.exit

.critedge.i569:                                   ; preds = %1791, %HashMap_insert_keyK_valueV.exit1036
  %1931 = add i32 %1752, 2127912214
  %1932 = shl i32 %1752, 12
  %1933 = add i32 %1931, %1932
  %1934 = ashr i32 %1933, 19
  %1935 = xor i32 %1933, %1934
  %1936 = xor i32 %1935, -949894596
  %1937 = add i32 %1936, 374761393
  %1938 = shl i32 %1936, 5
  %1939 = add i32 %1937, %1938
  %1940 = add i32 %1939, -744332180
  %1941 = shl i32 %1939, 9
  %1942 = xor i32 %1940, %1941
  %1943 = add i32 %1942, -42973499
  %1944 = shl i32 %1942, 3
  %1945 = add i32 %1943, %1944
  %1946 = ashr i32 %1945, 16
  %1947 = xor i32 %1945, %1946
  %1948 = xor i32 %1947, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1949 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1950 = load ptr, ptr %214, align 8
  %1951 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1950, 0
  %1952 = load ptr, ptr %215, align 8
  %1953 = insertvalue { ptr, ptr, ptr, i32 } %1951, ptr %1952, 1
  %1954 = load ptr, ptr %216, align 8
  %1955 = insertvalue { ptr, ptr, ptr, i32 } %1953, ptr %1954, 2
  %1956 = load i32, ptr %217, align 4
  %1957 = insertvalue { ptr, ptr, ptr, i32 } %1955, i32 %1956, 3
  %hash_coef_ptr.i.i10.i1285 = getelementptr i8, ptr %1950, i64 8
  %tbl_size_ptr.i.i11.i1286 = getelementptr i8, ptr %1950, i64 16
  %offset_tbl_ptr.i.i12.i1287 = getelementptr i8, ptr %1950, i64 40
  %hash_coef.i.i13.i1288 = load i64, ptr %hash_coef_ptr.i.i10.i1285, align 4
  %tbl_size.i.i14.i1289 = load i64, ptr %tbl_size_ptr.i.i11.i1286, align 4
  %offset_tbl.i.i15.i1290 = load ptr, ptr %offset_tbl_ptr.i.i12.i1287, align 8
  %product.i.i.i16.i1291 = mul i64 %hash_coef.i.i13.i1288, -5261542750394134544
  %shifted.i.i.i17.i1292 = lshr i64 %product.i.i.i16.i1291, 32
  %xored.i.i.i18.i1293 = xor i64 %shifted.i.i.i17.i1292, %product.i.i.i16.i1291
  %hash.i.i.i19.i1294 = and i64 %xored.i.i.i18.i1293, %tbl_size.i.i14.i1289
  %offset_ptr.i.i20.i1295 = getelementptr i32, ptr %offset_tbl.i.i15.i1290, i64 %hash.i.i.i19.i1294
  %offset.i.i21.i1296 = load i32, ptr %offset_ptr.i.i20.i1295, align 4
  %eq.i.i1297 = icmp eq i32 %1956, %offset.i.i21.i1296
  call void @llvm.assume(i1 %eq.i.i1297) #30
  %1958 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1959 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1950)
  %1960 = sext i32 %1956 to i64
  %1961 = getelementptr ptr, ptr %1950, i64 %1960
  %1962 = getelementptr i8, ptr %1961, i64 64
  %1963 = load ptr, ptr %1962, align 8
  %1964 = call ptr %1963({ ptr, ptr, ptr, i32 } %1957, ptr nonnull %2)
  %1965 = call i32 %1964({ ptr, ptr, ptr, i32 } %1957, { ptr, ptr, ptr, i32 } %1957, ptr nonnull %2)
  %1966 = add i32 %1965, -1
  %1967 = and i32 %1966, %1948
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1968 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1969 = load ptr, ptr %214, align 8
  %1970 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1969, 0
  %1971 = load ptr, ptr %215, align 8
  %1972 = insertvalue { ptr, ptr, ptr, i32 } %1970, ptr %1971, 1
  %1973 = load ptr, ptr %216, align 8
  %1974 = insertvalue { ptr, ptr, ptr, i32 } %1972, ptr %1973, 2
  %1975 = load i32, ptr %217, align 4
  %1976 = insertvalue { ptr, ptr, ptr, i32 } %1974, i32 %1975, 3
  %hash_coef_ptr.i.i221.i = getelementptr i8, ptr %1969, i64 8
  %tbl_size_ptr.i.i222.i = getelementptr i8, ptr %1969, i64 16
  %offset_tbl_ptr.i.i223.i = getelementptr i8, ptr %1969, i64 40
  %hash_coef.i.i224.i = load i64, ptr %hash_coef_ptr.i.i221.i, align 4
  %tbl_size.i.i225.i = load i64, ptr %tbl_size_ptr.i.i222.i, align 4
  %offset_tbl.i.i226.i = load ptr, ptr %offset_tbl_ptr.i.i223.i, align 8
  %product.i.i.i227.i = mul i64 %hash_coef.i.i224.i, -5261542750394134544
  %shifted.i.i.i228.i = lshr i64 %product.i.i.i227.i, 32
  %xored.i.i.i229.i = xor i64 %shifted.i.i.i228.i, %product.i.i.i227.i
  %hash.i.i.i230.i = and i64 %xored.i.i.i229.i, %tbl_size.i.i225.i
  %offset_ptr.i.i231.i = getelementptr i32, ptr %offset_tbl.i.i226.i, i64 %hash.i.i.i230.i
  %offset.i.i232.i = load i32, ptr %offset_ptr.i.i231.i, align 4
  %eq.i235.i = icmp eq i32 %1975, %offset.i.i232.i
  call void @llvm.assume(i1 %eq.i235.i) #30
  store ptr @_parameterization_Ptri32, ptr %127, align 8
  %1977 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %127)
  %1978 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1969)
  %1979 = sext i32 %1975 to i64
  %1980 = getelementptr ptr, ptr %1969, i64 %1979
  %1981 = getelementptr i8, ptr %1980, i64 120
  %1982 = load ptr, ptr %1981, align 8
  store ptr @i32_typ, ptr %128, align 8
  %1983 = call ptr %1982({ ptr, ptr, ptr, i32 } %1976, ptr nonnull %128)
  %1984 = call { ptr, i160 } %1983({ ptr, ptr, ptr, i32 } %1976, { ptr, ptr, ptr, i32 } %1976, ptr nonnull %127, i32 %1967)
  %.fca.0.extract102.i = extractvalue { ptr, i160 } %1984, 0
  %1985 = icmp ne ptr %.fca.0.extract102.i, @nil_typ
  %1986 = icmp ne ptr %.fca.0.extract102.i, null
  %.not151.i = and i1 %1985, %1986
  br i1 %.not151.i, label %1987, label %.critedge158.i

1987:                                             ; preds = %.critedge.i569
  %.fca.1.extract104.i = extractvalue { ptr, i160 } %1984, 1
  %.sroa.4.8.extract.trunc.i = trunc i160 %.fca.1.extract104.i to i64
  %1988 = inttoptr i64 %.sroa.4.8.extract.trunc.i to ptr
  %.sroa.7508.8.extract.shift.i = lshr i160 %.fca.1.extract104.i, 64
  %.sroa.7508.8.extract.trunc.i = trunc i160 %.sroa.7508.8.extract.shift.i to i64
  %1989 = inttoptr i64 %.sroa.7508.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i237.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 8
  %tbl_size_ptr.i.i238.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 16
  %offset_tbl_ptr.i.i239.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 40
  %hash_coef.i.i240.i = load i64, ptr %hash_coef_ptr.i.i237.i, align 4
  %tbl_size.i.i241.i = load i64, ptr %tbl_size_ptr.i.i238.i, align 4
  %offset_tbl.i.i242.i = load ptr, ptr %offset_tbl_ptr.i.i239.i, align 8
  %product.i.i.i243.i = mul i64 %hash_coef.i.i240.i, 4015701072841558310
  %shifted.i.i.i244.i = lshr i64 %product.i.i.i243.i, 32
  %xored.i.i.i245.i = xor i64 %shifted.i.i.i244.i, %product.i.i.i243.i
  %hash.i.i.i246.i = and i64 %xored.i.i.i245.i, %tbl_size.i.i241.i
  %offset_ptr.i.i247.i = getelementptr i32, ptr %offset_tbl.i.i242.i, i64 %hash.i.i.i246.i
  %offset.i.i248.i = load i32, ptr %offset_ptr.i.i247.i, align 4
  %1990 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i, 0
  %1991 = insertvalue { ptr, ptr, ptr, i32 } %1990, ptr %1988, 1
  %1992 = insertvalue { ptr, ptr, ptr, i32 } %1991, ptr %1989, 2
  %1993 = insertvalue { ptr, ptr, ptr, i32 } %1992, i32 %offset.i.i248.i, 3
  %1994 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1995 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1996 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %1997 = sext i32 %offset.i.i248.i to i64
  %1998 = getelementptr ptr, ptr %.fca.0.extract102.i, i64 %1997
  %1999 = getelementptr i8, ptr %1998, i64 64
  %2000 = load ptr, ptr %1999, align 8
  %2001 = call ptr %2000({ ptr, ptr, ptr, i32 } %1993, ptr nonnull %2)
  %2002 = call i32 %2001({ ptr, ptr, ptr, i32 } %1993, { ptr, ptr, ptr, i32 } %1993, ptr nonnull %2)
  %2003 = icmp eq i32 %2002, %1752
  %2004 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2005 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2006 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %2007 = getelementptr i8, ptr %1998, i64 48
  %2008 = load ptr, ptr %2007, align 8
  %2009 = call ptr %2008({ ptr, ptr, ptr, i32 } %1993, ptr nonnull %2)
  %2010 = call { ptr, i160 } %2009({ ptr, ptr, ptr, i32 } %1993, { ptr, ptr, ptr, i32 } %1993, ptr nonnull %2)
  %2011 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2012 = load ptr, ptr %186, align 8
  %2013 = call i1 %2012({ ptr, i160 } %2010, { ptr, i160 } %324)
  %2014 = and i1 %2003, %2013
  br i1 %2014, label %2015, label %.critedge158.i

2015:                                             ; preds = %1987
  %2016 = load ptr, ptr %result.i130, align 8
  %2017 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2018 = load ptr, ptr %180, align 8
  %2019 = load ptr, ptr %2016, align 8
  %2020 = getelementptr i8, ptr %2019, i64 48
  %2021 = load ptr, ptr %2020, align 8
  %2022 = call { i64, i64 } %2021(ptr nonnull %2016)
  %2023 = extractvalue { i64, i64 } %2022, 0
  %2024 = extractvalue { i64, i64 } %2022, 1
  %2025 = urem i64 20, %2024
  %2026 = icmp eq i64 %2025, 0
  %2027 = sub i64 %2024, %2025
  %2028 = select i1 %2026, i64 0, i64 %2027
  %2029 = add i64 %2023, 20
  %2030 = add i64 %2029, %2028
  %2031 = load ptr, ptr %2018, align 8
  %2032 = getelementptr i8, ptr %2031, i64 48
  %2033 = load ptr, ptr %2032, align 8
  %2034 = call { i64, i64 } %2033(ptr nonnull %2018)
  %2035 = extractvalue { i64, i64 } %2034, 0
  %2036 = extractvalue { i64, i64 } %2034, 1
  %2037 = call i64 @llvm.umax.i64(i64 %2024, i64 %2036)
  %2038 = call i64 @llvm.umax.i64(i64 %2037, i64 8)
  %2039 = urem i64 %2030, %2036
  %2040 = icmp eq i64 %2039, 0
  %2041 = sub i64 %2036, %2039
  %2042 = select i1 %2040, i64 0, i64 %2041
  %2043 = add i64 %2035, %2030
  %2044 = add i64 %2043, %2042
  %2045 = urem i64 %2044, %2038
  %2046 = icmp eq i64 %2045, 0
  %2047 = sub i64 %2038, %2045
  %2048 = select i1 %2046, i64 0, i64 %2047
  %2049 = add i64 %2048, %2044
  %result.i250.i = call noalias ptr @bump_malloc_inner(i64 noundef %2049, ptr nonnull @current_ptr) #29
  store ptr %2016, ptr %result.i250.i, align 8
  %2050 = getelementptr i8, ptr %result.i250.i, i64 8
  store ptr %2018, ptr %2050, align 8
  %2051 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i)
  store ptr @Entry, ptr %129, align 8
  store ptr %result.i250.i, ptr %228, align 8
  store i32 9, ptr %229, align 8
  %2052 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %129)
  %2053 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2054 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2055 = load ptr, ptr %2016, align 8
  %2056 = getelementptr i8, ptr %2055, i64 48
  %2057 = load ptr, ptr %2056, align 8
  %2058 = call { i64, i64 } %2057(ptr nonnull %2016)
  %2059 = extractvalue { i64, i64 } %2058, 1
  %2060 = urem i64 20, %2059
  %2061 = icmp eq i64 %2060, 0
  %reass.sub3773 = sub i64 %2059, %2060
  %2062 = add i64 %reass.sub3773, 20
  %2063 = select i1 %2061, i64 20, i64 %2062
  %2064 = getelementptr i8, ptr %result.i250.i, i64 %2063
  %2065 = load ptr, ptr %result.i250.i, align 8
  %2066 = load ptr, ptr %2065, align 8
  %2067 = getelementptr i8, ptr %2066, i64 64
  %2068 = load ptr, ptr %2067, align 8
  call void %2068({ ptr, i160 } %324, ptr nonnull %2065, ptr %2064)
  %2069 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2070 = load ptr, ptr %result.i250.i, align 8
  %2071 = load ptr, ptr %2070, align 8
  %2072 = getelementptr i8, ptr %2071, i64 48
  %2073 = load ptr, ptr %2072, align 8
  %2074 = call { i64, i64 } %2073(ptr nonnull %2070)
  %2075 = extractvalue { i64, i64 } %2074, 0
  %2076 = extractvalue { i64, i64 } %2074, 1
  %2077 = urem i64 20, %2076
  %2078 = icmp eq i64 %2077, 0
  %2079 = sub i64 %2076, %2077
  %2080 = select i1 %2078, i64 0, i64 %2079
  %2081 = add i64 %2075, 20
  %2082 = add i64 %2081, %2080
  %2083 = load ptr, ptr %2050, align 8
  %2084 = load ptr, ptr %2083, align 8
  %2085 = getelementptr i8, ptr %2084, i64 48
  %2086 = load ptr, ptr %2085, align 8
  %2087 = call { i64, i64 } %2086(ptr nonnull %2083)
  %2088 = extractvalue { i64, i64 } %2087, 1
  %2089 = urem i64 %2082, %2088
  %2090 = icmp eq i64 %2089, 0
  %2091 = sub i64 %2088, %2089
  %2092 = select i1 %2090, i64 0, i64 %2091
  %2093 = getelementptr i8, ptr %result.i250.i, i64 %2082
  %2094 = getelementptr i8, ptr %2093, i64 %2092
  %2095 = load ptr, ptr %2050, align 8
  %2096 = load ptr, ptr %2095, align 8
  %2097 = getelementptr i8, ptr %2096, i64 64
  %2098 = load ptr, ptr %2097, align 8
  call void %2098({ ptr, i160 } %1749, ptr nonnull %2095, ptr %2094)
  %2099 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2100 = getelementptr i8, ptr %result.i250.i, i64 16
  store i32 %1752, ptr %2100, align 4
  %2101 = load ptr, ptr %230, align 8
  %2102 = ptrtoint ptr %result.i250.i to i64
  %2103 = ptrtoint ptr %2101 to i64
  %.sroa.282.0.insert.ext.i = zext i64 %2103 to i160
  %.sroa.282.0.insert.shift.i = shl nuw nsw i160 %.sroa.282.0.insert.ext.i, 64
  %.sroa.081.0.insert.ext.i = zext i64 %2102 to i160
  %.sroa.282.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.shift.i, %.sroa.081.0.insert.ext.i
  %.sroa.081.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.insert.i, 3062541302288446171170371466885913903104
  %2104 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i, 1
  %2105 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2106 = load ptr, ptr %214, align 8
  %2107 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2106, 0
  %2108 = load ptr, ptr %215, align 8
  %2109 = insertvalue { ptr, ptr, ptr, i32 } %2107, ptr %2108, 1
  %2110 = load ptr, ptr %216, align 8
  %2111 = insertvalue { ptr, ptr, ptr, i32 } %2109, ptr %2110, 2
  %2112 = load i32, ptr %217, align 4
  %2113 = insertvalue { ptr, ptr, ptr, i32 } %2111, i32 %2112, 3
  %hash_coef_ptr.i.i266.i = getelementptr i8, ptr %2106, i64 8
  %tbl_size_ptr.i.i267.i = getelementptr i8, ptr %2106, i64 16
  %offset_tbl_ptr.i.i268.i = getelementptr i8, ptr %2106, i64 40
  %hash_coef.i.i269.i = load i64, ptr %hash_coef_ptr.i.i266.i, align 4
  %tbl_size.i.i270.i = load i64, ptr %tbl_size_ptr.i.i267.i, align 4
  %offset_tbl.i.i271.i = load ptr, ptr %offset_tbl_ptr.i.i268.i, align 8
  %product.i.i.i272.i = mul i64 %hash_coef.i.i269.i, -5261542750394134544
  %shifted.i.i.i273.i = lshr i64 %product.i.i.i272.i, 32
  %xored.i.i.i274.i = xor i64 %shifted.i.i.i273.i, %product.i.i.i272.i
  %hash.i.i.i275.i = and i64 %xored.i.i.i274.i, %tbl_size.i.i270.i
  %offset_ptr.i.i276.i = getelementptr i32, ptr %offset_tbl.i.i271.i, i64 %hash.i.i.i275.i
  %offset.i.i277.i = load i32, ptr %offset_ptr.i.i276.i, align 4
  %eq.i280.i = icmp eq i32 %2112, %offset.i.i277.i
  call void @llvm.assume(i1 %eq.i280.i) #30
  %2114 = load ptr, ptr %result.i130, align 8
  %2115 = load ptr, ptr %180, align 8
  %result.i281.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2116 = getelementptr i8, ptr %result.i281.i, i64 16
  store ptr %2115, ptr %2116, align 8
  %2117 = getelementptr i8, ptr %result.i281.i, i64 8
  store ptr %2114, ptr %2117, align 8
  %2118 = getelementptr i8, ptr %result.i281.i, i64 24
  store ptr null, ptr %2118, align 8
  %2119 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i)
  store ptr @Entry, ptr %result.i281.i, align 8
  store ptr @_parameterization_Ptri32, ptr %130, align 8
  store ptr %result.i281.i, ptr %231, align 8
  %2120 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %130)
  %2121 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2106)
  %2122 = sext i32 %2112 to i64
  %2123 = getelementptr ptr, ptr %2106, i64 %2122
  %2124 = getelementptr i8, ptr %2123, i64 128
  %2125 = load ptr, ptr %2124, align 8
  store ptr @i32_typ, ptr %131, align 8
  store ptr @Entry, ptr %232, align 8
  %2126 = call ptr %2125({ ptr, ptr, ptr, i32 } %2113, ptr nonnull %131)
  call void %2126({ ptr, ptr, ptr, i32 } %2113, { ptr, ptr, ptr, i32 } %2113, ptr nonnull %130, i32 %1967, { ptr, i160 } %2104)
  br label %HashMap_insert_keyK_valueV.exit

.critedge158.i:                                   ; preds = %1987, %.critedge.i569
  %2127 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2128 = load ptr, ptr %197, align 8
  %2129 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2128, 0
  %2130 = load ptr, ptr %198, align 8
  %2131 = insertvalue { ptr, ptr, ptr, i32 } %2129, ptr %2130, 1
  %2132 = load ptr, ptr %199, align 8
  %2133 = insertvalue { ptr, ptr, ptr, i32 } %2131, ptr %2132, 2
  %2134 = load i32, ptr %200, align 4
  %2135 = insertvalue { ptr, ptr, ptr, i32 } %2133, i32 %2134, 3
  %hash_coef_ptr.i.i283.i = getelementptr i8, ptr %2128, i64 8
  %tbl_size_ptr.i.i284.i = getelementptr i8, ptr %2128, i64 16
  %offset_tbl_ptr.i.i285.i = getelementptr i8, ptr %2128, i64 40
  %hash_coef.i.i286.i = load i64, ptr %hash_coef_ptr.i.i283.i, align 4
  %tbl_size.i.i287.i = load i64, ptr %tbl_size_ptr.i.i284.i, align 4
  %offset_tbl.i.i288.i = load ptr, ptr %offset_tbl_ptr.i.i285.i, align 8
  %product.i.i.i289.i = mul i64 %hash_coef.i.i286.i, -5261542750394134544
  %shifted.i.i.i290.i = lshr i64 %product.i.i.i289.i, 32
  %xored.i.i.i291.i = xor i64 %shifted.i.i.i290.i, %product.i.i.i289.i
  %hash.i.i.i292.i = and i64 %xored.i.i.i291.i, %tbl_size.i.i287.i
  %offset_ptr.i.i293.i = getelementptr i32, ptr %offset_tbl.i.i288.i, i64 %hash.i.i.i292.i
  %offset.i.i294.i = load i32, ptr %offset_ptr.i.i293.i, align 4
  %eq.i297.i = icmp eq i32 %2134, %offset.i.i294.i
  call void @llvm.assume(i1 %eq.i297.i) #30
  %2136 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2137 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2128)
  %2138 = sext i32 %2134 to i64
  %2139 = getelementptr ptr, ptr %2128, i64 %2138
  %2140 = getelementptr i8, ptr %2139, i64 64
  %2141 = load ptr, ptr %2140, align 8
  %2142 = call ptr %2141({ ptr, ptr, ptr, i32 } %2135, ptr nonnull %2)
  %2143 = call i32 %2142({ ptr, ptr, ptr, i32 } %2135, { ptr, ptr, ptr, i32 } %2135, ptr nonnull %2)
  %2144 = load i32, ptr %218, align 4
  %.not.i = icmp slt i32 %2144, %2143
  br i1 %.not.i, label %._crit_edge.i, label %2145

2145:                                             ; preds = %.critedge158.i
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %99)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %100)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %101)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %102)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %103)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %104)
  %2146 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2147 = load ptr, ptr %197, align 8
  %2148 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2147, 0
  %2149 = load ptr, ptr %198, align 8
  %2150 = insertvalue { ptr, ptr, ptr, i32 } %2148, ptr %2149, 1
  %2151 = load ptr, ptr %199, align 8
  %2152 = insertvalue { ptr, ptr, ptr, i32 } %2150, ptr %2151, 2
  %2153 = load i32, ptr %200, align 4
  %2154 = insertvalue { ptr, ptr, ptr, i32 } %2152, i32 %2153, 3
  %hash_coef_ptr.i.i64.i = getelementptr i8, ptr %2147, i64 8
  %tbl_size_ptr.i.i65.i = getelementptr i8, ptr %2147, i64 16
  %offset_tbl_ptr.i.i66.i = getelementptr i8, ptr %2147, i64 40
  %hash_coef.i.i67.i = load i64, ptr %hash_coef_ptr.i.i64.i, align 4
  %tbl_size.i.i68.i = load i64, ptr %tbl_size_ptr.i.i65.i, align 4
  %offset_tbl.i.i69.i = load ptr, ptr %offset_tbl_ptr.i.i66.i, align 8
  %product.i.i.i70.i = mul i64 %hash_coef.i.i67.i, -5261542750394134544
  %shifted.i.i.i71.i = lshr i64 %product.i.i.i70.i, 32
  %xored.i.i.i72.i = xor i64 %shifted.i.i.i71.i, %product.i.i.i70.i
  %hash.i.i.i73.i = and i64 %xored.i.i.i72.i, %tbl_size.i.i68.i
  %offset_ptr.i.i74.i = getelementptr i32, ptr %offset_tbl.i.i69.i, i64 %hash.i.i.i73.i
  %offset.i.i75.i = load i32, ptr %offset_ptr.i.i74.i, align 4
  %eq.i.i1311 = icmp eq i32 %2153, %offset.i.i75.i
  call void @llvm.assume(i1 %eq.i.i1311) #30
  %2155 = load ptr, ptr %214, align 8
  %2156 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2155, 0
  %2157 = load ptr, ptr %215, align 8
  %2158 = insertvalue { ptr, ptr, ptr, i32 } %2156, ptr %2157, 1
  %2159 = load ptr, ptr %216, align 8
  %2160 = insertvalue { ptr, ptr, ptr, i32 } %2158, ptr %2159, 2
  %2161 = load i32, ptr %217, align 4
  %2162 = insertvalue { ptr, ptr, ptr, i32 } %2160, i32 %2161, 3
  %hash_coef_ptr.i.i92.i = getelementptr i8, ptr %2155, i64 8
  %tbl_size_ptr.i.i93.i = getelementptr i8, ptr %2155, i64 16
  %offset_tbl_ptr.i.i94.i = getelementptr i8, ptr %2155, i64 40
  %hash_coef.i.i95.i = load i64, ptr %hash_coef_ptr.i.i92.i, align 4
  %tbl_size.i.i96.i = load i64, ptr %tbl_size_ptr.i.i93.i, align 4
  %offset_tbl.i.i97.i = load ptr, ptr %offset_tbl_ptr.i.i94.i, align 8
  %product.i.i.i98.i = mul i64 %hash_coef.i.i95.i, -5261542750394134544
  %shifted.i.i.i99.i = lshr i64 %product.i.i.i98.i, 32
  %xored.i.i.i100.i = xor i64 %shifted.i.i.i99.i, %product.i.i.i98.i
  %hash.i.i.i101.i = and i64 %xored.i.i.i100.i, %tbl_size.i.i96.i
  %offset_ptr.i.i102.i = getelementptr i32, ptr %offset_tbl.i.i97.i, i64 %hash.i.i.i101.i
  %offset.i.i103.i = load i32, ptr %offset_ptr.i.i102.i, align 4
  %eq.i106.i = icmp eq i32 %2161, %offset.i.i103.i
  call void @llvm.assume(i1 %eq.i106.i) #30
  %2163 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2164 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2147)
  %2165 = sext i32 %2153 to i64
  %2166 = getelementptr ptr, ptr %2147, i64 %2165
  %2167 = getelementptr i8, ptr %2166, i64 64
  %2168 = load ptr, ptr %2167, align 8
  %2169 = call ptr %2168({ ptr, ptr, ptr, i32 } %2154, ptr nonnull %2)
  %2170 = call i32 %2169({ ptr, ptr, ptr, i32 } %2154, { ptr, ptr, ptr, i32 } %2154, ptr nonnull %2)
  %2171 = shl i32 %2170, 1
  %2172 = load i32, ptr %218, align 4
  %2173 = load ptr, ptr %result.i130, align 8
  %2174 = load ptr, ptr %180, align 8
  %2175 = sext i32 %2172 to i64
  %2176 = shl nsw i64 %2175, 5
  %result.i.i.i1317 = call noalias ptr @bump_malloc_inner(i64 noundef %2176, ptr nonnull @current_ptr) #29
  %2177 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2178 = icmp sgt i32 %2170, 0
  br i1 %2178, label %.lr.ph434.i, label %._crit_edge395.i

.lr.ph434.i:                                      ; preds = %2145
  %invariant.gep.i = getelementptr i8, ptr %2147, i64 120
  %2179 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i = getelementptr ptr, ptr %invariant.gep.i, i64 %2165
  br label %2180

2180:                                             ; preds = %2202, %.lr.ph434.i
  %.reg2mem105.0432.i = phi i32 [ 0, %.lr.ph434.i ], [ %.reg2mem101.0.i, %2202 ]
  %.reg2mem103.0431.i = phi i32 [ 0, %.lr.ph434.i ], [ %2203, %2202 ]
  store ptr @_parameterization_Ptri32, ptr %99, align 8
  %2181 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %99)
  %2182 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2147)
  %2183 = load ptr, ptr %gep.i, align 8
  store ptr @i32_typ, ptr %100, align 8
  %2184 = call ptr %2183({ ptr, ptr, ptr, i32 } %2154, ptr nonnull %100)
  %2185 = call { ptr, i160 } %2184({ ptr, ptr, ptr, i32 } %2154, { ptr, ptr, ptr, i32 } %2154, ptr nonnull %99, i32 %.reg2mem103.0431.i)
  %.fca.0.extract52.i = extractvalue { ptr, i160 } %2185, 0
  %2186 = icmp ne ptr %.fca.0.extract52.i, @nil_typ
  %2187 = icmp ne ptr %.fca.0.extract52.i, null
  %.not60.i = and i1 %2186, %2187
  br i1 %.not60.i, label %2188, label %2202

2188:                                             ; preds = %2180
  %hash_coef_ptr.i.i137.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 8
  %tbl_size_ptr.i.i138.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 16
  %offset_tbl_ptr.i.i139.i = getelementptr i8, ptr %.fca.0.extract52.i, i64 40
  %hash_coef.i.i140.i = load i64, ptr %hash_coef_ptr.i.i137.i, align 4
  %tbl_size.i.i141.i = load i64, ptr %tbl_size_ptr.i.i138.i, align 4
  %offset_tbl.i.i142.i = load ptr, ptr %offset_tbl_ptr.i.i139.i, align 8
  %product.i.i.i143.i = mul i64 %hash_coef.i.i140.i, 4015701072841558310
  %shifted.i.i.i144.i = lshr i64 %product.i.i.i143.i, 32
  %xored.i.i.i145.i = xor i64 %shifted.i.i.i144.i, %product.i.i.i143.i
  %hash.i.i.i146.i = and i64 %xored.i.i.i145.i, %tbl_size.i.i141.i
  %offset_ptr.i.i147.i = getelementptr i32, ptr %offset_tbl.i.i142.i, i64 %hash.i.i.i146.i
  %offset.i.i148.i = load i32, ptr %offset_ptr.i.i147.i, align 4
  %2189 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2190 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2191 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2192 = icmp slt i32 %.reg2mem105.0432.i, %2172
  br i1 %2192, label %2193, label %._crit_edge.i1319

2193:                                             ; preds = %2188
  %.fca.1.extract54.i = extractvalue { ptr, i160 } %2185, 1
  %.sroa.351.0.insert.ext.i = zext i32 %offset.i.i148.i to i160
  %.sroa.351.0.insert.shift.i = shl nuw i160 %.sroa.351.0.insert.ext.i, 128
  %2194 = and i160 %.fca.1.extract54.i, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i = or disjoint i160 %.sroa.351.0.insert.shift.i, %2194
  %2195 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2196 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2197 = sext i32 %.reg2mem105.0432.i to i64
  %2198 = shl nsw i64 %2197, 5
  %2199 = getelementptr i8, ptr %result.i.i.i1317, i64 %2198
  store ptr %.fca.0.extract52.i, ptr %2199, align 8
  %2200 = getelementptr i8, ptr %2199, i64 8
  store i160 %.sroa.049.0.insert.insert.i, ptr %2200, align 4
  br label %._crit_edge.i1319

._crit_edge.i1319:                                ; preds = %2193, %2188
  %2201 = add i32 %.reg2mem105.0432.i, 1
  br label %2202

2202:                                             ; preds = %._crit_edge.i1319, %2180
  %.reg2mem101.0.i = phi i32 [ %2201, %._crit_edge.i1319 ], [ %.reg2mem105.0432.i, %2180 ]
  %2203 = add nuw nsw i32 %.reg2mem103.0431.i, 1
  %2204 = icmp slt i32 %2203, %2170
  br i1 %2204, label %2180, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2202
  %invariant.gep396.i = getelementptr i8, ptr %2155, i64 120
  %2205 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2206 = sext i32 %2161 to i64
  %gep397.i = getelementptr ptr, ptr %invariant.gep396.i, i64 %2206
  br label %2207

2207:                                             ; preds = %2229, %.lr.ph.i
  %.reg2mem91.0394.i = phi i32 [ %.reg2mem101.0.i, %.lr.ph.i ], [ %.reg2mem87.0.i, %2229 ]
  %.reg2mem89.0393.i = phi i32 [ 0, %.lr.ph.i ], [ %2230, %2229 ]
  store ptr @_parameterization_Ptri32, ptr %101, align 8
  %2208 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %101)
  %2209 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2155)
  %2210 = load ptr, ptr %gep397.i, align 8
  store ptr @i32_typ, ptr %102, align 8
  %2211 = call ptr %2210({ ptr, ptr, ptr, i32 } %2162, ptr nonnull %102)
  %2212 = call { ptr, i160 } %2211({ ptr, ptr, ptr, i32 } %2162, { ptr, ptr, ptr, i32 } %2162, ptr nonnull %101, i32 %.reg2mem89.0393.i)
  %.fca.0.extract42.i = extractvalue { ptr, i160 } %2212, 0
  %2213 = icmp ne ptr %.fca.0.extract42.i, @nil_typ
  %2214 = icmp ne ptr %.fca.0.extract42.i, null
  %.not62.i = and i1 %2213, %2214
  br i1 %.not62.i, label %2215, label %2229

2215:                                             ; preds = %2207
  %hash_coef_ptr.i.i152.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 8
  %tbl_size_ptr.i.i153.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 16
  %offset_tbl_ptr.i.i154.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 40
  %hash_coef.i.i155.i = load i64, ptr %hash_coef_ptr.i.i152.i, align 4
  %tbl_size.i.i156.i = load i64, ptr %tbl_size_ptr.i.i153.i, align 4
  %offset_tbl.i.i157.i = load ptr, ptr %offset_tbl_ptr.i.i154.i, align 8
  %product.i.i.i158.i = mul i64 %hash_coef.i.i155.i, 4015701072841558310
  %shifted.i.i.i159.i = lshr i64 %product.i.i.i158.i, 32
  %xored.i.i.i160.i = xor i64 %shifted.i.i.i159.i, %product.i.i.i158.i
  %hash.i.i.i161.i = and i64 %xored.i.i.i160.i, %tbl_size.i.i156.i
  %offset_ptr.i.i162.i = getelementptr i32, ptr %offset_tbl.i.i157.i, i64 %hash.i.i.i161.i
  %offset.i.i163.i = load i32, ptr %offset_ptr.i.i162.i, align 4
  %2216 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2217 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2218 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2219 = icmp slt i32 %.reg2mem91.0394.i, %2172
  br i1 %2219, label %2220, label %._crit_edge1.i1318

2220:                                             ; preds = %2215
  %.fca.1.extract44.i = extractvalue { ptr, i160 } %2212, 1
  %.sroa.3.0.insert.ext.i = zext i32 %offset.i.i163.i to i160
  %.sroa.3.0.insert.shift.i = shl nuw i160 %.sroa.3.0.insert.ext.i, 128
  %2221 = and i160 %.fca.1.extract44.i, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i = or disjoint i160 %.sroa.3.0.insert.shift.i, %2221
  %2222 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2223 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2224 = sext i32 %.reg2mem91.0394.i to i64
  %2225 = shl nsw i64 %2224, 5
  %2226 = getelementptr i8, ptr %result.i.i.i1317, i64 %2225
  store ptr %.fca.0.extract42.i, ptr %2226, align 8
  %2227 = getelementptr i8, ptr %2226, i64 8
  store i160 %.sroa.040.0.insert.insert.i, ptr %2227, align 4
  br label %._crit_edge1.i1318

._crit_edge1.i1318:                               ; preds = %2220, %2215
  %2228 = add i32 %.reg2mem91.0394.i, 1
  br label %2229

2229:                                             ; preds = %._crit_edge1.i1318, %2207
  %.reg2mem87.0.i = phi i32 [ %2228, %._crit_edge1.i1318 ], [ %.reg2mem91.0394.i, %2207 ]
  %2230 = add nuw nsw i32 %.reg2mem89.0393.i, 1
  %2231 = icmp slt i32 %2230, %2170
  br i1 %2231, label %2207, label %._crit_edge395.i.loopexit

._crit_edge395.i.loopexit:                        ; preds = %2229
  %.pre = load ptr, ptr %result.i130, align 8
  %.pre3059 = load ptr, ptr %180, align 8
  br label %._crit_edge395.i

._crit_edge395.i:                                 ; preds = %._crit_edge395.i.loopexit, %2145
  %2232 = phi ptr [ %2174, %2145 ], [ %.pre3059, %._crit_edge395.i.loopexit ]
  %2233 = phi ptr [ %2173, %2145 ], [ %.pre, %._crit_edge395.i.loopexit ]
  %.reg2mem91.0.lcssa.i = phi i32 [ 0, %2145 ], [ %.reg2mem87.0.i, %._crit_edge395.i.loopexit ]
  %2234 = call i32 @llvm.smax.i32(i32 %2171, i32 16)
  %result.i166.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2235 = getelementptr i8, ptr %result.i166.i, i64 16
  store ptr @_parameterization_Nil, ptr %2235, align 8
  %result.i167.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2236 = getelementptr i8, ptr %result.i167.i, i64 16
  store ptr %2232, ptr %2236, align 8
  %2237 = getelementptr i8, ptr %result.i167.i, i64 8
  store ptr %2233, ptr %2237, align 8
  %2238 = getelementptr i8, ptr %result.i167.i, i64 24
  store ptr null, ptr %2238, align 8
  %2239 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i)
  store ptr @Entry, ptr %result.i167.i, align 8
  %2240 = getelementptr i8, ptr %result.i166.i, i64 8
  store ptr %result.i167.i, ptr %2240, align 8
  %2241 = getelementptr i8, ptr %result.i166.i, i64 24
  store ptr null, ptr %2241, align 8
  %2242 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i)
  store ptr @union_typ, ptr %result.i166.i, align 8
  %result.i168.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i, ptr %result.i168.i, align 8
  %2243 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i)
  store ptr @Array, ptr %103, align 8
  store ptr %result.i168.i, ptr %254, align 8
  store i32 9, ptr %255, align 8
  %2244 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %103)
  %2245 = getelementptr i8, ptr %result.i168.i, i64 16
  store i32 %2234, ptr %2245, align 4
  %2246 = getelementptr i8, ptr %result.i168.i, i64 20
  store i32 %2234, ptr %2246, align 4
  %2247 = zext nneg i32 %2234 to i64
  %2248 = shl nuw nsw i64 %2247, 5
  %result.i.i416.i = call noalias ptr @bump_malloc_inner(i64 noundef %2248, ptr nonnull @current_ptr) #29
  %2249 = getelementptr i8, ptr %result.i168.i, i64 8
  store ptr %result.i.i416.i, ptr %2249, align 8
  %2250 = load ptr, ptr %256, align 8
  store ptr @Array, ptr %197, align 8
  store ptr %result.i168.i, ptr %198, align 8
  store ptr %2250, ptr %199, align 8
  store i32 9, ptr %200, align 4
  %2251 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2252 = getelementptr i8, ptr %result.i183.i, i64 16
  store ptr @_parameterization_Nil, ptr %2252, align 8
  %result.i184.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2253 = getelementptr i8, ptr %result.i184.i, i64 16
  store ptr %2232, ptr %2253, align 8
  %2254 = getelementptr i8, ptr %result.i184.i, i64 8
  store ptr %2233, ptr %2254, align 8
  %2255 = getelementptr i8, ptr %result.i184.i, i64 24
  store ptr null, ptr %2255, align 8
  %2256 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i)
  store ptr @Entry, ptr %result.i184.i, align 8
  %2257 = getelementptr i8, ptr %result.i183.i, i64 8
  store ptr %result.i184.i, ptr %2257, align 8
  %2258 = getelementptr i8, ptr %result.i183.i, i64 24
  store ptr null, ptr %2258, align 8
  %2259 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i)
  store ptr @union_typ, ptr %result.i183.i, align 8
  %result.i185.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i, ptr %result.i185.i, align 8
  %2260 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i)
  store ptr @Array, ptr %104, align 8
  store ptr %result.i185.i, ptr %257, align 8
  store i32 9, ptr %258, align 8
  %2261 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %104)
  %2262 = getelementptr i8, ptr %result.i185.i, i64 16
  store i32 %2234, ptr %2262, align 4
  %2263 = getelementptr i8, ptr %result.i185.i, i64 20
  store i32 %2234, ptr %2263, align 4
  %result.i.i430.i = call noalias ptr @bump_malloc_inner(i64 noundef %2248, ptr nonnull @current_ptr) #29
  %2264 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2265 = getelementptr i8, ptr %result.i185.i, i64 8
  store ptr %result.i.i430.i, ptr %2265, align 8
  %2266 = load ptr, ptr %259, align 8
  store ptr @Array, ptr %214, align 8
  store ptr %result.i185.i, ptr %215, align 8
  store ptr %2266, ptr %216, align 8
  store i32 9, ptr %217, align 4
  store i32 0, ptr %218, align 4
  %2267 = icmp sgt i32 %.reg2mem91.0.lcssa.i, 0
  br i1 %2267, label %.lr.ph400.i, label %HashMap_resize_.exit

.lr.ph400.i:                                      ; preds = %._crit_edge395.i
  %2268 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2269 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2270 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %._crit_edge2.i, %.lr.ph400.i
  %.reg2mem77.0398.i = phi i32 [ 0, %.lr.ph400.i ], [ %2284, %._crit_edge2.i ]
  %2271 = zext nneg i32 %.reg2mem77.0398.i to i64
  %2272 = shl nuw nsw i64 %2271, 5
  %2273 = getelementptr i8, ptr %result.i.i.i1317, i64 %2272
  %2274 = load ptr, ptr %2273, align 8
  %2275 = getelementptr i8, ptr %2273, i64 8
  %2276 = load i160, ptr %2275, align 4
  %.sroa.3362.8.extract.trunc.i = trunc i160 %2276 to i64
  %2277 = inttoptr i64 %.sroa.3362.8.extract.trunc.i to ptr
  %.sroa.5363.8.extract.shift.i = lshr i160 %2276, 64
  %.sroa.5363.8.extract.trunc.i = trunc i160 %.sroa.5363.8.extract.shift.i to i64
  %2278 = inttoptr i64 %.sroa.5363.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i201.i = getelementptr i8, ptr %2274, i64 8
  %tbl_size_ptr.i.i202.i = getelementptr i8, ptr %2274, i64 16
  %offset_tbl_ptr.i.i203.i = getelementptr i8, ptr %2274, i64 40
  %hash_coef.i.i232.i = load i64, ptr %hash_coef_ptr.i.i201.i, align 4
  %tbl_size.i.i233.i = load i64, ptr %tbl_size_ptr.i.i202.i, align 4
  %offset_tbl.i.i234.i = load ptr, ptr %offset_tbl_ptr.i.i203.i, align 8
  %product.i.i.i235.i = mul i64 %hash_coef.i.i232.i, 4015701072841558310
  %shifted.i.i.i236.i = lshr i64 %product.i.i.i235.i, 32
  %xored.i.i.i237.i = xor i64 %shifted.i.i.i236.i, %product.i.i.i235.i
  %hash.i.i.i238.i = and i64 %xored.i.i.i237.i, %tbl_size.i.i233.i
  %offset_ptr.i.i239.i = getelementptr i32, ptr %offset_tbl.i.i234.i, i64 %hash.i.i.i238.i
  %offset.i.i240.i = load i32, ptr %offset_ptr.i.i239.i, align 4
  %2279 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2274, 0
  %2280 = insertvalue { ptr, ptr, ptr, i32 } %2279, ptr %2277, 1
  %2281 = insertvalue { ptr, ptr, ptr, i32 } %2280, ptr %2278, 2
  %2282 = insertvalue { ptr, ptr, ptr, i32 } %2281, i32 %offset.i.i240.i, 3
  %2283 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %262, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2282)
  %2284 = add nuw nsw i32 %.reg2mem77.0398.i, 1
  %2285 = icmp slt i32 %2284, %.reg2mem91.0.lcssa.i
  br i1 %2285, label %._crit_edge2.i, label %HashMap_resize_.exit

HashMap_resize_.exit:                             ; preds = %._crit_edge2.i, %._crit_edge395.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %99)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %100)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %101)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %102)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %103)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %104)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %HashMap_resize_.exit, %.critedge158.i
  %2286 = load ptr, ptr %result.i130, align 8
  %2287 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2288 = load ptr, ptr %180, align 8
  %2289 = load ptr, ptr %2286, align 8
  %2290 = getelementptr i8, ptr %2289, i64 48
  %2291 = load ptr, ptr %2290, align 8
  %2292 = call { i64, i64 } %2291(ptr nonnull %2286)
  %2293 = extractvalue { i64, i64 } %2292, 0
  %2294 = extractvalue { i64, i64 } %2292, 1
  %2295 = urem i64 20, %2294
  %2296 = icmp eq i64 %2295, 0
  %2297 = sub i64 %2294, %2295
  %2298 = select i1 %2296, i64 0, i64 %2297
  %2299 = add i64 %2293, 20
  %2300 = add i64 %2299, %2298
  %2301 = load ptr, ptr %2288, align 8
  %2302 = getelementptr i8, ptr %2301, i64 48
  %2303 = load ptr, ptr %2302, align 8
  %2304 = call { i64, i64 } %2303(ptr nonnull %2288)
  %2305 = extractvalue { i64, i64 } %2304, 0
  %2306 = extractvalue { i64, i64 } %2304, 1
  %2307 = call i64 @llvm.umax.i64(i64 %2294, i64 %2306)
  %2308 = call i64 @llvm.umax.i64(i64 %2307, i64 8)
  %2309 = urem i64 %2300, %2306
  %2310 = icmp eq i64 %2309, 0
  %2311 = sub i64 %2306, %2309
  %2312 = select i1 %2310, i64 0, i64 %2311
  %2313 = add i64 %2305, %2300
  %2314 = add i64 %2313, %2312
  %2315 = urem i64 %2314, %2308
  %2316 = icmp eq i64 %2315, 0
  %2317 = sub i64 %2308, %2315
  %2318 = select i1 %2316, i64 0, i64 %2317
  %2319 = add i64 %2318, %2314
  %result.i298.i = call noalias ptr @bump_malloc_inner(i64 noundef %2319, ptr nonnull @current_ptr) #29
  store ptr %2286, ptr %result.i298.i, align 8
  %2320 = getelementptr i8, ptr %result.i298.i, i64 8
  store ptr %2288, ptr %2320, align 8
  %2321 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i)
  store ptr @Entry, ptr %132, align 8
  store ptr %result.i298.i, ptr %225, align 8
  store i32 9, ptr %226, align 8
  %2322 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %132)
  %2323 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2324 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2325 = load ptr, ptr %2286, align 8
  %2326 = getelementptr i8, ptr %2325, i64 48
  %2327 = load ptr, ptr %2326, align 8
  %2328 = call { i64, i64 } %2327(ptr nonnull %2286)
  %2329 = extractvalue { i64, i64 } %2328, 1
  %2330 = urem i64 20, %2329
  %2331 = icmp eq i64 %2330, 0
  %reass.sub3772 = sub i64 %2329, %2330
  %2332 = add i64 %reass.sub3772, 20
  %2333 = select i1 %2331, i64 20, i64 %2332
  %2334 = getelementptr i8, ptr %result.i298.i, i64 %2333
  %2335 = load ptr, ptr %result.i298.i, align 8
  %2336 = load ptr, ptr %2335, align 8
  %2337 = getelementptr i8, ptr %2336, i64 64
  %2338 = load ptr, ptr %2337, align 8
  call void %2338({ ptr, i160 } %324, ptr nonnull %2335, ptr %2334)
  %2339 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2340 = load ptr, ptr %result.i298.i, align 8
  %2341 = load ptr, ptr %2340, align 8
  %2342 = getelementptr i8, ptr %2341, i64 48
  %2343 = load ptr, ptr %2342, align 8
  %2344 = call { i64, i64 } %2343(ptr nonnull %2340)
  %2345 = extractvalue { i64, i64 } %2344, 0
  %2346 = extractvalue { i64, i64 } %2344, 1
  %2347 = urem i64 20, %2346
  %2348 = icmp eq i64 %2347, 0
  %2349 = sub i64 %2346, %2347
  %2350 = select i1 %2348, i64 0, i64 %2349
  %2351 = add i64 %2345, 20
  %2352 = add i64 %2351, %2350
  %2353 = load ptr, ptr %2320, align 8
  %2354 = load ptr, ptr %2353, align 8
  %2355 = getelementptr i8, ptr %2354, i64 48
  %2356 = load ptr, ptr %2355, align 8
  %2357 = call { i64, i64 } %2356(ptr nonnull %2353)
  %2358 = extractvalue { i64, i64 } %2357, 1
  %2359 = urem i64 %2352, %2358
  %2360 = icmp eq i64 %2359, 0
  %2361 = sub i64 %2358, %2359
  %2362 = select i1 %2360, i64 0, i64 %2361
  %2363 = getelementptr i8, ptr %result.i298.i, i64 %2352
  %2364 = getelementptr i8, ptr %2363, i64 %2362
  %2365 = load ptr, ptr %2320, align 8
  %2366 = load ptr, ptr %2365, align 8
  %2367 = getelementptr i8, ptr %2366, i64 64
  %2368 = load ptr, ptr %2367, align 8
  call void %2368({ ptr, i160 } %1749, ptr nonnull %2365, ptr %2364)
  %2369 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2370 = getelementptr i8, ptr %result.i298.i, i64 16
  store i32 %1752, ptr %2370, align 4
  %2371 = load ptr, ptr %227, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1320)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %98)
  store ptr @Entry, ptr %98, align 8
  store ptr %result.i298.i, ptr %263, align 8
  store ptr %2371, ptr %264, align 8
  store i32 9, ptr %265, align 8
  %2372 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %98)
  %2373 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2374 = load i32, ptr %220, align 4
  %2375 = icmp sgt i32 %2374, 0
  br i1 %2375, label %.lr.ph.i1350, label %._crit_edge1.i

.lr.ph.i1350:                                     ; preds = %._crit_edge.i
  %2376 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2377 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %2378

2378:                                             ; preds = %.cont.cont.i, %.lr.ph.i1350
  %offset.i.i260.i2056 = phi i32 [ 9, %.lr.ph.i1350 ], [ %offset.i.i260.i, %.cont.cont.i ]
  %.sroa.speculated346.i2054 = phi ptr [ %2371, %.lr.ph.i1350 ], [ %.sroa.speculated346.i, %.cont.cont.i ]
  %.sroa.speculated352.i2052 = phi ptr [ %result.i298.i, %.lr.ph.i1350 ], [ %.sroa.speculated352.i, %.cont.cont.i ]
  %.reg2mem195.0678.i = phi i32 [ 1, %.lr.ph.i1350 ], [ %2534, %.cont.cont.i ]
  %.reg2mem193.0677.i = phi i32 [ 0, %.lr.ph.i1350 ], [ %2535, %.cont.cont.i ]
  %2379 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i2052, 1
  %2380 = insertvalue { ptr, ptr, ptr, i32 } %2379, ptr %.sroa.speculated346.i2054, 2
  %2381 = insertvalue { ptr, ptr, ptr, i32 } %2380, i32 %offset.i.i260.i2056, 3
  %2382 = sext i32 %offset.i.i260.i2056 to i64
  %gep2051 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %2382
  %2383 = load ptr, ptr %gep2051, align 8
  %2384 = call ptr %2383({ ptr, ptr, ptr, i32 } %2381, ptr nonnull %2)
  %2385 = call i32 %2384({ ptr, ptr, ptr, i32 } %2381, { ptr, ptr, ptr, i32 } %2381, ptr nonnull %2)
  %2386 = icmp eq i32 %.reg2mem195.0678.i, 1
  %2387 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %2386, label %2388, label %2452

2388:                                             ; preds = %2378
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2389 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2390 = load ptr, ptr %197, align 8
  %2391 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2390, 0
  %2392 = load ptr, ptr %198, align 8
  %2393 = insertvalue { ptr, ptr, ptr, i32 } %2391, ptr %2392, 1
  %2394 = load ptr, ptr %199, align 8
  %2395 = insertvalue { ptr, ptr, ptr, i32 } %2393, ptr %2394, 2
  %2396 = load i32, ptr %200, align 4
  %2397 = insertvalue { ptr, ptr, ptr, i32 } %2395, i32 %2396, 3
  %hash_coef_ptr.i.i10.i3152 = getelementptr i8, ptr %2390, i64 8
  %tbl_size_ptr.i.i11.i3153 = getelementptr i8, ptr %2390, i64 16
  %offset_tbl_ptr.i.i12.i3154 = getelementptr i8, ptr %2390, i64 40
  %hash_coef.i.i13.i3155 = load i64, ptr %hash_coef_ptr.i.i10.i3152, align 4
  %tbl_size.i.i14.i3156 = load i64, ptr %tbl_size_ptr.i.i11.i3153, align 4
  %offset_tbl.i.i15.i3157 = load ptr, ptr %offset_tbl_ptr.i.i12.i3154, align 8
  %product.i.i.i16.i3158 = mul i64 %hash_coef.i.i13.i3155, -5261542750394134544
  %shifted.i.i.i17.i3159 = lshr i64 %product.i.i.i16.i3158, 32
  %xored.i.i.i18.i3160 = xor i64 %shifted.i.i.i17.i3159, %product.i.i.i16.i3158
  %hash.i.i.i19.i3161 = and i64 %xored.i.i.i18.i3160, %tbl_size.i.i14.i3156
  %offset_ptr.i.i20.i3162 = getelementptr i32, ptr %offset_tbl.i.i15.i3157, i64 %hash.i.i.i19.i3161
  %offset.i.i21.i3163 = load i32, ptr %offset_ptr.i.i20.i3162, align 4
  %eq.i.i3164 = icmp eq i32 %2396, %offset.i.i21.i3163
  call void @llvm.assume(i1 %eq.i.i3164) #30
  %2398 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2399 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2390)
  %2400 = sext i32 %2396 to i64
  %2401 = getelementptr ptr, ptr %2390, i64 %2400
  %2402 = getelementptr i8, ptr %2401, i64 64
  %2403 = load ptr, ptr %2402, align 8
  %2404 = call ptr %2403({ ptr, ptr, ptr, i32 } %2397, ptr nonnull %2)
  %2405 = call i32 %2404({ ptr, ptr, ptr, i32 } %2397, { ptr, ptr, ptr, i32 } %2397, ptr nonnull %2)
  %2406 = add i32 %2405, -1
  %2407 = and i32 %2406, %2385
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2408 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2409 = load ptr, ptr %197, align 8
  %2410 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2409, 0
  %2411 = load ptr, ptr %198, align 8
  %2412 = insertvalue { ptr, ptr, ptr, i32 } %2410, ptr %2411, 1
  %2413 = load ptr, ptr %199, align 8
  %2414 = insertvalue { ptr, ptr, ptr, i32 } %2412, ptr %2413, 2
  %2415 = load i32, ptr %200, align 4
  %2416 = insertvalue { ptr, ptr, ptr, i32 } %2414, i32 %2415, 3
  %hash_coef_ptr.i.i172.i = getelementptr i8, ptr %2409, i64 8
  %tbl_size_ptr.i.i173.i = getelementptr i8, ptr %2409, i64 16
  %offset_tbl_ptr.i.i174.i = getelementptr i8, ptr %2409, i64 40
  %hash_coef.i.i175.i = load i64, ptr %hash_coef_ptr.i.i172.i, align 4
  %tbl_size.i.i176.i = load i64, ptr %tbl_size_ptr.i.i173.i, align 4
  %offset_tbl.i.i177.i = load ptr, ptr %offset_tbl_ptr.i.i174.i, align 8
  %product.i.i.i178.i = mul i64 %hash_coef.i.i175.i, -5261542750394134544
  %shifted.i.i.i179.i = lshr i64 %product.i.i.i178.i, 32
  %xored.i.i.i180.i = xor i64 %shifted.i.i.i179.i, %product.i.i.i178.i
  %hash.i.i.i181.i = and i64 %xored.i.i.i180.i, %tbl_size.i.i176.i
  %offset_ptr.i.i182.i = getelementptr i32, ptr %offset_tbl.i.i177.i, i64 %hash.i.i.i181.i
  %offset.i.i183.i = load i32, ptr %offset_ptr.i.i182.i, align 4
  %eq.i.i1353 = icmp eq i32 %2415, %offset.i.i183.i
  call void @llvm.assume(i1 %eq.i.i1353) #30
  store ptr @_parameterization_Ptri32, ptr %82, align 8
  %2417 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %82)
  %2418 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2409)
  %2419 = sext i32 %2415 to i64
  %2420 = getelementptr ptr, ptr %2409, i64 %2419
  %2421 = getelementptr i8, ptr %2420, i64 120
  %2422 = load ptr, ptr %2421, align 8
  store ptr @i32_typ, ptr %83, align 8
  %2423 = call ptr %2422({ ptr, ptr, ptr, i32 } %2416, ptr nonnull %83)
  %2424 = call { ptr, i160 } %2423({ ptr, ptr, ptr, i32 } %2416, { ptr, ptr, ptr, i32 } %2416, ptr nonnull %82, i32 %2407)
  %.fca.0.extract112.i = extractvalue { ptr, i160 } %2424, 0
  %2425 = ptrtoint ptr %.sroa.speculated352.i2052 to i64
  %2426 = ptrtoint ptr %.sroa.speculated346.i2054 to i64
  %.sroa.3111.0.insert.ext.i = zext i32 %offset.i.i260.i2056 to i160
  %.sroa.3111.0.insert.shift.i = shl nuw i160 %.sroa.3111.0.insert.ext.i, 128
  %.sroa.2110.0.insert.ext.i = zext i64 %2426 to i160
  %.sroa.2110.0.insert.shift.i = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i, 64
  %.sroa.2110.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.shift.i, %.sroa.3111.0.insert.shift.i
  %.sroa.0109.0.insert.ext.i = zext i64 %2425 to i160
  %.sroa.0109.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.insert.i, %.sroa.0109.0.insert.ext.i
  %2427 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i, 1
  %2428 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2429 = load ptr, ptr %197, align 8
  %2430 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2429, 0
  %2431 = load ptr, ptr %198, align 8
  %2432 = insertvalue { ptr, ptr, ptr, i32 } %2430, ptr %2431, 1
  %2433 = load ptr, ptr %199, align 8
  %2434 = insertvalue { ptr, ptr, ptr, i32 } %2432, ptr %2433, 2
  %2435 = load i32, ptr %200, align 4
  %2436 = insertvalue { ptr, ptr, ptr, i32 } %2434, i32 %2435, 3
  %hash_coef_ptr.i.i186.i = getelementptr i8, ptr %2429, i64 8
  %tbl_size_ptr.i.i187.i = getelementptr i8, ptr %2429, i64 16
  %offset_tbl_ptr.i.i188.i = getelementptr i8, ptr %2429, i64 40
  %hash_coef.i.i189.i = load i64, ptr %hash_coef_ptr.i.i186.i, align 4
  %tbl_size.i.i190.i = load i64, ptr %tbl_size_ptr.i.i187.i, align 4
  %offset_tbl.i.i191.i = load ptr, ptr %offset_tbl_ptr.i.i188.i, align 8
  %product.i.i.i192.i = mul i64 %hash_coef.i.i189.i, -5261542750394134544
  %shifted.i.i.i193.i = lshr i64 %product.i.i.i192.i, 32
  %xored.i.i.i194.i = xor i64 %shifted.i.i.i193.i, %product.i.i.i192.i
  %hash.i.i.i195.i = and i64 %xored.i.i.i194.i, %tbl_size.i.i190.i
  %offset_ptr.i.i196.i = getelementptr i32, ptr %offset_tbl.i.i191.i, i64 %hash.i.i.i195.i
  %offset.i.i197.i = load i32, ptr %offset_ptr.i.i196.i, align 4
  %eq.i200.i = icmp eq i32 %2435, %offset.i.i197.i
  call void @llvm.assume(i1 %eq.i200.i) #30
  %2437 = load ptr, ptr %result.i130, align 8
  %2438 = load ptr, ptr %180, align 8
  %result.i.i1354 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2439 = getelementptr i8, ptr %result.i.i1354, i64 16
  store ptr %2438, ptr %2439, align 8
  %2440 = getelementptr i8, ptr %result.i.i1354, i64 8
  store ptr %2437, ptr %2440, align 8
  %2441 = getelementptr i8, ptr %result.i.i1354, i64 24
  store ptr null, ptr %2441, align 8
  %2442 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1354)
  store ptr @Entry, ptr %result.i.i1354, align 8
  store ptr @_parameterization_Ptri32, ptr %84, align 8
  store ptr %result.i.i1354, ptr %268, align 8
  %2443 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %84)
  %2444 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2429)
  %2445 = sext i32 %2435 to i64
  %2446 = getelementptr ptr, ptr %2429, i64 %2445
  %2447 = getelementptr i8, ptr %2446, i64 128
  %2448 = load ptr, ptr %2447, align 8
  store ptr @i32_typ, ptr %85, align 8
  store ptr @Entry, ptr %269, align 8
  %2449 = call ptr %2448({ ptr, ptr, ptr, i32 } %2436, ptr nonnull %85)
  call void %2449({ ptr, ptr, ptr, i32 } %2436, { ptr, ptr, ptr, i32 } %2436, ptr nonnull %84, i32 %2407, { ptr, i160 } %2427)
  %2450 = icmp ne ptr %.fca.0.extract112.i, @nil_typ
  %2451 = icmp ne ptr %.fca.0.extract112.i, null
  %.not140.i = and i1 %2450, %2451
  br i1 %.not140.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

2452:                                             ; preds = %2378
  %2453 = add i32 %2385, 2127912214
  %2454 = shl i32 %2385, 12
  %2455 = add i32 %2453, %2454
  %2456 = ashr i32 %2455, 19
  %2457 = xor i32 %2455, %2456
  %2458 = xor i32 %2457, -949894596
  %2459 = add i32 %2458, 374761393
  %2460 = shl i32 %2458, 5
  %2461 = add i32 %2459, %2460
  %2462 = add i32 %2461, -744332180
  %2463 = shl i32 %2461, 9
  %2464 = xor i32 %2462, %2463
  %2465 = add i32 %2464, -42973499
  %2466 = shl i32 %2464, 3
  %2467 = add i32 %2465, %2466
  %2468 = ashr i32 %2467, 16
  %2469 = xor i32 %2467, %2468
  %2470 = xor i32 %2469, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2471 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2472 = load ptr, ptr %214, align 8
  %2473 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2472, 0
  %2474 = load ptr, ptr %215, align 8
  %2475 = insertvalue { ptr, ptr, ptr, i32 } %2473, ptr %2474, 1
  %2476 = load ptr, ptr %216, align 8
  %2477 = insertvalue { ptr, ptr, ptr, i32 } %2475, ptr %2476, 2
  %2478 = load i32, ptr %217, align 4
  %2479 = insertvalue { ptr, ptr, ptr, i32 } %2477, i32 %2478, 3
  %hash_coef_ptr.i.i10.i3182 = getelementptr i8, ptr %2472, i64 8
  %tbl_size_ptr.i.i11.i3183 = getelementptr i8, ptr %2472, i64 16
  %offset_tbl_ptr.i.i12.i3184 = getelementptr i8, ptr %2472, i64 40
  %hash_coef.i.i13.i3185 = load i64, ptr %hash_coef_ptr.i.i10.i3182, align 4
  %tbl_size.i.i14.i3186 = load i64, ptr %tbl_size_ptr.i.i11.i3183, align 4
  %offset_tbl.i.i15.i3187 = load ptr, ptr %offset_tbl_ptr.i.i12.i3184, align 8
  %product.i.i.i16.i3188 = mul i64 %hash_coef.i.i13.i3185, -5261542750394134544
  %shifted.i.i.i17.i3189 = lshr i64 %product.i.i.i16.i3188, 32
  %xored.i.i.i18.i3190 = xor i64 %shifted.i.i.i17.i3189, %product.i.i.i16.i3188
  %hash.i.i.i19.i3191 = and i64 %xored.i.i.i18.i3190, %tbl_size.i.i14.i3186
  %offset_ptr.i.i20.i3192 = getelementptr i32, ptr %offset_tbl.i.i15.i3187, i64 %hash.i.i.i19.i3191
  %offset.i.i21.i3193 = load i32, ptr %offset_ptr.i.i20.i3192, align 4
  %eq.i.i3194 = icmp eq i32 %2478, %offset.i.i21.i3193
  call void @llvm.assume(i1 %eq.i.i3194) #30
  %2480 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2481 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2472)
  %2482 = sext i32 %2478 to i64
  %2483 = getelementptr ptr, ptr %2472, i64 %2482
  %2484 = getelementptr i8, ptr %2483, i64 64
  %2485 = load ptr, ptr %2484, align 8
  %2486 = call ptr %2485({ ptr, ptr, ptr, i32 } %2479, ptr nonnull %2)
  %2487 = call i32 %2486({ ptr, ptr, ptr, i32 } %2479, { ptr, ptr, ptr, i32 } %2479, ptr nonnull %2)
  %2488 = add i32 %2487, -1
  %2489 = and i32 %2488, %2470
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2490 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2491 = load ptr, ptr %214, align 8
  %2492 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2491, 0
  %2493 = load ptr, ptr %215, align 8
  %2494 = insertvalue { ptr, ptr, ptr, i32 } %2492, ptr %2493, 1
  %2495 = load ptr, ptr %216, align 8
  %2496 = insertvalue { ptr, ptr, ptr, i32 } %2494, ptr %2495, 2
  %2497 = load i32, ptr %217, align 4
  %2498 = insertvalue { ptr, ptr, ptr, i32 } %2496, i32 %2497, 3
  %hash_coef_ptr.i.i202.i = getelementptr i8, ptr %2491, i64 8
  %tbl_size_ptr.i.i203.i = getelementptr i8, ptr %2491, i64 16
  %offset_tbl_ptr.i.i204.i = getelementptr i8, ptr %2491, i64 40
  %hash_coef.i.i205.i = load i64, ptr %hash_coef_ptr.i.i202.i, align 4
  %tbl_size.i.i206.i = load i64, ptr %tbl_size_ptr.i.i203.i, align 4
  %offset_tbl.i.i207.i = load ptr, ptr %offset_tbl_ptr.i.i204.i, align 8
  %product.i.i.i208.i = mul i64 %hash_coef.i.i205.i, -5261542750394134544
  %shifted.i.i.i209.i = lshr i64 %product.i.i.i208.i, 32
  %xored.i.i.i210.i = xor i64 %shifted.i.i.i209.i, %product.i.i.i208.i
  %hash.i.i.i211.i = and i64 %xored.i.i.i210.i, %tbl_size.i.i206.i
  %offset_ptr.i.i212.i = getelementptr i32, ptr %offset_tbl.i.i207.i, i64 %hash.i.i.i211.i
  %offset.i.i213.i = load i32, ptr %offset_ptr.i.i212.i, align 4
  %eq.i216.i = icmp eq i32 %2497, %offset.i.i213.i
  call void @llvm.assume(i1 %eq.i216.i) #30
  store ptr @_parameterization_Ptri32, ptr %90, align 8
  %2499 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %90)
  %2500 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2491)
  %2501 = sext i32 %2497 to i64
  %2502 = getelementptr ptr, ptr %2491, i64 %2501
  %2503 = getelementptr i8, ptr %2502, i64 120
  %2504 = load ptr, ptr %2503, align 8
  store ptr @i32_typ, ptr %91, align 8
  %2505 = call ptr %2504({ ptr, ptr, ptr, i32 } %2498, ptr nonnull %91)
  %2506 = call { ptr, i160 } %2505({ ptr, ptr, ptr, i32 } %2498, { ptr, ptr, ptr, i32 } %2498, ptr nonnull %90, i32 %2489)
  %.fca.0.extract87.i = extractvalue { ptr, i160 } %2506, 0
  %2507 = ptrtoint ptr %.sroa.speculated352.i2052 to i64
  %2508 = ptrtoint ptr %.sroa.speculated346.i2054 to i64
  %.sroa.3.0.insert.ext.i1351 = zext i32 %offset.i.i260.i2056 to i160
  %.sroa.3.0.insert.shift.i1352 = shl nuw i160 %.sroa.3.0.insert.ext.i1351, 128
  %.sroa.2.0.insert.ext.i = zext i64 %2508 to i160
  %.sroa.2.0.insert.shift.i = shl nuw nsw i160 %.sroa.2.0.insert.ext.i, 64
  %.sroa.2.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.shift.i, %.sroa.3.0.insert.shift.i1352
  %.sroa.0.0.insert.ext.i = zext i64 %2507 to i160
  %.sroa.0.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.insert.i, %.sroa.0.0.insert.ext.i
  %2509 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i, 1
  %2510 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2511 = load ptr, ptr %214, align 8
  %2512 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2511, 0
  %2513 = load ptr, ptr %215, align 8
  %2514 = insertvalue { ptr, ptr, ptr, i32 } %2512, ptr %2513, 1
  %2515 = load ptr, ptr %216, align 8
  %2516 = insertvalue { ptr, ptr, ptr, i32 } %2514, ptr %2515, 2
  %2517 = load i32, ptr %217, align 4
  %2518 = insertvalue { ptr, ptr, ptr, i32 } %2516, i32 %2517, 3
  %hash_coef_ptr.i.i218.i = getelementptr i8, ptr %2511, i64 8
  %tbl_size_ptr.i.i219.i = getelementptr i8, ptr %2511, i64 16
  %offset_tbl_ptr.i.i220.i = getelementptr i8, ptr %2511, i64 40
  %hash_coef.i.i221.i = load i64, ptr %hash_coef_ptr.i.i218.i, align 4
  %tbl_size.i.i222.i = load i64, ptr %tbl_size_ptr.i.i219.i, align 4
  %offset_tbl.i.i223.i = load ptr, ptr %offset_tbl_ptr.i.i220.i, align 8
  %product.i.i.i224.i = mul i64 %hash_coef.i.i221.i, -5261542750394134544
  %shifted.i.i.i225.i = lshr i64 %product.i.i.i224.i, 32
  %xored.i.i.i226.i = xor i64 %shifted.i.i.i225.i, %product.i.i.i224.i
  %hash.i.i.i227.i = and i64 %xored.i.i.i226.i, %tbl_size.i.i222.i
  %offset_ptr.i.i228.i = getelementptr i32, ptr %offset_tbl.i.i223.i, i64 %hash.i.i.i227.i
  %offset.i.i229.i = load i32, ptr %offset_ptr.i.i228.i, align 4
  %eq.i232.i = icmp eq i32 %2517, %offset.i.i229.i
  call void @llvm.assume(i1 %eq.i232.i) #30
  %2519 = load ptr, ptr %result.i130, align 8
  %2520 = load ptr, ptr %180, align 8
  %result.i233.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2521 = getelementptr i8, ptr %result.i233.i, i64 16
  store ptr %2520, ptr %2521, align 8
  %2522 = getelementptr i8, ptr %result.i233.i, i64 8
  store ptr %2519, ptr %2522, align 8
  %2523 = getelementptr i8, ptr %result.i233.i, i64 24
  store ptr null, ptr %2523, align 8
  %2524 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i)
  store ptr @Entry, ptr %result.i233.i, align 8
  store ptr @_parameterization_Ptri32, ptr %92, align 8
  store ptr %result.i233.i, ptr %266, align 8
  %2525 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %92)
  %2526 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2511)
  %2527 = sext i32 %2517 to i64
  %2528 = getelementptr ptr, ptr %2511, i64 %2527
  %2529 = getelementptr i8, ptr %2528, i64 128
  %2530 = load ptr, ptr %2529, align 8
  store ptr @i32_typ, ptr %93, align 8
  store ptr @Entry, ptr %267, align 8
  %2531 = call ptr %2530({ ptr, ptr, ptr, i32 } %2518, ptr nonnull %93)
  call void %2531({ ptr, ptr, ptr, i32 } %2518, { ptr, ptr, ptr, i32 } %2518, ptr nonnull %92, i32 %2489, { ptr, i160 } %2509)
  %2532 = icmp ne ptr %.fca.0.extract87.i, @nil_typ
  %2533 = icmp ne ptr %.fca.0.extract87.i, null
  %.not138.i = and i1 %2532, %2533
  br i1 %.not138.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %2452, %2388
  %.sink = phi { ptr, i160 } [ %2424, %2388 ], [ %2506, %2452 ]
  %2534 = phi i32 [ 2, %2388 ], [ 1, %2452 ]
  %vptr.i248.sroa.speculated.i = phi ptr [ %.fca.0.extract112.i, %2388 ], [ %.fca.0.extract87.i, %2452 ]
  %.fca.1.extract89.i = extractvalue { ptr, i160 } %.sink, 1
  %.sroa.3407.sroa.4.0.extract.shift.i = lshr i160 %.fca.1.extract89.i, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i = trunc i160 %.fca.1.extract89.i to i64
  %.sroa.speculated352.i = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i to ptr
  %.sroa.speculated346.i = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i to ptr
  %hash_coef_ptr.i.i249.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i250.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i251.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 40
  %hash_coef.i.i252.i = load i64, ptr %hash_coef_ptr.i.i249.i, align 4
  %tbl_size.i.i253.i = load i64, ptr %tbl_size_ptr.i.i250.i, align 4
  %offset_tbl.i.i254.i = load ptr, ptr %offset_tbl_ptr.i.i251.i, align 8
  %product.i.i.i255.i = mul i64 %hash_coef.i.i252.i, 4015701072841558310
  %shifted.i.i.i256.i = lshr i64 %product.i.i.i255.i, 32
  %xored.i.i.i257.i = xor i64 %shifted.i.i.i256.i, %product.i.i.i255.i
  %hash.i.i.i258.i = and i64 %xored.i.i.i257.i, %tbl_size.i.i253.i
  %offset_ptr.i.i259.i = getelementptr i32, ptr %offset_tbl.i.i254.i, i64 %hash.i.i.i258.i
  %offset.i.i260.i = load i32, ptr %offset_ptr.i.i259.i, align 4
  store ptr %vptr.i248.sroa.speculated.i, ptr %98, align 8
  store ptr %.sroa.speculated352.i, ptr %263, align 8
  store ptr %.sroa.speculated346.i, ptr %264, align 8
  store i32 %offset.i.i260.i, ptr %265, align 8
  %2535 = add nuw nsw i32 %.reg2mem193.0677.i, 1
  %2536 = load i32, ptr %220, align 4
  %2537 = icmp slt i32 %2535, %2536
  br i1 %2537, label %2378, label %._crit_edge1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %2388, %2452
  %2538 = phi ptr [ %94, %2452 ], [ %86, %2388 ]
  %2539 = phi ptr [ %95, %2452 ], [ %87, %2388 ]
  %2540 = phi ptr [ %96, %2452 ], [ %88, %2388 ]
  %2541 = phi ptr [ %.sroa.0.i1320, %2452 ], [ %.sroa.0680.i, %2388 ]
  %2542 = phi ptr [ %97, %2452 ], [ %89, %2388 ]
  %2543 = load i32, ptr %218, align 4
  store i32 %2543, ptr %2538, align 4
  store i32 1, ptr %2539, align 4
  %2544 = add i32 %2543, 1
  store i32 %2544, ptr %2540, align 4
  %2545 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %2544, ptr %218, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2542, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2541, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1320)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %98)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.i:                                   ; preds = %.cont.cont.i, %._crit_edge.i
  %2546 = load i160, ptr %263, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1320)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %98)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %76)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %77)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %78)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %79)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %80)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %81)
  %2547 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2548 = load ptr, ptr %197, align 8
  %2549 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2548, 0
  %2550 = load ptr, ptr %198, align 8
  %2551 = insertvalue { ptr, ptr, ptr, i32 } %2549, ptr %2550, 1
  %2552 = load ptr, ptr %199, align 8
  %2553 = insertvalue { ptr, ptr, ptr, i32 } %2551, ptr %2552, 2
  %2554 = load i32, ptr %200, align 4
  %2555 = insertvalue { ptr, ptr, ptr, i32 } %2553, i32 %2554, 3
  %hash_coef_ptr.i.i64.i1374 = getelementptr i8, ptr %2548, i64 8
  %tbl_size_ptr.i.i65.i1375 = getelementptr i8, ptr %2548, i64 16
  %offset_tbl_ptr.i.i66.i1376 = getelementptr i8, ptr %2548, i64 40
  %hash_coef.i.i67.i1377 = load i64, ptr %hash_coef_ptr.i.i64.i1374, align 4
  %tbl_size.i.i68.i1378 = load i64, ptr %tbl_size_ptr.i.i65.i1375, align 4
  %offset_tbl.i.i69.i1379 = load ptr, ptr %offset_tbl_ptr.i.i66.i1376, align 8
  %product.i.i.i70.i1380 = mul i64 %hash_coef.i.i67.i1377, -5261542750394134544
  %shifted.i.i.i71.i1381 = lshr i64 %product.i.i.i70.i1380, 32
  %xored.i.i.i72.i1382 = xor i64 %shifted.i.i.i71.i1381, %product.i.i.i70.i1380
  %hash.i.i.i73.i1383 = and i64 %xored.i.i.i72.i1382, %tbl_size.i.i68.i1378
  %offset_ptr.i.i74.i1384 = getelementptr i32, ptr %offset_tbl.i.i69.i1379, i64 %hash.i.i.i73.i1383
  %offset.i.i75.i1385 = load i32, ptr %offset_ptr.i.i74.i1384, align 4
  %eq.i.i1386 = icmp eq i32 %2554, %offset.i.i75.i1385
  call void @llvm.assume(i1 %eq.i.i1386) #30
  %2556 = load ptr, ptr %214, align 8
  %2557 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2556, 0
  %2558 = load ptr, ptr %215, align 8
  %2559 = insertvalue { ptr, ptr, ptr, i32 } %2557, ptr %2558, 1
  %2560 = load ptr, ptr %216, align 8
  %2561 = insertvalue { ptr, ptr, ptr, i32 } %2559, ptr %2560, 2
  %2562 = load i32, ptr %217, align 4
  %2563 = insertvalue { ptr, ptr, ptr, i32 } %2561, i32 %2562, 3
  %hash_coef_ptr.i.i92.i1391 = getelementptr i8, ptr %2556, i64 8
  %tbl_size_ptr.i.i93.i1392 = getelementptr i8, ptr %2556, i64 16
  %offset_tbl_ptr.i.i94.i1393 = getelementptr i8, ptr %2556, i64 40
  %hash_coef.i.i95.i1394 = load i64, ptr %hash_coef_ptr.i.i92.i1391, align 4
  %tbl_size.i.i96.i1395 = load i64, ptr %tbl_size_ptr.i.i93.i1392, align 4
  %offset_tbl.i.i97.i1396 = load ptr, ptr %offset_tbl_ptr.i.i94.i1393, align 8
  %product.i.i.i98.i1397 = mul i64 %hash_coef.i.i95.i1394, -5261542750394134544
  %shifted.i.i.i99.i1398 = lshr i64 %product.i.i.i98.i1397, 32
  %xored.i.i.i100.i1399 = xor i64 %shifted.i.i.i99.i1398, %product.i.i.i98.i1397
  %hash.i.i.i101.i1400 = and i64 %xored.i.i.i100.i1399, %tbl_size.i.i96.i1395
  %offset_ptr.i.i102.i1401 = getelementptr i32, ptr %offset_tbl.i.i97.i1396, i64 %hash.i.i.i101.i1400
  %offset.i.i103.i1402 = load i32, ptr %offset_ptr.i.i102.i1401, align 4
  %eq.i106.i1403 = icmp eq i32 %2562, %offset.i.i103.i1402
  call void @llvm.assume(i1 %eq.i106.i1403) #30
  %2564 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2565 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2548)
  %2566 = sext i32 %2554 to i64
  %2567 = getelementptr ptr, ptr %2548, i64 %2566
  %2568 = getelementptr i8, ptr %2567, i64 64
  %2569 = load ptr, ptr %2568, align 8
  %2570 = call ptr %2569({ ptr, ptr, ptr, i32 } %2555, ptr nonnull %2)
  %2571 = call i32 %2570({ ptr, ptr, ptr, i32 } %2555, { ptr, ptr, ptr, i32 } %2555, ptr nonnull %2)
  %2572 = shl i32 %2571, 1
  %2573 = load i32, ptr %218, align 4
  %2574 = load ptr, ptr %result.i130, align 8
  %2575 = load ptr, ptr %180, align 8
  %2576 = sext i32 %2573 to i64
  %2577 = shl nsw i64 %2576, 5
  %result.i.i.i1406 = call noalias ptr @bump_malloc_inner(i64 noundef %2577, ptr nonnull @current_ptr) #29
  %2578 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2579 = icmp sgt i32 %2571, 0
  br i1 %2579, label %.lr.ph434.i1476, label %._crit_edge395.i1420

.lr.ph434.i1476:                                  ; preds = %._crit_edge1.i
  %invariant.gep.i1419 = getelementptr i8, ptr %2548, i64 120
  %2580 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1479 = getelementptr ptr, ptr %invariant.gep.i1419, i64 %2566
  br label %2581

2581:                                             ; preds = %2603, %.lr.ph434.i1476
  %.reg2mem105.0432.i1477 = phi i32 [ 0, %.lr.ph434.i1476 ], [ %.reg2mem101.0.i1482, %2603 ]
  %.reg2mem103.0431.i1478 = phi i32 [ 0, %.lr.ph434.i1476 ], [ %2604, %2603 ]
  store ptr @_parameterization_Ptri32, ptr %76, align 8
  %2582 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %76)
  %2583 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2548)
  %2584 = load ptr, ptr %gep.i1479, align 8
  store ptr @i32_typ, ptr %77, align 8
  %2585 = call ptr %2584({ ptr, ptr, ptr, i32 } %2555, ptr nonnull %77)
  %2586 = call { ptr, i160 } %2585({ ptr, ptr, ptr, i32 } %2555, { ptr, ptr, ptr, i32 } %2555, ptr nonnull %76, i32 %.reg2mem103.0431.i1478)
  %.fca.0.extract52.i1480 = extractvalue { ptr, i160 } %2586, 0
  %2587 = icmp ne ptr %.fca.0.extract52.i1480, @nil_typ
  %2588 = icmp ne ptr %.fca.0.extract52.i1480, null
  %.not60.i1481 = and i1 %2587, %2588
  br i1 %.not60.i1481, label %2589, label %2603

2589:                                             ; preds = %2581
  %hash_coef_ptr.i.i137.i1509 = getelementptr i8, ptr %.fca.0.extract52.i1480, i64 8
  %tbl_size_ptr.i.i138.i1510 = getelementptr i8, ptr %.fca.0.extract52.i1480, i64 16
  %offset_tbl_ptr.i.i139.i1511 = getelementptr i8, ptr %.fca.0.extract52.i1480, i64 40
  %hash_coef.i.i140.i1512 = load i64, ptr %hash_coef_ptr.i.i137.i1509, align 4
  %tbl_size.i.i141.i1513 = load i64, ptr %tbl_size_ptr.i.i138.i1510, align 4
  %offset_tbl.i.i142.i1514 = load ptr, ptr %offset_tbl_ptr.i.i139.i1511, align 8
  %product.i.i.i143.i1515 = mul i64 %hash_coef.i.i140.i1512, 4015701072841558310
  %shifted.i.i.i144.i1516 = lshr i64 %product.i.i.i143.i1515, 32
  %xored.i.i.i145.i1517 = xor i64 %shifted.i.i.i144.i1516, %product.i.i.i143.i1515
  %hash.i.i.i146.i1518 = and i64 %xored.i.i.i145.i1517, %tbl_size.i.i141.i1513
  %offset_ptr.i.i147.i1519 = getelementptr i32, ptr %offset_tbl.i.i142.i1514, i64 %hash.i.i.i146.i1518
  %offset.i.i148.i1520 = load i32, ptr %offset_ptr.i.i147.i1519, align 4
  %2590 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2591 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2592 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2593 = icmp slt i32 %.reg2mem105.0432.i1477, %2573
  br i1 %2593, label %2594, label %._crit_edge.i1521

2594:                                             ; preds = %2589
  %.fca.1.extract54.i1522 = extractvalue { ptr, i160 } %2586, 1
  %.sroa.351.0.insert.ext.i1523 = zext i32 %offset.i.i148.i1520 to i160
  %.sroa.351.0.insert.shift.i1524 = shl nuw i160 %.sroa.351.0.insert.ext.i1523, 128
  %2595 = and i160 %.fca.1.extract54.i1522, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1525 = or disjoint i160 %.sroa.351.0.insert.shift.i1524, %2595
  %2596 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2597 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2598 = sext i32 %.reg2mem105.0432.i1477 to i64
  %2599 = shl nsw i64 %2598, 5
  %2600 = getelementptr i8, ptr %result.i.i.i1406, i64 %2599
  store ptr %.fca.0.extract52.i1480, ptr %2600, align 8
  %2601 = getelementptr i8, ptr %2600, i64 8
  store i160 %.sroa.049.0.insert.insert.i1525, ptr %2601, align 4
  br label %._crit_edge.i1521

._crit_edge.i1521:                                ; preds = %2594, %2589
  %2602 = add i32 %.reg2mem105.0432.i1477, 1
  br label %2603

2603:                                             ; preds = %._crit_edge.i1521, %2581
  %.reg2mem101.0.i1482 = phi i32 [ %2602, %._crit_edge.i1521 ], [ %.reg2mem105.0432.i1477, %2581 ]
  %2604 = add nuw nsw i32 %.reg2mem103.0431.i1478, 1
  %2605 = icmp slt i32 %2604, %2571
  br i1 %2605, label %2581, label %.lr.ph.i1483

.lr.ph.i1483:                                     ; preds = %2603
  %invariant.gep396.i1484 = getelementptr i8, ptr %2556, i64 120
  %2606 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2607 = sext i32 %2562 to i64
  %gep397.i1487 = getelementptr ptr, ptr %invariant.gep396.i1484, i64 %2607
  br label %2608

2608:                                             ; preds = %2630, %.lr.ph.i1483
  %.reg2mem91.0394.i1485 = phi i32 [ %.reg2mem101.0.i1482, %.lr.ph.i1483 ], [ %.reg2mem87.0.i1490, %2630 ]
  %.reg2mem89.0393.i1486 = phi i32 [ 0, %.lr.ph.i1483 ], [ %2631, %2630 ]
  store ptr @_parameterization_Ptri32, ptr %78, align 8
  %2609 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %78)
  %2610 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2556)
  %2611 = load ptr, ptr %gep397.i1487, align 8
  store ptr @i32_typ, ptr %79, align 8
  %2612 = call ptr %2611({ ptr, ptr, ptr, i32 } %2563, ptr nonnull %79)
  %2613 = call { ptr, i160 } %2612({ ptr, ptr, ptr, i32 } %2563, { ptr, ptr, ptr, i32 } %2563, ptr nonnull %78, i32 %.reg2mem89.0393.i1486)
  %.fca.0.extract42.i1488 = extractvalue { ptr, i160 } %2613, 0
  %2614 = icmp ne ptr %.fca.0.extract42.i1488, @nil_typ
  %2615 = icmp ne ptr %.fca.0.extract42.i1488, null
  %.not62.i1489 = and i1 %2614, %2615
  br i1 %.not62.i1489, label %2616, label %2630

2616:                                             ; preds = %2608
  %hash_coef_ptr.i.i152.i1491 = getelementptr i8, ptr %.fca.0.extract42.i1488, i64 8
  %tbl_size_ptr.i.i153.i1492 = getelementptr i8, ptr %.fca.0.extract42.i1488, i64 16
  %offset_tbl_ptr.i.i154.i1493 = getelementptr i8, ptr %.fca.0.extract42.i1488, i64 40
  %hash_coef.i.i155.i1494 = load i64, ptr %hash_coef_ptr.i.i152.i1491, align 4
  %tbl_size.i.i156.i1495 = load i64, ptr %tbl_size_ptr.i.i153.i1492, align 4
  %offset_tbl.i.i157.i1496 = load ptr, ptr %offset_tbl_ptr.i.i154.i1493, align 8
  %product.i.i.i158.i1497 = mul i64 %hash_coef.i.i155.i1494, 4015701072841558310
  %shifted.i.i.i159.i1498 = lshr i64 %product.i.i.i158.i1497, 32
  %xored.i.i.i160.i1499 = xor i64 %shifted.i.i.i159.i1498, %product.i.i.i158.i1497
  %hash.i.i.i161.i1500 = and i64 %xored.i.i.i160.i1499, %tbl_size.i.i156.i1495
  %offset_ptr.i.i162.i1501 = getelementptr i32, ptr %offset_tbl.i.i157.i1496, i64 %hash.i.i.i161.i1500
  %offset.i.i163.i1502 = load i32, ptr %offset_ptr.i.i162.i1501, align 4
  %2617 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2618 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2619 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2620 = icmp slt i32 %.reg2mem91.0394.i1485, %2573
  br i1 %2620, label %2621, label %._crit_edge1.i1503

2621:                                             ; preds = %2616
  %.fca.1.extract44.i1504 = extractvalue { ptr, i160 } %2613, 1
  %.sroa.3.0.insert.ext.i1505 = zext i32 %offset.i.i163.i1502 to i160
  %.sroa.3.0.insert.shift.i1506 = shl nuw i160 %.sroa.3.0.insert.ext.i1505, 128
  %2622 = and i160 %.fca.1.extract44.i1504, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1507 = or disjoint i160 %.sroa.3.0.insert.shift.i1506, %2622
  %2623 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2624 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2625 = sext i32 %.reg2mem91.0394.i1485 to i64
  %2626 = shl nsw i64 %2625, 5
  %2627 = getelementptr i8, ptr %result.i.i.i1406, i64 %2626
  store ptr %.fca.0.extract42.i1488, ptr %2627, align 8
  %2628 = getelementptr i8, ptr %2627, i64 8
  store i160 %.sroa.040.0.insert.insert.i1507, ptr %2628, align 4
  br label %._crit_edge1.i1503

._crit_edge1.i1503:                               ; preds = %2621, %2616
  %2629 = add i32 %.reg2mem91.0394.i1485, 1
  br label %2630

2630:                                             ; preds = %._crit_edge1.i1503, %2608
  %.reg2mem87.0.i1490 = phi i32 [ %2629, %._crit_edge1.i1503 ], [ %.reg2mem91.0394.i1485, %2608 ]
  %2631 = add nuw nsw i32 %.reg2mem89.0393.i1486, 1
  %2632 = icmp slt i32 %2631, %2571
  br i1 %2632, label %2608, label %._crit_edge395.i1420.loopexit

._crit_edge395.i1420.loopexit:                    ; preds = %2630
  %.pre3060 = load ptr, ptr %result.i130, align 8
  %.pre3061 = load ptr, ptr %180, align 8
  br label %._crit_edge395.i1420

._crit_edge395.i1420:                             ; preds = %._crit_edge395.i1420.loopexit, %._crit_edge1.i
  %2633 = phi ptr [ %2575, %._crit_edge1.i ], [ %.pre3061, %._crit_edge395.i1420.loopexit ]
  %2634 = phi ptr [ %2574, %._crit_edge1.i ], [ %.pre3060, %._crit_edge395.i1420.loopexit ]
  %.reg2mem91.0.lcssa.i1421 = phi i32 [ 0, %._crit_edge1.i ], [ %.reg2mem87.0.i1490, %._crit_edge395.i1420.loopexit ]
  %2635 = call i32 @llvm.smax.i32(i32 %2572, i32 16)
  %result.i166.i1422 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2636 = getelementptr i8, ptr %result.i166.i1422, i64 16
  store ptr @_parameterization_Nil, ptr %2636, align 8
  %result.i167.i1423 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2637 = getelementptr i8, ptr %result.i167.i1423, i64 16
  store ptr %2633, ptr %2637, align 8
  %2638 = getelementptr i8, ptr %result.i167.i1423, i64 8
  store ptr %2634, ptr %2638, align 8
  %2639 = getelementptr i8, ptr %result.i167.i1423, i64 24
  store ptr null, ptr %2639, align 8
  %2640 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1423)
  store ptr @Entry, ptr %result.i167.i1423, align 8
  %2641 = getelementptr i8, ptr %result.i166.i1422, i64 8
  store ptr %result.i167.i1423, ptr %2641, align 8
  %2642 = getelementptr i8, ptr %result.i166.i1422, i64 24
  store ptr null, ptr %2642, align 8
  %2643 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1422)
  store ptr @union_typ, ptr %result.i166.i1422, align 8
  %result.i168.i1424 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1422, ptr %result.i168.i1424, align 8
  %2644 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1424)
  store ptr @Array, ptr %80, align 8
  store ptr %result.i168.i1424, ptr %270, align 8
  store i32 9, ptr %271, align 8
  %2645 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %80)
  %2646 = getelementptr i8, ptr %result.i168.i1424, i64 16
  store i32 %2635, ptr %2646, align 4
  %2647 = getelementptr i8, ptr %result.i168.i1424, i64 20
  store i32 %2635, ptr %2647, align 4
  %2648 = zext nneg i32 %2635 to i64
  %2649 = shl nuw nsw i64 %2648, 5
  %result.i.i416.i1425 = call noalias ptr @bump_malloc_inner(i64 noundef %2649, ptr nonnull @current_ptr) #29
  %2650 = getelementptr i8, ptr %result.i168.i1424, i64 8
  store ptr %result.i.i416.i1425, ptr %2650, align 8
  %2651 = load ptr, ptr %272, align 8
  store ptr @Array, ptr %197, align 8
  store ptr %result.i168.i1424, ptr %198, align 8
  store ptr %2651, ptr %199, align 8
  store i32 9, ptr %200, align 4
  %2652 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i1438 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2653 = getelementptr i8, ptr %result.i183.i1438, i64 16
  store ptr @_parameterization_Nil, ptr %2653, align 8
  %result.i184.i1439 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2654 = getelementptr i8, ptr %result.i184.i1439, i64 16
  store ptr %2633, ptr %2654, align 8
  %2655 = getelementptr i8, ptr %result.i184.i1439, i64 8
  store ptr %2634, ptr %2655, align 8
  %2656 = getelementptr i8, ptr %result.i184.i1439, i64 24
  store ptr null, ptr %2656, align 8
  %2657 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1439)
  store ptr @Entry, ptr %result.i184.i1439, align 8
  %2658 = getelementptr i8, ptr %result.i183.i1438, i64 8
  store ptr %result.i184.i1439, ptr %2658, align 8
  %2659 = getelementptr i8, ptr %result.i183.i1438, i64 24
  store ptr null, ptr %2659, align 8
  %2660 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1438)
  store ptr @union_typ, ptr %result.i183.i1438, align 8
  %result.i185.i1440 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1438, ptr %result.i185.i1440, align 8
  %2661 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1440)
  store ptr @Array, ptr %81, align 8
  store ptr %result.i185.i1440, ptr %273, align 8
  store i32 9, ptr %274, align 8
  %2662 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %81)
  %2663 = getelementptr i8, ptr %result.i185.i1440, i64 16
  store i32 %2635, ptr %2663, align 4
  %2664 = getelementptr i8, ptr %result.i185.i1440, i64 20
  store i32 %2635, ptr %2664, align 4
  %result.i.i430.i1441 = call noalias ptr @bump_malloc_inner(i64 noundef %2649, ptr nonnull @current_ptr) #29
  %2665 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2666 = getelementptr i8, ptr %result.i185.i1440, i64 8
  store ptr %result.i.i430.i1441, ptr %2666, align 8
  %2667 = load ptr, ptr %275, align 8
  store ptr @Array, ptr %214, align 8
  store ptr %result.i185.i1440, ptr %215, align 8
  store ptr %2667, ptr %216, align 8
  store i32 9, ptr %217, align 4
  store i32 0, ptr %218, align 4
  %2668 = icmp sgt i32 %.reg2mem91.0.lcssa.i1421, 0
  br i1 %2668, label %.lr.ph400.i1454, label %HashMap_resize_.exit1527

.lr.ph400.i1454:                                  ; preds = %._crit_edge395.i1420
  %2669 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2670 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2671 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1456

._crit_edge2.i1456:                               ; preds = %._crit_edge2.i1456, %.lr.ph400.i1454
  %.reg2mem77.0398.i1457 = phi i32 [ 0, %.lr.ph400.i1454 ], [ %2685, %._crit_edge2.i1456 ]
  %2672 = zext nneg i32 %.reg2mem77.0398.i1457 to i64
  %2673 = shl nuw nsw i64 %2672, 5
  %2674 = getelementptr i8, ptr %result.i.i.i1406, i64 %2673
  %2675 = load ptr, ptr %2674, align 8
  %2676 = getelementptr i8, ptr %2674, i64 8
  %2677 = load i160, ptr %2676, align 4
  %.sroa.3362.8.extract.trunc.i1460 = trunc i160 %2677 to i64
  %2678 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1460 to ptr
  %.sroa.5363.8.extract.shift.i1461 = lshr i160 %2677, 64
  %.sroa.5363.8.extract.trunc.i1462 = trunc i160 %.sroa.5363.8.extract.shift.i1461 to i64
  %2679 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1462 to ptr
  %hash_coef_ptr.i.i201.i1463 = getelementptr i8, ptr %2675, i64 8
  %tbl_size_ptr.i.i202.i1464 = getelementptr i8, ptr %2675, i64 16
  %offset_tbl_ptr.i.i203.i1465 = getelementptr i8, ptr %2675, i64 40
  %hash_coef.i.i232.i1466 = load i64, ptr %hash_coef_ptr.i.i201.i1463, align 4
  %tbl_size.i.i233.i1467 = load i64, ptr %tbl_size_ptr.i.i202.i1464, align 4
  %offset_tbl.i.i234.i1468 = load ptr, ptr %offset_tbl_ptr.i.i203.i1465, align 8
  %product.i.i.i235.i1469 = mul i64 %hash_coef.i.i232.i1466, 4015701072841558310
  %shifted.i.i.i236.i1470 = lshr i64 %product.i.i.i235.i1469, 32
  %xored.i.i.i237.i1471 = xor i64 %shifted.i.i.i236.i1470, %product.i.i.i235.i1469
  %hash.i.i.i238.i1472 = and i64 %xored.i.i.i237.i1471, %tbl_size.i.i233.i1467
  %offset_ptr.i.i239.i1473 = getelementptr i32, ptr %offset_tbl.i.i234.i1468, i64 %hash.i.i.i238.i1472
  %offset.i.i240.i1474 = load i32, ptr %offset_ptr.i.i239.i1473, align 4
  %2680 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2675, 0
  %2681 = insertvalue { ptr, ptr, ptr, i32 } %2680, ptr %2678, 1
  %2682 = insertvalue { ptr, ptr, ptr, i32 } %2681, ptr %2679, 2
  %2683 = insertvalue { ptr, ptr, ptr, i32 } %2682, i32 %offset.i.i240.i1474, 3
  %2684 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %262, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2683)
  %2685 = add nuw nsw i32 %.reg2mem77.0398.i1457, 1
  %2686 = icmp slt i32 %2685, %.reg2mem91.0.lcssa.i1421
  br i1 %2686, label %._crit_edge2.i1456, label %HashMap_resize_.exit1527

HashMap_resize_.exit1527:                         ; preds = %._crit_edge2.i1456, %._crit_edge395.i1420
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %76)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %77)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %78)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %79)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %80)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %81)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i1528)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1530)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %75)
  %2687 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2688 = load i32, ptr %220, align 4
  %2689 = icmp sgt i32 %2688, 0
  br i1 %2689, label %.lr.ph.i1565, label %._crit_edge1.1.i

.lr.ph.i1565:                                     ; preds = %HashMap_resize_.exit1527
  %2690 = lshr i160 %2546, 64
  %2691 = insertelement <2 x i160> poison, i160 %2690, i64 0
  %2692 = insertelement <2 x i160> %2691, i160 %2546, i64 1
  %2693 = trunc <2 x i160> %2692 to <2 x i64>
  %2694 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2695 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %2696

2696:                                             ; preds = %.cont.cont.i1619, %.lr.ph.i1565
  %offset.i.i260.i16362064 = phi i32 [ 9, %.lr.ph.i1565 ], [ %offset.i.i260.i1636, %.cont.cont.i1619 ]
  %.reg2mem195.0678.i1567 = phi i32 [ 1, %.lr.ph.i1565 ], [ %2851, %.cont.cont.i1619 ]
  %.reg2mem193.0677.i1568 = phi i32 [ 0, %.lr.ph.i1565 ], [ %2856, %.cont.cont.i1619 ]
  %2697 = phi <2 x i64> [ %2693, %.lr.ph.i1565 ], [ %2855, %.cont.cont.i1619 ]
  %2698 = extractelement <2 x i64> %2697, i64 1
  %.sroa.speculated352.i16232060 = inttoptr i64 %2698 to ptr
  %2699 = extractelement <2 x i64> %2697, i64 0
  %.sroa.speculated346.i16242062 = inttoptr i64 %2699 to ptr
  %2700 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i16232060, 1
  %2701 = insertvalue { ptr, ptr, ptr, i32 } %2700, ptr %.sroa.speculated346.i16242062, 2
  %2702 = insertvalue { ptr, ptr, ptr, i32 } %2701, i32 %offset.i.i260.i16362064, 3
  %2703 = sext i32 %offset.i.i260.i16362064 to i64
  %gep2058 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %2703
  %2704 = load ptr, ptr %gep2058, align 8
  %2705 = call ptr %2704({ ptr, ptr, ptr, i32 } %2702, ptr nonnull %2)
  %2706 = call i32 %2705({ ptr, ptr, ptr, i32 } %2702, { ptr, ptr, ptr, i32 } %2702, ptr nonnull %2)
  %2707 = icmp eq i32 %.reg2mem195.0678.i1567, 1
  %2708 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %2707, label %2709, label %2771

2709:                                             ; preds = %2696
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2710 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2711 = load ptr, ptr %197, align 8
  %2712 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2711, 0
  %2713 = load ptr, ptr %198, align 8
  %2714 = insertvalue { ptr, ptr, ptr, i32 } %2712, ptr %2713, 1
  %2715 = load ptr, ptr %199, align 8
  %2716 = insertvalue { ptr, ptr, ptr, i32 } %2714, ptr %2715, 2
  %2717 = load i32, ptr %200, align 4
  %2718 = insertvalue { ptr, ptr, ptr, i32 } %2716, i32 %2717, 3
  %hash_coef_ptr.i.i10.i3285 = getelementptr i8, ptr %2711, i64 8
  %tbl_size_ptr.i.i11.i3286 = getelementptr i8, ptr %2711, i64 16
  %offset_tbl_ptr.i.i12.i3287 = getelementptr i8, ptr %2711, i64 40
  %hash_coef.i.i13.i3288 = load i64, ptr %hash_coef_ptr.i.i10.i3285, align 4
  %tbl_size.i.i14.i3289 = load i64, ptr %tbl_size_ptr.i.i11.i3286, align 4
  %offset_tbl.i.i15.i3290 = load ptr, ptr %offset_tbl_ptr.i.i12.i3287, align 8
  %product.i.i.i16.i3291 = mul i64 %hash_coef.i.i13.i3288, -5261542750394134544
  %shifted.i.i.i17.i3292 = lshr i64 %product.i.i.i16.i3291, 32
  %xored.i.i.i18.i3293 = xor i64 %shifted.i.i.i17.i3292, %product.i.i.i16.i3291
  %hash.i.i.i19.i3294 = and i64 %xored.i.i.i18.i3293, %tbl_size.i.i14.i3289
  %offset_ptr.i.i20.i3295 = getelementptr i32, ptr %offset_tbl.i.i15.i3290, i64 %hash.i.i.i19.i3294
  %offset.i.i21.i3296 = load i32, ptr %offset_ptr.i.i20.i3295, align 4
  %eq.i.i3297 = icmp eq i32 %2717, %offset.i.i21.i3296
  call void @llvm.assume(i1 %eq.i.i3297) #30
  %2719 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2720 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2711)
  %2721 = sext i32 %2717 to i64
  %2722 = getelementptr ptr, ptr %2711, i64 %2721
  %2723 = getelementptr i8, ptr %2722, i64 64
  %2724 = load ptr, ptr %2723, align 8
  %2725 = call ptr %2724({ ptr, ptr, ptr, i32 } %2718, ptr nonnull %2)
  %2726 = call i32 %2725({ ptr, ptr, ptr, i32 } %2718, { ptr, ptr, ptr, i32 } %2718, ptr nonnull %2)
  %2727 = add i32 %2726, -1
  %2728 = and i32 %2727, %2706
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2729 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2730 = load ptr, ptr %197, align 8
  %2731 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2730, 0
  %2732 = load ptr, ptr %198, align 8
  %2733 = insertvalue { ptr, ptr, ptr, i32 } %2731, ptr %2732, 1
  %2734 = load ptr, ptr %199, align 8
  %2735 = insertvalue { ptr, ptr, ptr, i32 } %2733, ptr %2734, 2
  %2736 = load i32, ptr %200, align 4
  %2737 = insertvalue { ptr, ptr, ptr, i32 } %2735, i32 %2736, 3
  %hash_coef_ptr.i.i172.i1641 = getelementptr i8, ptr %2730, i64 8
  %tbl_size_ptr.i.i173.i1642 = getelementptr i8, ptr %2730, i64 16
  %offset_tbl_ptr.i.i174.i1643 = getelementptr i8, ptr %2730, i64 40
  %hash_coef.i.i175.i1644 = load i64, ptr %hash_coef_ptr.i.i172.i1641, align 4
  %tbl_size.i.i176.i1645 = load i64, ptr %tbl_size_ptr.i.i173.i1642, align 4
  %offset_tbl.i.i177.i1646 = load ptr, ptr %offset_tbl_ptr.i.i174.i1643, align 8
  %product.i.i.i178.i1647 = mul i64 %hash_coef.i.i175.i1644, -5261542750394134544
  %shifted.i.i.i179.i1648 = lshr i64 %product.i.i.i178.i1647, 32
  %xored.i.i.i180.i1649 = xor i64 %shifted.i.i.i179.i1648, %product.i.i.i178.i1647
  %hash.i.i.i181.i1650 = and i64 %xored.i.i.i180.i1649, %tbl_size.i.i176.i1645
  %offset_ptr.i.i182.i1651 = getelementptr i32, ptr %offset_tbl.i.i177.i1646, i64 %hash.i.i.i181.i1650
  %offset.i.i183.i1652 = load i32, ptr %offset_ptr.i.i182.i1651, align 4
  %eq.i.i1653 = icmp eq i32 %2736, %offset.i.i183.i1652
  call void @llvm.assume(i1 %eq.i.i1653) #30
  store ptr @_parameterization_Ptri32, ptr %60, align 8
  %2738 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %60)
  %2739 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2730)
  %2740 = sext i32 %2736 to i64
  %2741 = getelementptr ptr, ptr %2730, i64 %2740
  %2742 = getelementptr i8, ptr %2741, i64 120
  %2743 = load ptr, ptr %2742, align 8
  store ptr @i32_typ, ptr %61, align 8
  %2744 = call ptr %2743({ ptr, ptr, ptr, i32 } %2737, ptr nonnull %61)
  %2745 = call { ptr, i160 } %2744({ ptr, ptr, ptr, i32 } %2737, { ptr, ptr, ptr, i32 } %2737, ptr nonnull %60, i32 %2728)
  %.fca.0.extract112.i1654 = extractvalue { ptr, i160 } %2745, 0
  %.sroa.3111.0.insert.ext.i1655 = zext i32 %offset.i.i260.i16362064 to i160
  %.sroa.3111.0.insert.shift.i1656 = shl nuw i160 %.sroa.3111.0.insert.ext.i1655, 128
  %.sroa.2110.0.insert.ext.i1657 = zext i64 %2699 to i160
  %.sroa.2110.0.insert.shift.i1658 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i1657, 64
  %.sroa.2110.0.insert.insert.i1659 = or disjoint i160 %.sroa.2110.0.insert.shift.i1658, %.sroa.3111.0.insert.shift.i1656
  %.sroa.0109.0.insert.ext.i1660 = zext i64 %2698 to i160
  %.sroa.0109.0.insert.insert.i1661 = or disjoint i160 %.sroa.2110.0.insert.insert.i1659, %.sroa.0109.0.insert.ext.i1660
  %2746 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i1661, 1
  %2747 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2748 = load ptr, ptr %197, align 8
  %2749 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2748, 0
  %2750 = load ptr, ptr %198, align 8
  %2751 = insertvalue { ptr, ptr, ptr, i32 } %2749, ptr %2750, 1
  %2752 = load ptr, ptr %199, align 8
  %2753 = insertvalue { ptr, ptr, ptr, i32 } %2751, ptr %2752, 2
  %2754 = load i32, ptr %200, align 4
  %2755 = insertvalue { ptr, ptr, ptr, i32 } %2753, i32 %2754, 3
  %hash_coef_ptr.i.i186.i1666 = getelementptr i8, ptr %2748, i64 8
  %tbl_size_ptr.i.i187.i1667 = getelementptr i8, ptr %2748, i64 16
  %offset_tbl_ptr.i.i188.i1668 = getelementptr i8, ptr %2748, i64 40
  %hash_coef.i.i189.i1669 = load i64, ptr %hash_coef_ptr.i.i186.i1666, align 4
  %tbl_size.i.i190.i1670 = load i64, ptr %tbl_size_ptr.i.i187.i1667, align 4
  %offset_tbl.i.i191.i1671 = load ptr, ptr %offset_tbl_ptr.i.i188.i1668, align 8
  %product.i.i.i192.i1672 = mul i64 %hash_coef.i.i189.i1669, -5261542750394134544
  %shifted.i.i.i193.i1673 = lshr i64 %product.i.i.i192.i1672, 32
  %xored.i.i.i194.i1674 = xor i64 %shifted.i.i.i193.i1673, %product.i.i.i192.i1672
  %hash.i.i.i195.i1675 = and i64 %xored.i.i.i194.i1674, %tbl_size.i.i190.i1670
  %offset_ptr.i.i196.i1676 = getelementptr i32, ptr %offset_tbl.i.i191.i1671, i64 %hash.i.i.i195.i1675
  %offset.i.i197.i1677 = load i32, ptr %offset_ptr.i.i196.i1676, align 4
  %eq.i200.i1678 = icmp eq i32 %2754, %offset.i.i197.i1677
  call void @llvm.assume(i1 %eq.i200.i1678) #30
  %2756 = load ptr, ptr %result.i130, align 8
  %2757 = load ptr, ptr %180, align 8
  %result.i.i1679 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2758 = getelementptr i8, ptr %result.i.i1679, i64 16
  store ptr %2757, ptr %2758, align 8
  %2759 = getelementptr i8, ptr %result.i.i1679, i64 8
  store ptr %2756, ptr %2759, align 8
  %2760 = getelementptr i8, ptr %result.i.i1679, i64 24
  store ptr null, ptr %2760, align 8
  %2761 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1679)
  store ptr @Entry, ptr %result.i.i1679, align 8
  store ptr @_parameterization_Ptri32, ptr %62, align 8
  store ptr %result.i.i1679, ptr %278, align 8
  %2762 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %62)
  %2763 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2748)
  %2764 = sext i32 %2754 to i64
  %2765 = getelementptr ptr, ptr %2748, i64 %2764
  %2766 = getelementptr i8, ptr %2765, i64 128
  %2767 = load ptr, ptr %2766, align 8
  store ptr @i32_typ, ptr %63, align 8
  store ptr @Entry, ptr %279, align 8
  %2768 = call ptr %2767({ ptr, ptr, ptr, i32 } %2755, ptr nonnull %63)
  call void %2768({ ptr, ptr, ptr, i32 } %2755, { ptr, ptr, ptr, i32 } %2755, ptr nonnull %62, i32 %2728, { ptr, i160 } %2746)
  %2769 = icmp ne ptr %.fca.0.extract112.i1654, @nil_typ
  %2770 = icmp ne ptr %.fca.0.extract112.i1654, null
  %.not140.i1680 = and i1 %2769, %2770
  br i1 %.not140.i1680, label %.cont.cont.i1619, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1686.thread

2771:                                             ; preds = %2696
  %2772 = add i32 %2706, 2127912214
  %2773 = shl i32 %2706, 12
  %2774 = add i32 %2772, %2773
  %2775 = ashr i32 %2774, 19
  %2776 = xor i32 %2774, %2775
  %2777 = xor i32 %2776, -949894596
  %2778 = add i32 %2777, 374761393
  %2779 = shl i32 %2777, 5
  %2780 = add i32 %2778, %2779
  %2781 = add i32 %2780, -744332180
  %2782 = shl i32 %2780, 9
  %2783 = xor i32 %2781, %2782
  %2784 = add i32 %2783, -42973499
  %2785 = shl i32 %2783, 3
  %2786 = add i32 %2784, %2785
  %2787 = ashr i32 %2786, 16
  %2788 = xor i32 %2786, %2787
  %2789 = xor i32 %2788, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2790 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2791 = load ptr, ptr %214, align 8
  %2792 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2791, 0
  %2793 = load ptr, ptr %215, align 8
  %2794 = insertvalue { ptr, ptr, ptr, i32 } %2792, ptr %2793, 1
  %2795 = load ptr, ptr %216, align 8
  %2796 = insertvalue { ptr, ptr, ptr, i32 } %2794, ptr %2795, 2
  %2797 = load i32, ptr %217, align 4
  %2798 = insertvalue { ptr, ptr, ptr, i32 } %2796, i32 %2797, 3
  %hash_coef_ptr.i.i10.i3315 = getelementptr i8, ptr %2791, i64 8
  %tbl_size_ptr.i.i11.i3316 = getelementptr i8, ptr %2791, i64 16
  %offset_tbl_ptr.i.i12.i3317 = getelementptr i8, ptr %2791, i64 40
  %hash_coef.i.i13.i3318 = load i64, ptr %hash_coef_ptr.i.i10.i3315, align 4
  %tbl_size.i.i14.i3319 = load i64, ptr %tbl_size_ptr.i.i11.i3316, align 4
  %offset_tbl.i.i15.i3320 = load ptr, ptr %offset_tbl_ptr.i.i12.i3317, align 8
  %product.i.i.i16.i3321 = mul i64 %hash_coef.i.i13.i3318, -5261542750394134544
  %shifted.i.i.i17.i3322 = lshr i64 %product.i.i.i16.i3321, 32
  %xored.i.i.i18.i3323 = xor i64 %shifted.i.i.i17.i3322, %product.i.i.i16.i3321
  %hash.i.i.i19.i3324 = and i64 %xored.i.i.i18.i3323, %tbl_size.i.i14.i3319
  %offset_ptr.i.i20.i3325 = getelementptr i32, ptr %offset_tbl.i.i15.i3320, i64 %hash.i.i.i19.i3324
  %offset.i.i21.i3326 = load i32, ptr %offset_ptr.i.i20.i3325, align 4
  %eq.i.i3327 = icmp eq i32 %2797, %offset.i.i21.i3326
  call void @llvm.assume(i1 %eq.i.i3327) #30
  %2799 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2800 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2791)
  %2801 = sext i32 %2797 to i64
  %2802 = getelementptr ptr, ptr %2791, i64 %2801
  %2803 = getelementptr i8, ptr %2802, i64 64
  %2804 = load ptr, ptr %2803, align 8
  %2805 = call ptr %2804({ ptr, ptr, ptr, i32 } %2798, ptr nonnull %2)
  %2806 = call i32 %2805({ ptr, ptr, ptr, i32 } %2798, { ptr, ptr, ptr, i32 } %2798, ptr nonnull %2)
  %2807 = add i32 %2806, -1
  %2808 = and i32 %2807, %2789
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2809 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2810 = load ptr, ptr %214, align 8
  %2811 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2810, 0
  %2812 = load ptr, ptr %215, align 8
  %2813 = insertvalue { ptr, ptr, ptr, i32 } %2811, ptr %2812, 1
  %2814 = load ptr, ptr %216, align 8
  %2815 = insertvalue { ptr, ptr, ptr, i32 } %2813, ptr %2814, 2
  %2816 = load i32, ptr %217, align 4
  %2817 = insertvalue { ptr, ptr, ptr, i32 } %2815, i32 %2816, 3
  %hash_coef_ptr.i.i202.i1573 = getelementptr i8, ptr %2810, i64 8
  %tbl_size_ptr.i.i203.i1574 = getelementptr i8, ptr %2810, i64 16
  %offset_tbl_ptr.i.i204.i1575 = getelementptr i8, ptr %2810, i64 40
  %hash_coef.i.i205.i1576 = load i64, ptr %hash_coef_ptr.i.i202.i1573, align 4
  %tbl_size.i.i206.i1577 = load i64, ptr %tbl_size_ptr.i.i203.i1574, align 4
  %offset_tbl.i.i207.i1578 = load ptr, ptr %offset_tbl_ptr.i.i204.i1575, align 8
  %product.i.i.i208.i1579 = mul i64 %hash_coef.i.i205.i1576, -5261542750394134544
  %shifted.i.i.i209.i1580 = lshr i64 %product.i.i.i208.i1579, 32
  %xored.i.i.i210.i1581 = xor i64 %shifted.i.i.i209.i1580, %product.i.i.i208.i1579
  %hash.i.i.i211.i1582 = and i64 %xored.i.i.i210.i1581, %tbl_size.i.i206.i1577
  %offset_ptr.i.i212.i1583 = getelementptr i32, ptr %offset_tbl.i.i207.i1578, i64 %hash.i.i.i211.i1582
  %offset.i.i213.i1584 = load i32, ptr %offset_ptr.i.i212.i1583, align 4
  %eq.i216.i1585 = icmp eq i32 %2816, %offset.i.i213.i1584
  call void @llvm.assume(i1 %eq.i216.i1585) #30
  store ptr @_parameterization_Ptri32, ptr %68, align 8
  %2818 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %68)
  %2819 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2810)
  %2820 = sext i32 %2816 to i64
  %2821 = getelementptr ptr, ptr %2810, i64 %2820
  %2822 = getelementptr i8, ptr %2821, i64 120
  %2823 = load ptr, ptr %2822, align 8
  store ptr @i32_typ, ptr %69, align 8
  %2824 = call ptr %2823({ ptr, ptr, ptr, i32 } %2817, ptr nonnull %69)
  %2825 = call { ptr, i160 } %2824({ ptr, ptr, ptr, i32 } %2817, { ptr, ptr, ptr, i32 } %2817, ptr nonnull %68, i32 %2808)
  %.fca.0.extract87.i1586 = extractvalue { ptr, i160 } %2825, 0
  %.sroa.3.0.insert.ext.i1587 = zext i32 %offset.i.i260.i16362064 to i160
  %.sroa.3.0.insert.shift.i1588 = shl nuw i160 %.sroa.3.0.insert.ext.i1587, 128
  %.sroa.2.0.insert.ext.i1589 = zext i64 %2699 to i160
  %.sroa.2.0.insert.shift.i1590 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i1589, 64
  %.sroa.2.0.insert.insert.i1591 = or disjoint i160 %.sroa.2.0.insert.shift.i1590, %.sroa.3.0.insert.shift.i1588
  %.sroa.0.0.insert.ext.i1592 = zext i64 %2698 to i160
  %.sroa.0.0.insert.insert.i1593 = or disjoint i160 %.sroa.2.0.insert.insert.i1591, %.sroa.0.0.insert.ext.i1592
  %2826 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i1593, 1
  %2827 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2828 = load ptr, ptr %214, align 8
  %2829 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2828, 0
  %2830 = load ptr, ptr %215, align 8
  %2831 = insertvalue { ptr, ptr, ptr, i32 } %2829, ptr %2830, 1
  %2832 = load ptr, ptr %216, align 8
  %2833 = insertvalue { ptr, ptr, ptr, i32 } %2831, ptr %2832, 2
  %2834 = load i32, ptr %217, align 4
  %2835 = insertvalue { ptr, ptr, ptr, i32 } %2833, i32 %2834, 3
  %hash_coef_ptr.i.i218.i1598 = getelementptr i8, ptr %2828, i64 8
  %tbl_size_ptr.i.i219.i1599 = getelementptr i8, ptr %2828, i64 16
  %offset_tbl_ptr.i.i220.i1600 = getelementptr i8, ptr %2828, i64 40
  %hash_coef.i.i221.i1601 = load i64, ptr %hash_coef_ptr.i.i218.i1598, align 4
  %tbl_size.i.i222.i1602 = load i64, ptr %tbl_size_ptr.i.i219.i1599, align 4
  %offset_tbl.i.i223.i1603 = load ptr, ptr %offset_tbl_ptr.i.i220.i1600, align 8
  %product.i.i.i224.i1604 = mul i64 %hash_coef.i.i221.i1601, -5261542750394134544
  %shifted.i.i.i225.i1605 = lshr i64 %product.i.i.i224.i1604, 32
  %xored.i.i.i226.i1606 = xor i64 %shifted.i.i.i225.i1605, %product.i.i.i224.i1604
  %hash.i.i.i227.i1607 = and i64 %xored.i.i.i226.i1606, %tbl_size.i.i222.i1602
  %offset_ptr.i.i228.i1608 = getelementptr i32, ptr %offset_tbl.i.i223.i1603, i64 %hash.i.i.i227.i1607
  %offset.i.i229.i1609 = load i32, ptr %offset_ptr.i.i228.i1608, align 4
  %eq.i232.i1610 = icmp eq i32 %2834, %offset.i.i229.i1609
  call void @llvm.assume(i1 %eq.i232.i1610) #30
  %2836 = load ptr, ptr %result.i130, align 8
  %2837 = load ptr, ptr %180, align 8
  %result.i233.i1611 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2838 = getelementptr i8, ptr %result.i233.i1611, i64 16
  store ptr %2837, ptr %2838, align 8
  %2839 = getelementptr i8, ptr %result.i233.i1611, i64 8
  store ptr %2836, ptr %2839, align 8
  %2840 = getelementptr i8, ptr %result.i233.i1611, i64 24
  store ptr null, ptr %2840, align 8
  %2841 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i1611)
  store ptr @Entry, ptr %result.i233.i1611, align 8
  store ptr @_parameterization_Ptri32, ptr %70, align 8
  store ptr %result.i233.i1611, ptr %276, align 8
  %2842 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %70)
  %2843 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2828)
  %2844 = sext i32 %2834 to i64
  %2845 = getelementptr ptr, ptr %2828, i64 %2844
  %2846 = getelementptr i8, ptr %2845, i64 128
  %2847 = load ptr, ptr %2846, align 8
  store ptr @i32_typ, ptr %71, align 8
  store ptr @Entry, ptr %277, align 8
  %2848 = call ptr %2847({ ptr, ptr, ptr, i32 } %2835, ptr nonnull %71)
  call void %2848({ ptr, ptr, ptr, i32 } %2835, { ptr, ptr, ptr, i32 } %2835, ptr nonnull %70, i32 %2808, { ptr, i160 } %2826)
  %2849 = icmp ne ptr %.fca.0.extract87.i1586, @nil_typ
  %2850 = icmp ne ptr %.fca.0.extract87.i1586, null
  %.not138.i1612 = and i1 %2849, %2850
  br i1 %.not138.i1612, label %.cont.cont.i1619, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1686.thread

.cont.cont.i1619:                                 ; preds = %2771, %2709
  %.sink2075 = phi { ptr, i160 } [ %2745, %2709 ], [ %2825, %2771 ]
  %2851 = phi i32 [ 2, %2709 ], [ 1, %2771 ]
  %vptr.i248.sroa.speculated.i1622 = phi ptr [ %.fca.0.extract112.i1654, %2709 ], [ %.fca.0.extract87.i1586, %2771 ]
  %.fca.1.extract89.i1615 = extractvalue { ptr, i160 } %.sink2075, 1
  %.sroa.3407.sroa.4.0.extract.shift.i1616 = lshr i160 %.fca.1.extract89.i1615, 64
  %2852 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i1616 to i64
  %2853 = insertelement <2 x i64> poison, i64 %2852, i64 0
  %2854 = trunc i160 %.fca.1.extract89.i1615 to i64
  %2855 = insertelement <2 x i64> %2853, i64 %2854, i64 1
  %hash_coef_ptr.i.i249.i1625 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1622, i64 8
  %tbl_size_ptr.i.i250.i1626 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1622, i64 16
  %offset_tbl_ptr.i.i251.i1627 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1622, i64 40
  %hash_coef.i.i252.i1628 = load i64, ptr %hash_coef_ptr.i.i249.i1625, align 4
  %tbl_size.i.i253.i1629 = load i64, ptr %tbl_size_ptr.i.i250.i1626, align 4
  %offset_tbl.i.i254.i1630 = load ptr, ptr %offset_tbl_ptr.i.i251.i1627, align 8
  %product.i.i.i255.i1631 = mul i64 %hash_coef.i.i252.i1628, 4015701072841558310
  %shifted.i.i.i256.i1632 = lshr i64 %product.i.i.i255.i1631, 32
  %xored.i.i.i257.i1633 = xor i64 %shifted.i.i.i256.i1632, %product.i.i.i255.i1631
  %hash.i.i.i258.i1634 = and i64 %xored.i.i.i257.i1633, %tbl_size.i.i253.i1629
  %offset_ptr.i.i259.i1635 = getelementptr i32, ptr %offset_tbl.i.i254.i1630, i64 %hash.i.i.i258.i1634
  %offset.i.i260.i1636 = load i32, ptr %offset_ptr.i.i259.i1635, align 4
  %2856 = add nuw nsw i32 %.reg2mem193.0677.i1568, 1
  %2857 = load i32, ptr %220, align 4
  %2858 = icmp slt i32 %2856, %2857
  br i1 %2858, label %2696, label %._crit_edge1.1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1686.thread: ; preds = %2709, %2771
  %2859 = phi ptr [ %72, %2771 ], [ %64, %2709 ]
  %2860 = phi ptr [ %73, %2771 ], [ %65, %2709 ]
  %2861 = phi ptr [ %74, %2771 ], [ %66, %2709 ]
  %2862 = phi ptr [ %.sroa.0.i1530, %2771 ], [ %.sroa.0680.i1528, %2709 ]
  %2863 = phi ptr [ %75, %2771 ], [ %67, %2709 ]
  %2864 = load i32, ptr %218, align 4
  store i32 %2864, ptr %2859, align 4
  store i32 1, ptr %2860, align 4
  %2865 = add i32 %2864, 1
  store i32 %2865, ptr %2861, align 4
  %2866 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %2865, ptr %218, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2863, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2862, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1528)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1530)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %75)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.1.i:                                 ; preds = %.cont.cont.i1619, %HashMap_resize_.exit1527
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1528)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1530)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %75)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %57)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %59)
  %2867 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2868 = load ptr, ptr %197, align 8
  %2869 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2868, 0
  %2870 = load ptr, ptr %198, align 8
  %2871 = insertvalue { ptr, ptr, ptr, i32 } %2869, ptr %2870, 1
  %2872 = load ptr, ptr %199, align 8
  %2873 = insertvalue { ptr, ptr, ptr, i32 } %2871, ptr %2872, 2
  %2874 = load i32, ptr %200, align 4
  %2875 = insertvalue { ptr, ptr, ptr, i32 } %2873, i32 %2874, 3
  %hash_coef_ptr.i.i64.i1704 = getelementptr i8, ptr %2868, i64 8
  %tbl_size_ptr.i.i65.i1705 = getelementptr i8, ptr %2868, i64 16
  %offset_tbl_ptr.i.i66.i1706 = getelementptr i8, ptr %2868, i64 40
  %hash_coef.i.i67.i1707 = load i64, ptr %hash_coef_ptr.i.i64.i1704, align 4
  %tbl_size.i.i68.i1708 = load i64, ptr %tbl_size_ptr.i.i65.i1705, align 4
  %offset_tbl.i.i69.i1709 = load ptr, ptr %offset_tbl_ptr.i.i66.i1706, align 8
  %product.i.i.i70.i1710 = mul i64 %hash_coef.i.i67.i1707, -5261542750394134544
  %shifted.i.i.i71.i1711 = lshr i64 %product.i.i.i70.i1710, 32
  %xored.i.i.i72.i1712 = xor i64 %shifted.i.i.i71.i1711, %product.i.i.i70.i1710
  %hash.i.i.i73.i1713 = and i64 %xored.i.i.i72.i1712, %tbl_size.i.i68.i1708
  %offset_ptr.i.i74.i1714 = getelementptr i32, ptr %offset_tbl.i.i69.i1709, i64 %hash.i.i.i73.i1713
  %offset.i.i75.i1715 = load i32, ptr %offset_ptr.i.i74.i1714, align 4
  %eq.i.i1716 = icmp eq i32 %2874, %offset.i.i75.i1715
  call void @llvm.assume(i1 %eq.i.i1716) #30
  %2876 = load ptr, ptr %214, align 8
  %2877 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2876, 0
  %2878 = load ptr, ptr %215, align 8
  %2879 = insertvalue { ptr, ptr, ptr, i32 } %2877, ptr %2878, 1
  %2880 = load ptr, ptr %216, align 8
  %2881 = insertvalue { ptr, ptr, ptr, i32 } %2879, ptr %2880, 2
  %2882 = load i32, ptr %217, align 4
  %2883 = insertvalue { ptr, ptr, ptr, i32 } %2881, i32 %2882, 3
  %hash_coef_ptr.i.i92.i1721 = getelementptr i8, ptr %2876, i64 8
  %tbl_size_ptr.i.i93.i1722 = getelementptr i8, ptr %2876, i64 16
  %offset_tbl_ptr.i.i94.i1723 = getelementptr i8, ptr %2876, i64 40
  %hash_coef.i.i95.i1724 = load i64, ptr %hash_coef_ptr.i.i92.i1721, align 4
  %tbl_size.i.i96.i1725 = load i64, ptr %tbl_size_ptr.i.i93.i1722, align 4
  %offset_tbl.i.i97.i1726 = load ptr, ptr %offset_tbl_ptr.i.i94.i1723, align 8
  %product.i.i.i98.i1727 = mul i64 %hash_coef.i.i95.i1724, -5261542750394134544
  %shifted.i.i.i99.i1728 = lshr i64 %product.i.i.i98.i1727, 32
  %xored.i.i.i100.i1729 = xor i64 %shifted.i.i.i99.i1728, %product.i.i.i98.i1727
  %hash.i.i.i101.i1730 = and i64 %xored.i.i.i100.i1729, %tbl_size.i.i96.i1725
  %offset_ptr.i.i102.i1731 = getelementptr i32, ptr %offset_tbl.i.i97.i1726, i64 %hash.i.i.i101.i1730
  %offset.i.i103.i1732 = load i32, ptr %offset_ptr.i.i102.i1731, align 4
  %eq.i106.i1733 = icmp eq i32 %2882, %offset.i.i103.i1732
  call void @llvm.assume(i1 %eq.i106.i1733) #30
  %2884 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2885 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2868)
  %2886 = sext i32 %2874 to i64
  %2887 = getelementptr ptr, ptr %2868, i64 %2886
  %2888 = getelementptr i8, ptr %2887, i64 64
  %2889 = load ptr, ptr %2888, align 8
  %2890 = call ptr %2889({ ptr, ptr, ptr, i32 } %2875, ptr nonnull %2)
  %2891 = call i32 %2890({ ptr, ptr, ptr, i32 } %2875, { ptr, ptr, ptr, i32 } %2875, ptr nonnull %2)
  %2892 = shl i32 %2891, 1
  %2893 = load i32, ptr %218, align 4
  %2894 = load ptr, ptr %result.i130, align 8
  %2895 = load ptr, ptr %180, align 8
  %2896 = sext i32 %2893 to i64
  %2897 = shl nsw i64 %2896, 5
  %result.i.i.i1736 = call noalias ptr @bump_malloc_inner(i64 noundef %2897, ptr nonnull @current_ptr) #29
  %2898 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2899 = icmp sgt i32 %2891, 0
  br i1 %2899, label %.lr.ph434.i1806, label %._crit_edge395.i1750

.lr.ph434.i1806:                                  ; preds = %._crit_edge1.1.i
  %invariant.gep.i1749 = getelementptr i8, ptr %2868, i64 120
  %2900 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1809 = getelementptr ptr, ptr %invariant.gep.i1749, i64 %2886
  br label %2901

2901:                                             ; preds = %2923, %.lr.ph434.i1806
  %.reg2mem105.0432.i1807 = phi i32 [ 0, %.lr.ph434.i1806 ], [ %.reg2mem101.0.i1812, %2923 ]
  %.reg2mem103.0431.i1808 = phi i32 [ 0, %.lr.ph434.i1806 ], [ %2924, %2923 ]
  store ptr @_parameterization_Ptri32, ptr %54, align 8
  %2902 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %54)
  %2903 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2868)
  %2904 = load ptr, ptr %gep.i1809, align 8
  store ptr @i32_typ, ptr %55, align 8
  %2905 = call ptr %2904({ ptr, ptr, ptr, i32 } %2875, ptr nonnull %55)
  %2906 = call { ptr, i160 } %2905({ ptr, ptr, ptr, i32 } %2875, { ptr, ptr, ptr, i32 } %2875, ptr nonnull %54, i32 %.reg2mem103.0431.i1808)
  %.fca.0.extract52.i1810 = extractvalue { ptr, i160 } %2906, 0
  %2907 = icmp ne ptr %.fca.0.extract52.i1810, @nil_typ
  %2908 = icmp ne ptr %.fca.0.extract52.i1810, null
  %.not60.i1811 = and i1 %2907, %2908
  br i1 %.not60.i1811, label %2909, label %2923

2909:                                             ; preds = %2901
  %hash_coef_ptr.i.i137.i1839 = getelementptr i8, ptr %.fca.0.extract52.i1810, i64 8
  %tbl_size_ptr.i.i138.i1840 = getelementptr i8, ptr %.fca.0.extract52.i1810, i64 16
  %offset_tbl_ptr.i.i139.i1841 = getelementptr i8, ptr %.fca.0.extract52.i1810, i64 40
  %hash_coef.i.i140.i1842 = load i64, ptr %hash_coef_ptr.i.i137.i1839, align 4
  %tbl_size.i.i141.i1843 = load i64, ptr %tbl_size_ptr.i.i138.i1840, align 4
  %offset_tbl.i.i142.i1844 = load ptr, ptr %offset_tbl_ptr.i.i139.i1841, align 8
  %product.i.i.i143.i1845 = mul i64 %hash_coef.i.i140.i1842, 4015701072841558310
  %shifted.i.i.i144.i1846 = lshr i64 %product.i.i.i143.i1845, 32
  %xored.i.i.i145.i1847 = xor i64 %shifted.i.i.i144.i1846, %product.i.i.i143.i1845
  %hash.i.i.i146.i1848 = and i64 %xored.i.i.i145.i1847, %tbl_size.i.i141.i1843
  %offset_ptr.i.i147.i1849 = getelementptr i32, ptr %offset_tbl.i.i142.i1844, i64 %hash.i.i.i146.i1848
  %offset.i.i148.i1850 = load i32, ptr %offset_ptr.i.i147.i1849, align 4
  %2910 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2911 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2912 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2913 = icmp slt i32 %.reg2mem105.0432.i1807, %2893
  br i1 %2913, label %2914, label %._crit_edge.i1851

2914:                                             ; preds = %2909
  %.fca.1.extract54.i1852 = extractvalue { ptr, i160 } %2906, 1
  %.sroa.351.0.insert.ext.i1853 = zext i32 %offset.i.i148.i1850 to i160
  %.sroa.351.0.insert.shift.i1854 = shl nuw i160 %.sroa.351.0.insert.ext.i1853, 128
  %2915 = and i160 %.fca.1.extract54.i1852, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1855 = or disjoint i160 %.sroa.351.0.insert.shift.i1854, %2915
  %2916 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2917 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2918 = sext i32 %.reg2mem105.0432.i1807 to i64
  %2919 = shl nsw i64 %2918, 5
  %2920 = getelementptr i8, ptr %result.i.i.i1736, i64 %2919
  store ptr %.fca.0.extract52.i1810, ptr %2920, align 8
  %2921 = getelementptr i8, ptr %2920, i64 8
  store i160 %.sroa.049.0.insert.insert.i1855, ptr %2921, align 4
  br label %._crit_edge.i1851

._crit_edge.i1851:                                ; preds = %2914, %2909
  %2922 = add i32 %.reg2mem105.0432.i1807, 1
  br label %2923

2923:                                             ; preds = %._crit_edge.i1851, %2901
  %.reg2mem101.0.i1812 = phi i32 [ %2922, %._crit_edge.i1851 ], [ %.reg2mem105.0432.i1807, %2901 ]
  %2924 = add nuw nsw i32 %.reg2mem103.0431.i1808, 1
  %2925 = icmp slt i32 %2924, %2891
  br i1 %2925, label %2901, label %.lr.ph.i1813

.lr.ph.i1813:                                     ; preds = %2923
  %invariant.gep396.i1814 = getelementptr i8, ptr %2876, i64 120
  %2926 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2927 = sext i32 %2882 to i64
  %gep397.i1817 = getelementptr ptr, ptr %invariant.gep396.i1814, i64 %2927
  br label %2928

2928:                                             ; preds = %2950, %.lr.ph.i1813
  %.reg2mem91.0394.i1815 = phi i32 [ %.reg2mem101.0.i1812, %.lr.ph.i1813 ], [ %.reg2mem87.0.i1820, %2950 ]
  %.reg2mem89.0393.i1816 = phi i32 [ 0, %.lr.ph.i1813 ], [ %2951, %2950 ]
  store ptr @_parameterization_Ptri32, ptr %56, align 8
  %2929 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %56)
  %2930 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2876)
  %2931 = load ptr, ptr %gep397.i1817, align 8
  store ptr @i32_typ, ptr %57, align 8
  %2932 = call ptr %2931({ ptr, ptr, ptr, i32 } %2883, ptr nonnull %57)
  %2933 = call { ptr, i160 } %2932({ ptr, ptr, ptr, i32 } %2883, { ptr, ptr, ptr, i32 } %2883, ptr nonnull %56, i32 %.reg2mem89.0393.i1816)
  %.fca.0.extract42.i1818 = extractvalue { ptr, i160 } %2933, 0
  %2934 = icmp ne ptr %.fca.0.extract42.i1818, @nil_typ
  %2935 = icmp ne ptr %.fca.0.extract42.i1818, null
  %.not62.i1819 = and i1 %2934, %2935
  br i1 %.not62.i1819, label %2936, label %2950

2936:                                             ; preds = %2928
  %hash_coef_ptr.i.i152.i1821 = getelementptr i8, ptr %.fca.0.extract42.i1818, i64 8
  %tbl_size_ptr.i.i153.i1822 = getelementptr i8, ptr %.fca.0.extract42.i1818, i64 16
  %offset_tbl_ptr.i.i154.i1823 = getelementptr i8, ptr %.fca.0.extract42.i1818, i64 40
  %hash_coef.i.i155.i1824 = load i64, ptr %hash_coef_ptr.i.i152.i1821, align 4
  %tbl_size.i.i156.i1825 = load i64, ptr %tbl_size_ptr.i.i153.i1822, align 4
  %offset_tbl.i.i157.i1826 = load ptr, ptr %offset_tbl_ptr.i.i154.i1823, align 8
  %product.i.i.i158.i1827 = mul i64 %hash_coef.i.i155.i1824, 4015701072841558310
  %shifted.i.i.i159.i1828 = lshr i64 %product.i.i.i158.i1827, 32
  %xored.i.i.i160.i1829 = xor i64 %shifted.i.i.i159.i1828, %product.i.i.i158.i1827
  %hash.i.i.i161.i1830 = and i64 %xored.i.i.i160.i1829, %tbl_size.i.i156.i1825
  %offset_ptr.i.i162.i1831 = getelementptr i32, ptr %offset_tbl.i.i157.i1826, i64 %hash.i.i.i161.i1830
  %offset.i.i163.i1832 = load i32, ptr %offset_ptr.i.i162.i1831, align 4
  %2937 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2938 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2939 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2940 = icmp slt i32 %.reg2mem91.0394.i1815, %2893
  br i1 %2940, label %2941, label %._crit_edge1.i1833

2941:                                             ; preds = %2936
  %.fca.1.extract44.i1834 = extractvalue { ptr, i160 } %2933, 1
  %.sroa.3.0.insert.ext.i1835 = zext i32 %offset.i.i163.i1832 to i160
  %.sroa.3.0.insert.shift.i1836 = shl nuw i160 %.sroa.3.0.insert.ext.i1835, 128
  %2942 = and i160 %.fca.1.extract44.i1834, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1837 = or disjoint i160 %.sroa.3.0.insert.shift.i1836, %2942
  %2943 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2944 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2945 = sext i32 %.reg2mem91.0394.i1815 to i64
  %2946 = shl nsw i64 %2945, 5
  %2947 = getelementptr i8, ptr %result.i.i.i1736, i64 %2946
  store ptr %.fca.0.extract42.i1818, ptr %2947, align 8
  %2948 = getelementptr i8, ptr %2947, i64 8
  store i160 %.sroa.040.0.insert.insert.i1837, ptr %2948, align 4
  br label %._crit_edge1.i1833

._crit_edge1.i1833:                               ; preds = %2941, %2936
  %2949 = add i32 %.reg2mem91.0394.i1815, 1
  br label %2950

2950:                                             ; preds = %._crit_edge1.i1833, %2928
  %.reg2mem87.0.i1820 = phi i32 [ %2949, %._crit_edge1.i1833 ], [ %.reg2mem91.0394.i1815, %2928 ]
  %2951 = add nuw nsw i32 %.reg2mem89.0393.i1816, 1
  %2952 = icmp slt i32 %2951, %2891
  br i1 %2952, label %2928, label %._crit_edge395.i1750.loopexit

._crit_edge395.i1750.loopexit:                    ; preds = %2950
  %.pre3062 = load ptr, ptr %result.i130, align 8
  %.pre3063 = load ptr, ptr %180, align 8
  br label %._crit_edge395.i1750

._crit_edge395.i1750:                             ; preds = %._crit_edge395.i1750.loopexit, %._crit_edge1.1.i
  %2953 = phi ptr [ %2895, %._crit_edge1.1.i ], [ %.pre3063, %._crit_edge395.i1750.loopexit ]
  %2954 = phi ptr [ %2894, %._crit_edge1.1.i ], [ %.pre3062, %._crit_edge395.i1750.loopexit ]
  %.reg2mem91.0.lcssa.i1751 = phi i32 [ 0, %._crit_edge1.1.i ], [ %.reg2mem87.0.i1820, %._crit_edge395.i1750.loopexit ]
  %2955 = call i32 @llvm.smax.i32(i32 %2892, i32 16)
  %result.i166.i1752 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2956 = getelementptr i8, ptr %result.i166.i1752, i64 16
  store ptr @_parameterization_Nil, ptr %2956, align 8
  %result.i167.i1753 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2957 = getelementptr i8, ptr %result.i167.i1753, i64 16
  store ptr %2953, ptr %2957, align 8
  %2958 = getelementptr i8, ptr %result.i167.i1753, i64 8
  store ptr %2954, ptr %2958, align 8
  %2959 = getelementptr i8, ptr %result.i167.i1753, i64 24
  store ptr null, ptr %2959, align 8
  %2960 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1753)
  store ptr @Entry, ptr %result.i167.i1753, align 8
  %2961 = getelementptr i8, ptr %result.i166.i1752, i64 8
  store ptr %result.i167.i1753, ptr %2961, align 8
  %2962 = getelementptr i8, ptr %result.i166.i1752, i64 24
  store ptr null, ptr %2962, align 8
  %2963 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1752)
  store ptr @union_typ, ptr %result.i166.i1752, align 8
  %result.i168.i1754 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1752, ptr %result.i168.i1754, align 8
  %2964 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1754)
  store ptr @Array, ptr %58, align 8
  store ptr %result.i168.i1754, ptr %280, align 8
  store i32 9, ptr %281, align 8
  %2965 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %58)
  %2966 = getelementptr i8, ptr %result.i168.i1754, i64 16
  store i32 %2955, ptr %2966, align 4
  %2967 = getelementptr i8, ptr %result.i168.i1754, i64 20
  store i32 %2955, ptr %2967, align 4
  %2968 = zext nneg i32 %2955 to i64
  %2969 = shl nuw nsw i64 %2968, 5
  %result.i.i416.i1755 = call noalias ptr @bump_malloc_inner(i64 noundef %2969, ptr nonnull @current_ptr) #29
  %2970 = getelementptr i8, ptr %result.i168.i1754, i64 8
  store ptr %result.i.i416.i1755, ptr %2970, align 8
  %2971 = load ptr, ptr %282, align 8
  store ptr @Array, ptr %197, align 8
  store ptr %result.i168.i1754, ptr %198, align 8
  store ptr %2971, ptr %199, align 8
  store i32 9, ptr %200, align 4
  %result.i183.i1768 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2972 = getelementptr i8, ptr %result.i183.i1768, i64 16
  store ptr @_parameterization_Nil, ptr %2972, align 8
  %result.i184.i1769 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2973 = getelementptr i8, ptr %result.i184.i1769, i64 16
  store ptr %2953, ptr %2973, align 8
  %2974 = getelementptr i8, ptr %result.i184.i1769, i64 8
  store ptr %2954, ptr %2974, align 8
  %2975 = getelementptr i8, ptr %result.i184.i1769, i64 24
  store ptr null, ptr %2975, align 8
  %2976 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1769)
  store ptr @Entry, ptr %result.i184.i1769, align 8
  %2977 = getelementptr i8, ptr %result.i183.i1768, i64 8
  store ptr %result.i184.i1769, ptr %2977, align 8
  %2978 = getelementptr i8, ptr %result.i183.i1768, i64 24
  store ptr null, ptr %2978, align 8
  %2979 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1768)
  store ptr @union_typ, ptr %result.i183.i1768, align 8
  %result.i185.i1770 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1768, ptr %result.i185.i1770, align 8
  %2980 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1770)
  store ptr @Array, ptr %59, align 8
  store ptr %result.i185.i1770, ptr %283, align 8
  store i32 9, ptr %284, align 8
  %2981 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %59)
  %2982 = getelementptr i8, ptr %result.i185.i1770, i64 16
  store i32 %2955, ptr %2982, align 4
  %2983 = getelementptr i8, ptr %result.i185.i1770, i64 20
  store i32 %2955, ptr %2983, align 4
  %result.i.i430.i1771 = call noalias ptr @bump_malloc_inner(i64 noundef %2969, ptr nonnull @current_ptr) #29
  %2984 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2985 = getelementptr i8, ptr %result.i185.i1770, i64 8
  store ptr %result.i.i430.i1771, ptr %2985, align 8
  %2986 = load ptr, ptr %285, align 8
  store ptr @Array, ptr %214, align 8
  store ptr %result.i185.i1770, ptr %215, align 8
  store ptr %2986, ptr %216, align 8
  store i32 9, ptr %217, align 4
  %2987 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 0, ptr %218, align 4
  %2988 = icmp sgt i32 %.reg2mem91.0.lcssa.i1751, 0
  br i1 %2988, label %.lr.ph400.i1784, label %HashMap_resize_.exit1857

.lr.ph400.i1784:                                  ; preds = %._crit_edge395.i1750
  %2989 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2990 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2991 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1786

._crit_edge2.i1786:                               ; preds = %._crit_edge2.i1786, %.lr.ph400.i1784
  %.reg2mem77.0398.i1787 = phi i32 [ 0, %.lr.ph400.i1784 ], [ %3005, %._crit_edge2.i1786 ]
  %2992 = zext nneg i32 %.reg2mem77.0398.i1787 to i64
  %2993 = shl nuw nsw i64 %2992, 5
  %2994 = getelementptr i8, ptr %result.i.i.i1736, i64 %2993
  %2995 = load ptr, ptr %2994, align 8
  %2996 = getelementptr i8, ptr %2994, i64 8
  %2997 = load i160, ptr %2996, align 4
  %.sroa.3362.8.extract.trunc.i1790 = trunc i160 %2997 to i64
  %2998 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1790 to ptr
  %.sroa.5363.8.extract.shift.i1791 = lshr i160 %2997, 64
  %.sroa.5363.8.extract.trunc.i1792 = trunc i160 %.sroa.5363.8.extract.shift.i1791 to i64
  %2999 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1792 to ptr
  %hash_coef_ptr.i.i201.i1793 = getelementptr i8, ptr %2995, i64 8
  %tbl_size_ptr.i.i202.i1794 = getelementptr i8, ptr %2995, i64 16
  %offset_tbl_ptr.i.i203.i1795 = getelementptr i8, ptr %2995, i64 40
  %hash_coef.i.i232.i1796 = load i64, ptr %hash_coef_ptr.i.i201.i1793, align 4
  %tbl_size.i.i233.i1797 = load i64, ptr %tbl_size_ptr.i.i202.i1794, align 4
  %offset_tbl.i.i234.i1798 = load ptr, ptr %offset_tbl_ptr.i.i203.i1795, align 8
  %product.i.i.i235.i1799 = mul i64 %hash_coef.i.i232.i1796, 4015701072841558310
  %shifted.i.i.i236.i1800 = lshr i64 %product.i.i.i235.i1799, 32
  %xored.i.i.i237.i1801 = xor i64 %shifted.i.i.i236.i1800, %product.i.i.i235.i1799
  %hash.i.i.i238.i1802 = and i64 %xored.i.i.i237.i1801, %tbl_size.i.i233.i1797
  %offset_ptr.i.i239.i1803 = getelementptr i32, ptr %offset_tbl.i.i234.i1798, i64 %hash.i.i.i238.i1802
  %offset.i.i240.i1804 = load i32, ptr %offset_ptr.i.i239.i1803, align 4
  %3000 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2995, 0
  %3001 = insertvalue { ptr, ptr, ptr, i32 } %3000, ptr %2998, 1
  %3002 = insertvalue { ptr, ptr, ptr, i32 } %3001, ptr %2999, 2
  %3003 = insertvalue { ptr, ptr, ptr, i32 } %3002, i32 %offset.i.i240.i1804, 3
  %3004 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %262, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %3003)
  %3005 = add nuw nsw i32 %.reg2mem77.0398.i1787, 1
  %3006 = icmp slt i32 %3005, %.reg2mem91.0.lcssa.i1751
  br i1 %3006, label %._crit_edge2.i1786, label %HashMap_resize_.exit1857

HashMap_resize_.exit1857:                         ; preds = %._crit_edge2.i1786, %._crit_edge395.i1750
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %57)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %59)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1686.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %1819, %2015, %HashMap_resize_.exit1857
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %124)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %125)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %126)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %127)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %128)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %129)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %130)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %131)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %132)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %133)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %134)
  %3007 = add nsw i32 %.reg2mem168.0346, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %HashMap_insert_keyK_valueV.exit, %HashMap_get_keyK.exit
  %.reg2mem164.0 = phi i32 [ %3007, %HashMap_insert_keyK_valueV.exit ], [ %.reg2mem168.0346, %HashMap_get_keyK.exit ]
  %3008 = add nuw nsw i32 %.reg2mem166.0345, 1
  %3009 = icmp slt i32 %.reg2mem164.0, %0
  %3010 = icmp slt i32 %3008, %221
  %3011 = and i1 %3010, %3009
  br i1 %3011, label %318, label %._crit_edge._crit_edge

._crit_edge._crit_edge:                           ; preds = %._crit_edge, %1
  %3012 = sext i32 %0 to i64
  %3013 = shl nsw i64 %3012, 5
  %result.i.i393 = call noalias ptr @bump_malloc_inner(i64 noundef %3013, ptr nonnull @current_ptr) #29
  %3014 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %3015 = mul i32 %0, 20
  %3016 = icmp sgt i32 %3015, 0
  %3017 = and i1 %222, %3016
  br i1 %3017, label %.lr.ph351, label %._crit_edge352

.lr.ph351:                                        ; preds = %._crit_edge._crit_edge
  %result.i115.promoted = load i32, ptr %result.i115, align 4
  %3018 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  br label %3019

3019:                                             ; preds = %.lr.ph351, %3196
  %3020 = phi i32 [ %result.i115.promoted, %.lr.ph351 ], [ %3023, %3196 ]
  %.reg2mem158.0349 = phi i32 [ 0, %.lr.ph351 ], [ %.reg2mem154.0, %3196 ]
  %.reg2mem156.0348 = phi i32 [ 0, %.lr.ph351 ], [ %3197, %3196 ]
  %3021 = mul i32 %3020, 1103515245
  %3022 = add i32 %3021, 12345
  %3023 = and i32 %3022, 2147483647
  %.sroa.067.0.insert.ext = zext nneg i32 %3023 to i160
  %3024 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.067.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i593)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i594)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i595)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i596)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %120)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %121)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i597)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i598)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i599)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i600)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %122)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %123)
  %3025 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3026 = load ptr, ptr %185, align 8
  %3027 = call i32 %3026({ ptr, i160 } %3024)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3028 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3029 = load ptr, ptr %197, align 8
  %3030 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3029, 0
  %3031 = load ptr, ptr %198, align 8
  %3032 = insertvalue { ptr, ptr, ptr, i32 } %3030, ptr %3031, 1
  %3033 = load ptr, ptr %199, align 8
  %3034 = insertvalue { ptr, ptr, ptr, i32 } %3032, ptr %3033, 2
  %3035 = load i32, ptr %200, align 4
  %3036 = insertvalue { ptr, ptr, ptr, i32 } %3034, i32 %3035, 3
  %hash_coef_ptr.i.i10.i1890 = getelementptr i8, ptr %3029, i64 8
  %tbl_size_ptr.i.i11.i1891 = getelementptr i8, ptr %3029, i64 16
  %offset_tbl_ptr.i.i12.i1892 = getelementptr i8, ptr %3029, i64 40
  %hash_coef.i.i13.i1893 = load i64, ptr %hash_coef_ptr.i.i10.i1890, align 4
  %tbl_size.i.i14.i1894 = load i64, ptr %tbl_size_ptr.i.i11.i1891, align 4
  %offset_tbl.i.i15.i1895 = load ptr, ptr %offset_tbl_ptr.i.i12.i1892, align 8
  %product.i.i.i16.i1896 = mul i64 %hash_coef.i.i13.i1893, -5261542750394134544
  %shifted.i.i.i17.i1897 = lshr i64 %product.i.i.i16.i1896, 32
  %xored.i.i.i18.i1898 = xor i64 %shifted.i.i.i17.i1897, %product.i.i.i16.i1896
  %hash.i.i.i19.i1899 = and i64 %xored.i.i.i18.i1898, %tbl_size.i.i14.i1894
  %offset_ptr.i.i20.i1900 = getelementptr i32, ptr %offset_tbl.i.i15.i1895, i64 %hash.i.i.i19.i1899
  %offset.i.i21.i1901 = load i32, ptr %offset_ptr.i.i20.i1900, align 4
  %eq.i.i1902 = icmp eq i32 %3035, %offset.i.i21.i1901
  call void @llvm.assume(i1 %eq.i.i1902) #30
  %3037 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3038 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3029)
  %3039 = sext i32 %3035 to i64
  %3040 = getelementptr ptr, ptr %3029, i64 %3039
  %3041 = getelementptr i8, ptr %3040, i64 64
  %3042 = load ptr, ptr %3041, align 8
  %3043 = call ptr %3042({ ptr, ptr, ptr, i32 } %3036, ptr nonnull %2)
  %3044 = call i32 %3043({ ptr, ptr, ptr, i32 } %3036, { ptr, ptr, ptr, i32 } %3036, ptr nonnull %2)
  %3045 = add i32 %3044, -1
  %3046 = and i32 %3045, %3027
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3047 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3048 = load ptr, ptr %197, align 8
  %3049 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3048, 0
  %3050 = load ptr, ptr %198, align 8
  %3051 = insertvalue { ptr, ptr, ptr, i32 } %3049, ptr %3050, 1
  %3052 = load ptr, ptr %199, align 8
  %3053 = insertvalue { ptr, ptr, ptr, i32 } %3051, ptr %3052, 2
  %3054 = load i32, ptr %200, align 4
  %3055 = insertvalue { ptr, ptr, ptr, i32 } %3053, i32 %3054, 3
  %hash_coef_ptr.i.i130.i619 = getelementptr i8, ptr %3048, i64 8
  %tbl_size_ptr.i.i131.i620 = getelementptr i8, ptr %3048, i64 16
  %offset_tbl_ptr.i.i132.i621 = getelementptr i8, ptr %3048, i64 40
  %hash_coef.i.i133.i622 = load i64, ptr %hash_coef_ptr.i.i130.i619, align 4
  %tbl_size.i.i134.i623 = load i64, ptr %tbl_size_ptr.i.i131.i620, align 4
  %offset_tbl.i.i135.i624 = load ptr, ptr %offset_tbl_ptr.i.i132.i621, align 8
  %product.i.i.i136.i625 = mul i64 %hash_coef.i.i133.i622, -5261542750394134544
  %shifted.i.i.i137.i626 = lshr i64 %product.i.i.i136.i625, 32
  %xored.i.i.i138.i627 = xor i64 %shifted.i.i.i137.i626, %product.i.i.i136.i625
  %hash.i.i.i139.i628 = and i64 %xored.i.i.i138.i627, %tbl_size.i.i134.i623
  %offset_ptr.i.i140.i629 = getelementptr i32, ptr %offset_tbl.i.i135.i624, i64 %hash.i.i.i139.i628
  %offset.i.i141.i630 = load i32, ptr %offset_ptr.i.i140.i629, align 4
  %eq.i.i631 = icmp eq i32 %3054, %offset.i.i141.i630
  call void @llvm.assume(i1 %eq.i.i631) #30
  store ptr @_parameterization_Ptri32, ptr %122, align 8
  %3056 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %122)
  %3057 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3048)
  %3058 = sext i32 %3054 to i64
  %3059 = getelementptr ptr, ptr %3048, i64 %3058
  %3060 = getelementptr i8, ptr %3059, i64 120
  %3061 = load ptr, ptr %3060, align 8
  store ptr @i32_typ, ptr %123, align 8
  %3062 = call ptr %3061({ ptr, ptr, ptr, i32 } %3055, ptr nonnull %123)
  %3063 = call { ptr, i160 } %3062({ ptr, ptr, ptr, i32 } %3055, { ptr, ptr, ptr, i32 } %3055, ptr nonnull %122, i32 %3046)
  %.fca.0.extract.i632 = extractvalue { ptr, i160 } %3063, 0
  %3064 = icmp ne ptr %.fca.0.extract.i632, @nil_typ
  %3065 = icmp ne ptr %.fca.0.extract.i632, null
  %.not126.i633 = and i1 %3064, %3065
  br i1 %.not126.i633, label %3066, label %.critedge.i634

3066:                                             ; preds = %3019
  %.fca.1.extract.i685 = extractvalue { ptr, i160 } %3063, 1
  %.sroa.5.8.extract.trunc.i686 = trunc i160 %.fca.1.extract.i685 to i64
  %3067 = inttoptr i64 %.sroa.5.8.extract.trunc.i686 to ptr
  %.sroa.9.8.extract.shift.i687 = lshr i160 %.fca.1.extract.i685, 64
  %.sroa.9.8.extract.trunc.i688 = trunc i160 %.sroa.9.8.extract.shift.i687 to i64
  %3068 = inttoptr i64 %.sroa.9.8.extract.trunc.i688 to ptr
  %hash_coef_ptr.i.i144.i689 = getelementptr i8, ptr %.fca.0.extract.i632, i64 8
  %tbl_size_ptr.i.i145.i690 = getelementptr i8, ptr %.fca.0.extract.i632, i64 16
  %offset_tbl_ptr.i.i146.i691 = getelementptr i8, ptr %.fca.0.extract.i632, i64 40
  %hash_coef.i.i147.i692 = load i64, ptr %hash_coef_ptr.i.i144.i689, align 4
  %tbl_size.i.i148.i693 = load i64, ptr %tbl_size_ptr.i.i145.i690, align 4
  %offset_tbl.i.i149.i694 = load ptr, ptr %offset_tbl_ptr.i.i146.i691, align 8
  %product.i.i.i150.i695 = mul i64 %hash_coef.i.i147.i692, 4015701072841558310
  %shifted.i.i.i151.i696 = lshr i64 %product.i.i.i150.i695, 32
  %xored.i.i.i152.i697 = xor i64 %shifted.i.i.i151.i696, %product.i.i.i150.i695
  %hash.i.i.i153.i698 = and i64 %xored.i.i.i152.i697, %tbl_size.i.i148.i693
  %offset_ptr.i.i154.i699 = getelementptr i32, ptr %offset_tbl.i.i149.i694, i64 %hash.i.i.i153.i698
  %offset.i.i155.i700 = load i32, ptr %offset_ptr.i.i154.i699, align 4
  %3069 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i632, 0
  %3070 = insertvalue { ptr, ptr, ptr, i32 } %3069, ptr %3067, 1
  %3071 = insertvalue { ptr, ptr, ptr, i32 } %3070, ptr %3068, 2
  %3072 = insertvalue { ptr, ptr, ptr, i32 } %3071, i32 %offset.i.i155.i700, 3
  %3073 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3074 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3075 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i632)
  %3076 = sext i32 %offset.i.i155.i700 to i64
  %3077 = getelementptr ptr, ptr %.fca.0.extract.i632, i64 %3076
  %3078 = getelementptr i8, ptr %3077, i64 64
  %3079 = load ptr, ptr %3078, align 8
  %3080 = call ptr %3079({ ptr, ptr, ptr, i32 } %3072, ptr nonnull %2)
  %3081 = call i32 %3080({ ptr, ptr, ptr, i32 } %3072, { ptr, ptr, ptr, i32 } %3072, ptr nonnull %2)
  %3082 = icmp eq i32 %3081, %3027
  %3083 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3084 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3085 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i632)
  %3086 = getelementptr i8, ptr %3077, i64 48
  %3087 = load ptr, ptr %3086, align 8
  %3088 = call ptr %3087({ ptr, ptr, ptr, i32 } %3072, ptr nonnull %2)
  %3089 = call { ptr, i160 } %3088({ ptr, ptr, ptr, i32 } %3072, { ptr, ptr, ptr, i32 } %3072, ptr nonnull %2)
  %3090 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3091 = load ptr, ptr %186, align 8
  %3092 = call i1 %3091({ ptr, i160 } %3089, { ptr, i160 } %3024)
  %3093 = and i1 %3082, %3092
  br i1 %3093, label %HashMap_get_keyK.exit702, label %.critedge.i634

.critedge.i634:                                   ; preds = %3066, %3019
  %3094 = add i32 %3027, 2127912214
  %3095 = shl i32 %3027, 12
  %3096 = add i32 %3094, %3095
  %3097 = ashr i32 %3096, 19
  %3098 = xor i32 %3096, %3097
  %3099 = xor i32 %3098, -949894596
  %3100 = add i32 %3099, 374761393
  %3101 = shl i32 %3099, 5
  %3102 = add i32 %3100, %3101
  %3103 = add i32 %3102, -744332180
  %3104 = shl i32 %3102, 9
  %3105 = xor i32 %3103, %3104
  %3106 = add i32 %3105, -42973499
  %3107 = shl i32 %3105, 3
  %3108 = add i32 %3106, %3107
  %3109 = ashr i32 %3108, 16
  %3110 = xor i32 %3108, %3109
  %3111 = xor i32 %3110, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3112 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3113 = load ptr, ptr %214, align 8
  %3114 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3113, 0
  %3115 = load ptr, ptr %215, align 8
  %3116 = insertvalue { ptr, ptr, ptr, i32 } %3114, ptr %3115, 1
  %3117 = load ptr, ptr %216, align 8
  %3118 = insertvalue { ptr, ptr, ptr, i32 } %3116, ptr %3117, 2
  %3119 = load i32, ptr %217, align 4
  %3120 = insertvalue { ptr, ptr, ptr, i32 } %3118, i32 %3119, 3
  %hash_coef_ptr.i.i10.i1921 = getelementptr i8, ptr %3113, i64 8
  %tbl_size_ptr.i.i11.i1922 = getelementptr i8, ptr %3113, i64 16
  %offset_tbl_ptr.i.i12.i1923 = getelementptr i8, ptr %3113, i64 40
  %hash_coef.i.i13.i1924 = load i64, ptr %hash_coef_ptr.i.i10.i1921, align 4
  %tbl_size.i.i14.i1925 = load i64, ptr %tbl_size_ptr.i.i11.i1922, align 4
  %offset_tbl.i.i15.i1926 = load ptr, ptr %offset_tbl_ptr.i.i12.i1923, align 8
  %product.i.i.i16.i1927 = mul i64 %hash_coef.i.i13.i1924, -5261542750394134544
  %shifted.i.i.i17.i1928 = lshr i64 %product.i.i.i16.i1927, 32
  %xored.i.i.i18.i1929 = xor i64 %shifted.i.i.i17.i1928, %product.i.i.i16.i1927
  %hash.i.i.i19.i1930 = and i64 %xored.i.i.i18.i1929, %tbl_size.i.i14.i1925
  %offset_ptr.i.i20.i1931 = getelementptr i32, ptr %offset_tbl.i.i15.i1926, i64 %hash.i.i.i19.i1930
  %offset.i.i21.i1932 = load i32, ptr %offset_ptr.i.i20.i1931, align 4
  %eq.i.i1933 = icmp eq i32 %3119, %offset.i.i21.i1932
  call void @llvm.assume(i1 %eq.i.i1933) #30
  %3121 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3122 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3113)
  %3123 = sext i32 %3119 to i64
  %3124 = getelementptr ptr, ptr %3113, i64 %3123
  %3125 = getelementptr i8, ptr %3124, i64 64
  %3126 = load ptr, ptr %3125, align 8
  %3127 = call ptr %3126({ ptr, ptr, ptr, i32 } %3120, ptr nonnull %2)
  %3128 = call i32 %3127({ ptr, ptr, ptr, i32 } %3120, { ptr, ptr, ptr, i32 } %3120, ptr nonnull %2)
  %3129 = add i32 %3128, -1
  %3130 = and i32 %3129, %3111
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3131 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3132 = load ptr, ptr %214, align 8
  %3133 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3132, 0
  %3134 = load ptr, ptr %215, align 8
  %3135 = insertvalue { ptr, ptr, ptr, i32 } %3133, ptr %3134, 1
  %3136 = load ptr, ptr %216, align 8
  %3137 = insertvalue { ptr, ptr, ptr, i32 } %3135, ptr %3136, 2
  %3138 = load i32, ptr %217, align 4
  %3139 = insertvalue { ptr, ptr, ptr, i32 } %3137, i32 %3138, 3
  %hash_coef_ptr.i.i158.i639 = getelementptr i8, ptr %3132, i64 8
  %tbl_size_ptr.i.i159.i640 = getelementptr i8, ptr %3132, i64 16
  %offset_tbl_ptr.i.i160.i641 = getelementptr i8, ptr %3132, i64 40
  %hash_coef.i.i161.i642 = load i64, ptr %hash_coef_ptr.i.i158.i639, align 4
  %tbl_size.i.i162.i643 = load i64, ptr %tbl_size_ptr.i.i159.i640, align 4
  %offset_tbl.i.i163.i644 = load ptr, ptr %offset_tbl_ptr.i.i160.i641, align 8
  %product.i.i.i164.i645 = mul i64 %hash_coef.i.i161.i642, -5261542750394134544
  %shifted.i.i.i165.i646 = lshr i64 %product.i.i.i164.i645, 32
  %xored.i.i.i166.i647 = xor i64 %shifted.i.i.i165.i646, %product.i.i.i164.i645
  %hash.i.i.i167.i648 = and i64 %xored.i.i.i166.i647, %tbl_size.i.i162.i643
  %offset_ptr.i.i168.i649 = getelementptr i32, ptr %offset_tbl.i.i163.i644, i64 %hash.i.i.i167.i648
  %offset.i.i169.i650 = load i32, ptr %offset_ptr.i.i168.i649, align 4
  %eq.i172.i651 = icmp eq i32 %3138, %offset.i.i169.i650
  call void @llvm.assume(i1 %eq.i172.i651) #30
  store ptr @_parameterization_Ptri32, ptr %120, align 8
  %3140 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %120)
  %3141 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3132)
  %3142 = sext i32 %3138 to i64
  %3143 = getelementptr ptr, ptr %3132, i64 %3142
  %3144 = getelementptr i8, ptr %3143, i64 120
  %3145 = load ptr, ptr %3144, align 8
  store ptr @i32_typ, ptr %121, align 8
  %3146 = call ptr %3145({ ptr, ptr, ptr, i32 } %3139, ptr nonnull %121)
  %3147 = call { ptr, i160 } %3146({ ptr, ptr, ptr, i32 } %3139, { ptr, ptr, ptr, i32 } %3139, ptr nonnull %120, i32 %3130)
  %.fca.0.extract57.i652 = extractvalue { ptr, i160 } %3147, 0
  %3148 = icmp ne ptr %.fca.0.extract57.i652, @nil_typ
  %3149 = icmp ne ptr %.fca.0.extract57.i652, null
  %.not128.i653 = and i1 %3148, %3149
  br i1 %.not128.i653, label %3150, label %HashMap_get_keyK.exit702.thread

3150:                                             ; preds = %.critedge.i634
  %.fca.1.extract59.i658 = extractvalue { ptr, i160 } %3147, 1
  %.sroa.6.8.extract.trunc.i659 = trunc i160 %.fca.1.extract59.i658 to i64
  %3151 = inttoptr i64 %.sroa.6.8.extract.trunc.i659 to ptr
  %.sroa.11.8.extract.shift.i660 = lshr i160 %.fca.1.extract59.i658, 64
  %.sroa.11.8.extract.trunc.i661 = trunc i160 %.sroa.11.8.extract.shift.i660 to i64
  %3152 = inttoptr i64 %.sroa.11.8.extract.trunc.i661 to ptr
  %hash_coef_ptr.i.i174.i662 = getelementptr i8, ptr %.fca.0.extract57.i652, i64 8
  %tbl_size_ptr.i.i175.i663 = getelementptr i8, ptr %.fca.0.extract57.i652, i64 16
  %offset_tbl_ptr.i.i176.i664 = getelementptr i8, ptr %.fca.0.extract57.i652, i64 40
  %hash_coef.i.i177.i665 = load i64, ptr %hash_coef_ptr.i.i174.i662, align 4
  %tbl_size.i.i178.i666 = load i64, ptr %tbl_size_ptr.i.i175.i663, align 4
  %offset_tbl.i.i179.i667 = load ptr, ptr %offset_tbl_ptr.i.i176.i664, align 8
  %product.i.i.i180.i668 = mul i64 %hash_coef.i.i177.i665, 4015701072841558310
  %shifted.i.i.i181.i669 = lshr i64 %product.i.i.i180.i668, 32
  %xored.i.i.i182.i670 = xor i64 %shifted.i.i.i181.i669, %product.i.i.i180.i668
  %hash.i.i.i183.i671 = and i64 %xored.i.i.i182.i670, %tbl_size.i.i178.i666
  %offset_ptr.i.i184.i672 = getelementptr i32, ptr %offset_tbl.i.i179.i667, i64 %hash.i.i.i183.i671
  %offset.i.i185.i673 = load i32, ptr %offset_ptr.i.i184.i672, align 4
  %3153 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i652, 0
  %3154 = insertvalue { ptr, ptr, ptr, i32 } %3153, ptr %3151, 1
  %3155 = insertvalue { ptr, ptr, ptr, i32 } %3154, ptr %3152, 2
  %3156 = insertvalue { ptr, ptr, ptr, i32 } %3155, i32 %offset.i.i185.i673, 3
  %3157 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3158 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3159 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i652)
  %3160 = sext i32 %offset.i.i185.i673 to i64
  %3161 = getelementptr ptr, ptr %.fca.0.extract57.i652, i64 %3160
  %3162 = getelementptr i8, ptr %3161, i64 64
  %3163 = load ptr, ptr %3162, align 8
  %3164 = call ptr %3163({ ptr, ptr, ptr, i32 } %3156, ptr nonnull %2)
  %3165 = call i32 %3164({ ptr, ptr, ptr, i32 } %3156, { ptr, ptr, ptr, i32 } %3156, ptr nonnull %2)
  %3166 = icmp eq i32 %3165, %3027
  %3167 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3168 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3169 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i652)
  %3170 = getelementptr i8, ptr %3161, i64 48
  %3171 = load ptr, ptr %3170, align 8
  %3172 = call ptr %3171({ ptr, ptr, ptr, i32 } %3156, ptr nonnull %2)
  %3173 = call { ptr, i160 } %3172({ ptr, ptr, ptr, i32 } %3156, { ptr, ptr, ptr, i32 } %3156, ptr nonnull %2)
  %3174 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3175 = load ptr, ptr %186, align 8
  %3176 = call i1 %3175({ ptr, i160 } %3173, { ptr, i160 } %3024)
  %3177 = and i1 %3166, %3176
  br i1 %3177, label %HashMap_get_keyK.exit702, label %HashMap_get_keyK.exit702.thread

HashMap_get_keyK.exit702.thread:                  ; preds = %3150, %.critedge.i634
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i593)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i594)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i595)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i596)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %120)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %121)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i597)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i598)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i599)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i600)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %122)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %123)
  br label %3189

HashMap_get_keyK.exit702:                         ; preds = %3066, %3150
  %.pre-phi313.i676 = phi i64 [ %3076, %3066 ], [ %3160, %3150 ]
  %.pre-phi312.i677 = phi { ptr, ptr, ptr, i32 } [ %3072, %3066 ], [ %3156, %3150 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i678 = phi ptr [ %.fca.0.extract.i632, %3066 ], [ %.fca.0.extract57.i652, %3150 ]
  %.reg2mem59.0.sroa.phi120289.i679 = phi ptr [ %.sroa.1.i594, %3066 ], [ %.sroa.2124.i598, %3150 ]
  %.reg2mem59.0.sroa.phi117288.i680 = phi ptr [ %.sroa.0271.i593, %3066 ], [ %.sroa.0123.i597, %3150 ]
  %.reg2mem57.0.sroa.phi94287.i681 = phi ptr [ %.sroa.2.i596, %3066 ], [ %.sroa.2116.i600, %3150 ]
  %.reg2mem57.0.sroa.phi91286.i682 = phi ptr [ %.sroa.0.i595, %3066 ], [ %.sroa.0115.i599, %3150 ]
  %3178 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3179 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3180 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i678)
  %3181 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i678, i64 %.pre-phi313.i676
  %3182 = getelementptr i8, ptr %3181, i64 56
  %3183 = load ptr, ptr %3182, align 8
  %3184 = call ptr %3183({ ptr, ptr, ptr, i32 } %.pre-phi312.i677, ptr nonnull %2)
  %3185 = call { ptr, i160 } %3184({ ptr, ptr, ptr, i32 } %.pre-phi312.i677, { ptr, ptr, ptr, i32 } %.pre-phi312.i677, ptr nonnull %2)
  %.fca.0.extract97.i683 = extractvalue { ptr, i160 } %3185, 0
  store ptr %.fca.0.extract97.i683, ptr %.reg2mem59.0.sroa.phi117288.i680, align 8
  %.fca.1.extract99.i684 = extractvalue { ptr, i160 } %3185, 1
  store i160 %.fca.1.extract99.i684, ptr %.reg2mem59.0.sroa.phi120289.i679, align 8
  store ptr %.fca.0.extract97.i683, ptr %.reg2mem57.0.sroa.phi91286.i682, align 8
  store i160 %.fca.1.extract99.i684, ptr %.reg2mem57.0.sroa.phi94287.i681, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i593)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i594)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i595)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i596)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %120)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %121)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i597)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i598)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i599)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i600)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %122)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %123)
  %3186 = icmp eq ptr %.fca.0.extract97.i683, @nil_typ
  %3187 = icmp eq ptr %.fca.0.extract97.i683, null
  %3188 = or i1 %3186, %3187
  br i1 %3188, label %3189, label %3196

3189:                                             ; preds = %HashMap_get_keyK.exit702.thread, %HashMap_get_keyK.exit702
  %3190 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %3191 = sext i32 %.reg2mem158.0349 to i64
  %3192 = shl nsw i64 %3191, 5
  %3193 = getelementptr i8, ptr %result.i.i393, i64 %3192
  store ptr @i32_typ, ptr %3193, align 8
  %3194 = getelementptr i8, ptr %3193, i64 8
  store i160 %.sroa.067.0.insert.ext, ptr %3194, align 4
  %3195 = add nsw i32 %.reg2mem158.0349, 1
  br label %3196

3196:                                             ; preds = %3189, %HashMap_get_keyK.exit702
  %.reg2mem154.0 = phi i32 [ %3195, %3189 ], [ %.reg2mem158.0349, %HashMap_get_keyK.exit702 ]
  %3197 = add nuw nsw i32 %.reg2mem156.0348, 1
  %3198 = icmp slt i32 %.reg2mem154.0, %0
  %3199 = icmp slt i32 %3197, %3015
  %3200 = and i1 %3199, %3198
  br i1 %3200, label %3019, label %._crit_edge352.loopexit

._crit_edge352.loopexit:                          ; preds = %3196
  store i32 %3023, ptr %result.i115, align 4
  br label %._crit_edge352

._crit_edge352:                                   ; preds = %._crit_edge352.loopexit, %._crit_edge._crit_edge
  %.reg2mem158.0.lcssa = phi i32 [ 0, %._crit_edge._crit_edge ], [ %.reg2mem154.0, %._crit_edge352.loopexit ]
  %3201 = call i32 @llvm.smin.i32(i32 %.reg2mem158.0.lcssa, i32 %0)
  %3202 = call i64 @clock()
  %3203 = icmp sgt i32 %3201, 0
  br i1 %3203, label %.lr.ph357.preheader, label %3383

.lr.ph357.preheader:                              ; preds = %._crit_edge352
  %3204 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %invariant.gep = getelementptr i8, ptr %result.i.i393, i64 8
  %3205 = getelementptr i8, ptr %result.i, i64 40
  %3206 = getelementptr i8, ptr %result.i, i64 72
  br label %.lr.ph357

.lr.ph357:                                        ; preds = %.lr.ph357.preheader, %HashMap_get_keyK.exit1139
  %.reg2mem144.0355 = phi i32 [ %.reg2mem138.0, %HashMap_get_keyK.exit1139 ], [ 0, %.lr.ph357.preheader ]
  %.reg2mem142.0354 = phi i32 [ %.reg2mem136.0, %HashMap_get_keyK.exit1139 ], [ 0, %.lr.ph357.preheader ]
  %.reg2mem140.0353 = phi i32 [ %3376, %HashMap_get_keyK.exit1139 ], [ 0, %.lr.ph357.preheader ]
  %3207 = zext nneg i32 %.reg2mem140.0353 to i64
  %3208 = shl nuw nsw i64 %3207, 5
  %gep = getelementptr i8, ptr %invariant.gep, i64 %3208
  %3209 = load i160, ptr %gep, align 4
  %.sroa.048.0.insert.ext = and i160 %3209, 4294967295
  %3210 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.048.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i1037)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i1038)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1039)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i1040)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i1041)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i1042)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i1043)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i1044)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %108)
  %3211 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3212 = load ptr, ptr %150, align 8
  %3213 = call i32 %3212({ ptr, i160 } %3210)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3214 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3215 = load ptr, ptr %162, align 8
  %3216 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3215, 0
  %3217 = load ptr, ptr %163, align 8
  %3218 = insertvalue { ptr, ptr, ptr, i32 } %3216, ptr %3217, 1
  %3219 = load ptr, ptr %3205, align 8
  %3220 = insertvalue { ptr, ptr, ptr, i32 } %3218, ptr %3219, 2
  %3221 = load i32, ptr %164, align 4
  %3222 = insertvalue { ptr, ptr, ptr, i32 } %3220, i32 %3221, 3
  %hash_coef_ptr.i.i10.i2972 = getelementptr i8, ptr %3215, i64 8
  %tbl_size_ptr.i.i11.i2973 = getelementptr i8, ptr %3215, i64 16
  %offset_tbl_ptr.i.i12.i2974 = getelementptr i8, ptr %3215, i64 40
  %hash_coef.i.i13.i2975 = load i64, ptr %hash_coef_ptr.i.i10.i2972, align 4
  %tbl_size.i.i14.i2976 = load i64, ptr %tbl_size_ptr.i.i11.i2973, align 4
  %offset_tbl.i.i15.i2977 = load ptr, ptr %offset_tbl_ptr.i.i12.i2974, align 8
  %product.i.i.i16.i2978 = mul i64 %hash_coef.i.i13.i2975, -5261542750394134544
  %shifted.i.i.i17.i2979 = lshr i64 %product.i.i.i16.i2978, 32
  %xored.i.i.i18.i2980 = xor i64 %shifted.i.i.i17.i2979, %product.i.i.i16.i2978
  %hash.i.i.i19.i2981 = and i64 %xored.i.i.i18.i2980, %tbl_size.i.i14.i2976
  %offset_ptr.i.i20.i2982 = getelementptr i32, ptr %offset_tbl.i.i15.i2977, i64 %hash.i.i.i19.i2981
  %offset.i.i21.i2983 = load i32, ptr %offset_ptr.i.i20.i2982, align 4
  %eq.i.i2984 = icmp eq i32 %3221, %offset.i.i21.i2983
  call void @llvm.assume(i1 %eq.i.i2984) #30
  %3223 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3224 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3215)
  %3225 = sext i32 %3221 to i64
  %3226 = getelementptr ptr, ptr %3215, i64 %3225
  %3227 = getelementptr i8, ptr %3226, i64 64
  %3228 = load ptr, ptr %3227, align 8
  %3229 = call ptr %3228({ ptr, ptr, ptr, i32 } %3222, ptr nonnull %2)
  %3230 = call i32 %3229({ ptr, ptr, ptr, i32 } %3222, { ptr, ptr, ptr, i32 } %3222, ptr nonnull %2)
  %3231 = add i32 %3230, -1
  %3232 = and i32 %3231, %3213
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3233 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3234 = load ptr, ptr %162, align 8
  %3235 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3234, 0
  %3236 = load ptr, ptr %163, align 8
  %3237 = insertvalue { ptr, ptr, ptr, i32 } %3235, ptr %3236, 1
  %3238 = load ptr, ptr %3205, align 8
  %3239 = insertvalue { ptr, ptr, ptr, i32 } %3237, ptr %3238, 2
  %3240 = load i32, ptr %164, align 4
  %3241 = insertvalue { ptr, ptr, ptr, i32 } %3239, i32 %3240, 3
  %hash_coef_ptr.i.i130.i1061 = getelementptr i8, ptr %3234, i64 8
  %tbl_size_ptr.i.i131.i1062 = getelementptr i8, ptr %3234, i64 16
  %offset_tbl_ptr.i.i132.i1063 = getelementptr i8, ptr %3234, i64 40
  %hash_coef.i.i133.i1064 = load i64, ptr %hash_coef_ptr.i.i130.i1061, align 4
  %tbl_size.i.i134.i1065 = load i64, ptr %tbl_size_ptr.i.i131.i1062, align 4
  %offset_tbl.i.i135.i1066 = load ptr, ptr %offset_tbl_ptr.i.i132.i1063, align 8
  %product.i.i.i136.i1067 = mul i64 %hash_coef.i.i133.i1064, -5261542750394134544
  %shifted.i.i.i137.i1068 = lshr i64 %product.i.i.i136.i1067, 32
  %xored.i.i.i138.i1069 = xor i64 %shifted.i.i.i137.i1068, %product.i.i.i136.i1067
  %hash.i.i.i139.i1070 = and i64 %xored.i.i.i138.i1069, %tbl_size.i.i134.i1065
  %offset_ptr.i.i140.i1071 = getelementptr i32, ptr %offset_tbl.i.i135.i1066, i64 %hash.i.i.i139.i1070
  %offset.i.i141.i1072 = load i32, ptr %offset_ptr.i.i140.i1071, align 4
  %eq.i.i1073 = icmp eq i32 %3240, %offset.i.i141.i1072
  call void @llvm.assume(i1 %eq.i.i1073) #30
  store ptr @_parameterization_Ptri32, ptr %107, align 8
  %3242 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %107)
  %3243 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3234)
  %3244 = sext i32 %3240 to i64
  %3245 = getelementptr ptr, ptr %3234, i64 %3244
  %3246 = getelementptr i8, ptr %3245, i64 120
  %3247 = load ptr, ptr %3246, align 8
  store ptr @i32_typ, ptr %108, align 8
  %3248 = call ptr %3247({ ptr, ptr, ptr, i32 } %3241, ptr nonnull %108)
  %3249 = call { ptr, i160 } %3248({ ptr, ptr, ptr, i32 } %3241, { ptr, ptr, ptr, i32 } %3241, ptr nonnull %107, i32 %3232)
  %.fca.0.extract.i1074 = extractvalue { ptr, i160 } %3249, 0
  %3250 = icmp ne ptr %.fca.0.extract.i1074, @nil_typ
  %3251 = icmp ne ptr %.fca.0.extract.i1074, null
  %.not126.i1075 = and i1 %3250, %3251
  br i1 %.not126.i1075, label %3252, label %.critedge.i1076

3252:                                             ; preds = %.lr.ph357
  %.fca.1.extract.i1122 = extractvalue { ptr, i160 } %3249, 1
  %.sroa.5.8.extract.trunc.i1123 = trunc i160 %.fca.1.extract.i1122 to i64
  %3253 = inttoptr i64 %.sroa.5.8.extract.trunc.i1123 to ptr
  %.sroa.9.8.extract.shift.i1124 = lshr i160 %.fca.1.extract.i1122, 64
  %.sroa.9.8.extract.trunc.i1125 = trunc i160 %.sroa.9.8.extract.shift.i1124 to i64
  %3254 = inttoptr i64 %.sroa.9.8.extract.trunc.i1125 to ptr
  %hash_coef_ptr.i.i144.i1126 = getelementptr i8, ptr %.fca.0.extract.i1074, i64 8
  %tbl_size_ptr.i.i145.i1127 = getelementptr i8, ptr %.fca.0.extract.i1074, i64 16
  %offset_tbl_ptr.i.i146.i1128 = getelementptr i8, ptr %.fca.0.extract.i1074, i64 40
  %hash_coef.i.i147.i1129 = load i64, ptr %hash_coef_ptr.i.i144.i1126, align 4
  %tbl_size.i.i148.i1130 = load i64, ptr %tbl_size_ptr.i.i145.i1127, align 4
  %offset_tbl.i.i149.i1131 = load ptr, ptr %offset_tbl_ptr.i.i146.i1128, align 8
  %product.i.i.i150.i1132 = mul i64 %hash_coef.i.i147.i1129, 4015701072841558310
  %shifted.i.i.i151.i1133 = lshr i64 %product.i.i.i150.i1132, 32
  %xored.i.i.i152.i1134 = xor i64 %shifted.i.i.i151.i1133, %product.i.i.i150.i1132
  %hash.i.i.i153.i1135 = and i64 %xored.i.i.i152.i1134, %tbl_size.i.i148.i1130
  %offset_ptr.i.i154.i1136 = getelementptr i32, ptr %offset_tbl.i.i149.i1131, i64 %hash.i.i.i153.i1135
  %offset.i.i155.i1137 = load i32, ptr %offset_ptr.i.i154.i1136, align 4
  %3255 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i1074, 0
  %3256 = insertvalue { ptr, ptr, ptr, i32 } %3255, ptr %3253, 1
  %3257 = insertvalue { ptr, ptr, ptr, i32 } %3256, ptr %3254, 2
  %3258 = insertvalue { ptr, ptr, ptr, i32 } %3257, i32 %offset.i.i155.i1137, 3
  %3259 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3260 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3261 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i1074)
  %3262 = sext i32 %offset.i.i155.i1137 to i64
  %3263 = getelementptr ptr, ptr %.fca.0.extract.i1074, i64 %3262
  %3264 = getelementptr i8, ptr %3263, i64 64
  %3265 = load ptr, ptr %3264, align 8
  %3266 = call ptr %3265({ ptr, ptr, ptr, i32 } %3258, ptr nonnull %2)
  %3267 = call i32 %3266({ ptr, ptr, ptr, i32 } %3258, { ptr, ptr, ptr, i32 } %3258, ptr nonnull %2)
  %3268 = icmp eq i32 %3267, %3213
  %3269 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3270 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3271 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i1074)
  %3272 = getelementptr i8, ptr %3263, i64 48
  %3273 = load ptr, ptr %3272, align 8
  %3274 = call ptr %3273({ ptr, ptr, ptr, i32 } %3258, ptr nonnull %2)
  %3275 = call { ptr, i160 } %3274({ ptr, ptr, ptr, i32 } %3258, { ptr, ptr, ptr, i32 } %3258, ptr nonnull %2)
  %3276 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3277 = load ptr, ptr %151, align 8
  %3278 = call i1 %3277({ ptr, i160 } %3275, { ptr, i160 } %3210)
  %3279 = and i1 %3268, %3278
  br i1 %3279, label %.thread.i, label %.critedge.i1076

.critedge.i1076:                                  ; preds = %3252, %.lr.ph357
  %3280 = add i32 %3213, 2127912214
  %3281 = shl i32 %3213, 12
  %3282 = add i32 %3280, %3281
  %3283 = ashr i32 %3282, 19
  %3284 = xor i32 %3282, %3283
  %3285 = xor i32 %3284, -949894596
  %3286 = add i32 %3285, 374761393
  %3287 = shl i32 %3285, 5
  %3288 = add i32 %3286, %3287
  %3289 = add i32 %3288, -744332180
  %3290 = shl i32 %3288, 9
  %3291 = xor i32 %3289, %3290
  %3292 = add i32 %3291, -42973499
  %3293 = shl i32 %3291, 3
  %3294 = add i32 %3292, %3293
  %3295 = ashr i32 %3294, 16
  %3296 = xor i32 %3294, %3295
  %3297 = xor i32 %3296, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3298 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3299 = load ptr, ptr %175, align 8
  %3300 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3299, 0
  %3301 = load ptr, ptr %176, align 8
  %3302 = insertvalue { ptr, ptr, ptr, i32 } %3300, ptr %3301, 1
  %3303 = load ptr, ptr %3206, align 8
  %3304 = insertvalue { ptr, ptr, ptr, i32 } %3302, ptr %3303, 2
  %3305 = load i32, ptr %177, align 4
  %3306 = insertvalue { ptr, ptr, ptr, i32 } %3304, i32 %3305, 3
  %hash_coef_ptr.i.i10.i3003 = getelementptr i8, ptr %3299, i64 8
  %tbl_size_ptr.i.i11.i3004 = getelementptr i8, ptr %3299, i64 16
  %offset_tbl_ptr.i.i12.i3005 = getelementptr i8, ptr %3299, i64 40
  %hash_coef.i.i13.i3006 = load i64, ptr %hash_coef_ptr.i.i10.i3003, align 4
  %tbl_size.i.i14.i3007 = load i64, ptr %tbl_size_ptr.i.i11.i3004, align 4
  %offset_tbl.i.i15.i3008 = load ptr, ptr %offset_tbl_ptr.i.i12.i3005, align 8
  %product.i.i.i16.i3009 = mul i64 %hash_coef.i.i13.i3006, -5261542750394134544
  %shifted.i.i.i17.i3010 = lshr i64 %product.i.i.i16.i3009, 32
  %xored.i.i.i18.i3011 = xor i64 %shifted.i.i.i17.i3010, %product.i.i.i16.i3009
  %hash.i.i.i19.i3012 = and i64 %xored.i.i.i18.i3011, %tbl_size.i.i14.i3007
  %offset_ptr.i.i20.i3013 = getelementptr i32, ptr %offset_tbl.i.i15.i3008, i64 %hash.i.i.i19.i3012
  %offset.i.i21.i3014 = load i32, ptr %offset_ptr.i.i20.i3013, align 4
  %eq.i.i3015 = icmp eq i32 %3305, %offset.i.i21.i3014
  call void @llvm.assume(i1 %eq.i.i3015) #30
  %3307 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3308 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3299)
  %3309 = sext i32 %3305 to i64
  %3310 = getelementptr ptr, ptr %3299, i64 %3309
  %3311 = getelementptr i8, ptr %3310, i64 64
  %3312 = load ptr, ptr %3311, align 8
  %3313 = call ptr %3312({ ptr, ptr, ptr, i32 } %3306, ptr nonnull %2)
  %3314 = call i32 %3313({ ptr, ptr, ptr, i32 } %3306, { ptr, ptr, ptr, i32 } %3306, ptr nonnull %2)
  %3315 = add i32 %3314, -1
  %3316 = and i32 %3315, %3297
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3317 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3318 = load ptr, ptr %175, align 8
  %3319 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3318, 0
  %3320 = load ptr, ptr %176, align 8
  %3321 = insertvalue { ptr, ptr, ptr, i32 } %3319, ptr %3320, 1
  %3322 = load ptr, ptr %3206, align 8
  %3323 = insertvalue { ptr, ptr, ptr, i32 } %3321, ptr %3322, 2
  %3324 = load i32, ptr %177, align 4
  %3325 = insertvalue { ptr, ptr, ptr, i32 } %3323, i32 %3324, 3
  %hash_coef_ptr.i.i158.i1081 = getelementptr i8, ptr %3318, i64 8
  %tbl_size_ptr.i.i159.i1082 = getelementptr i8, ptr %3318, i64 16
  %offset_tbl_ptr.i.i160.i1083 = getelementptr i8, ptr %3318, i64 40
  %hash_coef.i.i161.i1084 = load i64, ptr %hash_coef_ptr.i.i158.i1081, align 4
  %tbl_size.i.i162.i1085 = load i64, ptr %tbl_size_ptr.i.i159.i1082, align 4
  %offset_tbl.i.i163.i1086 = load ptr, ptr %offset_tbl_ptr.i.i160.i1083, align 8
  %product.i.i.i164.i1087 = mul i64 %hash_coef.i.i161.i1084, -5261542750394134544
  %shifted.i.i.i165.i1088 = lshr i64 %product.i.i.i164.i1087, 32
  %xored.i.i.i166.i1089 = xor i64 %shifted.i.i.i165.i1088, %product.i.i.i164.i1087
  %hash.i.i.i167.i1090 = and i64 %xored.i.i.i166.i1089, %tbl_size.i.i162.i1085
  %offset_ptr.i.i168.i1091 = getelementptr i32, ptr %offset_tbl.i.i163.i1086, i64 %hash.i.i.i167.i1090
  %offset.i.i169.i1092 = load i32, ptr %offset_ptr.i.i168.i1091, align 4
  %eq.i172.i1093 = icmp eq i32 %3324, %offset.i.i169.i1092
  call void @llvm.assume(i1 %eq.i172.i1093) #30
  store ptr @_parameterization_Ptri32, ptr %105, align 8
  %3326 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %105)
  %3327 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3318)
  %3328 = sext i32 %3324 to i64
  %3329 = getelementptr ptr, ptr %3318, i64 %3328
  %3330 = getelementptr i8, ptr %3329, i64 120
  %3331 = load ptr, ptr %3330, align 8
  store ptr @i32_typ, ptr %106, align 8
  %3332 = call ptr %3331({ ptr, ptr, ptr, i32 } %3325, ptr nonnull %106)
  %3333 = call { ptr, i160 } %3332({ ptr, ptr, ptr, i32 } %3325, { ptr, ptr, ptr, i32 } %3325, ptr nonnull %105, i32 %3316)
  %.fca.0.extract57.i1094 = extractvalue { ptr, i160 } %3333, 0
  %3334 = icmp ne ptr %.fca.0.extract57.i1094, @nil_typ
  %3335 = icmp ne ptr %.fca.0.extract57.i1094, null
  %.not128.i1095 = and i1 %3334, %3335
  br i1 %.not128.i1095, label %3336, label %HashMap_get_keyK.exit1139

3336:                                             ; preds = %.critedge.i1076
  %.fca.1.extract59.i1096 = extractvalue { ptr, i160 } %3333, 1
  %.sroa.6.8.extract.trunc.i1097 = trunc i160 %.fca.1.extract59.i1096 to i64
  %3337 = inttoptr i64 %.sroa.6.8.extract.trunc.i1097 to ptr
  %.sroa.11.8.extract.shift.i1098 = lshr i160 %.fca.1.extract59.i1096, 64
  %.sroa.11.8.extract.trunc.i1099 = trunc i160 %.sroa.11.8.extract.shift.i1098 to i64
  %3338 = inttoptr i64 %.sroa.11.8.extract.trunc.i1099 to ptr
  %hash_coef_ptr.i.i174.i1100 = getelementptr i8, ptr %.fca.0.extract57.i1094, i64 8
  %tbl_size_ptr.i.i175.i1101 = getelementptr i8, ptr %.fca.0.extract57.i1094, i64 16
  %offset_tbl_ptr.i.i176.i1102 = getelementptr i8, ptr %.fca.0.extract57.i1094, i64 40
  %hash_coef.i.i177.i1103 = load i64, ptr %hash_coef_ptr.i.i174.i1100, align 4
  %tbl_size.i.i178.i1104 = load i64, ptr %tbl_size_ptr.i.i175.i1101, align 4
  %offset_tbl.i.i179.i1105 = load ptr, ptr %offset_tbl_ptr.i.i176.i1102, align 8
  %product.i.i.i180.i1106 = mul i64 %hash_coef.i.i177.i1103, 4015701072841558310
  %shifted.i.i.i181.i1107 = lshr i64 %product.i.i.i180.i1106, 32
  %xored.i.i.i182.i1108 = xor i64 %shifted.i.i.i181.i1107, %product.i.i.i180.i1106
  %hash.i.i.i183.i1109 = and i64 %xored.i.i.i182.i1108, %tbl_size.i.i178.i1104
  %offset_ptr.i.i184.i1110 = getelementptr i32, ptr %offset_tbl.i.i179.i1105, i64 %hash.i.i.i183.i1109
  %offset.i.i185.i1111 = load i32, ptr %offset_ptr.i.i184.i1110, align 4
  %3339 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i1094, 0
  %3340 = insertvalue { ptr, ptr, ptr, i32 } %3339, ptr %3337, 1
  %3341 = insertvalue { ptr, ptr, ptr, i32 } %3340, ptr %3338, 2
  %3342 = insertvalue { ptr, ptr, ptr, i32 } %3341, i32 %offset.i.i185.i1111, 3
  %3343 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3344 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3345 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i1094)
  %3346 = sext i32 %offset.i.i185.i1111 to i64
  %3347 = getelementptr ptr, ptr %.fca.0.extract57.i1094, i64 %3346
  %3348 = getelementptr i8, ptr %3347, i64 64
  %3349 = load ptr, ptr %3348, align 8
  %3350 = call ptr %3349({ ptr, ptr, ptr, i32 } %3342, ptr nonnull %2)
  %3351 = call i32 %3350({ ptr, ptr, ptr, i32 } %3342, { ptr, ptr, ptr, i32 } %3342, ptr nonnull %2)
  %3352 = icmp eq i32 %3351, %3213
  %3353 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3354 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3355 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i1094)
  %3356 = getelementptr i8, ptr %3347, i64 48
  %3357 = load ptr, ptr %3356, align 8
  %3358 = call ptr %3357({ ptr, ptr, ptr, i32 } %3342, ptr nonnull %2)
  %3359 = call { ptr, i160 } %3358({ ptr, ptr, ptr, i32 } %3342, { ptr, ptr, ptr, i32 } %3342, ptr nonnull %2)
  %3360 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3361 = load ptr, ptr %151, align 8
  %3362 = call i1 %3361({ ptr, i160 } %3359, { ptr, i160 } %3210)
  %3363 = and i1 %3352, %3362
  br i1 %3363, label %.thread.i, label %HashMap_get_keyK.exit1139

.thread.i:                                        ; preds = %3336, %3252
  %.pre-phi313.i1113 = phi i64 [ %3262, %3252 ], [ %3346, %3336 ]
  %.pre-phi312.i1114 = phi { ptr, ptr, ptr, i32 } [ %3258, %3252 ], [ %3342, %3336 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i1115 = phi ptr [ %.fca.0.extract.i1074, %3252 ], [ %.fca.0.extract57.i1094, %3336 ]
  %.reg2mem59.0.sroa.phi120289.i1116 = phi ptr [ %.sroa.1.i1038, %3252 ], [ %.sroa.2124.i1042, %3336 ]
  %.reg2mem59.0.sroa.phi117288.i1117 = phi ptr [ %.sroa.0271.i1037, %3252 ], [ %.sroa.0123.i1041, %3336 ]
  %.reg2mem57.0.sroa.phi94287.i1118 = phi ptr [ %.sroa.2.i1040, %3252 ], [ %.sroa.2116.i1044, %3336 ]
  %.reg2mem57.0.sroa.phi91286.i1119 = phi ptr [ %.sroa.0.i1039, %3252 ], [ %.sroa.0115.i1043, %3336 ]
  %3364 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3365 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3366 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i1115)
  %3367 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i1115, i64 %.pre-phi313.i1113
  %3368 = getelementptr i8, ptr %3367, i64 56
  %3369 = load ptr, ptr %3368, align 8
  %3370 = call ptr %3369({ ptr, ptr, ptr, i32 } %.pre-phi312.i1114, ptr nonnull %2)
  %3371 = call { ptr, i160 } %3370({ ptr, ptr, ptr, i32 } %.pre-phi312.i1114, { ptr, ptr, ptr, i32 } %.pre-phi312.i1114, ptr nonnull %2)
  %.fca.0.extract97.i1120 = extractvalue { ptr, i160 } %3371, 0
  store ptr %.fca.0.extract97.i1120, ptr %.reg2mem59.0.sroa.phi117288.i1117, align 8
  %.fca.1.extract99.i1121 = extractvalue { ptr, i160 } %3371, 1
  store i160 %.fca.1.extract99.i1121, ptr %.reg2mem59.0.sroa.phi120289.i1116, align 8
  store ptr %.fca.0.extract97.i1120, ptr %.reg2mem57.0.sroa.phi91286.i1119, align 8
  store i160 %.fca.1.extract99.i1121, ptr %.reg2mem57.0.sroa.phi94287.i1118, align 8
  br label %HashMap_get_keyK.exit1139

HashMap_get_keyK.exit1139:                        ; preds = %.critedge.i1076, %3336, %.thread.i
  %.reg2mem51.sroa.0.0.i = phi ptr [ %.fca.0.extract97.i1120, %.thread.i ], [ @nil_typ, %3336 ], [ @nil_typ, %.critedge.i1076 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i1037)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i1038)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1039)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i1040)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i1041)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i1042)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i1043)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i1044)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %108)
  %3372 = icmp ne ptr %.reg2mem51.sroa.0.0.i, @nil_typ
  %3373 = icmp ne ptr %.reg2mem51.sroa.0.0.i, null
  %.not344 = and i1 %3372, %3373
  %3374 = zext i1 %.not344 to i32
  %.reg2mem136.0 = add i32 %.reg2mem142.0354, %3374
  %not..not344 = xor i1 %.not344, true
  %3375 = zext i1 %not..not344 to i32
  %.reg2mem138.0 = add i32 %.reg2mem144.0355, %3375
  %3376 = add nuw nsw i32 %.reg2mem140.0353, 1
  %3377 = icmp slt i32 %3376, %3201
  br i1 %3377, label %.lr.ph357, label %3378

3378:                                             ; preds = %HashMap_get_keyK.exit1139
  %3379 = call i64 @clock()
  %3380 = mul i32 %.reg2mem136.0, 100
  %3381 = sdiv i32 %3380, %3201
  %.fr = freeze i32 %3381
  %3382 = icmp slt i32 %.fr, 5
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

3383:                                             ; preds = %._crit_edge352
  %3384 = call i64 @clock()
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit: ; preds = %3378, %3383
  %3385 = phi i64 [ %3379, %3378 ], [ %3384, %3383 ]
  %.reg2mem144.0.lcssa365 = phi i32 [ %.reg2mem138.0, %3378 ], [ 0, %3383 ]
  %.reg2mem142.0.lcssa363 = phi i32 [ %.reg2mem136.0, %3378 ], [ 0, %3383 ]
  %.reg2mem122.0.in = phi i1 [ %3382, %3378 ], [ true, %3383 ]
  %result.i168 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %result.i168, align 16
  %result.i169 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3386 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i169, 1
  %3387 = insertvalue { ptr, ptr, ptr, i32 } %3386, ptr undef, 2
  %3388 = insertvalue { ptr, ptr, ptr, i32 } %3387, i32 9, 3
  store ptr %result.i168, ptr %result.i169, align 8
  %3389 = getelementptr i8, ptr %result.i169, i64 8
  store i32 15, ptr %3389, align 4
  %3390 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3391 = getelementptr i8, ptr %result.i169, i64 12
  store i32 16, ptr %3391, align 4
  %3392 = sub i64 %3385, %3202
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %3388, i32 %3201, i64 %3392)
  %result.i170 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nonnull @current_ptr) #29
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i170, align 32
  %result.i171 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3393 = getelementptr inbounds i8, ptr %139, i64 8
  %3394 = getelementptr inbounds i8, ptr %139, i64 24
  store ptr @String, ptr %139, align 8
  store ptr %result.i171, ptr %3393, align 8
  store i32 9, ptr %3394, align 8
  %3395 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %139)
  store ptr %result.i170, ptr %result.i171, align 8
  %3396 = getelementptr i8, ptr %result.i171, i64 8
  store i32 18, ptr %3396, align 4
  %3397 = getelementptr i8, ptr %result.i171, i64 12
  store i32 19, ptr %3397, align 4
  %3398 = load i160, ptr %3393, align 8
  %3399 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i = trunc i160 %3398 to i64
  %3400 = inttoptr i64 %.sroa.3.8.extract.trunc.i to ptr
  %3401 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3402 = getelementptr i8, ptr %3400, i64 8
  %3403 = load i32, ptr %3402, align 4
  %3404 = add i32 %3403, 1
  %3405 = sext i32 %3404 to i64
  %result.i.i1948 = call noalias ptr @bump_malloc_inner(i64 noundef %3405, ptr nonnull @current_ptr) #29
  %3406 = load i32, ptr %3402, align 4
  %3407 = icmp sgt i32 %3406, 0
  br i1 %3407, label %.lr.ph.i1949, label %String_c_string_.exit

.lr.ph.i1949:                                     ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %3408 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3409 = load ptr, ptr %3400, align 8
  %3410 = zext nneg i32 %3406 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1948, ptr align 1 %3409, i64 %3410, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %.lr.ph.i1949, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %3411 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3412 = sext i32 %3406 to i64
  %3413 = getelementptr i8, ptr %result.i.i1948, i64 %3412
  store i8 0, ptr %3413, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1948)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i172 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nonnull @current_ptr) #29
  %. = select i1 %.reg2mem122.0.in, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.1178 = select i1 %.reg2mem122.0.in, ptr %140, ptr %141
  store <4 x i8> %., ptr %result.i172, align 4
  %result.i173 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %.1178.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem122.0.in, ptr %140, ptr %141
  %.1178.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.1178.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  %.1178.sroa.sel2034.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem122.0.in, ptr %140, ptr %141
  %.1178.sroa.sel2034.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.1178.sroa.sel2034.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 24
  store ptr @String, ptr %.1178, align 8
  store ptr %result.i173, ptr %.1178.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store i32 9, ptr %.1178.sroa.sel2034.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %3414 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %.1178)
  store ptr %result.i172, ptr %result.i173, align 8
  %3415 = getelementptr i8, ptr %result.i173, i64 8
  store i32 4, ptr %3415, align 4
  %3416 = getelementptr i8, ptr %result.i173, i64 12
  store i32 5, ptr %3416, align 4
  %3417 = load i160, ptr %.1178.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %3418 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i752 = trunc i160 %3417 to i64
  %3419 = inttoptr i64 %.sroa.3.8.extract.trunc.i752 to ptr
  %3420 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3421 = getelementptr i8, ptr %3419, i64 8
  %3422 = load i32, ptr %3421, align 4
  %3423 = add i32 %3422, 1
  %3424 = sext i32 %3423 to i64
  %result.i.i1965 = call noalias ptr @bump_malloc_inner(i64 noundef %3424, ptr nonnull @current_ptr) #29
  %3425 = load i32, ptr %3421, align 4
  %3426 = icmp sgt i32 %3425, 0
  br i1 %3426, label %.lr.ph.i1966, label %String_c_string_.exit1970

.lr.ph.i1966:                                     ; preds = %String_c_string_.exit
  %3427 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3428 = load ptr, ptr %3419, align 8
  %3429 = zext nneg i32 %3425 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1965, ptr align 1 %3428, i64 %3429, i1 false)
  br label %String_c_string_.exit1970

String_c_string_.exit1970:                        ; preds = %.lr.ph.i1966, %String_c_string_.exit
  %3430 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3431 = sext i32 %3425 to i64
  %3432 = getelementptr i8, ptr %result.i.i1965, i64 %3431
  store i8 0, ptr %3432, align 1
  %puts.i768 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1965)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i212 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nonnull @current_ptr) #29
  store <13 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %result.i212, align 16
  %result.i213 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3433 = getelementptr inbounds i8, ptr %142, i64 8
  %3434 = getelementptr inbounds i8, ptr %142, i64 24
  store ptr @String, ptr %142, align 8
  store ptr %result.i213, ptr %3433, align 8
  store i32 9, ptr %3434, align 8
  %3435 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %142)
  store ptr %result.i212, ptr %result.i213, align 8
  %3436 = getelementptr i8, ptr %result.i213, i64 8
  store i32 13, ptr %3436, align 4
  %3437 = getelementptr i8, ptr %result.i213, i64 12
  store i32 14, ptr %3437, align 4
  %3438 = load i160, ptr %3433, align 8
  %3439 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i772 = trunc i160 %3438 to i64
  %3440 = inttoptr i64 %.sroa.3.8.extract.trunc.i772 to ptr
  %3441 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3442 = getelementptr i8, ptr %3440, i64 8
  %3443 = load i32, ptr %3442, align 4
  %3444 = add i32 %3443, 1
  %3445 = sext i32 %3444 to i64
  %result.i.i1985 = call noalias ptr @bump_malloc_inner(i64 noundef %3445, ptr nonnull @current_ptr) #29
  %3446 = load i32, ptr %3442, align 4
  %3447 = icmp sgt i32 %3446, 0
  br i1 %3447, label %.lr.ph.i1986, label %String_c_string_.exit1990

.lr.ph.i1986:                                     ; preds = %String_c_string_.exit1970
  %3448 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3449 = load ptr, ptr %3440, align 8
  %3450 = zext nneg i32 %3446 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1985, ptr align 1 %3449, i64 %3450, i1 false)
  br label %String_c_string_.exit1990

String_c_string_.exit1990:                        ; preds = %.lr.ph.i1986, %String_c_string_.exit1970
  %3451 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3452 = sext i32 %3446 to i64
  %3453 = getelementptr i8, ptr %result.i.i1985, i64 %3452
  store i8 0, ptr %3453, align 1
  %puts.i788 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1985)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3454 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %.reg2mem144.0.lcssa365)
  %result.i250 = call noalias dereferenceable_or_null(9) ptr @bump_malloc_inner(i64 noundef 9, ptr nonnull @current_ptr) #29
  store <8 x i8> <i8 44, i8 32, i8 72, i8 105, i8 116, i8 115, i8 58, i8 32>, ptr %result.i250, align 8
  %result.i251 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3455 = getelementptr inbounds i8, ptr %143, i64 8
  %3456 = getelementptr inbounds i8, ptr %143, i64 24
  store ptr @String, ptr %143, align 8
  store ptr %result.i251, ptr %3455, align 8
  store i32 9, ptr %3456, align 8
  %3457 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %143)
  store ptr %result.i250, ptr %result.i251, align 8
  %3458 = getelementptr i8, ptr %result.i251, i64 8
  store i32 8, ptr %3458, align 4
  %3459 = getelementptr i8, ptr %result.i251, i64 12
  store i32 9, ptr %3459, align 4
  %3460 = load i160, ptr %3455, align 8
  %3461 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i793 = trunc i160 %3460 to i64
  %3462 = inttoptr i64 %.sroa.3.8.extract.trunc.i793 to ptr
  %3463 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3464 = getelementptr i8, ptr %3462, i64 8
  %3465 = load i32, ptr %3464, align 4
  %3466 = add i32 %3465, 1
  %3467 = sext i32 %3466 to i64
  %result.i.i2005 = call noalias ptr @bump_malloc_inner(i64 noundef %3467, ptr nonnull @current_ptr) #29
  %3468 = load i32, ptr %3464, align 4
  %3469 = icmp sgt i32 %3468, 0
  br i1 %3469, label %.lr.ph.i2006, label %String_c_string_.exit2010

.lr.ph.i2006:                                     ; preds = %String_c_string_.exit1990
  %3470 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3471 = load ptr, ptr %3462, align 8
  %3472 = zext nneg i32 %3468 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i2005, ptr align 1 %3471, i64 %3472, i1 false)
  br label %String_c_string_.exit2010

String_c_string_.exit2010:                        ; preds = %.lr.ph.i2006, %String_c_string_.exit1990
  %3473 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3474 = sext i32 %3468 to i64
  %3475 = getelementptr i8, ptr %result.i.i2005, i64 %3474
  store i8 0, ptr %3475, align 1
  %puts.i809 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2005)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3476 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %.reg2mem142.0.lcssa363)
  %result.i288 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nonnull @current_ptr) #29
  store <1 x i8> <i8 41>, ptr %result.i288, align 1
  %result.i289 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3477 = getelementptr inbounds i8, ptr %144, i64 8
  %3478 = getelementptr inbounds i8, ptr %144, i64 24
  store ptr @String, ptr %144, align 8
  store ptr %result.i289, ptr %3477, align 8
  store i32 9, ptr %3478, align 8
  %3479 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %144)
  store ptr %result.i288, ptr %result.i289, align 8
  %3480 = getelementptr i8, ptr %result.i289, i64 8
  store i32 1, ptr %3480, align 4
  %3481 = getelementptr i8, ptr %result.i289, i64 12
  store i32 2, ptr %3481, align 4
  %3482 = load i160, ptr %3477, align 8
  %3483 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i814 = trunc i160 %3482 to i64
  %3484 = inttoptr i64 %.sroa.3.8.extract.trunc.i814 to ptr
  %3485 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3486 = getelementptr i8, ptr %3484, i64 8
  %3487 = load i32, ptr %3486, align 4
  %3488 = add i32 %3487, 1
  %3489 = sext i32 %3488 to i64
  %result.i.i2025 = call noalias ptr @bump_malloc_inner(i64 noundef %3489, ptr nonnull @current_ptr) #29
  %3490 = load i32, ptr %3486, align 4
  %3491 = icmp sgt i32 %3490, 0
  br i1 %3491, label %.lr.ph.i2026, label %String_c_string_.exit2030

.lr.ph.i2026:                                     ; preds = %String_c_string_.exit2010
  %3492 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3493 = load ptr, ptr %3484, align 8
  %3494 = zext nneg i32 %3490 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i2025, ptr align 1 %3493, i64 %3494, i1 false)
  br label %String_c_string_.exit2030

String_c_string_.exit2030:                        ; preds = %.lr.ph.i2026, %String_c_string_.exit2010
  %3495 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3496 = sext i32 %3490 to i64
  %3497 = getelementptr i8, ptr %result.i.i2025, i64 %3496
  store i8 0, ptr %3497, align 1
  %puts.i830 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2025)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [1 x ptr], align 8
  %4 = alloca { ptr }, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca [2 x ptr], align 8
  %12 = alloca { ptr, ptr }, align 8
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %.sroa.0680.i2286 = alloca ptr, align 8
  %16 = alloca i64, align 8
  %17 = alloca [1 x ptr], align 8
  %18 = alloca { ptr }, align 8
  %19 = alloca [2 x ptr], align 8
  %20 = alloca { ptr, ptr }, align 8
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %.sroa.0.i2288 = alloca ptr, align 8
  %24 = alloca i64, align 8
  %25 = alloca [1 x ptr], align 8
  %26 = alloca { ptr }, align 8
  %27 = alloca [1 x ptr], align 8
  %28 = alloca { ptr }, align 8
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  %30 = alloca { ptr, ptr, ptr, i32 }, align 8
  %31 = alloca [1 x ptr], align 8
  %32 = alloca { ptr }, align 8
  %33 = alloca [2 x ptr], align 8
  %34 = alloca { ptr, ptr }, align 8
  %35 = alloca i32, align 4
  %36 = alloca i32, align 4
  %37 = alloca i32, align 4
  %.sroa.0680.i1975 = alloca ptr, align 8
  %38 = alloca i64, align 8
  %39 = alloca [1 x ptr], align 8
  %40 = alloca { ptr }, align 8
  %41 = alloca [2 x ptr], align 8
  %42 = alloca { ptr, ptr }, align 8
  %43 = alloca i32, align 4
  %44 = alloca i32, align 4
  %45 = alloca i32, align 4
  %.sroa.0.i1976 = alloca ptr, align 8
  %46 = alloca i64, align 8
  %47 = alloca { ptr, ptr, ptr, i32 }, align 8
  %48 = alloca [1 x ptr], align 8
  %49 = alloca { ptr }, align 8
  %50 = alloca [1 x ptr], align 8
  %51 = alloca { ptr }, align 8
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = alloca { ptr, ptr, ptr, i32 }, align 8
  %54 = alloca [1 x ptr], align 8
  %55 = alloca { ptr }, align 8
  %56 = alloca [1 x ptr], align 8
  %57 = alloca { ptr }, align 8
  %58 = alloca { ptr, ptr, ptr, i32 }, align 8
  %59 = alloca { ptr, ptr, ptr, i32 }, align 8
  %60 = alloca [1 x ptr], align 8
  %61 = alloca { ptr }, align 8
  %62 = alloca [2 x ptr], align 8
  %63 = alloca { ptr, ptr }, align 8
  %64 = alloca i32, align 4
  %65 = alloca i32, align 4
  %66 = alloca i32, align 4
  %.sroa.0680.i1329 = alloca ptr, align 8
  %67 = alloca i64, align 8
  %68 = alloca [1 x ptr], align 8
  %69 = alloca { ptr }, align 8
  %70 = alloca [2 x ptr], align 8
  %71 = alloca { ptr, ptr }, align 8
  %72 = alloca i32, align 4
  %73 = alloca i32, align 4
  %74 = alloca i32, align 4
  %.sroa.0.i1331 = alloca ptr, align 8
  %75 = alloca i64, align 8
  %76 = alloca [1 x ptr], align 8
  %77 = alloca { ptr }, align 8
  %78 = alloca [1 x ptr], align 8
  %79 = alloca { ptr }, align 8
  %80 = alloca { ptr, ptr, ptr, i32 }, align 8
  %81 = alloca { ptr, ptr, ptr, i32 }, align 8
  %82 = alloca [1 x ptr], align 8
  %83 = alloca { ptr }, align 8
  %84 = alloca [2 x ptr], align 8
  %85 = alloca { ptr, ptr }, align 8
  %86 = alloca i32, align 4
  %87 = alloca i32, align 4
  %88 = alloca i32, align 4
  %.sroa.0680.i = alloca ptr, align 8
  %89 = alloca i64, align 8
  %90 = alloca [1 x ptr], align 8
  %91 = alloca { ptr }, align 8
  %92 = alloca [2 x ptr], align 8
  %93 = alloca { ptr, ptr }, align 8
  %94 = alloca i32, align 4
  %95 = alloca i32, align 4
  %96 = alloca i32, align 4
  %.sroa.0.i1117 = alloca ptr, align 8
  %97 = alloca i64, align 8
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  %99 = alloca [1 x ptr], align 8
  %100 = alloca { ptr }, align 8
  %101 = alloca [1 x ptr], align 8
  %102 = alloca { ptr }, align 8
  %103 = alloca { ptr, ptr, ptr, i32 }, align 8
  %104 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.sroa.0271.i840 = alloca ptr, align 8
  %.sroa.1.i841 = alloca i160, align 8
  %.sroa.0.i842 = alloca ptr, align 8
  %.sroa.2.i843 = alloca i160, align 8
  %105 = alloca [1 x ptr], align 8
  %106 = alloca { ptr }, align 8
  %.sroa.0123.i844 = alloca ptr, align 8
  %.sroa.2124.i845 = alloca i160, align 8
  %.sroa.0115.i846 = alloca ptr, align 8
  %.sroa.2116.i847 = alloca i160, align 8
  %107 = alloca [1 x ptr], align 8
  %108 = alloca { ptr }, align 8
  %109 = alloca [2 x ptr], align 8
  %110 = alloca { ptr, ptr }, align 8
  %111 = alloca [1 x ptr], align 8
  %112 = alloca { ptr }, align 8
  %113 = alloca [2 x ptr], align 8
  %114 = alloca { ptr, ptr }, align 8
  %115 = alloca [1 x ptr], align 8
  %116 = alloca { ptr }, align 8
  %117 = alloca { ptr, ptr, ptr, i32 }, align 8
  %118 = alloca [2 x ptr], align 8
  %119 = alloca { ptr, ptr }, align 8
  %120 = alloca [1 x ptr], align 8
  %121 = alloca { ptr }, align 8
  %122 = alloca { ptr, ptr, ptr, i32 }, align 8
  %123 = alloca [2 x ptr], align 8
  %124 = alloca { ptr, ptr }, align 8
  %125 = alloca { ptr, ptr, ptr, i32 }, align 8
  %126 = alloca [1 x ptr], align 8
  %127 = alloca { ptr }, align 8
  %128 = alloca { ptr, ptr, ptr, i32 }, align 8
  %129 = alloca [2 x ptr], align 8
  %130 = alloca { ptr, ptr }, align 8
  %131 = alloca [1 x ptr], align 8
  %132 = alloca { ptr }, align 8
  %133 = alloca { ptr, ptr, ptr, i32 }, align 8
  %134 = alloca [2 x ptr], align 8
  %135 = alloca { ptr, ptr }, align 8
  %136 = alloca { ptr, ptr, ptr, i32 }, align 8
  %137 = alloca [1 x ptr], align 8
  %138 = alloca { ptr }, align 8
  %.sroa.0271.i = alloca ptr, align 8
  %.sroa.1.i = alloca i160, align 8
  %.sroa.0.i = alloca ptr, align 8
  %.sroa.2.i = alloca i160, align 8
  %139 = alloca [1 x ptr], align 8
  %140 = alloca { ptr }, align 8
  %.sroa.0123.i = alloca ptr, align 8
  %.sroa.2124.i = alloca i160, align 8
  %.sroa.0115.i = alloca ptr, align 8
  %.sroa.2116.i = alloca i160, align 8
  %141 = alloca [1 x ptr], align 8
  %142 = alloca { ptr }, align 8
  %oldProtect.i140 = alloca i32, align 4
  %oldProtect.i136 = alloca i32, align 4
  %oldProtect.i101 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.064.sroa.0 = alloca i8, align 8
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  %144 = alloca { ptr, ptr, ptr, i32 }, align 8
  %145 = alloca { ptr, ptr, ptr, i32 }, align 8
  %146 = alloca { ptr, ptr, ptr, i32 }, align 8
  %147 = alloca { ptr, ptr, ptr, i32 }, align 8
  %result.i = tail call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i, align 8
  %148 = getelementptr i8, ptr %result.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %148, align 8
  %149 = getelementptr i8, ptr %result.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %149, align 8
  %150 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i)
  %result.i98 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i99 = call i32 @VirtualProtect(ptr %result.i98, i64 16, i32 64, ptr nonnull %oldProtect.i) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr %result.i98, ptr nonnull @gojtwpxwke, ptr nonnull @i32_hasher)
  %ret.i = call ptr @llvm.adjust.trampoline(ptr readonly %result.i98) #31
  %151 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i98)
  %result.i100 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i101)
  %result.i102 = call i32 @VirtualProtect(ptr %result.i100, i64 16, i32 64, ptr nonnull %oldProtect.i101) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i101)
  call void @llvm.init.trampoline(ptr %result.i100, ptr nonnull @cwuqubmlcx, ptr nonnull @i32_eq)
  %ret.i103 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i100) #31
  %152 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i100)
  %153 = getelementptr i8, ptr %result.i, i64 96
  store ptr %ret.i, ptr %153, align 8
  %154 = getelementptr i8, ptr %result.i, i64 104
  store ptr %ret.i103, ptr %154, align 8
  %result.i.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %155 = getelementptr i8, ptr %result.i.i, i64 16
  store ptr @_parameterization_Nil, ptr %155, align 8
  %result.i4.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %156 = getelementptr i8, ptr %result.i4.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %156, align 8
  %157 = getelementptr i8, ptr %result.i4.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %157, align 8
  %158 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i)
  store ptr @Entry, ptr %result.i4.i, align 8
  %159 = getelementptr i8, ptr %result.i.i, i64 8
  store ptr %result.i4.i, ptr %159, align 8
  %160 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i)
  store ptr @union_typ, ptr %result.i.i, align 8
  %result.i5.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i, ptr %result.i5.i, align 8
  %161 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i)
  %162 = getelementptr i8, ptr %result.i5.i, i64 16
  store i32 8, ptr %162, align 4
  %163 = getelementptr i8, ptr %result.i5.i, i64 20
  store i32 8, ptr %163, align 4
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %164 = getelementptr i8, ptr %result.i5.i, i64 8
  store ptr %result.i.i.i, ptr %164, align 8
  %165 = getelementptr i8, ptr %result.i, i64 24
  store ptr @Array, ptr %165, align 8
  %166 = getelementptr i8, ptr %result.i, i64 32
  store ptr %result.i5.i, ptr %166, align 8
  %167 = getelementptr i8, ptr %result.i, i64 48
  store i32 9, ptr %167, align 4
  %result.i20.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %168 = getelementptr i8, ptr %result.i20.i, i64 16
  store ptr @_parameterization_Nil, ptr %168, align 8
  %result.i21.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %169 = getelementptr i8, ptr %result.i21.i, i64 16
  store ptr @_parameterization_Ptri32, ptr %169, align 8
  %170 = getelementptr i8, ptr %result.i21.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %170, align 8
  %171 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i)
  store ptr @Entry, ptr %result.i21.i, align 8
  %172 = getelementptr i8, ptr %result.i20.i, i64 8
  store ptr %result.i21.i, ptr %172, align 8
  %173 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i)
  store ptr @union_typ, ptr %result.i20.i, align 8
  %result.i22.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i, ptr %result.i22.i, align 8
  %174 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i)
  %175 = getelementptr i8, ptr %result.i22.i, i64 16
  store i32 8, ptr %175, align 4
  %176 = getelementptr i8, ptr %result.i22.i, i64 20
  store i32 8, ptr %176, align 4
  %result.i.i97.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %177 = getelementptr i8, ptr %result.i22.i, i64 8
  store ptr %result.i.i97.i, ptr %177, align 8
  %178 = getelementptr i8, ptr %result.i, i64 56
  store ptr @Array, ptr %178, align 8
  %179 = getelementptr i8, ptr %result.i, i64 64
  store ptr %result.i22.i, ptr %179, align 8
  %180 = getelementptr i8, ptr %result.i, i64 80
  store i32 9, ptr %180, align 4
  %181 = getelementptr i8, ptr %result.i, i64 112
  store i32 100, ptr %181, align 4
  %result.i104 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  %182 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  store i32 101112, ptr %result.i104, align 4
  %result.i119 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i119, align 8
  %183 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i119)
  %184 = getelementptr i8, ptr %result.i119, i64 20
  store i32 %0, ptr %184, align 4
  %185 = sext i32 %0 to i64
  %186 = shl nsw i64 %185, 5
  %result.i.i321 = call noalias ptr @bump_malloc_inner(i64 noundef %186, ptr nonnull @current_ptr) #29
  %187 = getelementptr i8, ptr %result.i119, i64 8
  store ptr %result.i.i321, ptr %187, align 8
  %result.i134 = call noalias dereferenceable_or_null(120) ptr @bump_malloc_inner(i64 noundef 120, ptr nonnull @current_ptr) #29
  store ptr @_parameterization_Ptri32, ptr %result.i134, align 8
  %188 = getelementptr i8, ptr %result.i134, i64 8
  store ptr @_parameterization_Ptri1, ptr %188, align 8
  %189 = getelementptr i8, ptr %result.i134, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %189, align 8
  %190 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i134)
  %result.i135 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i136)
  %result.i137 = call i32 @VirtualProtect(ptr %result.i135, i64 16, i32 64, ptr nonnull %oldProtect.i136) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i136)
  call void @llvm.init.trampoline(ptr %result.i135, ptr nonnull @ojkmfkcqig, ptr nonnull @i32_hasher)
  %ret.i138 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i135) #31
  %191 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i135)
  %result.i139 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i140)
  %result.i141 = call i32 @VirtualProtect(ptr %result.i139, i64 16, i32 64, ptr nonnull %oldProtect.i140) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i140)
  call void @llvm.init.trampoline(ptr %result.i139, ptr nonnull @sfgguycfej, ptr nonnull @i32_eq)
  %ret.i142 = call ptr @llvm.adjust.trampoline(ptr readonly %result.i139) #31
  %192 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i139)
  %193 = getelementptr i8, ptr %result.i134, i64 96
  store ptr %ret.i138, ptr %193, align 8
  %194 = getelementptr i8, ptr %result.i134, i64 104
  store ptr %ret.i142, ptr %194, align 8
  %result.i.i435 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %195 = getelementptr i8, ptr %result.i.i435, i64 16
  store ptr @_parameterization_Nil, ptr %195, align 8
  %result.i4.i436 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %196 = getelementptr i8, ptr %result.i4.i436, i64 16
  store ptr @_parameterization_Ptri1, ptr %196, align 8
  %197 = getelementptr i8, ptr %result.i4.i436, i64 8
  store ptr @_parameterization_Ptri32, ptr %197, align 8
  %198 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i4.i436)
  store ptr @Entry, ptr %result.i4.i436, align 8
  %199 = getelementptr i8, ptr %result.i.i435, i64 8
  store ptr %result.i4.i436, ptr %199, align 8
  %200 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i435)
  store ptr @union_typ, ptr %result.i.i435, align 8
  %result.i5.i437 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i.i435, ptr %result.i5.i437, align 8
  %201 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i5.i437)
  %202 = getelementptr i8, ptr %result.i5.i437, i64 16
  store i32 8, ptr %202, align 4
  %203 = getelementptr i8, ptr %result.i5.i437, i64 20
  store i32 8, ptr %203, align 4
  %result.i.i.i438 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %204 = getelementptr i8, ptr %result.i5.i437, i64 8
  store ptr %result.i.i.i438, ptr %204, align 8
  %205 = getelementptr i8, ptr %result.i134, i64 24
  store ptr @Array, ptr %205, align 8
  %206 = getelementptr i8, ptr %result.i134, i64 32
  store ptr %result.i5.i437, ptr %206, align 8
  %207 = getelementptr i8, ptr %result.i134, i64 40
  %208 = getelementptr i8, ptr %result.i134, i64 48
  store i32 9, ptr %208, align 4
  %result.i20.i439 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %209 = getelementptr i8, ptr %result.i20.i439, i64 16
  store ptr @_parameterization_Nil, ptr %209, align 8
  %result.i21.i440 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %210 = getelementptr i8, ptr %result.i21.i440, i64 16
  store ptr @_parameterization_Ptri1, ptr %210, align 8
  %211 = getelementptr i8, ptr %result.i21.i440, i64 8
  store ptr @_parameterization_Ptri32, ptr %211, align 8
  %212 = getelementptr i8, ptr %result.i21.i440, i64 24
  store ptr null, ptr %212, align 8
  %213 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i21.i440)
  store ptr @Entry, ptr %result.i21.i440, align 8
  %214 = getelementptr i8, ptr %result.i20.i439, i64 8
  store ptr %result.i21.i440, ptr %214, align 8
  %215 = getelementptr i8, ptr %result.i20.i439, i64 24
  store ptr null, ptr %215, align 8
  %216 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i20.i439)
  store ptr @union_typ, ptr %result.i20.i439, align 8
  %result.i22.i441 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i20.i439, ptr %result.i22.i441, align 8
  %217 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i22.i441)
  %218 = getelementptr i8, ptr %result.i22.i441, i64 16
  store i32 8, ptr %218, align 4
  %219 = getelementptr i8, ptr %result.i22.i441, i64 20
  store i32 8, ptr %219, align 4
  %result.i.i97.i442 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nonnull @current_ptr) #29
  %220 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %221 = getelementptr i8, ptr %result.i22.i441, i64 8
  store ptr %result.i.i97.i442, ptr %221, align 8
  %222 = getelementptr i8, ptr %result.i134, i64 56
  store ptr @Array, ptr %222, align 8
  %223 = getelementptr i8, ptr %result.i134, i64 64
  store ptr %result.i22.i441, ptr %223, align 8
  %224 = getelementptr i8, ptr %result.i134, i64 72
  %225 = getelementptr i8, ptr %result.i134, i64 80
  store i32 9, ptr %225, align 4
  %226 = getelementptr i8, ptr %result.i134, i64 88
  store i32 0, ptr %226, align 4
  %227 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %228 = getelementptr i8, ptr %result.i134, i64 112
  store i32 100, ptr %228, align 4
  %229 = mul i32 %0, 10
  %230 = icmp sgt i32 %0, 0
  %231 = icmp sgt i32 %229, 0
  %232 = and i1 %230, %231
  br i1 %232, label %.lr.ph, label %._crit_edge288

.lr.ph:                                           ; preds = %1
  %233 = getelementptr inbounds i8, ptr %136, i64 8
  %234 = getelementptr inbounds i8, ptr %136, i64 24
  %235 = getelementptr inbounds i8, ptr %136, i64 16
  %236 = getelementptr inbounds i8, ptr %133, i64 8
  %237 = getelementptr inbounds i8, ptr %133, i64 24
  %238 = getelementptr inbounds i8, ptr %133, i64 16
  %239 = getelementptr inbounds i8, ptr %134, i64 8
  %240 = getelementptr inbounds i8, ptr %135, i64 8
  %241 = getelementptr inbounds i8, ptr %128, i64 8
  %242 = getelementptr inbounds i8, ptr %128, i64 24
  %243 = getelementptr inbounds i8, ptr %128, i64 16
  %244 = getelementptr inbounds i8, ptr %129, i64 8
  %245 = getelementptr inbounds i8, ptr %130, i64 8
  %246 = getelementptr inbounds i8, ptr %125, i64 8
  %247 = getelementptr inbounds i8, ptr %125, i64 24
  %248 = getelementptr inbounds i8, ptr %125, i64 16
  %249 = getelementptr inbounds i8, ptr %122, i64 8
  %250 = getelementptr inbounds i8, ptr %122, i64 24
  %251 = getelementptr inbounds i8, ptr %122, i64 16
  %252 = getelementptr inbounds i8, ptr %123, i64 8
  %253 = getelementptr inbounds i8, ptr %124, i64 8
  %254 = getelementptr inbounds i8, ptr %117, i64 8
  %255 = getelementptr inbounds i8, ptr %117, i64 24
  %256 = getelementptr inbounds i8, ptr %117, i64 16
  %257 = getelementptr inbounds i8, ptr %118, i64 8
  %258 = getelementptr inbounds i8, ptr %119, i64 8
  %259 = getelementptr i8, ptr %result.i, i64 40
  %260 = getelementptr i8, ptr %result.i, i64 72
  %261 = getelementptr i8, ptr %result.i, i64 88
  %262 = getelementptr inbounds i8, ptr %103, i64 8
  %263 = getelementptr inbounds i8, ptr %103, i64 24
  %264 = getelementptr inbounds i8, ptr %103, i64 16
  %265 = getelementptr inbounds i8, ptr %104, i64 8
  %266 = getelementptr inbounds i8, ptr %104, i64 24
  %267 = getelementptr inbounds i8, ptr %104, i64 16
  %268 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i134, 1
  %269 = insertvalue { ptr, ptr, ptr, i32 } %268, ptr undef, 2
  %270 = insertvalue { ptr, ptr, ptr, i32 } %269, i32 9, 3
  %271 = getelementptr inbounds i8, ptr %98, i64 8
  %272 = getelementptr inbounds i8, ptr %98, i64 16
  %273 = getelementptr inbounds i8, ptr %98, i64 24
  %274 = getelementptr inbounds i8, ptr %92, i64 8
  %275 = getelementptr inbounds i8, ptr %93, i64 8
  %276 = getelementptr inbounds i8, ptr %84, i64 8
  %277 = getelementptr inbounds i8, ptr %85, i64 8
  %278 = getelementptr inbounds i8, ptr %80, i64 8
  %279 = getelementptr inbounds i8, ptr %80, i64 24
  %280 = getelementptr inbounds i8, ptr %80, i64 16
  %281 = getelementptr inbounds i8, ptr %81, i64 8
  %282 = getelementptr inbounds i8, ptr %81, i64 24
  %283 = getelementptr inbounds i8, ptr %81, i64 16
  %284 = getelementptr inbounds i8, ptr %70, i64 8
  %285 = getelementptr inbounds i8, ptr %71, i64 8
  %286 = getelementptr inbounds i8, ptr %62, i64 8
  %287 = getelementptr inbounds i8, ptr %63, i64 8
  %288 = getelementptr inbounds i8, ptr %58, i64 8
  %289 = getelementptr inbounds i8, ptr %58, i64 24
  %290 = getelementptr inbounds i8, ptr %58, i64 16
  %291 = getelementptr inbounds i8, ptr %59, i64 8
  %292 = getelementptr inbounds i8, ptr %59, i64 24
  %293 = getelementptr inbounds i8, ptr %59, i64 16
  %294 = getelementptr inbounds i8, ptr %52, i64 8
  %295 = getelementptr inbounds i8, ptr %52, i64 24
  %296 = getelementptr inbounds i8, ptr %52, i64 16
  %297 = getelementptr inbounds i8, ptr %53, i64 8
  %298 = getelementptr inbounds i8, ptr %53, i64 24
  %299 = getelementptr inbounds i8, ptr %53, i64 16
  %300 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMap, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %301 = insertvalue { ptr, ptr, ptr, i32 } %300, ptr undef, 2
  %302 = insertvalue { ptr, ptr, ptr, i32 } %301, i32 9, 3
  %303 = getelementptr inbounds i8, ptr %47, i64 8
  %304 = getelementptr inbounds i8, ptr %47, i64 16
  %305 = getelementptr inbounds i8, ptr %47, i64 24
  %306 = getelementptr inbounds i8, ptr %41, i64 8
  %307 = getelementptr inbounds i8, ptr %42, i64 8
  %308 = getelementptr inbounds i8, ptr %33, i64 8
  %309 = getelementptr inbounds i8, ptr %34, i64 8
  %310 = getelementptr inbounds i8, ptr %29, i64 8
  %311 = getelementptr inbounds i8, ptr %29, i64 24
  %312 = getelementptr inbounds i8, ptr %29, i64 16
  %313 = getelementptr inbounds i8, ptr %30, i64 8
  %314 = getelementptr inbounds i8, ptr %30, i64 24
  %315 = getelementptr inbounds i8, ptr %30, i64 16
  %316 = getelementptr inbounds i8, ptr %19, i64 8
  %317 = getelementptr inbounds i8, ptr %20, i64 8
  %318 = getelementptr inbounds i8, ptr %11, i64 8
  %319 = getelementptr inbounds i8, ptr %12, i64 8
  %320 = getelementptr inbounds i8, ptr %7, i64 8
  %321 = getelementptr inbounds i8, ptr %7, i64 24
  %322 = getelementptr inbounds i8, ptr %7, i64 16
  %323 = getelementptr inbounds i8, ptr %8, i64 8
  %324 = getelementptr inbounds i8, ptr %8, i64 24
  %325 = getelementptr inbounds i8, ptr %8, i64 16
  br label %326

326:                                              ; preds = %.lr.ph, %3022
  %.reg2mem129.0286 = phi i32 [ 0, %.lr.ph ], [ %.reg2mem125.0, %3022 ]
  %.reg2mem127.0285 = phi i32 [ 0, %.lr.ph ], [ %3023, %3022 ]
  %327 = load i32, ptr %result.i104, align 4
  %328 = mul i32 %327, 1103515245
  %329 = add i32 %328, 12345
  %330 = and i32 %329, 2147483647
  store i32 %330, ptr %result.i104, align 4
  %331 = call ptr @llvm.invariant.start.p0(i64 40, ptr nonnull @PRNG)
  %.sroa.087.0.insert.ext = zext nneg i32 %330 to i160
  %332 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.087.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %139)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %140)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %141)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %142)
  %333 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %334 = load ptr, ptr %193, align 8
  %335 = call i32 %334({ ptr, i160 } %332)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %336 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %337 = load ptr, ptr %205, align 8
  %338 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %337, 0
  %339 = load ptr, ptr %206, align 8
  %340 = insertvalue { ptr, ptr, ptr, i32 } %338, ptr %339, 1
  %341 = load ptr, ptr %207, align 8
  %342 = insertvalue { ptr, ptr, ptr, i32 } %340, ptr %341, 2
  %343 = load i32, ptr %208, align 4
  %344 = insertvalue { ptr, ptr, ptr, i32 } %342, i32 %343, 3
  %hash_coef_ptr.i.i10.i = getelementptr i8, ptr %337, i64 8
  %tbl_size_ptr.i.i11.i = getelementptr i8, ptr %337, i64 16
  %offset_tbl_ptr.i.i12.i = getelementptr i8, ptr %337, i64 40
  %hash_coef.i.i13.i = load i64, ptr %hash_coef_ptr.i.i10.i, align 4
  %tbl_size.i.i14.i = load i64, ptr %tbl_size_ptr.i.i11.i, align 4
  %offset_tbl.i.i15.i = load ptr, ptr %offset_tbl_ptr.i.i12.i, align 8
  %product.i.i.i16.i = mul i64 %hash_coef.i.i13.i, -5261542750394134544
  %shifted.i.i.i17.i = lshr i64 %product.i.i.i16.i, 32
  %xored.i.i.i18.i = xor i64 %shifted.i.i.i17.i, %product.i.i.i16.i
  %hash.i.i.i19.i = and i64 %xored.i.i.i18.i, %tbl_size.i.i14.i
  %offset_ptr.i.i20.i = getelementptr i32, ptr %offset_tbl.i.i15.i, i64 %hash.i.i.i19.i
  %offset.i.i21.i = load i32, ptr %offset_ptr.i.i20.i, align 4
  %eq.i.i978 = icmp eq i32 %343, %offset.i.i21.i
  call void @llvm.assume(i1 %eq.i.i978) #30
  %345 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %346 = call ptr @llvm.invariant.start.p0(i64 600, ptr %337)
  %347 = sext i32 %343 to i64
  %348 = getelementptr ptr, ptr %337, i64 %347
  %349 = getelementptr i8, ptr %348, i64 64
  %350 = load ptr, ptr %349, align 8
  %351 = call ptr %350({ ptr, ptr, ptr, i32 } %344, ptr nonnull %2)
  %352 = call i32 %351({ ptr, ptr, ptr, i32 } %344, { ptr, ptr, ptr, i32 } %344, ptr nonnull %2)
  %353 = add i32 %352, -1
  %354 = and i32 %353, %335
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %355 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %356 = load ptr, ptr %205, align 8
  %357 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %356, 0
  %358 = load ptr, ptr %206, align 8
  %359 = insertvalue { ptr, ptr, ptr, i32 } %357, ptr %358, 1
  %360 = load ptr, ptr %207, align 8
  %361 = insertvalue { ptr, ptr, ptr, i32 } %359, ptr %360, 2
  %362 = load i32, ptr %208, align 4
  %363 = insertvalue { ptr, ptr, ptr, i32 } %361, i32 %362, 3
  %hash_coef_ptr.i.i130.i = getelementptr i8, ptr %356, i64 8
  %tbl_size_ptr.i.i131.i = getelementptr i8, ptr %356, i64 16
  %offset_tbl_ptr.i.i132.i = getelementptr i8, ptr %356, i64 40
  %hash_coef.i.i133.i = load i64, ptr %hash_coef_ptr.i.i130.i, align 4
  %tbl_size.i.i134.i = load i64, ptr %tbl_size_ptr.i.i131.i, align 4
  %offset_tbl.i.i135.i = load ptr, ptr %offset_tbl_ptr.i.i132.i, align 8
  %product.i.i.i136.i = mul i64 %hash_coef.i.i133.i, -5261542750394134544
  %shifted.i.i.i137.i = lshr i64 %product.i.i.i136.i, 32
  %xored.i.i.i138.i = xor i64 %shifted.i.i.i137.i, %product.i.i.i136.i
  %hash.i.i.i139.i = and i64 %xored.i.i.i138.i, %tbl_size.i.i134.i
  %offset_ptr.i.i140.i = getelementptr i32, ptr %offset_tbl.i.i135.i, i64 %hash.i.i.i139.i
  %offset.i.i141.i = load i32, ptr %offset_ptr.i.i140.i, align 4
  %eq.i.i = icmp eq i32 %362, %offset.i.i141.i
  call void @llvm.assume(i1 %eq.i.i) #30
  store ptr @_parameterization_Ptri32, ptr %141, align 8
  %364 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %141)
  %365 = call ptr @llvm.invariant.start.p0(i64 600, ptr %356)
  %366 = sext i32 %362 to i64
  %367 = getelementptr ptr, ptr %356, i64 %366
  %368 = getelementptr i8, ptr %367, i64 120
  %369 = load ptr, ptr %368, align 8
  store ptr @i32_typ, ptr %142, align 8
  %370 = call ptr %369({ ptr, ptr, ptr, i32 } %363, ptr nonnull %142)
  %371 = call { ptr, i160 } %370({ ptr, ptr, ptr, i32 } %363, { ptr, ptr, ptr, i32 } %363, ptr nonnull %141, i32 %354)
  %.fca.0.extract.i467 = extractvalue { ptr, i160 } %371, 0
  %372 = icmp ne ptr %.fca.0.extract.i467, @nil_typ
  %373 = icmp ne ptr %.fca.0.extract.i467, null
  %.not126.i = and i1 %372, %373
  br i1 %.not126.i, label %374, label %.critedge.i

374:                                              ; preds = %326
  %.fca.1.extract.i = extractvalue { ptr, i160 } %371, 1
  %.sroa.5.8.extract.trunc.i = trunc i160 %.fca.1.extract.i to i64
  %375 = inttoptr i64 %.sroa.5.8.extract.trunc.i to ptr
  %.sroa.9.8.extract.shift.i = lshr i160 %.fca.1.extract.i, 64
  %.sroa.9.8.extract.trunc.i = trunc i160 %.sroa.9.8.extract.shift.i to i64
  %376 = inttoptr i64 %.sroa.9.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i144.i = getelementptr i8, ptr %.fca.0.extract.i467, i64 8
  %tbl_size_ptr.i.i145.i = getelementptr i8, ptr %.fca.0.extract.i467, i64 16
  %offset_tbl_ptr.i.i146.i = getelementptr i8, ptr %.fca.0.extract.i467, i64 40
  %hash_coef.i.i147.i = load i64, ptr %hash_coef_ptr.i.i144.i, align 4
  %tbl_size.i.i148.i = load i64, ptr %tbl_size_ptr.i.i145.i, align 4
  %offset_tbl.i.i149.i = load ptr, ptr %offset_tbl_ptr.i.i146.i, align 8
  %product.i.i.i150.i = mul i64 %hash_coef.i.i147.i, 4015701072841558310
  %shifted.i.i.i151.i = lshr i64 %product.i.i.i150.i, 32
  %xored.i.i.i152.i = xor i64 %shifted.i.i.i151.i, %product.i.i.i150.i
  %hash.i.i.i153.i = and i64 %xored.i.i.i152.i, %tbl_size.i.i148.i
  %offset_ptr.i.i154.i = getelementptr i32, ptr %offset_tbl.i.i149.i, i64 %hash.i.i.i153.i
  %offset.i.i155.i = load i32, ptr %offset_ptr.i.i154.i, align 4
  %377 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i467, 0
  %378 = insertvalue { ptr, ptr, ptr, i32 } %377, ptr %375, 1
  %379 = insertvalue { ptr, ptr, ptr, i32 } %378, ptr %376, 2
  %380 = insertvalue { ptr, ptr, ptr, i32 } %379, i32 %offset.i.i155.i, 3
  %381 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %382 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %383 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i467)
  %384 = sext i32 %offset.i.i155.i to i64
  %385 = getelementptr ptr, ptr %.fca.0.extract.i467, i64 %384
  %386 = getelementptr i8, ptr %385, i64 64
  %387 = load ptr, ptr %386, align 8
  %388 = call ptr %387({ ptr, ptr, ptr, i32 } %380, ptr nonnull %2)
  %389 = call i32 %388({ ptr, ptr, ptr, i32 } %380, { ptr, ptr, ptr, i32 } %380, ptr nonnull %2)
  %390 = icmp eq i32 %389, %335
  %391 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %392 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %393 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i467)
  %394 = getelementptr i8, ptr %385, i64 48
  %395 = load ptr, ptr %394, align 8
  %396 = call ptr %395({ ptr, ptr, ptr, i32 } %380, ptr nonnull %2)
  %397 = call { ptr, i160 } %396({ ptr, ptr, ptr, i32 } %380, { ptr, ptr, ptr, i32 } %380, ptr nonnull %2)
  %398 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %399 = load ptr, ptr %194, align 8
  %400 = call i1 %399({ ptr, i160 } %397, { ptr, i160 } %332)
  %401 = and i1 %390, %400
  br i1 %401, label %HashMap_get_keyK.exit, label %.critedge.i

.critedge.i:                                      ; preds = %374, %326
  %402 = add i32 %335, 2127912214
  %403 = shl i32 %335, 12
  %404 = add i32 %402, %403
  %405 = ashr i32 %404, 19
  %406 = xor i32 %404, %405
  %407 = xor i32 %406, -949894596
  %408 = add i32 %407, 374761393
  %409 = shl i32 %407, 5
  %410 = add i32 %408, %409
  %411 = add i32 %410, -744332180
  %412 = shl i32 %410, 9
  %413 = xor i32 %411, %412
  %414 = add i32 %413, -42973499
  %415 = shl i32 %413, 3
  %416 = add i32 %414, %415
  %417 = ashr i32 %416, 16
  %418 = xor i32 %416, %417
  %419 = xor i32 %418, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %420 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %421 = load ptr, ptr %222, align 8
  %422 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %421, 0
  %423 = load ptr, ptr %223, align 8
  %424 = insertvalue { ptr, ptr, ptr, i32 } %422, ptr %423, 1
  %425 = load ptr, ptr %224, align 8
  %426 = insertvalue { ptr, ptr, ptr, i32 } %424, ptr %425, 2
  %427 = load i32, ptr %225, align 4
  %428 = insertvalue { ptr, ptr, ptr, i32 } %426, i32 %427, 3
  %hash_coef_ptr.i.i10.i996 = getelementptr i8, ptr %421, i64 8
  %tbl_size_ptr.i.i11.i997 = getelementptr i8, ptr %421, i64 16
  %offset_tbl_ptr.i.i12.i998 = getelementptr i8, ptr %421, i64 40
  %hash_coef.i.i13.i999 = load i64, ptr %hash_coef_ptr.i.i10.i996, align 4
  %tbl_size.i.i14.i1000 = load i64, ptr %tbl_size_ptr.i.i11.i997, align 4
  %offset_tbl.i.i15.i1001 = load ptr, ptr %offset_tbl_ptr.i.i12.i998, align 8
  %product.i.i.i16.i1002 = mul i64 %hash_coef.i.i13.i999, -5261542750394134544
  %shifted.i.i.i17.i1003 = lshr i64 %product.i.i.i16.i1002, 32
  %xored.i.i.i18.i1004 = xor i64 %shifted.i.i.i17.i1003, %product.i.i.i16.i1002
  %hash.i.i.i19.i1005 = and i64 %xored.i.i.i18.i1004, %tbl_size.i.i14.i1000
  %offset_ptr.i.i20.i1006 = getelementptr i32, ptr %offset_tbl.i.i15.i1001, i64 %hash.i.i.i19.i1005
  %offset.i.i21.i1007 = load i32, ptr %offset_ptr.i.i20.i1006, align 4
  %eq.i.i1008 = icmp eq i32 %427, %offset.i.i21.i1007
  call void @llvm.assume(i1 %eq.i.i1008) #30
  %429 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %430 = call ptr @llvm.invariant.start.p0(i64 600, ptr %421)
  %431 = sext i32 %427 to i64
  %432 = getelementptr ptr, ptr %421, i64 %431
  %433 = getelementptr i8, ptr %432, i64 64
  %434 = load ptr, ptr %433, align 8
  %435 = call ptr %434({ ptr, ptr, ptr, i32 } %428, ptr nonnull %2)
  %436 = call i32 %435({ ptr, ptr, ptr, i32 } %428, { ptr, ptr, ptr, i32 } %428, ptr nonnull %2)
  %437 = add i32 %436, -1
  %438 = and i32 %437, %419
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %439 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %440 = load ptr, ptr %222, align 8
  %441 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %440, 0
  %442 = load ptr, ptr %223, align 8
  %443 = insertvalue { ptr, ptr, ptr, i32 } %441, ptr %442, 1
  %444 = load ptr, ptr %224, align 8
  %445 = insertvalue { ptr, ptr, ptr, i32 } %443, ptr %444, 2
  %446 = load i32, ptr %225, align 4
  %447 = insertvalue { ptr, ptr, ptr, i32 } %445, i32 %446, 3
  %hash_coef_ptr.i.i158.i = getelementptr i8, ptr %440, i64 8
  %tbl_size_ptr.i.i159.i = getelementptr i8, ptr %440, i64 16
  %offset_tbl_ptr.i.i160.i = getelementptr i8, ptr %440, i64 40
  %hash_coef.i.i161.i = load i64, ptr %hash_coef_ptr.i.i158.i, align 4
  %tbl_size.i.i162.i = load i64, ptr %tbl_size_ptr.i.i159.i, align 4
  %offset_tbl.i.i163.i = load ptr, ptr %offset_tbl_ptr.i.i160.i, align 8
  %product.i.i.i164.i = mul i64 %hash_coef.i.i161.i, -5261542750394134544
  %shifted.i.i.i165.i = lshr i64 %product.i.i.i164.i, 32
  %xored.i.i.i166.i = xor i64 %shifted.i.i.i165.i, %product.i.i.i164.i
  %hash.i.i.i167.i = and i64 %xored.i.i.i166.i, %tbl_size.i.i162.i
  %offset_ptr.i.i168.i = getelementptr i32, ptr %offset_tbl.i.i163.i, i64 %hash.i.i.i167.i
  %offset.i.i169.i = load i32, ptr %offset_ptr.i.i168.i, align 4
  %eq.i172.i = icmp eq i32 %446, %offset.i.i169.i
  call void @llvm.assume(i1 %eq.i172.i) #30
  store ptr @_parameterization_Ptri32, ptr %139, align 8
  %448 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %139)
  %449 = call ptr @llvm.invariant.start.p0(i64 600, ptr %440)
  %450 = sext i32 %446 to i64
  %451 = getelementptr ptr, ptr %440, i64 %450
  %452 = getelementptr i8, ptr %451, i64 120
  %453 = load ptr, ptr %452, align 8
  store ptr @i32_typ, ptr %140, align 8
  %454 = call ptr %453({ ptr, ptr, ptr, i32 } %447, ptr nonnull %140)
  %455 = call { ptr, i160 } %454({ ptr, ptr, ptr, i32 } %447, { ptr, ptr, ptr, i32 } %447, ptr nonnull %139, i32 %438)
  %.fca.0.extract57.i = extractvalue { ptr, i160 } %455, 0
  %456 = icmp ne ptr %.fca.0.extract57.i, @nil_typ
  %457 = icmp ne ptr %.fca.0.extract57.i, null
  %.not128.i = and i1 %456, %457
  br i1 %.not128.i, label %458, label %HashMap_get_keyK.exit.thread

458:                                              ; preds = %.critedge.i
  %.fca.1.extract59.i = extractvalue { ptr, i160 } %455, 1
  %.sroa.6.8.extract.trunc.i = trunc i160 %.fca.1.extract59.i to i64
  %459 = inttoptr i64 %.sroa.6.8.extract.trunc.i to ptr
  %.sroa.11.8.extract.shift.i = lshr i160 %.fca.1.extract59.i, 64
  %.sroa.11.8.extract.trunc.i = trunc i160 %.sroa.11.8.extract.shift.i to i64
  %460 = inttoptr i64 %.sroa.11.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i174.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 8
  %tbl_size_ptr.i.i175.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 16
  %offset_tbl_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract57.i, i64 40
  %hash_coef.i.i177.i = load i64, ptr %hash_coef_ptr.i.i174.i, align 4
  %tbl_size.i.i178.i = load i64, ptr %tbl_size_ptr.i.i175.i, align 4
  %offset_tbl.i.i179.i = load ptr, ptr %offset_tbl_ptr.i.i176.i, align 8
  %product.i.i.i180.i = mul i64 %hash_coef.i.i177.i, 4015701072841558310
  %shifted.i.i.i181.i = lshr i64 %product.i.i.i180.i, 32
  %xored.i.i.i182.i = xor i64 %shifted.i.i.i181.i, %product.i.i.i180.i
  %hash.i.i.i183.i = and i64 %xored.i.i.i182.i, %tbl_size.i.i178.i
  %offset_ptr.i.i184.i = getelementptr i32, ptr %offset_tbl.i.i179.i, i64 %hash.i.i.i183.i
  %offset.i.i185.i = load i32, ptr %offset_ptr.i.i184.i, align 4
  %461 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i, 0
  %462 = insertvalue { ptr, ptr, ptr, i32 } %461, ptr %459, 1
  %463 = insertvalue { ptr, ptr, ptr, i32 } %462, ptr %460, 2
  %464 = insertvalue { ptr, ptr, ptr, i32 } %463, i32 %offset.i.i185.i, 3
  %465 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %466 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %467 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %468 = sext i32 %offset.i.i185.i to i64
  %469 = getelementptr ptr, ptr %.fca.0.extract57.i, i64 %468
  %470 = getelementptr i8, ptr %469, i64 64
  %471 = load ptr, ptr %470, align 8
  %472 = call ptr %471({ ptr, ptr, ptr, i32 } %464, ptr nonnull %2)
  %473 = call i32 %472({ ptr, ptr, ptr, i32 } %464, { ptr, ptr, ptr, i32 } %464, ptr nonnull %2)
  %474 = icmp eq i32 %473, %335
  %475 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %476 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %477 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i)
  %478 = getelementptr i8, ptr %469, i64 48
  %479 = load ptr, ptr %478, align 8
  %480 = call ptr %479({ ptr, ptr, ptr, i32 } %464, ptr nonnull %2)
  %481 = call { ptr, i160 } %480({ ptr, ptr, ptr, i32 } %464, { ptr, ptr, ptr, i32 } %464, ptr nonnull %2)
  %482 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %483 = load ptr, ptr %194, align 8
  %484 = call i1 %483({ ptr, i160 } %481, { ptr, i160 } %332)
  %485 = and i1 %474, %484
  br i1 %485, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %458, %.critedge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %139)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %140)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %141)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %142)
  br label %497

HashMap_get_keyK.exit:                            ; preds = %374, %458
  %.pre-phi313.i = phi i64 [ %384, %374 ], [ %468, %458 ]
  %.pre-phi312.i = phi { ptr, ptr, ptr, i32 } [ %380, %374 ], [ %464, %458 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i = phi ptr [ %.fca.0.extract.i467, %374 ], [ %.fca.0.extract57.i, %458 ]
  %.reg2mem59.0.sroa.phi120289.i = phi ptr [ %.sroa.1.i, %374 ], [ %.sroa.2124.i, %458 ]
  %.reg2mem59.0.sroa.phi117288.i = phi ptr [ %.sroa.0271.i, %374 ], [ %.sroa.0123.i, %458 ]
  %.reg2mem57.0.sroa.phi94287.i = phi ptr [ %.sroa.2.i, %374 ], [ %.sroa.2116.i, %458 ]
  %.reg2mem57.0.sroa.phi91286.i = phi ptr [ %.sroa.0.i, %374 ], [ %.sroa.0115.i, %458 ]
  %486 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %487 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %488 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i)
  %489 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i, i64 %.pre-phi313.i
  %490 = getelementptr i8, ptr %489, i64 56
  %491 = load ptr, ptr %490, align 8
  %492 = call ptr %491({ ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %493 = call { ptr, i160 } %492({ ptr, ptr, ptr, i32 } %.pre-phi312.i, { ptr, ptr, ptr, i32 } %.pre-phi312.i, ptr nonnull %2)
  %.fca.0.extract97.i = extractvalue { ptr, i160 } %493, 0
  store ptr %.fca.0.extract97.i, ptr %.reg2mem59.0.sroa.phi117288.i, align 8
  %.fca.1.extract99.i = extractvalue { ptr, i160 } %493, 1
  store i160 %.fca.1.extract99.i, ptr %.reg2mem59.0.sroa.phi120289.i, align 8
  store ptr %.fca.0.extract97.i, ptr %.reg2mem57.0.sroa.phi91286.i, align 8
  store i160 %.fca.1.extract99.i, ptr %.reg2mem57.0.sroa.phi94287.i, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %139)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %140)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %141)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %142)
  %494 = icmp eq ptr %.fca.0.extract97.i, @nil_typ
  %495 = icmp eq ptr %.fca.0.extract97.i, null
  %496 = or i1 %494, %495
  br i1 %496, label %497, label %3022

497:                                              ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit
  %498 = add nuw i32 %330, 1
  %.sroa.073.0.insert.ext = zext i32 %498 to i160
  %499 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.073.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %117)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %118)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %119)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %120)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %121)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %122)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %123)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %124)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %125)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %126)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %127)
  %500 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %501 = load ptr, ptr %153, align 8
  %502 = call i32 %501({ ptr, i160 } %332)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %503 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %504 = load ptr, ptr %165, align 8
  %505 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %504, 0
  %506 = load ptr, ptr %166, align 8
  %507 = insertvalue { ptr, ptr, ptr, i32 } %505, ptr %506, 1
  %508 = load ptr, ptr %259, align 8
  %509 = insertvalue { ptr, ptr, ptr, i32 } %507, ptr %508, 2
  %510 = load i32, ptr %167, align 4
  %511 = insertvalue { ptr, ptr, ptr, i32 } %509, i32 %510, 3
  %hash_coef_ptr.i.i10.i1798 = getelementptr i8, ptr %504, i64 8
  %tbl_size_ptr.i.i11.i1799 = getelementptr i8, ptr %504, i64 16
  %offset_tbl_ptr.i.i12.i1800 = getelementptr i8, ptr %504, i64 40
  %hash_coef.i.i13.i1801 = load i64, ptr %hash_coef_ptr.i.i10.i1798, align 4
  %tbl_size.i.i14.i1802 = load i64, ptr %tbl_size_ptr.i.i11.i1799, align 4
  %offset_tbl.i.i15.i1803 = load ptr, ptr %offset_tbl_ptr.i.i12.i1800, align 8
  %product.i.i.i16.i1804 = mul i64 %hash_coef.i.i13.i1801, -5261542750394134544
  %shifted.i.i.i17.i1805 = lshr i64 %product.i.i.i16.i1804, 32
  %xored.i.i.i18.i1806 = xor i64 %shifted.i.i.i17.i1805, %product.i.i.i16.i1804
  %hash.i.i.i19.i1807 = and i64 %xored.i.i.i18.i1806, %tbl_size.i.i14.i1802
  %offset_ptr.i.i20.i1808 = getelementptr i32, ptr %offset_tbl.i.i15.i1803, i64 %hash.i.i.i19.i1807
  %offset.i.i21.i1809 = load i32, ptr %offset_ptr.i.i20.i1808, align 4
  %eq.i.i1810 = icmp eq i32 %510, %offset.i.i21.i1809
  call void @llvm.assume(i1 %eq.i.i1810) #30
  %512 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %513 = call ptr @llvm.invariant.start.p0(i64 600, ptr %504)
  %514 = sext i32 %510 to i64
  %515 = getelementptr ptr, ptr %504, i64 %514
  %516 = getelementptr i8, ptr %515, i64 64
  %517 = load ptr, ptr %516, align 8
  %518 = call ptr %517({ ptr, ptr, ptr, i32 } %511, ptr nonnull %2)
  %519 = call i32 %518({ ptr, ptr, ptr, i32 } %511, { ptr, ptr, ptr, i32 } %511, ptr nonnull %2)
  %520 = add i32 %519, -1
  %521 = and i32 %520, %502
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %522 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %523 = load ptr, ptr %165, align 8
  %524 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %523, 0
  %525 = load ptr, ptr %166, align 8
  %526 = insertvalue { ptr, ptr, ptr, i32 } %524, ptr %525, 1
  %527 = load ptr, ptr %259, align 8
  %528 = insertvalue { ptr, ptr, ptr, i32 } %526, ptr %527, 2
  %529 = load i32, ptr %167, align 4
  %530 = insertvalue { ptr, ptr, ptr, i32 } %528, i32 %529, 3
  %hash_coef_ptr.i.i162.i651 = getelementptr i8, ptr %523, i64 8
  %tbl_size_ptr.i.i163.i652 = getelementptr i8, ptr %523, i64 16
  %offset_tbl_ptr.i.i164.i653 = getelementptr i8, ptr %523, i64 40
  %hash_coef.i.i165.i654 = load i64, ptr %hash_coef_ptr.i.i162.i651, align 4
  %tbl_size.i.i166.i655 = load i64, ptr %tbl_size_ptr.i.i163.i652, align 4
  %offset_tbl.i.i167.i656 = load ptr, ptr %offset_tbl_ptr.i.i164.i653, align 8
  %product.i.i.i168.i657 = mul i64 %hash_coef.i.i165.i654, -5261542750394134544
  %shifted.i.i.i169.i658 = lshr i64 %product.i.i.i168.i657, 32
  %xored.i.i.i170.i659 = xor i64 %shifted.i.i.i169.i658, %product.i.i.i168.i657
  %hash.i.i.i171.i660 = and i64 %xored.i.i.i170.i659, %tbl_size.i.i166.i655
  %offset_ptr.i.i172.i661 = getelementptr i32, ptr %offset_tbl.i.i167.i656, i64 %hash.i.i.i171.i660
  %offset.i.i173.i662 = load i32, ptr %offset_ptr.i.i172.i661, align 4
  %eq.i.i663 = icmp eq i32 %529, %offset.i.i173.i662
  call void @llvm.assume(i1 %eq.i.i663) #30
  store ptr @_parameterization_Ptri32, ptr %126, align 8
  %531 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %126)
  %532 = call ptr @llvm.invariant.start.p0(i64 600, ptr %523)
  %533 = sext i32 %529 to i64
  %534 = getelementptr ptr, ptr %523, i64 %533
  %535 = getelementptr i8, ptr %534, i64 120
  %536 = load ptr, ptr %535, align 8
  store ptr @i32_typ, ptr %127, align 8
  %537 = call ptr %536({ ptr, ptr, ptr, i32 } %530, ptr nonnull %127)
  %538 = call { ptr, i160 } %537({ ptr, ptr, ptr, i32 } %530, { ptr, ptr, ptr, i32 } %530, ptr nonnull %126, i32 %521)
  %.fca.0.extract.i664 = extractvalue { ptr, i160 } %538, 0
  %539 = icmp ne ptr %.fca.0.extract.i664, @nil_typ
  %540 = icmp ne ptr %.fca.0.extract.i664, null
  %.not149.i665 = and i1 %539, %540
  br i1 %.not149.i665, label %541, label %.critedge.i666

541:                                              ; preds = %497
  %.fca.1.extract.i759 = extractvalue { ptr, i160 } %538, 1
  %.sroa.4520.8.extract.trunc.i760 = trunc i160 %.fca.1.extract.i759 to i64
  %542 = inttoptr i64 %.sroa.4520.8.extract.trunc.i760 to ptr
  %.sroa.7522.8.extract.shift.i761 = lshr i160 %.fca.1.extract.i759, 64
  %.sroa.7522.8.extract.trunc.i762 = trunc i160 %.sroa.7522.8.extract.shift.i761 to i64
  %543 = inttoptr i64 %.sroa.7522.8.extract.trunc.i762 to ptr
  %hash_coef_ptr.i.i176.i763 = getelementptr i8, ptr %.fca.0.extract.i664, i64 8
  %tbl_size_ptr.i.i177.i764 = getelementptr i8, ptr %.fca.0.extract.i664, i64 16
  %offset_tbl_ptr.i.i178.i765 = getelementptr i8, ptr %.fca.0.extract.i664, i64 40
  %hash_coef.i.i179.i766 = load i64, ptr %hash_coef_ptr.i.i176.i763, align 4
  %tbl_size.i.i180.i767 = load i64, ptr %tbl_size_ptr.i.i177.i764, align 4
  %offset_tbl.i.i181.i768 = load ptr, ptr %offset_tbl_ptr.i.i178.i765, align 8
  %product.i.i.i182.i769 = mul i64 %hash_coef.i.i179.i766, 4015701072841558310
  %shifted.i.i.i183.i770 = lshr i64 %product.i.i.i182.i769, 32
  %xored.i.i.i184.i771 = xor i64 %shifted.i.i.i183.i770, %product.i.i.i182.i769
  %hash.i.i.i185.i772 = and i64 %xored.i.i.i184.i771, %tbl_size.i.i180.i767
  %offset_ptr.i.i186.i773 = getelementptr i32, ptr %offset_tbl.i.i181.i768, i64 %hash.i.i.i185.i772
  %offset.i.i187.i774 = load i32, ptr %offset_ptr.i.i186.i773, align 4
  %544 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i664, 0
  %545 = insertvalue { ptr, ptr, ptr, i32 } %544, ptr %542, 1
  %546 = insertvalue { ptr, ptr, ptr, i32 } %545, ptr %543, 2
  %547 = insertvalue { ptr, ptr, ptr, i32 } %546, i32 %offset.i.i187.i774, 3
  %548 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %549 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %550 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i664)
  %551 = sext i32 %offset.i.i187.i774 to i64
  %552 = getelementptr ptr, ptr %.fca.0.extract.i664, i64 %551
  %553 = getelementptr i8, ptr %552, i64 64
  %554 = load ptr, ptr %553, align 8
  %555 = call ptr %554({ ptr, ptr, ptr, i32 } %547, ptr nonnull %2)
  %556 = call i32 %555({ ptr, ptr, ptr, i32 } %547, { ptr, ptr, ptr, i32 } %547, ptr nonnull %2)
  %557 = icmp eq i32 %556, %502
  %558 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %559 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %560 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i664)
  %561 = getelementptr i8, ptr %552, i64 48
  %562 = load ptr, ptr %561, align 8
  %563 = call ptr %562({ ptr, ptr, ptr, i32 } %547, ptr nonnull %2)
  %564 = call { ptr, i160 } %563({ ptr, ptr, ptr, i32 } %547, { ptr, ptr, ptr, i32 } %547, ptr nonnull %2)
  %565 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %566 = load ptr, ptr %154, align 8
  %567 = call i1 %566({ ptr, i160 } %564, { ptr, i160 } %332)
  %568 = and i1 %557, %567
  br i1 %568, label %569, label %.critedge.i666

569:                                              ; preds = %541
  %570 = load ptr, ptr %result.i, align 8
  %571 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %572 = load ptr, ptr %148, align 8
  %573 = load ptr, ptr %570, align 8
  %574 = getelementptr i8, ptr %573, i64 48
  %575 = load ptr, ptr %574, align 8
  %576 = call { i64, i64 } %575(ptr nonnull %570)
  %577 = extractvalue { i64, i64 } %576, 0
  %578 = extractvalue { i64, i64 } %576, 1
  %579 = urem i64 20, %578
  %580 = icmp eq i64 %579, 0
  %581 = sub i64 %578, %579
  %582 = select i1 %580, i64 0, i64 %581
  %583 = add i64 %577, 20
  %584 = add i64 %583, %582
  %585 = load ptr, ptr %572, align 8
  %586 = getelementptr i8, ptr %585, i64 48
  %587 = load ptr, ptr %586, align 8
  %588 = call { i64, i64 } %587(ptr nonnull %572)
  %589 = extractvalue { i64, i64 } %588, 0
  %590 = extractvalue { i64, i64 } %588, 1
  %591 = call i64 @llvm.umax.i64(i64 %578, i64 %590)
  %592 = call i64 @llvm.umax.i64(i64 %591, i64 8)
  %593 = urem i64 %584, %590
  %594 = icmp eq i64 %593, 0
  %595 = sub i64 %590, %593
  %596 = select i1 %594, i64 0, i64 %595
  %597 = add i64 %589, %584
  %598 = add i64 %597, %596
  %599 = urem i64 %598, %592
  %600 = icmp eq i64 %599, 0
  %601 = sub i64 %592, %599
  %602 = select i1 %600, i64 0, i64 %601
  %603 = add i64 %602, %598
  %result.i.i776 = call noalias ptr @bump_malloc_inner(i64 noundef %603, ptr nonnull @current_ptr) #29
  store ptr %570, ptr %result.i.i776, align 8
  %604 = getelementptr i8, ptr %result.i.i776, i64 8
  store ptr %572, ptr %604, align 8
  %605 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i776)
  store ptr @Entry, ptr %117, align 8
  store ptr %result.i.i776, ptr %254, align 8
  store i32 9, ptr %255, align 8
  %606 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %117)
  %607 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %608 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %609 = load ptr, ptr %570, align 8
  %610 = getelementptr i8, ptr %609, i64 48
  %611 = load ptr, ptr %610, align 8
  %612 = call { i64, i64 } %611(ptr nonnull %570)
  %613 = extractvalue { i64, i64 } %612, 1
  %614 = urem i64 20, %613
  %615 = icmp eq i64 %614, 0
  %reass.sub = sub i64 %613, %614
  %616 = add i64 %reass.sub, 20
  %617 = select i1 %615, i64 20, i64 %616
  %618 = getelementptr i8, ptr %result.i.i776, i64 %617
  %619 = load ptr, ptr %result.i.i776, align 8
  %620 = load ptr, ptr %619, align 8
  %621 = getelementptr i8, ptr %620, i64 64
  %622 = load ptr, ptr %621, align 8
  call void %622({ ptr, i160 } %332, ptr nonnull %619, ptr %618)
  %623 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %624 = load ptr, ptr %result.i.i776, align 8
  %625 = load ptr, ptr %624, align 8
  %626 = getelementptr i8, ptr %625, i64 48
  %627 = load ptr, ptr %626, align 8
  %628 = call { i64, i64 } %627(ptr nonnull %624)
  %629 = extractvalue { i64, i64 } %628, 0
  %630 = extractvalue { i64, i64 } %628, 1
  %631 = urem i64 20, %630
  %632 = icmp eq i64 %631, 0
  %633 = sub i64 %630, %631
  %634 = select i1 %632, i64 0, i64 %633
  %635 = add i64 %629, 20
  %636 = add i64 %635, %634
  %637 = load ptr, ptr %604, align 8
  %638 = load ptr, ptr %637, align 8
  %639 = getelementptr i8, ptr %638, i64 48
  %640 = load ptr, ptr %639, align 8
  %641 = call { i64, i64 } %640(ptr nonnull %637)
  %642 = extractvalue { i64, i64 } %641, 1
  %643 = urem i64 %636, %642
  %644 = icmp eq i64 %643, 0
  %645 = sub i64 %642, %643
  %646 = select i1 %644, i64 0, i64 %645
  %647 = getelementptr i8, ptr %result.i.i776, i64 %636
  %648 = getelementptr i8, ptr %647, i64 %646
  %649 = load ptr, ptr %604, align 8
  %650 = load ptr, ptr %649, align 8
  %651 = getelementptr i8, ptr %650, i64 64
  %652 = load ptr, ptr %651, align 8
  call void %652({ ptr, i160 } %499, ptr nonnull %649, ptr %648)
  %653 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %654 = getelementptr i8, ptr %result.i.i776, i64 16
  store i32 %502, ptr %654, align 4
  %655 = load ptr, ptr %256, align 8
  %656 = ptrtoint ptr %result.i.i776 to i64
  %657 = ptrtoint ptr %655 to i64
  %.sroa.2127.0.insert.ext.i777 = zext i64 %657 to i160
  %.sroa.2127.0.insert.shift.i778 = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i777, 64
  %.sroa.0126.0.insert.ext.i780 = zext i64 %656 to i160
  %.sroa.2127.0.insert.insert.i779 = or disjoint i160 %.sroa.2127.0.insert.shift.i778, %.sroa.0126.0.insert.ext.i780
  %.sroa.0126.0.insert.insert.i781 = or disjoint i160 %.sroa.2127.0.insert.insert.i779, 3062541302288446171170371466885913903104
  %658 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i781, 1
  %659 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %660 = load ptr, ptr %165, align 8
  %661 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %660, 0
  %662 = load ptr, ptr %166, align 8
  %663 = insertvalue { ptr, ptr, ptr, i32 } %661, ptr %662, 1
  %664 = load ptr, ptr %259, align 8
  %665 = insertvalue { ptr, ptr, ptr, i32 } %663, ptr %664, 2
  %666 = load i32, ptr %167, align 4
  %667 = insertvalue { ptr, ptr, ptr, i32 } %665, i32 %666, 3
  %hash_coef_ptr.i.i204.i786 = getelementptr i8, ptr %660, i64 8
  %tbl_size_ptr.i.i205.i787 = getelementptr i8, ptr %660, i64 16
  %offset_tbl_ptr.i.i206.i788 = getelementptr i8, ptr %660, i64 40
  %hash_coef.i.i207.i789 = load i64, ptr %hash_coef_ptr.i.i204.i786, align 4
  %tbl_size.i.i208.i790 = load i64, ptr %tbl_size_ptr.i.i205.i787, align 4
  %offset_tbl.i.i209.i791 = load ptr, ptr %offset_tbl_ptr.i.i206.i788, align 8
  %product.i.i.i210.i792 = mul i64 %hash_coef.i.i207.i789, -5261542750394134544
  %shifted.i.i.i211.i793 = lshr i64 %product.i.i.i210.i792, 32
  %xored.i.i.i212.i794 = xor i64 %shifted.i.i.i211.i793, %product.i.i.i210.i792
  %hash.i.i.i213.i795 = and i64 %xored.i.i.i212.i794, %tbl_size.i.i208.i790
  %offset_ptr.i.i214.i796 = getelementptr i32, ptr %offset_tbl.i.i209.i791, i64 %hash.i.i.i213.i795
  %offset.i.i215.i797 = load i32, ptr %offset_ptr.i.i214.i796, align 4
  %eq.i218.i798 = icmp eq i32 %666, %offset.i.i215.i797
  call void @llvm.assume(i1 %eq.i218.i798) #30
  %668 = load ptr, ptr %result.i, align 8
  %669 = load ptr, ptr %148, align 8
  %result.i219.i799 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %670 = getelementptr i8, ptr %result.i219.i799, i64 16
  store ptr %669, ptr %670, align 8
  %671 = getelementptr i8, ptr %result.i219.i799, i64 8
  store ptr %668, ptr %671, align 8
  %672 = getelementptr i8, ptr %result.i219.i799, i64 24
  store ptr null, ptr %672, align 8
  %673 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i799)
  store ptr @Entry, ptr %result.i219.i799, align 8
  store ptr @_parameterization_Ptri32, ptr %118, align 8
  store ptr %result.i219.i799, ptr %257, align 8
  %674 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %118)
  %675 = call ptr @llvm.invariant.start.p0(i64 600, ptr %660)
  %676 = sext i32 %666 to i64
  %677 = getelementptr ptr, ptr %660, i64 %676
  %678 = getelementptr i8, ptr %677, i64 128
  %679 = load ptr, ptr %678, align 8
  store ptr @i32_typ, ptr %119, align 8
  store ptr @Entry, ptr %258, align 8
  %680 = call ptr %679({ ptr, ptr, ptr, i32 } %667, ptr nonnull %119)
  call void %680({ ptr, ptr, ptr, i32 } %667, { ptr, ptr, ptr, i32 } %667, ptr nonnull %118, i32 %521, { ptr, i160 } %658)
  br label %HashMap_insert_keyK_valueV.exit800

.critedge.i666:                                   ; preds = %541, %497
  %681 = add i32 %502, 2127912214
  %682 = shl i32 %502, 12
  %683 = add i32 %681, %682
  %684 = ashr i32 %683, 19
  %685 = xor i32 %683, %684
  %686 = xor i32 %685, -949894596
  %687 = add i32 %686, 374761393
  %688 = shl i32 %686, 5
  %689 = add i32 %687, %688
  %690 = add i32 %689, -744332180
  %691 = shl i32 %689, 9
  %692 = xor i32 %690, %691
  %693 = add i32 %692, -42973499
  %694 = shl i32 %692, 3
  %695 = add i32 %693, %694
  %696 = ashr i32 %695, 16
  %697 = xor i32 %695, %696
  %698 = xor i32 %697, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %699 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %700 = load ptr, ptr %178, align 8
  %701 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %700, 0
  %702 = load ptr, ptr %179, align 8
  %703 = insertvalue { ptr, ptr, ptr, i32 } %701, ptr %702, 1
  %704 = load ptr, ptr %260, align 8
  %705 = insertvalue { ptr, ptr, ptr, i32 } %703, ptr %704, 2
  %706 = load i32, ptr %180, align 4
  %707 = insertvalue { ptr, ptr, ptr, i32 } %705, i32 %706, 3
  %hash_coef_ptr.i.i10.i1829 = getelementptr i8, ptr %700, i64 8
  %tbl_size_ptr.i.i11.i1830 = getelementptr i8, ptr %700, i64 16
  %offset_tbl_ptr.i.i12.i1831 = getelementptr i8, ptr %700, i64 40
  %hash_coef.i.i13.i1832 = load i64, ptr %hash_coef_ptr.i.i10.i1829, align 4
  %tbl_size.i.i14.i1833 = load i64, ptr %tbl_size_ptr.i.i11.i1830, align 4
  %offset_tbl.i.i15.i1834 = load ptr, ptr %offset_tbl_ptr.i.i12.i1831, align 8
  %product.i.i.i16.i1835 = mul i64 %hash_coef.i.i13.i1832, -5261542750394134544
  %shifted.i.i.i17.i1836 = lshr i64 %product.i.i.i16.i1835, 32
  %xored.i.i.i18.i1837 = xor i64 %shifted.i.i.i17.i1836, %product.i.i.i16.i1835
  %hash.i.i.i19.i1838 = and i64 %xored.i.i.i18.i1837, %tbl_size.i.i14.i1833
  %offset_ptr.i.i20.i1839 = getelementptr i32, ptr %offset_tbl.i.i15.i1834, i64 %hash.i.i.i19.i1838
  %offset.i.i21.i1840 = load i32, ptr %offset_ptr.i.i20.i1839, align 4
  %eq.i.i1841 = icmp eq i32 %706, %offset.i.i21.i1840
  call void @llvm.assume(i1 %eq.i.i1841) #30
  %708 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %709 = call ptr @llvm.invariant.start.p0(i64 600, ptr %700)
  %710 = sext i32 %706 to i64
  %711 = getelementptr ptr, ptr %700, i64 %710
  %712 = getelementptr i8, ptr %711, i64 64
  %713 = load ptr, ptr %712, align 8
  %714 = call ptr %713({ ptr, ptr, ptr, i32 } %707, ptr nonnull %2)
  %715 = call i32 %714({ ptr, ptr, ptr, i32 } %707, { ptr, ptr, ptr, i32 } %707, ptr nonnull %2)
  %716 = add i32 %715, -1
  %717 = and i32 %716, %698
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %718 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %719 = load ptr, ptr %178, align 8
  %720 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %719, 0
  %721 = load ptr, ptr %179, align 8
  %722 = insertvalue { ptr, ptr, ptr, i32 } %720, ptr %721, 1
  %723 = load ptr, ptr %260, align 8
  %724 = insertvalue { ptr, ptr, ptr, i32 } %722, ptr %723, 2
  %725 = load i32, ptr %180, align 4
  %726 = insertvalue { ptr, ptr, ptr, i32 } %724, i32 %725, 3
  %hash_coef_ptr.i.i221.i671 = getelementptr i8, ptr %719, i64 8
  %tbl_size_ptr.i.i222.i672 = getelementptr i8, ptr %719, i64 16
  %offset_tbl_ptr.i.i223.i673 = getelementptr i8, ptr %719, i64 40
  %hash_coef.i.i224.i674 = load i64, ptr %hash_coef_ptr.i.i221.i671, align 4
  %tbl_size.i.i225.i675 = load i64, ptr %tbl_size_ptr.i.i222.i672, align 4
  %offset_tbl.i.i226.i676 = load ptr, ptr %offset_tbl_ptr.i.i223.i673, align 8
  %product.i.i.i227.i677 = mul i64 %hash_coef.i.i224.i674, -5261542750394134544
  %shifted.i.i.i228.i678 = lshr i64 %product.i.i.i227.i677, 32
  %xored.i.i.i229.i679 = xor i64 %shifted.i.i.i228.i678, %product.i.i.i227.i677
  %hash.i.i.i230.i680 = and i64 %xored.i.i.i229.i679, %tbl_size.i.i225.i675
  %offset_ptr.i.i231.i681 = getelementptr i32, ptr %offset_tbl.i.i226.i676, i64 %hash.i.i.i230.i680
  %offset.i.i232.i682 = load i32, ptr %offset_ptr.i.i231.i681, align 4
  %eq.i235.i683 = icmp eq i32 %725, %offset.i.i232.i682
  call void @llvm.assume(i1 %eq.i235.i683) #30
  store ptr @_parameterization_Ptri32, ptr %120, align 8
  %727 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %120)
  %728 = call ptr @llvm.invariant.start.p0(i64 600, ptr %719)
  %729 = sext i32 %725 to i64
  %730 = getelementptr ptr, ptr %719, i64 %729
  %731 = getelementptr i8, ptr %730, i64 120
  %732 = load ptr, ptr %731, align 8
  store ptr @i32_typ, ptr %121, align 8
  %733 = call ptr %732({ ptr, ptr, ptr, i32 } %726, ptr nonnull %121)
  %734 = call { ptr, i160 } %733({ ptr, ptr, ptr, i32 } %726, { ptr, ptr, ptr, i32 } %726, ptr nonnull %120, i32 %717)
  %.fca.0.extract102.i684 = extractvalue { ptr, i160 } %734, 0
  %735 = icmp ne ptr %.fca.0.extract102.i684, @nil_typ
  %736 = icmp ne ptr %.fca.0.extract102.i684, null
  %.not151.i685 = and i1 %735, %736
  br i1 %.not151.i685, label %737, label %.critedge158.i686

737:                                              ; preds = %.critedge.i666
  %.fca.1.extract104.i718 = extractvalue { ptr, i160 } %734, 1
  %.sroa.4.8.extract.trunc.i719 = trunc i160 %.fca.1.extract104.i718 to i64
  %738 = inttoptr i64 %.sroa.4.8.extract.trunc.i719 to ptr
  %.sroa.7508.8.extract.shift.i720 = lshr i160 %.fca.1.extract104.i718, 64
  %.sroa.7508.8.extract.trunc.i721 = trunc i160 %.sroa.7508.8.extract.shift.i720 to i64
  %739 = inttoptr i64 %.sroa.7508.8.extract.trunc.i721 to ptr
  %hash_coef_ptr.i.i237.i722 = getelementptr i8, ptr %.fca.0.extract102.i684, i64 8
  %tbl_size_ptr.i.i238.i723 = getelementptr i8, ptr %.fca.0.extract102.i684, i64 16
  %offset_tbl_ptr.i.i239.i724 = getelementptr i8, ptr %.fca.0.extract102.i684, i64 40
  %hash_coef.i.i240.i725 = load i64, ptr %hash_coef_ptr.i.i237.i722, align 4
  %tbl_size.i.i241.i726 = load i64, ptr %tbl_size_ptr.i.i238.i723, align 4
  %offset_tbl.i.i242.i727 = load ptr, ptr %offset_tbl_ptr.i.i239.i724, align 8
  %product.i.i.i243.i728 = mul i64 %hash_coef.i.i240.i725, 4015701072841558310
  %shifted.i.i.i244.i729 = lshr i64 %product.i.i.i243.i728, 32
  %xored.i.i.i245.i730 = xor i64 %shifted.i.i.i244.i729, %product.i.i.i243.i728
  %hash.i.i.i246.i731 = and i64 %xored.i.i.i245.i730, %tbl_size.i.i241.i726
  %offset_ptr.i.i247.i732 = getelementptr i32, ptr %offset_tbl.i.i242.i727, i64 %hash.i.i.i246.i731
  %offset.i.i248.i733 = load i32, ptr %offset_ptr.i.i247.i732, align 4
  %740 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i684, 0
  %741 = insertvalue { ptr, ptr, ptr, i32 } %740, ptr %738, 1
  %742 = insertvalue { ptr, ptr, ptr, i32 } %741, ptr %739, 2
  %743 = insertvalue { ptr, ptr, ptr, i32 } %742, i32 %offset.i.i248.i733, 3
  %744 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %745 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %746 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i684)
  %747 = sext i32 %offset.i.i248.i733 to i64
  %748 = getelementptr ptr, ptr %.fca.0.extract102.i684, i64 %747
  %749 = getelementptr i8, ptr %748, i64 64
  %750 = load ptr, ptr %749, align 8
  %751 = call ptr %750({ ptr, ptr, ptr, i32 } %743, ptr nonnull %2)
  %752 = call i32 %751({ ptr, ptr, ptr, i32 } %743, { ptr, ptr, ptr, i32 } %743, ptr nonnull %2)
  %753 = icmp eq i32 %752, %502
  %754 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %755 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %756 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i684)
  %757 = getelementptr i8, ptr %748, i64 48
  %758 = load ptr, ptr %757, align 8
  %759 = call ptr %758({ ptr, ptr, ptr, i32 } %743, ptr nonnull %2)
  %760 = call { ptr, i160 } %759({ ptr, ptr, ptr, i32 } %743, { ptr, ptr, ptr, i32 } %743, ptr nonnull %2)
  %761 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %762 = load ptr, ptr %154, align 8
  %763 = call i1 %762({ ptr, i160 } %760, { ptr, i160 } %332)
  %764 = and i1 %753, %763
  br i1 %764, label %765, label %.critedge158.i686

765:                                              ; preds = %737
  %766 = load ptr, ptr %result.i, align 8
  %767 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %768 = load ptr, ptr %148, align 8
  %769 = load ptr, ptr %766, align 8
  %770 = getelementptr i8, ptr %769, i64 48
  %771 = load ptr, ptr %770, align 8
  %772 = call { i64, i64 } %771(ptr nonnull %766)
  %773 = extractvalue { i64, i64 } %772, 0
  %774 = extractvalue { i64, i64 } %772, 1
  %775 = urem i64 20, %774
  %776 = icmp eq i64 %775, 0
  %777 = sub i64 %774, %775
  %778 = select i1 %776, i64 0, i64 %777
  %779 = add i64 %773, 20
  %780 = add i64 %779, %778
  %781 = load ptr, ptr %768, align 8
  %782 = getelementptr i8, ptr %781, i64 48
  %783 = load ptr, ptr %782, align 8
  %784 = call { i64, i64 } %783(ptr nonnull %768)
  %785 = extractvalue { i64, i64 } %784, 0
  %786 = extractvalue { i64, i64 } %784, 1
  %787 = call i64 @llvm.umax.i64(i64 %774, i64 %786)
  %788 = call i64 @llvm.umax.i64(i64 %787, i64 8)
  %789 = urem i64 %780, %786
  %790 = icmp eq i64 %789, 0
  %791 = sub i64 %786, %789
  %792 = select i1 %790, i64 0, i64 %791
  %793 = add i64 %785, %780
  %794 = add i64 %793, %792
  %795 = urem i64 %794, %788
  %796 = icmp eq i64 %795, 0
  %797 = sub i64 %788, %795
  %798 = select i1 %796, i64 0, i64 %797
  %799 = add i64 %798, %794
  %result.i250.i735 = call noalias ptr @bump_malloc_inner(i64 noundef %799, ptr nonnull @current_ptr) #29
  store ptr %766, ptr %result.i250.i735, align 8
  %800 = getelementptr i8, ptr %result.i250.i735, i64 8
  store ptr %768, ptr %800, align 8
  %801 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i735)
  store ptr @Entry, ptr %122, align 8
  store ptr %result.i250.i735, ptr %249, align 8
  store i32 9, ptr %250, align 8
  %802 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %122)
  %803 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %804 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %805 = load ptr, ptr %766, align 8
  %806 = getelementptr i8, ptr %805, i64 48
  %807 = load ptr, ptr %806, align 8
  %808 = call { i64, i64 } %807(ptr nonnull %766)
  %809 = extractvalue { i64, i64 } %808, 1
  %810 = urem i64 20, %809
  %811 = icmp eq i64 %810, 0
  %reass.sub3547 = sub i64 %809, %810
  %812 = add i64 %reass.sub3547, 20
  %813 = select i1 %811, i64 20, i64 %812
  %814 = getelementptr i8, ptr %result.i250.i735, i64 %813
  %815 = load ptr, ptr %result.i250.i735, align 8
  %816 = load ptr, ptr %815, align 8
  %817 = getelementptr i8, ptr %816, i64 64
  %818 = load ptr, ptr %817, align 8
  call void %818({ ptr, i160 } %332, ptr nonnull %815, ptr %814)
  %819 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %820 = load ptr, ptr %result.i250.i735, align 8
  %821 = load ptr, ptr %820, align 8
  %822 = getelementptr i8, ptr %821, i64 48
  %823 = load ptr, ptr %822, align 8
  %824 = call { i64, i64 } %823(ptr nonnull %820)
  %825 = extractvalue { i64, i64 } %824, 0
  %826 = extractvalue { i64, i64 } %824, 1
  %827 = urem i64 20, %826
  %828 = icmp eq i64 %827, 0
  %829 = sub i64 %826, %827
  %830 = select i1 %828, i64 0, i64 %829
  %831 = add i64 %825, 20
  %832 = add i64 %831, %830
  %833 = load ptr, ptr %800, align 8
  %834 = load ptr, ptr %833, align 8
  %835 = getelementptr i8, ptr %834, i64 48
  %836 = load ptr, ptr %835, align 8
  %837 = call { i64, i64 } %836(ptr nonnull %833)
  %838 = extractvalue { i64, i64 } %837, 1
  %839 = urem i64 %832, %838
  %840 = icmp eq i64 %839, 0
  %841 = sub i64 %838, %839
  %842 = select i1 %840, i64 0, i64 %841
  %843 = getelementptr i8, ptr %result.i250.i735, i64 %832
  %844 = getelementptr i8, ptr %843, i64 %842
  %845 = load ptr, ptr %800, align 8
  %846 = load ptr, ptr %845, align 8
  %847 = getelementptr i8, ptr %846, i64 64
  %848 = load ptr, ptr %847, align 8
  call void %848({ ptr, i160 } %499, ptr nonnull %845, ptr %844)
  %849 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %850 = getelementptr i8, ptr %result.i250.i735, i64 16
  store i32 %502, ptr %850, align 4
  %851 = load ptr, ptr %251, align 8
  %852 = ptrtoint ptr %result.i250.i735 to i64
  %853 = ptrtoint ptr %851 to i64
  %.sroa.282.0.insert.ext.i736 = zext i64 %853 to i160
  %.sroa.282.0.insert.shift.i737 = shl nuw nsw i160 %.sroa.282.0.insert.ext.i736, 64
  %.sroa.081.0.insert.ext.i739 = zext i64 %852 to i160
  %.sroa.282.0.insert.insert.i738 = or disjoint i160 %.sroa.282.0.insert.shift.i737, %.sroa.081.0.insert.ext.i739
  %.sroa.081.0.insert.insert.i740 = or disjoint i160 %.sroa.282.0.insert.insert.i738, 3062541302288446171170371466885913903104
  %854 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i740, 1
  %855 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %856 = load ptr, ptr %178, align 8
  %857 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %856, 0
  %858 = load ptr, ptr %179, align 8
  %859 = insertvalue { ptr, ptr, ptr, i32 } %857, ptr %858, 1
  %860 = load ptr, ptr %260, align 8
  %861 = insertvalue { ptr, ptr, ptr, i32 } %859, ptr %860, 2
  %862 = load i32, ptr %180, align 4
  %863 = insertvalue { ptr, ptr, ptr, i32 } %861, i32 %862, 3
  %hash_coef_ptr.i.i266.i745 = getelementptr i8, ptr %856, i64 8
  %tbl_size_ptr.i.i267.i746 = getelementptr i8, ptr %856, i64 16
  %offset_tbl_ptr.i.i268.i747 = getelementptr i8, ptr %856, i64 40
  %hash_coef.i.i269.i748 = load i64, ptr %hash_coef_ptr.i.i266.i745, align 4
  %tbl_size.i.i270.i749 = load i64, ptr %tbl_size_ptr.i.i267.i746, align 4
  %offset_tbl.i.i271.i750 = load ptr, ptr %offset_tbl_ptr.i.i268.i747, align 8
  %product.i.i.i272.i751 = mul i64 %hash_coef.i.i269.i748, -5261542750394134544
  %shifted.i.i.i273.i752 = lshr i64 %product.i.i.i272.i751, 32
  %xored.i.i.i274.i753 = xor i64 %shifted.i.i.i273.i752, %product.i.i.i272.i751
  %hash.i.i.i275.i754 = and i64 %xored.i.i.i274.i753, %tbl_size.i.i270.i749
  %offset_ptr.i.i276.i755 = getelementptr i32, ptr %offset_tbl.i.i271.i750, i64 %hash.i.i.i275.i754
  %offset.i.i277.i756 = load i32, ptr %offset_ptr.i.i276.i755, align 4
  %eq.i280.i757 = icmp eq i32 %862, %offset.i.i277.i756
  call void @llvm.assume(i1 %eq.i280.i757) #30
  %864 = load ptr, ptr %result.i, align 8
  %865 = load ptr, ptr %148, align 8
  %result.i281.i758 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %866 = getelementptr i8, ptr %result.i281.i758, i64 16
  store ptr %865, ptr %866, align 8
  %867 = getelementptr i8, ptr %result.i281.i758, i64 8
  store ptr %864, ptr %867, align 8
  %868 = getelementptr i8, ptr %result.i281.i758, i64 24
  store ptr null, ptr %868, align 8
  %869 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i758)
  store ptr @Entry, ptr %result.i281.i758, align 8
  store ptr @_parameterization_Ptri32, ptr %123, align 8
  store ptr %result.i281.i758, ptr %252, align 8
  %870 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %123)
  %871 = call ptr @llvm.invariant.start.p0(i64 600, ptr %856)
  %872 = sext i32 %862 to i64
  %873 = getelementptr ptr, ptr %856, i64 %872
  %874 = getelementptr i8, ptr %873, i64 128
  %875 = load ptr, ptr %874, align 8
  store ptr @i32_typ, ptr %124, align 8
  store ptr @Entry, ptr %253, align 8
  %876 = call ptr %875({ ptr, ptr, ptr, i32 } %863, ptr nonnull %124)
  call void %876({ ptr, ptr, ptr, i32 } %863, { ptr, ptr, ptr, i32 } %863, ptr nonnull %123, i32 %717, { ptr, i160 } %854)
  br label %HashMap_insert_keyK_valueV.exit800

.critedge158.i686:                                ; preds = %737, %.critedge.i666
  %877 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %878 = load ptr, ptr %165, align 8
  %879 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %878, 0
  %880 = load ptr, ptr %166, align 8
  %881 = insertvalue { ptr, ptr, ptr, i32 } %879, ptr %880, 1
  %882 = load ptr, ptr %259, align 8
  %883 = insertvalue { ptr, ptr, ptr, i32 } %881, ptr %882, 2
  %884 = load i32, ptr %167, align 4
  %885 = insertvalue { ptr, ptr, ptr, i32 } %883, i32 %884, 3
  %hash_coef_ptr.i.i283.i691 = getelementptr i8, ptr %878, i64 8
  %tbl_size_ptr.i.i284.i692 = getelementptr i8, ptr %878, i64 16
  %offset_tbl_ptr.i.i285.i693 = getelementptr i8, ptr %878, i64 40
  %hash_coef.i.i286.i694 = load i64, ptr %hash_coef_ptr.i.i283.i691, align 4
  %tbl_size.i.i287.i695 = load i64, ptr %tbl_size_ptr.i.i284.i692, align 4
  %offset_tbl.i.i288.i696 = load ptr, ptr %offset_tbl_ptr.i.i285.i693, align 8
  %product.i.i.i289.i697 = mul i64 %hash_coef.i.i286.i694, -5261542750394134544
  %shifted.i.i.i290.i698 = lshr i64 %product.i.i.i289.i697, 32
  %xored.i.i.i291.i699 = xor i64 %shifted.i.i.i290.i698, %product.i.i.i289.i697
  %hash.i.i.i292.i700 = and i64 %xored.i.i.i291.i699, %tbl_size.i.i287.i695
  %offset_ptr.i.i293.i701 = getelementptr i32, ptr %offset_tbl.i.i288.i696, i64 %hash.i.i.i292.i700
  %offset.i.i294.i702 = load i32, ptr %offset_ptr.i.i293.i701, align 4
  %eq.i297.i703 = icmp eq i32 %884, %offset.i.i294.i702
  call void @llvm.assume(i1 %eq.i297.i703) #30
  %886 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %887 = call ptr @llvm.invariant.start.p0(i64 600, ptr %878)
  %888 = sext i32 %884 to i64
  %889 = getelementptr ptr, ptr %878, i64 %888
  %890 = getelementptr i8, ptr %889, i64 64
  %891 = load ptr, ptr %890, align 8
  %892 = call ptr %891({ ptr, ptr, ptr, i32 } %885, ptr nonnull %2)
  %893 = call i32 %892({ ptr, ptr, ptr, i32 } %885, { ptr, ptr, ptr, i32 } %885, ptr nonnull %2)
  %894 = load i32, ptr %261, align 4
  %.not.i704 = icmp slt i32 %894, %893
  br i1 %.not.i704, label %._crit_edge.i705, label %895

895:                                              ; preds = %.critedge158.i686
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %53)
  %896 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %897 = load ptr, ptr %165, align 8
  %898 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %897, 0
  %899 = load ptr, ptr %166, align 8
  %900 = insertvalue { ptr, ptr, ptr, i32 } %898, ptr %899, 1
  %901 = load ptr, ptr %259, align 8
  %902 = insertvalue { ptr, ptr, ptr, i32 } %900, ptr %901, 2
  %903 = load i32, ptr %167, align 4
  %904 = insertvalue { ptr, ptr, ptr, i32 } %902, i32 %903, 3
  %hash_coef_ptr.i.i64.i1858 = getelementptr i8, ptr %897, i64 8
  %tbl_size_ptr.i.i65.i1859 = getelementptr i8, ptr %897, i64 16
  %offset_tbl_ptr.i.i66.i1860 = getelementptr i8, ptr %897, i64 40
  %hash_coef.i.i67.i1861 = load i64, ptr %hash_coef_ptr.i.i64.i1858, align 4
  %tbl_size.i.i68.i1862 = load i64, ptr %tbl_size_ptr.i.i65.i1859, align 4
  %offset_tbl.i.i69.i1863 = load ptr, ptr %offset_tbl_ptr.i.i66.i1860, align 8
  %product.i.i.i70.i1864 = mul i64 %hash_coef.i.i67.i1861, -5261542750394134544
  %shifted.i.i.i71.i1865 = lshr i64 %product.i.i.i70.i1864, 32
  %xored.i.i.i72.i1866 = xor i64 %shifted.i.i.i71.i1865, %product.i.i.i70.i1864
  %hash.i.i.i73.i1867 = and i64 %xored.i.i.i72.i1866, %tbl_size.i.i68.i1862
  %offset_ptr.i.i74.i1868 = getelementptr i32, ptr %offset_tbl.i.i69.i1863, i64 %hash.i.i.i73.i1867
  %offset.i.i75.i1869 = load i32, ptr %offset_ptr.i.i74.i1868, align 4
  %eq.i.i1870 = icmp eq i32 %903, %offset.i.i75.i1869
  call void @llvm.assume(i1 %eq.i.i1870) #30
  %905 = load ptr, ptr %178, align 8
  %906 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %905, 0
  %907 = load ptr, ptr %179, align 8
  %908 = insertvalue { ptr, ptr, ptr, i32 } %906, ptr %907, 1
  %909 = load ptr, ptr %260, align 8
  %910 = insertvalue { ptr, ptr, ptr, i32 } %908, ptr %909, 2
  %911 = load i32, ptr %180, align 4
  %912 = insertvalue { ptr, ptr, ptr, i32 } %910, i32 %911, 3
  %hash_coef_ptr.i.i92.i1875 = getelementptr i8, ptr %905, i64 8
  %tbl_size_ptr.i.i93.i1876 = getelementptr i8, ptr %905, i64 16
  %offset_tbl_ptr.i.i94.i1877 = getelementptr i8, ptr %905, i64 40
  %hash_coef.i.i95.i1878 = load i64, ptr %hash_coef_ptr.i.i92.i1875, align 4
  %tbl_size.i.i96.i1879 = load i64, ptr %tbl_size_ptr.i.i93.i1876, align 4
  %offset_tbl.i.i97.i1880 = load ptr, ptr %offset_tbl_ptr.i.i94.i1877, align 8
  %product.i.i.i98.i1881 = mul i64 %hash_coef.i.i95.i1878, -5261542750394134544
  %shifted.i.i.i99.i1882 = lshr i64 %product.i.i.i98.i1881, 32
  %xored.i.i.i100.i1883 = xor i64 %shifted.i.i.i99.i1882, %product.i.i.i98.i1881
  %hash.i.i.i101.i1884 = and i64 %xored.i.i.i100.i1883, %tbl_size.i.i96.i1879
  %offset_ptr.i.i102.i1885 = getelementptr i32, ptr %offset_tbl.i.i97.i1880, i64 %hash.i.i.i101.i1884
  %offset.i.i103.i1886 = load i32, ptr %offset_ptr.i.i102.i1885, align 4
  %eq.i106.i1887 = icmp eq i32 %911, %offset.i.i103.i1886
  call void @llvm.assume(i1 %eq.i106.i1887) #30
  %913 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %914 = call ptr @llvm.invariant.start.p0(i64 600, ptr %897)
  %915 = sext i32 %903 to i64
  %916 = getelementptr ptr, ptr %897, i64 %915
  %917 = getelementptr i8, ptr %916, i64 64
  %918 = load ptr, ptr %917, align 8
  %919 = call ptr %918({ ptr, ptr, ptr, i32 } %904, ptr nonnull %2)
  %920 = call i32 %919({ ptr, ptr, ptr, i32 } %904, { ptr, ptr, ptr, i32 } %904, ptr nonnull %2)
  %921 = shl i32 %920, 1
  %922 = load i32, ptr %261, align 4
  %923 = load ptr, ptr %result.i, align 8
  %924 = load ptr, ptr %148, align 8
  %925 = sext i32 %922 to i64
  %926 = shl nsw i64 %925, 5
  %result.i.i.i1890 = call noalias ptr @bump_malloc_inner(i64 noundef %926, ptr nonnull @current_ptr) #29
  %927 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %928 = icmp sgt i32 %920, 0
  br i1 %928, label %.lr.ph434.i1923, label %._crit_edge395.i1892

.lr.ph434.i1923:                                  ; preds = %895
  %invariant.gep.i1891 = getelementptr i8, ptr %897, i64 120
  %929 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1926 = getelementptr ptr, ptr %invariant.gep.i1891, i64 %915
  br label %930

930:                                              ; preds = %952, %.lr.ph434.i1923
  %.reg2mem105.0432.i1924 = phi i32 [ 0, %.lr.ph434.i1923 ], [ %.reg2mem101.0.i1929, %952 ]
  %.reg2mem103.0431.i1925 = phi i32 [ 0, %.lr.ph434.i1923 ], [ %953, %952 ]
  store ptr @_parameterization_Ptri32, ptr %48, align 8
  %931 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %48)
  %932 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %897)
  %933 = load ptr, ptr %gep.i1926, align 8
  store ptr @i32_typ, ptr %49, align 8
  %934 = call ptr %933({ ptr, ptr, ptr, i32 } %904, ptr nonnull %49)
  %935 = call { ptr, i160 } %934({ ptr, ptr, ptr, i32 } %904, { ptr, ptr, ptr, i32 } %904, ptr nonnull %48, i32 %.reg2mem103.0431.i1925)
  %.fca.0.extract52.i1927 = extractvalue { ptr, i160 } %935, 0
  %936 = icmp ne ptr %.fca.0.extract52.i1927, @nil_typ
  %937 = icmp ne ptr %.fca.0.extract52.i1927, null
  %.not60.i1928 = and i1 %936, %937
  br i1 %.not60.i1928, label %938, label %952

938:                                              ; preds = %930
  %hash_coef_ptr.i.i137.i1956 = getelementptr i8, ptr %.fca.0.extract52.i1927, i64 8
  %tbl_size_ptr.i.i138.i1957 = getelementptr i8, ptr %.fca.0.extract52.i1927, i64 16
  %offset_tbl_ptr.i.i139.i1958 = getelementptr i8, ptr %.fca.0.extract52.i1927, i64 40
  %hash_coef.i.i140.i1959 = load i64, ptr %hash_coef_ptr.i.i137.i1956, align 4
  %tbl_size.i.i141.i1960 = load i64, ptr %tbl_size_ptr.i.i138.i1957, align 4
  %offset_tbl.i.i142.i1961 = load ptr, ptr %offset_tbl_ptr.i.i139.i1958, align 8
  %product.i.i.i143.i1962 = mul i64 %hash_coef.i.i140.i1959, 4015701072841558310
  %shifted.i.i.i144.i1963 = lshr i64 %product.i.i.i143.i1962, 32
  %xored.i.i.i145.i1964 = xor i64 %shifted.i.i.i144.i1963, %product.i.i.i143.i1962
  %hash.i.i.i146.i1965 = and i64 %xored.i.i.i145.i1964, %tbl_size.i.i141.i1960
  %offset_ptr.i.i147.i1966 = getelementptr i32, ptr %offset_tbl.i.i142.i1961, i64 %hash.i.i.i146.i1965
  %offset.i.i148.i1967 = load i32, ptr %offset_ptr.i.i147.i1966, align 4
  %939 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %940 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %941 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %942 = icmp slt i32 %.reg2mem105.0432.i1924, %922
  br i1 %942, label %943, label %._crit_edge.i1968

943:                                              ; preds = %938
  %.fca.1.extract54.i1969 = extractvalue { ptr, i160 } %935, 1
  %.sroa.351.0.insert.ext.i1970 = zext i32 %offset.i.i148.i1967 to i160
  %.sroa.351.0.insert.shift.i1971 = shl nuw i160 %.sroa.351.0.insert.ext.i1970, 128
  %944 = and i160 %.fca.1.extract54.i1969, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1972 = or disjoint i160 %.sroa.351.0.insert.shift.i1971, %944
  %945 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %946 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %947 = sext i32 %.reg2mem105.0432.i1924 to i64
  %948 = shl nsw i64 %947, 5
  %949 = getelementptr i8, ptr %result.i.i.i1890, i64 %948
  store ptr %.fca.0.extract52.i1927, ptr %949, align 8
  %950 = getelementptr i8, ptr %949, i64 8
  store i160 %.sroa.049.0.insert.insert.i1972, ptr %950, align 4
  br label %._crit_edge.i1968

._crit_edge.i1968:                                ; preds = %943, %938
  %951 = add i32 %.reg2mem105.0432.i1924, 1
  br label %952

952:                                              ; preds = %._crit_edge.i1968, %930
  %.reg2mem101.0.i1929 = phi i32 [ %951, %._crit_edge.i1968 ], [ %.reg2mem105.0432.i1924, %930 ]
  %953 = add nuw nsw i32 %.reg2mem103.0431.i1925, 1
  %954 = icmp slt i32 %953, %920
  br i1 %954, label %930, label %.lr.ph.i1930

.lr.ph.i1930:                                     ; preds = %952
  %invariant.gep396.i1931 = getelementptr i8, ptr %905, i64 120
  %955 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %956 = sext i32 %911 to i64
  %gep397.i1934 = getelementptr ptr, ptr %invariant.gep396.i1931, i64 %956
  br label %957

957:                                              ; preds = %979, %.lr.ph.i1930
  %.reg2mem91.0394.i1932 = phi i32 [ %.reg2mem101.0.i1929, %.lr.ph.i1930 ], [ %.reg2mem87.0.i1937, %979 ]
  %.reg2mem89.0393.i1933 = phi i32 [ 0, %.lr.ph.i1930 ], [ %980, %979 ]
  store ptr @_parameterization_Ptri32, ptr %50, align 8
  %958 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %50)
  %959 = call ptr @llvm.invariant.start.p0(i64 600, ptr %905)
  %960 = load ptr, ptr %gep397.i1934, align 8
  store ptr @i32_typ, ptr %51, align 8
  %961 = call ptr %960({ ptr, ptr, ptr, i32 } %912, ptr nonnull %51)
  %962 = call { ptr, i160 } %961({ ptr, ptr, ptr, i32 } %912, { ptr, ptr, ptr, i32 } %912, ptr nonnull %50, i32 %.reg2mem89.0393.i1933)
  %.fca.0.extract42.i1935 = extractvalue { ptr, i160 } %962, 0
  %963 = icmp ne ptr %.fca.0.extract42.i1935, @nil_typ
  %964 = icmp ne ptr %.fca.0.extract42.i1935, null
  %.not62.i1936 = and i1 %963, %964
  br i1 %.not62.i1936, label %965, label %979

965:                                              ; preds = %957
  %hash_coef_ptr.i.i152.i1938 = getelementptr i8, ptr %.fca.0.extract42.i1935, i64 8
  %tbl_size_ptr.i.i153.i1939 = getelementptr i8, ptr %.fca.0.extract42.i1935, i64 16
  %offset_tbl_ptr.i.i154.i1940 = getelementptr i8, ptr %.fca.0.extract42.i1935, i64 40
  %hash_coef.i.i155.i1941 = load i64, ptr %hash_coef_ptr.i.i152.i1938, align 4
  %tbl_size.i.i156.i1942 = load i64, ptr %tbl_size_ptr.i.i153.i1939, align 4
  %offset_tbl.i.i157.i1943 = load ptr, ptr %offset_tbl_ptr.i.i154.i1940, align 8
  %product.i.i.i158.i1944 = mul i64 %hash_coef.i.i155.i1941, 4015701072841558310
  %shifted.i.i.i159.i1945 = lshr i64 %product.i.i.i158.i1944, 32
  %xored.i.i.i160.i1946 = xor i64 %shifted.i.i.i159.i1945, %product.i.i.i158.i1944
  %hash.i.i.i161.i1947 = and i64 %xored.i.i.i160.i1946, %tbl_size.i.i156.i1942
  %offset_ptr.i.i162.i1948 = getelementptr i32, ptr %offset_tbl.i.i157.i1943, i64 %hash.i.i.i161.i1947
  %offset.i.i163.i1949 = load i32, ptr %offset_ptr.i.i162.i1948, align 4
  %966 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %967 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %968 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %969 = icmp slt i32 %.reg2mem91.0394.i1932, %922
  br i1 %969, label %970, label %._crit_edge1.i1950

970:                                              ; preds = %965
  %.fca.1.extract44.i1951 = extractvalue { ptr, i160 } %962, 1
  %.sroa.3.0.insert.ext.i1952 = zext i32 %offset.i.i163.i1949 to i160
  %.sroa.3.0.insert.shift.i1953 = shl nuw i160 %.sroa.3.0.insert.ext.i1952, 128
  %971 = and i160 %.fca.1.extract44.i1951, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1954 = or disjoint i160 %.sroa.3.0.insert.shift.i1953, %971
  %972 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %973 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %974 = sext i32 %.reg2mem91.0394.i1932 to i64
  %975 = shl nsw i64 %974, 5
  %976 = getelementptr i8, ptr %result.i.i.i1890, i64 %975
  store ptr %.fca.0.extract42.i1935, ptr %976, align 8
  %977 = getelementptr i8, ptr %976, i64 8
  store i160 %.sroa.040.0.insert.insert.i1954, ptr %977, align 4
  br label %._crit_edge1.i1950

._crit_edge1.i1950:                               ; preds = %970, %965
  %978 = add i32 %.reg2mem91.0394.i1932, 1
  br label %979

979:                                              ; preds = %._crit_edge1.i1950, %957
  %.reg2mem87.0.i1937 = phi i32 [ %978, %._crit_edge1.i1950 ], [ %.reg2mem91.0394.i1932, %957 ]
  %980 = add nuw nsw i32 %.reg2mem89.0393.i1933, 1
  %981 = icmp slt i32 %980, %920
  br i1 %981, label %957, label %._crit_edge395.i1892.loopexit

._crit_edge395.i1892.loopexit:                    ; preds = %979
  %.pre3193 = load ptr, ptr %result.i, align 8
  %.pre3194 = load ptr, ptr %148, align 8
  br label %._crit_edge395.i1892

._crit_edge395.i1892:                             ; preds = %._crit_edge395.i1892.loopexit, %895
  %982 = phi ptr [ %924, %895 ], [ %.pre3194, %._crit_edge395.i1892.loopexit ]
  %983 = phi ptr [ %923, %895 ], [ %.pre3193, %._crit_edge395.i1892.loopexit ]
  %.reg2mem91.0.lcssa.i1893 = phi i32 [ 0, %895 ], [ %.reg2mem87.0.i1937, %._crit_edge395.i1892.loopexit ]
  %984 = call i32 @llvm.smax.i32(i32 %921, i32 16)
  %result.i166.i1894 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %985 = getelementptr i8, ptr %result.i166.i1894, i64 16
  store ptr @_parameterization_Nil, ptr %985, align 8
  %result.i167.i1895 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %986 = getelementptr i8, ptr %result.i167.i1895, i64 16
  store ptr %982, ptr %986, align 8
  %987 = getelementptr i8, ptr %result.i167.i1895, i64 8
  store ptr %983, ptr %987, align 8
  %988 = getelementptr i8, ptr %result.i167.i1895, i64 24
  store ptr null, ptr %988, align 8
  %989 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1895)
  store ptr @Entry, ptr %result.i167.i1895, align 8
  %990 = getelementptr i8, ptr %result.i166.i1894, i64 8
  store ptr %result.i167.i1895, ptr %990, align 8
  %991 = getelementptr i8, ptr %result.i166.i1894, i64 24
  store ptr null, ptr %991, align 8
  %992 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1894)
  store ptr @union_typ, ptr %result.i166.i1894, align 8
  %result.i168.i1896 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1894, ptr %result.i168.i1896, align 8
  %993 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1896)
  store ptr @Array, ptr %52, align 8
  store ptr %result.i168.i1896, ptr %294, align 8
  store i32 9, ptr %295, align 8
  %994 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %52)
  %995 = getelementptr i8, ptr %result.i168.i1896, i64 16
  store i32 %984, ptr %995, align 4
  %996 = getelementptr i8, ptr %result.i168.i1896, i64 20
  store i32 %984, ptr %996, align 4
  %997 = zext nneg i32 %984 to i64
  %998 = shl nuw nsw i64 %997, 5
  %result.i.i416.i1897 = call noalias ptr @bump_malloc_inner(i64 noundef %998, ptr nonnull @current_ptr) #29
  %999 = getelementptr i8, ptr %result.i168.i1896, i64 8
  store ptr %result.i.i416.i1897, ptr %999, align 8
  %1000 = load ptr, ptr %296, align 8
  store ptr @Array, ptr %165, align 8
  store ptr %result.i168.i1896, ptr %166, align 8
  store ptr %1000, ptr %259, align 8
  store i32 9, ptr %167, align 4
  %1001 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i1898 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1002 = getelementptr i8, ptr %result.i183.i1898, i64 16
  store ptr @_parameterization_Nil, ptr %1002, align 8
  %result.i184.i1899 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1003 = getelementptr i8, ptr %result.i184.i1899, i64 16
  store ptr %982, ptr %1003, align 8
  %1004 = getelementptr i8, ptr %result.i184.i1899, i64 8
  store ptr %983, ptr %1004, align 8
  %1005 = getelementptr i8, ptr %result.i184.i1899, i64 24
  store ptr null, ptr %1005, align 8
  %1006 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1899)
  store ptr @Entry, ptr %result.i184.i1899, align 8
  %1007 = getelementptr i8, ptr %result.i183.i1898, i64 8
  store ptr %result.i184.i1899, ptr %1007, align 8
  %1008 = getelementptr i8, ptr %result.i183.i1898, i64 24
  store ptr null, ptr %1008, align 8
  %1009 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1898)
  store ptr @union_typ, ptr %result.i183.i1898, align 8
  %result.i185.i1900 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1898, ptr %result.i185.i1900, align 8
  %1010 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1900)
  store ptr @Array, ptr %53, align 8
  store ptr %result.i185.i1900, ptr %297, align 8
  store i32 9, ptr %298, align 8
  %1011 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %53)
  %1012 = getelementptr i8, ptr %result.i185.i1900, i64 16
  store i32 %984, ptr %1012, align 4
  %1013 = getelementptr i8, ptr %result.i185.i1900, i64 20
  store i32 %984, ptr %1013, align 4
  %result.i.i430.i1901 = call noalias ptr @bump_malloc_inner(i64 noundef %998, ptr nonnull @current_ptr) #29
  %1014 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1015 = getelementptr i8, ptr %result.i185.i1900, i64 8
  store ptr %result.i.i430.i1901, ptr %1015, align 8
  %1016 = load ptr, ptr %299, align 8
  store ptr @Array, ptr %178, align 8
  store ptr %result.i185.i1900, ptr %179, align 8
  store ptr %1016, ptr %260, align 8
  store i32 9, ptr %180, align 4
  store i32 0, ptr %261, align 4
  %1017 = icmp sgt i32 %.reg2mem91.0.lcssa.i1893, 0
  br i1 %1017, label %.lr.ph400.i1902, label %HashMap_resize_.exit1974

.lr.ph400.i1902:                                  ; preds = %._crit_edge395.i1892
  %1018 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1019 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1020 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1903

._crit_edge2.i1903:                               ; preds = %._crit_edge2.i1903, %.lr.ph400.i1902
  %.reg2mem77.0398.i1904 = phi i32 [ 0, %.lr.ph400.i1902 ], [ %1034, %._crit_edge2.i1903 ]
  %1021 = zext nneg i32 %.reg2mem77.0398.i1904 to i64
  %1022 = shl nuw nsw i64 %1021, 5
  %1023 = getelementptr i8, ptr %result.i.i.i1890, i64 %1022
  %1024 = load ptr, ptr %1023, align 8
  %1025 = getelementptr i8, ptr %1023, i64 8
  %1026 = load i160, ptr %1025, align 4
  %.sroa.3362.8.extract.trunc.i1907 = trunc i160 %1026 to i64
  %1027 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1907 to ptr
  %.sroa.5363.8.extract.shift.i1908 = lshr i160 %1026, 64
  %.sroa.5363.8.extract.trunc.i1909 = trunc i160 %.sroa.5363.8.extract.shift.i1908 to i64
  %1028 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1909 to ptr
  %hash_coef_ptr.i.i201.i1910 = getelementptr i8, ptr %1024, i64 8
  %tbl_size_ptr.i.i202.i1911 = getelementptr i8, ptr %1024, i64 16
  %offset_tbl_ptr.i.i203.i1912 = getelementptr i8, ptr %1024, i64 40
  %hash_coef.i.i232.i1913 = load i64, ptr %hash_coef_ptr.i.i201.i1910, align 4
  %tbl_size.i.i233.i1914 = load i64, ptr %tbl_size_ptr.i.i202.i1911, align 4
  %offset_tbl.i.i234.i1915 = load ptr, ptr %offset_tbl_ptr.i.i203.i1912, align 8
  %product.i.i.i235.i1916 = mul i64 %hash_coef.i.i232.i1913, 4015701072841558310
  %shifted.i.i.i236.i1917 = lshr i64 %product.i.i.i235.i1916, 32
  %xored.i.i.i237.i1918 = xor i64 %shifted.i.i.i236.i1917, %product.i.i.i235.i1916
  %hash.i.i.i238.i1919 = and i64 %xored.i.i.i237.i1918, %tbl_size.i.i233.i1914
  %offset_ptr.i.i239.i1920 = getelementptr i32, ptr %offset_tbl.i.i234.i1915, i64 %hash.i.i.i238.i1919
  %offset.i.i240.i1921 = load i32, ptr %offset_ptr.i.i239.i1920, align 4
  %1029 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1024, 0
  %1030 = insertvalue { ptr, ptr, ptr, i32 } %1029, ptr %1027, 1
  %1031 = insertvalue { ptr, ptr, ptr, i32 } %1030, ptr %1028, 2
  %1032 = insertvalue { ptr, ptr, ptr, i32 } %1031, i32 %offset.i.i240.i1921, 3
  %1033 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %302, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1032)
  %1034 = add nuw nsw i32 %.reg2mem77.0398.i1904, 1
  %1035 = icmp slt i32 %1034, %.reg2mem91.0.lcssa.i1893
  br i1 %1035, label %._crit_edge2.i1903, label %HashMap_resize_.exit1974

HashMap_resize_.exit1974:                         ; preds = %._crit_edge2.i1903, %._crit_edge395.i1892
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %51)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %52)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %53)
  br label %._crit_edge.i705

._crit_edge.i705:                                 ; preds = %HashMap_resize_.exit1974, %.critedge158.i686
  %1036 = load ptr, ptr %result.i, align 8
  %1037 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1038 = load ptr, ptr %148, align 8
  %1039 = load ptr, ptr %1036, align 8
  %1040 = getelementptr i8, ptr %1039, i64 48
  %1041 = load ptr, ptr %1040, align 8
  %1042 = call { i64, i64 } %1041(ptr nonnull %1036)
  %1043 = extractvalue { i64, i64 } %1042, 0
  %1044 = extractvalue { i64, i64 } %1042, 1
  %1045 = urem i64 20, %1044
  %1046 = icmp eq i64 %1045, 0
  %1047 = sub i64 %1044, %1045
  %1048 = select i1 %1046, i64 0, i64 %1047
  %1049 = add i64 %1043, 20
  %1050 = add i64 %1049, %1048
  %1051 = load ptr, ptr %1038, align 8
  %1052 = getelementptr i8, ptr %1051, i64 48
  %1053 = load ptr, ptr %1052, align 8
  %1054 = call { i64, i64 } %1053(ptr nonnull %1038)
  %1055 = extractvalue { i64, i64 } %1054, 0
  %1056 = extractvalue { i64, i64 } %1054, 1
  %1057 = call i64 @llvm.umax.i64(i64 %1044, i64 %1056)
  %1058 = call i64 @llvm.umax.i64(i64 %1057, i64 8)
  %1059 = urem i64 %1050, %1056
  %1060 = icmp eq i64 %1059, 0
  %1061 = sub i64 %1056, %1059
  %1062 = select i1 %1060, i64 0, i64 %1061
  %1063 = add i64 %1055, %1050
  %1064 = add i64 %1063, %1062
  %1065 = urem i64 %1064, %1058
  %1066 = icmp eq i64 %1065, 0
  %1067 = sub i64 %1058, %1065
  %1068 = select i1 %1066, i64 0, i64 %1067
  %1069 = add i64 %1068, %1064
  %result.i298.i706 = call noalias ptr @bump_malloc_inner(i64 noundef %1069, ptr nonnull @current_ptr) #29
  store ptr %1036, ptr %result.i298.i706, align 8
  %1070 = getelementptr i8, ptr %result.i298.i706, i64 8
  store ptr %1038, ptr %1070, align 8
  %1071 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i706)
  store ptr @Entry, ptr %125, align 8
  store ptr %result.i298.i706, ptr %246, align 8
  store i32 9, ptr %247, align 8
  %1072 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %125)
  %1073 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1074 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1075 = load ptr, ptr %1036, align 8
  %1076 = getelementptr i8, ptr %1075, i64 48
  %1077 = load ptr, ptr %1076, align 8
  %1078 = call { i64, i64 } %1077(ptr nonnull %1036)
  %1079 = extractvalue { i64, i64 } %1078, 1
  %1080 = urem i64 20, %1079
  %1081 = icmp eq i64 %1080, 0
  %reass.sub3546 = sub i64 %1079, %1080
  %1082 = add i64 %reass.sub3546, 20
  %1083 = select i1 %1081, i64 20, i64 %1082
  %1084 = getelementptr i8, ptr %result.i298.i706, i64 %1083
  %1085 = load ptr, ptr %result.i298.i706, align 8
  %1086 = load ptr, ptr %1085, align 8
  %1087 = getelementptr i8, ptr %1086, i64 64
  %1088 = load ptr, ptr %1087, align 8
  call void %1088({ ptr, i160 } %332, ptr nonnull %1085, ptr %1084)
  %1089 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1090 = load ptr, ptr %result.i298.i706, align 8
  %1091 = load ptr, ptr %1090, align 8
  %1092 = getelementptr i8, ptr %1091, i64 48
  %1093 = load ptr, ptr %1092, align 8
  %1094 = call { i64, i64 } %1093(ptr nonnull %1090)
  %1095 = extractvalue { i64, i64 } %1094, 0
  %1096 = extractvalue { i64, i64 } %1094, 1
  %1097 = urem i64 20, %1096
  %1098 = icmp eq i64 %1097, 0
  %1099 = sub i64 %1096, %1097
  %1100 = select i1 %1098, i64 0, i64 %1099
  %1101 = add i64 %1095, 20
  %1102 = add i64 %1101, %1100
  %1103 = load ptr, ptr %1070, align 8
  %1104 = load ptr, ptr %1103, align 8
  %1105 = getelementptr i8, ptr %1104, i64 48
  %1106 = load ptr, ptr %1105, align 8
  %1107 = call { i64, i64 } %1106(ptr nonnull %1103)
  %1108 = extractvalue { i64, i64 } %1107, 1
  %1109 = urem i64 %1102, %1108
  %1110 = icmp eq i64 %1109, 0
  %1111 = sub i64 %1108, %1109
  %1112 = select i1 %1110, i64 0, i64 %1111
  %1113 = getelementptr i8, ptr %result.i298.i706, i64 %1102
  %1114 = getelementptr i8, ptr %1113, i64 %1112
  %1115 = load ptr, ptr %1070, align 8
  %1116 = load ptr, ptr %1115, align 8
  %1117 = getelementptr i8, ptr %1116, i64 64
  %1118 = load ptr, ptr %1117, align 8
  call void %1118({ ptr, i160 } %499, ptr nonnull %1115, ptr %1114)
  %1119 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1120 = getelementptr i8, ptr %result.i298.i706, i64 16
  store i32 %502, ptr %1120, align 4
  %1121 = load ptr, ptr %248, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i1975)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1976)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %47)
  store ptr @Entry, ptr %47, align 8
  store ptr %result.i298.i706, ptr %303, align 8
  store ptr %1121, ptr %304, align 8
  store i32 9, ptr %305, align 8
  %1122 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %47)
  %1123 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1124 = load i32, ptr %181, align 4
  %1125 = icmp sgt i32 %1124, 0
  br i1 %1125, label %.lr.ph.i2006, label %._crit_edge1.i711

.lr.ph.i2006:                                     ; preds = %._crit_edge.i705
  %1126 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1127 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1128

1128:                                             ; preds = %.cont.cont.i2053, %.lr.ph.i2006
  %offset.i.i260.i20682817 = phi i32 [ 9, %.lr.ph.i2006 ], [ %offset.i.i260.i2068, %.cont.cont.i2053 ]
  %.sroa.speculated346.i20562815 = phi ptr [ %1121, %.lr.ph.i2006 ], [ %.sroa.speculated346.i2056, %.cont.cont.i2053 ]
  %.sroa.speculated352.i20552813 = phi ptr [ %result.i298.i706, %.lr.ph.i2006 ], [ %.sroa.speculated352.i2055, %.cont.cont.i2053 ]
  %.reg2mem195.0678.i2007 = phi i32 [ 1, %.lr.ph.i2006 ], [ %1284, %.cont.cont.i2053 ]
  %.reg2mem193.0677.i2008 = phi i32 [ 0, %.lr.ph.i2006 ], [ %1285, %.cont.cont.i2053 ]
  %1129 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i20552813, 1
  %1130 = insertvalue { ptr, ptr, ptr, i32 } %1129, ptr %.sroa.speculated346.i20562815, 2
  %1131 = insertvalue { ptr, ptr, ptr, i32 } %1130, i32 %offset.i.i260.i20682817, 3
  %1132 = sext i32 %offset.i.i260.i20682817 to i64
  %gep2812 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1132
  %1133 = load ptr, ptr %gep2812, align 8
  %1134 = call ptr %1133({ ptr, ptr, ptr, i32 } %1131, ptr nonnull %2)
  %1135 = call i32 %1134({ ptr, ptr, ptr, i32 } %1131, { ptr, ptr, ptr, i32 } %1131, ptr nonnull %2)
  %1136 = icmp eq i32 %.reg2mem195.0678.i2007, 1
  %1137 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1136, label %1138, label %1202

1138:                                             ; preds = %1128
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1139 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1140 = load ptr, ptr %165, align 8
  %1141 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1140, 0
  %1142 = load ptr, ptr %166, align 8
  %1143 = insertvalue { ptr, ptr, ptr, i32 } %1141, ptr %1142, 1
  %1144 = load ptr, ptr %259, align 8
  %1145 = insertvalue { ptr, ptr, ptr, i32 } %1143, ptr %1144, 2
  %1146 = load i32, ptr %167, align 4
  %1147 = insertvalue { ptr, ptr, ptr, i32 } %1145, i32 %1146, 3
  %hash_coef_ptr.i.i10.i3273 = getelementptr i8, ptr %1140, i64 8
  %tbl_size_ptr.i.i11.i3274 = getelementptr i8, ptr %1140, i64 16
  %offset_tbl_ptr.i.i12.i3275 = getelementptr i8, ptr %1140, i64 40
  %hash_coef.i.i13.i3276 = load i64, ptr %hash_coef_ptr.i.i10.i3273, align 4
  %tbl_size.i.i14.i3277 = load i64, ptr %tbl_size_ptr.i.i11.i3274, align 4
  %offset_tbl.i.i15.i3278 = load ptr, ptr %offset_tbl_ptr.i.i12.i3275, align 8
  %product.i.i.i16.i3279 = mul i64 %hash_coef.i.i13.i3276, -5261542750394134544
  %shifted.i.i.i17.i3280 = lshr i64 %product.i.i.i16.i3279, 32
  %xored.i.i.i18.i3281 = xor i64 %shifted.i.i.i17.i3280, %product.i.i.i16.i3279
  %hash.i.i.i19.i3282 = and i64 %xored.i.i.i18.i3281, %tbl_size.i.i14.i3277
  %offset_ptr.i.i20.i3283 = getelementptr i32, ptr %offset_tbl.i.i15.i3278, i64 %hash.i.i.i19.i3282
  %offset.i.i21.i3284 = load i32, ptr %offset_ptr.i.i20.i3283, align 4
  %eq.i.i3285 = icmp eq i32 %1146, %offset.i.i21.i3284
  call void @llvm.assume(i1 %eq.i.i3285) #30
  %1148 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1149 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1140)
  %1150 = sext i32 %1146 to i64
  %1151 = getelementptr ptr, ptr %1140, i64 %1150
  %1152 = getelementptr i8, ptr %1151, i64 64
  %1153 = load ptr, ptr %1152, align 8
  %1154 = call ptr %1153({ ptr, ptr, ptr, i32 } %1147, ptr nonnull %2)
  %1155 = call i32 %1154({ ptr, ptr, ptr, i32 } %1147, { ptr, ptr, ptr, i32 } %1147, ptr nonnull %2)
  %1156 = add i32 %1155, -1
  %1157 = and i32 %1156, %1135
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1158 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1159 = load ptr, ptr %165, align 8
  %1160 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1159, 0
  %1161 = load ptr, ptr %166, align 8
  %1162 = insertvalue { ptr, ptr, ptr, i32 } %1160, ptr %1161, 1
  %1163 = load ptr, ptr %259, align 8
  %1164 = insertvalue { ptr, ptr, ptr, i32 } %1162, ptr %1163, 2
  %1165 = load i32, ptr %167, align 4
  %1166 = insertvalue { ptr, ptr, ptr, i32 } %1164, i32 %1165, 3
  %hash_coef_ptr.i.i172.i2073 = getelementptr i8, ptr %1159, i64 8
  %tbl_size_ptr.i.i173.i2074 = getelementptr i8, ptr %1159, i64 16
  %offset_tbl_ptr.i.i174.i2075 = getelementptr i8, ptr %1159, i64 40
  %hash_coef.i.i175.i2076 = load i64, ptr %hash_coef_ptr.i.i172.i2073, align 4
  %tbl_size.i.i176.i2077 = load i64, ptr %tbl_size_ptr.i.i173.i2074, align 4
  %offset_tbl.i.i177.i2078 = load ptr, ptr %offset_tbl_ptr.i.i174.i2075, align 8
  %product.i.i.i178.i2079 = mul i64 %hash_coef.i.i175.i2076, -5261542750394134544
  %shifted.i.i.i179.i2080 = lshr i64 %product.i.i.i178.i2079, 32
  %xored.i.i.i180.i2081 = xor i64 %shifted.i.i.i179.i2080, %product.i.i.i178.i2079
  %hash.i.i.i181.i2082 = and i64 %xored.i.i.i180.i2081, %tbl_size.i.i176.i2077
  %offset_ptr.i.i182.i2083 = getelementptr i32, ptr %offset_tbl.i.i177.i2078, i64 %hash.i.i.i181.i2082
  %offset.i.i183.i2084 = load i32, ptr %offset_ptr.i.i182.i2083, align 4
  %eq.i.i2085 = icmp eq i32 %1165, %offset.i.i183.i2084
  call void @llvm.assume(i1 %eq.i.i2085) #30
  store ptr @_parameterization_Ptri32, ptr %31, align 8
  %1167 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %31)
  %1168 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1159)
  %1169 = sext i32 %1165 to i64
  %1170 = getelementptr ptr, ptr %1159, i64 %1169
  %1171 = getelementptr i8, ptr %1170, i64 120
  %1172 = load ptr, ptr %1171, align 8
  store ptr @i32_typ, ptr %32, align 8
  %1173 = call ptr %1172({ ptr, ptr, ptr, i32 } %1166, ptr nonnull %32)
  %1174 = call { ptr, i160 } %1173({ ptr, ptr, ptr, i32 } %1166, { ptr, ptr, ptr, i32 } %1166, ptr nonnull %31, i32 %1157)
  %.fca.0.extract112.i2086 = extractvalue { ptr, i160 } %1174, 0
  %1175 = ptrtoint ptr %.sroa.speculated352.i20552813 to i64
  %1176 = ptrtoint ptr %.sroa.speculated346.i20562815 to i64
  %.sroa.3111.0.insert.ext.i2087 = zext i32 %offset.i.i260.i20682817 to i160
  %.sroa.3111.0.insert.shift.i2088 = shl nuw i160 %.sroa.3111.0.insert.ext.i2087, 128
  %.sroa.2110.0.insert.ext.i2089 = zext i64 %1176 to i160
  %.sroa.2110.0.insert.shift.i2090 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i2089, 64
  %.sroa.2110.0.insert.insert.i2091 = or disjoint i160 %.sroa.2110.0.insert.shift.i2090, %.sroa.3111.0.insert.shift.i2088
  %.sroa.0109.0.insert.ext.i2092 = zext i64 %1175 to i160
  %.sroa.0109.0.insert.insert.i2093 = or disjoint i160 %.sroa.2110.0.insert.insert.i2091, %.sroa.0109.0.insert.ext.i2092
  %1177 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i2093, 1
  %1178 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1179 = load ptr, ptr %165, align 8
  %1180 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1179, 0
  %1181 = load ptr, ptr %166, align 8
  %1182 = insertvalue { ptr, ptr, ptr, i32 } %1180, ptr %1181, 1
  %1183 = load ptr, ptr %259, align 8
  %1184 = insertvalue { ptr, ptr, ptr, i32 } %1182, ptr %1183, 2
  %1185 = load i32, ptr %167, align 4
  %1186 = insertvalue { ptr, ptr, ptr, i32 } %1184, i32 %1185, 3
  %hash_coef_ptr.i.i186.i2098 = getelementptr i8, ptr %1179, i64 8
  %tbl_size_ptr.i.i187.i2099 = getelementptr i8, ptr %1179, i64 16
  %offset_tbl_ptr.i.i188.i2100 = getelementptr i8, ptr %1179, i64 40
  %hash_coef.i.i189.i2101 = load i64, ptr %hash_coef_ptr.i.i186.i2098, align 4
  %tbl_size.i.i190.i2102 = load i64, ptr %tbl_size_ptr.i.i187.i2099, align 4
  %offset_tbl.i.i191.i2103 = load ptr, ptr %offset_tbl_ptr.i.i188.i2100, align 8
  %product.i.i.i192.i2104 = mul i64 %hash_coef.i.i189.i2101, -5261542750394134544
  %shifted.i.i.i193.i2105 = lshr i64 %product.i.i.i192.i2104, 32
  %xored.i.i.i194.i2106 = xor i64 %shifted.i.i.i193.i2105, %product.i.i.i192.i2104
  %hash.i.i.i195.i2107 = and i64 %xored.i.i.i194.i2106, %tbl_size.i.i190.i2102
  %offset_ptr.i.i196.i2108 = getelementptr i32, ptr %offset_tbl.i.i191.i2103, i64 %hash.i.i.i195.i2107
  %offset.i.i197.i2109 = load i32, ptr %offset_ptr.i.i196.i2108, align 4
  %eq.i200.i2110 = icmp eq i32 %1185, %offset.i.i197.i2109
  call void @llvm.assume(i1 %eq.i200.i2110) #30
  %1187 = load ptr, ptr %result.i, align 8
  %1188 = load ptr, ptr %148, align 8
  %result.i.i2111 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1189 = getelementptr i8, ptr %result.i.i2111, i64 16
  store ptr %1188, ptr %1189, align 8
  %1190 = getelementptr i8, ptr %result.i.i2111, i64 8
  store ptr %1187, ptr %1190, align 8
  %1191 = getelementptr i8, ptr %result.i.i2111, i64 24
  store ptr null, ptr %1191, align 8
  %1192 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i2111)
  store ptr @Entry, ptr %result.i.i2111, align 8
  store ptr @_parameterization_Ptri32, ptr %33, align 8
  store ptr %result.i.i2111, ptr %308, align 8
  %1193 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %33)
  %1194 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1179)
  %1195 = sext i32 %1185 to i64
  %1196 = getelementptr ptr, ptr %1179, i64 %1195
  %1197 = getelementptr i8, ptr %1196, i64 128
  %1198 = load ptr, ptr %1197, align 8
  store ptr @i32_typ, ptr %34, align 8
  store ptr @Entry, ptr %309, align 8
  %1199 = call ptr %1198({ ptr, ptr, ptr, i32 } %1186, ptr nonnull %34)
  call void %1199({ ptr, ptr, ptr, i32 } %1186, { ptr, ptr, ptr, i32 } %1186, ptr nonnull %33, i32 %1157, { ptr, i160 } %1177)
  %1200 = icmp ne ptr %.fca.0.extract112.i2086, @nil_typ
  %1201 = icmp ne ptr %.fca.0.extract112.i2086, null
  %.not140.i2112 = and i1 %1200, %1201
  br i1 %.not140.i2112, label %.cont.cont.i2053, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2795

1202:                                             ; preds = %1128
  %1203 = add i32 %1135, 2127912214
  %1204 = shl i32 %1135, 12
  %1205 = add i32 %1203, %1204
  %1206 = ashr i32 %1205, 19
  %1207 = xor i32 %1205, %1206
  %1208 = xor i32 %1207, -949894596
  %1209 = add i32 %1208, 374761393
  %1210 = shl i32 %1208, 5
  %1211 = add i32 %1209, %1210
  %1212 = add i32 %1211, -744332180
  %1213 = shl i32 %1211, 9
  %1214 = xor i32 %1212, %1213
  %1215 = add i32 %1214, -42973499
  %1216 = shl i32 %1214, 3
  %1217 = add i32 %1215, %1216
  %1218 = ashr i32 %1217, 16
  %1219 = xor i32 %1217, %1218
  %1220 = xor i32 %1219, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1221 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1222 = load ptr, ptr %178, align 8
  %1223 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1222, 0
  %1224 = load ptr, ptr %179, align 8
  %1225 = insertvalue { ptr, ptr, ptr, i32 } %1223, ptr %1224, 1
  %1226 = load ptr, ptr %260, align 8
  %1227 = insertvalue { ptr, ptr, ptr, i32 } %1225, ptr %1226, 2
  %1228 = load i32, ptr %180, align 4
  %1229 = insertvalue { ptr, ptr, ptr, i32 } %1227, i32 %1228, 3
  %hash_coef_ptr.i.i10.i3303 = getelementptr i8, ptr %1222, i64 8
  %tbl_size_ptr.i.i11.i3304 = getelementptr i8, ptr %1222, i64 16
  %offset_tbl_ptr.i.i12.i3305 = getelementptr i8, ptr %1222, i64 40
  %hash_coef.i.i13.i3306 = load i64, ptr %hash_coef_ptr.i.i10.i3303, align 4
  %tbl_size.i.i14.i3307 = load i64, ptr %tbl_size_ptr.i.i11.i3304, align 4
  %offset_tbl.i.i15.i3308 = load ptr, ptr %offset_tbl_ptr.i.i12.i3305, align 8
  %product.i.i.i16.i3309 = mul i64 %hash_coef.i.i13.i3306, -5261542750394134544
  %shifted.i.i.i17.i3310 = lshr i64 %product.i.i.i16.i3309, 32
  %xored.i.i.i18.i3311 = xor i64 %shifted.i.i.i17.i3310, %product.i.i.i16.i3309
  %hash.i.i.i19.i3312 = and i64 %xored.i.i.i18.i3311, %tbl_size.i.i14.i3307
  %offset_ptr.i.i20.i3313 = getelementptr i32, ptr %offset_tbl.i.i15.i3308, i64 %hash.i.i.i19.i3312
  %offset.i.i21.i3314 = load i32, ptr %offset_ptr.i.i20.i3313, align 4
  %eq.i.i3315 = icmp eq i32 %1228, %offset.i.i21.i3314
  call void @llvm.assume(i1 %eq.i.i3315) #30
  %1230 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1231 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1222)
  %1232 = sext i32 %1228 to i64
  %1233 = getelementptr ptr, ptr %1222, i64 %1232
  %1234 = getelementptr i8, ptr %1233, i64 64
  %1235 = load ptr, ptr %1234, align 8
  %1236 = call ptr %1235({ ptr, ptr, ptr, i32 } %1229, ptr nonnull %2)
  %1237 = call i32 %1236({ ptr, ptr, ptr, i32 } %1229, { ptr, ptr, ptr, i32 } %1229, ptr nonnull %2)
  %1238 = add i32 %1237, -1
  %1239 = and i32 %1238, %1220
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1240 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1241 = load ptr, ptr %178, align 8
  %1242 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1241, 0
  %1243 = load ptr, ptr %179, align 8
  %1244 = insertvalue { ptr, ptr, ptr, i32 } %1242, ptr %1243, 1
  %1245 = load ptr, ptr %260, align 8
  %1246 = insertvalue { ptr, ptr, ptr, i32 } %1244, ptr %1245, 2
  %1247 = load i32, ptr %180, align 4
  %1248 = insertvalue { ptr, ptr, ptr, i32 } %1246, i32 %1247, 3
  %hash_coef_ptr.i.i202.i2009 = getelementptr i8, ptr %1241, i64 8
  %tbl_size_ptr.i.i203.i2010 = getelementptr i8, ptr %1241, i64 16
  %offset_tbl_ptr.i.i204.i2011 = getelementptr i8, ptr %1241, i64 40
  %hash_coef.i.i205.i2012 = load i64, ptr %hash_coef_ptr.i.i202.i2009, align 4
  %tbl_size.i.i206.i2013 = load i64, ptr %tbl_size_ptr.i.i203.i2010, align 4
  %offset_tbl.i.i207.i2014 = load ptr, ptr %offset_tbl_ptr.i.i204.i2011, align 8
  %product.i.i.i208.i2015 = mul i64 %hash_coef.i.i205.i2012, -5261542750394134544
  %shifted.i.i.i209.i2016 = lshr i64 %product.i.i.i208.i2015, 32
  %xored.i.i.i210.i2017 = xor i64 %shifted.i.i.i209.i2016, %product.i.i.i208.i2015
  %hash.i.i.i211.i2018 = and i64 %xored.i.i.i210.i2017, %tbl_size.i.i206.i2013
  %offset_ptr.i.i212.i2019 = getelementptr i32, ptr %offset_tbl.i.i207.i2014, i64 %hash.i.i.i211.i2018
  %offset.i.i213.i2020 = load i32, ptr %offset_ptr.i.i212.i2019, align 4
  %eq.i216.i2021 = icmp eq i32 %1247, %offset.i.i213.i2020
  call void @llvm.assume(i1 %eq.i216.i2021) #30
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %1249 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %39)
  %1250 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1241)
  %1251 = sext i32 %1247 to i64
  %1252 = getelementptr ptr, ptr %1241, i64 %1251
  %1253 = getelementptr i8, ptr %1252, i64 120
  %1254 = load ptr, ptr %1253, align 8
  store ptr @i32_typ, ptr %40, align 8
  %1255 = call ptr %1254({ ptr, ptr, ptr, i32 } %1248, ptr nonnull %40)
  %1256 = call { ptr, i160 } %1255({ ptr, ptr, ptr, i32 } %1248, { ptr, ptr, ptr, i32 } %1248, ptr nonnull %39, i32 %1239)
  %.fca.0.extract87.i2022 = extractvalue { ptr, i160 } %1256, 0
  %1257 = ptrtoint ptr %.sroa.speculated352.i20552813 to i64
  %1258 = ptrtoint ptr %.sroa.speculated346.i20562815 to i64
  %.sroa.3.0.insert.ext.i2023 = zext i32 %offset.i.i260.i20682817 to i160
  %.sroa.3.0.insert.shift.i2024 = shl nuw i160 %.sroa.3.0.insert.ext.i2023, 128
  %.sroa.2.0.insert.ext.i2025 = zext i64 %1258 to i160
  %.sroa.2.0.insert.shift.i2026 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i2025, 64
  %.sroa.2.0.insert.insert.i2027 = or disjoint i160 %.sroa.2.0.insert.shift.i2026, %.sroa.3.0.insert.shift.i2024
  %.sroa.0.0.insert.ext.i2028 = zext i64 %1257 to i160
  %.sroa.0.0.insert.insert.i2029 = or disjoint i160 %.sroa.2.0.insert.insert.i2027, %.sroa.0.0.insert.ext.i2028
  %1259 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i2029, 1
  %1260 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1261 = load ptr, ptr %178, align 8
  %1262 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1261, 0
  %1263 = load ptr, ptr %179, align 8
  %1264 = insertvalue { ptr, ptr, ptr, i32 } %1262, ptr %1263, 1
  %1265 = load ptr, ptr %260, align 8
  %1266 = insertvalue { ptr, ptr, ptr, i32 } %1264, ptr %1265, 2
  %1267 = load i32, ptr %180, align 4
  %1268 = insertvalue { ptr, ptr, ptr, i32 } %1266, i32 %1267, 3
  %hash_coef_ptr.i.i218.i2034 = getelementptr i8, ptr %1261, i64 8
  %tbl_size_ptr.i.i219.i2035 = getelementptr i8, ptr %1261, i64 16
  %offset_tbl_ptr.i.i220.i2036 = getelementptr i8, ptr %1261, i64 40
  %hash_coef.i.i221.i2037 = load i64, ptr %hash_coef_ptr.i.i218.i2034, align 4
  %tbl_size.i.i222.i2038 = load i64, ptr %tbl_size_ptr.i.i219.i2035, align 4
  %offset_tbl.i.i223.i2039 = load ptr, ptr %offset_tbl_ptr.i.i220.i2036, align 8
  %product.i.i.i224.i2040 = mul i64 %hash_coef.i.i221.i2037, -5261542750394134544
  %shifted.i.i.i225.i2041 = lshr i64 %product.i.i.i224.i2040, 32
  %xored.i.i.i226.i2042 = xor i64 %shifted.i.i.i225.i2041, %product.i.i.i224.i2040
  %hash.i.i.i227.i2043 = and i64 %xored.i.i.i226.i2042, %tbl_size.i.i222.i2038
  %offset_ptr.i.i228.i2044 = getelementptr i32, ptr %offset_tbl.i.i223.i2039, i64 %hash.i.i.i227.i2043
  %offset.i.i229.i2045 = load i32, ptr %offset_ptr.i.i228.i2044, align 4
  %eq.i232.i2046 = icmp eq i32 %1267, %offset.i.i229.i2045
  call void @llvm.assume(i1 %eq.i232.i2046) #30
  %1269 = load ptr, ptr %result.i, align 8
  %1270 = load ptr, ptr %148, align 8
  %result.i233.i2047 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1271 = getelementptr i8, ptr %result.i233.i2047, i64 16
  store ptr %1270, ptr %1271, align 8
  %1272 = getelementptr i8, ptr %result.i233.i2047, i64 8
  store ptr %1269, ptr %1272, align 8
  %1273 = getelementptr i8, ptr %result.i233.i2047, i64 24
  store ptr null, ptr %1273, align 8
  %1274 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i2047)
  store ptr @Entry, ptr %result.i233.i2047, align 8
  store ptr @_parameterization_Ptri32, ptr %41, align 8
  store ptr %result.i233.i2047, ptr %306, align 8
  %1275 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %41)
  %1276 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1261)
  %1277 = sext i32 %1267 to i64
  %1278 = getelementptr ptr, ptr %1261, i64 %1277
  %1279 = getelementptr i8, ptr %1278, i64 128
  %1280 = load ptr, ptr %1279, align 8
  store ptr @i32_typ, ptr %42, align 8
  store ptr @Entry, ptr %307, align 8
  %1281 = call ptr %1280({ ptr, ptr, ptr, i32 } %1268, ptr nonnull %42)
  call void %1281({ ptr, ptr, ptr, i32 } %1268, { ptr, ptr, ptr, i32 } %1268, ptr nonnull %41, i32 %1239, { ptr, i160 } %1259)
  %1282 = icmp ne ptr %.fca.0.extract87.i2022, @nil_typ
  %1283 = icmp ne ptr %.fca.0.extract87.i2022, null
  %.not138.i2048 = and i1 %1282, %1283
  br i1 %.not138.i2048, label %.cont.cont.i2053, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2795

.cont.cont.i2053:                                 ; preds = %1202, %1138
  %.sink2841 = phi { ptr, i160 } [ %1174, %1138 ], [ %1256, %1202 ]
  %1284 = phi i32 [ 2, %1138 ], [ 1, %1202 ]
  %vptr.i248.sroa.speculated.i2054 = phi ptr [ %.fca.0.extract112.i2086, %1138 ], [ %.fca.0.extract87.i2022, %1202 ]
  %.fca.1.extract89.i2049 = extractvalue { ptr, i160 } %.sink2841, 1
  %.sroa.3407.sroa.4.0.extract.shift.i2050 = lshr i160 %.fca.1.extract89.i2049, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i2051 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i2050 to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i2052 = trunc i160 %.fca.1.extract89.i2049 to i64
  %.sroa.speculated352.i2055 = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i2052 to ptr
  %.sroa.speculated346.i2056 = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i2051 to ptr
  %hash_coef_ptr.i.i249.i2057 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2054, i64 8
  %tbl_size_ptr.i.i250.i2058 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2054, i64 16
  %offset_tbl_ptr.i.i251.i2059 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2054, i64 40
  %hash_coef.i.i252.i2060 = load i64, ptr %hash_coef_ptr.i.i249.i2057, align 4
  %tbl_size.i.i253.i2061 = load i64, ptr %tbl_size_ptr.i.i250.i2058, align 4
  %offset_tbl.i.i254.i2062 = load ptr, ptr %offset_tbl_ptr.i.i251.i2059, align 8
  %product.i.i.i255.i2063 = mul i64 %hash_coef.i.i252.i2060, 4015701072841558310
  %shifted.i.i.i256.i2064 = lshr i64 %product.i.i.i255.i2063, 32
  %xored.i.i.i257.i2065 = xor i64 %shifted.i.i.i256.i2064, %product.i.i.i255.i2063
  %hash.i.i.i258.i2066 = and i64 %xored.i.i.i257.i2065, %tbl_size.i.i253.i2061
  %offset_ptr.i.i259.i2067 = getelementptr i32, ptr %offset_tbl.i.i254.i2062, i64 %hash.i.i.i258.i2066
  %offset.i.i260.i2068 = load i32, ptr %offset_ptr.i.i259.i2067, align 4
  store ptr %vptr.i248.sroa.speculated.i2054, ptr %47, align 8
  store ptr %.sroa.speculated352.i2055, ptr %303, align 8
  store ptr %.sroa.speculated346.i2056, ptr %304, align 8
  store i32 %offset.i.i260.i2068, ptr %305, align 8
  %1285 = add nuw nsw i32 %.reg2mem193.0677.i2008, 1
  %1286 = load i32, ptr %181, align 4
  %1287 = icmp slt i32 %1285, %1286
  br i1 %1287, label %1128, label %._crit_edge1.i711

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2795: ; preds = %1138, %1202
  %1288 = phi ptr [ %43, %1202 ], [ %35, %1138 ]
  %1289 = phi ptr [ %44, %1202 ], [ %36, %1138 ]
  %1290 = phi ptr [ %45, %1202 ], [ %37, %1138 ]
  %1291 = phi ptr [ %.sroa.0.i1976, %1202 ], [ %.sroa.0680.i1975, %1138 ]
  %1292 = phi ptr [ %46, %1202 ], [ %38, %1138 ]
  %1293 = load i32, ptr %261, align 4
  store i32 %1293, ptr %1288, align 4
  store i32 1, ptr %1289, align 4
  %1294 = add i32 %1293, 1
  store i32 %1294, ptr %1290, align 4
  %1295 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1294, ptr %261, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1292, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1291, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1975)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1976)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  br label %HashMap_insert_keyK_valueV.exit800

._crit_edge1.i711:                                ; preds = %.cont.cont.i2053, %._crit_edge.i705
  %1296 = load i160, ptr %303, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %32)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %34)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %35)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %36)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1975)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %40)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %41)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %42)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %43)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %44)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1976)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %46)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %47)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %30)
  %1297 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1298 = load ptr, ptr %165, align 8
  %1299 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1298, 0
  %1300 = load ptr, ptr %166, align 8
  %1301 = insertvalue { ptr, ptr, ptr, i32 } %1299, ptr %1300, 1
  %1302 = load ptr, ptr %259, align 8
  %1303 = insertvalue { ptr, ptr, ptr, i32 } %1301, ptr %1302, 2
  %1304 = load i32, ptr %167, align 4
  %1305 = insertvalue { ptr, ptr, ptr, i32 } %1303, i32 %1304, 3
  %hash_coef_ptr.i.i64.i2132 = getelementptr i8, ptr %1298, i64 8
  %tbl_size_ptr.i.i65.i2133 = getelementptr i8, ptr %1298, i64 16
  %offset_tbl_ptr.i.i66.i2134 = getelementptr i8, ptr %1298, i64 40
  %hash_coef.i.i67.i2135 = load i64, ptr %hash_coef_ptr.i.i64.i2132, align 4
  %tbl_size.i.i68.i2136 = load i64, ptr %tbl_size_ptr.i.i65.i2133, align 4
  %offset_tbl.i.i69.i2137 = load ptr, ptr %offset_tbl_ptr.i.i66.i2134, align 8
  %product.i.i.i70.i2138 = mul i64 %hash_coef.i.i67.i2135, -5261542750394134544
  %shifted.i.i.i71.i2139 = lshr i64 %product.i.i.i70.i2138, 32
  %xored.i.i.i72.i2140 = xor i64 %shifted.i.i.i71.i2139, %product.i.i.i70.i2138
  %hash.i.i.i73.i2141 = and i64 %xored.i.i.i72.i2140, %tbl_size.i.i68.i2136
  %offset_ptr.i.i74.i2142 = getelementptr i32, ptr %offset_tbl.i.i69.i2137, i64 %hash.i.i.i73.i2141
  %offset.i.i75.i2143 = load i32, ptr %offset_ptr.i.i74.i2142, align 4
  %eq.i.i2144 = icmp eq i32 %1304, %offset.i.i75.i2143
  call void @llvm.assume(i1 %eq.i.i2144) #30
  %1306 = load ptr, ptr %178, align 8
  %1307 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1306, 0
  %1308 = load ptr, ptr %179, align 8
  %1309 = insertvalue { ptr, ptr, ptr, i32 } %1307, ptr %1308, 1
  %1310 = load ptr, ptr %260, align 8
  %1311 = insertvalue { ptr, ptr, ptr, i32 } %1309, ptr %1310, 2
  %1312 = load i32, ptr %180, align 4
  %1313 = insertvalue { ptr, ptr, ptr, i32 } %1311, i32 %1312, 3
  %hash_coef_ptr.i.i92.i2149 = getelementptr i8, ptr %1306, i64 8
  %tbl_size_ptr.i.i93.i2150 = getelementptr i8, ptr %1306, i64 16
  %offset_tbl_ptr.i.i94.i2151 = getelementptr i8, ptr %1306, i64 40
  %hash_coef.i.i95.i2152 = load i64, ptr %hash_coef_ptr.i.i92.i2149, align 4
  %tbl_size.i.i96.i2153 = load i64, ptr %tbl_size_ptr.i.i93.i2150, align 4
  %offset_tbl.i.i97.i2154 = load ptr, ptr %offset_tbl_ptr.i.i94.i2151, align 8
  %product.i.i.i98.i2155 = mul i64 %hash_coef.i.i95.i2152, -5261542750394134544
  %shifted.i.i.i99.i2156 = lshr i64 %product.i.i.i98.i2155, 32
  %xored.i.i.i100.i2157 = xor i64 %shifted.i.i.i99.i2156, %product.i.i.i98.i2155
  %hash.i.i.i101.i2158 = and i64 %xored.i.i.i100.i2157, %tbl_size.i.i96.i2153
  %offset_ptr.i.i102.i2159 = getelementptr i32, ptr %offset_tbl.i.i97.i2154, i64 %hash.i.i.i101.i2158
  %offset.i.i103.i2160 = load i32, ptr %offset_ptr.i.i102.i2159, align 4
  %eq.i106.i2161 = icmp eq i32 %1312, %offset.i.i103.i2160
  call void @llvm.assume(i1 %eq.i106.i2161) #30
  %1314 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1315 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1298)
  %1316 = sext i32 %1304 to i64
  %1317 = getelementptr ptr, ptr %1298, i64 %1316
  %1318 = getelementptr i8, ptr %1317, i64 64
  %1319 = load ptr, ptr %1318, align 8
  %1320 = call ptr %1319({ ptr, ptr, ptr, i32 } %1305, ptr nonnull %2)
  %1321 = call i32 %1320({ ptr, ptr, ptr, i32 } %1305, { ptr, ptr, ptr, i32 } %1305, ptr nonnull %2)
  %1322 = shl i32 %1321, 1
  %1323 = load i32, ptr %261, align 4
  %1324 = load ptr, ptr %result.i, align 8
  %1325 = load ptr, ptr %148, align 8
  %1326 = sext i32 %1323 to i64
  %1327 = shl nsw i64 %1326, 5
  %result.i.i.i2164 = call noalias ptr @bump_malloc_inner(i64 noundef %1327, ptr nonnull @current_ptr) #29
  %1328 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1329 = icmp sgt i32 %1321, 0
  br i1 %1329, label %.lr.ph434.i2234, label %._crit_edge395.i2178

.lr.ph434.i2234:                                  ; preds = %._crit_edge1.i711
  %invariant.gep.i2177 = getelementptr i8, ptr %1298, i64 120
  %1330 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i2237 = getelementptr ptr, ptr %invariant.gep.i2177, i64 %1316
  br label %1331

1331:                                             ; preds = %1353, %.lr.ph434.i2234
  %.reg2mem105.0432.i2235 = phi i32 [ 0, %.lr.ph434.i2234 ], [ %.reg2mem101.0.i2240, %1353 ]
  %.reg2mem103.0431.i2236 = phi i32 [ 0, %.lr.ph434.i2234 ], [ %1354, %1353 ]
  store ptr @_parameterization_Ptri32, ptr %25, align 8
  %1332 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %25)
  %1333 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1298)
  %1334 = load ptr, ptr %gep.i2237, align 8
  store ptr @i32_typ, ptr %26, align 8
  %1335 = call ptr %1334({ ptr, ptr, ptr, i32 } %1305, ptr nonnull %26)
  %1336 = call { ptr, i160 } %1335({ ptr, ptr, ptr, i32 } %1305, { ptr, ptr, ptr, i32 } %1305, ptr nonnull %25, i32 %.reg2mem103.0431.i2236)
  %.fca.0.extract52.i2238 = extractvalue { ptr, i160 } %1336, 0
  %1337 = icmp ne ptr %.fca.0.extract52.i2238, @nil_typ
  %1338 = icmp ne ptr %.fca.0.extract52.i2238, null
  %.not60.i2239 = and i1 %1337, %1338
  br i1 %.not60.i2239, label %1339, label %1353

1339:                                             ; preds = %1331
  %hash_coef_ptr.i.i137.i2267 = getelementptr i8, ptr %.fca.0.extract52.i2238, i64 8
  %tbl_size_ptr.i.i138.i2268 = getelementptr i8, ptr %.fca.0.extract52.i2238, i64 16
  %offset_tbl_ptr.i.i139.i2269 = getelementptr i8, ptr %.fca.0.extract52.i2238, i64 40
  %hash_coef.i.i140.i2270 = load i64, ptr %hash_coef_ptr.i.i137.i2267, align 4
  %tbl_size.i.i141.i2271 = load i64, ptr %tbl_size_ptr.i.i138.i2268, align 4
  %offset_tbl.i.i142.i2272 = load ptr, ptr %offset_tbl_ptr.i.i139.i2269, align 8
  %product.i.i.i143.i2273 = mul i64 %hash_coef.i.i140.i2270, 4015701072841558310
  %shifted.i.i.i144.i2274 = lshr i64 %product.i.i.i143.i2273, 32
  %xored.i.i.i145.i2275 = xor i64 %shifted.i.i.i144.i2274, %product.i.i.i143.i2273
  %hash.i.i.i146.i2276 = and i64 %xored.i.i.i145.i2275, %tbl_size.i.i141.i2271
  %offset_ptr.i.i147.i2277 = getelementptr i32, ptr %offset_tbl.i.i142.i2272, i64 %hash.i.i.i146.i2276
  %offset.i.i148.i2278 = load i32, ptr %offset_ptr.i.i147.i2277, align 4
  %1340 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1341 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1342 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1343 = icmp slt i32 %.reg2mem105.0432.i2235, %1323
  br i1 %1343, label %1344, label %._crit_edge.i2279

1344:                                             ; preds = %1339
  %.fca.1.extract54.i2280 = extractvalue { ptr, i160 } %1336, 1
  %.sroa.351.0.insert.ext.i2281 = zext i32 %offset.i.i148.i2278 to i160
  %.sroa.351.0.insert.shift.i2282 = shl nuw i160 %.sroa.351.0.insert.ext.i2281, 128
  %1345 = and i160 %.fca.1.extract54.i2280, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2283 = or disjoint i160 %.sroa.351.0.insert.shift.i2282, %1345
  %1346 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1347 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1348 = sext i32 %.reg2mem105.0432.i2235 to i64
  %1349 = shl nsw i64 %1348, 5
  %1350 = getelementptr i8, ptr %result.i.i.i2164, i64 %1349
  store ptr %.fca.0.extract52.i2238, ptr %1350, align 8
  %1351 = getelementptr i8, ptr %1350, i64 8
  store i160 %.sroa.049.0.insert.insert.i2283, ptr %1351, align 4
  br label %._crit_edge.i2279

._crit_edge.i2279:                                ; preds = %1344, %1339
  %1352 = add i32 %.reg2mem105.0432.i2235, 1
  br label %1353

1353:                                             ; preds = %._crit_edge.i2279, %1331
  %.reg2mem101.0.i2240 = phi i32 [ %1352, %._crit_edge.i2279 ], [ %.reg2mem105.0432.i2235, %1331 ]
  %1354 = add nuw nsw i32 %.reg2mem103.0431.i2236, 1
  %1355 = icmp slt i32 %1354, %1321
  br i1 %1355, label %1331, label %.lr.ph.i2241

.lr.ph.i2241:                                     ; preds = %1353
  %invariant.gep396.i2242 = getelementptr i8, ptr %1306, i64 120
  %1356 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1357 = sext i32 %1312 to i64
  %gep397.i2245 = getelementptr ptr, ptr %invariant.gep396.i2242, i64 %1357
  br label %1358

1358:                                             ; preds = %1380, %.lr.ph.i2241
  %.reg2mem91.0394.i2243 = phi i32 [ %.reg2mem101.0.i2240, %.lr.ph.i2241 ], [ %.reg2mem87.0.i2248, %1380 ]
  %.reg2mem89.0393.i2244 = phi i32 [ 0, %.lr.ph.i2241 ], [ %1381, %1380 ]
  store ptr @_parameterization_Ptri32, ptr %27, align 8
  %1359 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %27)
  %1360 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1306)
  %1361 = load ptr, ptr %gep397.i2245, align 8
  store ptr @i32_typ, ptr %28, align 8
  %1362 = call ptr %1361({ ptr, ptr, ptr, i32 } %1313, ptr nonnull %28)
  %1363 = call { ptr, i160 } %1362({ ptr, ptr, ptr, i32 } %1313, { ptr, ptr, ptr, i32 } %1313, ptr nonnull %27, i32 %.reg2mem89.0393.i2244)
  %.fca.0.extract42.i2246 = extractvalue { ptr, i160 } %1363, 0
  %1364 = icmp ne ptr %.fca.0.extract42.i2246, @nil_typ
  %1365 = icmp ne ptr %.fca.0.extract42.i2246, null
  %.not62.i2247 = and i1 %1364, %1365
  br i1 %.not62.i2247, label %1366, label %1380

1366:                                             ; preds = %1358
  %hash_coef_ptr.i.i152.i2249 = getelementptr i8, ptr %.fca.0.extract42.i2246, i64 8
  %tbl_size_ptr.i.i153.i2250 = getelementptr i8, ptr %.fca.0.extract42.i2246, i64 16
  %offset_tbl_ptr.i.i154.i2251 = getelementptr i8, ptr %.fca.0.extract42.i2246, i64 40
  %hash_coef.i.i155.i2252 = load i64, ptr %hash_coef_ptr.i.i152.i2249, align 4
  %tbl_size.i.i156.i2253 = load i64, ptr %tbl_size_ptr.i.i153.i2250, align 4
  %offset_tbl.i.i157.i2254 = load ptr, ptr %offset_tbl_ptr.i.i154.i2251, align 8
  %product.i.i.i158.i2255 = mul i64 %hash_coef.i.i155.i2252, 4015701072841558310
  %shifted.i.i.i159.i2256 = lshr i64 %product.i.i.i158.i2255, 32
  %xored.i.i.i160.i2257 = xor i64 %shifted.i.i.i159.i2256, %product.i.i.i158.i2255
  %hash.i.i.i161.i2258 = and i64 %xored.i.i.i160.i2257, %tbl_size.i.i156.i2253
  %offset_ptr.i.i162.i2259 = getelementptr i32, ptr %offset_tbl.i.i157.i2254, i64 %hash.i.i.i161.i2258
  %offset.i.i163.i2260 = load i32, ptr %offset_ptr.i.i162.i2259, align 4
  %1367 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1368 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1369 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1370 = icmp slt i32 %.reg2mem91.0394.i2243, %1323
  br i1 %1370, label %1371, label %._crit_edge1.i2261

1371:                                             ; preds = %1366
  %.fca.1.extract44.i2262 = extractvalue { ptr, i160 } %1363, 1
  %.sroa.3.0.insert.ext.i2263 = zext i32 %offset.i.i163.i2260 to i160
  %.sroa.3.0.insert.shift.i2264 = shl nuw i160 %.sroa.3.0.insert.ext.i2263, 128
  %1372 = and i160 %.fca.1.extract44.i2262, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2265 = or disjoint i160 %.sroa.3.0.insert.shift.i2264, %1372
  %1373 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1374 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1375 = sext i32 %.reg2mem91.0394.i2243 to i64
  %1376 = shl nsw i64 %1375, 5
  %1377 = getelementptr i8, ptr %result.i.i.i2164, i64 %1376
  store ptr %.fca.0.extract42.i2246, ptr %1377, align 8
  %1378 = getelementptr i8, ptr %1377, i64 8
  store i160 %.sroa.040.0.insert.insert.i2265, ptr %1378, align 4
  br label %._crit_edge1.i2261

._crit_edge1.i2261:                               ; preds = %1371, %1366
  %1379 = add i32 %.reg2mem91.0394.i2243, 1
  br label %1380

1380:                                             ; preds = %._crit_edge1.i2261, %1358
  %.reg2mem87.0.i2248 = phi i32 [ %1379, %._crit_edge1.i2261 ], [ %.reg2mem91.0394.i2243, %1358 ]
  %1381 = add nuw nsw i32 %.reg2mem89.0393.i2244, 1
  %1382 = icmp slt i32 %1381, %1321
  br i1 %1382, label %1358, label %._crit_edge395.i2178.loopexit

._crit_edge395.i2178.loopexit:                    ; preds = %1380
  %.pre3195 = load ptr, ptr %result.i, align 8
  %.pre3196 = load ptr, ptr %148, align 8
  br label %._crit_edge395.i2178

._crit_edge395.i2178:                             ; preds = %._crit_edge395.i2178.loopexit, %._crit_edge1.i711
  %1383 = phi ptr [ %1325, %._crit_edge1.i711 ], [ %.pre3196, %._crit_edge395.i2178.loopexit ]
  %1384 = phi ptr [ %1324, %._crit_edge1.i711 ], [ %.pre3195, %._crit_edge395.i2178.loopexit ]
  %.reg2mem91.0.lcssa.i2179 = phi i32 [ 0, %._crit_edge1.i711 ], [ %.reg2mem87.0.i2248, %._crit_edge395.i2178.loopexit ]
  %1385 = call i32 @llvm.smax.i32(i32 %1322, i32 16)
  %result.i166.i2180 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1386 = getelementptr i8, ptr %result.i166.i2180, i64 16
  store ptr @_parameterization_Nil, ptr %1386, align 8
  %result.i167.i2181 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1387 = getelementptr i8, ptr %result.i167.i2181, i64 16
  store ptr %1383, ptr %1387, align 8
  %1388 = getelementptr i8, ptr %result.i167.i2181, i64 8
  store ptr %1384, ptr %1388, align 8
  %1389 = getelementptr i8, ptr %result.i167.i2181, i64 24
  store ptr null, ptr %1389, align 8
  %1390 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i2181)
  store ptr @Entry, ptr %result.i167.i2181, align 8
  %1391 = getelementptr i8, ptr %result.i166.i2180, i64 8
  store ptr %result.i167.i2181, ptr %1391, align 8
  %1392 = getelementptr i8, ptr %result.i166.i2180, i64 24
  store ptr null, ptr %1392, align 8
  %1393 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i2180)
  store ptr @union_typ, ptr %result.i166.i2180, align 8
  %result.i168.i2182 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i2180, ptr %result.i168.i2182, align 8
  %1394 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i2182)
  store ptr @Array, ptr %29, align 8
  store ptr %result.i168.i2182, ptr %310, align 8
  store i32 9, ptr %311, align 8
  %1395 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %29)
  %1396 = getelementptr i8, ptr %result.i168.i2182, i64 16
  store i32 %1385, ptr %1396, align 4
  %1397 = getelementptr i8, ptr %result.i168.i2182, i64 20
  store i32 %1385, ptr %1397, align 4
  %1398 = zext nneg i32 %1385 to i64
  %1399 = shl nuw nsw i64 %1398, 5
  %result.i.i416.i2183 = call noalias ptr @bump_malloc_inner(i64 noundef %1399, ptr nonnull @current_ptr) #29
  %1400 = getelementptr i8, ptr %result.i168.i2182, i64 8
  store ptr %result.i.i416.i2183, ptr %1400, align 8
  %1401 = load ptr, ptr %312, align 8
  store ptr @Array, ptr %165, align 8
  store ptr %result.i168.i2182, ptr %166, align 8
  store ptr %1401, ptr %259, align 8
  store i32 9, ptr %167, align 4
  %1402 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i2196 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1403 = getelementptr i8, ptr %result.i183.i2196, i64 16
  store ptr @_parameterization_Nil, ptr %1403, align 8
  %result.i184.i2197 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1404 = getelementptr i8, ptr %result.i184.i2197, i64 16
  store ptr %1383, ptr %1404, align 8
  %1405 = getelementptr i8, ptr %result.i184.i2197, i64 8
  store ptr %1384, ptr %1405, align 8
  %1406 = getelementptr i8, ptr %result.i184.i2197, i64 24
  store ptr null, ptr %1406, align 8
  %1407 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i2197)
  store ptr @Entry, ptr %result.i184.i2197, align 8
  %1408 = getelementptr i8, ptr %result.i183.i2196, i64 8
  store ptr %result.i184.i2197, ptr %1408, align 8
  %1409 = getelementptr i8, ptr %result.i183.i2196, i64 24
  store ptr null, ptr %1409, align 8
  %1410 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i2196)
  store ptr @union_typ, ptr %result.i183.i2196, align 8
  %result.i185.i2198 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i2196, ptr %result.i185.i2198, align 8
  %1411 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i2198)
  store ptr @Array, ptr %30, align 8
  store ptr %result.i185.i2198, ptr %313, align 8
  store i32 9, ptr %314, align 8
  %1412 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %30)
  %1413 = getelementptr i8, ptr %result.i185.i2198, i64 16
  store i32 %1385, ptr %1413, align 4
  %1414 = getelementptr i8, ptr %result.i185.i2198, i64 20
  store i32 %1385, ptr %1414, align 4
  %result.i.i430.i2199 = call noalias ptr @bump_malloc_inner(i64 noundef %1399, ptr nonnull @current_ptr) #29
  %1415 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1416 = getelementptr i8, ptr %result.i185.i2198, i64 8
  store ptr %result.i.i430.i2199, ptr %1416, align 8
  %1417 = load ptr, ptr %315, align 8
  store ptr @Array, ptr %178, align 8
  store ptr %result.i185.i2198, ptr %179, align 8
  store ptr %1417, ptr %260, align 8
  store i32 9, ptr %180, align 4
  store i32 0, ptr %261, align 4
  %1418 = icmp sgt i32 %.reg2mem91.0.lcssa.i2179, 0
  br i1 %1418, label %.lr.ph400.i2212, label %HashMap_resize_.exit2285

.lr.ph400.i2212:                                  ; preds = %._crit_edge395.i2178
  %1419 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1420 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1421 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i2214

._crit_edge2.i2214:                               ; preds = %._crit_edge2.i2214, %.lr.ph400.i2212
  %.reg2mem77.0398.i2215 = phi i32 [ 0, %.lr.ph400.i2212 ], [ %1435, %._crit_edge2.i2214 ]
  %1422 = zext nneg i32 %.reg2mem77.0398.i2215 to i64
  %1423 = shl nuw nsw i64 %1422, 5
  %1424 = getelementptr i8, ptr %result.i.i.i2164, i64 %1423
  %1425 = load ptr, ptr %1424, align 8
  %1426 = getelementptr i8, ptr %1424, i64 8
  %1427 = load i160, ptr %1426, align 4
  %.sroa.3362.8.extract.trunc.i2218 = trunc i160 %1427 to i64
  %1428 = inttoptr i64 %.sroa.3362.8.extract.trunc.i2218 to ptr
  %.sroa.5363.8.extract.shift.i2219 = lshr i160 %1427, 64
  %.sroa.5363.8.extract.trunc.i2220 = trunc i160 %.sroa.5363.8.extract.shift.i2219 to i64
  %1429 = inttoptr i64 %.sroa.5363.8.extract.trunc.i2220 to ptr
  %hash_coef_ptr.i.i201.i2221 = getelementptr i8, ptr %1425, i64 8
  %tbl_size_ptr.i.i202.i2222 = getelementptr i8, ptr %1425, i64 16
  %offset_tbl_ptr.i.i203.i2223 = getelementptr i8, ptr %1425, i64 40
  %hash_coef.i.i232.i2224 = load i64, ptr %hash_coef_ptr.i.i201.i2221, align 4
  %tbl_size.i.i233.i2225 = load i64, ptr %tbl_size_ptr.i.i202.i2222, align 4
  %offset_tbl.i.i234.i2226 = load ptr, ptr %offset_tbl_ptr.i.i203.i2223, align 8
  %product.i.i.i235.i2227 = mul i64 %hash_coef.i.i232.i2224, 4015701072841558310
  %shifted.i.i.i236.i2228 = lshr i64 %product.i.i.i235.i2227, 32
  %xored.i.i.i237.i2229 = xor i64 %shifted.i.i.i236.i2228, %product.i.i.i235.i2227
  %hash.i.i.i238.i2230 = and i64 %xored.i.i.i237.i2229, %tbl_size.i.i233.i2225
  %offset_ptr.i.i239.i2231 = getelementptr i32, ptr %offset_tbl.i.i234.i2226, i64 %hash.i.i.i238.i2230
  %offset.i.i240.i2232 = load i32, ptr %offset_ptr.i.i239.i2231, align 4
  %1430 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1425, 0
  %1431 = insertvalue { ptr, ptr, ptr, i32 } %1430, ptr %1428, 1
  %1432 = insertvalue { ptr, ptr, ptr, i32 } %1431, ptr %1429, 2
  %1433 = insertvalue { ptr, ptr, ptr, i32 } %1432, i32 %offset.i.i240.i2232, 3
  %1434 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %302, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1433)
  %1435 = add nuw nsw i32 %.reg2mem77.0398.i2215, 1
  %1436 = icmp slt i32 %1435, %.reg2mem91.0.lcssa.i2179
  br i1 %1436, label %._crit_edge2.i2214, label %HashMap_resize_.exit2285

HashMap_resize_.exit2285:                         ; preds = %._crit_edge2.i2214, %._crit_edge395.i2178
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %28)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %30)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i2286)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i2288)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %24)
  %1437 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1438 = load i32, ptr %181, align 4
  %1439 = icmp sgt i32 %1438, 0
  br i1 %1439, label %.lr.ph.i2323, label %._crit_edge1.1.i717

.lr.ph.i2323:                                     ; preds = %HashMap_resize_.exit2285
  %1440 = lshr i160 %1296, 64
  %1441 = insertelement <2 x i160> poison, i160 %1440, i64 0
  %1442 = insertelement <2 x i160> %1441, i160 %1296, i64 1
  %1443 = trunc <2 x i160> %1442 to <2 x i64>
  %1444 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1445 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %1446

1446:                                             ; preds = %.cont.cont.i2377, %.lr.ph.i2323
  %offset.i.i260.i23942825 = phi i32 [ 9, %.lr.ph.i2323 ], [ %offset.i.i260.i2394, %.cont.cont.i2377 ]
  %.reg2mem195.0678.i2325 = phi i32 [ 1, %.lr.ph.i2323 ], [ %1601, %.cont.cont.i2377 ]
  %.reg2mem193.0677.i2326 = phi i32 [ 0, %.lr.ph.i2323 ], [ %1606, %.cont.cont.i2377 ]
  %1447 = phi <2 x i64> [ %1443, %.lr.ph.i2323 ], [ %1605, %.cont.cont.i2377 ]
  %1448 = extractelement <2 x i64> %1447, i64 1
  %.sroa.speculated352.i23812821 = inttoptr i64 %1448 to ptr
  %1449 = extractelement <2 x i64> %1447, i64 0
  %.sroa.speculated346.i23822823 = inttoptr i64 %1449 to ptr
  %1450 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i23812821, 1
  %1451 = insertvalue { ptr, ptr, ptr, i32 } %1450, ptr %.sroa.speculated346.i23822823, 2
  %1452 = insertvalue { ptr, ptr, ptr, i32 } %1451, i32 %offset.i.i260.i23942825, 3
  %1453 = sext i32 %offset.i.i260.i23942825 to i64
  %gep2819 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %1453
  %1454 = load ptr, ptr %gep2819, align 8
  %1455 = call ptr %1454({ ptr, ptr, ptr, i32 } %1452, ptr nonnull %2)
  %1456 = call i32 %1455({ ptr, ptr, ptr, i32 } %1452, { ptr, ptr, ptr, i32 } %1452, ptr nonnull %2)
  %1457 = icmp eq i32 %.reg2mem195.0678.i2325, 1
  %1458 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %1457, label %1459, label %1521

1459:                                             ; preds = %1446
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1460 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1461 = load ptr, ptr %165, align 8
  %1462 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1461, 0
  %1463 = load ptr, ptr %166, align 8
  %1464 = insertvalue { ptr, ptr, ptr, i32 } %1462, ptr %1463, 1
  %1465 = load ptr, ptr %259, align 8
  %1466 = insertvalue { ptr, ptr, ptr, i32 } %1464, ptr %1465, 2
  %1467 = load i32, ptr %167, align 4
  %1468 = insertvalue { ptr, ptr, ptr, i32 } %1466, i32 %1467, 3
  %hash_coef_ptr.i.i10.i3406 = getelementptr i8, ptr %1461, i64 8
  %tbl_size_ptr.i.i11.i3407 = getelementptr i8, ptr %1461, i64 16
  %offset_tbl_ptr.i.i12.i3408 = getelementptr i8, ptr %1461, i64 40
  %hash_coef.i.i13.i3409 = load i64, ptr %hash_coef_ptr.i.i10.i3406, align 4
  %tbl_size.i.i14.i3410 = load i64, ptr %tbl_size_ptr.i.i11.i3407, align 4
  %offset_tbl.i.i15.i3411 = load ptr, ptr %offset_tbl_ptr.i.i12.i3408, align 8
  %product.i.i.i16.i3412 = mul i64 %hash_coef.i.i13.i3409, -5261542750394134544
  %shifted.i.i.i17.i3413 = lshr i64 %product.i.i.i16.i3412, 32
  %xored.i.i.i18.i3414 = xor i64 %shifted.i.i.i17.i3413, %product.i.i.i16.i3412
  %hash.i.i.i19.i3415 = and i64 %xored.i.i.i18.i3414, %tbl_size.i.i14.i3410
  %offset_ptr.i.i20.i3416 = getelementptr i32, ptr %offset_tbl.i.i15.i3411, i64 %hash.i.i.i19.i3415
  %offset.i.i21.i3417 = load i32, ptr %offset_ptr.i.i20.i3416, align 4
  %eq.i.i3418 = icmp eq i32 %1467, %offset.i.i21.i3417
  call void @llvm.assume(i1 %eq.i.i3418) #30
  %1469 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1470 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1461)
  %1471 = sext i32 %1467 to i64
  %1472 = getelementptr ptr, ptr %1461, i64 %1471
  %1473 = getelementptr i8, ptr %1472, i64 64
  %1474 = load ptr, ptr %1473, align 8
  %1475 = call ptr %1474({ ptr, ptr, ptr, i32 } %1468, ptr nonnull %2)
  %1476 = call i32 %1475({ ptr, ptr, ptr, i32 } %1468, { ptr, ptr, ptr, i32 } %1468, ptr nonnull %2)
  %1477 = add i32 %1476, -1
  %1478 = and i32 %1477, %1456
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1479 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1480 = load ptr, ptr %165, align 8
  %1481 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1480, 0
  %1482 = load ptr, ptr %166, align 8
  %1483 = insertvalue { ptr, ptr, ptr, i32 } %1481, ptr %1482, 1
  %1484 = load ptr, ptr %259, align 8
  %1485 = insertvalue { ptr, ptr, ptr, i32 } %1483, ptr %1484, 2
  %1486 = load i32, ptr %167, align 4
  %1487 = insertvalue { ptr, ptr, ptr, i32 } %1485, i32 %1486, 3
  %hash_coef_ptr.i.i172.i2399 = getelementptr i8, ptr %1480, i64 8
  %tbl_size_ptr.i.i173.i2400 = getelementptr i8, ptr %1480, i64 16
  %offset_tbl_ptr.i.i174.i2401 = getelementptr i8, ptr %1480, i64 40
  %hash_coef.i.i175.i2402 = load i64, ptr %hash_coef_ptr.i.i172.i2399, align 4
  %tbl_size.i.i176.i2403 = load i64, ptr %tbl_size_ptr.i.i173.i2400, align 4
  %offset_tbl.i.i177.i2404 = load ptr, ptr %offset_tbl_ptr.i.i174.i2401, align 8
  %product.i.i.i178.i2405 = mul i64 %hash_coef.i.i175.i2402, -5261542750394134544
  %shifted.i.i.i179.i2406 = lshr i64 %product.i.i.i178.i2405, 32
  %xored.i.i.i180.i2407 = xor i64 %shifted.i.i.i179.i2406, %product.i.i.i178.i2405
  %hash.i.i.i181.i2408 = and i64 %xored.i.i.i180.i2407, %tbl_size.i.i176.i2403
  %offset_ptr.i.i182.i2409 = getelementptr i32, ptr %offset_tbl.i.i177.i2404, i64 %hash.i.i.i181.i2408
  %offset.i.i183.i2410 = load i32, ptr %offset_ptr.i.i182.i2409, align 4
  %eq.i.i2411 = icmp eq i32 %1486, %offset.i.i183.i2410
  call void @llvm.assume(i1 %eq.i.i2411) #30
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  %1488 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %9)
  %1489 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1480)
  %1490 = sext i32 %1486 to i64
  %1491 = getelementptr ptr, ptr %1480, i64 %1490
  %1492 = getelementptr i8, ptr %1491, i64 120
  %1493 = load ptr, ptr %1492, align 8
  store ptr @i32_typ, ptr %10, align 8
  %1494 = call ptr %1493({ ptr, ptr, ptr, i32 } %1487, ptr nonnull %10)
  %1495 = call { ptr, i160 } %1494({ ptr, ptr, ptr, i32 } %1487, { ptr, ptr, ptr, i32 } %1487, ptr nonnull %9, i32 %1478)
  %.fca.0.extract112.i2412 = extractvalue { ptr, i160 } %1495, 0
  %.sroa.3111.0.insert.ext.i2413 = zext i32 %offset.i.i260.i23942825 to i160
  %.sroa.3111.0.insert.shift.i2414 = shl nuw i160 %.sroa.3111.0.insert.ext.i2413, 128
  %.sroa.2110.0.insert.ext.i2415 = zext i64 %1449 to i160
  %.sroa.2110.0.insert.shift.i2416 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i2415, 64
  %.sroa.2110.0.insert.insert.i2417 = or disjoint i160 %.sroa.2110.0.insert.shift.i2416, %.sroa.3111.0.insert.shift.i2414
  %.sroa.0109.0.insert.ext.i2418 = zext i64 %1448 to i160
  %.sroa.0109.0.insert.insert.i2419 = or disjoint i160 %.sroa.2110.0.insert.insert.i2417, %.sroa.0109.0.insert.ext.i2418
  %1496 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i2419, 1
  %1497 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1498 = load ptr, ptr %165, align 8
  %1499 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1498, 0
  %1500 = load ptr, ptr %166, align 8
  %1501 = insertvalue { ptr, ptr, ptr, i32 } %1499, ptr %1500, 1
  %1502 = load ptr, ptr %259, align 8
  %1503 = insertvalue { ptr, ptr, ptr, i32 } %1501, ptr %1502, 2
  %1504 = load i32, ptr %167, align 4
  %1505 = insertvalue { ptr, ptr, ptr, i32 } %1503, i32 %1504, 3
  %hash_coef_ptr.i.i186.i2424 = getelementptr i8, ptr %1498, i64 8
  %tbl_size_ptr.i.i187.i2425 = getelementptr i8, ptr %1498, i64 16
  %offset_tbl_ptr.i.i188.i2426 = getelementptr i8, ptr %1498, i64 40
  %hash_coef.i.i189.i2427 = load i64, ptr %hash_coef_ptr.i.i186.i2424, align 4
  %tbl_size.i.i190.i2428 = load i64, ptr %tbl_size_ptr.i.i187.i2425, align 4
  %offset_tbl.i.i191.i2429 = load ptr, ptr %offset_tbl_ptr.i.i188.i2426, align 8
  %product.i.i.i192.i2430 = mul i64 %hash_coef.i.i189.i2427, -5261542750394134544
  %shifted.i.i.i193.i2431 = lshr i64 %product.i.i.i192.i2430, 32
  %xored.i.i.i194.i2432 = xor i64 %shifted.i.i.i193.i2431, %product.i.i.i192.i2430
  %hash.i.i.i195.i2433 = and i64 %xored.i.i.i194.i2432, %tbl_size.i.i190.i2428
  %offset_ptr.i.i196.i2434 = getelementptr i32, ptr %offset_tbl.i.i191.i2429, i64 %hash.i.i.i195.i2433
  %offset.i.i197.i2435 = load i32, ptr %offset_ptr.i.i196.i2434, align 4
  %eq.i200.i2436 = icmp eq i32 %1504, %offset.i.i197.i2435
  call void @llvm.assume(i1 %eq.i200.i2436) #30
  %1506 = load ptr, ptr %result.i, align 8
  %1507 = load ptr, ptr %148, align 8
  %result.i.i2437 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1508 = getelementptr i8, ptr %result.i.i2437, i64 16
  store ptr %1507, ptr %1508, align 8
  %1509 = getelementptr i8, ptr %result.i.i2437, i64 8
  store ptr %1506, ptr %1509, align 8
  %1510 = getelementptr i8, ptr %result.i.i2437, i64 24
  store ptr null, ptr %1510, align 8
  %1511 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i2437)
  store ptr @Entry, ptr %result.i.i2437, align 8
  store ptr @_parameterization_Ptri32, ptr %11, align 8
  store ptr %result.i.i2437, ptr %318, align 8
  %1512 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %11)
  %1513 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1498)
  %1514 = sext i32 %1504 to i64
  %1515 = getelementptr ptr, ptr %1498, i64 %1514
  %1516 = getelementptr i8, ptr %1515, i64 128
  %1517 = load ptr, ptr %1516, align 8
  store ptr @i32_typ, ptr %12, align 8
  store ptr @Entry, ptr %319, align 8
  %1518 = call ptr %1517({ ptr, ptr, ptr, i32 } %1505, ptr nonnull %12)
  call void %1518({ ptr, ptr, ptr, i32 } %1505, { ptr, ptr, ptr, i32 } %1505, ptr nonnull %11, i32 %1478, { ptr, i160 } %1496)
  %1519 = icmp ne ptr %.fca.0.extract112.i2412, @nil_typ
  %1520 = icmp ne ptr %.fca.0.extract112.i2412, null
  %.not140.i2438 = and i1 %1519, %1520
  br i1 %.not140.i2438, label %.cont.cont.i2377, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2444.thread

1521:                                             ; preds = %1446
  %1522 = add i32 %1456, 2127912214
  %1523 = shl i32 %1456, 12
  %1524 = add i32 %1522, %1523
  %1525 = ashr i32 %1524, 19
  %1526 = xor i32 %1524, %1525
  %1527 = xor i32 %1526, -949894596
  %1528 = add i32 %1527, 374761393
  %1529 = shl i32 %1527, 5
  %1530 = add i32 %1528, %1529
  %1531 = add i32 %1530, -744332180
  %1532 = shl i32 %1530, 9
  %1533 = xor i32 %1531, %1532
  %1534 = add i32 %1533, -42973499
  %1535 = shl i32 %1533, 3
  %1536 = add i32 %1534, %1535
  %1537 = ashr i32 %1536, 16
  %1538 = xor i32 %1536, %1537
  %1539 = xor i32 %1538, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1540 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1541 = load ptr, ptr %178, align 8
  %1542 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1541, 0
  %1543 = load ptr, ptr %179, align 8
  %1544 = insertvalue { ptr, ptr, ptr, i32 } %1542, ptr %1543, 1
  %1545 = load ptr, ptr %260, align 8
  %1546 = insertvalue { ptr, ptr, ptr, i32 } %1544, ptr %1545, 2
  %1547 = load i32, ptr %180, align 4
  %1548 = insertvalue { ptr, ptr, ptr, i32 } %1546, i32 %1547, 3
  %hash_coef_ptr.i.i10.i3436 = getelementptr i8, ptr %1541, i64 8
  %tbl_size_ptr.i.i11.i3437 = getelementptr i8, ptr %1541, i64 16
  %offset_tbl_ptr.i.i12.i3438 = getelementptr i8, ptr %1541, i64 40
  %hash_coef.i.i13.i3439 = load i64, ptr %hash_coef_ptr.i.i10.i3436, align 4
  %tbl_size.i.i14.i3440 = load i64, ptr %tbl_size_ptr.i.i11.i3437, align 4
  %offset_tbl.i.i15.i3441 = load ptr, ptr %offset_tbl_ptr.i.i12.i3438, align 8
  %product.i.i.i16.i3442 = mul i64 %hash_coef.i.i13.i3439, -5261542750394134544
  %shifted.i.i.i17.i3443 = lshr i64 %product.i.i.i16.i3442, 32
  %xored.i.i.i18.i3444 = xor i64 %shifted.i.i.i17.i3443, %product.i.i.i16.i3442
  %hash.i.i.i19.i3445 = and i64 %xored.i.i.i18.i3444, %tbl_size.i.i14.i3440
  %offset_ptr.i.i20.i3446 = getelementptr i32, ptr %offset_tbl.i.i15.i3441, i64 %hash.i.i.i19.i3445
  %offset.i.i21.i3447 = load i32, ptr %offset_ptr.i.i20.i3446, align 4
  %eq.i.i3448 = icmp eq i32 %1547, %offset.i.i21.i3447
  call void @llvm.assume(i1 %eq.i.i3448) #30
  %1549 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1550 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1541)
  %1551 = sext i32 %1547 to i64
  %1552 = getelementptr ptr, ptr %1541, i64 %1551
  %1553 = getelementptr i8, ptr %1552, i64 64
  %1554 = load ptr, ptr %1553, align 8
  %1555 = call ptr %1554({ ptr, ptr, ptr, i32 } %1548, ptr nonnull %2)
  %1556 = call i32 %1555({ ptr, ptr, ptr, i32 } %1548, { ptr, ptr, ptr, i32 } %1548, ptr nonnull %2)
  %1557 = add i32 %1556, -1
  %1558 = and i32 %1557, %1539
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1559 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1560 = load ptr, ptr %178, align 8
  %1561 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1560, 0
  %1562 = load ptr, ptr %179, align 8
  %1563 = insertvalue { ptr, ptr, ptr, i32 } %1561, ptr %1562, 1
  %1564 = load ptr, ptr %260, align 8
  %1565 = insertvalue { ptr, ptr, ptr, i32 } %1563, ptr %1564, 2
  %1566 = load i32, ptr %180, align 4
  %1567 = insertvalue { ptr, ptr, ptr, i32 } %1565, i32 %1566, 3
  %hash_coef_ptr.i.i202.i2331 = getelementptr i8, ptr %1560, i64 8
  %tbl_size_ptr.i.i203.i2332 = getelementptr i8, ptr %1560, i64 16
  %offset_tbl_ptr.i.i204.i2333 = getelementptr i8, ptr %1560, i64 40
  %hash_coef.i.i205.i2334 = load i64, ptr %hash_coef_ptr.i.i202.i2331, align 4
  %tbl_size.i.i206.i2335 = load i64, ptr %tbl_size_ptr.i.i203.i2332, align 4
  %offset_tbl.i.i207.i2336 = load ptr, ptr %offset_tbl_ptr.i.i204.i2333, align 8
  %product.i.i.i208.i2337 = mul i64 %hash_coef.i.i205.i2334, -5261542750394134544
  %shifted.i.i.i209.i2338 = lshr i64 %product.i.i.i208.i2337, 32
  %xored.i.i.i210.i2339 = xor i64 %shifted.i.i.i209.i2338, %product.i.i.i208.i2337
  %hash.i.i.i211.i2340 = and i64 %xored.i.i.i210.i2339, %tbl_size.i.i206.i2335
  %offset_ptr.i.i212.i2341 = getelementptr i32, ptr %offset_tbl.i.i207.i2336, i64 %hash.i.i.i211.i2340
  %offset.i.i213.i2342 = load i32, ptr %offset_ptr.i.i212.i2341, align 4
  %eq.i216.i2343 = icmp eq i32 %1566, %offset.i.i213.i2342
  call void @llvm.assume(i1 %eq.i216.i2343) #30
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %1568 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %17)
  %1569 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1560)
  %1570 = sext i32 %1566 to i64
  %1571 = getelementptr ptr, ptr %1560, i64 %1570
  %1572 = getelementptr i8, ptr %1571, i64 120
  %1573 = load ptr, ptr %1572, align 8
  store ptr @i32_typ, ptr %18, align 8
  %1574 = call ptr %1573({ ptr, ptr, ptr, i32 } %1567, ptr nonnull %18)
  %1575 = call { ptr, i160 } %1574({ ptr, ptr, ptr, i32 } %1567, { ptr, ptr, ptr, i32 } %1567, ptr nonnull %17, i32 %1558)
  %.fca.0.extract87.i2344 = extractvalue { ptr, i160 } %1575, 0
  %.sroa.3.0.insert.ext.i2345 = zext i32 %offset.i.i260.i23942825 to i160
  %.sroa.3.0.insert.shift.i2346 = shl nuw i160 %.sroa.3.0.insert.ext.i2345, 128
  %.sroa.2.0.insert.ext.i2347 = zext i64 %1449 to i160
  %.sroa.2.0.insert.shift.i2348 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i2347, 64
  %.sroa.2.0.insert.insert.i2349 = or disjoint i160 %.sroa.2.0.insert.shift.i2348, %.sroa.3.0.insert.shift.i2346
  %.sroa.0.0.insert.ext.i2350 = zext i64 %1448 to i160
  %.sroa.0.0.insert.insert.i2351 = or disjoint i160 %.sroa.2.0.insert.insert.i2349, %.sroa.0.0.insert.ext.i2350
  %1576 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i2351, 1
  %1577 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1578 = load ptr, ptr %178, align 8
  %1579 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1578, 0
  %1580 = load ptr, ptr %179, align 8
  %1581 = insertvalue { ptr, ptr, ptr, i32 } %1579, ptr %1580, 1
  %1582 = load ptr, ptr %260, align 8
  %1583 = insertvalue { ptr, ptr, ptr, i32 } %1581, ptr %1582, 2
  %1584 = load i32, ptr %180, align 4
  %1585 = insertvalue { ptr, ptr, ptr, i32 } %1583, i32 %1584, 3
  %hash_coef_ptr.i.i218.i2356 = getelementptr i8, ptr %1578, i64 8
  %tbl_size_ptr.i.i219.i2357 = getelementptr i8, ptr %1578, i64 16
  %offset_tbl_ptr.i.i220.i2358 = getelementptr i8, ptr %1578, i64 40
  %hash_coef.i.i221.i2359 = load i64, ptr %hash_coef_ptr.i.i218.i2356, align 4
  %tbl_size.i.i222.i2360 = load i64, ptr %tbl_size_ptr.i.i219.i2357, align 4
  %offset_tbl.i.i223.i2361 = load ptr, ptr %offset_tbl_ptr.i.i220.i2358, align 8
  %product.i.i.i224.i2362 = mul i64 %hash_coef.i.i221.i2359, -5261542750394134544
  %shifted.i.i.i225.i2363 = lshr i64 %product.i.i.i224.i2362, 32
  %xored.i.i.i226.i2364 = xor i64 %shifted.i.i.i225.i2363, %product.i.i.i224.i2362
  %hash.i.i.i227.i2365 = and i64 %xored.i.i.i226.i2364, %tbl_size.i.i222.i2360
  %offset_ptr.i.i228.i2366 = getelementptr i32, ptr %offset_tbl.i.i223.i2361, i64 %hash.i.i.i227.i2365
  %offset.i.i229.i2367 = load i32, ptr %offset_ptr.i.i228.i2366, align 4
  %eq.i232.i2368 = icmp eq i32 %1584, %offset.i.i229.i2367
  call void @llvm.assume(i1 %eq.i232.i2368) #30
  %1586 = load ptr, ptr %result.i, align 8
  %1587 = load ptr, ptr %148, align 8
  %result.i233.i2369 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1588 = getelementptr i8, ptr %result.i233.i2369, i64 16
  store ptr %1587, ptr %1588, align 8
  %1589 = getelementptr i8, ptr %result.i233.i2369, i64 8
  store ptr %1586, ptr %1589, align 8
  %1590 = getelementptr i8, ptr %result.i233.i2369, i64 24
  store ptr null, ptr %1590, align 8
  %1591 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i2369)
  store ptr @Entry, ptr %result.i233.i2369, align 8
  store ptr @_parameterization_Ptri32, ptr %19, align 8
  store ptr %result.i233.i2369, ptr %316, align 8
  %1592 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %19)
  %1593 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1578)
  %1594 = sext i32 %1584 to i64
  %1595 = getelementptr ptr, ptr %1578, i64 %1594
  %1596 = getelementptr i8, ptr %1595, i64 128
  %1597 = load ptr, ptr %1596, align 8
  store ptr @i32_typ, ptr %20, align 8
  store ptr @Entry, ptr %317, align 8
  %1598 = call ptr %1597({ ptr, ptr, ptr, i32 } %1585, ptr nonnull %20)
  call void %1598({ ptr, ptr, ptr, i32 } %1585, { ptr, ptr, ptr, i32 } %1585, ptr nonnull %19, i32 %1558, { ptr, i160 } %1576)
  %1599 = icmp ne ptr %.fca.0.extract87.i2344, @nil_typ
  %1600 = icmp ne ptr %.fca.0.extract87.i2344, null
  %.not138.i2370 = and i1 %1599, %1600
  br i1 %.not138.i2370, label %.cont.cont.i2377, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2444.thread

.cont.cont.i2377:                                 ; preds = %1521, %1459
  %.sink2843 = phi { ptr, i160 } [ %1495, %1459 ], [ %1575, %1521 ]
  %1601 = phi i32 [ 2, %1459 ], [ 1, %1521 ]
  %vptr.i248.sroa.speculated.i2380 = phi ptr [ %.fca.0.extract112.i2412, %1459 ], [ %.fca.0.extract87.i2344, %1521 ]
  %.fca.1.extract89.i2373 = extractvalue { ptr, i160 } %.sink2843, 1
  %.sroa.3407.sroa.4.0.extract.shift.i2374 = lshr i160 %.fca.1.extract89.i2373, 64
  %1602 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i2374 to i64
  %1603 = insertelement <2 x i64> poison, i64 %1602, i64 0
  %1604 = trunc i160 %.fca.1.extract89.i2373 to i64
  %1605 = insertelement <2 x i64> %1603, i64 %1604, i64 1
  %hash_coef_ptr.i.i249.i2383 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2380, i64 8
  %tbl_size_ptr.i.i250.i2384 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2380, i64 16
  %offset_tbl_ptr.i.i251.i2385 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i2380, i64 40
  %hash_coef.i.i252.i2386 = load i64, ptr %hash_coef_ptr.i.i249.i2383, align 4
  %tbl_size.i.i253.i2387 = load i64, ptr %tbl_size_ptr.i.i250.i2384, align 4
  %offset_tbl.i.i254.i2388 = load ptr, ptr %offset_tbl_ptr.i.i251.i2385, align 8
  %product.i.i.i255.i2389 = mul i64 %hash_coef.i.i252.i2386, 4015701072841558310
  %shifted.i.i.i256.i2390 = lshr i64 %product.i.i.i255.i2389, 32
  %xored.i.i.i257.i2391 = xor i64 %shifted.i.i.i256.i2390, %product.i.i.i255.i2389
  %hash.i.i.i258.i2392 = and i64 %xored.i.i.i257.i2391, %tbl_size.i.i253.i2387
  %offset_ptr.i.i259.i2393 = getelementptr i32, ptr %offset_tbl.i.i254.i2388, i64 %hash.i.i.i258.i2392
  %offset.i.i260.i2394 = load i32, ptr %offset_ptr.i.i259.i2393, align 4
  %1606 = add nuw nsw i32 %.reg2mem193.0677.i2326, 1
  %1607 = load i32, ptr %181, align 4
  %1608 = icmp slt i32 %1606, %1607
  br i1 %1608, label %1446, label %._crit_edge1.1.i717

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2444.thread: ; preds = %1459, %1521
  %1609 = phi ptr [ %21, %1521 ], [ %13, %1459 ]
  %1610 = phi ptr [ %22, %1521 ], [ %14, %1459 ]
  %1611 = phi ptr [ %23, %1521 ], [ %15, %1459 ]
  %1612 = phi ptr [ %.sroa.0.i2288, %1521 ], [ %.sroa.0680.i2286, %1459 ]
  %1613 = phi ptr [ %24, %1521 ], [ %16, %1459 ]
  %1614 = load i32, ptr %261, align 4
  store i32 %1614, ptr %1609, align 4
  store i32 1, ptr %1610, align 4
  %1615 = add i32 %1614, 1
  store i32 %1615, ptr %1611, align 4
  %1616 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %1615, ptr %261, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1613, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %1612, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2286)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2288)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  br label %HashMap_insert_keyK_valueV.exit800

._crit_edge1.1.i717:                              ; preds = %.cont.cont.i2377, %HashMap_resize_.exit2285
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %10)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %12)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i2286)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %20)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i2288)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %24)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %8)
  %1617 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1618 = load ptr, ptr %165, align 8
  %1619 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1618, 0
  %1620 = load ptr, ptr %166, align 8
  %1621 = insertvalue { ptr, ptr, ptr, i32 } %1619, ptr %1620, 1
  %1622 = load ptr, ptr %259, align 8
  %1623 = insertvalue { ptr, ptr, ptr, i32 } %1621, ptr %1622, 2
  %1624 = load i32, ptr %167, align 4
  %1625 = insertvalue { ptr, ptr, ptr, i32 } %1623, i32 %1624, 3
  %hash_coef_ptr.i.i64.i2462 = getelementptr i8, ptr %1618, i64 8
  %tbl_size_ptr.i.i65.i2463 = getelementptr i8, ptr %1618, i64 16
  %offset_tbl_ptr.i.i66.i2464 = getelementptr i8, ptr %1618, i64 40
  %hash_coef.i.i67.i2465 = load i64, ptr %hash_coef_ptr.i.i64.i2462, align 4
  %tbl_size.i.i68.i2466 = load i64, ptr %tbl_size_ptr.i.i65.i2463, align 4
  %offset_tbl.i.i69.i2467 = load ptr, ptr %offset_tbl_ptr.i.i66.i2464, align 8
  %product.i.i.i70.i2468 = mul i64 %hash_coef.i.i67.i2465, -5261542750394134544
  %shifted.i.i.i71.i2469 = lshr i64 %product.i.i.i70.i2468, 32
  %xored.i.i.i72.i2470 = xor i64 %shifted.i.i.i71.i2469, %product.i.i.i70.i2468
  %hash.i.i.i73.i2471 = and i64 %xored.i.i.i72.i2470, %tbl_size.i.i68.i2466
  %offset_ptr.i.i74.i2472 = getelementptr i32, ptr %offset_tbl.i.i69.i2467, i64 %hash.i.i.i73.i2471
  %offset.i.i75.i2473 = load i32, ptr %offset_ptr.i.i74.i2472, align 4
  %eq.i.i2474 = icmp eq i32 %1624, %offset.i.i75.i2473
  call void @llvm.assume(i1 %eq.i.i2474) #30
  %1626 = load ptr, ptr %178, align 8
  %1627 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1626, 0
  %1628 = load ptr, ptr %179, align 8
  %1629 = insertvalue { ptr, ptr, ptr, i32 } %1627, ptr %1628, 1
  %1630 = load ptr, ptr %260, align 8
  %1631 = insertvalue { ptr, ptr, ptr, i32 } %1629, ptr %1630, 2
  %1632 = load i32, ptr %180, align 4
  %1633 = insertvalue { ptr, ptr, ptr, i32 } %1631, i32 %1632, 3
  %hash_coef_ptr.i.i92.i2479 = getelementptr i8, ptr %1626, i64 8
  %tbl_size_ptr.i.i93.i2480 = getelementptr i8, ptr %1626, i64 16
  %offset_tbl_ptr.i.i94.i2481 = getelementptr i8, ptr %1626, i64 40
  %hash_coef.i.i95.i2482 = load i64, ptr %hash_coef_ptr.i.i92.i2479, align 4
  %tbl_size.i.i96.i2483 = load i64, ptr %tbl_size_ptr.i.i93.i2480, align 4
  %offset_tbl.i.i97.i2484 = load ptr, ptr %offset_tbl_ptr.i.i94.i2481, align 8
  %product.i.i.i98.i2485 = mul i64 %hash_coef.i.i95.i2482, -5261542750394134544
  %shifted.i.i.i99.i2486 = lshr i64 %product.i.i.i98.i2485, 32
  %xored.i.i.i100.i2487 = xor i64 %shifted.i.i.i99.i2486, %product.i.i.i98.i2485
  %hash.i.i.i101.i2488 = and i64 %xored.i.i.i100.i2487, %tbl_size.i.i96.i2483
  %offset_ptr.i.i102.i2489 = getelementptr i32, ptr %offset_tbl.i.i97.i2484, i64 %hash.i.i.i101.i2488
  %offset.i.i103.i2490 = load i32, ptr %offset_ptr.i.i102.i2489, align 4
  %eq.i106.i2491 = icmp eq i32 %1632, %offset.i.i103.i2490
  call void @llvm.assume(i1 %eq.i106.i2491) #30
  %1634 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1635 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1618)
  %1636 = sext i32 %1624 to i64
  %1637 = getelementptr ptr, ptr %1618, i64 %1636
  %1638 = getelementptr i8, ptr %1637, i64 64
  %1639 = load ptr, ptr %1638, align 8
  %1640 = call ptr %1639({ ptr, ptr, ptr, i32 } %1625, ptr nonnull %2)
  %1641 = call i32 %1640({ ptr, ptr, ptr, i32 } %1625, { ptr, ptr, ptr, i32 } %1625, ptr nonnull %2)
  %1642 = shl i32 %1641, 1
  %1643 = load i32, ptr %261, align 4
  %1644 = load ptr, ptr %result.i, align 8
  %1645 = load ptr, ptr %148, align 8
  %1646 = sext i32 %1643 to i64
  %1647 = shl nsw i64 %1646, 5
  %result.i.i.i2494 = call noalias ptr @bump_malloc_inner(i64 noundef %1647, ptr nonnull @current_ptr) #29
  %1648 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1649 = icmp sgt i32 %1641, 0
  br i1 %1649, label %.lr.ph434.i2564, label %._crit_edge395.i2508

.lr.ph434.i2564:                                  ; preds = %._crit_edge1.1.i717
  %invariant.gep.i2507 = getelementptr i8, ptr %1618, i64 120
  %1650 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i2567 = getelementptr ptr, ptr %invariant.gep.i2507, i64 %1636
  br label %1651

1651:                                             ; preds = %1673, %.lr.ph434.i2564
  %.reg2mem105.0432.i2565 = phi i32 [ 0, %.lr.ph434.i2564 ], [ %.reg2mem101.0.i2570, %1673 ]
  %.reg2mem103.0431.i2566 = phi i32 [ 0, %.lr.ph434.i2564 ], [ %1674, %1673 ]
  store ptr @_parameterization_Ptri32, ptr %3, align 8
  %1652 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %3)
  %1653 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %1618)
  %1654 = load ptr, ptr %gep.i2567, align 8
  store ptr @i32_typ, ptr %4, align 8
  %1655 = call ptr %1654({ ptr, ptr, ptr, i32 } %1625, ptr nonnull %4)
  %1656 = call { ptr, i160 } %1655({ ptr, ptr, ptr, i32 } %1625, { ptr, ptr, ptr, i32 } %1625, ptr nonnull %3, i32 %.reg2mem103.0431.i2566)
  %.fca.0.extract52.i2568 = extractvalue { ptr, i160 } %1656, 0
  %1657 = icmp ne ptr %.fca.0.extract52.i2568, @nil_typ
  %1658 = icmp ne ptr %.fca.0.extract52.i2568, null
  %.not60.i2569 = and i1 %1657, %1658
  br i1 %.not60.i2569, label %1659, label %1673

1659:                                             ; preds = %1651
  %hash_coef_ptr.i.i137.i2597 = getelementptr i8, ptr %.fca.0.extract52.i2568, i64 8
  %tbl_size_ptr.i.i138.i2598 = getelementptr i8, ptr %.fca.0.extract52.i2568, i64 16
  %offset_tbl_ptr.i.i139.i2599 = getelementptr i8, ptr %.fca.0.extract52.i2568, i64 40
  %hash_coef.i.i140.i2600 = load i64, ptr %hash_coef_ptr.i.i137.i2597, align 4
  %tbl_size.i.i141.i2601 = load i64, ptr %tbl_size_ptr.i.i138.i2598, align 4
  %offset_tbl.i.i142.i2602 = load ptr, ptr %offset_tbl_ptr.i.i139.i2599, align 8
  %product.i.i.i143.i2603 = mul i64 %hash_coef.i.i140.i2600, 4015701072841558310
  %shifted.i.i.i144.i2604 = lshr i64 %product.i.i.i143.i2603, 32
  %xored.i.i.i145.i2605 = xor i64 %shifted.i.i.i144.i2604, %product.i.i.i143.i2603
  %hash.i.i.i146.i2606 = and i64 %xored.i.i.i145.i2605, %tbl_size.i.i141.i2601
  %offset_ptr.i.i147.i2607 = getelementptr i32, ptr %offset_tbl.i.i142.i2602, i64 %hash.i.i.i146.i2606
  %offset.i.i148.i2608 = load i32, ptr %offset_ptr.i.i147.i2607, align 4
  %1660 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1661 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1662 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1663 = icmp slt i32 %.reg2mem105.0432.i2565, %1643
  br i1 %1663, label %1664, label %._crit_edge.i2609

1664:                                             ; preds = %1659
  %.fca.1.extract54.i2610 = extractvalue { ptr, i160 } %1656, 1
  %.sroa.351.0.insert.ext.i2611 = zext i32 %offset.i.i148.i2608 to i160
  %.sroa.351.0.insert.shift.i2612 = shl nuw i160 %.sroa.351.0.insert.ext.i2611, 128
  %1665 = and i160 %.fca.1.extract54.i2610, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i2613 = or disjoint i160 %.sroa.351.0.insert.shift.i2612, %1665
  %1666 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1667 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1668 = sext i32 %.reg2mem105.0432.i2565 to i64
  %1669 = shl nsw i64 %1668, 5
  %1670 = getelementptr i8, ptr %result.i.i.i2494, i64 %1669
  store ptr %.fca.0.extract52.i2568, ptr %1670, align 8
  %1671 = getelementptr i8, ptr %1670, i64 8
  store i160 %.sroa.049.0.insert.insert.i2613, ptr %1671, align 4
  br label %._crit_edge.i2609

._crit_edge.i2609:                                ; preds = %1664, %1659
  %1672 = add i32 %.reg2mem105.0432.i2565, 1
  br label %1673

1673:                                             ; preds = %._crit_edge.i2609, %1651
  %.reg2mem101.0.i2570 = phi i32 [ %1672, %._crit_edge.i2609 ], [ %.reg2mem105.0432.i2565, %1651 ]
  %1674 = add nuw nsw i32 %.reg2mem103.0431.i2566, 1
  %1675 = icmp slt i32 %1674, %1641
  br i1 %1675, label %1651, label %.lr.ph.i2571

.lr.ph.i2571:                                     ; preds = %1673
  %invariant.gep396.i2572 = getelementptr i8, ptr %1626, i64 120
  %1676 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1677 = sext i32 %1632 to i64
  %gep397.i2575 = getelementptr ptr, ptr %invariant.gep396.i2572, i64 %1677
  br label %1678

1678:                                             ; preds = %1700, %.lr.ph.i2571
  %.reg2mem91.0394.i2573 = phi i32 [ %.reg2mem101.0.i2570, %.lr.ph.i2571 ], [ %.reg2mem87.0.i2578, %1700 ]
  %.reg2mem89.0393.i2574 = phi i32 [ 0, %.lr.ph.i2571 ], [ %1701, %1700 ]
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %1679 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %1680 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1626)
  %1681 = load ptr, ptr %gep397.i2575, align 8
  store ptr @i32_typ, ptr %6, align 8
  %1682 = call ptr %1681({ ptr, ptr, ptr, i32 } %1633, ptr nonnull %6)
  %1683 = call { ptr, i160 } %1682({ ptr, ptr, ptr, i32 } %1633, { ptr, ptr, ptr, i32 } %1633, ptr nonnull %5, i32 %.reg2mem89.0393.i2574)
  %.fca.0.extract42.i2576 = extractvalue { ptr, i160 } %1683, 0
  %1684 = icmp ne ptr %.fca.0.extract42.i2576, @nil_typ
  %1685 = icmp ne ptr %.fca.0.extract42.i2576, null
  %.not62.i2577 = and i1 %1684, %1685
  br i1 %.not62.i2577, label %1686, label %1700

1686:                                             ; preds = %1678
  %hash_coef_ptr.i.i152.i2579 = getelementptr i8, ptr %.fca.0.extract42.i2576, i64 8
  %tbl_size_ptr.i.i153.i2580 = getelementptr i8, ptr %.fca.0.extract42.i2576, i64 16
  %offset_tbl_ptr.i.i154.i2581 = getelementptr i8, ptr %.fca.0.extract42.i2576, i64 40
  %hash_coef.i.i155.i2582 = load i64, ptr %hash_coef_ptr.i.i152.i2579, align 4
  %tbl_size.i.i156.i2583 = load i64, ptr %tbl_size_ptr.i.i153.i2580, align 4
  %offset_tbl.i.i157.i2584 = load ptr, ptr %offset_tbl_ptr.i.i154.i2581, align 8
  %product.i.i.i158.i2585 = mul i64 %hash_coef.i.i155.i2582, 4015701072841558310
  %shifted.i.i.i159.i2586 = lshr i64 %product.i.i.i158.i2585, 32
  %xored.i.i.i160.i2587 = xor i64 %shifted.i.i.i159.i2586, %product.i.i.i158.i2585
  %hash.i.i.i161.i2588 = and i64 %xored.i.i.i160.i2587, %tbl_size.i.i156.i2583
  %offset_ptr.i.i162.i2589 = getelementptr i32, ptr %offset_tbl.i.i157.i2584, i64 %hash.i.i.i161.i2588
  %offset.i.i163.i2590 = load i32, ptr %offset_ptr.i.i162.i2589, align 4
  %1687 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1688 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1689 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1690 = icmp slt i32 %.reg2mem91.0394.i2573, %1643
  br i1 %1690, label %1691, label %._crit_edge1.i2591

1691:                                             ; preds = %1686
  %.fca.1.extract44.i2592 = extractvalue { ptr, i160 } %1683, 1
  %.sroa.3.0.insert.ext.i2593 = zext i32 %offset.i.i163.i2590 to i160
  %.sroa.3.0.insert.shift.i2594 = shl nuw i160 %.sroa.3.0.insert.ext.i2593, 128
  %1692 = and i160 %.fca.1.extract44.i2592, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i2595 = or disjoint i160 %.sroa.3.0.insert.shift.i2594, %1692
  %1693 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1694 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1695 = sext i32 %.reg2mem91.0394.i2573 to i64
  %1696 = shl nsw i64 %1695, 5
  %1697 = getelementptr i8, ptr %result.i.i.i2494, i64 %1696
  store ptr %.fca.0.extract42.i2576, ptr %1697, align 8
  %1698 = getelementptr i8, ptr %1697, i64 8
  store i160 %.sroa.040.0.insert.insert.i2595, ptr %1698, align 4
  br label %._crit_edge1.i2591

._crit_edge1.i2591:                               ; preds = %1691, %1686
  %1699 = add i32 %.reg2mem91.0394.i2573, 1
  br label %1700

1700:                                             ; preds = %._crit_edge1.i2591, %1678
  %.reg2mem87.0.i2578 = phi i32 [ %1699, %._crit_edge1.i2591 ], [ %.reg2mem91.0394.i2573, %1678 ]
  %1701 = add nuw nsw i32 %.reg2mem89.0393.i2574, 1
  %1702 = icmp slt i32 %1701, %1641
  br i1 %1702, label %1678, label %._crit_edge395.i2508.loopexit

._crit_edge395.i2508.loopexit:                    ; preds = %1700
  %.pre3197 = load ptr, ptr %result.i, align 8
  %.pre3198 = load ptr, ptr %148, align 8
  br label %._crit_edge395.i2508

._crit_edge395.i2508:                             ; preds = %._crit_edge395.i2508.loopexit, %._crit_edge1.1.i717
  %1703 = phi ptr [ %1645, %._crit_edge1.1.i717 ], [ %.pre3198, %._crit_edge395.i2508.loopexit ]
  %1704 = phi ptr [ %1644, %._crit_edge1.1.i717 ], [ %.pre3197, %._crit_edge395.i2508.loopexit ]
  %.reg2mem91.0.lcssa.i2509 = phi i32 [ 0, %._crit_edge1.1.i717 ], [ %.reg2mem87.0.i2578, %._crit_edge395.i2508.loopexit ]
  %1705 = call i32 @llvm.smax.i32(i32 %1642, i32 16)
  %result.i166.i2510 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1706 = getelementptr i8, ptr %result.i166.i2510, i64 16
  store ptr @_parameterization_Nil, ptr %1706, align 8
  %result.i167.i2511 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1707 = getelementptr i8, ptr %result.i167.i2511, i64 16
  store ptr %1703, ptr %1707, align 8
  %1708 = getelementptr i8, ptr %result.i167.i2511, i64 8
  store ptr %1704, ptr %1708, align 8
  %1709 = getelementptr i8, ptr %result.i167.i2511, i64 24
  store ptr null, ptr %1709, align 8
  %1710 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i2511)
  store ptr @Entry, ptr %result.i167.i2511, align 8
  %1711 = getelementptr i8, ptr %result.i166.i2510, i64 8
  store ptr %result.i167.i2511, ptr %1711, align 8
  %1712 = getelementptr i8, ptr %result.i166.i2510, i64 24
  store ptr null, ptr %1712, align 8
  %1713 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i2510)
  store ptr @union_typ, ptr %result.i166.i2510, align 8
  %result.i168.i2512 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i2510, ptr %result.i168.i2512, align 8
  %1714 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i2512)
  store ptr @Array, ptr %7, align 8
  store ptr %result.i168.i2512, ptr %320, align 8
  store i32 9, ptr %321, align 8
  %1715 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %7)
  %1716 = getelementptr i8, ptr %result.i168.i2512, i64 16
  store i32 %1705, ptr %1716, align 4
  %1717 = getelementptr i8, ptr %result.i168.i2512, i64 20
  store i32 %1705, ptr %1717, align 4
  %1718 = zext nneg i32 %1705 to i64
  %1719 = shl nuw nsw i64 %1718, 5
  %result.i.i416.i2513 = call noalias ptr @bump_malloc_inner(i64 noundef %1719, ptr nonnull @current_ptr) #29
  %1720 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1721 = getelementptr i8, ptr %result.i168.i2512, i64 8
  store ptr %result.i.i416.i2513, ptr %1721, align 8
  %1722 = load ptr, ptr %322, align 8
  store ptr @Array, ptr %165, align 8
  store ptr %result.i168.i2512, ptr %166, align 8
  store ptr %1722, ptr %259, align 8
  store i32 9, ptr %167, align 4
  %1723 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i2526 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1724 = getelementptr i8, ptr %result.i183.i2526, i64 16
  store ptr @_parameterization_Nil, ptr %1724, align 8
  %result.i184.i2527 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1725 = getelementptr i8, ptr %result.i184.i2527, i64 16
  store ptr %1703, ptr %1725, align 8
  %1726 = getelementptr i8, ptr %result.i184.i2527, i64 8
  store ptr %1704, ptr %1726, align 8
  %1727 = getelementptr i8, ptr %result.i184.i2527, i64 24
  store ptr null, ptr %1727, align 8
  %1728 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i2527)
  store ptr @Entry, ptr %result.i184.i2527, align 8
  %1729 = getelementptr i8, ptr %result.i183.i2526, i64 8
  store ptr %result.i184.i2527, ptr %1729, align 8
  %1730 = getelementptr i8, ptr %result.i183.i2526, i64 24
  store ptr null, ptr %1730, align 8
  %1731 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i2526)
  store ptr @union_typ, ptr %result.i183.i2526, align 8
  %result.i185.i2528 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i2526, ptr %result.i185.i2528, align 8
  %1732 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i2528)
  store ptr @Array, ptr %8, align 8
  store ptr %result.i185.i2528, ptr %323, align 8
  store i32 9, ptr %324, align 8
  %1733 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %8)
  %1734 = getelementptr i8, ptr %result.i185.i2528, i64 16
  store i32 %1705, ptr %1734, align 4
  %1735 = getelementptr i8, ptr %result.i185.i2528, i64 20
  store i32 %1705, ptr %1735, align 4
  %result.i.i430.i2529 = call noalias ptr @bump_malloc_inner(i64 noundef %1719, ptr nonnull @current_ptr) #29
  %1736 = getelementptr i8, ptr %result.i185.i2528, i64 8
  store ptr %result.i.i430.i2529, ptr %1736, align 8
  %1737 = load ptr, ptr %325, align 8
  store ptr @Array, ptr %178, align 8
  store ptr %result.i185.i2528, ptr %179, align 8
  store ptr %1737, ptr %260, align 8
  store i32 9, ptr %180, align 4
  store i32 0, ptr %261, align 4
  %1738 = icmp sgt i32 %.reg2mem91.0.lcssa.i2509, 0
  br i1 %1738, label %.lr.ph400.i2542, label %HashMap_resize_.exit2615

.lr.ph400.i2542:                                  ; preds = %._crit_edge395.i2508
  %1739 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1740 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1741 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i2544

._crit_edge2.i2544:                               ; preds = %._crit_edge2.i2544, %.lr.ph400.i2542
  %.reg2mem77.0398.i2545 = phi i32 [ 0, %.lr.ph400.i2542 ], [ %1755, %._crit_edge2.i2544 ]
  %1742 = zext nneg i32 %.reg2mem77.0398.i2545 to i64
  %1743 = shl nuw nsw i64 %1742, 5
  %1744 = getelementptr i8, ptr %result.i.i.i2494, i64 %1743
  %1745 = load ptr, ptr %1744, align 8
  %1746 = getelementptr i8, ptr %1744, i64 8
  %1747 = load i160, ptr %1746, align 4
  %.sroa.3362.8.extract.trunc.i2548 = trunc i160 %1747 to i64
  %1748 = inttoptr i64 %.sroa.3362.8.extract.trunc.i2548 to ptr
  %.sroa.5363.8.extract.shift.i2549 = lshr i160 %1747, 64
  %.sroa.5363.8.extract.trunc.i2550 = trunc i160 %.sroa.5363.8.extract.shift.i2549 to i64
  %1749 = inttoptr i64 %.sroa.5363.8.extract.trunc.i2550 to ptr
  %hash_coef_ptr.i.i201.i2551 = getelementptr i8, ptr %1745, i64 8
  %tbl_size_ptr.i.i202.i2552 = getelementptr i8, ptr %1745, i64 16
  %offset_tbl_ptr.i.i203.i2553 = getelementptr i8, ptr %1745, i64 40
  %hash_coef.i.i232.i2554 = load i64, ptr %hash_coef_ptr.i.i201.i2551, align 4
  %tbl_size.i.i233.i2555 = load i64, ptr %tbl_size_ptr.i.i202.i2552, align 4
  %offset_tbl.i.i234.i2556 = load ptr, ptr %offset_tbl_ptr.i.i203.i2553, align 8
  %product.i.i.i235.i2557 = mul i64 %hash_coef.i.i232.i2554, 4015701072841558310
  %shifted.i.i.i236.i2558 = lshr i64 %product.i.i.i235.i2557, 32
  %xored.i.i.i237.i2559 = xor i64 %shifted.i.i.i236.i2558, %product.i.i.i235.i2557
  %hash.i.i.i238.i2560 = and i64 %xored.i.i.i237.i2559, %tbl_size.i.i233.i2555
  %offset_ptr.i.i239.i2561 = getelementptr i32, ptr %offset_tbl.i.i234.i2556, i64 %hash.i.i.i238.i2560
  %offset.i.i240.i2562 = load i32, ptr %offset_ptr.i.i239.i2561, align 4
  %1750 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1745, 0
  %1751 = insertvalue { ptr, ptr, ptr, i32 } %1750, ptr %1748, 1
  %1752 = insertvalue { ptr, ptr, ptr, i32 } %1751, ptr %1749, 2
  %1753 = insertvalue { ptr, ptr, ptr, i32 } %1752, i32 %offset.i.i240.i2562, 3
  %1754 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %302, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %1753)
  %1755 = add nuw nsw i32 %.reg2mem77.0398.i2545, 1
  %1756 = icmp slt i32 %1755, %.reg2mem91.0.lcssa.i2509
  br i1 %1756, label %._crit_edge2.i2544, label %HashMap_resize_.exit2615

HashMap_resize_.exit2615:                         ; preds = %._crit_edge2.i2544, %._crit_edge395.i2508
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %8)
  br label %HashMap_insert_keyK_valueV.exit800

HashMap_insert_keyK_valueV.exit800:               ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2444.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread2795, %569, %765, %HashMap_resize_.exit2615
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %117)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %118)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %119)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %120)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %121)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %122)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %123)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %124)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %125)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %126)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %127)
  %1757 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %1758 = load ptr, ptr %187, align 8
  %1759 = sext i32 %.reg2mem129.0286 to i64
  %1760 = shl nsw i64 %1759, 5
  %1761 = getelementptr i8, ptr %1758, i64 %1760
  store ptr @i32_typ, ptr %1761, align 8
  %1762 = getelementptr i8, ptr %1761, i64 8
  store i160 %.sroa.087.0.insert.ext, ptr %1762, align 4
  store i1 true, ptr %.sroa.064.sroa.0, align 8
  %.sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.0. = load i8, ptr %.sroa.064.sroa.0, align 8
  %.sroa.064.0.insert.ext = zext i8 %.sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.sroa.0.0..sroa.064.0. to i160
  %1763 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.064.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %128)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %129)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %130)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %131)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %132)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %133)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %134)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %135)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %136)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %137)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %138)
  %1764 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1765 = load ptr, ptr %193, align 8
  %1766 = call i32 %1765({ ptr, i160 } %332)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1767 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1768 = load ptr, ptr %205, align 8
  %1769 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1768, 0
  %1770 = load ptr, ptr %206, align 8
  %1771 = insertvalue { ptr, ptr, ptr, i32 } %1769, ptr %1770, 1
  %1772 = load ptr, ptr %207, align 8
  %1773 = insertvalue { ptr, ptr, ptr, i32 } %1771, ptr %1772, 2
  %1774 = load i32, ptr %208, align 4
  %1775 = insertvalue { ptr, ptr, ptr, i32 } %1773, i32 %1774, 3
  %hash_coef_ptr.i.i10.i1040 = getelementptr i8, ptr %1768, i64 8
  %tbl_size_ptr.i.i11.i1041 = getelementptr i8, ptr %1768, i64 16
  %offset_tbl_ptr.i.i12.i1042 = getelementptr i8, ptr %1768, i64 40
  %hash_coef.i.i13.i1043 = load i64, ptr %hash_coef_ptr.i.i10.i1040, align 4
  %tbl_size.i.i14.i1044 = load i64, ptr %tbl_size_ptr.i.i11.i1041, align 4
  %offset_tbl.i.i15.i1045 = load ptr, ptr %offset_tbl_ptr.i.i12.i1042, align 8
  %product.i.i.i16.i1046 = mul i64 %hash_coef.i.i13.i1043, -5261542750394134544
  %shifted.i.i.i17.i1047 = lshr i64 %product.i.i.i16.i1046, 32
  %xored.i.i.i18.i1048 = xor i64 %shifted.i.i.i17.i1047, %product.i.i.i16.i1046
  %hash.i.i.i19.i1049 = and i64 %xored.i.i.i18.i1048, %tbl_size.i.i14.i1044
  %offset_ptr.i.i20.i1050 = getelementptr i32, ptr %offset_tbl.i.i15.i1045, i64 %hash.i.i.i19.i1049
  %offset.i.i21.i1051 = load i32, ptr %offset_ptr.i.i20.i1050, align 4
  %eq.i.i1052 = icmp eq i32 %1774, %offset.i.i21.i1051
  call void @llvm.assume(i1 %eq.i.i1052) #30
  %1776 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1777 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1768)
  %1778 = sext i32 %1774 to i64
  %1779 = getelementptr ptr, ptr %1768, i64 %1778
  %1780 = getelementptr i8, ptr %1779, i64 64
  %1781 = load ptr, ptr %1780, align 8
  %1782 = call ptr %1781({ ptr, ptr, ptr, i32 } %1775, ptr nonnull %2)
  %1783 = call i32 %1782({ ptr, ptr, ptr, i32 } %1775, { ptr, ptr, ptr, i32 } %1775, ptr nonnull %2)
  %1784 = add i32 %1783, -1
  %1785 = and i32 %1784, %1766
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1786 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1787 = load ptr, ptr %205, align 8
  %1788 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1787, 0
  %1789 = load ptr, ptr %206, align 8
  %1790 = insertvalue { ptr, ptr, ptr, i32 } %1788, ptr %1789, 1
  %1791 = load ptr, ptr %207, align 8
  %1792 = insertvalue { ptr, ptr, ptr, i32 } %1790, ptr %1791, 2
  %1793 = load i32, ptr %208, align 4
  %1794 = insertvalue { ptr, ptr, ptr, i32 } %1792, i32 %1793, 3
  %hash_coef_ptr.i.i162.i = getelementptr i8, ptr %1787, i64 8
  %tbl_size_ptr.i.i163.i = getelementptr i8, ptr %1787, i64 16
  %offset_tbl_ptr.i.i164.i = getelementptr i8, ptr %1787, i64 40
  %hash_coef.i.i165.i = load i64, ptr %hash_coef_ptr.i.i162.i, align 4
  %tbl_size.i.i166.i = load i64, ptr %tbl_size_ptr.i.i163.i, align 4
  %offset_tbl.i.i167.i = load ptr, ptr %offset_tbl_ptr.i.i164.i, align 8
  %product.i.i.i168.i = mul i64 %hash_coef.i.i165.i, -5261542750394134544
  %shifted.i.i.i169.i = lshr i64 %product.i.i.i168.i, 32
  %xored.i.i.i170.i = xor i64 %shifted.i.i.i169.i, %product.i.i.i168.i
  %hash.i.i.i171.i = and i64 %xored.i.i.i170.i, %tbl_size.i.i166.i
  %offset_ptr.i.i172.i = getelementptr i32, ptr %offset_tbl.i.i167.i, i64 %hash.i.i.i171.i
  %offset.i.i173.i = load i32, ptr %offset_ptr.i.i172.i, align 4
  %eq.i.i498 = icmp eq i32 %1793, %offset.i.i173.i
  call void @llvm.assume(i1 %eq.i.i498) #30
  store ptr @_parameterization_Ptri32, ptr %137, align 8
  %1795 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %137)
  %1796 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1787)
  %1797 = sext i32 %1793 to i64
  %1798 = getelementptr ptr, ptr %1787, i64 %1797
  %1799 = getelementptr i8, ptr %1798, i64 120
  %1800 = load ptr, ptr %1799, align 8
  store ptr @i32_typ, ptr %138, align 8
  %1801 = call ptr %1800({ ptr, ptr, ptr, i32 } %1794, ptr nonnull %138)
  %1802 = call { ptr, i160 } %1801({ ptr, ptr, ptr, i32 } %1794, { ptr, ptr, ptr, i32 } %1794, ptr nonnull %137, i32 %1785)
  %.fca.0.extract.i499 = extractvalue { ptr, i160 } %1802, 0
  %1803 = icmp ne ptr %.fca.0.extract.i499, @nil_typ
  %1804 = icmp ne ptr %.fca.0.extract.i499, null
  %.not149.i = and i1 %1803, %1804
  br i1 %.not149.i, label %1805, label %.critedge.i500

1805:                                             ; preds = %HashMap_insert_keyK_valueV.exit800
  %.fca.1.extract.i507 = extractvalue { ptr, i160 } %1802, 1
  %.sroa.4520.8.extract.trunc.i = trunc i160 %.fca.1.extract.i507 to i64
  %1806 = inttoptr i64 %.sroa.4520.8.extract.trunc.i to ptr
  %.sroa.7522.8.extract.shift.i = lshr i160 %.fca.1.extract.i507, 64
  %.sroa.7522.8.extract.trunc.i = trunc i160 %.sroa.7522.8.extract.shift.i to i64
  %1807 = inttoptr i64 %.sroa.7522.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i176.i = getelementptr i8, ptr %.fca.0.extract.i499, i64 8
  %tbl_size_ptr.i.i177.i = getelementptr i8, ptr %.fca.0.extract.i499, i64 16
  %offset_tbl_ptr.i.i178.i = getelementptr i8, ptr %.fca.0.extract.i499, i64 40
  %hash_coef.i.i179.i = load i64, ptr %hash_coef_ptr.i.i176.i, align 4
  %tbl_size.i.i180.i = load i64, ptr %tbl_size_ptr.i.i177.i, align 4
  %offset_tbl.i.i181.i = load ptr, ptr %offset_tbl_ptr.i.i178.i, align 8
  %product.i.i.i182.i = mul i64 %hash_coef.i.i179.i, 4015701072841558310
  %shifted.i.i.i183.i = lshr i64 %product.i.i.i182.i, 32
  %xored.i.i.i184.i = xor i64 %shifted.i.i.i183.i, %product.i.i.i182.i
  %hash.i.i.i185.i = and i64 %xored.i.i.i184.i, %tbl_size.i.i180.i
  %offset_ptr.i.i186.i = getelementptr i32, ptr %offset_tbl.i.i181.i, i64 %hash.i.i.i185.i
  %offset.i.i187.i = load i32, ptr %offset_ptr.i.i186.i, align 4
  %1808 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i499, 0
  %1809 = insertvalue { ptr, ptr, ptr, i32 } %1808, ptr %1806, 1
  %1810 = insertvalue { ptr, ptr, ptr, i32 } %1809, ptr %1807, 2
  %1811 = insertvalue { ptr, ptr, ptr, i32 } %1810, i32 %offset.i.i187.i, 3
  %1812 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1813 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1814 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i499)
  %1815 = sext i32 %offset.i.i187.i to i64
  %1816 = getelementptr ptr, ptr %.fca.0.extract.i499, i64 %1815
  %1817 = getelementptr i8, ptr %1816, i64 64
  %1818 = load ptr, ptr %1817, align 8
  %1819 = call ptr %1818({ ptr, ptr, ptr, i32 } %1811, ptr nonnull %2)
  %1820 = call i32 %1819({ ptr, ptr, ptr, i32 } %1811, { ptr, ptr, ptr, i32 } %1811, ptr nonnull %2)
  %1821 = icmp eq i32 %1820, %1766
  %1822 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1823 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1824 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i499)
  %1825 = getelementptr i8, ptr %1816, i64 48
  %1826 = load ptr, ptr %1825, align 8
  %1827 = call ptr %1826({ ptr, ptr, ptr, i32 } %1811, ptr nonnull %2)
  %1828 = call { ptr, i160 } %1827({ ptr, ptr, ptr, i32 } %1811, { ptr, ptr, ptr, i32 } %1811, ptr nonnull %2)
  %1829 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1830 = load ptr, ptr %194, align 8
  %1831 = call i1 %1830({ ptr, i160 } %1828, { ptr, i160 } %332)
  %1832 = and i1 %1821, %1831
  br i1 %1832, label %1833, label %.critedge.i500

1833:                                             ; preds = %1805
  %1834 = load ptr, ptr %result.i134, align 8
  %1835 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1836 = load ptr, ptr %188, align 8
  %1837 = load ptr, ptr %1834, align 8
  %1838 = getelementptr i8, ptr %1837, i64 48
  %1839 = load ptr, ptr %1838, align 8
  %1840 = call { i64, i64 } %1839(ptr nonnull %1834)
  %1841 = extractvalue { i64, i64 } %1840, 0
  %1842 = extractvalue { i64, i64 } %1840, 1
  %1843 = urem i64 20, %1842
  %1844 = icmp eq i64 %1843, 0
  %1845 = sub i64 %1842, %1843
  %1846 = select i1 %1844, i64 0, i64 %1845
  %1847 = add i64 %1841, 20
  %1848 = add i64 %1847, %1846
  %1849 = load ptr, ptr %1836, align 8
  %1850 = getelementptr i8, ptr %1849, i64 48
  %1851 = load ptr, ptr %1850, align 8
  %1852 = call { i64, i64 } %1851(ptr nonnull %1836)
  %1853 = extractvalue { i64, i64 } %1852, 0
  %1854 = extractvalue { i64, i64 } %1852, 1
  %1855 = call i64 @llvm.umax.i64(i64 %1842, i64 %1854)
  %1856 = call i64 @llvm.umax.i64(i64 %1855, i64 8)
  %1857 = urem i64 %1848, %1854
  %1858 = icmp eq i64 %1857, 0
  %1859 = sub i64 %1854, %1857
  %1860 = select i1 %1858, i64 0, i64 %1859
  %1861 = add i64 %1853, %1848
  %1862 = add i64 %1861, %1860
  %1863 = urem i64 %1862, %1856
  %1864 = icmp eq i64 %1863, 0
  %1865 = sub i64 %1856, %1863
  %1866 = select i1 %1864, i64 0, i64 %1865
  %1867 = add i64 %1866, %1862
  %result.i.i508 = call noalias ptr @bump_malloc_inner(i64 noundef %1867, ptr nonnull @current_ptr) #29
  store ptr %1834, ptr %result.i.i508, align 8
  %1868 = getelementptr i8, ptr %result.i.i508, i64 8
  store ptr %1836, ptr %1868, align 8
  %1869 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i.i508)
  store ptr @Entry, ptr %128, align 8
  store ptr %result.i.i508, ptr %241, align 8
  store i32 9, ptr %242, align 8
  %1870 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %128)
  %1871 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1872 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1873 = load ptr, ptr %1834, align 8
  %1874 = getelementptr i8, ptr %1873, i64 48
  %1875 = load ptr, ptr %1874, align 8
  %1876 = call { i64, i64 } %1875(ptr nonnull %1834)
  %1877 = extractvalue { i64, i64 } %1876, 1
  %1878 = urem i64 20, %1877
  %1879 = icmp eq i64 %1878, 0
  %reass.sub3550 = sub i64 %1877, %1878
  %1880 = add i64 %reass.sub3550, 20
  %1881 = select i1 %1879, i64 20, i64 %1880
  %1882 = getelementptr i8, ptr %result.i.i508, i64 %1881
  %1883 = load ptr, ptr %result.i.i508, align 8
  %1884 = load ptr, ptr %1883, align 8
  %1885 = getelementptr i8, ptr %1884, i64 64
  %1886 = load ptr, ptr %1885, align 8
  call void %1886({ ptr, i160 } %332, ptr nonnull %1883, ptr %1882)
  %1887 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1888 = load ptr, ptr %result.i.i508, align 8
  %1889 = load ptr, ptr %1888, align 8
  %1890 = getelementptr i8, ptr %1889, i64 48
  %1891 = load ptr, ptr %1890, align 8
  %1892 = call { i64, i64 } %1891(ptr nonnull %1888)
  %1893 = extractvalue { i64, i64 } %1892, 0
  %1894 = extractvalue { i64, i64 } %1892, 1
  %1895 = urem i64 20, %1894
  %1896 = icmp eq i64 %1895, 0
  %1897 = sub i64 %1894, %1895
  %1898 = select i1 %1896, i64 0, i64 %1897
  %1899 = add i64 %1893, 20
  %1900 = add i64 %1899, %1898
  %1901 = load ptr, ptr %1868, align 8
  %1902 = load ptr, ptr %1901, align 8
  %1903 = getelementptr i8, ptr %1902, i64 48
  %1904 = load ptr, ptr %1903, align 8
  %1905 = call { i64, i64 } %1904(ptr nonnull %1901)
  %1906 = extractvalue { i64, i64 } %1905, 1
  %1907 = urem i64 %1900, %1906
  %1908 = icmp eq i64 %1907, 0
  %1909 = sub i64 %1906, %1907
  %1910 = select i1 %1908, i64 0, i64 %1909
  %1911 = getelementptr i8, ptr %result.i.i508, i64 %1900
  %1912 = getelementptr i8, ptr %1911, i64 %1910
  %1913 = load ptr, ptr %1868, align 8
  %1914 = load ptr, ptr %1913, align 8
  %1915 = getelementptr i8, ptr %1914, i64 64
  %1916 = load ptr, ptr %1915, align 8
  call void %1916({ ptr, i160 } %1763, ptr nonnull %1913, ptr %1912)
  %1917 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %1918 = getelementptr i8, ptr %result.i.i508, i64 16
  store i32 %1766, ptr %1918, align 4
  %1919 = load ptr, ptr %243, align 8
  %1920 = ptrtoint ptr %result.i.i508 to i64
  %1921 = ptrtoint ptr %1919 to i64
  %.sroa.2127.0.insert.ext.i = zext i64 %1921 to i160
  %.sroa.2127.0.insert.shift.i = shl nuw nsw i160 %.sroa.2127.0.insert.ext.i, 64
  %.sroa.0126.0.insert.ext.i = zext i64 %1920 to i160
  %.sroa.2127.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.shift.i, %.sroa.0126.0.insert.ext.i
  %.sroa.0126.0.insert.insert.i = or disjoint i160 %.sroa.2127.0.insert.insert.i, 3062541302288446171170371466885913903104
  %1922 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0126.0.insert.insert.i, 1
  %1923 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1924 = load ptr, ptr %205, align 8
  %1925 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1924, 0
  %1926 = load ptr, ptr %206, align 8
  %1927 = insertvalue { ptr, ptr, ptr, i32 } %1925, ptr %1926, 1
  %1928 = load ptr, ptr %207, align 8
  %1929 = insertvalue { ptr, ptr, ptr, i32 } %1927, ptr %1928, 2
  %1930 = load i32, ptr %208, align 4
  %1931 = insertvalue { ptr, ptr, ptr, i32 } %1929, i32 %1930, 3
  %hash_coef_ptr.i.i204.i = getelementptr i8, ptr %1924, i64 8
  %tbl_size_ptr.i.i205.i = getelementptr i8, ptr %1924, i64 16
  %offset_tbl_ptr.i.i206.i = getelementptr i8, ptr %1924, i64 40
  %hash_coef.i.i207.i = load i64, ptr %hash_coef_ptr.i.i204.i, align 4
  %tbl_size.i.i208.i = load i64, ptr %tbl_size_ptr.i.i205.i, align 4
  %offset_tbl.i.i209.i = load ptr, ptr %offset_tbl_ptr.i.i206.i, align 8
  %product.i.i.i210.i = mul i64 %hash_coef.i.i207.i, -5261542750394134544
  %shifted.i.i.i211.i = lshr i64 %product.i.i.i210.i, 32
  %xored.i.i.i212.i = xor i64 %shifted.i.i.i211.i, %product.i.i.i210.i
  %hash.i.i.i213.i = and i64 %xored.i.i.i212.i, %tbl_size.i.i208.i
  %offset_ptr.i.i214.i = getelementptr i32, ptr %offset_tbl.i.i209.i, i64 %hash.i.i.i213.i
  %offset.i.i215.i = load i32, ptr %offset_ptr.i.i214.i, align 4
  %eq.i218.i = icmp eq i32 %1930, %offset.i.i215.i
  call void @llvm.assume(i1 %eq.i218.i) #30
  %1932 = load ptr, ptr %result.i134, align 8
  %1933 = load ptr, ptr %188, align 8
  %result.i219.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %1934 = getelementptr i8, ptr %result.i219.i, i64 16
  store ptr %1933, ptr %1934, align 8
  %1935 = getelementptr i8, ptr %result.i219.i, i64 8
  store ptr %1932, ptr %1935, align 8
  %1936 = getelementptr i8, ptr %result.i219.i, i64 24
  store ptr null, ptr %1936, align 8
  %1937 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i219.i)
  store ptr @Entry, ptr %result.i219.i, align 8
  store ptr @_parameterization_Ptri32, ptr %129, align 8
  store ptr %result.i219.i, ptr %244, align 8
  %1938 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %129)
  %1939 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1924)
  %1940 = sext i32 %1930 to i64
  %1941 = getelementptr ptr, ptr %1924, i64 %1940
  %1942 = getelementptr i8, ptr %1941, i64 128
  %1943 = load ptr, ptr %1942, align 8
  store ptr @i32_typ, ptr %130, align 8
  store ptr @Entry, ptr %245, align 8
  %1944 = call ptr %1943({ ptr, ptr, ptr, i32 } %1931, ptr nonnull %130)
  call void %1944({ ptr, ptr, ptr, i32 } %1931, { ptr, ptr, ptr, i32 } %1931, ptr nonnull %129, i32 %1785, { ptr, i160 } %1922)
  br label %HashMap_insert_keyK_valueV.exit

.critedge.i500:                                   ; preds = %1805, %HashMap_insert_keyK_valueV.exit800
  %1945 = add i32 %1766, 2127912214
  %1946 = shl i32 %1766, 12
  %1947 = add i32 %1945, %1946
  %1948 = ashr i32 %1947, 19
  %1949 = xor i32 %1947, %1948
  %1950 = xor i32 %1949, -949894596
  %1951 = add i32 %1950, 374761393
  %1952 = shl i32 %1950, 5
  %1953 = add i32 %1951, %1952
  %1954 = add i32 %1953, -744332180
  %1955 = shl i32 %1953, 9
  %1956 = xor i32 %1954, %1955
  %1957 = add i32 %1956, -42973499
  %1958 = shl i32 %1956, 3
  %1959 = add i32 %1957, %1958
  %1960 = ashr i32 %1959, 16
  %1961 = xor i32 %1959, %1960
  %1962 = xor i32 %1961, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1963 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1964 = load ptr, ptr %222, align 8
  %1965 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1964, 0
  %1966 = load ptr, ptr %223, align 8
  %1967 = insertvalue { ptr, ptr, ptr, i32 } %1965, ptr %1966, 1
  %1968 = load ptr, ptr %224, align 8
  %1969 = insertvalue { ptr, ptr, ptr, i32 } %1967, ptr %1968, 2
  %1970 = load i32, ptr %225, align 4
  %1971 = insertvalue { ptr, ptr, ptr, i32 } %1969, i32 %1970, 3
  %hash_coef_ptr.i.i10.i1070 = getelementptr i8, ptr %1964, i64 8
  %tbl_size_ptr.i.i11.i1071 = getelementptr i8, ptr %1964, i64 16
  %offset_tbl_ptr.i.i12.i1072 = getelementptr i8, ptr %1964, i64 40
  %hash_coef.i.i13.i1073 = load i64, ptr %hash_coef_ptr.i.i10.i1070, align 4
  %tbl_size.i.i14.i1074 = load i64, ptr %tbl_size_ptr.i.i11.i1071, align 4
  %offset_tbl.i.i15.i1075 = load ptr, ptr %offset_tbl_ptr.i.i12.i1072, align 8
  %product.i.i.i16.i1076 = mul i64 %hash_coef.i.i13.i1073, -5261542750394134544
  %shifted.i.i.i17.i1077 = lshr i64 %product.i.i.i16.i1076, 32
  %xored.i.i.i18.i1078 = xor i64 %shifted.i.i.i17.i1077, %product.i.i.i16.i1076
  %hash.i.i.i19.i1079 = and i64 %xored.i.i.i18.i1078, %tbl_size.i.i14.i1074
  %offset_ptr.i.i20.i1080 = getelementptr i32, ptr %offset_tbl.i.i15.i1075, i64 %hash.i.i.i19.i1079
  %offset.i.i21.i1081 = load i32, ptr %offset_ptr.i.i20.i1080, align 4
  %eq.i.i1082 = icmp eq i32 %1970, %offset.i.i21.i1081
  call void @llvm.assume(i1 %eq.i.i1082) #30
  %1972 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %1973 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1964)
  %1974 = sext i32 %1970 to i64
  %1975 = getelementptr ptr, ptr %1964, i64 %1974
  %1976 = getelementptr i8, ptr %1975, i64 64
  %1977 = load ptr, ptr %1976, align 8
  %1978 = call ptr %1977({ ptr, ptr, ptr, i32 } %1971, ptr nonnull %2)
  %1979 = call i32 %1978({ ptr, ptr, ptr, i32 } %1971, { ptr, ptr, ptr, i32 } %1971, ptr nonnull %2)
  %1980 = add i32 %1979, -1
  %1981 = and i32 %1980, %1962
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1982 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %1983 = load ptr, ptr %222, align 8
  %1984 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1983, 0
  %1985 = load ptr, ptr %223, align 8
  %1986 = insertvalue { ptr, ptr, ptr, i32 } %1984, ptr %1985, 1
  %1987 = load ptr, ptr %224, align 8
  %1988 = insertvalue { ptr, ptr, ptr, i32 } %1986, ptr %1987, 2
  %1989 = load i32, ptr %225, align 4
  %1990 = insertvalue { ptr, ptr, ptr, i32 } %1988, i32 %1989, 3
  %hash_coef_ptr.i.i221.i = getelementptr i8, ptr %1983, i64 8
  %tbl_size_ptr.i.i222.i = getelementptr i8, ptr %1983, i64 16
  %offset_tbl_ptr.i.i223.i = getelementptr i8, ptr %1983, i64 40
  %hash_coef.i.i224.i = load i64, ptr %hash_coef_ptr.i.i221.i, align 4
  %tbl_size.i.i225.i = load i64, ptr %tbl_size_ptr.i.i222.i, align 4
  %offset_tbl.i.i226.i = load ptr, ptr %offset_tbl_ptr.i.i223.i, align 8
  %product.i.i.i227.i = mul i64 %hash_coef.i.i224.i, -5261542750394134544
  %shifted.i.i.i228.i = lshr i64 %product.i.i.i227.i, 32
  %xored.i.i.i229.i = xor i64 %shifted.i.i.i228.i, %product.i.i.i227.i
  %hash.i.i.i230.i = and i64 %xored.i.i.i229.i, %tbl_size.i.i225.i
  %offset_ptr.i.i231.i = getelementptr i32, ptr %offset_tbl.i.i226.i, i64 %hash.i.i.i230.i
  %offset.i.i232.i = load i32, ptr %offset_ptr.i.i231.i, align 4
  %eq.i235.i = icmp eq i32 %1989, %offset.i.i232.i
  call void @llvm.assume(i1 %eq.i235.i) #30
  store ptr @_parameterization_Ptri32, ptr %131, align 8
  %1991 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %131)
  %1992 = call ptr @llvm.invariant.start.p0(i64 600, ptr %1983)
  %1993 = sext i32 %1989 to i64
  %1994 = getelementptr ptr, ptr %1983, i64 %1993
  %1995 = getelementptr i8, ptr %1994, i64 120
  %1996 = load ptr, ptr %1995, align 8
  store ptr @i32_typ, ptr %132, align 8
  %1997 = call ptr %1996({ ptr, ptr, ptr, i32 } %1990, ptr nonnull %132)
  %1998 = call { ptr, i160 } %1997({ ptr, ptr, ptr, i32 } %1990, { ptr, ptr, ptr, i32 } %1990, ptr nonnull %131, i32 %1981)
  %.fca.0.extract102.i = extractvalue { ptr, i160 } %1998, 0
  %1999 = icmp ne ptr %.fca.0.extract102.i, @nil_typ
  %2000 = icmp ne ptr %.fca.0.extract102.i, null
  %.not151.i = and i1 %1999, %2000
  br i1 %.not151.i, label %2001, label %.critedge158.i

2001:                                             ; preds = %.critedge.i500
  %.fca.1.extract104.i = extractvalue { ptr, i160 } %1998, 1
  %.sroa.4.8.extract.trunc.i = trunc i160 %.fca.1.extract104.i to i64
  %2002 = inttoptr i64 %.sroa.4.8.extract.trunc.i to ptr
  %.sroa.7508.8.extract.shift.i = lshr i160 %.fca.1.extract104.i, 64
  %.sroa.7508.8.extract.trunc.i = trunc i160 %.sroa.7508.8.extract.shift.i to i64
  %2003 = inttoptr i64 %.sroa.7508.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i237.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 8
  %tbl_size_ptr.i.i238.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 16
  %offset_tbl_ptr.i.i239.i = getelementptr i8, ptr %.fca.0.extract102.i, i64 40
  %hash_coef.i.i240.i = load i64, ptr %hash_coef_ptr.i.i237.i, align 4
  %tbl_size.i.i241.i = load i64, ptr %tbl_size_ptr.i.i238.i, align 4
  %offset_tbl.i.i242.i = load ptr, ptr %offset_tbl_ptr.i.i239.i, align 8
  %product.i.i.i243.i = mul i64 %hash_coef.i.i240.i, 4015701072841558310
  %shifted.i.i.i244.i = lshr i64 %product.i.i.i243.i, 32
  %xored.i.i.i245.i = xor i64 %shifted.i.i.i244.i, %product.i.i.i243.i
  %hash.i.i.i246.i = and i64 %xored.i.i.i245.i, %tbl_size.i.i241.i
  %offset_ptr.i.i247.i = getelementptr i32, ptr %offset_tbl.i.i242.i, i64 %hash.i.i.i246.i
  %offset.i.i248.i = load i32, ptr %offset_ptr.i.i247.i, align 4
  %2004 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract102.i, 0
  %2005 = insertvalue { ptr, ptr, ptr, i32 } %2004, ptr %2002, 1
  %2006 = insertvalue { ptr, ptr, ptr, i32 } %2005, ptr %2003, 2
  %2007 = insertvalue { ptr, ptr, ptr, i32 } %2006, i32 %offset.i.i248.i, 3
  %2008 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2009 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2010 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %2011 = sext i32 %offset.i.i248.i to i64
  %2012 = getelementptr ptr, ptr %.fca.0.extract102.i, i64 %2011
  %2013 = getelementptr i8, ptr %2012, i64 64
  %2014 = load ptr, ptr %2013, align 8
  %2015 = call ptr %2014({ ptr, ptr, ptr, i32 } %2007, ptr nonnull %2)
  %2016 = call i32 %2015({ ptr, ptr, ptr, i32 } %2007, { ptr, ptr, ptr, i32 } %2007, ptr nonnull %2)
  %2017 = icmp eq i32 %2016, %1766
  %2018 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2019 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2020 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract102.i)
  %2021 = getelementptr i8, ptr %2012, i64 48
  %2022 = load ptr, ptr %2021, align 8
  %2023 = call ptr %2022({ ptr, ptr, ptr, i32 } %2007, ptr nonnull %2)
  %2024 = call { ptr, i160 } %2023({ ptr, ptr, ptr, i32 } %2007, { ptr, ptr, ptr, i32 } %2007, ptr nonnull %2)
  %2025 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2026 = load ptr, ptr %194, align 8
  %2027 = call i1 %2026({ ptr, i160 } %2024, { ptr, i160 } %332)
  %2028 = and i1 %2017, %2027
  br i1 %2028, label %2029, label %.critedge158.i

2029:                                             ; preds = %2001
  %2030 = load ptr, ptr %result.i134, align 8
  %2031 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2032 = load ptr, ptr %188, align 8
  %2033 = load ptr, ptr %2030, align 8
  %2034 = getelementptr i8, ptr %2033, i64 48
  %2035 = load ptr, ptr %2034, align 8
  %2036 = call { i64, i64 } %2035(ptr nonnull %2030)
  %2037 = extractvalue { i64, i64 } %2036, 0
  %2038 = extractvalue { i64, i64 } %2036, 1
  %2039 = urem i64 20, %2038
  %2040 = icmp eq i64 %2039, 0
  %2041 = sub i64 %2038, %2039
  %2042 = select i1 %2040, i64 0, i64 %2041
  %2043 = add i64 %2037, 20
  %2044 = add i64 %2043, %2042
  %2045 = load ptr, ptr %2032, align 8
  %2046 = getelementptr i8, ptr %2045, i64 48
  %2047 = load ptr, ptr %2046, align 8
  %2048 = call { i64, i64 } %2047(ptr nonnull %2032)
  %2049 = extractvalue { i64, i64 } %2048, 0
  %2050 = extractvalue { i64, i64 } %2048, 1
  %2051 = call i64 @llvm.umax.i64(i64 %2038, i64 %2050)
  %2052 = call i64 @llvm.umax.i64(i64 %2051, i64 8)
  %2053 = urem i64 %2044, %2050
  %2054 = icmp eq i64 %2053, 0
  %2055 = sub i64 %2050, %2053
  %2056 = select i1 %2054, i64 0, i64 %2055
  %2057 = add i64 %2049, %2044
  %2058 = add i64 %2057, %2056
  %2059 = urem i64 %2058, %2052
  %2060 = icmp eq i64 %2059, 0
  %2061 = sub i64 %2052, %2059
  %2062 = select i1 %2060, i64 0, i64 %2061
  %2063 = add i64 %2062, %2058
  %result.i250.i = call noalias ptr @bump_malloc_inner(i64 noundef %2063, ptr nonnull @current_ptr) #29
  store ptr %2030, ptr %result.i250.i, align 8
  %2064 = getelementptr i8, ptr %result.i250.i, i64 8
  store ptr %2032, ptr %2064, align 8
  %2065 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i250.i)
  store ptr @Entry, ptr %133, align 8
  store ptr %result.i250.i, ptr %236, align 8
  store i32 9, ptr %237, align 8
  %2066 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %133)
  %2067 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2068 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2069 = load ptr, ptr %2030, align 8
  %2070 = getelementptr i8, ptr %2069, i64 48
  %2071 = load ptr, ptr %2070, align 8
  %2072 = call { i64, i64 } %2071(ptr nonnull %2030)
  %2073 = extractvalue { i64, i64 } %2072, 1
  %2074 = urem i64 20, %2073
  %2075 = icmp eq i64 %2074, 0
  %reass.sub3549 = sub i64 %2073, %2074
  %2076 = add i64 %reass.sub3549, 20
  %2077 = select i1 %2075, i64 20, i64 %2076
  %2078 = getelementptr i8, ptr %result.i250.i, i64 %2077
  %2079 = load ptr, ptr %result.i250.i, align 8
  %2080 = load ptr, ptr %2079, align 8
  %2081 = getelementptr i8, ptr %2080, i64 64
  %2082 = load ptr, ptr %2081, align 8
  call void %2082({ ptr, i160 } %332, ptr nonnull %2079, ptr %2078)
  %2083 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2084 = load ptr, ptr %result.i250.i, align 8
  %2085 = load ptr, ptr %2084, align 8
  %2086 = getelementptr i8, ptr %2085, i64 48
  %2087 = load ptr, ptr %2086, align 8
  %2088 = call { i64, i64 } %2087(ptr nonnull %2084)
  %2089 = extractvalue { i64, i64 } %2088, 0
  %2090 = extractvalue { i64, i64 } %2088, 1
  %2091 = urem i64 20, %2090
  %2092 = icmp eq i64 %2091, 0
  %2093 = sub i64 %2090, %2091
  %2094 = select i1 %2092, i64 0, i64 %2093
  %2095 = add i64 %2089, 20
  %2096 = add i64 %2095, %2094
  %2097 = load ptr, ptr %2064, align 8
  %2098 = load ptr, ptr %2097, align 8
  %2099 = getelementptr i8, ptr %2098, i64 48
  %2100 = load ptr, ptr %2099, align 8
  %2101 = call { i64, i64 } %2100(ptr nonnull %2097)
  %2102 = extractvalue { i64, i64 } %2101, 1
  %2103 = urem i64 %2096, %2102
  %2104 = icmp eq i64 %2103, 0
  %2105 = sub i64 %2102, %2103
  %2106 = select i1 %2104, i64 0, i64 %2105
  %2107 = getelementptr i8, ptr %result.i250.i, i64 %2096
  %2108 = getelementptr i8, ptr %2107, i64 %2106
  %2109 = load ptr, ptr %2064, align 8
  %2110 = load ptr, ptr %2109, align 8
  %2111 = getelementptr i8, ptr %2110, i64 64
  %2112 = load ptr, ptr %2111, align 8
  call void %2112({ ptr, i160 } %1763, ptr nonnull %2109, ptr %2108)
  %2113 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2114 = getelementptr i8, ptr %result.i250.i, i64 16
  store i32 %1766, ptr %2114, align 4
  %2115 = load ptr, ptr %238, align 8
  %2116 = ptrtoint ptr %result.i250.i to i64
  %2117 = ptrtoint ptr %2115 to i64
  %.sroa.282.0.insert.ext.i = zext i64 %2117 to i160
  %.sroa.282.0.insert.shift.i = shl nuw nsw i160 %.sroa.282.0.insert.ext.i, 64
  %.sroa.081.0.insert.ext.i = zext i64 %2116 to i160
  %.sroa.282.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.shift.i, %.sroa.081.0.insert.ext.i
  %.sroa.081.0.insert.insert.i = or disjoint i160 %.sroa.282.0.insert.insert.i, 3062541302288446171170371466885913903104
  %2118 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.081.0.insert.insert.i, 1
  %2119 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2120 = load ptr, ptr %222, align 8
  %2121 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2120, 0
  %2122 = load ptr, ptr %223, align 8
  %2123 = insertvalue { ptr, ptr, ptr, i32 } %2121, ptr %2122, 1
  %2124 = load ptr, ptr %224, align 8
  %2125 = insertvalue { ptr, ptr, ptr, i32 } %2123, ptr %2124, 2
  %2126 = load i32, ptr %225, align 4
  %2127 = insertvalue { ptr, ptr, ptr, i32 } %2125, i32 %2126, 3
  %hash_coef_ptr.i.i266.i = getelementptr i8, ptr %2120, i64 8
  %tbl_size_ptr.i.i267.i = getelementptr i8, ptr %2120, i64 16
  %offset_tbl_ptr.i.i268.i = getelementptr i8, ptr %2120, i64 40
  %hash_coef.i.i269.i = load i64, ptr %hash_coef_ptr.i.i266.i, align 4
  %tbl_size.i.i270.i = load i64, ptr %tbl_size_ptr.i.i267.i, align 4
  %offset_tbl.i.i271.i = load ptr, ptr %offset_tbl_ptr.i.i268.i, align 8
  %product.i.i.i272.i = mul i64 %hash_coef.i.i269.i, -5261542750394134544
  %shifted.i.i.i273.i = lshr i64 %product.i.i.i272.i, 32
  %xored.i.i.i274.i = xor i64 %shifted.i.i.i273.i, %product.i.i.i272.i
  %hash.i.i.i275.i = and i64 %xored.i.i.i274.i, %tbl_size.i.i270.i
  %offset_ptr.i.i276.i = getelementptr i32, ptr %offset_tbl.i.i271.i, i64 %hash.i.i.i275.i
  %offset.i.i277.i = load i32, ptr %offset_ptr.i.i276.i, align 4
  %eq.i280.i = icmp eq i32 %2126, %offset.i.i277.i
  call void @llvm.assume(i1 %eq.i280.i) #30
  %2128 = load ptr, ptr %result.i134, align 8
  %2129 = load ptr, ptr %188, align 8
  %result.i281.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2130 = getelementptr i8, ptr %result.i281.i, i64 16
  store ptr %2129, ptr %2130, align 8
  %2131 = getelementptr i8, ptr %result.i281.i, i64 8
  store ptr %2128, ptr %2131, align 8
  %2132 = getelementptr i8, ptr %result.i281.i, i64 24
  store ptr null, ptr %2132, align 8
  %2133 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i281.i)
  store ptr @Entry, ptr %result.i281.i, align 8
  store ptr @_parameterization_Ptri32, ptr %134, align 8
  store ptr %result.i281.i, ptr %239, align 8
  %2134 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %134)
  %2135 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2120)
  %2136 = sext i32 %2126 to i64
  %2137 = getelementptr ptr, ptr %2120, i64 %2136
  %2138 = getelementptr i8, ptr %2137, i64 128
  %2139 = load ptr, ptr %2138, align 8
  store ptr @i32_typ, ptr %135, align 8
  store ptr @Entry, ptr %240, align 8
  %2140 = call ptr %2139({ ptr, ptr, ptr, i32 } %2127, ptr nonnull %135)
  call void %2140({ ptr, ptr, ptr, i32 } %2127, { ptr, ptr, ptr, i32 } %2127, ptr nonnull %134, i32 %1981, { ptr, i160 } %2118)
  br label %HashMap_insert_keyK_valueV.exit

.critedge158.i:                                   ; preds = %2001, %.critedge.i500
  %2141 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2142 = load ptr, ptr %205, align 8
  %2143 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2142, 0
  %2144 = load ptr, ptr %206, align 8
  %2145 = insertvalue { ptr, ptr, ptr, i32 } %2143, ptr %2144, 1
  %2146 = load ptr, ptr %207, align 8
  %2147 = insertvalue { ptr, ptr, ptr, i32 } %2145, ptr %2146, 2
  %2148 = load i32, ptr %208, align 4
  %2149 = insertvalue { ptr, ptr, ptr, i32 } %2147, i32 %2148, 3
  %hash_coef_ptr.i.i283.i = getelementptr i8, ptr %2142, i64 8
  %tbl_size_ptr.i.i284.i = getelementptr i8, ptr %2142, i64 16
  %offset_tbl_ptr.i.i285.i = getelementptr i8, ptr %2142, i64 40
  %hash_coef.i.i286.i = load i64, ptr %hash_coef_ptr.i.i283.i, align 4
  %tbl_size.i.i287.i = load i64, ptr %tbl_size_ptr.i.i284.i, align 4
  %offset_tbl.i.i288.i = load ptr, ptr %offset_tbl_ptr.i.i285.i, align 8
  %product.i.i.i289.i = mul i64 %hash_coef.i.i286.i, -5261542750394134544
  %shifted.i.i.i290.i = lshr i64 %product.i.i.i289.i, 32
  %xored.i.i.i291.i = xor i64 %shifted.i.i.i290.i, %product.i.i.i289.i
  %hash.i.i.i292.i = and i64 %xored.i.i.i291.i, %tbl_size.i.i287.i
  %offset_ptr.i.i293.i = getelementptr i32, ptr %offset_tbl.i.i288.i, i64 %hash.i.i.i292.i
  %offset.i.i294.i = load i32, ptr %offset_ptr.i.i293.i, align 4
  %eq.i297.i = icmp eq i32 %2148, %offset.i.i294.i
  call void @llvm.assume(i1 %eq.i297.i) #30
  %2150 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2151 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2142)
  %2152 = sext i32 %2148 to i64
  %2153 = getelementptr ptr, ptr %2142, i64 %2152
  %2154 = getelementptr i8, ptr %2153, i64 64
  %2155 = load ptr, ptr %2154, align 8
  %2156 = call ptr %2155({ ptr, ptr, ptr, i32 } %2149, ptr nonnull %2)
  %2157 = call i32 %2156({ ptr, ptr, ptr, i32 } %2149, { ptr, ptr, ptr, i32 } %2149, ptr nonnull %2)
  %2158 = load i32, ptr %226, align 4
  %.not.i = icmp slt i32 %2158, %2157
  br i1 %.not.i, label %._crit_edge.i, label %2159

2159:                                             ; preds = %.critedge158.i
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %99)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %100)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %101)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %102)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %103)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %104)
  %2160 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2161 = load ptr, ptr %205, align 8
  %2162 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2161, 0
  %2163 = load ptr, ptr %206, align 8
  %2164 = insertvalue { ptr, ptr, ptr, i32 } %2162, ptr %2163, 1
  %2165 = load ptr, ptr %207, align 8
  %2166 = insertvalue { ptr, ptr, ptr, i32 } %2164, ptr %2165, 2
  %2167 = load i32, ptr %208, align 4
  %2168 = insertvalue { ptr, ptr, ptr, i32 } %2166, i32 %2167, 3
  %hash_coef_ptr.i.i64.i = getelementptr i8, ptr %2161, i64 8
  %tbl_size_ptr.i.i65.i = getelementptr i8, ptr %2161, i64 16
  %offset_tbl_ptr.i.i66.i = getelementptr i8, ptr %2161, i64 40
  %hash_coef.i.i67.i = load i64, ptr %hash_coef_ptr.i.i64.i, align 4
  %tbl_size.i.i68.i = load i64, ptr %tbl_size_ptr.i.i65.i, align 4
  %offset_tbl.i.i69.i = load ptr, ptr %offset_tbl_ptr.i.i66.i, align 8
  %product.i.i.i70.i = mul i64 %hash_coef.i.i67.i, -5261542750394134544
  %shifted.i.i.i71.i = lshr i64 %product.i.i.i70.i, 32
  %xored.i.i.i72.i = xor i64 %shifted.i.i.i71.i, %product.i.i.i70.i
  %hash.i.i.i73.i = and i64 %xored.i.i.i72.i, %tbl_size.i.i68.i
  %offset_ptr.i.i74.i = getelementptr i32, ptr %offset_tbl.i.i69.i, i64 %hash.i.i.i73.i
  %offset.i.i75.i = load i32, ptr %offset_ptr.i.i74.i, align 4
  %eq.i.i1096 = icmp eq i32 %2167, %offset.i.i75.i
  call void @llvm.assume(i1 %eq.i.i1096) #30
  %2169 = load ptr, ptr %222, align 8
  %2170 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2169, 0
  %2171 = load ptr, ptr %223, align 8
  %2172 = insertvalue { ptr, ptr, ptr, i32 } %2170, ptr %2171, 1
  %2173 = load ptr, ptr %224, align 8
  %2174 = insertvalue { ptr, ptr, ptr, i32 } %2172, ptr %2173, 2
  %2175 = load i32, ptr %225, align 4
  %2176 = insertvalue { ptr, ptr, ptr, i32 } %2174, i32 %2175, 3
  %hash_coef_ptr.i.i92.i = getelementptr i8, ptr %2169, i64 8
  %tbl_size_ptr.i.i93.i = getelementptr i8, ptr %2169, i64 16
  %offset_tbl_ptr.i.i94.i = getelementptr i8, ptr %2169, i64 40
  %hash_coef.i.i95.i = load i64, ptr %hash_coef_ptr.i.i92.i, align 4
  %tbl_size.i.i96.i = load i64, ptr %tbl_size_ptr.i.i93.i, align 4
  %offset_tbl.i.i97.i = load ptr, ptr %offset_tbl_ptr.i.i94.i, align 8
  %product.i.i.i98.i = mul i64 %hash_coef.i.i95.i, -5261542750394134544
  %shifted.i.i.i99.i = lshr i64 %product.i.i.i98.i, 32
  %xored.i.i.i100.i = xor i64 %shifted.i.i.i99.i, %product.i.i.i98.i
  %hash.i.i.i101.i = and i64 %xored.i.i.i100.i, %tbl_size.i.i96.i
  %offset_ptr.i.i102.i = getelementptr i32, ptr %offset_tbl.i.i97.i, i64 %hash.i.i.i101.i
  %offset.i.i103.i = load i32, ptr %offset_ptr.i.i102.i, align 4
  %eq.i106.i = icmp eq i32 %2175, %offset.i.i103.i
  call void @llvm.assume(i1 %eq.i106.i) #30
  %2177 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2178 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2161)
  %2179 = sext i32 %2167 to i64
  %2180 = getelementptr ptr, ptr %2161, i64 %2179
  %2181 = getelementptr i8, ptr %2180, i64 64
  %2182 = load ptr, ptr %2181, align 8
  %2183 = call ptr %2182({ ptr, ptr, ptr, i32 } %2168, ptr nonnull %2)
  %2184 = call i32 %2183({ ptr, ptr, ptr, i32 } %2168, { ptr, ptr, ptr, i32 } %2168, ptr nonnull %2)
  %2185 = shl i32 %2184, 1
  %2186 = load i32, ptr %226, align 4
  %2187 = load ptr, ptr %result.i134, align 8
  %2188 = load ptr, ptr %188, align 8
  %2189 = sext i32 %2186 to i64
  %2190 = shl nsw i64 %2189, 5
  %result.i.i.i1102 = call noalias ptr @bump_malloc_inner(i64 noundef %2190, ptr nonnull @current_ptr) #29
  %2191 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2192 = icmp sgt i32 %2184, 0
  br i1 %2192, label %.lr.ph434.i, label %._crit_edge395.i

.lr.ph434.i:                                      ; preds = %2159
  %invariant.gep.i = getelementptr i8, ptr %2161, i64 120
  %2193 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i = getelementptr ptr, ptr %invariant.gep.i, i64 %2179
  br label %2194

2194:                                             ; preds = %2216, %.lr.ph434.i
  %.reg2mem105.0432.i = phi i32 [ 0, %.lr.ph434.i ], [ %.reg2mem101.0.i, %2216 ]
  %.reg2mem103.0431.i = phi i32 [ 0, %.lr.ph434.i ], [ %2217, %2216 ]
  store ptr @_parameterization_Ptri32, ptr %99, align 8
  %2195 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %99)
  %2196 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2161)
  %2197 = load ptr, ptr %gep.i, align 8
  store ptr @i32_typ, ptr %100, align 8
  %2198 = call ptr %2197({ ptr, ptr, ptr, i32 } %2168, ptr nonnull %100)
  %2199 = call { ptr, i160 } %2198({ ptr, ptr, ptr, i32 } %2168, { ptr, ptr, ptr, i32 } %2168, ptr nonnull %99, i32 %.reg2mem103.0431.i)
  %.fca.0.extract52.i = extractvalue { ptr, i160 } %2199, 0
  %2200 = icmp ne ptr %.fca.0.extract52.i, @nil_typ
  %2201 = icmp ne ptr %.fca.0.extract52.i, null
  %.not60.i = and i1 %2200, %2201
  br i1 %.not60.i, label %2202, label %2216

2202:                                             ; preds = %2194
  %hash_coef_ptr.i.i137.i1104 = getelementptr i8, ptr %.fca.0.extract52.i, i64 8
  %tbl_size_ptr.i.i138.i1105 = getelementptr i8, ptr %.fca.0.extract52.i, i64 16
  %offset_tbl_ptr.i.i139.i1106 = getelementptr i8, ptr %.fca.0.extract52.i, i64 40
  %hash_coef.i.i140.i1107 = load i64, ptr %hash_coef_ptr.i.i137.i1104, align 4
  %tbl_size.i.i141.i1108 = load i64, ptr %tbl_size_ptr.i.i138.i1105, align 4
  %offset_tbl.i.i142.i1109 = load ptr, ptr %offset_tbl_ptr.i.i139.i1106, align 8
  %product.i.i.i143.i1110 = mul i64 %hash_coef.i.i140.i1107, 4015701072841558310
  %shifted.i.i.i144.i1111 = lshr i64 %product.i.i.i143.i1110, 32
  %xored.i.i.i145.i1112 = xor i64 %shifted.i.i.i144.i1111, %product.i.i.i143.i1110
  %hash.i.i.i146.i1113 = and i64 %xored.i.i.i145.i1112, %tbl_size.i.i141.i1108
  %offset_ptr.i.i147.i1114 = getelementptr i32, ptr %offset_tbl.i.i142.i1109, i64 %hash.i.i.i146.i1113
  %offset.i.i148.i1115 = load i32, ptr %offset_ptr.i.i147.i1114, align 4
  %2203 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2204 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2205 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2206 = icmp slt i32 %.reg2mem105.0432.i, %2186
  br i1 %2206, label %2207, label %._crit_edge.i1116

2207:                                             ; preds = %2202
  %.fca.1.extract54.i = extractvalue { ptr, i160 } %2199, 1
  %.sroa.351.0.insert.ext.i = zext i32 %offset.i.i148.i1115 to i160
  %.sroa.351.0.insert.shift.i = shl nuw i160 %.sroa.351.0.insert.ext.i, 128
  %2208 = and i160 %.fca.1.extract54.i, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i = or disjoint i160 %.sroa.351.0.insert.shift.i, %2208
  %2209 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2210 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2211 = sext i32 %.reg2mem105.0432.i to i64
  %2212 = shl nsw i64 %2211, 5
  %2213 = getelementptr i8, ptr %result.i.i.i1102, i64 %2212
  store ptr %.fca.0.extract52.i, ptr %2213, align 8
  %2214 = getelementptr i8, ptr %2213, i64 8
  store i160 %.sroa.049.0.insert.insert.i, ptr %2214, align 4
  br label %._crit_edge.i1116

._crit_edge.i1116:                                ; preds = %2207, %2202
  %2215 = add i32 %.reg2mem105.0432.i, 1
  br label %2216

2216:                                             ; preds = %._crit_edge.i1116, %2194
  %.reg2mem101.0.i = phi i32 [ %2215, %._crit_edge.i1116 ], [ %.reg2mem105.0432.i, %2194 ]
  %2217 = add nuw nsw i32 %.reg2mem103.0431.i, 1
  %2218 = icmp slt i32 %2217, %2184
  br i1 %2218, label %2194, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2216
  %invariant.gep396.i = getelementptr i8, ptr %2169, i64 120
  %2219 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2220 = sext i32 %2175 to i64
  %gep397.i = getelementptr ptr, ptr %invariant.gep396.i, i64 %2220
  br label %2221

2221:                                             ; preds = %2243, %.lr.ph.i
  %.reg2mem91.0394.i = phi i32 [ %.reg2mem101.0.i, %.lr.ph.i ], [ %.reg2mem87.0.i, %2243 ]
  %.reg2mem89.0393.i = phi i32 [ 0, %.lr.ph.i ], [ %2244, %2243 ]
  store ptr @_parameterization_Ptri32, ptr %101, align 8
  %2222 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %101)
  %2223 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2169)
  %2224 = load ptr, ptr %gep397.i, align 8
  store ptr @i32_typ, ptr %102, align 8
  %2225 = call ptr %2224({ ptr, ptr, ptr, i32 } %2176, ptr nonnull %102)
  %2226 = call { ptr, i160 } %2225({ ptr, ptr, ptr, i32 } %2176, { ptr, ptr, ptr, i32 } %2176, ptr nonnull %101, i32 %.reg2mem89.0393.i)
  %.fca.0.extract42.i = extractvalue { ptr, i160 } %2226, 0
  %2227 = icmp ne ptr %.fca.0.extract42.i, @nil_typ
  %2228 = icmp ne ptr %.fca.0.extract42.i, null
  %.not62.i = and i1 %2227, %2228
  br i1 %.not62.i, label %2229, label %2243

2229:                                             ; preds = %2221
  %hash_coef_ptr.i.i152.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 8
  %tbl_size_ptr.i.i153.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 16
  %offset_tbl_ptr.i.i154.i = getelementptr i8, ptr %.fca.0.extract42.i, i64 40
  %hash_coef.i.i155.i = load i64, ptr %hash_coef_ptr.i.i152.i, align 4
  %tbl_size.i.i156.i = load i64, ptr %tbl_size_ptr.i.i153.i, align 4
  %offset_tbl.i.i157.i = load ptr, ptr %offset_tbl_ptr.i.i154.i, align 8
  %product.i.i.i158.i = mul i64 %hash_coef.i.i155.i, 4015701072841558310
  %shifted.i.i.i159.i = lshr i64 %product.i.i.i158.i, 32
  %xored.i.i.i160.i = xor i64 %shifted.i.i.i159.i, %product.i.i.i158.i
  %hash.i.i.i161.i = and i64 %xored.i.i.i160.i, %tbl_size.i.i156.i
  %offset_ptr.i.i162.i = getelementptr i32, ptr %offset_tbl.i.i157.i, i64 %hash.i.i.i161.i
  %offset.i.i163.i = load i32, ptr %offset_ptr.i.i162.i, align 4
  %2230 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2231 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2232 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2233 = icmp slt i32 %.reg2mem91.0394.i, %2186
  br i1 %2233, label %2234, label %._crit_edge1.i1103

2234:                                             ; preds = %2229
  %.fca.1.extract44.i = extractvalue { ptr, i160 } %2226, 1
  %.sroa.3.0.insert.ext.i = zext i32 %offset.i.i163.i to i160
  %.sroa.3.0.insert.shift.i = shl nuw i160 %.sroa.3.0.insert.ext.i, 128
  %2235 = and i160 %.fca.1.extract44.i, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i = or disjoint i160 %.sroa.3.0.insert.shift.i, %2235
  %2236 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2237 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2238 = sext i32 %.reg2mem91.0394.i to i64
  %2239 = shl nsw i64 %2238, 5
  %2240 = getelementptr i8, ptr %result.i.i.i1102, i64 %2239
  store ptr %.fca.0.extract42.i, ptr %2240, align 8
  %2241 = getelementptr i8, ptr %2240, i64 8
  store i160 %.sroa.040.0.insert.insert.i, ptr %2241, align 4
  br label %._crit_edge1.i1103

._crit_edge1.i1103:                               ; preds = %2234, %2229
  %2242 = add i32 %.reg2mem91.0394.i, 1
  br label %2243

2243:                                             ; preds = %._crit_edge1.i1103, %2221
  %.reg2mem87.0.i = phi i32 [ %2242, %._crit_edge1.i1103 ], [ %.reg2mem91.0394.i, %2221 ]
  %2244 = add nuw nsw i32 %.reg2mem89.0393.i, 1
  %2245 = icmp slt i32 %2244, %2184
  br i1 %2245, label %2221, label %._crit_edge395.i.loopexit

._crit_edge395.i.loopexit:                        ; preds = %2243
  %.pre = load ptr, ptr %result.i134, align 8
  %.pre2835 = load ptr, ptr %188, align 8
  br label %._crit_edge395.i

._crit_edge395.i:                                 ; preds = %._crit_edge395.i.loopexit, %2159
  %2246 = phi ptr [ %2188, %2159 ], [ %.pre2835, %._crit_edge395.i.loopexit ]
  %2247 = phi ptr [ %2187, %2159 ], [ %.pre, %._crit_edge395.i.loopexit ]
  %.reg2mem91.0.lcssa.i = phi i32 [ 0, %2159 ], [ %.reg2mem87.0.i, %._crit_edge395.i.loopexit ]
  %2248 = call i32 @llvm.smax.i32(i32 %2185, i32 16)
  %result.i166.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2249 = getelementptr i8, ptr %result.i166.i, i64 16
  store ptr @_parameterization_Nil, ptr %2249, align 8
  %result.i167.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2250 = getelementptr i8, ptr %result.i167.i, i64 16
  store ptr %2246, ptr %2250, align 8
  %2251 = getelementptr i8, ptr %result.i167.i, i64 8
  store ptr %2247, ptr %2251, align 8
  %2252 = getelementptr i8, ptr %result.i167.i, i64 24
  store ptr null, ptr %2252, align 8
  %2253 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i)
  store ptr @Entry, ptr %result.i167.i, align 8
  %2254 = getelementptr i8, ptr %result.i166.i, i64 8
  store ptr %result.i167.i, ptr %2254, align 8
  %2255 = getelementptr i8, ptr %result.i166.i, i64 24
  store ptr null, ptr %2255, align 8
  %2256 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i)
  store ptr @union_typ, ptr %result.i166.i, align 8
  %result.i168.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i, ptr %result.i168.i, align 8
  %2257 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i)
  store ptr @Array, ptr %103, align 8
  store ptr %result.i168.i, ptr %262, align 8
  store i32 9, ptr %263, align 8
  %2258 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %103)
  %2259 = getelementptr i8, ptr %result.i168.i, i64 16
  store i32 %2248, ptr %2259, align 4
  %2260 = getelementptr i8, ptr %result.i168.i, i64 20
  store i32 %2248, ptr %2260, align 4
  %2261 = zext nneg i32 %2248 to i64
  %2262 = shl nuw nsw i64 %2261, 5
  %result.i.i416.i = call noalias ptr @bump_malloc_inner(i64 noundef %2262, ptr nonnull @current_ptr) #29
  %2263 = getelementptr i8, ptr %result.i168.i, i64 8
  store ptr %result.i.i416.i, ptr %2263, align 8
  %2264 = load ptr, ptr %264, align 8
  store ptr @Array, ptr %205, align 8
  store ptr %result.i168.i, ptr %206, align 8
  store ptr %2264, ptr %207, align 8
  store i32 9, ptr %208, align 4
  %2265 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2266 = getelementptr i8, ptr %result.i183.i, i64 16
  store ptr @_parameterization_Nil, ptr %2266, align 8
  %result.i184.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2267 = getelementptr i8, ptr %result.i184.i, i64 16
  store ptr %2246, ptr %2267, align 8
  %2268 = getelementptr i8, ptr %result.i184.i, i64 8
  store ptr %2247, ptr %2268, align 8
  %2269 = getelementptr i8, ptr %result.i184.i, i64 24
  store ptr null, ptr %2269, align 8
  %2270 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i)
  store ptr @Entry, ptr %result.i184.i, align 8
  %2271 = getelementptr i8, ptr %result.i183.i, i64 8
  store ptr %result.i184.i, ptr %2271, align 8
  %2272 = getelementptr i8, ptr %result.i183.i, i64 24
  store ptr null, ptr %2272, align 8
  %2273 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i)
  store ptr @union_typ, ptr %result.i183.i, align 8
  %result.i185.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i, ptr %result.i185.i, align 8
  %2274 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i)
  store ptr @Array, ptr %104, align 8
  store ptr %result.i185.i, ptr %265, align 8
  store i32 9, ptr %266, align 8
  %2275 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %104)
  %2276 = getelementptr i8, ptr %result.i185.i, i64 16
  store i32 %2248, ptr %2276, align 4
  %2277 = getelementptr i8, ptr %result.i185.i, i64 20
  store i32 %2248, ptr %2277, align 4
  %result.i.i430.i = call noalias ptr @bump_malloc_inner(i64 noundef %2262, ptr nonnull @current_ptr) #29
  %2278 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2279 = getelementptr i8, ptr %result.i185.i, i64 8
  store ptr %result.i.i430.i, ptr %2279, align 8
  %2280 = load ptr, ptr %267, align 8
  store ptr @Array, ptr %222, align 8
  store ptr %result.i185.i, ptr %223, align 8
  store ptr %2280, ptr %224, align 8
  store i32 9, ptr %225, align 4
  store i32 0, ptr %226, align 4
  %2281 = icmp sgt i32 %.reg2mem91.0.lcssa.i, 0
  br i1 %2281, label %.lr.ph400.i, label %HashMap_resize_.exit

.lr.ph400.i:                                      ; preds = %._crit_edge395.i
  %2282 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2283 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2284 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %._crit_edge2.i, %.lr.ph400.i
  %.reg2mem77.0398.i = phi i32 [ 0, %.lr.ph400.i ], [ %2298, %._crit_edge2.i ]
  %2285 = zext nneg i32 %.reg2mem77.0398.i to i64
  %2286 = shl nuw nsw i64 %2285, 5
  %2287 = getelementptr i8, ptr %result.i.i.i1102, i64 %2286
  %2288 = load ptr, ptr %2287, align 8
  %2289 = getelementptr i8, ptr %2287, i64 8
  %2290 = load i160, ptr %2289, align 4
  %.sroa.3362.8.extract.trunc.i = trunc i160 %2290 to i64
  %2291 = inttoptr i64 %.sroa.3362.8.extract.trunc.i to ptr
  %.sroa.5363.8.extract.shift.i = lshr i160 %2290, 64
  %.sroa.5363.8.extract.trunc.i = trunc i160 %.sroa.5363.8.extract.shift.i to i64
  %2292 = inttoptr i64 %.sroa.5363.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i201.i = getelementptr i8, ptr %2288, i64 8
  %tbl_size_ptr.i.i202.i = getelementptr i8, ptr %2288, i64 16
  %offset_tbl_ptr.i.i203.i = getelementptr i8, ptr %2288, i64 40
  %hash_coef.i.i232.i = load i64, ptr %hash_coef_ptr.i.i201.i, align 4
  %tbl_size.i.i233.i = load i64, ptr %tbl_size_ptr.i.i202.i, align 4
  %offset_tbl.i.i234.i = load ptr, ptr %offset_tbl_ptr.i.i203.i, align 8
  %product.i.i.i235.i = mul i64 %hash_coef.i.i232.i, 4015701072841558310
  %shifted.i.i.i236.i = lshr i64 %product.i.i.i235.i, 32
  %xored.i.i.i237.i = xor i64 %shifted.i.i.i236.i, %product.i.i.i235.i
  %hash.i.i.i238.i = and i64 %xored.i.i.i237.i, %tbl_size.i.i233.i
  %offset_ptr.i.i239.i = getelementptr i32, ptr %offset_tbl.i.i234.i, i64 %hash.i.i.i238.i
  %offset.i.i240.i = load i32, ptr %offset_ptr.i.i239.i, align 4
  %2293 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2288, 0
  %2294 = insertvalue { ptr, ptr, ptr, i32 } %2293, ptr %2291, 1
  %2295 = insertvalue { ptr, ptr, ptr, i32 } %2294, ptr %2292, 2
  %2296 = insertvalue { ptr, ptr, ptr, i32 } %2295, i32 %offset.i.i240.i, 3
  %2297 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2296)
  %2298 = add nuw nsw i32 %.reg2mem77.0398.i, 1
  %2299 = icmp slt i32 %2298, %.reg2mem91.0.lcssa.i
  br i1 %2299, label %._crit_edge2.i, label %HashMap_resize_.exit

HashMap_resize_.exit:                             ; preds = %._crit_edge2.i, %._crit_edge395.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %99)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %100)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %101)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %102)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %103)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %104)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %HashMap_resize_.exit, %.critedge158.i
  %2300 = load ptr, ptr %result.i134, align 8
  %2301 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2302 = load ptr, ptr %188, align 8
  %2303 = load ptr, ptr %2300, align 8
  %2304 = getelementptr i8, ptr %2303, i64 48
  %2305 = load ptr, ptr %2304, align 8
  %2306 = call { i64, i64 } %2305(ptr nonnull %2300)
  %2307 = extractvalue { i64, i64 } %2306, 0
  %2308 = extractvalue { i64, i64 } %2306, 1
  %2309 = urem i64 20, %2308
  %2310 = icmp eq i64 %2309, 0
  %2311 = sub i64 %2308, %2309
  %2312 = select i1 %2310, i64 0, i64 %2311
  %2313 = add i64 %2307, 20
  %2314 = add i64 %2313, %2312
  %2315 = load ptr, ptr %2302, align 8
  %2316 = getelementptr i8, ptr %2315, i64 48
  %2317 = load ptr, ptr %2316, align 8
  %2318 = call { i64, i64 } %2317(ptr nonnull %2302)
  %2319 = extractvalue { i64, i64 } %2318, 0
  %2320 = extractvalue { i64, i64 } %2318, 1
  %2321 = call i64 @llvm.umax.i64(i64 %2308, i64 %2320)
  %2322 = call i64 @llvm.umax.i64(i64 %2321, i64 8)
  %2323 = urem i64 %2314, %2320
  %2324 = icmp eq i64 %2323, 0
  %2325 = sub i64 %2320, %2323
  %2326 = select i1 %2324, i64 0, i64 %2325
  %2327 = add i64 %2319, %2314
  %2328 = add i64 %2327, %2326
  %2329 = urem i64 %2328, %2322
  %2330 = icmp eq i64 %2329, 0
  %2331 = sub i64 %2322, %2329
  %2332 = select i1 %2330, i64 0, i64 %2331
  %2333 = add i64 %2332, %2328
  %result.i298.i = call noalias ptr @bump_malloc_inner(i64 noundef %2333, ptr nonnull @current_ptr) #29
  store ptr %2300, ptr %result.i298.i, align 8
  %2334 = getelementptr i8, ptr %result.i298.i, i64 8
  store ptr %2302, ptr %2334, align 8
  %2335 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i298.i)
  store ptr @Entry, ptr %136, align 8
  store ptr %result.i298.i, ptr %233, align 8
  store i32 9, ptr %234, align 8
  %2336 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %136)
  %2337 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2338 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2339 = load ptr, ptr %2300, align 8
  %2340 = getelementptr i8, ptr %2339, i64 48
  %2341 = load ptr, ptr %2340, align 8
  %2342 = call { i64, i64 } %2341(ptr nonnull %2300)
  %2343 = extractvalue { i64, i64 } %2342, 1
  %2344 = urem i64 20, %2343
  %2345 = icmp eq i64 %2344, 0
  %reass.sub3548 = sub i64 %2343, %2344
  %2346 = add i64 %reass.sub3548, 20
  %2347 = select i1 %2345, i64 20, i64 %2346
  %2348 = getelementptr i8, ptr %result.i298.i, i64 %2347
  %2349 = load ptr, ptr %result.i298.i, align 8
  %2350 = load ptr, ptr %2349, align 8
  %2351 = getelementptr i8, ptr %2350, i64 64
  %2352 = load ptr, ptr %2351, align 8
  call void %2352({ ptr, i160 } %332, ptr nonnull %2349, ptr %2348)
  %2353 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2354 = load ptr, ptr %result.i298.i, align 8
  %2355 = load ptr, ptr %2354, align 8
  %2356 = getelementptr i8, ptr %2355, i64 48
  %2357 = load ptr, ptr %2356, align 8
  %2358 = call { i64, i64 } %2357(ptr nonnull %2354)
  %2359 = extractvalue { i64, i64 } %2358, 0
  %2360 = extractvalue { i64, i64 } %2358, 1
  %2361 = urem i64 20, %2360
  %2362 = icmp eq i64 %2361, 0
  %2363 = sub i64 %2360, %2361
  %2364 = select i1 %2362, i64 0, i64 %2363
  %2365 = add i64 %2359, 20
  %2366 = add i64 %2365, %2364
  %2367 = load ptr, ptr %2334, align 8
  %2368 = load ptr, ptr %2367, align 8
  %2369 = getelementptr i8, ptr %2368, i64 48
  %2370 = load ptr, ptr %2369, align 8
  %2371 = call { i64, i64 } %2370(ptr nonnull %2367)
  %2372 = extractvalue { i64, i64 } %2371, 1
  %2373 = urem i64 %2366, %2372
  %2374 = icmp eq i64 %2373, 0
  %2375 = sub i64 %2372, %2373
  %2376 = select i1 %2374, i64 0, i64 %2375
  %2377 = getelementptr i8, ptr %result.i298.i, i64 %2366
  %2378 = getelementptr i8, ptr %2377, i64 %2376
  %2379 = load ptr, ptr %2334, align 8
  %2380 = load ptr, ptr %2379, align 8
  %2381 = getelementptr i8, ptr %2380, i64 64
  %2382 = load ptr, ptr %2381, align 8
  call void %2382({ ptr, i160 } %1763, ptr nonnull %2379, ptr %2378)
  %2383 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  %2384 = getelementptr i8, ptr %result.i298.i, i64 16
  store i32 %1766, ptr %2384, align 4
  %2385 = load ptr, ptr %235, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1117)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %98)
  store ptr @Entry, ptr %98, align 8
  store ptr %result.i298.i, ptr %271, align 8
  store ptr %2385, ptr %272, align 8
  store i32 9, ptr %273, align 8
  %2386 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %98)
  %2387 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2388 = load i32, ptr %228, align 4
  %2389 = icmp sgt i32 %2388, 0
  br i1 %2389, label %.lr.ph.i1147, label %._crit_edge1.i

.lr.ph.i1147:                                     ; preds = %._crit_edge.i
  %2390 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2391 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %2392

2392:                                             ; preds = %.cont.cont.i, %.lr.ph.i1147
  %offset.i.i260.i1760 = phi i32 [ 9, %.lr.ph.i1147 ], [ %offset.i.i260.i, %.cont.cont.i ]
  %.sroa.speculated346.i1758 = phi ptr [ %2385, %.lr.ph.i1147 ], [ %.sroa.speculated346.i, %.cont.cont.i ]
  %.sroa.speculated352.i1756 = phi ptr [ %result.i298.i, %.lr.ph.i1147 ], [ %.sroa.speculated352.i, %.cont.cont.i ]
  %.reg2mem195.0678.i = phi i32 [ 1, %.lr.ph.i1147 ], [ %2548, %.cont.cont.i ]
  %.reg2mem193.0677.i = phi i32 [ 0, %.lr.ph.i1147 ], [ %2549, %.cont.cont.i ]
  %2393 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i1756, 1
  %2394 = insertvalue { ptr, ptr, ptr, i32 } %2393, ptr %.sroa.speculated346.i1758, 2
  %2395 = insertvalue { ptr, ptr, ptr, i32 } %2394, i32 %offset.i.i260.i1760, 3
  %2396 = sext i32 %offset.i.i260.i1760 to i64
  %gep1755 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %2396
  %2397 = load ptr, ptr %gep1755, align 8
  %2398 = call ptr %2397({ ptr, ptr, ptr, i32 } %2395, ptr nonnull %2)
  %2399 = call i32 %2398({ ptr, ptr, ptr, i32 } %2395, { ptr, ptr, ptr, i32 } %2395, ptr nonnull %2)
  %2400 = icmp eq i32 %.reg2mem195.0678.i, 1
  %2401 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %2400, label %2402, label %2466

2402:                                             ; preds = %2392
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2403 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2404 = load ptr, ptr %205, align 8
  %2405 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2404, 0
  %2406 = load ptr, ptr %206, align 8
  %2407 = insertvalue { ptr, ptr, ptr, i32 } %2405, ptr %2406, 1
  %2408 = load ptr, ptr %207, align 8
  %2409 = insertvalue { ptr, ptr, ptr, i32 } %2407, ptr %2408, 2
  %2410 = load i32, ptr %208, align 4
  %2411 = insertvalue { ptr, ptr, ptr, i32 } %2409, i32 %2410, 3
  %hash_coef_ptr.i.i10.i2928 = getelementptr i8, ptr %2404, i64 8
  %tbl_size_ptr.i.i11.i2929 = getelementptr i8, ptr %2404, i64 16
  %offset_tbl_ptr.i.i12.i2930 = getelementptr i8, ptr %2404, i64 40
  %hash_coef.i.i13.i2931 = load i64, ptr %hash_coef_ptr.i.i10.i2928, align 4
  %tbl_size.i.i14.i2932 = load i64, ptr %tbl_size_ptr.i.i11.i2929, align 4
  %offset_tbl.i.i15.i2933 = load ptr, ptr %offset_tbl_ptr.i.i12.i2930, align 8
  %product.i.i.i16.i2934 = mul i64 %hash_coef.i.i13.i2931, -5261542750394134544
  %shifted.i.i.i17.i2935 = lshr i64 %product.i.i.i16.i2934, 32
  %xored.i.i.i18.i2936 = xor i64 %shifted.i.i.i17.i2935, %product.i.i.i16.i2934
  %hash.i.i.i19.i2937 = and i64 %xored.i.i.i18.i2936, %tbl_size.i.i14.i2932
  %offset_ptr.i.i20.i2938 = getelementptr i32, ptr %offset_tbl.i.i15.i2933, i64 %hash.i.i.i19.i2937
  %offset.i.i21.i2939 = load i32, ptr %offset_ptr.i.i20.i2938, align 4
  %eq.i.i2940 = icmp eq i32 %2410, %offset.i.i21.i2939
  call void @llvm.assume(i1 %eq.i.i2940) #30
  %2412 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2413 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2404)
  %2414 = sext i32 %2410 to i64
  %2415 = getelementptr ptr, ptr %2404, i64 %2414
  %2416 = getelementptr i8, ptr %2415, i64 64
  %2417 = load ptr, ptr %2416, align 8
  %2418 = call ptr %2417({ ptr, ptr, ptr, i32 } %2411, ptr nonnull %2)
  %2419 = call i32 %2418({ ptr, ptr, ptr, i32 } %2411, { ptr, ptr, ptr, i32 } %2411, ptr nonnull %2)
  %2420 = add i32 %2419, -1
  %2421 = and i32 %2420, %2399
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2422 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2423 = load ptr, ptr %205, align 8
  %2424 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2423, 0
  %2425 = load ptr, ptr %206, align 8
  %2426 = insertvalue { ptr, ptr, ptr, i32 } %2424, ptr %2425, 1
  %2427 = load ptr, ptr %207, align 8
  %2428 = insertvalue { ptr, ptr, ptr, i32 } %2426, ptr %2427, 2
  %2429 = load i32, ptr %208, align 4
  %2430 = insertvalue { ptr, ptr, ptr, i32 } %2428, i32 %2429, 3
  %hash_coef_ptr.i.i172.i = getelementptr i8, ptr %2423, i64 8
  %tbl_size_ptr.i.i173.i = getelementptr i8, ptr %2423, i64 16
  %offset_tbl_ptr.i.i174.i = getelementptr i8, ptr %2423, i64 40
  %hash_coef.i.i175.i = load i64, ptr %hash_coef_ptr.i.i172.i, align 4
  %tbl_size.i.i176.i = load i64, ptr %tbl_size_ptr.i.i173.i, align 4
  %offset_tbl.i.i177.i = load ptr, ptr %offset_tbl_ptr.i.i174.i, align 8
  %product.i.i.i178.i = mul i64 %hash_coef.i.i175.i, -5261542750394134544
  %shifted.i.i.i179.i = lshr i64 %product.i.i.i178.i, 32
  %xored.i.i.i180.i = xor i64 %shifted.i.i.i179.i, %product.i.i.i178.i
  %hash.i.i.i181.i = and i64 %xored.i.i.i180.i, %tbl_size.i.i176.i
  %offset_ptr.i.i182.i = getelementptr i32, ptr %offset_tbl.i.i177.i, i64 %hash.i.i.i181.i
  %offset.i.i183.i = load i32, ptr %offset_ptr.i.i182.i, align 4
  %eq.i.i1154 = icmp eq i32 %2429, %offset.i.i183.i
  call void @llvm.assume(i1 %eq.i.i1154) #30
  store ptr @_parameterization_Ptri32, ptr %82, align 8
  %2431 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %82)
  %2432 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2423)
  %2433 = sext i32 %2429 to i64
  %2434 = getelementptr ptr, ptr %2423, i64 %2433
  %2435 = getelementptr i8, ptr %2434, i64 120
  %2436 = load ptr, ptr %2435, align 8
  store ptr @i32_typ, ptr %83, align 8
  %2437 = call ptr %2436({ ptr, ptr, ptr, i32 } %2430, ptr nonnull %83)
  %2438 = call { ptr, i160 } %2437({ ptr, ptr, ptr, i32 } %2430, { ptr, ptr, ptr, i32 } %2430, ptr nonnull %82, i32 %2421)
  %.fca.0.extract112.i = extractvalue { ptr, i160 } %2438, 0
  %2439 = ptrtoint ptr %.sroa.speculated352.i1756 to i64
  %2440 = ptrtoint ptr %.sroa.speculated346.i1758 to i64
  %.sroa.3111.0.insert.ext.i = zext i32 %offset.i.i260.i1760 to i160
  %.sroa.3111.0.insert.shift.i = shl nuw i160 %.sroa.3111.0.insert.ext.i, 128
  %.sroa.2110.0.insert.ext.i = zext i64 %2440 to i160
  %.sroa.2110.0.insert.shift.i = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i, 64
  %.sroa.2110.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.shift.i, %.sroa.3111.0.insert.shift.i
  %.sroa.0109.0.insert.ext.i = zext i64 %2439 to i160
  %.sroa.0109.0.insert.insert.i = or disjoint i160 %.sroa.2110.0.insert.insert.i, %.sroa.0109.0.insert.ext.i
  %2441 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i, 1
  %2442 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2443 = load ptr, ptr %205, align 8
  %2444 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2443, 0
  %2445 = load ptr, ptr %206, align 8
  %2446 = insertvalue { ptr, ptr, ptr, i32 } %2444, ptr %2445, 1
  %2447 = load ptr, ptr %207, align 8
  %2448 = insertvalue { ptr, ptr, ptr, i32 } %2446, ptr %2447, 2
  %2449 = load i32, ptr %208, align 4
  %2450 = insertvalue { ptr, ptr, ptr, i32 } %2448, i32 %2449, 3
  %hash_coef_ptr.i.i186.i = getelementptr i8, ptr %2443, i64 8
  %tbl_size_ptr.i.i187.i = getelementptr i8, ptr %2443, i64 16
  %offset_tbl_ptr.i.i188.i = getelementptr i8, ptr %2443, i64 40
  %hash_coef.i.i189.i = load i64, ptr %hash_coef_ptr.i.i186.i, align 4
  %tbl_size.i.i190.i = load i64, ptr %tbl_size_ptr.i.i187.i, align 4
  %offset_tbl.i.i191.i = load ptr, ptr %offset_tbl_ptr.i.i188.i, align 8
  %product.i.i.i192.i = mul i64 %hash_coef.i.i189.i, -5261542750394134544
  %shifted.i.i.i193.i = lshr i64 %product.i.i.i192.i, 32
  %xored.i.i.i194.i = xor i64 %shifted.i.i.i193.i, %product.i.i.i192.i
  %hash.i.i.i195.i = and i64 %xored.i.i.i194.i, %tbl_size.i.i190.i
  %offset_ptr.i.i196.i = getelementptr i32, ptr %offset_tbl.i.i191.i, i64 %hash.i.i.i195.i
  %offset.i.i197.i = load i32, ptr %offset_ptr.i.i196.i, align 4
  %eq.i200.i = icmp eq i32 %2449, %offset.i.i197.i
  call void @llvm.assume(i1 %eq.i200.i) #30
  %2451 = load ptr, ptr %result.i134, align 8
  %2452 = load ptr, ptr %188, align 8
  %result.i.i1155 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2453 = getelementptr i8, ptr %result.i.i1155, i64 16
  store ptr %2452, ptr %2453, align 8
  %2454 = getelementptr i8, ptr %result.i.i1155, i64 8
  store ptr %2451, ptr %2454, align 8
  %2455 = getelementptr i8, ptr %result.i.i1155, i64 24
  store ptr null, ptr %2455, align 8
  %2456 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1155)
  store ptr @Entry, ptr %result.i.i1155, align 8
  store ptr @_parameterization_Ptri32, ptr %84, align 8
  store ptr %result.i.i1155, ptr %276, align 8
  %2457 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %84)
  %2458 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2443)
  %2459 = sext i32 %2449 to i64
  %2460 = getelementptr ptr, ptr %2443, i64 %2459
  %2461 = getelementptr i8, ptr %2460, i64 128
  %2462 = load ptr, ptr %2461, align 8
  store ptr @i32_typ, ptr %85, align 8
  store ptr @Entry, ptr %277, align 8
  %2463 = call ptr %2462({ ptr, ptr, ptr, i32 } %2450, ptr nonnull %85)
  call void %2463({ ptr, ptr, ptr, i32 } %2450, { ptr, ptr, ptr, i32 } %2450, ptr nonnull %84, i32 %2421, { ptr, i160 } %2441)
  %2464 = icmp ne ptr %.fca.0.extract112.i, @nil_typ
  %2465 = icmp ne ptr %.fca.0.extract112.i, null
  %.not140.i = and i1 %2464, %2465
  br i1 %.not140.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

2466:                                             ; preds = %2392
  %2467 = add i32 %2399, 2127912214
  %2468 = shl i32 %2399, 12
  %2469 = add i32 %2467, %2468
  %2470 = ashr i32 %2469, 19
  %2471 = xor i32 %2469, %2470
  %2472 = xor i32 %2471, -949894596
  %2473 = add i32 %2472, 374761393
  %2474 = shl i32 %2472, 5
  %2475 = add i32 %2473, %2474
  %2476 = add i32 %2475, -744332180
  %2477 = shl i32 %2475, 9
  %2478 = xor i32 %2476, %2477
  %2479 = add i32 %2478, -42973499
  %2480 = shl i32 %2478, 3
  %2481 = add i32 %2479, %2480
  %2482 = ashr i32 %2481, 16
  %2483 = xor i32 %2481, %2482
  %2484 = xor i32 %2483, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2485 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2486 = load ptr, ptr %222, align 8
  %2487 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2486, 0
  %2488 = load ptr, ptr %223, align 8
  %2489 = insertvalue { ptr, ptr, ptr, i32 } %2487, ptr %2488, 1
  %2490 = load ptr, ptr %224, align 8
  %2491 = insertvalue { ptr, ptr, ptr, i32 } %2489, ptr %2490, 2
  %2492 = load i32, ptr %225, align 4
  %2493 = insertvalue { ptr, ptr, ptr, i32 } %2491, i32 %2492, 3
  %hash_coef_ptr.i.i10.i2958 = getelementptr i8, ptr %2486, i64 8
  %tbl_size_ptr.i.i11.i2959 = getelementptr i8, ptr %2486, i64 16
  %offset_tbl_ptr.i.i12.i2960 = getelementptr i8, ptr %2486, i64 40
  %hash_coef.i.i13.i2961 = load i64, ptr %hash_coef_ptr.i.i10.i2958, align 4
  %tbl_size.i.i14.i2962 = load i64, ptr %tbl_size_ptr.i.i11.i2959, align 4
  %offset_tbl.i.i15.i2963 = load ptr, ptr %offset_tbl_ptr.i.i12.i2960, align 8
  %product.i.i.i16.i2964 = mul i64 %hash_coef.i.i13.i2961, -5261542750394134544
  %shifted.i.i.i17.i2965 = lshr i64 %product.i.i.i16.i2964, 32
  %xored.i.i.i18.i2966 = xor i64 %shifted.i.i.i17.i2965, %product.i.i.i16.i2964
  %hash.i.i.i19.i2967 = and i64 %xored.i.i.i18.i2966, %tbl_size.i.i14.i2962
  %offset_ptr.i.i20.i2968 = getelementptr i32, ptr %offset_tbl.i.i15.i2963, i64 %hash.i.i.i19.i2967
  %offset.i.i21.i2969 = load i32, ptr %offset_ptr.i.i20.i2968, align 4
  %eq.i.i2970 = icmp eq i32 %2492, %offset.i.i21.i2969
  call void @llvm.assume(i1 %eq.i.i2970) #30
  %2494 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2495 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2486)
  %2496 = sext i32 %2492 to i64
  %2497 = getelementptr ptr, ptr %2486, i64 %2496
  %2498 = getelementptr i8, ptr %2497, i64 64
  %2499 = load ptr, ptr %2498, align 8
  %2500 = call ptr %2499({ ptr, ptr, ptr, i32 } %2493, ptr nonnull %2)
  %2501 = call i32 %2500({ ptr, ptr, ptr, i32 } %2493, { ptr, ptr, ptr, i32 } %2493, ptr nonnull %2)
  %2502 = add i32 %2501, -1
  %2503 = and i32 %2502, %2484
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2504 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2505 = load ptr, ptr %222, align 8
  %2506 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2505, 0
  %2507 = load ptr, ptr %223, align 8
  %2508 = insertvalue { ptr, ptr, ptr, i32 } %2506, ptr %2507, 1
  %2509 = load ptr, ptr %224, align 8
  %2510 = insertvalue { ptr, ptr, ptr, i32 } %2508, ptr %2509, 2
  %2511 = load i32, ptr %225, align 4
  %2512 = insertvalue { ptr, ptr, ptr, i32 } %2510, i32 %2511, 3
  %hash_coef_ptr.i.i202.i = getelementptr i8, ptr %2505, i64 8
  %tbl_size_ptr.i.i203.i = getelementptr i8, ptr %2505, i64 16
  %offset_tbl_ptr.i.i204.i = getelementptr i8, ptr %2505, i64 40
  %hash_coef.i.i205.i = load i64, ptr %hash_coef_ptr.i.i202.i, align 4
  %tbl_size.i.i206.i = load i64, ptr %tbl_size_ptr.i.i203.i, align 4
  %offset_tbl.i.i207.i = load ptr, ptr %offset_tbl_ptr.i.i204.i, align 8
  %product.i.i.i208.i = mul i64 %hash_coef.i.i205.i, -5261542750394134544
  %shifted.i.i.i209.i = lshr i64 %product.i.i.i208.i, 32
  %xored.i.i.i210.i = xor i64 %shifted.i.i.i209.i, %product.i.i.i208.i
  %hash.i.i.i211.i = and i64 %xored.i.i.i210.i, %tbl_size.i.i206.i
  %offset_ptr.i.i212.i = getelementptr i32, ptr %offset_tbl.i.i207.i, i64 %hash.i.i.i211.i
  %offset.i.i213.i = load i32, ptr %offset_ptr.i.i212.i, align 4
  %eq.i216.i = icmp eq i32 %2511, %offset.i.i213.i
  call void @llvm.assume(i1 %eq.i216.i) #30
  store ptr @_parameterization_Ptri32, ptr %90, align 8
  %2513 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %90)
  %2514 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2505)
  %2515 = sext i32 %2511 to i64
  %2516 = getelementptr ptr, ptr %2505, i64 %2515
  %2517 = getelementptr i8, ptr %2516, i64 120
  %2518 = load ptr, ptr %2517, align 8
  store ptr @i32_typ, ptr %91, align 8
  %2519 = call ptr %2518({ ptr, ptr, ptr, i32 } %2512, ptr nonnull %91)
  %2520 = call { ptr, i160 } %2519({ ptr, ptr, ptr, i32 } %2512, { ptr, ptr, ptr, i32 } %2512, ptr nonnull %90, i32 %2503)
  %.fca.0.extract87.i = extractvalue { ptr, i160 } %2520, 0
  %2521 = ptrtoint ptr %.sroa.speculated352.i1756 to i64
  %2522 = ptrtoint ptr %.sroa.speculated346.i1758 to i64
  %.sroa.3.0.insert.ext.i1152 = zext i32 %offset.i.i260.i1760 to i160
  %.sroa.3.0.insert.shift.i1153 = shl nuw i160 %.sroa.3.0.insert.ext.i1152, 128
  %.sroa.2.0.insert.ext.i = zext i64 %2522 to i160
  %.sroa.2.0.insert.shift.i = shl nuw nsw i160 %.sroa.2.0.insert.ext.i, 64
  %.sroa.2.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.shift.i, %.sroa.3.0.insert.shift.i1153
  %.sroa.0.0.insert.ext.i = zext i64 %2521 to i160
  %.sroa.0.0.insert.insert.i = or disjoint i160 %.sroa.2.0.insert.insert.i, %.sroa.0.0.insert.ext.i
  %2523 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i, 1
  %2524 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2525 = load ptr, ptr %222, align 8
  %2526 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2525, 0
  %2527 = load ptr, ptr %223, align 8
  %2528 = insertvalue { ptr, ptr, ptr, i32 } %2526, ptr %2527, 1
  %2529 = load ptr, ptr %224, align 8
  %2530 = insertvalue { ptr, ptr, ptr, i32 } %2528, ptr %2529, 2
  %2531 = load i32, ptr %225, align 4
  %2532 = insertvalue { ptr, ptr, ptr, i32 } %2530, i32 %2531, 3
  %hash_coef_ptr.i.i218.i = getelementptr i8, ptr %2525, i64 8
  %tbl_size_ptr.i.i219.i = getelementptr i8, ptr %2525, i64 16
  %offset_tbl_ptr.i.i220.i = getelementptr i8, ptr %2525, i64 40
  %hash_coef.i.i221.i = load i64, ptr %hash_coef_ptr.i.i218.i, align 4
  %tbl_size.i.i222.i = load i64, ptr %tbl_size_ptr.i.i219.i, align 4
  %offset_tbl.i.i223.i = load ptr, ptr %offset_tbl_ptr.i.i220.i, align 8
  %product.i.i.i224.i = mul i64 %hash_coef.i.i221.i, -5261542750394134544
  %shifted.i.i.i225.i = lshr i64 %product.i.i.i224.i, 32
  %xored.i.i.i226.i = xor i64 %shifted.i.i.i225.i, %product.i.i.i224.i
  %hash.i.i.i227.i = and i64 %xored.i.i.i226.i, %tbl_size.i.i222.i
  %offset_ptr.i.i228.i = getelementptr i32, ptr %offset_tbl.i.i223.i, i64 %hash.i.i.i227.i
  %offset.i.i229.i = load i32, ptr %offset_ptr.i.i228.i, align 4
  %eq.i232.i = icmp eq i32 %2531, %offset.i.i229.i
  call void @llvm.assume(i1 %eq.i232.i) #30
  %2533 = load ptr, ptr %result.i134, align 8
  %2534 = load ptr, ptr %188, align 8
  %result.i233.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2535 = getelementptr i8, ptr %result.i233.i, i64 16
  store ptr %2534, ptr %2535, align 8
  %2536 = getelementptr i8, ptr %result.i233.i, i64 8
  store ptr %2533, ptr %2536, align 8
  %2537 = getelementptr i8, ptr %result.i233.i, i64 24
  store ptr null, ptr %2537, align 8
  %2538 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i)
  store ptr @Entry, ptr %result.i233.i, align 8
  store ptr @_parameterization_Ptri32, ptr %92, align 8
  store ptr %result.i233.i, ptr %274, align 8
  %2539 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %92)
  %2540 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2525)
  %2541 = sext i32 %2531 to i64
  %2542 = getelementptr ptr, ptr %2525, i64 %2541
  %2543 = getelementptr i8, ptr %2542, i64 128
  %2544 = load ptr, ptr %2543, align 8
  store ptr @i32_typ, ptr %93, align 8
  store ptr @Entry, ptr %275, align 8
  %2545 = call ptr %2544({ ptr, ptr, ptr, i32 } %2532, ptr nonnull %93)
  call void %2545({ ptr, ptr, ptr, i32 } %2532, { ptr, ptr, ptr, i32 } %2532, ptr nonnull %92, i32 %2503, { ptr, i160 } %2523)
  %2546 = icmp ne ptr %.fca.0.extract87.i, @nil_typ
  %2547 = icmp ne ptr %.fca.0.extract87.i, null
  %.not138.i = and i1 %2546, %2547
  br i1 %.not138.i, label %.cont.cont.i, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %2466, %2402
  %.sink = phi { ptr, i160 } [ %2438, %2402 ], [ %2520, %2466 ]
  %2548 = phi i32 [ 2, %2402 ], [ 1, %2466 ]
  %vptr.i248.sroa.speculated.i = phi ptr [ %.fca.0.extract112.i, %2402 ], [ %.fca.0.extract87.i, %2466 ]
  %.fca.1.extract89.i = extractvalue { ptr, i160 } %.sink, 1
  %.sroa.3407.sroa.4.0.extract.shift.i = lshr i160 %.fca.1.extract89.i, 64
  %.sroa.3407.sroa.4.0.extract.trunc.i = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i to i64
  %.sroa.3407.sroa.0.0.extract.trunc.i = trunc i160 %.fca.1.extract89.i to i64
  %.sroa.speculated352.i = inttoptr i64 %.sroa.3407.sroa.0.0.extract.trunc.i to ptr
  %.sroa.speculated346.i = inttoptr i64 %.sroa.3407.sroa.4.0.extract.trunc.i to ptr
  %hash_coef_ptr.i.i249.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i250.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i251.i = getelementptr i8, ptr %vptr.i248.sroa.speculated.i, i64 40
  %hash_coef.i.i252.i = load i64, ptr %hash_coef_ptr.i.i249.i, align 4
  %tbl_size.i.i253.i = load i64, ptr %tbl_size_ptr.i.i250.i, align 4
  %offset_tbl.i.i254.i = load ptr, ptr %offset_tbl_ptr.i.i251.i, align 8
  %product.i.i.i255.i = mul i64 %hash_coef.i.i252.i, 4015701072841558310
  %shifted.i.i.i256.i = lshr i64 %product.i.i.i255.i, 32
  %xored.i.i.i257.i = xor i64 %shifted.i.i.i256.i, %product.i.i.i255.i
  %hash.i.i.i258.i = and i64 %xored.i.i.i257.i, %tbl_size.i.i253.i
  %offset_ptr.i.i259.i = getelementptr i32, ptr %offset_tbl.i.i254.i, i64 %hash.i.i.i258.i
  %offset.i.i260.i = load i32, ptr %offset_ptr.i.i259.i, align 4
  store ptr %vptr.i248.sroa.speculated.i, ptr %98, align 8
  store ptr %.sroa.speculated352.i, ptr %271, align 8
  store ptr %.sroa.speculated346.i, ptr %272, align 8
  store i32 %offset.i.i260.i, ptr %273, align 8
  %2549 = add nuw nsw i32 %.reg2mem193.0677.i, 1
  %2550 = load i32, ptr %228, align 4
  %2551 = icmp slt i32 %2549, %2550
  br i1 %2551, label %2392, label %._crit_edge1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %2402, %2466
  %2552 = phi ptr [ %94, %2466 ], [ %86, %2402 ]
  %2553 = phi ptr [ %95, %2466 ], [ %87, %2402 ]
  %2554 = phi ptr [ %96, %2466 ], [ %88, %2402 ]
  %2555 = phi ptr [ %.sroa.0.i1117, %2466 ], [ %.sroa.0680.i, %2402 ]
  %2556 = phi ptr [ %97, %2466 ], [ %89, %2402 ]
  %2557 = load i32, ptr %226, align 4
  store i32 %2557, ptr %2552, align 4
  store i32 1, ptr %2553, align 4
  %2558 = add i32 %2557, 1
  store i32 %2558, ptr %2554, align 4
  %2559 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %2558, ptr %226, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2556, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2555, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1117)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %98)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.i:                                   ; preds = %.cont.cont.i, %._crit_edge.i
  %2560 = load i160, ptr %271, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %82)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %83)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %84)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %85)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %86)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %87)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %88)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %89)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %90)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %91)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %92)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %93)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %94)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %96)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1117)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %97)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %98)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %76)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %77)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %78)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %79)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %80)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %81)
  %2561 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2562 = load ptr, ptr %205, align 8
  %2563 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2562, 0
  %2564 = load ptr, ptr %206, align 8
  %2565 = insertvalue { ptr, ptr, ptr, i32 } %2563, ptr %2564, 1
  %2566 = load ptr, ptr %207, align 8
  %2567 = insertvalue { ptr, ptr, ptr, i32 } %2565, ptr %2566, 2
  %2568 = load i32, ptr %208, align 4
  %2569 = insertvalue { ptr, ptr, ptr, i32 } %2567, i32 %2568, 3
  %hash_coef_ptr.i.i64.i1175 = getelementptr i8, ptr %2562, i64 8
  %tbl_size_ptr.i.i65.i1176 = getelementptr i8, ptr %2562, i64 16
  %offset_tbl_ptr.i.i66.i1177 = getelementptr i8, ptr %2562, i64 40
  %hash_coef.i.i67.i1178 = load i64, ptr %hash_coef_ptr.i.i64.i1175, align 4
  %tbl_size.i.i68.i1179 = load i64, ptr %tbl_size_ptr.i.i65.i1176, align 4
  %offset_tbl.i.i69.i1180 = load ptr, ptr %offset_tbl_ptr.i.i66.i1177, align 8
  %product.i.i.i70.i1181 = mul i64 %hash_coef.i.i67.i1178, -5261542750394134544
  %shifted.i.i.i71.i1182 = lshr i64 %product.i.i.i70.i1181, 32
  %xored.i.i.i72.i1183 = xor i64 %shifted.i.i.i71.i1182, %product.i.i.i70.i1181
  %hash.i.i.i73.i1184 = and i64 %xored.i.i.i72.i1183, %tbl_size.i.i68.i1179
  %offset_ptr.i.i74.i1185 = getelementptr i32, ptr %offset_tbl.i.i69.i1180, i64 %hash.i.i.i73.i1184
  %offset.i.i75.i1186 = load i32, ptr %offset_ptr.i.i74.i1185, align 4
  %eq.i.i1187 = icmp eq i32 %2568, %offset.i.i75.i1186
  call void @llvm.assume(i1 %eq.i.i1187) #30
  %2570 = load ptr, ptr %222, align 8
  %2571 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2570, 0
  %2572 = load ptr, ptr %223, align 8
  %2573 = insertvalue { ptr, ptr, ptr, i32 } %2571, ptr %2572, 1
  %2574 = load ptr, ptr %224, align 8
  %2575 = insertvalue { ptr, ptr, ptr, i32 } %2573, ptr %2574, 2
  %2576 = load i32, ptr %225, align 4
  %2577 = insertvalue { ptr, ptr, ptr, i32 } %2575, i32 %2576, 3
  %hash_coef_ptr.i.i92.i1192 = getelementptr i8, ptr %2570, i64 8
  %tbl_size_ptr.i.i93.i1193 = getelementptr i8, ptr %2570, i64 16
  %offset_tbl_ptr.i.i94.i1194 = getelementptr i8, ptr %2570, i64 40
  %hash_coef.i.i95.i1195 = load i64, ptr %hash_coef_ptr.i.i92.i1192, align 4
  %tbl_size.i.i96.i1196 = load i64, ptr %tbl_size_ptr.i.i93.i1193, align 4
  %offset_tbl.i.i97.i1197 = load ptr, ptr %offset_tbl_ptr.i.i94.i1194, align 8
  %product.i.i.i98.i1198 = mul i64 %hash_coef.i.i95.i1195, -5261542750394134544
  %shifted.i.i.i99.i1199 = lshr i64 %product.i.i.i98.i1198, 32
  %xored.i.i.i100.i1200 = xor i64 %shifted.i.i.i99.i1199, %product.i.i.i98.i1198
  %hash.i.i.i101.i1201 = and i64 %xored.i.i.i100.i1200, %tbl_size.i.i96.i1196
  %offset_ptr.i.i102.i1202 = getelementptr i32, ptr %offset_tbl.i.i97.i1197, i64 %hash.i.i.i101.i1201
  %offset.i.i103.i1203 = load i32, ptr %offset_ptr.i.i102.i1202, align 4
  %eq.i106.i1204 = icmp eq i32 %2576, %offset.i.i103.i1203
  call void @llvm.assume(i1 %eq.i106.i1204) #30
  %2578 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2579 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2562)
  %2580 = sext i32 %2568 to i64
  %2581 = getelementptr ptr, ptr %2562, i64 %2580
  %2582 = getelementptr i8, ptr %2581, i64 64
  %2583 = load ptr, ptr %2582, align 8
  %2584 = call ptr %2583({ ptr, ptr, ptr, i32 } %2569, ptr nonnull %2)
  %2585 = call i32 %2584({ ptr, ptr, ptr, i32 } %2569, { ptr, ptr, ptr, i32 } %2569, ptr nonnull %2)
  %2586 = shl i32 %2585, 1
  %2587 = load i32, ptr %226, align 4
  %2588 = load ptr, ptr %result.i134, align 8
  %2589 = load ptr, ptr %188, align 8
  %2590 = sext i32 %2587 to i64
  %2591 = shl nsw i64 %2590, 5
  %result.i.i.i1207 = call noalias ptr @bump_malloc_inner(i64 noundef %2591, ptr nonnull @current_ptr) #29
  %2592 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2593 = icmp sgt i32 %2585, 0
  br i1 %2593, label %.lr.ph434.i1277, label %._crit_edge395.i1221

.lr.ph434.i1277:                                  ; preds = %._crit_edge1.i
  %invariant.gep.i1220 = getelementptr i8, ptr %2562, i64 120
  %2594 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1280 = getelementptr ptr, ptr %invariant.gep.i1220, i64 %2580
  br label %2595

2595:                                             ; preds = %2617, %.lr.ph434.i1277
  %.reg2mem105.0432.i1278 = phi i32 [ 0, %.lr.ph434.i1277 ], [ %.reg2mem101.0.i1283, %2617 ]
  %.reg2mem103.0431.i1279 = phi i32 [ 0, %.lr.ph434.i1277 ], [ %2618, %2617 ]
  store ptr @_parameterization_Ptri32, ptr %76, align 8
  %2596 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %76)
  %2597 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2562)
  %2598 = load ptr, ptr %gep.i1280, align 8
  store ptr @i32_typ, ptr %77, align 8
  %2599 = call ptr %2598({ ptr, ptr, ptr, i32 } %2569, ptr nonnull %77)
  %2600 = call { ptr, i160 } %2599({ ptr, ptr, ptr, i32 } %2569, { ptr, ptr, ptr, i32 } %2569, ptr nonnull %76, i32 %.reg2mem103.0431.i1279)
  %.fca.0.extract52.i1281 = extractvalue { ptr, i160 } %2600, 0
  %2601 = icmp ne ptr %.fca.0.extract52.i1281, @nil_typ
  %2602 = icmp ne ptr %.fca.0.extract52.i1281, null
  %.not60.i1282 = and i1 %2601, %2602
  br i1 %.not60.i1282, label %2603, label %2617

2603:                                             ; preds = %2595
  %hash_coef_ptr.i.i137.i1310 = getelementptr i8, ptr %.fca.0.extract52.i1281, i64 8
  %tbl_size_ptr.i.i138.i1311 = getelementptr i8, ptr %.fca.0.extract52.i1281, i64 16
  %offset_tbl_ptr.i.i139.i1312 = getelementptr i8, ptr %.fca.0.extract52.i1281, i64 40
  %hash_coef.i.i140.i1313 = load i64, ptr %hash_coef_ptr.i.i137.i1310, align 4
  %tbl_size.i.i141.i1314 = load i64, ptr %tbl_size_ptr.i.i138.i1311, align 4
  %offset_tbl.i.i142.i1315 = load ptr, ptr %offset_tbl_ptr.i.i139.i1312, align 8
  %product.i.i.i143.i1316 = mul i64 %hash_coef.i.i140.i1313, 4015701072841558310
  %shifted.i.i.i144.i1317 = lshr i64 %product.i.i.i143.i1316, 32
  %xored.i.i.i145.i1318 = xor i64 %shifted.i.i.i144.i1317, %product.i.i.i143.i1316
  %hash.i.i.i146.i1319 = and i64 %xored.i.i.i145.i1318, %tbl_size.i.i141.i1314
  %offset_ptr.i.i147.i1320 = getelementptr i32, ptr %offset_tbl.i.i142.i1315, i64 %hash.i.i.i146.i1319
  %offset.i.i148.i1321 = load i32, ptr %offset_ptr.i.i147.i1320, align 4
  %2604 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2605 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2606 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2607 = icmp slt i32 %.reg2mem105.0432.i1278, %2587
  br i1 %2607, label %2608, label %._crit_edge.i1322

2608:                                             ; preds = %2603
  %.fca.1.extract54.i1323 = extractvalue { ptr, i160 } %2600, 1
  %.sroa.351.0.insert.ext.i1324 = zext i32 %offset.i.i148.i1321 to i160
  %.sroa.351.0.insert.shift.i1325 = shl nuw i160 %.sroa.351.0.insert.ext.i1324, 128
  %2609 = and i160 %.fca.1.extract54.i1323, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1326 = or disjoint i160 %.sroa.351.0.insert.shift.i1325, %2609
  %2610 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2611 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2612 = sext i32 %.reg2mem105.0432.i1278 to i64
  %2613 = shl nsw i64 %2612, 5
  %2614 = getelementptr i8, ptr %result.i.i.i1207, i64 %2613
  store ptr %.fca.0.extract52.i1281, ptr %2614, align 8
  %2615 = getelementptr i8, ptr %2614, i64 8
  store i160 %.sroa.049.0.insert.insert.i1326, ptr %2615, align 4
  br label %._crit_edge.i1322

._crit_edge.i1322:                                ; preds = %2608, %2603
  %2616 = add i32 %.reg2mem105.0432.i1278, 1
  br label %2617

2617:                                             ; preds = %._crit_edge.i1322, %2595
  %.reg2mem101.0.i1283 = phi i32 [ %2616, %._crit_edge.i1322 ], [ %.reg2mem105.0432.i1278, %2595 ]
  %2618 = add nuw nsw i32 %.reg2mem103.0431.i1279, 1
  %2619 = icmp slt i32 %2618, %2585
  br i1 %2619, label %2595, label %.lr.ph.i1284

.lr.ph.i1284:                                     ; preds = %2617
  %invariant.gep396.i1285 = getelementptr i8, ptr %2570, i64 120
  %2620 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2621 = sext i32 %2576 to i64
  %gep397.i1288 = getelementptr ptr, ptr %invariant.gep396.i1285, i64 %2621
  br label %2622

2622:                                             ; preds = %2644, %.lr.ph.i1284
  %.reg2mem91.0394.i1286 = phi i32 [ %.reg2mem101.0.i1283, %.lr.ph.i1284 ], [ %.reg2mem87.0.i1291, %2644 ]
  %.reg2mem89.0393.i1287 = phi i32 [ 0, %.lr.ph.i1284 ], [ %2645, %2644 ]
  store ptr @_parameterization_Ptri32, ptr %78, align 8
  %2623 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %78)
  %2624 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2570)
  %2625 = load ptr, ptr %gep397.i1288, align 8
  store ptr @i32_typ, ptr %79, align 8
  %2626 = call ptr %2625({ ptr, ptr, ptr, i32 } %2577, ptr nonnull %79)
  %2627 = call { ptr, i160 } %2626({ ptr, ptr, ptr, i32 } %2577, { ptr, ptr, ptr, i32 } %2577, ptr nonnull %78, i32 %.reg2mem89.0393.i1287)
  %.fca.0.extract42.i1289 = extractvalue { ptr, i160 } %2627, 0
  %2628 = icmp ne ptr %.fca.0.extract42.i1289, @nil_typ
  %2629 = icmp ne ptr %.fca.0.extract42.i1289, null
  %.not62.i1290 = and i1 %2628, %2629
  br i1 %.not62.i1290, label %2630, label %2644

2630:                                             ; preds = %2622
  %hash_coef_ptr.i.i152.i1292 = getelementptr i8, ptr %.fca.0.extract42.i1289, i64 8
  %tbl_size_ptr.i.i153.i1293 = getelementptr i8, ptr %.fca.0.extract42.i1289, i64 16
  %offset_tbl_ptr.i.i154.i1294 = getelementptr i8, ptr %.fca.0.extract42.i1289, i64 40
  %hash_coef.i.i155.i1295 = load i64, ptr %hash_coef_ptr.i.i152.i1292, align 4
  %tbl_size.i.i156.i1296 = load i64, ptr %tbl_size_ptr.i.i153.i1293, align 4
  %offset_tbl.i.i157.i1297 = load ptr, ptr %offset_tbl_ptr.i.i154.i1294, align 8
  %product.i.i.i158.i1298 = mul i64 %hash_coef.i.i155.i1295, 4015701072841558310
  %shifted.i.i.i159.i1299 = lshr i64 %product.i.i.i158.i1298, 32
  %xored.i.i.i160.i1300 = xor i64 %shifted.i.i.i159.i1299, %product.i.i.i158.i1298
  %hash.i.i.i161.i1301 = and i64 %xored.i.i.i160.i1300, %tbl_size.i.i156.i1296
  %offset_ptr.i.i162.i1302 = getelementptr i32, ptr %offset_tbl.i.i157.i1297, i64 %hash.i.i.i161.i1301
  %offset.i.i163.i1303 = load i32, ptr %offset_ptr.i.i162.i1302, align 4
  %2631 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2632 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2633 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2634 = icmp slt i32 %.reg2mem91.0394.i1286, %2587
  br i1 %2634, label %2635, label %._crit_edge1.i1304

2635:                                             ; preds = %2630
  %.fca.1.extract44.i1305 = extractvalue { ptr, i160 } %2627, 1
  %.sroa.3.0.insert.ext.i1306 = zext i32 %offset.i.i163.i1303 to i160
  %.sroa.3.0.insert.shift.i1307 = shl nuw i160 %.sroa.3.0.insert.ext.i1306, 128
  %2636 = and i160 %.fca.1.extract44.i1305, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1308 = or disjoint i160 %.sroa.3.0.insert.shift.i1307, %2636
  %2637 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2638 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2639 = sext i32 %.reg2mem91.0394.i1286 to i64
  %2640 = shl nsw i64 %2639, 5
  %2641 = getelementptr i8, ptr %result.i.i.i1207, i64 %2640
  store ptr %.fca.0.extract42.i1289, ptr %2641, align 8
  %2642 = getelementptr i8, ptr %2641, i64 8
  store i160 %.sroa.040.0.insert.insert.i1308, ptr %2642, align 4
  br label %._crit_edge1.i1304

._crit_edge1.i1304:                               ; preds = %2635, %2630
  %2643 = add i32 %.reg2mem91.0394.i1286, 1
  br label %2644

2644:                                             ; preds = %._crit_edge1.i1304, %2622
  %.reg2mem87.0.i1291 = phi i32 [ %2643, %._crit_edge1.i1304 ], [ %.reg2mem91.0394.i1286, %2622 ]
  %2645 = add nuw nsw i32 %.reg2mem89.0393.i1287, 1
  %2646 = icmp slt i32 %2645, %2585
  br i1 %2646, label %2622, label %._crit_edge395.i1221.loopexit

._crit_edge395.i1221.loopexit:                    ; preds = %2644
  %.pre2836 = load ptr, ptr %result.i134, align 8
  %.pre2837 = load ptr, ptr %188, align 8
  br label %._crit_edge395.i1221

._crit_edge395.i1221:                             ; preds = %._crit_edge395.i1221.loopexit, %._crit_edge1.i
  %2647 = phi ptr [ %2589, %._crit_edge1.i ], [ %.pre2837, %._crit_edge395.i1221.loopexit ]
  %2648 = phi ptr [ %2588, %._crit_edge1.i ], [ %.pre2836, %._crit_edge395.i1221.loopexit ]
  %.reg2mem91.0.lcssa.i1222 = phi i32 [ 0, %._crit_edge1.i ], [ %.reg2mem87.0.i1291, %._crit_edge395.i1221.loopexit ]
  %2649 = call i32 @llvm.smax.i32(i32 %2586, i32 16)
  %result.i166.i1223 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2650 = getelementptr i8, ptr %result.i166.i1223, i64 16
  store ptr @_parameterization_Nil, ptr %2650, align 8
  %result.i167.i1224 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2651 = getelementptr i8, ptr %result.i167.i1224, i64 16
  store ptr %2647, ptr %2651, align 8
  %2652 = getelementptr i8, ptr %result.i167.i1224, i64 8
  store ptr %2648, ptr %2652, align 8
  %2653 = getelementptr i8, ptr %result.i167.i1224, i64 24
  store ptr null, ptr %2653, align 8
  %2654 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1224)
  store ptr @Entry, ptr %result.i167.i1224, align 8
  %2655 = getelementptr i8, ptr %result.i166.i1223, i64 8
  store ptr %result.i167.i1224, ptr %2655, align 8
  %2656 = getelementptr i8, ptr %result.i166.i1223, i64 24
  store ptr null, ptr %2656, align 8
  %2657 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1223)
  store ptr @union_typ, ptr %result.i166.i1223, align 8
  %result.i168.i1225 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1223, ptr %result.i168.i1225, align 8
  %2658 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1225)
  store ptr @Array, ptr %80, align 8
  store ptr %result.i168.i1225, ptr %278, align 8
  store i32 9, ptr %279, align 8
  %2659 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %80)
  %2660 = getelementptr i8, ptr %result.i168.i1225, i64 16
  store i32 %2649, ptr %2660, align 4
  %2661 = getelementptr i8, ptr %result.i168.i1225, i64 20
  store i32 %2649, ptr %2661, align 4
  %2662 = zext nneg i32 %2649 to i64
  %2663 = shl nuw nsw i64 %2662, 5
  %result.i.i416.i1226 = call noalias ptr @bump_malloc_inner(i64 noundef %2663, ptr nonnull @current_ptr) #29
  %2664 = getelementptr i8, ptr %result.i168.i1225, i64 8
  store ptr %result.i.i416.i1226, ptr %2664, align 8
  %2665 = load ptr, ptr %280, align 8
  store ptr @Array, ptr %205, align 8
  store ptr %result.i168.i1225, ptr %206, align 8
  store ptr %2665, ptr %207, align 8
  store i32 9, ptr %208, align 4
  %2666 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %result.i183.i1239 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2667 = getelementptr i8, ptr %result.i183.i1239, i64 16
  store ptr @_parameterization_Nil, ptr %2667, align 8
  %result.i184.i1240 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2668 = getelementptr i8, ptr %result.i184.i1240, i64 16
  store ptr %2647, ptr %2668, align 8
  %2669 = getelementptr i8, ptr %result.i184.i1240, i64 8
  store ptr %2648, ptr %2669, align 8
  %2670 = getelementptr i8, ptr %result.i184.i1240, i64 24
  store ptr null, ptr %2670, align 8
  %2671 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1240)
  store ptr @Entry, ptr %result.i184.i1240, align 8
  %2672 = getelementptr i8, ptr %result.i183.i1239, i64 8
  store ptr %result.i184.i1240, ptr %2672, align 8
  %2673 = getelementptr i8, ptr %result.i183.i1239, i64 24
  store ptr null, ptr %2673, align 8
  %2674 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1239)
  store ptr @union_typ, ptr %result.i183.i1239, align 8
  %result.i185.i1241 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1239, ptr %result.i185.i1241, align 8
  %2675 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1241)
  store ptr @Array, ptr %81, align 8
  store ptr %result.i185.i1241, ptr %281, align 8
  store i32 9, ptr %282, align 8
  %2676 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %81)
  %2677 = getelementptr i8, ptr %result.i185.i1241, i64 16
  store i32 %2649, ptr %2677, align 4
  %2678 = getelementptr i8, ptr %result.i185.i1241, i64 20
  store i32 %2649, ptr %2678, align 4
  %result.i.i430.i1242 = call noalias ptr @bump_malloc_inner(i64 noundef %2663, ptr nonnull @current_ptr) #29
  %2679 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2680 = getelementptr i8, ptr %result.i185.i1241, i64 8
  store ptr %result.i.i430.i1242, ptr %2680, align 8
  %2681 = load ptr, ptr %283, align 8
  store ptr @Array, ptr %222, align 8
  store ptr %result.i185.i1241, ptr %223, align 8
  store ptr %2681, ptr %224, align 8
  store i32 9, ptr %225, align 4
  store i32 0, ptr %226, align 4
  %2682 = icmp sgt i32 %.reg2mem91.0.lcssa.i1222, 0
  br i1 %2682, label %.lr.ph400.i1255, label %HashMap_resize_.exit1328

.lr.ph400.i1255:                                  ; preds = %._crit_edge395.i1221
  %2683 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2684 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2685 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1257

._crit_edge2.i1257:                               ; preds = %._crit_edge2.i1257, %.lr.ph400.i1255
  %.reg2mem77.0398.i1258 = phi i32 [ 0, %.lr.ph400.i1255 ], [ %2699, %._crit_edge2.i1257 ]
  %2686 = zext nneg i32 %.reg2mem77.0398.i1258 to i64
  %2687 = shl nuw nsw i64 %2686, 5
  %2688 = getelementptr i8, ptr %result.i.i.i1207, i64 %2687
  %2689 = load ptr, ptr %2688, align 8
  %2690 = getelementptr i8, ptr %2688, i64 8
  %2691 = load i160, ptr %2690, align 4
  %.sroa.3362.8.extract.trunc.i1261 = trunc i160 %2691 to i64
  %2692 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1261 to ptr
  %.sroa.5363.8.extract.shift.i1262 = lshr i160 %2691, 64
  %.sroa.5363.8.extract.trunc.i1263 = trunc i160 %.sroa.5363.8.extract.shift.i1262 to i64
  %2693 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1263 to ptr
  %hash_coef_ptr.i.i201.i1264 = getelementptr i8, ptr %2689, i64 8
  %tbl_size_ptr.i.i202.i1265 = getelementptr i8, ptr %2689, i64 16
  %offset_tbl_ptr.i.i203.i1266 = getelementptr i8, ptr %2689, i64 40
  %hash_coef.i.i232.i1267 = load i64, ptr %hash_coef_ptr.i.i201.i1264, align 4
  %tbl_size.i.i233.i1268 = load i64, ptr %tbl_size_ptr.i.i202.i1265, align 4
  %offset_tbl.i.i234.i1269 = load ptr, ptr %offset_tbl_ptr.i.i203.i1266, align 8
  %product.i.i.i235.i1270 = mul i64 %hash_coef.i.i232.i1267, 4015701072841558310
  %shifted.i.i.i236.i1271 = lshr i64 %product.i.i.i235.i1270, 32
  %xored.i.i.i237.i1272 = xor i64 %shifted.i.i.i236.i1271, %product.i.i.i235.i1270
  %hash.i.i.i238.i1273 = and i64 %xored.i.i.i237.i1272, %tbl_size.i.i233.i1268
  %offset_ptr.i.i239.i1274 = getelementptr i32, ptr %offset_tbl.i.i234.i1269, i64 %hash.i.i.i238.i1273
  %offset.i.i240.i1275 = load i32, ptr %offset_ptr.i.i239.i1274, align 4
  %2694 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2689, 0
  %2695 = insertvalue { ptr, ptr, ptr, i32 } %2694, ptr %2692, 1
  %2696 = insertvalue { ptr, ptr, ptr, i32 } %2695, ptr %2693, 2
  %2697 = insertvalue { ptr, ptr, ptr, i32 } %2696, i32 %offset.i.i240.i1275, 3
  %2698 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %2697)
  %2699 = add nuw nsw i32 %.reg2mem77.0398.i1258, 1
  %2700 = icmp slt i32 %2699, %.reg2mem91.0.lcssa.i1222
  br i1 %2700, label %._crit_edge2.i1257, label %HashMap_resize_.exit1328

HashMap_resize_.exit1328:                         ; preds = %._crit_edge2.i1257, %._crit_edge395.i1221
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %76)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %77)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %78)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %79)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %80)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %81)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0680.i1329)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i1331)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %75)
  %2701 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2702 = load i32, ptr %228, align 4
  %2703 = icmp sgt i32 %2702, 0
  br i1 %2703, label %.lr.ph.i1366, label %._crit_edge1.1.i

.lr.ph.i1366:                                     ; preds = %HashMap_resize_.exit1328
  %2704 = lshr i160 %2560, 64
  %2705 = insertelement <2 x i160> poison, i160 %2704, i64 0
  %2706 = insertelement <2 x i160> %2705, i160 %2560, i64 1
  %2707 = trunc <2 x i160> %2706 to <2 x i64>
  %2708 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2709 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Entry)
  br label %2710

2710:                                             ; preds = %.cont.cont.i1420, %.lr.ph.i1366
  %offset.i.i260.i14371768 = phi i32 [ 9, %.lr.ph.i1366 ], [ %offset.i.i260.i1437, %.cont.cont.i1420 ]
  %.reg2mem195.0678.i1368 = phi i32 [ 1, %.lr.ph.i1366 ], [ %2865, %.cont.cont.i1420 ]
  %.reg2mem193.0677.i1369 = phi i32 [ 0, %.lr.ph.i1366 ], [ %2870, %.cont.cont.i1420 ]
  %2711 = phi <2 x i64> [ %2707, %.lr.ph.i1366 ], [ %2869, %.cont.cont.i1420 ]
  %2712 = extractelement <2 x i64> %2711, i64 1
  %.sroa.speculated352.i14241764 = inttoptr i64 %2712 to ptr
  %2713 = extractelement <2 x i64> %2711, i64 0
  %.sroa.speculated346.i14251766 = inttoptr i64 %2713 to ptr
  %2714 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %.sroa.speculated352.i14241764, 1
  %2715 = insertvalue { ptr, ptr, ptr, i32 } %2714, ptr %.sroa.speculated346.i14251766, 2
  %2716 = insertvalue { ptr, ptr, ptr, i32 } %2715, i32 %offset.i.i260.i14371768, 3
  %2717 = sext i32 %offset.i.i260.i14371768 to i64
  %gep1762 = getelementptr ptr, ptr getelementptr inbounds (i8, ptr @Entry, i64 64), i64 %2717
  %2718 = load ptr, ptr %gep1762, align 8
  %2719 = call ptr %2718({ ptr, ptr, ptr, i32 } %2716, ptr nonnull %2)
  %2720 = call i32 %2719({ ptr, ptr, ptr, i32 } %2716, { ptr, ptr, ptr, i32 } %2716, ptr nonnull %2)
  %2721 = icmp eq i32 %.reg2mem195.0678.i1368, 1
  %2722 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br i1 %2721, label %2723, label %2785

2723:                                             ; preds = %2710
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2724 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2725 = load ptr, ptr %205, align 8
  %2726 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2725, 0
  %2727 = load ptr, ptr %206, align 8
  %2728 = insertvalue { ptr, ptr, ptr, i32 } %2726, ptr %2727, 1
  %2729 = load ptr, ptr %207, align 8
  %2730 = insertvalue { ptr, ptr, ptr, i32 } %2728, ptr %2729, 2
  %2731 = load i32, ptr %208, align 4
  %2732 = insertvalue { ptr, ptr, ptr, i32 } %2730, i32 %2731, 3
  %hash_coef_ptr.i.i10.i3061 = getelementptr i8, ptr %2725, i64 8
  %tbl_size_ptr.i.i11.i3062 = getelementptr i8, ptr %2725, i64 16
  %offset_tbl_ptr.i.i12.i3063 = getelementptr i8, ptr %2725, i64 40
  %hash_coef.i.i13.i3064 = load i64, ptr %hash_coef_ptr.i.i10.i3061, align 4
  %tbl_size.i.i14.i3065 = load i64, ptr %tbl_size_ptr.i.i11.i3062, align 4
  %offset_tbl.i.i15.i3066 = load ptr, ptr %offset_tbl_ptr.i.i12.i3063, align 8
  %product.i.i.i16.i3067 = mul i64 %hash_coef.i.i13.i3064, -5261542750394134544
  %shifted.i.i.i17.i3068 = lshr i64 %product.i.i.i16.i3067, 32
  %xored.i.i.i18.i3069 = xor i64 %shifted.i.i.i17.i3068, %product.i.i.i16.i3067
  %hash.i.i.i19.i3070 = and i64 %xored.i.i.i18.i3069, %tbl_size.i.i14.i3065
  %offset_ptr.i.i20.i3071 = getelementptr i32, ptr %offset_tbl.i.i15.i3066, i64 %hash.i.i.i19.i3070
  %offset.i.i21.i3072 = load i32, ptr %offset_ptr.i.i20.i3071, align 4
  %eq.i.i3073 = icmp eq i32 %2731, %offset.i.i21.i3072
  call void @llvm.assume(i1 %eq.i.i3073) #30
  %2733 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2734 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2725)
  %2735 = sext i32 %2731 to i64
  %2736 = getelementptr ptr, ptr %2725, i64 %2735
  %2737 = getelementptr i8, ptr %2736, i64 64
  %2738 = load ptr, ptr %2737, align 8
  %2739 = call ptr %2738({ ptr, ptr, ptr, i32 } %2732, ptr nonnull %2)
  %2740 = call i32 %2739({ ptr, ptr, ptr, i32 } %2732, { ptr, ptr, ptr, i32 } %2732, ptr nonnull %2)
  %2741 = add i32 %2740, -1
  %2742 = and i32 %2741, %2720
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2743 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2744 = load ptr, ptr %205, align 8
  %2745 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2744, 0
  %2746 = load ptr, ptr %206, align 8
  %2747 = insertvalue { ptr, ptr, ptr, i32 } %2745, ptr %2746, 1
  %2748 = load ptr, ptr %207, align 8
  %2749 = insertvalue { ptr, ptr, ptr, i32 } %2747, ptr %2748, 2
  %2750 = load i32, ptr %208, align 4
  %2751 = insertvalue { ptr, ptr, ptr, i32 } %2749, i32 %2750, 3
  %hash_coef_ptr.i.i172.i1442 = getelementptr i8, ptr %2744, i64 8
  %tbl_size_ptr.i.i173.i1443 = getelementptr i8, ptr %2744, i64 16
  %offset_tbl_ptr.i.i174.i1444 = getelementptr i8, ptr %2744, i64 40
  %hash_coef.i.i175.i1445 = load i64, ptr %hash_coef_ptr.i.i172.i1442, align 4
  %tbl_size.i.i176.i1446 = load i64, ptr %tbl_size_ptr.i.i173.i1443, align 4
  %offset_tbl.i.i177.i1447 = load ptr, ptr %offset_tbl_ptr.i.i174.i1444, align 8
  %product.i.i.i178.i1448 = mul i64 %hash_coef.i.i175.i1445, -5261542750394134544
  %shifted.i.i.i179.i1449 = lshr i64 %product.i.i.i178.i1448, 32
  %xored.i.i.i180.i1450 = xor i64 %shifted.i.i.i179.i1449, %product.i.i.i178.i1448
  %hash.i.i.i181.i1451 = and i64 %xored.i.i.i180.i1450, %tbl_size.i.i176.i1446
  %offset_ptr.i.i182.i1452 = getelementptr i32, ptr %offset_tbl.i.i177.i1447, i64 %hash.i.i.i181.i1451
  %offset.i.i183.i1453 = load i32, ptr %offset_ptr.i.i182.i1452, align 4
  %eq.i.i1454 = icmp eq i32 %2750, %offset.i.i183.i1453
  call void @llvm.assume(i1 %eq.i.i1454) #30
  store ptr @_parameterization_Ptri32, ptr %60, align 8
  %2752 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %60)
  %2753 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2744)
  %2754 = sext i32 %2750 to i64
  %2755 = getelementptr ptr, ptr %2744, i64 %2754
  %2756 = getelementptr i8, ptr %2755, i64 120
  %2757 = load ptr, ptr %2756, align 8
  store ptr @i32_typ, ptr %61, align 8
  %2758 = call ptr %2757({ ptr, ptr, ptr, i32 } %2751, ptr nonnull %61)
  %2759 = call { ptr, i160 } %2758({ ptr, ptr, ptr, i32 } %2751, { ptr, ptr, ptr, i32 } %2751, ptr nonnull %60, i32 %2742)
  %.fca.0.extract112.i1455 = extractvalue { ptr, i160 } %2759, 0
  %.sroa.3111.0.insert.ext.i1456 = zext i32 %offset.i.i260.i14371768 to i160
  %.sroa.3111.0.insert.shift.i1457 = shl nuw i160 %.sroa.3111.0.insert.ext.i1456, 128
  %.sroa.2110.0.insert.ext.i1458 = zext i64 %2713 to i160
  %.sroa.2110.0.insert.shift.i1459 = shl nuw nsw i160 %.sroa.2110.0.insert.ext.i1458, 64
  %.sroa.2110.0.insert.insert.i1460 = or disjoint i160 %.sroa.2110.0.insert.shift.i1459, %.sroa.3111.0.insert.shift.i1457
  %.sroa.0109.0.insert.ext.i1461 = zext i64 %2712 to i160
  %.sroa.0109.0.insert.insert.i1462 = or disjoint i160 %.sroa.2110.0.insert.insert.i1460, %.sroa.0109.0.insert.ext.i1461
  %2760 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0109.0.insert.insert.i1462, 1
  %2761 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2762 = load ptr, ptr %205, align 8
  %2763 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2762, 0
  %2764 = load ptr, ptr %206, align 8
  %2765 = insertvalue { ptr, ptr, ptr, i32 } %2763, ptr %2764, 1
  %2766 = load ptr, ptr %207, align 8
  %2767 = insertvalue { ptr, ptr, ptr, i32 } %2765, ptr %2766, 2
  %2768 = load i32, ptr %208, align 4
  %2769 = insertvalue { ptr, ptr, ptr, i32 } %2767, i32 %2768, 3
  %hash_coef_ptr.i.i186.i1467 = getelementptr i8, ptr %2762, i64 8
  %tbl_size_ptr.i.i187.i1468 = getelementptr i8, ptr %2762, i64 16
  %offset_tbl_ptr.i.i188.i1469 = getelementptr i8, ptr %2762, i64 40
  %hash_coef.i.i189.i1470 = load i64, ptr %hash_coef_ptr.i.i186.i1467, align 4
  %tbl_size.i.i190.i1471 = load i64, ptr %tbl_size_ptr.i.i187.i1468, align 4
  %offset_tbl.i.i191.i1472 = load ptr, ptr %offset_tbl_ptr.i.i188.i1469, align 8
  %product.i.i.i192.i1473 = mul i64 %hash_coef.i.i189.i1470, -5261542750394134544
  %shifted.i.i.i193.i1474 = lshr i64 %product.i.i.i192.i1473, 32
  %xored.i.i.i194.i1475 = xor i64 %shifted.i.i.i193.i1474, %product.i.i.i192.i1473
  %hash.i.i.i195.i1476 = and i64 %xored.i.i.i194.i1475, %tbl_size.i.i190.i1471
  %offset_ptr.i.i196.i1477 = getelementptr i32, ptr %offset_tbl.i.i191.i1472, i64 %hash.i.i.i195.i1476
  %offset.i.i197.i1478 = load i32, ptr %offset_ptr.i.i196.i1477, align 4
  %eq.i200.i1479 = icmp eq i32 %2768, %offset.i.i197.i1478
  call void @llvm.assume(i1 %eq.i200.i1479) #30
  %2770 = load ptr, ptr %result.i134, align 8
  %2771 = load ptr, ptr %188, align 8
  %result.i.i1480 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2772 = getelementptr i8, ptr %result.i.i1480, i64 16
  store ptr %2771, ptr %2772, align 8
  %2773 = getelementptr i8, ptr %result.i.i1480, i64 8
  store ptr %2770, ptr %2773, align 8
  %2774 = getelementptr i8, ptr %result.i.i1480, i64 24
  store ptr null, ptr %2774, align 8
  %2775 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i.i1480)
  store ptr @Entry, ptr %result.i.i1480, align 8
  store ptr @_parameterization_Ptri32, ptr %62, align 8
  store ptr %result.i.i1480, ptr %286, align 8
  %2776 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %62)
  %2777 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2762)
  %2778 = sext i32 %2768 to i64
  %2779 = getelementptr ptr, ptr %2762, i64 %2778
  %2780 = getelementptr i8, ptr %2779, i64 128
  %2781 = load ptr, ptr %2780, align 8
  store ptr @i32_typ, ptr %63, align 8
  store ptr @Entry, ptr %287, align 8
  %2782 = call ptr %2781({ ptr, ptr, ptr, i32 } %2769, ptr nonnull %63)
  call void %2782({ ptr, ptr, ptr, i32 } %2769, { ptr, ptr, ptr, i32 } %2769, ptr nonnull %62, i32 %2742, { ptr, i160 } %2760)
  %2783 = icmp ne ptr %.fca.0.extract112.i1455, @nil_typ
  %2784 = icmp ne ptr %.fca.0.extract112.i1455, null
  %.not140.i1481 = and i1 %2783, %2784
  br i1 %.not140.i1481, label %.cont.cont.i1420, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1487.thread

2785:                                             ; preds = %2710
  %2786 = add i32 %2720, 2127912214
  %2787 = shl i32 %2720, 12
  %2788 = add i32 %2786, %2787
  %2789 = ashr i32 %2788, 19
  %2790 = xor i32 %2788, %2789
  %2791 = xor i32 %2790, -949894596
  %2792 = add i32 %2791, 374761393
  %2793 = shl i32 %2791, 5
  %2794 = add i32 %2792, %2793
  %2795 = add i32 %2794, -744332180
  %2796 = shl i32 %2794, 9
  %2797 = xor i32 %2795, %2796
  %2798 = add i32 %2797, -42973499
  %2799 = shl i32 %2797, 3
  %2800 = add i32 %2798, %2799
  %2801 = ashr i32 %2800, 16
  %2802 = xor i32 %2800, %2801
  %2803 = xor i32 %2802, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2804 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2805 = load ptr, ptr %222, align 8
  %2806 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2805, 0
  %2807 = load ptr, ptr %223, align 8
  %2808 = insertvalue { ptr, ptr, ptr, i32 } %2806, ptr %2807, 1
  %2809 = load ptr, ptr %224, align 8
  %2810 = insertvalue { ptr, ptr, ptr, i32 } %2808, ptr %2809, 2
  %2811 = load i32, ptr %225, align 4
  %2812 = insertvalue { ptr, ptr, ptr, i32 } %2810, i32 %2811, 3
  %hash_coef_ptr.i.i10.i3091 = getelementptr i8, ptr %2805, i64 8
  %tbl_size_ptr.i.i11.i3092 = getelementptr i8, ptr %2805, i64 16
  %offset_tbl_ptr.i.i12.i3093 = getelementptr i8, ptr %2805, i64 40
  %hash_coef.i.i13.i3094 = load i64, ptr %hash_coef_ptr.i.i10.i3091, align 4
  %tbl_size.i.i14.i3095 = load i64, ptr %tbl_size_ptr.i.i11.i3092, align 4
  %offset_tbl.i.i15.i3096 = load ptr, ptr %offset_tbl_ptr.i.i12.i3093, align 8
  %product.i.i.i16.i3097 = mul i64 %hash_coef.i.i13.i3094, -5261542750394134544
  %shifted.i.i.i17.i3098 = lshr i64 %product.i.i.i16.i3097, 32
  %xored.i.i.i18.i3099 = xor i64 %shifted.i.i.i17.i3098, %product.i.i.i16.i3097
  %hash.i.i.i19.i3100 = and i64 %xored.i.i.i18.i3099, %tbl_size.i.i14.i3095
  %offset_ptr.i.i20.i3101 = getelementptr i32, ptr %offset_tbl.i.i15.i3096, i64 %hash.i.i.i19.i3100
  %offset.i.i21.i3102 = load i32, ptr %offset_ptr.i.i20.i3101, align 4
  %eq.i.i3103 = icmp eq i32 %2811, %offset.i.i21.i3102
  call void @llvm.assume(i1 %eq.i.i3103) #30
  %2813 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2814 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2805)
  %2815 = sext i32 %2811 to i64
  %2816 = getelementptr ptr, ptr %2805, i64 %2815
  %2817 = getelementptr i8, ptr %2816, i64 64
  %2818 = load ptr, ptr %2817, align 8
  %2819 = call ptr %2818({ ptr, ptr, ptr, i32 } %2812, ptr nonnull %2)
  %2820 = call i32 %2819({ ptr, ptr, ptr, i32 } %2812, { ptr, ptr, ptr, i32 } %2812, ptr nonnull %2)
  %2821 = add i32 %2820, -1
  %2822 = and i32 %2821, %2803
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2823 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2824 = load ptr, ptr %222, align 8
  %2825 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2824, 0
  %2826 = load ptr, ptr %223, align 8
  %2827 = insertvalue { ptr, ptr, ptr, i32 } %2825, ptr %2826, 1
  %2828 = load ptr, ptr %224, align 8
  %2829 = insertvalue { ptr, ptr, ptr, i32 } %2827, ptr %2828, 2
  %2830 = load i32, ptr %225, align 4
  %2831 = insertvalue { ptr, ptr, ptr, i32 } %2829, i32 %2830, 3
  %hash_coef_ptr.i.i202.i1374 = getelementptr i8, ptr %2824, i64 8
  %tbl_size_ptr.i.i203.i1375 = getelementptr i8, ptr %2824, i64 16
  %offset_tbl_ptr.i.i204.i1376 = getelementptr i8, ptr %2824, i64 40
  %hash_coef.i.i205.i1377 = load i64, ptr %hash_coef_ptr.i.i202.i1374, align 4
  %tbl_size.i.i206.i1378 = load i64, ptr %tbl_size_ptr.i.i203.i1375, align 4
  %offset_tbl.i.i207.i1379 = load ptr, ptr %offset_tbl_ptr.i.i204.i1376, align 8
  %product.i.i.i208.i1380 = mul i64 %hash_coef.i.i205.i1377, -5261542750394134544
  %shifted.i.i.i209.i1381 = lshr i64 %product.i.i.i208.i1380, 32
  %xored.i.i.i210.i1382 = xor i64 %shifted.i.i.i209.i1381, %product.i.i.i208.i1380
  %hash.i.i.i211.i1383 = and i64 %xored.i.i.i210.i1382, %tbl_size.i.i206.i1378
  %offset_ptr.i.i212.i1384 = getelementptr i32, ptr %offset_tbl.i.i207.i1379, i64 %hash.i.i.i211.i1383
  %offset.i.i213.i1385 = load i32, ptr %offset_ptr.i.i212.i1384, align 4
  %eq.i216.i1386 = icmp eq i32 %2830, %offset.i.i213.i1385
  call void @llvm.assume(i1 %eq.i216.i1386) #30
  store ptr @_parameterization_Ptri32, ptr %68, align 8
  %2832 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %68)
  %2833 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2824)
  %2834 = sext i32 %2830 to i64
  %2835 = getelementptr ptr, ptr %2824, i64 %2834
  %2836 = getelementptr i8, ptr %2835, i64 120
  %2837 = load ptr, ptr %2836, align 8
  store ptr @i32_typ, ptr %69, align 8
  %2838 = call ptr %2837({ ptr, ptr, ptr, i32 } %2831, ptr nonnull %69)
  %2839 = call { ptr, i160 } %2838({ ptr, ptr, ptr, i32 } %2831, { ptr, ptr, ptr, i32 } %2831, ptr nonnull %68, i32 %2822)
  %.fca.0.extract87.i1387 = extractvalue { ptr, i160 } %2839, 0
  %.sroa.3.0.insert.ext.i1388 = zext i32 %offset.i.i260.i14371768 to i160
  %.sroa.3.0.insert.shift.i1389 = shl nuw i160 %.sroa.3.0.insert.ext.i1388, 128
  %.sroa.2.0.insert.ext.i1390 = zext i64 %2713 to i160
  %.sroa.2.0.insert.shift.i1391 = shl nuw nsw i160 %.sroa.2.0.insert.ext.i1390, 64
  %.sroa.2.0.insert.insert.i1392 = or disjoint i160 %.sroa.2.0.insert.shift.i1391, %.sroa.3.0.insert.shift.i1389
  %.sroa.0.0.insert.ext.i1393 = zext i64 %2712 to i160
  %.sroa.0.0.insert.insert.i1394 = or disjoint i160 %.sroa.2.0.insert.insert.i1392, %.sroa.0.0.insert.ext.i1393
  %2840 = insertvalue { ptr, i160 } { ptr @Entry, i160 undef }, i160 %.sroa.0.0.insert.insert.i1394, 1
  %2841 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2842 = load ptr, ptr %222, align 8
  %2843 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2842, 0
  %2844 = load ptr, ptr %223, align 8
  %2845 = insertvalue { ptr, ptr, ptr, i32 } %2843, ptr %2844, 1
  %2846 = load ptr, ptr %224, align 8
  %2847 = insertvalue { ptr, ptr, ptr, i32 } %2845, ptr %2846, 2
  %2848 = load i32, ptr %225, align 4
  %2849 = insertvalue { ptr, ptr, ptr, i32 } %2847, i32 %2848, 3
  %hash_coef_ptr.i.i218.i1399 = getelementptr i8, ptr %2842, i64 8
  %tbl_size_ptr.i.i219.i1400 = getelementptr i8, ptr %2842, i64 16
  %offset_tbl_ptr.i.i220.i1401 = getelementptr i8, ptr %2842, i64 40
  %hash_coef.i.i221.i1402 = load i64, ptr %hash_coef_ptr.i.i218.i1399, align 4
  %tbl_size.i.i222.i1403 = load i64, ptr %tbl_size_ptr.i.i219.i1400, align 4
  %offset_tbl.i.i223.i1404 = load ptr, ptr %offset_tbl_ptr.i.i220.i1401, align 8
  %product.i.i.i224.i1405 = mul i64 %hash_coef.i.i221.i1402, -5261542750394134544
  %shifted.i.i.i225.i1406 = lshr i64 %product.i.i.i224.i1405, 32
  %xored.i.i.i226.i1407 = xor i64 %shifted.i.i.i225.i1406, %product.i.i.i224.i1405
  %hash.i.i.i227.i1408 = and i64 %xored.i.i.i226.i1407, %tbl_size.i.i222.i1403
  %offset_ptr.i.i228.i1409 = getelementptr i32, ptr %offset_tbl.i.i223.i1404, i64 %hash.i.i.i227.i1408
  %offset.i.i229.i1410 = load i32, ptr %offset_ptr.i.i228.i1409, align 4
  %eq.i232.i1411 = icmp eq i32 %2848, %offset.i.i229.i1410
  call void @llvm.assume(i1 %eq.i232.i1411) #30
  %2850 = load ptr, ptr %result.i134, align 8
  %2851 = load ptr, ptr %188, align 8
  %result.i233.i1412 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2852 = getelementptr i8, ptr %result.i233.i1412, i64 16
  store ptr %2851, ptr %2852, align 8
  %2853 = getelementptr i8, ptr %result.i233.i1412, i64 8
  store ptr %2850, ptr %2853, align 8
  %2854 = getelementptr i8, ptr %result.i233.i1412, i64 24
  store ptr null, ptr %2854, align 8
  %2855 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i233.i1412)
  store ptr @Entry, ptr %result.i233.i1412, align 8
  store ptr @_parameterization_Ptri32, ptr %70, align 8
  store ptr %result.i233.i1412, ptr %284, align 8
  %2856 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %70)
  %2857 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2842)
  %2858 = sext i32 %2848 to i64
  %2859 = getelementptr ptr, ptr %2842, i64 %2858
  %2860 = getelementptr i8, ptr %2859, i64 128
  %2861 = load ptr, ptr %2860, align 8
  store ptr @i32_typ, ptr %71, align 8
  store ptr @Entry, ptr %285, align 8
  %2862 = call ptr %2861({ ptr, ptr, ptr, i32 } %2849, ptr nonnull %71)
  call void %2862({ ptr, ptr, ptr, i32 } %2849, { ptr, ptr, ptr, i32 } %2849, ptr nonnull %70, i32 %2822, { ptr, i160 } %2840)
  %2863 = icmp ne ptr %.fca.0.extract87.i1387, @nil_typ
  %2864 = icmp ne ptr %.fca.0.extract87.i1387, null
  %.not138.i1413 = and i1 %2863, %2864
  br i1 %.not138.i1413, label %.cont.cont.i1420, label %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1487.thread

.cont.cont.i1420:                                 ; preds = %2785, %2723
  %.sink1779 = phi { ptr, i160 } [ %2759, %2723 ], [ %2839, %2785 ]
  %2865 = phi i32 [ 2, %2723 ], [ 1, %2785 ]
  %vptr.i248.sroa.speculated.i1423 = phi ptr [ %.fca.0.extract112.i1455, %2723 ], [ %.fca.0.extract87.i1387, %2785 ]
  %.fca.1.extract89.i1416 = extractvalue { ptr, i160 } %.sink1779, 1
  %.sroa.3407.sroa.4.0.extract.shift.i1417 = lshr i160 %.fca.1.extract89.i1416, 64
  %2866 = trunc i160 %.sroa.3407.sroa.4.0.extract.shift.i1417 to i64
  %2867 = insertelement <2 x i64> poison, i64 %2866, i64 0
  %2868 = trunc i160 %.fca.1.extract89.i1416 to i64
  %2869 = insertelement <2 x i64> %2867, i64 %2868, i64 1
  %hash_coef_ptr.i.i249.i1426 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1423, i64 8
  %tbl_size_ptr.i.i250.i1427 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1423, i64 16
  %offset_tbl_ptr.i.i251.i1428 = getelementptr i8, ptr %vptr.i248.sroa.speculated.i1423, i64 40
  %hash_coef.i.i252.i1429 = load i64, ptr %hash_coef_ptr.i.i249.i1426, align 4
  %tbl_size.i.i253.i1430 = load i64, ptr %tbl_size_ptr.i.i250.i1427, align 4
  %offset_tbl.i.i254.i1431 = load ptr, ptr %offset_tbl_ptr.i.i251.i1428, align 8
  %product.i.i.i255.i1432 = mul i64 %hash_coef.i.i252.i1429, 4015701072841558310
  %shifted.i.i.i256.i1433 = lshr i64 %product.i.i.i255.i1432, 32
  %xored.i.i.i257.i1434 = xor i64 %shifted.i.i.i256.i1433, %product.i.i.i255.i1432
  %hash.i.i.i258.i1435 = and i64 %xored.i.i.i257.i1434, %tbl_size.i.i253.i1430
  %offset_ptr.i.i259.i1436 = getelementptr i32, ptr %offset_tbl.i.i254.i1431, i64 %hash.i.i.i258.i1435
  %offset.i.i260.i1437 = load i32, ptr %offset_ptr.i.i259.i1436, align 4
  %2870 = add nuw nsw i32 %.reg2mem193.0677.i1369, 1
  %2871 = load i32, ptr %228, align 4
  %2872 = icmp slt i32 %2870, %2871
  br i1 %2872, label %2710, label %._crit_edge1.1.i

HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1487.thread: ; preds = %2723, %2785
  %2873 = phi ptr [ %72, %2785 ], [ %64, %2723 ]
  %2874 = phi ptr [ %73, %2785 ], [ %65, %2723 ]
  %2875 = phi ptr [ %74, %2785 ], [ %66, %2723 ]
  %2876 = phi ptr [ %.sroa.0.i1331, %2785 ], [ %.sroa.0680.i1329, %2723 ]
  %2877 = phi ptr [ %75, %2785 ], [ %67, %2723 ]
  %2878 = load i32, ptr %226, align 4
  store i32 %2878, ptr %2873, align 4
  store i32 1, ptr %2874, align 4
  %2879 = add i32 %2878, 1
  store i32 %2879, ptr %2875, align 4
  %2880 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %2879, ptr %226, align 4
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2877, align 8
  store i64 ptrtoint (ptr @nil_typ to i64), ptr %2876, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1329)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1331)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %75)
  br label %HashMap_insert_keyK_valueV.exit

._crit_edge1.1.i:                                 ; preds = %.cont.cont.i1420, %HashMap_resize_.exit1328
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %62)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %63)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %64)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %65)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0680.i1329)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %67)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %68)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %69)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %70)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %71)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %72)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %73)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %74)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i1331)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %75)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %57)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %59)
  %2881 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2882 = load ptr, ptr %205, align 8
  %2883 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2882, 0
  %2884 = load ptr, ptr %206, align 8
  %2885 = insertvalue { ptr, ptr, ptr, i32 } %2883, ptr %2884, 1
  %2886 = load ptr, ptr %207, align 8
  %2887 = insertvalue { ptr, ptr, ptr, i32 } %2885, ptr %2886, 2
  %2888 = load i32, ptr %208, align 4
  %2889 = insertvalue { ptr, ptr, ptr, i32 } %2887, i32 %2888, 3
  %hash_coef_ptr.i.i64.i1505 = getelementptr i8, ptr %2882, i64 8
  %tbl_size_ptr.i.i65.i1506 = getelementptr i8, ptr %2882, i64 16
  %offset_tbl_ptr.i.i66.i1507 = getelementptr i8, ptr %2882, i64 40
  %hash_coef.i.i67.i1508 = load i64, ptr %hash_coef_ptr.i.i64.i1505, align 4
  %tbl_size.i.i68.i1509 = load i64, ptr %tbl_size_ptr.i.i65.i1506, align 4
  %offset_tbl.i.i69.i1510 = load ptr, ptr %offset_tbl_ptr.i.i66.i1507, align 8
  %product.i.i.i70.i1511 = mul i64 %hash_coef.i.i67.i1508, -5261542750394134544
  %shifted.i.i.i71.i1512 = lshr i64 %product.i.i.i70.i1511, 32
  %xored.i.i.i72.i1513 = xor i64 %shifted.i.i.i71.i1512, %product.i.i.i70.i1511
  %hash.i.i.i73.i1514 = and i64 %xored.i.i.i72.i1513, %tbl_size.i.i68.i1509
  %offset_ptr.i.i74.i1515 = getelementptr i32, ptr %offset_tbl.i.i69.i1510, i64 %hash.i.i.i73.i1514
  %offset.i.i75.i1516 = load i32, ptr %offset_ptr.i.i74.i1515, align 4
  %eq.i.i1517 = icmp eq i32 %2888, %offset.i.i75.i1516
  call void @llvm.assume(i1 %eq.i.i1517) #30
  %2890 = load ptr, ptr %222, align 8
  %2891 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2890, 0
  %2892 = load ptr, ptr %223, align 8
  %2893 = insertvalue { ptr, ptr, ptr, i32 } %2891, ptr %2892, 1
  %2894 = load ptr, ptr %224, align 8
  %2895 = insertvalue { ptr, ptr, ptr, i32 } %2893, ptr %2894, 2
  %2896 = load i32, ptr %225, align 4
  %2897 = insertvalue { ptr, ptr, ptr, i32 } %2895, i32 %2896, 3
  %hash_coef_ptr.i.i92.i1522 = getelementptr i8, ptr %2890, i64 8
  %tbl_size_ptr.i.i93.i1523 = getelementptr i8, ptr %2890, i64 16
  %offset_tbl_ptr.i.i94.i1524 = getelementptr i8, ptr %2890, i64 40
  %hash_coef.i.i95.i1525 = load i64, ptr %hash_coef_ptr.i.i92.i1522, align 4
  %tbl_size.i.i96.i1526 = load i64, ptr %tbl_size_ptr.i.i93.i1523, align 4
  %offset_tbl.i.i97.i1527 = load ptr, ptr %offset_tbl_ptr.i.i94.i1524, align 8
  %product.i.i.i98.i1528 = mul i64 %hash_coef.i.i95.i1525, -5261542750394134544
  %shifted.i.i.i99.i1529 = lshr i64 %product.i.i.i98.i1528, 32
  %xored.i.i.i100.i1530 = xor i64 %shifted.i.i.i99.i1529, %product.i.i.i98.i1528
  %hash.i.i.i101.i1531 = and i64 %xored.i.i.i100.i1530, %tbl_size.i.i96.i1526
  %offset_ptr.i.i102.i1532 = getelementptr i32, ptr %offset_tbl.i.i97.i1527, i64 %hash.i.i.i101.i1531
  %offset.i.i103.i1533 = load i32, ptr %offset_ptr.i.i102.i1532, align 4
  %eq.i106.i1534 = icmp eq i32 %2896, %offset.i.i103.i1533
  call void @llvm.assume(i1 %eq.i106.i1534) #30
  %2898 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2899 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2882)
  %2900 = sext i32 %2888 to i64
  %2901 = getelementptr ptr, ptr %2882, i64 %2900
  %2902 = getelementptr i8, ptr %2901, i64 64
  %2903 = load ptr, ptr %2902, align 8
  %2904 = call ptr %2903({ ptr, ptr, ptr, i32 } %2889, ptr nonnull %2)
  %2905 = call i32 %2904({ ptr, ptr, ptr, i32 } %2889, { ptr, ptr, ptr, i32 } %2889, ptr nonnull %2)
  %2906 = shl i32 %2905, 1
  %2907 = load i32, ptr %226, align 4
  %2908 = load ptr, ptr %result.i134, align 8
  %2909 = load ptr, ptr %188, align 8
  %2910 = sext i32 %2907 to i64
  %2911 = shl nsw i64 %2910, 5
  %result.i.i.i1537 = call noalias ptr @bump_malloc_inner(i64 noundef %2911, ptr nonnull @current_ptr) #29
  %2912 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2913 = icmp sgt i32 %2905, 0
  br i1 %2913, label %.lr.ph434.i1607, label %._crit_edge395.i1551

.lr.ph434.i1607:                                  ; preds = %._crit_edge1.1.i
  %invariant.gep.i1550 = getelementptr i8, ptr %2882, i64 120
  %2914 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %gep.i1610 = getelementptr ptr, ptr %invariant.gep.i1550, i64 %2900
  br label %2915

2915:                                             ; preds = %2937, %.lr.ph434.i1607
  %.reg2mem105.0432.i1608 = phi i32 [ 0, %.lr.ph434.i1607 ], [ %.reg2mem101.0.i1613, %2937 ]
  %.reg2mem103.0431.i1609 = phi i32 [ 0, %.lr.ph434.i1607 ], [ %2938, %2937 ]
  store ptr @_parameterization_Ptri32, ptr %54, align 8
  %2916 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %54)
  %2917 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %2882)
  %2918 = load ptr, ptr %gep.i1610, align 8
  store ptr @i32_typ, ptr %55, align 8
  %2919 = call ptr %2918({ ptr, ptr, ptr, i32 } %2889, ptr nonnull %55)
  %2920 = call { ptr, i160 } %2919({ ptr, ptr, ptr, i32 } %2889, { ptr, ptr, ptr, i32 } %2889, ptr nonnull %54, i32 %.reg2mem103.0431.i1609)
  %.fca.0.extract52.i1611 = extractvalue { ptr, i160 } %2920, 0
  %2921 = icmp ne ptr %.fca.0.extract52.i1611, @nil_typ
  %2922 = icmp ne ptr %.fca.0.extract52.i1611, null
  %.not60.i1612 = and i1 %2921, %2922
  br i1 %.not60.i1612, label %2923, label %2937

2923:                                             ; preds = %2915
  %hash_coef_ptr.i.i137.i1640 = getelementptr i8, ptr %.fca.0.extract52.i1611, i64 8
  %tbl_size_ptr.i.i138.i1641 = getelementptr i8, ptr %.fca.0.extract52.i1611, i64 16
  %offset_tbl_ptr.i.i139.i1642 = getelementptr i8, ptr %.fca.0.extract52.i1611, i64 40
  %hash_coef.i.i140.i1643 = load i64, ptr %hash_coef_ptr.i.i137.i1640, align 4
  %tbl_size.i.i141.i1644 = load i64, ptr %tbl_size_ptr.i.i138.i1641, align 4
  %offset_tbl.i.i142.i1645 = load ptr, ptr %offset_tbl_ptr.i.i139.i1642, align 8
  %product.i.i.i143.i1646 = mul i64 %hash_coef.i.i140.i1643, 4015701072841558310
  %shifted.i.i.i144.i1647 = lshr i64 %product.i.i.i143.i1646, 32
  %xored.i.i.i145.i1648 = xor i64 %shifted.i.i.i144.i1647, %product.i.i.i143.i1646
  %hash.i.i.i146.i1649 = and i64 %xored.i.i.i145.i1648, %tbl_size.i.i141.i1644
  %offset_ptr.i.i147.i1650 = getelementptr i32, ptr %offset_tbl.i.i142.i1645, i64 %hash.i.i.i146.i1649
  %offset.i.i148.i1651 = load i32, ptr %offset_ptr.i.i147.i1650, align 4
  %2924 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2925 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2926 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2927 = icmp slt i32 %.reg2mem105.0432.i1608, %2907
  br i1 %2927, label %2928, label %._crit_edge.i1652

2928:                                             ; preds = %2923
  %.fca.1.extract54.i1653 = extractvalue { ptr, i160 } %2920, 1
  %.sroa.351.0.insert.ext.i1654 = zext i32 %offset.i.i148.i1651 to i160
  %.sroa.351.0.insert.shift.i1655 = shl nuw i160 %.sroa.351.0.insert.ext.i1654, 128
  %2929 = and i160 %.fca.1.extract54.i1653, 340282366920938463463374607431768211455
  %.sroa.049.0.insert.insert.i1656 = or disjoint i160 %.sroa.351.0.insert.shift.i1655, %2929
  %2930 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2931 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2932 = sext i32 %.reg2mem105.0432.i1608 to i64
  %2933 = shl nsw i64 %2932, 5
  %2934 = getelementptr i8, ptr %result.i.i.i1537, i64 %2933
  store ptr %.fca.0.extract52.i1611, ptr %2934, align 8
  %2935 = getelementptr i8, ptr %2934, i64 8
  store i160 %.sroa.049.0.insert.insert.i1656, ptr %2935, align 4
  br label %._crit_edge.i1652

._crit_edge.i1652:                                ; preds = %2928, %2923
  %2936 = add i32 %.reg2mem105.0432.i1608, 1
  br label %2937

2937:                                             ; preds = %._crit_edge.i1652, %2915
  %.reg2mem101.0.i1613 = phi i32 [ %2936, %._crit_edge.i1652 ], [ %.reg2mem105.0432.i1608, %2915 ]
  %2938 = add nuw nsw i32 %.reg2mem103.0431.i1609, 1
  %2939 = icmp slt i32 %2938, %2905
  br i1 %2939, label %2915, label %.lr.ph.i1614

.lr.ph.i1614:                                     ; preds = %2937
  %invariant.gep396.i1615 = getelementptr i8, ptr %2890, i64 120
  %2940 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2941 = sext i32 %2896 to i64
  %gep397.i1618 = getelementptr ptr, ptr %invariant.gep396.i1615, i64 %2941
  br label %2942

2942:                                             ; preds = %2964, %.lr.ph.i1614
  %.reg2mem91.0394.i1616 = phi i32 [ %.reg2mem101.0.i1613, %.lr.ph.i1614 ], [ %.reg2mem87.0.i1621, %2964 ]
  %.reg2mem89.0393.i1617 = phi i32 [ 0, %.lr.ph.i1614 ], [ %2965, %2964 ]
  store ptr @_parameterization_Ptri32, ptr %56, align 8
  %2943 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %56)
  %2944 = call ptr @llvm.invariant.start.p0(i64 600, ptr %2890)
  %2945 = load ptr, ptr %gep397.i1618, align 8
  store ptr @i32_typ, ptr %57, align 8
  %2946 = call ptr %2945({ ptr, ptr, ptr, i32 } %2897, ptr nonnull %57)
  %2947 = call { ptr, i160 } %2946({ ptr, ptr, ptr, i32 } %2897, { ptr, ptr, ptr, i32 } %2897, ptr nonnull %56, i32 %.reg2mem89.0393.i1617)
  %.fca.0.extract42.i1619 = extractvalue { ptr, i160 } %2947, 0
  %2948 = icmp ne ptr %.fca.0.extract42.i1619, @nil_typ
  %2949 = icmp ne ptr %.fca.0.extract42.i1619, null
  %.not62.i1620 = and i1 %2948, %2949
  br i1 %.not62.i1620, label %2950, label %2964

2950:                                             ; preds = %2942
  %hash_coef_ptr.i.i152.i1622 = getelementptr i8, ptr %.fca.0.extract42.i1619, i64 8
  %tbl_size_ptr.i.i153.i1623 = getelementptr i8, ptr %.fca.0.extract42.i1619, i64 16
  %offset_tbl_ptr.i.i154.i1624 = getelementptr i8, ptr %.fca.0.extract42.i1619, i64 40
  %hash_coef.i.i155.i1625 = load i64, ptr %hash_coef_ptr.i.i152.i1622, align 4
  %tbl_size.i.i156.i1626 = load i64, ptr %tbl_size_ptr.i.i153.i1623, align 4
  %offset_tbl.i.i157.i1627 = load ptr, ptr %offset_tbl_ptr.i.i154.i1624, align 8
  %product.i.i.i158.i1628 = mul i64 %hash_coef.i.i155.i1625, 4015701072841558310
  %shifted.i.i.i159.i1629 = lshr i64 %product.i.i.i158.i1628, 32
  %xored.i.i.i160.i1630 = xor i64 %shifted.i.i.i159.i1629, %product.i.i.i158.i1628
  %hash.i.i.i161.i1631 = and i64 %xored.i.i.i160.i1630, %tbl_size.i.i156.i1626
  %offset_ptr.i.i162.i1632 = getelementptr i32, ptr %offset_tbl.i.i157.i1627, i64 %hash.i.i.i161.i1631
  %offset.i.i163.i1633 = load i32, ptr %offset_ptr.i.i162.i1632, align 4
  %2951 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2952 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %2953 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2954 = icmp slt i32 %.reg2mem91.0394.i1616, %2907
  br i1 %2954, label %2955, label %._crit_edge1.i1634

2955:                                             ; preds = %2950
  %.fca.1.extract44.i1635 = extractvalue { ptr, i160 } %2947, 1
  %.sroa.3.0.insert.ext.i1636 = zext i32 %offset.i.i163.i1633 to i160
  %.sroa.3.0.insert.shift.i1637 = shl nuw i160 %.sroa.3.0.insert.ext.i1636, 128
  %2956 = and i160 %.fca.1.extract44.i1635, 340282366920938463463374607431768211455
  %.sroa.040.0.insert.insert.i1638 = or disjoint i160 %.sroa.3.0.insert.shift.i1637, %2956
  %2957 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %2958 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2959 = sext i32 %.reg2mem91.0394.i1616 to i64
  %2960 = shl nsw i64 %2959, 5
  %2961 = getelementptr i8, ptr %result.i.i.i1537, i64 %2960
  store ptr %.fca.0.extract42.i1619, ptr %2961, align 8
  %2962 = getelementptr i8, ptr %2961, i64 8
  store i160 %.sroa.040.0.insert.insert.i1638, ptr %2962, align 4
  br label %._crit_edge1.i1634

._crit_edge1.i1634:                               ; preds = %2955, %2950
  %2963 = add i32 %.reg2mem91.0394.i1616, 1
  br label %2964

2964:                                             ; preds = %._crit_edge1.i1634, %2942
  %.reg2mem87.0.i1621 = phi i32 [ %2963, %._crit_edge1.i1634 ], [ %.reg2mem91.0394.i1616, %2942 ]
  %2965 = add nuw nsw i32 %.reg2mem89.0393.i1617, 1
  %2966 = icmp slt i32 %2965, %2905
  br i1 %2966, label %2942, label %._crit_edge395.i1551.loopexit

._crit_edge395.i1551.loopexit:                    ; preds = %2964
  %.pre2838 = load ptr, ptr %result.i134, align 8
  %.pre2839 = load ptr, ptr %188, align 8
  br label %._crit_edge395.i1551

._crit_edge395.i1551:                             ; preds = %._crit_edge395.i1551.loopexit, %._crit_edge1.1.i
  %2967 = phi ptr [ %2909, %._crit_edge1.1.i ], [ %.pre2839, %._crit_edge395.i1551.loopexit ]
  %2968 = phi ptr [ %2908, %._crit_edge1.1.i ], [ %.pre2838, %._crit_edge395.i1551.loopexit ]
  %.reg2mem91.0.lcssa.i1552 = phi i32 [ 0, %._crit_edge1.1.i ], [ %.reg2mem87.0.i1621, %._crit_edge395.i1551.loopexit ]
  %2969 = call i32 @llvm.smax.i32(i32 %2906, i32 16)
  %result.i166.i1553 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2970 = getelementptr i8, ptr %result.i166.i1553, i64 16
  store ptr @_parameterization_Nil, ptr %2970, align 8
  %result.i167.i1554 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2971 = getelementptr i8, ptr %result.i167.i1554, i64 16
  store ptr %2967, ptr %2971, align 8
  %2972 = getelementptr i8, ptr %result.i167.i1554, i64 8
  store ptr %2968, ptr %2972, align 8
  %2973 = getelementptr i8, ptr %result.i167.i1554, i64 24
  store ptr null, ptr %2973, align 8
  %2974 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i167.i1554)
  store ptr @Entry, ptr %result.i167.i1554, align 8
  %2975 = getelementptr i8, ptr %result.i166.i1553, i64 8
  store ptr %result.i167.i1554, ptr %2975, align 8
  %2976 = getelementptr i8, ptr %result.i166.i1553, i64 24
  store ptr null, ptr %2976, align 8
  %2977 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i166.i1553)
  store ptr @union_typ, ptr %result.i166.i1553, align 8
  %result.i168.i1555 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i166.i1553, ptr %result.i168.i1555, align 8
  %2978 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i168.i1555)
  store ptr @Array, ptr %58, align 8
  store ptr %result.i168.i1555, ptr %288, align 8
  store i32 9, ptr %289, align 8
  %2979 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %58)
  %2980 = getelementptr i8, ptr %result.i168.i1555, i64 16
  store i32 %2969, ptr %2980, align 4
  %2981 = getelementptr i8, ptr %result.i168.i1555, i64 20
  store i32 %2969, ptr %2981, align 4
  %2982 = zext nneg i32 %2969 to i64
  %2983 = shl nuw nsw i64 %2982, 5
  %result.i.i416.i1556 = call noalias ptr @bump_malloc_inner(i64 noundef %2983, ptr nonnull @current_ptr) #29
  %2984 = getelementptr i8, ptr %result.i168.i1555, i64 8
  store ptr %result.i.i416.i1556, ptr %2984, align 8
  %2985 = load ptr, ptr %290, align 8
  store ptr @Array, ptr %205, align 8
  store ptr %result.i168.i1555, ptr %206, align 8
  store ptr %2985, ptr %207, align 8
  store i32 9, ptr %208, align 4
  %result.i183.i1569 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2986 = getelementptr i8, ptr %result.i183.i1569, i64 16
  store ptr @_parameterization_Nil, ptr %2986, align 8
  %result.i184.i1570 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %2987 = getelementptr i8, ptr %result.i184.i1570, i64 16
  store ptr %2967, ptr %2987, align 8
  %2988 = getelementptr i8, ptr %result.i184.i1570, i64 8
  store ptr %2968, ptr %2988, align 8
  %2989 = getelementptr i8, ptr %result.i184.i1570, i64 24
  store ptr null, ptr %2989, align 8
  %2990 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i184.i1570)
  store ptr @Entry, ptr %result.i184.i1570, align 8
  %2991 = getelementptr i8, ptr %result.i183.i1569, i64 8
  store ptr %result.i184.i1570, ptr %2991, align 8
  %2992 = getelementptr i8, ptr %result.i183.i1569, i64 24
  store ptr null, ptr %2992, align 8
  %2993 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i183.i1569)
  store ptr @union_typ, ptr %result.i183.i1569, align 8
  %result.i185.i1571 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i183.i1569, ptr %result.i185.i1571, align 8
  %2994 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i185.i1571)
  store ptr @Array, ptr %59, align 8
  store ptr %result.i185.i1571, ptr %291, align 8
  store i32 9, ptr %292, align 8
  %2995 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %59)
  %2996 = getelementptr i8, ptr %result.i185.i1571, i64 16
  store i32 %2969, ptr %2996, align 4
  %2997 = getelementptr i8, ptr %result.i185.i1571, i64 20
  store i32 %2969, ptr %2997, align 4
  %result.i.i430.i1572 = call noalias ptr @bump_malloc_inner(i64 noundef %2983, ptr nonnull @current_ptr) #29
  %2998 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %2999 = getelementptr i8, ptr %result.i185.i1571, i64 8
  store ptr %result.i.i430.i1572, ptr %2999, align 8
  %3000 = load ptr, ptr %293, align 8
  store ptr @Array, ptr %222, align 8
  store ptr %result.i185.i1571, ptr %223, align 8
  store ptr %3000, ptr %224, align 8
  store i32 9, ptr %225, align 4
  %3001 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 0, ptr %226, align 4
  %3002 = icmp sgt i32 %.reg2mem91.0.lcssa.i1552, 0
  br i1 %3002, label %.lr.ph400.i1585, label %HashMap_resize_.exit1658

.lr.ph400.i1585:                                  ; preds = %._crit_edge395.i1551
  %3003 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3004 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %3005 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  br label %._crit_edge2.i1587

._crit_edge2.i1587:                               ; preds = %._crit_edge2.i1587, %.lr.ph400.i1585
  %.reg2mem77.0398.i1588 = phi i32 [ 0, %.lr.ph400.i1585 ], [ %3019, %._crit_edge2.i1587 ]
  %3006 = zext nneg i32 %.reg2mem77.0398.i1588 to i64
  %3007 = shl nuw nsw i64 %3006, 5
  %3008 = getelementptr i8, ptr %result.i.i.i1537, i64 %3007
  %3009 = load ptr, ptr %3008, align 8
  %3010 = getelementptr i8, ptr %3008, i64 8
  %3011 = load i160, ptr %3010, align 4
  %.sroa.3362.8.extract.trunc.i1591 = trunc i160 %3011 to i64
  %3012 = inttoptr i64 %.sroa.3362.8.extract.trunc.i1591 to ptr
  %.sroa.5363.8.extract.shift.i1592 = lshr i160 %3011, 64
  %.sroa.5363.8.extract.trunc.i1593 = trunc i160 %.sroa.5363.8.extract.shift.i1592 to i64
  %3013 = inttoptr i64 %.sroa.5363.8.extract.trunc.i1593 to ptr
  %hash_coef_ptr.i.i201.i1594 = getelementptr i8, ptr %3009, i64 8
  %tbl_size_ptr.i.i202.i1595 = getelementptr i8, ptr %3009, i64 16
  %offset_tbl_ptr.i.i203.i1596 = getelementptr i8, ptr %3009, i64 40
  %hash_coef.i.i232.i1597 = load i64, ptr %hash_coef_ptr.i.i201.i1594, align 4
  %tbl_size.i.i233.i1598 = load i64, ptr %tbl_size_ptr.i.i202.i1595, align 4
  %offset_tbl.i.i234.i1599 = load ptr, ptr %offset_tbl_ptr.i.i203.i1596, align 8
  %product.i.i.i235.i1600 = mul i64 %hash_coef.i.i232.i1597, 4015701072841558310
  %shifted.i.i.i236.i1601 = lshr i64 %product.i.i.i235.i1600, 32
  %xored.i.i.i237.i1602 = xor i64 %shifted.i.i.i236.i1601, %product.i.i.i235.i1600
  %hash.i.i.i238.i1603 = and i64 %xored.i.i.i237.i1602, %tbl_size.i.i233.i1598
  %offset_ptr.i.i239.i1604 = getelementptr i32, ptr %offset_tbl.i.i234.i1599, i64 %hash.i.i.i238.i1603
  %offset.i.i240.i1605 = load i32, ptr %offset_ptr.i.i239.i1604, align 4
  %3014 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3009, 0
  %3015 = insertvalue { ptr, ptr, ptr, i32 } %3014, ptr %3012, 1
  %3016 = insertvalue { ptr, ptr, ptr, i32 } %3015, ptr %3013, 2
  %3017 = insertvalue { ptr, ptr, ptr, i32 } %3016, i32 %offset.i.i240.i1605, 3
  %3018 = call { ptr, i160 } @HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } poison, ptr nonnull poison, { ptr, ptr, ptr, i32 } %3017)
  %3019 = add nuw nsw i32 %.reg2mem77.0398.i1588, 1
  %3020 = icmp slt i32 %3019, %.reg2mem91.0.lcssa.i1552
  br i1 %3020, label %._crit_edge2.i1587, label %HashMap_resize_.exit1658

HashMap_resize_.exit1658:                         ; preds = %._crit_edge2.i1587, %._crit_edge395.i1551
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %57)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %58)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %59)
  br label %HashMap_insert_keyK_valueV.exit

HashMap_insert_keyK_valueV.exit:                  ; preds = %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1487.thread, %HashMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %1833, %2029, %HashMap_resize_.exit1658
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %128)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %129)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %130)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %131)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %132)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %133)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %134)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %135)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %136)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %137)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %138)
  %3021 = add nsw i32 %.reg2mem129.0286, 1
  br label %3022

3022:                                             ; preds = %HashMap_insert_keyK_valueV.exit, %HashMap_get_keyK.exit
  %.reg2mem125.0 = phi i32 [ %3021, %HashMap_insert_keyK_valueV.exit ], [ %.reg2mem129.0286, %HashMap_get_keyK.exit ]
  %3023 = add nuw nsw i32 %.reg2mem127.0285, 1
  %3024 = icmp slt i32 %.reg2mem125.0, %0
  %3025 = icmp slt i32 %3023, %229
  %3026 = and i1 %3025, %3024
  br i1 %3026, label %326, label %._crit_edge288

._crit_edge288:                                   ; preds = %3022, %1
  %.reg2mem129.0.lcssa = phi i32 [ 0, %1 ], [ %.reg2mem125.0, %3022 ]
  %3027 = call i32 @llvm.smin.i32(i32 %.reg2mem129.0.lcssa, i32 %0)
  %3028 = call i64 @clock()
  %3029 = icmp sgt i32 %3027, 0
  br i1 %3029, label %.lr.ph293.preheader, label %._crit_edge294

.lr.ph293.preheader:                              ; preds = %._crit_edge288
  %3030 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %3031 = load ptr, ptr %187, align 8
  %invariant.gep = getelementptr i8, ptr %3031, i64 8
  %3032 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3033 = getelementptr inbounds i8, ptr %113, i64 8
  %3034 = getelementptr inbounds i8, ptr %114, i64 8
  %3035 = getelementptr inbounds i8, ptr %109, i64 8
  %3036 = getelementptr inbounds i8, ptr %110, i64 8
  %3037 = getelementptr i8, ptr %result.i, i64 40
  %3038 = getelementptr i8, ptr %result.i, i64 72
  %3039 = getelementptr i8, ptr %result.i, i64 88
  br label %.lr.ph293

.lr.ph293:                                        ; preds = %.lr.ph293.preheader, %3255
  %.reg2mem115.0291 = phi i32 [ %.reg2mem109.0, %3255 ], [ 0, %.lr.ph293.preheader ]
  %.reg2mem113.0290 = phi i1 [ %.reg2mem107.0, %3255 ], [ true, %.lr.ph293.preheader ]
  %.reg2mem111.0289 = phi i32 [ %3256, %3255 ], [ 0, %.lr.ph293.preheader ]
  %3040 = zext nneg i32 %.reg2mem111.0289 to i64
  %3041 = shl nuw nsw i64 %3040, 5
  %gep = getelementptr i8, ptr %invariant.gep, i64 %3041
  %3042 = load i160, ptr %gep, align 4
  %.sroa.052.0.insert.ext = and i160 %3042, 4294967295
  %3043 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.052.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %109)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %111)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %113)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %114)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %115)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %116)
  %3044 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3045 = load ptr, ptr %153, align 8
  %3046 = call i32 %3045({ ptr, i160 } %3043)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3047 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3048 = load ptr, ptr %165, align 8
  %3049 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3048, 0
  %3050 = load ptr, ptr %166, align 8
  %3051 = insertvalue { ptr, ptr, ptr, i32 } %3049, ptr %3050, 1
  %3052 = load ptr, ptr %3037, align 8
  %3053 = insertvalue { ptr, ptr, ptr, i32 } %3051, ptr %3052, 2
  %3054 = load i32, ptr %167, align 4
  %3055 = insertvalue { ptr, ptr, ptr, i32 } %3053, i32 %3054, 3
  %hash_coef_ptr.i.i10.i2672 = getelementptr i8, ptr %3048, i64 8
  %tbl_size_ptr.i.i11.i2673 = getelementptr i8, ptr %3048, i64 16
  %offset_tbl_ptr.i.i12.i2674 = getelementptr i8, ptr %3048, i64 40
  %hash_coef.i.i13.i2675 = load i64, ptr %hash_coef_ptr.i.i10.i2672, align 4
  %tbl_size.i.i14.i2676 = load i64, ptr %tbl_size_ptr.i.i11.i2673, align 4
  %offset_tbl.i.i15.i2677 = load ptr, ptr %offset_tbl_ptr.i.i12.i2674, align 8
  %product.i.i.i16.i2678 = mul i64 %hash_coef.i.i13.i2675, -5261542750394134544
  %shifted.i.i.i17.i2679 = lshr i64 %product.i.i.i16.i2678, 32
  %xored.i.i.i18.i2680 = xor i64 %shifted.i.i.i17.i2679, %product.i.i.i16.i2678
  %hash.i.i.i19.i2681 = and i64 %xored.i.i.i18.i2680, %tbl_size.i.i14.i2676
  %offset_ptr.i.i20.i2682 = getelementptr i32, ptr %offset_tbl.i.i15.i2677, i64 %hash.i.i.i19.i2681
  %offset.i.i21.i2683 = load i32, ptr %offset_ptr.i.i20.i2682, align 4
  %eq.i.i2684 = icmp eq i32 %3054, %offset.i.i21.i2683
  call void @llvm.assume(i1 %eq.i.i2684) #30
  %3056 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3057 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3048)
  %3058 = sext i32 %3054 to i64
  %3059 = getelementptr ptr, ptr %3048, i64 %3058
  %3060 = getelementptr i8, ptr %3059, i64 64
  %3061 = load ptr, ptr %3060, align 8
  %3062 = call ptr %3061({ ptr, ptr, ptr, i32 } %3055, ptr nonnull %2)
  %3063 = call i32 %3062({ ptr, ptr, ptr, i32 } %3055, { ptr, ptr, ptr, i32 } %3055, ptr nonnull %2)
  %3064 = add i32 %3063, -1
  %3065 = and i32 %3064, %3046
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3066 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3067 = load ptr, ptr %165, align 8
  %3068 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3067, 0
  %3069 = load ptr, ptr %166, align 8
  %3070 = insertvalue { ptr, ptr, ptr, i32 } %3068, ptr %3069, 1
  %3071 = load ptr, ptr %3037, align 8
  %3072 = insertvalue { ptr, ptr, ptr, i32 } %3070, ptr %3071, 2
  %3073 = load i32, ptr %167, align 4
  %3074 = insertvalue { ptr, ptr, ptr, i32 } %3072, i32 %3073, 3
  %hash_coef_ptr.i.i137.i = getelementptr i8, ptr %3067, i64 8
  %tbl_size_ptr.i.i138.i = getelementptr i8, ptr %3067, i64 16
  %offset_tbl_ptr.i.i139.i = getelementptr i8, ptr %3067, i64 40
  %hash_coef.i.i140.i = load i64, ptr %hash_coef_ptr.i.i137.i, align 4
  %tbl_size.i.i141.i = load i64, ptr %tbl_size_ptr.i.i138.i, align 4
  %offset_tbl.i.i142.i = load ptr, ptr %offset_tbl_ptr.i.i139.i, align 8
  %product.i.i.i143.i = mul i64 %hash_coef.i.i140.i, -5261542750394134544
  %shifted.i.i.i144.i = lshr i64 %product.i.i.i143.i, 32
  %xored.i.i.i145.i = xor i64 %shifted.i.i.i144.i, %product.i.i.i143.i
  %hash.i.i.i146.i = and i64 %xored.i.i.i145.i, %tbl_size.i.i141.i
  %offset_ptr.i.i147.i = getelementptr i32, ptr %offset_tbl.i.i142.i, i64 %hash.i.i.i146.i
  %offset.i.i148.i = load i32, ptr %offset_ptr.i.i147.i, align 4
  %eq.i.i817 = icmp eq i32 %3073, %offset.i.i148.i
  call void @llvm.assume(i1 %eq.i.i817) #30
  store ptr @_parameterization_Ptri32, ptr %115, align 8
  %3075 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %115)
  %3076 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3067)
  %3077 = sext i32 %3073 to i64
  %3078 = getelementptr ptr, ptr %3067, i64 %3077
  %3079 = getelementptr i8, ptr %3078, i64 120
  %3080 = load ptr, ptr %3079, align 8
  store ptr @i32_typ, ptr %116, align 8
  %3081 = call ptr %3080({ ptr, ptr, ptr, i32 } %3074, ptr nonnull %116)
  %3082 = call { ptr, i160 } %3081({ ptr, ptr, ptr, i32 } %3074, { ptr, ptr, ptr, i32 } %3074, ptr nonnull %115, i32 %3065)
  %.fca.0.extract.i818 = extractvalue { ptr, i160 } %3082, 0
  %3083 = icmp ne ptr %.fca.0.extract.i818, @nil_typ
  %3084 = icmp ne ptr %.fca.0.extract.i818, null
  %.not133.i = and i1 %3083, %3084
  br i1 %.not133.i, label %3085, label %3137

3085:                                             ; preds = %.lr.ph293
  %.fca.1.extract.i824 = extractvalue { ptr, i160 } %3082, 1
  %.sroa.5352.8.extract.trunc.i = trunc i160 %.fca.1.extract.i824 to i64
  %3086 = inttoptr i64 %.sroa.5352.8.extract.trunc.i to ptr
  %.sroa.9355.8.extract.shift.i = lshr i160 %.fca.1.extract.i824, 64
  %.sroa.9355.8.extract.trunc.i = trunc i160 %.sroa.9355.8.extract.shift.i to i64
  %3087 = inttoptr i64 %.sroa.9355.8.extract.trunc.i to ptr
  %hash_coef_ptr.i.i151.i = getelementptr i8, ptr %.fca.0.extract.i818, i64 8
  %tbl_size_ptr.i.i152.i = getelementptr i8, ptr %.fca.0.extract.i818, i64 16
  %offset_tbl_ptr.i.i153.i = getelementptr i8, ptr %.fca.0.extract.i818, i64 40
  %hash_coef.i.i154.i = load i64, ptr %hash_coef_ptr.i.i151.i, align 4
  %tbl_size.i.i155.i = load i64, ptr %tbl_size_ptr.i.i152.i, align 4
  %offset_tbl.i.i156.i = load ptr, ptr %offset_tbl_ptr.i.i153.i, align 8
  %product.i.i.i157.i = mul i64 %hash_coef.i.i154.i, 4015701072841558310
  %shifted.i.i.i158.i = lshr i64 %product.i.i.i157.i, 32
  %xored.i.i.i159.i = xor i64 %shifted.i.i.i158.i, %product.i.i.i157.i
  %hash.i.i.i160.i = and i64 %xored.i.i.i159.i, %tbl_size.i.i155.i
  %offset_ptr.i.i161.i = getelementptr i32, ptr %offset_tbl.i.i156.i, i64 %hash.i.i.i160.i
  %offset.i.i162.i = load i32, ptr %offset_ptr.i.i161.i, align 4
  %3088 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i818, 0
  %3089 = insertvalue { ptr, ptr, ptr, i32 } %3088, ptr %3086, 1
  %3090 = insertvalue { ptr, ptr, ptr, i32 } %3089, ptr %3087, 2
  %3091 = insertvalue { ptr, ptr, ptr, i32 } %3090, i32 %offset.i.i162.i, 3
  %3092 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3093 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3094 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i818)
  %3095 = sext i32 %offset.i.i162.i to i64
  %3096 = getelementptr ptr, ptr %.fca.0.extract.i818, i64 %3095
  %3097 = getelementptr i8, ptr %3096, i64 64
  %3098 = load ptr, ptr %3097, align 8
  %3099 = call ptr %3098({ ptr, ptr, ptr, i32 } %3091, ptr nonnull %2)
  %3100 = call i32 %3099({ ptr, ptr, ptr, i32 } %3091, { ptr, ptr, ptr, i32 } %3091, ptr nonnull %2)
  %3101 = icmp eq i32 %3100, %3046
  %3102 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3103 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3104 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i818)
  %3105 = getelementptr i8, ptr %3096, i64 48
  %3106 = load ptr, ptr %3105, align 8
  %3107 = call ptr %3106({ ptr, ptr, ptr, i32 } %3091, ptr nonnull %2)
  %3108 = call { ptr, i160 } %3107({ ptr, ptr, ptr, i32 } %3091, { ptr, ptr, ptr, i32 } %3091, ptr nonnull %2)
  %3109 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3110 = load ptr, ptr %154, align 8
  %3111 = call i1 %3110({ ptr, i160 } %3108, { ptr, i160 } %3043)
  %3112 = and i1 %3101, %3111
  br i1 %3112, label %3113, label %3137

3113:                                             ; preds = %3085
  %3114 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3115 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3116 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i818)
  %3117 = getelementptr i8, ptr %3096, i64 56
  %3118 = load ptr, ptr %3117, align 8
  %3119 = call ptr %3118({ ptr, ptr, ptr, i32 } %3091, ptr nonnull %2)
  %3120 = call { ptr, i160 } %3119({ ptr, ptr, ptr, i32 } %3091, { ptr, ptr, ptr, i32 } %3091, ptr nonnull %2)
  %3121 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3122 = load ptr, ptr %165, align 8
  %3123 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3122, 0
  %3124 = load ptr, ptr %166, align 8
  %3125 = insertvalue { ptr, ptr, ptr, i32 } %3123, ptr %3124, 1
  %3126 = load ptr, ptr %3037, align 8
  %3127 = insertvalue { ptr, ptr, ptr, i32 } %3125, ptr %3126, 2
  %3128 = load i32, ptr %167, align 4
  %3129 = insertvalue { ptr, ptr, ptr, i32 } %3127, i32 %3128, 3
  %hash_coef_ptr.i.i165.i = getelementptr i8, ptr %3122, i64 8
  %tbl_size_ptr.i.i166.i = getelementptr i8, ptr %3122, i64 16
  %offset_tbl_ptr.i.i167.i = getelementptr i8, ptr %3122, i64 40
  %hash_coef.i.i168.i = load i64, ptr %hash_coef_ptr.i.i165.i, align 4
  %tbl_size.i.i169.i = load i64, ptr %tbl_size_ptr.i.i166.i, align 4
  %offset_tbl.i.i170.i = load ptr, ptr %offset_tbl_ptr.i.i167.i, align 8
  %product.i.i.i171.i = mul i64 %hash_coef.i.i168.i, -5261542750394134544
  %shifted.i.i.i172.i = lshr i64 %product.i.i.i171.i, 32
  %xored.i.i.i173.i = xor i64 %shifted.i.i.i172.i, %product.i.i.i171.i
  %hash.i.i.i174.i = and i64 %xored.i.i.i173.i, %tbl_size.i.i169.i
  %offset_ptr.i.i175.i = getelementptr i32, ptr %offset_tbl.i.i170.i, i64 %hash.i.i.i174.i
  %offset.i.i176.i = load i32, ptr %offset_ptr.i.i175.i, align 4
  %eq.i179.i = icmp eq i32 %3128, %offset.i.i176.i
  call void @llvm.assume(i1 %eq.i179.i) #30
  store ptr @_parameterization_Ptri32, ptr %109, align 8
  store ptr @_parameterization_Nil, ptr %3035, align 8
  %3130 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %109)
  %3131 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3122)
  %3132 = sext i32 %3128 to i64
  %3133 = getelementptr ptr, ptr %3122, i64 %3132
  %3134 = getelementptr i8, ptr %3133, i64 128
  %3135 = load ptr, ptr %3134, align 8
  store ptr @i32_typ, ptr %110, align 8
  store ptr @nil_typ, ptr %3036, align 8
  %3136 = call ptr %3135({ ptr, ptr, ptr, i32 } %3129, ptr nonnull %110)
  call void %3136({ ptr, ptr, ptr, i32 } %3129, { ptr, ptr, ptr, i32 } %3129, ptr nonnull %109, i32 %3065, { ptr, i160 } { ptr @nil_typ, i160 undef })
  br label %HashMap_remove_keyK.exit

3137:                                             ; preds = %3085, %.lr.ph293
  %3138 = add i32 %3046, 2127912214
  %3139 = shl i32 %3046, 12
  %3140 = add i32 %3138, %3139
  %3141 = ashr i32 %3140, 19
  %3142 = xor i32 %3140, %3141
  %3143 = xor i32 %3142, -949894596
  %3144 = add i32 %3143, 374761393
  %3145 = shl i32 %3143, 5
  %3146 = add i32 %3144, %3145
  %3147 = add i32 %3146, -744332180
  %3148 = shl i32 %3146, 9
  %3149 = xor i32 %3147, %3148
  %3150 = add i32 %3149, -42973499
  %3151 = shl i32 %3149, 3
  %3152 = add i32 %3150, %3151
  %3153 = ashr i32 %3152, 16
  %3154 = xor i32 %3152, %3153
  %3155 = xor i32 %3154, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3156 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3157 = load ptr, ptr %178, align 8
  %3158 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3157, 0
  %3159 = load ptr, ptr %179, align 8
  %3160 = insertvalue { ptr, ptr, ptr, i32 } %3158, ptr %3159, 1
  %3161 = load ptr, ptr %3038, align 8
  %3162 = insertvalue { ptr, ptr, ptr, i32 } %3160, ptr %3161, 2
  %3163 = load i32, ptr %180, align 4
  %3164 = insertvalue { ptr, ptr, ptr, i32 } %3162, i32 %3163, 3
  %hash_coef_ptr.i.i10.i2703 = getelementptr i8, ptr %3157, i64 8
  %tbl_size_ptr.i.i11.i2704 = getelementptr i8, ptr %3157, i64 16
  %offset_tbl_ptr.i.i12.i2705 = getelementptr i8, ptr %3157, i64 40
  %hash_coef.i.i13.i2706 = load i64, ptr %hash_coef_ptr.i.i10.i2703, align 4
  %tbl_size.i.i14.i2707 = load i64, ptr %tbl_size_ptr.i.i11.i2704, align 4
  %offset_tbl.i.i15.i2708 = load ptr, ptr %offset_tbl_ptr.i.i12.i2705, align 8
  %product.i.i.i16.i2709 = mul i64 %hash_coef.i.i13.i2706, -5261542750394134544
  %shifted.i.i.i17.i2710 = lshr i64 %product.i.i.i16.i2709, 32
  %xored.i.i.i18.i2711 = xor i64 %shifted.i.i.i17.i2710, %product.i.i.i16.i2709
  %hash.i.i.i19.i2712 = and i64 %xored.i.i.i18.i2711, %tbl_size.i.i14.i2707
  %offset_ptr.i.i20.i2713 = getelementptr i32, ptr %offset_tbl.i.i15.i2708, i64 %hash.i.i.i19.i2712
  %offset.i.i21.i2714 = load i32, ptr %offset_ptr.i.i20.i2713, align 4
  %eq.i.i2715 = icmp eq i32 %3163, %offset.i.i21.i2714
  call void @llvm.assume(i1 %eq.i.i2715) #30
  %3165 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3166 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3157)
  %3167 = sext i32 %3163 to i64
  %3168 = getelementptr ptr, ptr %3157, i64 %3167
  %3169 = getelementptr i8, ptr %3168, i64 64
  %3170 = load ptr, ptr %3169, align 8
  %3171 = call ptr %3170({ ptr, ptr, ptr, i32 } %3164, ptr nonnull %2)
  %3172 = call i32 %3171({ ptr, ptr, ptr, i32 } %3164, { ptr, ptr, ptr, i32 } %3164, ptr nonnull %2)
  %3173 = add i32 %3172, -1
  %3174 = and i32 %3173, %3155
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3175 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3176 = load ptr, ptr %178, align 8
  %3177 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3176, 0
  %3178 = load ptr, ptr %179, align 8
  %3179 = insertvalue { ptr, ptr, ptr, i32 } %3177, ptr %3178, 1
  %3180 = load ptr, ptr %3038, align 8
  %3181 = insertvalue { ptr, ptr, ptr, i32 } %3179, ptr %3180, 2
  %3182 = load i32, ptr %180, align 4
  %3183 = insertvalue { ptr, ptr, ptr, i32 } %3181, i32 %3182, 3
  %hash_coef_ptr.i.i181.i = getelementptr i8, ptr %3176, i64 8
  %tbl_size_ptr.i.i182.i = getelementptr i8, ptr %3176, i64 16
  %offset_tbl_ptr.i.i183.i = getelementptr i8, ptr %3176, i64 40
  %hash_coef.i.i184.i = load i64, ptr %hash_coef_ptr.i.i181.i, align 4
  %tbl_size.i.i185.i = load i64, ptr %tbl_size_ptr.i.i182.i, align 4
  %offset_tbl.i.i186.i = load ptr, ptr %offset_tbl_ptr.i.i183.i, align 8
  %product.i.i.i187.i = mul i64 %hash_coef.i.i184.i, -5261542750394134544
  %shifted.i.i.i188.i = lshr i64 %product.i.i.i187.i, 32
  %xored.i.i.i189.i = xor i64 %shifted.i.i.i188.i, %product.i.i.i187.i
  %hash.i.i.i190.i = and i64 %xored.i.i.i189.i, %tbl_size.i.i185.i
  %offset_ptr.i.i191.i = getelementptr i32, ptr %offset_tbl.i.i186.i, i64 %hash.i.i.i190.i
  %offset.i.i192.i = load i32, ptr %offset_ptr.i.i191.i, align 4
  %eq.i195.i = icmp eq i32 %3182, %offset.i.i192.i
  call void @llvm.assume(i1 %eq.i195.i) #30
  store ptr @_parameterization_Ptri32, ptr %111, align 8
  %3184 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %111)
  %3185 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3176)
  %3186 = sext i32 %3182 to i64
  %3187 = getelementptr ptr, ptr %3176, i64 %3186
  %3188 = getelementptr i8, ptr %3187, i64 120
  %3189 = load ptr, ptr %3188, align 8
  store ptr @i32_typ, ptr %112, align 8
  %3190 = call ptr %3189({ ptr, ptr, ptr, i32 } %3183, ptr nonnull %112)
  %3191 = call { ptr, i160 } %3190({ ptr, ptr, ptr, i32 } %3183, { ptr, ptr, ptr, i32 } %3183, ptr nonnull %111, i32 %3174)
  %.fca.0.extract84.i = extractvalue { ptr, i160 } %3191, 0
  %3192 = icmp ne ptr %.fca.0.extract84.i, @nil_typ
  %3193 = icmp ne ptr %.fca.0.extract84.i, null
  %.not135.i = and i1 %3192, %3193
  br i1 %.not135.i, label %3194, label %HashMap_remove_keyK.exit.thread

3194:                                             ; preds = %3137
  %.fca.1.extract86.i = extractvalue { ptr, i160 } %3191, 1
  %.sroa.5.8.extract.trunc.i819 = trunc i160 %.fca.1.extract86.i to i64
  %3195 = inttoptr i64 %.sroa.5.8.extract.trunc.i819 to ptr
  %.sroa.9.8.extract.shift.i820 = lshr i160 %.fca.1.extract86.i, 64
  %.sroa.9.8.extract.trunc.i821 = trunc i160 %.sroa.9.8.extract.shift.i820 to i64
  %3196 = inttoptr i64 %.sroa.9.8.extract.trunc.i821 to ptr
  %hash_coef_ptr.i.i197.i = getelementptr i8, ptr %.fca.0.extract84.i, i64 8
  %tbl_size_ptr.i.i198.i = getelementptr i8, ptr %.fca.0.extract84.i, i64 16
  %offset_tbl_ptr.i.i199.i = getelementptr i8, ptr %.fca.0.extract84.i, i64 40
  %hash_coef.i.i200.i = load i64, ptr %hash_coef_ptr.i.i197.i, align 4
  %tbl_size.i.i201.i = load i64, ptr %tbl_size_ptr.i.i198.i, align 4
  %offset_tbl.i.i202.i = load ptr, ptr %offset_tbl_ptr.i.i199.i, align 8
  %product.i.i.i203.i = mul i64 %hash_coef.i.i200.i, 4015701072841558310
  %shifted.i.i.i204.i = lshr i64 %product.i.i.i203.i, 32
  %xored.i.i.i205.i = xor i64 %shifted.i.i.i204.i, %product.i.i.i203.i
  %hash.i.i.i206.i = and i64 %xored.i.i.i205.i, %tbl_size.i.i201.i
  %offset_ptr.i.i207.i = getelementptr i32, ptr %offset_tbl.i.i202.i, i64 %hash.i.i.i206.i
  %offset.i.i208.i = load i32, ptr %offset_ptr.i.i207.i, align 4
  %3197 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract84.i, 0
  %3198 = insertvalue { ptr, ptr, ptr, i32 } %3197, ptr %3195, 1
  %3199 = insertvalue { ptr, ptr, ptr, i32 } %3198, ptr %3196, 2
  %3200 = insertvalue { ptr, ptr, ptr, i32 } %3199, i32 %offset.i.i208.i, 3
  %3201 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3202 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3203 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract84.i)
  %3204 = sext i32 %offset.i.i208.i to i64
  %3205 = getelementptr ptr, ptr %.fca.0.extract84.i, i64 %3204
  %3206 = getelementptr i8, ptr %3205, i64 64
  %3207 = load ptr, ptr %3206, align 8
  %3208 = call ptr %3207({ ptr, ptr, ptr, i32 } %3200, ptr nonnull %2)
  %3209 = call i32 %3208({ ptr, ptr, ptr, i32 } %3200, { ptr, ptr, ptr, i32 } %3200, ptr nonnull %2)
  %3210 = icmp eq i32 %3209, %3046
  %3211 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3212 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3213 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract84.i)
  %3214 = getelementptr i8, ptr %3205, i64 48
  %3215 = load ptr, ptr %3214, align 8
  %3216 = call ptr %3215({ ptr, ptr, ptr, i32 } %3200, ptr nonnull %2)
  %3217 = call { ptr, i160 } %3216({ ptr, ptr, ptr, i32 } %3200, { ptr, ptr, ptr, i32 } %3200, ptr nonnull %2)
  %3218 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3219 = load ptr, ptr %154, align 8
  %3220 = call i1 %3219({ ptr, i160 } %3217, { ptr, i160 } %3043)
  %3221 = and i1 %3210, %3220
  br i1 %3221, label %3222, label %HashMap_remove_keyK.exit.thread

3222:                                             ; preds = %3194
  %3223 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3224 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3225 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract84.i)
  %3226 = getelementptr i8, ptr %3205, i64 56
  %3227 = load ptr, ptr %3226, align 8
  %3228 = call ptr %3227({ ptr, ptr, ptr, i32 } %3200, ptr nonnull %2)
  %3229 = call { ptr, i160 } %3228({ ptr, ptr, ptr, i32 } %3200, { ptr, ptr, ptr, i32 } %3200, ptr nonnull %2)
  %3230 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3231 = load ptr, ptr %178, align 8
  %3232 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3231, 0
  %3233 = load ptr, ptr %179, align 8
  %3234 = insertvalue { ptr, ptr, ptr, i32 } %3232, ptr %3233, 1
  %3235 = load ptr, ptr %3038, align 8
  %3236 = insertvalue { ptr, ptr, ptr, i32 } %3234, ptr %3235, 2
  %3237 = load i32, ptr %180, align 4
  %3238 = insertvalue { ptr, ptr, ptr, i32 } %3236, i32 %3237, 3
  %hash_coef_ptr.i.i211.i = getelementptr i8, ptr %3231, i64 8
  %tbl_size_ptr.i.i212.i = getelementptr i8, ptr %3231, i64 16
  %offset_tbl_ptr.i.i213.i = getelementptr i8, ptr %3231, i64 40
  %hash_coef.i.i214.i = load i64, ptr %hash_coef_ptr.i.i211.i, align 4
  %tbl_size.i.i215.i = load i64, ptr %tbl_size_ptr.i.i212.i, align 4
  %offset_tbl.i.i216.i = load ptr, ptr %offset_tbl_ptr.i.i213.i, align 8
  %product.i.i.i217.i = mul i64 %hash_coef.i.i214.i, -5261542750394134544
  %shifted.i.i.i218.i = lshr i64 %product.i.i.i217.i, 32
  %xored.i.i.i219.i = xor i64 %shifted.i.i.i218.i, %product.i.i.i217.i
  %hash.i.i.i220.i = and i64 %xored.i.i.i219.i, %tbl_size.i.i215.i
  %offset_ptr.i.i221.i = getelementptr i32, ptr %offset_tbl.i.i216.i, i64 %hash.i.i.i220.i
  %offset.i.i222.i = load i32, ptr %offset_ptr.i.i221.i, align 4
  %eq.i225.i = icmp eq i32 %3237, %offset.i.i222.i
  call void @llvm.assume(i1 %eq.i225.i) #30
  store ptr @_parameterization_Ptri32, ptr %113, align 8
  store ptr @_parameterization_Nil, ptr %3033, align 8
  %3239 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %113)
  %3240 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3231)
  %3241 = sext i32 %3237 to i64
  %3242 = getelementptr ptr, ptr %3231, i64 %3241
  %3243 = getelementptr i8, ptr %3242, i64 128
  %3244 = load ptr, ptr %3243, align 8
  store ptr @i32_typ, ptr %114, align 8
  store ptr @nil_typ, ptr %3034, align 8
  %3245 = call ptr %3244({ ptr, ptr, ptr, i32 } %3238, ptr nonnull %114)
  call void %3245({ ptr, ptr, ptr, i32 } %3238, { ptr, ptr, ptr, i32 } %3238, ptr nonnull %113, i32 %3174, { ptr, i160 } { ptr @nil_typ, i160 undef })
  br label %HashMap_remove_keyK.exit

HashMap_remove_keyK.exit.thread:                  ; preds = %3194, %3137
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %109)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %111)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %113)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %114)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %115)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %116)
  br label %3255

HashMap_remove_keyK.exit:                         ; preds = %3113, %3222
  %.pn.i = phi { ptr, i160 } [ %3229, %3222 ], [ %3120, %3113 ]
  %.reg2mem34.sroa.0.0.ph.i = extractvalue { ptr, i160 } %.pn.i, 0
  %3246 = load i32, ptr %3039, align 4
  %3247 = add i32 %3246, -1
  %3248 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  store i32 %3247, ptr %3039, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %109)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %110)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %111)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %112)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %113)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %114)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %115)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %116)
  %3249 = icmp ne ptr %.reg2mem34.sroa.0.0.ph.i, @nil_typ
  %3250 = icmp ne ptr %.reg2mem34.sroa.0.0.ph.i, null
  %.not90 = and i1 %3249, %3250
  br i1 %.not90, label %3251, label %3255

3251:                                             ; preds = %HashMap_remove_keyK.exit
  %.reg2mem34.sroa.3.0.ph.i = extractvalue { ptr, i160 } %.pn.i, 1
  %.sroa.247.8.extract.trunc = trunc i160 %.reg2mem34.sroa.3.0.ph.i to i32
  %.sroa.157.8.extract.trunc = trunc i160 %3042 to i32
  %3252 = add i32 %.sroa.157.8.extract.trunc, 1
  %.not = icmp eq i32 %3252, %.sroa.247.8.extract.trunc
  %3253 = select i1 %.not, i1 %.reg2mem113.0290, i1 false
  %3254 = add i32 %.reg2mem115.0291, 1
  br label %3255

3255:                                             ; preds = %HashMap_remove_keyK.exit.thread, %3251, %HashMap_remove_keyK.exit
  %.reg2mem107.0 = phi i1 [ %3253, %3251 ], [ false, %HashMap_remove_keyK.exit ], [ false, %HashMap_remove_keyK.exit.thread ]
  %.reg2mem109.0 = phi i32 [ %3254, %3251 ], [ %.reg2mem115.0291, %HashMap_remove_keyK.exit ], [ %.reg2mem115.0291, %HashMap_remove_keyK.exit.thread ]
  %3256 = add nuw nsw i32 %.reg2mem111.0289, 1
  %3257 = icmp slt i32 %3256, %3027
  br i1 %3257, label %.lr.ph293, label %._crit_edge294

._crit_edge294:                                   ; preds = %3255, %._crit_edge288
  %.reg2mem113.0.lcssa = phi i1 [ true, %._crit_edge288 ], [ %.reg2mem107.0, %3255 ]
  %.reg2mem115.0.lcssa = phi i32 [ 0, %._crit_edge288 ], [ %.reg2mem109.0, %3255 ]
  %3258 = call i64 @clock()
  %.not91 = icmp eq i32 %.reg2mem115.0.lcssa, %3027
  %3259 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3260 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3261 = getelementptr i8, ptr %result.i, i64 88
  %3262 = load i32, ptr %3261, align 4
  %.not92 = icmp eq i32 %3262, 0
  %3263 = select i1 %.not92, i1 %.not91, i1 false
  %3264 = select i1 %3263, i1 %.reg2mem113.0.lcssa, i1 false
  br i1 %3029, label %._crit_edge, label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

._crit_edge:                                      ; preds = %._crit_edge294
  %3265 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %3266 = load ptr, ptr %187, align 8
  %3267 = getelementptr i8, ptr %3266, i64 8
  %3268 = load i160, ptr %3267, align 4
  %.sroa.033.0.insert.ext = and i160 %3268, 4294967295
  %3269 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.033.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0271.i840)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.1.i841)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0.i842)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2.i843)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0123.i844)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2124.i845)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %.sroa.0115.i846)
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %.sroa.2116.i847)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %108)
  %3270 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3271 = load ptr, ptr %153, align 8
  %3272 = call i32 %3271({ ptr, i160 } %3269)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3273 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3274 = load ptr, ptr %165, align 8
  %3275 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3274, 0
  %3276 = load ptr, ptr %166, align 8
  %3277 = insertvalue { ptr, ptr, ptr, i32 } %3275, ptr %3276, 1
  %3278 = getelementptr i8, ptr %result.i, i64 40
  %3279 = load ptr, ptr %3278, align 8
  %3280 = insertvalue { ptr, ptr, ptr, i32 } %3277, ptr %3279, 2
  %3281 = load i32, ptr %167, align 4
  %3282 = insertvalue { ptr, ptr, ptr, i32 } %3280, i32 %3281, 3
  %hash_coef_ptr.i.i10.i2748 = getelementptr i8, ptr %3274, i64 8
  %tbl_size_ptr.i.i11.i2749 = getelementptr i8, ptr %3274, i64 16
  %offset_tbl_ptr.i.i12.i2750 = getelementptr i8, ptr %3274, i64 40
  %hash_coef.i.i13.i2751 = load i64, ptr %hash_coef_ptr.i.i10.i2748, align 4
  %tbl_size.i.i14.i2752 = load i64, ptr %tbl_size_ptr.i.i11.i2749, align 4
  %offset_tbl.i.i15.i2753 = load ptr, ptr %offset_tbl_ptr.i.i12.i2750, align 8
  %product.i.i.i16.i2754 = mul i64 %hash_coef.i.i13.i2751, -5261542750394134544
  %shifted.i.i.i17.i2755 = lshr i64 %product.i.i.i16.i2754, 32
  %xored.i.i.i18.i2756 = xor i64 %shifted.i.i.i17.i2755, %product.i.i.i16.i2754
  %hash.i.i.i19.i2757 = and i64 %xored.i.i.i18.i2756, %tbl_size.i.i14.i2752
  %offset_ptr.i.i20.i2758 = getelementptr i32, ptr %offset_tbl.i.i15.i2753, i64 %hash.i.i.i19.i2757
  %offset.i.i21.i2759 = load i32, ptr %offset_ptr.i.i20.i2758, align 4
  %eq.i.i2760 = icmp eq i32 %3281, %offset.i.i21.i2759
  call void @llvm.assume(i1 %eq.i.i2760) #30
  %3283 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3284 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3274)
  %3285 = sext i32 %3281 to i64
  %3286 = getelementptr ptr, ptr %3274, i64 %3285
  %3287 = getelementptr i8, ptr %3286, i64 64
  %3288 = load ptr, ptr %3287, align 8
  %3289 = call ptr %3288({ ptr, ptr, ptr, i32 } %3282, ptr nonnull %2)
  %3290 = call i32 %3289({ ptr, ptr, ptr, i32 } %3282, { ptr, ptr, ptr, i32 } %3282, ptr nonnull %2)
  %3291 = add i32 %3290, -1
  %3292 = and i32 %3291, %3272
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3293 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3294 = load ptr, ptr %165, align 8
  %3295 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3294, 0
  %3296 = load ptr, ptr %166, align 8
  %3297 = insertvalue { ptr, ptr, ptr, i32 } %3295, ptr %3296, 1
  %3298 = load ptr, ptr %3278, align 8
  %3299 = insertvalue { ptr, ptr, ptr, i32 } %3297, ptr %3298, 2
  %3300 = load i32, ptr %167, align 4
  %3301 = insertvalue { ptr, ptr, ptr, i32 } %3299, i32 %3300, 3
  %hash_coef_ptr.i.i130.i864 = getelementptr i8, ptr %3294, i64 8
  %tbl_size_ptr.i.i131.i865 = getelementptr i8, ptr %3294, i64 16
  %offset_tbl_ptr.i.i132.i866 = getelementptr i8, ptr %3294, i64 40
  %hash_coef.i.i133.i867 = load i64, ptr %hash_coef_ptr.i.i130.i864, align 4
  %tbl_size.i.i134.i868 = load i64, ptr %tbl_size_ptr.i.i131.i865, align 4
  %offset_tbl.i.i135.i869 = load ptr, ptr %offset_tbl_ptr.i.i132.i866, align 8
  %product.i.i.i136.i870 = mul i64 %hash_coef.i.i133.i867, -5261542750394134544
  %shifted.i.i.i137.i871 = lshr i64 %product.i.i.i136.i870, 32
  %xored.i.i.i138.i872 = xor i64 %shifted.i.i.i137.i871, %product.i.i.i136.i870
  %hash.i.i.i139.i873 = and i64 %xored.i.i.i138.i872, %tbl_size.i.i134.i868
  %offset_ptr.i.i140.i874 = getelementptr i32, ptr %offset_tbl.i.i135.i869, i64 %hash.i.i.i139.i873
  %offset.i.i141.i875 = load i32, ptr %offset_ptr.i.i140.i874, align 4
  %eq.i.i876 = icmp eq i32 %3300, %offset.i.i141.i875
  call void @llvm.assume(i1 %eq.i.i876) #30
  store ptr @_parameterization_Ptri32, ptr %107, align 8
  %3302 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %107)
  %3303 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3294)
  %3304 = sext i32 %3300 to i64
  %3305 = getelementptr ptr, ptr %3294, i64 %3304
  %3306 = getelementptr i8, ptr %3305, i64 120
  %3307 = load ptr, ptr %3306, align 8
  store ptr @i32_typ, ptr %108, align 8
  %3308 = call ptr %3307({ ptr, ptr, ptr, i32 } %3301, ptr nonnull %108)
  %3309 = call { ptr, i160 } %3308({ ptr, ptr, ptr, i32 } %3301, { ptr, ptr, ptr, i32 } %3301, ptr nonnull %107, i32 %3292)
  %.fca.0.extract.i877 = extractvalue { ptr, i160 } %3309, 0
  %3310 = icmp ne ptr %.fca.0.extract.i877, @nil_typ
  %3311 = icmp ne ptr %.fca.0.extract.i877, null
  %.not126.i878 = and i1 %3310, %3311
  br i1 %.not126.i878, label %3312, label %.critedge.i879

3312:                                             ; preds = %._crit_edge
  %.fca.1.extract.i925 = extractvalue { ptr, i160 } %3309, 1
  %.sroa.5.8.extract.trunc.i926 = trunc i160 %.fca.1.extract.i925 to i64
  %3313 = inttoptr i64 %.sroa.5.8.extract.trunc.i926 to ptr
  %.sroa.9.8.extract.shift.i927 = lshr i160 %.fca.1.extract.i925, 64
  %.sroa.9.8.extract.trunc.i928 = trunc i160 %.sroa.9.8.extract.shift.i927 to i64
  %3314 = inttoptr i64 %.sroa.9.8.extract.trunc.i928 to ptr
  %hash_coef_ptr.i.i144.i929 = getelementptr i8, ptr %.fca.0.extract.i877, i64 8
  %tbl_size_ptr.i.i145.i930 = getelementptr i8, ptr %.fca.0.extract.i877, i64 16
  %offset_tbl_ptr.i.i146.i931 = getelementptr i8, ptr %.fca.0.extract.i877, i64 40
  %hash_coef.i.i147.i932 = load i64, ptr %hash_coef_ptr.i.i144.i929, align 4
  %tbl_size.i.i148.i933 = load i64, ptr %tbl_size_ptr.i.i145.i930, align 4
  %offset_tbl.i.i149.i934 = load ptr, ptr %offset_tbl_ptr.i.i146.i931, align 8
  %product.i.i.i150.i935 = mul i64 %hash_coef.i.i147.i932, 4015701072841558310
  %shifted.i.i.i151.i936 = lshr i64 %product.i.i.i150.i935, 32
  %xored.i.i.i152.i937 = xor i64 %shifted.i.i.i151.i936, %product.i.i.i150.i935
  %hash.i.i.i153.i938 = and i64 %xored.i.i.i152.i937, %tbl_size.i.i148.i933
  %offset_ptr.i.i154.i939 = getelementptr i32, ptr %offset_tbl.i.i149.i934, i64 %hash.i.i.i153.i938
  %offset.i.i155.i940 = load i32, ptr %offset_ptr.i.i154.i939, align 4
  %3315 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract.i877, 0
  %3316 = insertvalue { ptr, ptr, ptr, i32 } %3315, ptr %3313, 1
  %3317 = insertvalue { ptr, ptr, ptr, i32 } %3316, ptr %3314, 2
  %3318 = insertvalue { ptr, ptr, ptr, i32 } %3317, i32 %offset.i.i155.i940, 3
  %3319 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3320 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3321 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i877)
  %3322 = sext i32 %offset.i.i155.i940 to i64
  %3323 = getelementptr ptr, ptr %.fca.0.extract.i877, i64 %3322
  %3324 = getelementptr i8, ptr %3323, i64 64
  %3325 = load ptr, ptr %3324, align 8
  %3326 = call ptr %3325({ ptr, ptr, ptr, i32 } %3318, ptr nonnull %2)
  %3327 = call i32 %3326({ ptr, ptr, ptr, i32 } %3318, { ptr, ptr, ptr, i32 } %3318, ptr nonnull %2)
  %3328 = icmp eq i32 %3327, %3272
  %3329 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3330 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3331 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract.i877)
  %3332 = getelementptr i8, ptr %3323, i64 48
  %3333 = load ptr, ptr %3332, align 8
  %3334 = call ptr %3333({ ptr, ptr, ptr, i32 } %3318, ptr nonnull %2)
  %3335 = call { ptr, i160 } %3334({ ptr, ptr, ptr, i32 } %3318, { ptr, ptr, ptr, i32 } %3318, ptr nonnull %2)
  %3336 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3337 = load ptr, ptr %154, align 8
  %3338 = call i1 %3337({ ptr, i160 } %3335, { ptr, i160 } %3269)
  %3339 = and i1 %3328, %3338
  br i1 %3339, label %.thread.i, label %.critedge.i879

.critedge.i879:                                   ; preds = %3312, %._crit_edge
  %3340 = add i32 %3272, 2127912214
  %3341 = shl i32 %3272, 12
  %3342 = add i32 %3340, %3341
  %3343 = ashr i32 %3342, 19
  %3344 = xor i32 %3342, %3343
  %3345 = xor i32 %3344, -949894596
  %3346 = add i32 %3345, 374761393
  %3347 = shl i32 %3345, 5
  %3348 = add i32 %3346, %3347
  %3349 = add i32 %3348, -744332180
  %3350 = shl i32 %3348, 9
  %3351 = xor i32 %3349, %3350
  %3352 = add i32 %3351, -42973499
  %3353 = shl i32 %3351, 3
  %3354 = add i32 %3352, %3353
  %3355 = ashr i32 %3354, 16
  %3356 = xor i32 %3354, %3355
  %3357 = xor i32 %3356, -1252372727
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %3358 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3359 = load ptr, ptr %178, align 8
  %3360 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3359, 0
  %3361 = load ptr, ptr %179, align 8
  %3362 = insertvalue { ptr, ptr, ptr, i32 } %3360, ptr %3361, 1
  %3363 = getelementptr i8, ptr %result.i, i64 72
  %3364 = load ptr, ptr %3363, align 8
  %3365 = insertvalue { ptr, ptr, ptr, i32 } %3362, ptr %3364, 2
  %3366 = load i32, ptr %180, align 4
  %3367 = insertvalue { ptr, ptr, ptr, i32 } %3365, i32 %3366, 3
  %hash_coef_ptr.i.i10.i2779 = getelementptr i8, ptr %3359, i64 8
  %tbl_size_ptr.i.i11.i2780 = getelementptr i8, ptr %3359, i64 16
  %offset_tbl_ptr.i.i12.i2781 = getelementptr i8, ptr %3359, i64 40
  %hash_coef.i.i13.i2782 = load i64, ptr %hash_coef_ptr.i.i10.i2779, align 4
  %tbl_size.i.i14.i2783 = load i64, ptr %tbl_size_ptr.i.i11.i2780, align 4
  %offset_tbl.i.i15.i2784 = load ptr, ptr %offset_tbl_ptr.i.i12.i2781, align 8
  %product.i.i.i16.i2785 = mul i64 %hash_coef.i.i13.i2782, -5261542750394134544
  %shifted.i.i.i17.i2786 = lshr i64 %product.i.i.i16.i2785, 32
  %xored.i.i.i18.i2787 = xor i64 %shifted.i.i.i17.i2786, %product.i.i.i16.i2785
  %hash.i.i.i19.i2788 = and i64 %xored.i.i.i18.i2787, %tbl_size.i.i14.i2783
  %offset_ptr.i.i20.i2789 = getelementptr i32, ptr %offset_tbl.i.i15.i2784, i64 %hash.i.i.i19.i2788
  %offset.i.i21.i2790 = load i32, ptr %offset_ptr.i.i20.i2789, align 4
  %eq.i.i2791 = icmp eq i32 %3366, %offset.i.i21.i2790
  call void @llvm.assume(i1 %eq.i.i2791) #30
  %3368 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3369 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3359)
  %3370 = sext i32 %3366 to i64
  %3371 = getelementptr ptr, ptr %3359, i64 %3370
  %3372 = getelementptr i8, ptr %3371, i64 64
  %3373 = load ptr, ptr %3372, align 8
  %3374 = call ptr %3373({ ptr, ptr, ptr, i32 } %3367, ptr nonnull %2)
  %3375 = call i32 %3374({ ptr, ptr, ptr, i32 } %3367, { ptr, ptr, ptr, i32 } %3367, ptr nonnull %2)
  %3376 = add i32 %3375, -1
  %3377 = and i32 %3376, %3357
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3378 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3379 = load ptr, ptr %178, align 8
  %3380 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3379, 0
  %3381 = load ptr, ptr %179, align 8
  %3382 = insertvalue { ptr, ptr, ptr, i32 } %3380, ptr %3381, 1
  %3383 = load ptr, ptr %3363, align 8
  %3384 = insertvalue { ptr, ptr, ptr, i32 } %3382, ptr %3383, 2
  %3385 = load i32, ptr %180, align 4
  %3386 = insertvalue { ptr, ptr, ptr, i32 } %3384, i32 %3385, 3
  %hash_coef_ptr.i.i158.i884 = getelementptr i8, ptr %3379, i64 8
  %tbl_size_ptr.i.i159.i885 = getelementptr i8, ptr %3379, i64 16
  %offset_tbl_ptr.i.i160.i886 = getelementptr i8, ptr %3379, i64 40
  %hash_coef.i.i161.i887 = load i64, ptr %hash_coef_ptr.i.i158.i884, align 4
  %tbl_size.i.i162.i888 = load i64, ptr %tbl_size_ptr.i.i159.i885, align 4
  %offset_tbl.i.i163.i889 = load ptr, ptr %offset_tbl_ptr.i.i160.i886, align 8
  %product.i.i.i164.i890 = mul i64 %hash_coef.i.i161.i887, -5261542750394134544
  %shifted.i.i.i165.i891 = lshr i64 %product.i.i.i164.i890, 32
  %xored.i.i.i166.i892 = xor i64 %shifted.i.i.i165.i891, %product.i.i.i164.i890
  %hash.i.i.i167.i893 = and i64 %xored.i.i.i166.i892, %tbl_size.i.i162.i888
  %offset_ptr.i.i168.i894 = getelementptr i32, ptr %offset_tbl.i.i163.i889, i64 %hash.i.i.i167.i893
  %offset.i.i169.i895 = load i32, ptr %offset_ptr.i.i168.i894, align 4
  %eq.i172.i896 = icmp eq i32 %3385, %offset.i.i169.i895
  call void @llvm.assume(i1 %eq.i172.i896) #30
  store ptr @_parameterization_Ptri32, ptr %105, align 8
  %3387 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %105)
  %3388 = call ptr @llvm.invariant.start.p0(i64 600, ptr %3379)
  %3389 = sext i32 %3385 to i64
  %3390 = getelementptr ptr, ptr %3379, i64 %3389
  %3391 = getelementptr i8, ptr %3390, i64 120
  %3392 = load ptr, ptr %3391, align 8
  store ptr @i32_typ, ptr %106, align 8
  %3393 = call ptr %3392({ ptr, ptr, ptr, i32 } %3386, ptr nonnull %106)
  %3394 = call { ptr, i160 } %3393({ ptr, ptr, ptr, i32 } %3386, { ptr, ptr, ptr, i32 } %3386, ptr nonnull %105, i32 %3377)
  %.fca.0.extract57.i897 = extractvalue { ptr, i160 } %3394, 0
  %3395 = icmp ne ptr %.fca.0.extract57.i897, @nil_typ
  %3396 = icmp ne ptr %.fca.0.extract57.i897, null
  %.not128.i898 = and i1 %3395, %3396
  br i1 %.not128.i898, label %3397, label %HashMap_get_keyK.exit942

3397:                                             ; preds = %.critedge.i879
  %.fca.1.extract59.i899 = extractvalue { ptr, i160 } %3394, 1
  %.sroa.6.8.extract.trunc.i900 = trunc i160 %.fca.1.extract59.i899 to i64
  %3398 = inttoptr i64 %.sroa.6.8.extract.trunc.i900 to ptr
  %.sroa.11.8.extract.shift.i901 = lshr i160 %.fca.1.extract59.i899, 64
  %.sroa.11.8.extract.trunc.i902 = trunc i160 %.sroa.11.8.extract.shift.i901 to i64
  %3399 = inttoptr i64 %.sroa.11.8.extract.trunc.i902 to ptr
  %hash_coef_ptr.i.i174.i903 = getelementptr i8, ptr %.fca.0.extract57.i897, i64 8
  %tbl_size_ptr.i.i175.i904 = getelementptr i8, ptr %.fca.0.extract57.i897, i64 16
  %offset_tbl_ptr.i.i176.i905 = getelementptr i8, ptr %.fca.0.extract57.i897, i64 40
  %hash_coef.i.i177.i906 = load i64, ptr %hash_coef_ptr.i.i174.i903, align 4
  %tbl_size.i.i178.i907 = load i64, ptr %tbl_size_ptr.i.i175.i904, align 4
  %offset_tbl.i.i179.i908 = load ptr, ptr %offset_tbl_ptr.i.i176.i905, align 8
  %product.i.i.i180.i909 = mul i64 %hash_coef.i.i177.i906, 4015701072841558310
  %shifted.i.i.i181.i910 = lshr i64 %product.i.i.i180.i909, 32
  %xored.i.i.i182.i911 = xor i64 %shifted.i.i.i181.i910, %product.i.i.i180.i909
  %hash.i.i.i183.i912 = and i64 %xored.i.i.i182.i911, %tbl_size.i.i178.i907
  %offset_ptr.i.i184.i913 = getelementptr i32, ptr %offset_tbl.i.i179.i908, i64 %hash.i.i.i183.i912
  %offset.i.i185.i914 = load i32, ptr %offset_ptr.i.i184.i913, align 4
  %3400 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract57.i897, 0
  %3401 = insertvalue { ptr, ptr, ptr, i32 } %3400, ptr %3398, 1
  %3402 = insertvalue { ptr, ptr, ptr, i32 } %3401, ptr %3399, 2
  %3403 = insertvalue { ptr, ptr, ptr, i32 } %3402, i32 %offset.i.i185.i914, 3
  %3404 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3405 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3406 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i897)
  %3407 = sext i32 %offset.i.i185.i914 to i64
  %3408 = getelementptr ptr, ptr %.fca.0.extract57.i897, i64 %3407
  %3409 = getelementptr i8, ptr %3408, i64 64
  %3410 = load ptr, ptr %3409, align 8
  %3411 = call ptr %3410({ ptr, ptr, ptr, i32 } %3403, ptr nonnull %2)
  %3412 = call i32 %3411({ ptr, ptr, ptr, i32 } %3403, { ptr, ptr, ptr, i32 } %3403, ptr nonnull %2)
  %3413 = icmp eq i32 %3412, %3272
  %3414 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3415 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3416 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract57.i897)
  %3417 = getelementptr i8, ptr %3408, i64 48
  %3418 = load ptr, ptr %3417, align 8
  %3419 = call ptr %3418({ ptr, ptr, ptr, i32 } %3403, ptr nonnull %2)
  %3420 = call { ptr, i160 } %3419({ ptr, ptr, ptr, i32 } %3403, { ptr, ptr, ptr, i32 } %3403, ptr nonnull %2)
  %3421 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3422 = load ptr, ptr %154, align 8
  %3423 = call i1 %3422({ ptr, i160 } %3420, { ptr, i160 } %3269)
  %3424 = and i1 %3413, %3423
  br i1 %3424, label %.thread.i, label %HashMap_get_keyK.exit942

.thread.i:                                        ; preds = %3397, %3312
  %.pre-phi313.i916 = phi i64 [ %3322, %3312 ], [ %3407, %3397 ]
  %.pre-phi312.i917 = phi { ptr, ptr, ptr, i32 } [ %3318, %3312 ], [ %3403, %3397 ]
  %.reg2mem65.0.sroa.phi290.sroa.speculated.i918 = phi ptr [ %.fca.0.extract.i877, %3312 ], [ %.fca.0.extract57.i897, %3397 ]
  %.reg2mem59.0.sroa.phi120289.i919 = phi ptr [ %.sroa.1.i841, %3312 ], [ %.sroa.2124.i845, %3397 ]
  %.reg2mem59.0.sroa.phi117288.i920 = phi ptr [ %.sroa.0271.i840, %3312 ], [ %.sroa.0123.i844, %3397 ]
  %.reg2mem57.0.sroa.phi94287.i921 = phi ptr [ %.sroa.2.i843, %3312 ], [ %.sroa.2116.i847, %3397 ]
  %.reg2mem57.0.sroa.phi91286.i922 = phi ptr [ %.sroa.0.i842, %3312 ], [ %.sroa.0115.i846, %3397 ]
  %3425 = call ptr @llvm.invariant.start.p0(i64 624, ptr nonnull @HashMap)
  %3426 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3427 = call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.reg2mem65.0.sroa.phi290.sroa.speculated.i918)
  %3428 = getelementptr ptr, ptr %.reg2mem65.0.sroa.phi290.sroa.speculated.i918, i64 %.pre-phi313.i916
  %3429 = getelementptr i8, ptr %3428, i64 56
  %3430 = load ptr, ptr %3429, align 8
  %3431 = call ptr %3430({ ptr, ptr, ptr, i32 } %.pre-phi312.i917, ptr nonnull %2)
  %3432 = call { ptr, i160 } %3431({ ptr, ptr, ptr, i32 } %.pre-phi312.i917, { ptr, ptr, ptr, i32 } %.pre-phi312.i917, ptr nonnull %2)
  %.fca.0.extract97.i923 = extractvalue { ptr, i160 } %3432, 0
  store ptr %.fca.0.extract97.i923, ptr %.reg2mem59.0.sroa.phi117288.i920, align 8
  %.fca.1.extract99.i924 = extractvalue { ptr, i160 } %3432, 1
  store i160 %.fca.1.extract99.i924, ptr %.reg2mem59.0.sroa.phi120289.i919, align 8
  store ptr %.fca.0.extract97.i923, ptr %.reg2mem57.0.sroa.phi91286.i922, align 8
  store i160 %.fca.1.extract99.i924, ptr %.reg2mem57.0.sroa.phi94287.i921, align 8
  br label %HashMap_get_keyK.exit942

HashMap_get_keyK.exit942:                         ; preds = %.critedge.i879, %3397, %.thread.i
  %.reg2mem51.sroa.0.0.i = phi ptr [ %.fca.0.extract97.i923, %.thread.i ], [ @nil_typ, %3397 ], [ @nil_typ, %.critedge.i879 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0271.i840)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.1.i841)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0.i842)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2.i843)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %105)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %106)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0123.i844)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2124.i845)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %.sroa.0115.i846)
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %.sroa.2116.i847)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %107)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %108)
  %3433 = icmp eq ptr %.reg2mem51.sroa.0.0.i, @nil_typ
  %3434 = icmp eq ptr %.reg2mem51.sroa.0.0.i, null
  %.not95.not = or i1 %3433, %3434
  %3435 = select i1 %.not95.not, i1 %3264, i1 false
  br label %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit

IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit: ; preds = %HashMap_get_keyK.exit942, %._crit_edge294
  %.reg2mem93.0 = phi i1 [ %3435, %HashMap_get_keyK.exit942 ], [ %3264, %._crit_edge294 ]
  %result.i157 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nonnull @current_ptr) #29
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i157, align 16
  %result.i158 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3436 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i158, 1
  %3437 = insertvalue { ptr, ptr, ptr, i32 } %3436, ptr undef, 2
  %3438 = insertvalue { ptr, ptr, ptr, i32 } %3437, i32 9, 3
  store ptr %result.i157, ptr %result.i158, align 8
  %3439 = getelementptr i8, ptr %result.i158, i64 8
  store i32 13, ptr %3439, align 4
  %3440 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3441 = getelementptr i8, ptr %result.i158, i64 12
  store i32 14, ptr %3441, align 4
  %3442 = sub i64 %3258, %3028
  call void @print_benchmark_result({ ptr, ptr, ptr, i32 } %3438, i32 %3027, i64 %3442)
  %result.i159 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nonnull @current_ptr) #29
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i159, align 32
  %result.i160 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3443 = getelementptr inbounds i8, ptr %143, i64 8
  %3444 = getelementptr inbounds i8, ptr %143, i64 24
  store ptr @String, ptr %143, align 8
  store ptr %result.i160, ptr %3443, align 8
  store i32 9, ptr %3444, align 8
  %3445 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %143)
  store ptr %result.i159, ptr %result.i160, align 8
  %3446 = getelementptr i8, ptr %result.i160, i64 8
  store i32 18, ptr %3446, align 4
  %3447 = getelementptr i8, ptr %result.i160, i64 12
  store i32 19, ptr %3447, align 4
  %3448 = load i160, ptr %3443, align 8
  %3449 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i = trunc i160 %3448 to i64
  %3450 = inttoptr i64 %.sroa.3.8.extract.trunc.i to ptr
  %3451 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3452 = getelementptr i8, ptr %3450, i64 8
  %3453 = load i32, ptr %3452, align 4
  %3454 = add i32 %3453, 1
  %3455 = sext i32 %3454 to i64
  %result.i.i1673 = call noalias ptr @bump_malloc_inner(i64 noundef %3455, ptr nonnull @current_ptr) #29
  %3456 = load i32, ptr %3452, align 4
  %3457 = icmp sgt i32 %3456, 0
  br i1 %3457, label %.lr.ph.i1674, label %String_c_string_.exit

.lr.ph.i1674:                                     ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %3458 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3459 = load ptr, ptr %3450, align 8
  %3460 = zext nneg i32 %3456 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1673, ptr align 1 %3459, i64 %3460, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %.lr.ph.i1674, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit
  %3461 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3462 = sext i32 %3456 to i64
  %3463 = getelementptr i8, ptr %result.i.i1673, i64 %3462
  store i8 0, ptr %3463, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1673)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i161 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nonnull @current_ptr) #29
  %. = select i1 %.reg2mem93.0, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %.420 = select i1 %.reg2mem93.0, ptr %144, ptr %145
  store <4 x i8> %., ptr %result.i161, align 4
  %result.i162 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %.420.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem93.0, ptr %144, ptr %145
  %.420.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.420.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
  %.420.sroa.sel619.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.reg2mem93.0, ptr %144, ptr %145
  %.420.sroa.sel619.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr inbounds i8, ptr %.420.sroa.sel619.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 24
  store ptr @String, ptr %.420, align 8
  store ptr %result.i162, ptr %.420.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  store i32 9, ptr %.420.sroa.sel619.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %3464 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %.420)
  store ptr %result.i161, ptr %result.i162, align 8
  %3465 = getelementptr i8, ptr %result.i162, i64 8
  store i32 4, ptr %3465, align 4
  %3466 = getelementptr i8, ptr %result.i162, i64 12
  store i32 5, ptr %3466, align 4
  %3467 = load i160, ptr %.420.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
  %3468 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i558 = trunc i160 %3467 to i64
  %3469 = inttoptr i64 %.sroa.3.8.extract.trunc.i558 to ptr
  %3470 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3471 = getelementptr i8, ptr %3469, i64 8
  %3472 = load i32, ptr %3471, align 4
  %3473 = add i32 %3472, 1
  %3474 = sext i32 %3473 to i64
  %result.i.i1690 = call noalias ptr @bump_malloc_inner(i64 noundef %3474, ptr nonnull @current_ptr) #29
  %3475 = load i32, ptr %3471, align 4
  %3476 = icmp sgt i32 %3475, 0
  br i1 %3476, label %.lr.ph.i1691, label %String_c_string_.exit1695

.lr.ph.i1691:                                     ; preds = %String_c_string_.exit
  %3477 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3478 = load ptr, ptr %3469, align 8
  %3479 = zext nneg i32 %3475 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1690, ptr align 1 %3478, i64 %3479, i1 false)
  br label %String_c_string_.exit1695

String_c_string_.exit1695:                        ; preds = %.lr.ph.i1691, %String_c_string_.exit
  %3480 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3481 = sext i32 %3475 to i64
  %3482 = getelementptr i8, ptr %result.i.i1690, i64 %3481
  store i8 0, ptr %3482, align 1
  %puts.i574 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1690)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i201 = call noalias dereferenceable_or_null(21) ptr @bump_malloc_inner(i64 noundef 21, ptr nonnull @current_ptr) #29
  store <20 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %result.i201, align 32
  %result.i202 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3483 = getelementptr inbounds i8, ptr %146, i64 8
  %3484 = getelementptr inbounds i8, ptr %146, i64 24
  store ptr @String, ptr %146, align 8
  store ptr %result.i202, ptr %3483, align 8
  store i32 9, ptr %3484, align 8
  %3485 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %146)
  store ptr %result.i201, ptr %result.i202, align 8
  %3486 = getelementptr i8, ptr %result.i202, i64 8
  store i32 20, ptr %3486, align 4
  %3487 = getelementptr i8, ptr %result.i202, i64 12
  store i32 21, ptr %3487, align 4
  %3488 = load i160, ptr %3483, align 8
  %3489 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i578 = trunc i160 %3488 to i64
  %3490 = inttoptr i64 %.sroa.3.8.extract.trunc.i578 to ptr
  %3491 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3492 = getelementptr i8, ptr %3490, i64 8
  %3493 = load i32, ptr %3492, align 4
  %3494 = add i32 %3493, 1
  %3495 = sext i32 %3494 to i64
  %result.i.i1710 = call noalias ptr @bump_malloc_inner(i64 noundef %3495, ptr nonnull @current_ptr) #29
  %3496 = load i32, ptr %3492, align 4
  %3497 = icmp sgt i32 %3496, 0
  br i1 %3497, label %.lr.ph.i1711, label %String_c_string_.exit1715

.lr.ph.i1711:                                     ; preds = %String_c_string_.exit1695
  %3498 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3499 = load ptr, ptr %3490, align 8
  %3500 = zext nneg i32 %3496 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1710, ptr align 1 %3499, i64 %3500, i1 false)
  br label %String_c_string_.exit1715

String_c_string_.exit1715:                        ; preds = %.lr.ph.i1711, %String_c_string_.exit1695
  %3501 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3502 = sext i32 %3496 to i64
  %3503 = getelementptr i8, ptr %result.i.i1710, i64 %3502
  store i8 0, ptr %3503, align 1
  %puts.i594 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1710)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %3504 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %.reg2mem115.0.lcssa)
  %result.i239 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nonnull @current_ptr) #29
  store <1 x i8> <i8 41>, ptr %result.i239, align 1
  %result.i240 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3505 = getelementptr inbounds i8, ptr %147, i64 8
  %3506 = getelementptr inbounds i8, ptr %147, i64 24
  store ptr @String, ptr %147, align 8
  store ptr %result.i240, ptr %3505, align 8
  store i32 9, ptr %3506, align 8
  %3507 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %147)
  store ptr %result.i239, ptr %result.i240, align 8
  %3508 = getelementptr i8, ptr %result.i240, i64 8
  store i32 1, ptr %3508, align 4
  %3509 = getelementptr i8, ptr %result.i240, i64 12
  store i32 2, ptr %3509, align 4
  %3510 = load i160, ptr %3505, align 8
  %3511 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %.sroa.3.8.extract.trunc.i599 = trunc i160 %3510 to i64
  %3512 = inttoptr i64 %.sroa.3.8.extract.trunc.i599 to ptr
  %3513 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %3514 = getelementptr i8, ptr %3512, i64 8
  %3515 = load i32, ptr %3514, align 4
  %3516 = add i32 %3515, 1
  %3517 = sext i32 %3516 to i64
  %result.i.i1730 = call noalias ptr @bump_malloc_inner(i64 noundef %3517, ptr nonnull @current_ptr) #29
  %3518 = load i32, ptr %3514, align 4
  %3519 = icmp sgt i32 %3518, 0
  br i1 %3519, label %.lr.ph.i1731, label %String_c_string_.exit1735

.lr.ph.i1731:                                     ; preds = %String_c_string_.exit1715
  %3520 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3521 = load ptr, ptr %3512, align 8
  %3522 = zext nneg i32 %3518 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i1730, ptr align 1 %3521, i64 %3522, i1 false)
  br label %String_c_string_.exit1735

String_c_string_.exit1735:                        ; preds = %.lr.ph.i1731, %String_c_string_.exit1715
  %3523 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %3524 = sext i32 %3518 to i64
  %3525 = getelementptr i8, ptr %result.i.i1730, i64 %3524
  store i8 0, ptr %3525, align 1
  %puts.i615 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1730)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define noundef i32 @main() local_unnamed_addr {
IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit22:
  %0 = alloca { ptr, ptr, ptr, i32 }, align 8
  %1 = alloca { ptr, ptr, ptr, i32 }, align 8
  tail call void @setup_landing_pad()
  %result.i = tail call noalias dereferenceable_or_null(60) ptr @bump_malloc_inner(i64 noundef 60, ptr nonnull @current_ptr) #29
  %2 = load <59 x i8>, ptr @cxrss__HashMap_Benchmarks_Cuckoo_Hashing__Rev__Cleaned_, align 64
  store <59 x i8> %2, ptr %result.i, align 64
  %result.i2 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  %4 = getelementptr inbounds i8, ptr %0, i64 24
  store ptr @String, ptr %0, align 8
  store ptr %result.i2, ptr %3, align 8
  store i32 9, ptr %4, align 8
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %0)
  store ptr %result.i, ptr %result.i2, align 8
  %6 = getelementptr i8, ptr %result.i2, i64 8
  store i32 59, ptr %6, align 4
  %7 = getelementptr i8, ptr %result.i2, i64 12
  store i32 60, ptr %7, align 4
  %8 = load i160, ptr %3, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %.sroa.3.8.extract.trunc.i = trunc i160 %8 to i64
  %10 = inttoptr i64 %.sroa.3.8.extract.trunc.i to ptr
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load i32, ptr %11, align 4
  %13 = add i32 %12, 1
  %14 = sext i32 %13 to i64
  %result.i.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %14, ptr nonnull @current_ptr) #29
  %15 = load i32, ptr %11, align 4
  %16 = icmp sgt i32 %15, 0
  br i1 %16, label %.lr.ph.i, label %String_c_string_.exit

.lr.ph.i:                                         ; preds = %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit22
  %17 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %18 = load ptr, ptr %10, align 8
  %19 = zext nneg i32 %15 to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i, ptr align 1 %18, i64 %19, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %.lr.ph.i, %IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil.exit22
  %20 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %21 = sext i32 %15 to i64
  %22 = getelementptr i8, ptr %result.i.i, i64 %21
  store i8 0, ptr %22, align 1
  %puts.i = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  tail call void @benchmark_insert_sequential(i32 1000000)
  tail call void @benchmark_insert_random(i32 1000000)
  tail call void @benchmark_get_sequential_hit(i32 1000000)
  tail call void @benchmark_get_random_hit(i32 1000000)
  tail call void @benchmark_get_random_miss(i32 1000000)
  tail call void @benchmark_remove_random(i32 1000000)
  %result.i3 = tail call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nonnull @current_ptr) #29
  store <27 x i8> <i8 45, i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %result.i3, align 32
  %result.i4 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %23 = getelementptr inbounds i8, ptr %1, i64 8
  %24 = getelementptr inbounds i8, ptr %1, i64 24
  store ptr @String, ptr %1, align 8
  store ptr %result.i4, ptr %23, align 8
  store i32 9, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %1)
  store ptr %result.i3, ptr %result.i4, align 8
  %26 = getelementptr i8, ptr %result.i4, i64 8
  store i32 27, ptr %26, align 4
  %27 = getelementptr i8, ptr %result.i4, i64 12
  store i32 28, ptr %27, align 4
  %28 = load i160, ptr %23, align 8
  %29 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @IO)
  %.sroa.3.8.extract.trunc.i39 = trunc i160 %28 to i64
  %30 = inttoptr i64 %.sroa.3.8.extract.trunc.i39 to ptr
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load i32, ptr %31, align 4
  %33 = add i32 %32, 1
  %34 = sext i32 %33 to i64
  %result.i.i70 = tail call noalias ptr @bump_malloc_inner(i64 noundef %34, ptr nonnull @current_ptr) #29
  %35 = load i32, ptr %31, align 4
  %36 = icmp sgt i32 %35, 0
  br i1 %36, label %.lr.ph.i71, label %String_c_string_.exit75

.lr.ph.i71:                                       ; preds = %String_c_string_.exit
  %37 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %38 = load ptr, ptr %30, align 8
  %39 = zext nneg i32 %35 to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %result.i.i70, ptr align 1 %38, i64 %39, i1 false)
  br label %String_c_string_.exit75

String_c_string_.exit75:                          ; preds = %.lr.ph.i71, %String_c_string_.exit
  %40 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %41 = sext i32 %35 to i64
  %42 = getelementptr i8, ptr %result.i.i70, i64 %41
  store i8 0, ptr %42, align 1
  %puts.i55 = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i70)
  ret i32 0
}

define { i64, i64 } @_size_Pair(ptr nocapture readonly %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = tail call { i64, i64 } %6(ptr nonnull %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 16, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 16
  %15 = add i64 %14, %13
  %16 = getelementptr i8, ptr %0, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 48
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { i64, i64 } %20(ptr nonnull %17)
  %22 = extractvalue { i64, i64 } %21, 0
  %23 = extractvalue { i64, i64 } %21, 1
  %24 = tail call i64 @llvm.umax.i64(i64 %9, i64 %23)
  %25 = tail call i64 @llvm.umax.i64(i64 %24, i64 8)
  %26 = urem i64 %15, %23
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %23, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %22, %15
  %31 = add i64 %30, %29
  %32 = urem i64 %31, %25
  %33 = icmp eq i64 %32, 0
  %34 = sub i64 %25, %32
  %35 = select i1 %33, i64 0, i64 %34
  %36 = add i64 %31, %35
  %37 = insertvalue { i64, i64 } undef, i64 %36, 0
  %38 = insertvalue { i64, i64 } %37, i64 %25, 1
  ret { i64, i64 } %38
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract11)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract11, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract12, { ptr, i160 } %3)
  %13 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract11)
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract12, { ptr, i160 } %4)
  ret void
}

define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract3)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4)
  ret { ptr, i160 } %10
}

define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract3)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4)
  ret { ptr, i160 } %10
}

define { ptr, i160 } @Pair_getter_second(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 48
  %5 = load ptr, ptr %4, align 8
  %6 = tail call { i64, i64 } %5(ptr nonnull %2)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = extractvalue { i64, i64 } %6, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 48
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { i64, i64 } %19(ptr nonnull %16)
  %21 = extractvalue { i64, i64 } %20, 1
  %22 = urem i64 %14, %21
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 %21, %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = getelementptr i8, ptr %0, i64 %14
  %27 = getelementptr i8, ptr %26, i64 %25
  %28 = load ptr, ptr %15, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = tail call { ptr, i160 } %31(ptr %27, ptr nonnull %28)
  ret { ptr, i160 } %32
}

define void @Pair_setter_second(ptr %0, { ptr, i160 } %1) {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = tail call { i64, i64 } %6(ptr nonnull %3)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = urem i64 16, %9
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %9, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %8, 16
  %15 = add i64 %14, %13
  %16 = getelementptr i8, ptr %0, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 48
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { i64, i64 } %20(ptr nonnull %17)
  %22 = extractvalue { i64, i64 } %21, 1
  %23 = urem i64 %15, %22
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %22, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = getelementptr i8, ptr %0, i64 %15
  %28 = getelementptr i8, ptr %27, i64 %26
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr i8, ptr %30, i64 64
  %32 = load ptr, ptr %31, align 8
  tail call void %32({ ptr, i160 } %1, ptr nonnull %29, ptr %28)
  ret void
}

define { ptr, i160 } @Pair_getter_first(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 48
  %5 = load ptr, ptr %4, align 8
  %6 = tail call { i64, i64 } %5(ptr nonnull %2)
  %7 = extractvalue { i64, i64 } %6, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = load ptr, ptr %0, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 56
  %16 = load ptr, ptr %15, align 8
  %17 = tail call { ptr, i160 } %16(ptr %12, ptr nonnull %13)
  ret { ptr, i160 } %17
}

define void @Pair_setter_first(ptr %0, { ptr, i160 } %1) {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = tail call { i64, i64 } %6(ptr nonnull %3)
  %8 = extractvalue { i64, i64 } %7, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %reass.sub = sub i64 %8, %9
  %11 = add i64 %reass.sub, 16
  %12 = select i1 %10, i64 16, i64 %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load ptr, ptr %0, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 64
  %17 = load ptr, ptr %16, align 8
  tail call void %17({ ptr, i160 } %1, ptr nonnull %14, ptr %13)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Container(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Iterator2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Iterable2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Array(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterable2T(ptr nocapture %0) #6 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %0)
  ret ptr @Array__Self_from_iterable_iterableIterable2T
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__set_index_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_throw_oob_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_insert_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterable2T(ptr nocapture readnone %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %result.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  store ptr @any_typ, ptr %result.i, align 8
  %result.i29 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  store ptr %result.i, ptr %result.i29, align 8
  %4 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i29)
  %result.i.i = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %5 = getelementptr i8, ptr %result.i29, i64 8
  store ptr %result.i.i, ptr %5, align 8
  %6 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  %7 = getelementptr i8, ptr %result.i29, i64 20
  store i32 1, ptr %7, align 4
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract3, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract5, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i.i, 3
  %12 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %13 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract1, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = call ptr %17({ ptr, ptr, ptr, i32 } %11, ptr nonnull %3)
  %19 = call { ptr, ptr, ptr, i32 } %18({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull %3)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %hash_coef_ptr.i.i45 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i48 = load i64, ptr %hash_coef_ptr.i.i45, align 4
  %tbl_size.i.i49 = load i64, ptr %tbl_size_ptr.i.i46, align 4
  %offset_tbl.i.i50 = load ptr, ptr %offset_tbl_ptr.i.i47, align 8
  %product.i.i.i51 = mul i64 %hash_coef.i.i48, 4189192806087951739
  %shifted.i.i.i52 = lshr i64 %product.i.i.i51, 32
  %xored.i.i.i53 = xor i64 %shifted.i.i.i52, %product.i.i.i51
  %hash.i.i.i54 = and i64 %xored.i.i.i53, %tbl_size.i.i49
  %offset_ptr.i.i55 = getelementptr i32, ptr %offset_tbl.i.i50, i64 %hash.i.i.i54
  %offset.i.i70 = load i32, ptr %offset_ptr.i.i55, align 4
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %offset.i.i70, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %25 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %.fca.0.extract)
  %26 = sext i32 %offset.i.i70 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = call ptr %29({ ptr, ptr, ptr, i32 } %23, ptr nonnull %3)
  %31 = call { ptr, i160 } %30({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %3)
  %.fca.0.extract23120 = extractvalue { ptr, i160 } %31, 0
  %32 = icmp ne ptr %.fca.0.extract23120, @nil_typ
  %33 = icmp ne ptr %.fca.0.extract23120, null
  %.not28121 = and i1 %32, %33
  br i1 %.not28121, label %._crit_edge.preheader, label %.critedge

._crit_edge.preheader:                            ; preds = %2
  %34 = getelementptr i8, ptr %result.i29, i64 16
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %Array_append_xT.exit
  %35 = phi ptr [ %55, %Array_append_xT.exit ], [ %result.i.i, %._crit_edge.preheader ]
  %.pre = phi i32 [ %61, %Array_append_xT.exit ], [ 0, %._crit_edge.preheader ]
  %36 = phi { ptr, i160 } [ %65, %Array_append_xT.exit ], [ %31, %._crit_edge.preheader ]
  %37 = load i32, ptr %7, align 4
  %.not.i = icmp slt i32 %.pre, %37
  br i1 %.not.i, label %Array_append_xT.exit, label %38

38:                                               ; preds = %._crit_edge
  %39 = shl i32 %37, 1
  %.not.i125 = icmp sgt i32 %39, %37
  %.pre127.pre = load ptr, ptr %5, align 8
  br i1 %.not.i125, label %40, label %Array_append_xT.exit

40:                                               ; preds = %38
  store i32 %39, ptr %7, align 4
  %41 = sext i32 %39 to i64
  %42 = shl nsw i64 %41, 5
  %result.i.i126 = call noalias ptr @bump_malloc_inner(i64 noundef %42, ptr nonnull @current_ptr) #29
  store ptr %result.i.i126, ptr %5, align 8
  %43 = icmp sgt i32 %.pre, 0
  br i1 %43, label %.lr.ph.i, label %Array_append_xT.exit

.lr.ph.i:                                         ; preds = %40
  %44 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i, %.lr.ph.i
  %.reg2mem17.030.i = phi i32 [ 0, %.lr.ph.i ], [ %53, %._crit_edge.i ]
  %45 = zext nneg i32 %.reg2mem17.030.i to i64
  %46 = shl nuw nsw i64 %45, 5
  %47 = getelementptr i8, ptr %.pre127.pre, i64 %46
  %48 = getelementptr i8, ptr %result.i.i126, i64 %46
  %49 = load ptr, ptr %47, align 8
  %50 = getelementptr i8, ptr %47, i64 8
  %51 = load i160, ptr %50, align 4
  store ptr %49, ptr %48, align 8
  %52 = getelementptr i8, ptr %48, i64 8
  store i160 %51, ptr %52, align 4
  %53 = add nuw nsw i32 %.reg2mem17.030.i, 1
  %54 = icmp slt i32 %53, %.pre
  br i1 %54, label %._crit_edge.i, label %Array_append_xT.exit

Array_append_xT.exit:                             ; preds = %._crit_edge.i, %40, %38, %._crit_edge
  %55 = phi ptr [ %35, %._crit_edge ], [ %.pre127.pre, %38 ], [ %result.i.i126, %40 ], [ %result.i.i126, %._crit_edge.i ]
  %.fca.1.extract.i = extractvalue { ptr, i160 } %36, 1
  %.fca.0.extract.i = extractvalue { ptr, i160 } %36, 0
  %56 = sext i32 %.pre to i64
  %57 = shl nsw i64 %56, 5
  %58 = getelementptr i8, ptr %55, i64 %57
  store ptr %.fca.0.extract.i, ptr %58, align 8
  %59 = getelementptr i8, ptr %58, i64 8
  store i160 %.fca.1.extract.i, ptr %59, align 4
  %60 = load i32, ptr %34, align 4
  %61 = add i32 %60, 1
  %62 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull @Array)
  store i32 %61, ptr %34, align 4
  %63 = load ptr, ptr %28, align 8
  %64 = call ptr %63({ ptr, ptr, ptr, i32 } %23, ptr nonnull %3)
  %65 = call { ptr, i160 } %64({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull %3)
  %.fca.0.extract23 = extractvalue { ptr, i160 } %65, 0
  %66 = icmp ne ptr %.fca.0.extract23, @nil_typ
  %67 = icmp ne ptr %.fca.0.extract23, null
  %.not28 = and i1 %66, %67
  br i1 %.not28, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %Array_append_xT.exit, %2
  %68 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i29, 1
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr undef, 2
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, i32 9, 3
  ret { ptr, ptr, ptr, i32 } %70
}

define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %result.i = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %4 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %10(ptr %.fca.1.extract, { ptr } %11)
  %12 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %13 = getelementptr i8, ptr %6, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  tail call void %16(ptr %.fca.1.extract, i32 0)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %18 = getelementptr i8, ptr %6, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract, i32 1)
  ret void
}

define void @Array_init_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract, i32 %3)
  %12 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract)
  %16 = sext i32 %15 to i64
  %17 = shl nsw i64 %16, 5
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %17, ptr nonnull @current_ptr) #29
  %18 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %19 = getelementptr i8, ptr %7, i64 8
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %22(ptr %.fca.1.extract, { ptr } %23)
  %24 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %25 = getelementptr i8, ptr %7, i64 16
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  tail call void %28(ptr %.fca.1.extract, i32 0)
  ret void
}

define void @Array_init_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3, i32 %4) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, i32 %3)
  %13 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4)
  %18 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %19 = load ptr, ptr %14, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call i32 %20(ptr %.fca.1.extract)
  %22 = sext i32 %21 to i64
  %23 = shl nsw i64 %22, 5
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %23, ptr nonnull @current_ptr) #29
  %24 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %25 = getelementptr i8, ptr %8, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %28(ptr %.fca.1.extract, { ptr } %29)
  ret void
}

define i32 @Array_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract)
  ret i32 %10
}

define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract)
  ret i32 %10
}

define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, i160 } %3) {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract1)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract1, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract2)
  %14 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract1)
  %15 = getelementptr i8, ptr %9, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract2)
  %.not = icmp slt i32 %13, %18
  br i1 %.not, label %.._crit_edge_crit_edge, label %19

.._crit_edge_crit_edge:                           ; preds = %4
  %.pre = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %.pre48 = insertvalue { ptr, ptr, ptr, i32 } %.pre, ptr %.fca.1.extract2, 1
  %.pre50 = insertvalue { ptr, ptr, ptr, i32 } %.pre48, ptr %.fca.2.extract, 2
  br label %._crit_edge

19:                                               ; preds = %4
  %20 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %21 = load ptr, ptr %15, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = tail call i32 %22(ptr %.fca.1.extract2)
  %24 = shl i32 %23, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.1.extract2, 1
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %.fca.2.extract, 2
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, i32 %offset.i.i, 3
  %29 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %30 = load ptr, ptr %9, align 8
  %31 = tail call ptr %30(ptr %.fca.1.extract2)
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %33 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %34 = getelementptr i8, ptr %9, i64 88
  %35 = load ptr, ptr %34, align 8
  store ptr @i32_typ, ptr %6, align 8
  %36 = call ptr %35({ ptr, ptr, ptr, i32 } %28, ptr nonnull %6)
  call void %36({ ptr, ptr, ptr, i32 } %28, { ptr, ptr, ptr, i32 } %28, ptr nonnull %5, i32 %24)
  br label %._crit_edge

._crit_edge:                                      ; preds = %.._crit_edge_crit_edge, %19
  %.pre-phi51 = phi { ptr, ptr, ptr, i32 } [ %.pre50, %.._crit_edge_crit_edge ], [ %27, %19 ]
  %.fca.1.extract = extractvalue { ptr, i160 } %3, 1
  %.fca.0.extract = extractvalue { ptr, i160 } %3, 0
  %37 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %38 = getelementptr i8, ptr %9, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call { ptr } %40(ptr %.fca.1.extract2)
  %.fca.0.extract5 = extractvalue { ptr } %41, 0
  %42 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %43 = load ptr, ptr %10, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call i32 %44(ptr %.fca.1.extract2)
  %46 = sext i32 %45 to i64
  %47 = shl nsw i64 %46, 5
  %48 = getelementptr i8, ptr %.fca.0.extract5, i64 %47
  store ptr %.fca.0.extract, ptr %48, align 8
  %49 = getelementptr i8, ptr %48, i64 8
  store i160 %.fca.1.extract, ptr %49, align 4
  %50 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %51 = load ptr, ptr %10, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr %.fca.1.extract2)
  %54 = add i32 %53, 1
  %55 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %56 = load ptr, ptr %10, align 8
  %57 = getelementptr i8, ptr %56, i64 8
  %58 = load ptr, ptr %57, align 8
  call void %58(ptr %.fca.1.extract2, i32 %54)
  %hash_coef.i.i12 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i13 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i14 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i15 = mul i64 %hash_coef.i.i12, -5261542750394134544
  %shifted.i.i.i16 = lshr i64 %product.i.i.i15, 32
  %xored.i.i.i17 = xor i64 %shifted.i.i.i16, %product.i.i.i15
  %hash.i.i.i18 = and i64 %xored.i.i.i17, %tbl_size.i.i13
  %offset_ptr.i.i19 = getelementptr i32, ptr %offset_tbl.i.i14, i64 %hash.i.i.i18
  %offset.i.i20 = load i32, ptr %offset_ptr.i.i19, align 4
  %59 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi51, i32 %offset.i.i20, 3
  ret { ptr, ptr, ptr, i32 } %59
}

define void @Array_reserve_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract)
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %.thread

12:                                               ; preds = %4
  %13 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %14 = load ptr, ptr %8, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  tail call void %16(ptr %.fca.1.extract, i32 %3)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %18 = getelementptr i8, ptr %7, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { ptr } %20(ptr %.fca.1.extract)
  %.fca.0.extract8 = extractvalue { ptr } %21, 0
  %22 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %23 = load ptr, ptr %8, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = tail call i32 %24(ptr %.fca.1.extract)
  %26 = sext i32 %25 to i64
  %27 = shl nsw i64 %26, 5
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %27, ptr nonnull @current_ptr) #29
  %28 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %29 = load ptr, ptr %18, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %31(ptr %.fca.1.extract, { ptr } %32)
  %33 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %34 = getelementptr i8, ptr %7, i64 16
  %35 = load ptr, ptr %34, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = tail call i32 %36(ptr %.fca.1.extract)
  %38 = icmp sgt i32 %37, 0
  br i1 %38, label %.lr.ph, label %.thread

.lr.ph:                                           ; preds = %12
  %39 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %.lr.ph, %._crit_edge
  %.reg2mem17.030 = phi i32 [ 0, %.lr.ph ], [ %51, %._crit_edge ]
  %40 = zext nneg i32 %.reg2mem17.030 to i64
  %41 = shl nuw nsw i64 %40, 5
  %42 = getelementptr i8, ptr %.fca.0.extract8, i64 %41
  %43 = load ptr, ptr %18, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = tail call { ptr } %44(ptr %.fca.1.extract)
  %.fca.0.extract4 = extractvalue { ptr } %45, 0
  %46 = getelementptr i8, ptr %.fca.0.extract4, i64 %41
  %47 = load ptr, ptr %42, align 8
  %48 = getelementptr i8, ptr %42, i64 8
  %49 = load i160, ptr %48, align 4
  store ptr %47, ptr %46, align 8
  %50 = getelementptr i8, ptr %46, i64 8
  store i160 %49, ptr %50, align 4
  %51 = add nuw nsw i32 %.reg2mem17.030, 1
  %52 = load ptr, ptr %34, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = tail call i32 %53(ptr %.fca.1.extract)
  %55 = icmp slt i32 %51, %54
  br i1 %55, label %._crit_edge, label %.thread

.thread:                                          ; preds = %._crit_edge, %12, %4
  ret void
}

define { ptr, i160 } @Array__index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %9 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract)
  %16 = add i32 %15, -1
  %17 = icmp sgt i32 %3, %16
  %18 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %19 = load ptr, ptr %12, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call i32 %20(ptr %.fca.1.extract)
  %22 = add i32 %21, %3
  %23 = icmp slt i32 %22, 0
  %24 = or i1 %17, %23
  br i1 %24, label %25, label %._crit_edge

25:                                               ; preds = %4
  %26 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %.fca.1.extract, 1
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.2.extract, 2
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %offset.i.i, 3
  %30 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %31 = load ptr, ptr %11, align 8
  %32 = tail call ptr %31(ptr %.fca.1.extract)
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %34 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %35 = getelementptr i8, ptr %11, i64 112
  %36 = load ptr, ptr %35, align 8
  store ptr @i32_typ, ptr %6, align 8
  %37 = call ptr %36({ ptr, ptr, ptr, i32 } %29, ptr nonnull %6)
  call void %37({ ptr, ptr, ptr, i32 } %29, { ptr, ptr, ptr, i32 } %29, ptr nonnull %5, i32 %3)
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %25
  %38 = icmp slt i32 %3, 0
  br i1 %38, label %39, label %45

39:                                               ; preds = %._crit_edge
  %40 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %41 = load ptr, ptr %12, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call i32 %42(ptr %.fca.1.extract)
  %44 = add i32 %43, %3
  br label %45

45:                                               ; preds = %._crit_edge, %39
  %.reg2mem3.0 = phi i32 [ %44, %39 ], [ %3, %._crit_edge ]
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %offset.i.i, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %51 = load ptr, ptr %11, align 8
  %52 = call ptr %51(ptr %.fca.1.extract)
  store ptr @_parameterization_Ptri32, ptr %7, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %7)
  %54 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract)
  %55 = getelementptr i8, ptr %11, i64 120
  %56 = load ptr, ptr %55, align 8
  store ptr @i32_typ, ptr %8, align 8
  %57 = call ptr %56({ ptr, ptr, ptr, i32 } %49, ptr nonnull %8)
  %58 = call { ptr, i160 } %57({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull %7, i32 %.reg2mem3.0)
  ret { ptr, i160 } %58
}

define void @Array__set_index_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3, { ptr, i160 } %4) {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %10 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract1)
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract1, i64 %11
  %13 = getelementptr i8, ptr %12, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract2)
  %17 = add i32 %16, -1
  %18 = icmp sgt i32 %3, %17
  %19 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract1)
  %20 = load ptr, ptr %13, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call i32 %21(ptr %.fca.1.extract2)
  %23 = add i32 %22, %3
  %24 = icmp slt i32 %23, 0
  %25 = or i1 %18, %24
  br i1 %25, label %26, label %._crit_edge

26:                                               ; preds = %5
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %28 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %.fca.1.extract2, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.2.extract, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 %offset.i.i, 3
  %31 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %32 = load ptr, ptr %12, align 8
  %33 = tail call ptr %32(ptr %.fca.1.extract2)
  store ptr @_parameterization_Ptri32, ptr %6, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %6)
  %35 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %36 = getelementptr i8, ptr %12, i64 112
  %37 = load ptr, ptr %36, align 8
  store ptr @i32_typ, ptr %7, align 8
  %38 = call ptr %37({ ptr, ptr, ptr, i32 } %30, ptr nonnull %7)
  call void %38({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull %6, i32 %3)
  br label %._crit_edge

._crit_edge:                                      ; preds = %5, %26
  %39 = icmp slt i32 %3, 0
  br i1 %39, label %40, label %46

40:                                               ; preds = %._crit_edge
  %41 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %42 = load ptr, ptr %13, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call i32 %43(ptr %.fca.1.extract2)
  %45 = add i32 %44, %3
  br label %46

46:                                               ; preds = %._crit_edge, %40
  %.reg2mem3.0 = phi i32 [ %45, %40 ], [ %3, %._crit_edge ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract2, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i.i, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %52 = load ptr, ptr %12, align 8
  %53 = call ptr %52(ptr %.fca.1.extract2)
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %54 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %53, ptr %54, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %8)
  %56 = call ptr @llvm.invariant.start.p0(i64 600, ptr nonnull %.fca.0.extract1)
  %57 = getelementptr i8, ptr %12, i64 128
  %58 = load ptr, ptr %57, align 8
  store ptr @i32_typ, ptr %9, align 8
  %59 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.0.extract, ptr %59, align 8
  %60 = call ptr %58({ ptr, ptr, ptr, i32 } %50, ptr nonnull %9)
  call void %60({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull %8, i32 %.reg2mem3.0, { ptr, i160 } %4)
  ret void
}

define void @Array_throw_oob_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %result.i = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nonnull @current_ptr) #29
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = getelementptr inbounds i8, ptr %5, i64 8
  %7 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @Exception, ptr %5, align 8
  store ptr %result.i, ptr %6, align 8
  store i32 9, ptr %7, align 8
  %8 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %5)
  %9 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = tail call ptr %12(ptr %.fca.1.extract)
  store i32 0, ptr %result.i, align 4
  %result.i.i = tail call noalias dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nonnull @current_ptr) #29
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i2.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  store ptr %result.i.i, ptr %result.i2.i, align 8
  %14 = getelementptr i8, ptr %result.i2.i, i64 8
  store i32 6, ptr %14, align 4
  %15 = getelementptr i8, ptr %result.i2.i, i64 12
  store i32 7, ptr %15, align 4
  %16 = getelementptr i8, ptr %result.i, i64 40
  store ptr @String, ptr %16, align 8
  %17 = getelementptr i8, ptr %result.i, i64 48
  store ptr %result.i2.i, ptr %17, align 8
  %18 = getelementptr i8, ptr %result.i, i64 64
  store i32 9, ptr %18, align 4
  %result.i17.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nonnull @current_ptr) #29
  %result.i18.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  store ptr %result.i17.i, ptr %result.i18.i, align 8
  %19 = getelementptr i8, ptr %result.i18.i, i64 8
  store i32 0, ptr %19, align 4
  %20 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %21 = getelementptr i8, ptr %result.i18.i, i64 12
  store i32 1, ptr %21, align 4
  %22 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Exception)
  %23 = getelementptr i8, ptr %result.i, i64 8
  store ptr @String, ptr %23, align 8
  %24 = getelementptr i8, ptr %result.i, i64 16
  store ptr %result.i18.i, ptr %24, align 8
  %25 = getelementptr i8, ptr %result.i, i64 32
  store i32 9, ptr %25, align 4
  %result.i1 = tail call noalias dereferenceable_or_null(17) ptr @bump_malloc_inner(i64 noundef 17, ptr nonnull @current_ptr) #29
  store <16 x i8> <i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i1, align 16
  %result.i2 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %26 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %27 = load ptr, ptr %11, align 8
  %28 = tail call ptr %27(ptr %.fca.1.extract)
  store ptr %result.i1, ptr %result.i2, align 8
  %29 = getelementptr i8, ptr %result.i2, i64 8
  store i32 16, ptr %29, align 4
  %30 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %31 = getelementptr i8, ptr %result.i2, i64 12
  store i32 17, ptr %31, align 4
  %32 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %33 = load ptr, ptr %11, align 8
  %34 = tail call ptr %33(ptr %.fca.1.extract)
  store i32 150, ptr %result.i, align 4
  %35 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull @Exception)
  store ptr @String, ptr %23, align 8
  store ptr %result.i2, ptr %24, align 8
  store i32 9, ptr %25, align 4
  %36 = load i160, ptr %6, align 8
  %37 = insertvalue { ptr, i160 } { ptr @Exception, i160 undef }, i160 %36, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %38 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %37, ptr %38, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture writeonly %into_callee_buf.i, ptr nonnull @into_caller_buf) #32
  ret void
}

define { ptr, i160 } @Array_unchecked_index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract2)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract2, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr } %10(ptr %.fca.1.extract)
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = sext i32 %3 to i64
  %13 = shl nsw i64 %12, 5
  %14 = getelementptr i8, ptr %.fca.0.extract, i64 %13
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %14, i64 8
  %17 = load i160, ptr %16, align 4
  %18 = insertvalue { ptr, i160 } undef, ptr %15, 0
  %19 = insertvalue { ptr, i160 } %18, i160 %17, 1
  ret { ptr, i160 } %19
}

define void @Array_unchecked_insert_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3, { ptr, i160 } %4) {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract4 = extractvalue { ptr, i160 } %4, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %4, 1
  %6 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract5)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract5, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr } %11(ptr %.fca.1.extract6)
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = sext i32 %3 to i64
  %14 = shl nsw i64 %13, 5
  %15 = getelementptr i8, ptr %.fca.0.extract, i64 %14
  store ptr %.fca.0.extract4, ptr %15, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  store i160 %.fca.1.extract, ptr %16, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = tail call ptr %7(ptr %.fca.1.extract)
  %result.i = tail call noalias dereferenceable_or_null(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nonnull @current_ptr) #29
  store ptr %8, ptr %result.i, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i)
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %13 = load ptr, ptr %6, align 8
  %14 = tail call ptr %13(ptr %.fca.1.extract)
  %15 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @ArrayIterator)
  %hash_coef.i.i59 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i60 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i61 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i62 = mul i64 %hash_coef.i.i59, -5261542750394134544
  %shifted.i.i.i63 = lshr i64 %product.i.i.i62, 32
  %xored.i.i.i64 = xor i64 %shifted.i.i.i63, %product.i.i.i62
  %hash.i.i.i65 = and i64 %xored.i.i.i64, %tbl_size.i.i60
  %offset_ptr.i.i66 = getelementptr i32, ptr %offset_tbl.i.i61, i64 %hash.i.i.i65
  %offset.i.i54 = load i32, ptr %offset_ptr.i.i66, align 4
  %16 = getelementptr i8, ptr %result.i, i64 8
  store ptr %.fca.0.extract, ptr %16, align 8
  %17 = getelementptr i8, ptr %result.i, i64 16
  store ptr %.fca.1.extract, ptr %17, align 8
  %18 = getelementptr i8, ptr %result.i, i64 24
  store ptr %.fca.2.extract, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i, i64 32
  store i32 %offset.i.i54, ptr %19, align 4
  %20 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @ArrayIterator)
  %21 = getelementptr i8, ptr %result.i, i64 40
  store i32 0, ptr %21, align 4
  %22 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 16, 3
  ret { ptr, ptr, ptr, i32 } %22
}

define void @Iterable2_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract5, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract3)
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract3, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = tail call ptr %13(ptr %.fca.1.extract5)
  %15 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %16 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract3)
  %17 = getelementptr i8, ptr %12, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = call ptr %18({ ptr, ptr, ptr, i32 } %9, ptr nonnull %5)
  %20 = call { ptr, ptr, ptr, i32 } %19({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %hash_coef_ptr.i.i25 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i26 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i28 = load i64, ptr %hash_coef_ptr.i.i25, align 4
  %tbl_size.i.i29 = load i64, ptr %tbl_size_ptr.i.i26, align 4
  %offset_tbl.i.i30 = load ptr, ptr %offset_tbl_ptr.i.i27, align 8
  %product.i.i.i31 = mul i64 %hash_coef.i.i28, 4189192806087951739
  %shifted.i.i.i32 = lshr i64 %product.i.i.i31, 32
  %xored.i.i.i33 = xor i64 %shifted.i.i.i32, %product.i.i.i31
  %hash.i.i.i34 = and i64 %xored.i.i.i33, %tbl_size.i.i29
  %offset_ptr.i.i35 = getelementptr i32, ptr %offset_tbl.i.i30, i64 %hash.i.i.i34
  %offset.i.i50 = load i32, ptr %offset_ptr.i.i35, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr %.fca.1.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %21, i64 16
  store ptr %.fca.2.extract, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %21, i64 24
  store i32 %offset.i.i50, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %21)
  %26 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %27 = call ptr @llvm.invariant.start.p0(i64 184, ptr nonnull %.fca.0.extract3)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %4
  %28 = phi i32 [ %.pre62, %._crit_edge ], [ %offset.i.i50, %4 ]
  %29 = phi ptr [ %.pre61, %._crit_edge ], [ %.fca.2.extract, %4 ]
  %30 = phi ptr [ %.pre, %._crit_edge ], [ %.fca.1.extract, %4 ]
  %31 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %30, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %29, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %28, 3
  %34 = load ptr, ptr %12, align 8
  %35 = call ptr %34(ptr %.fca.1.extract5)
  %36 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %37 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %.fca.0.extract)
  %38 = sext i32 %28 to i64
  %gep = getelementptr ptr, ptr %hash_coef_ptr.i.i25, i64 %38
  %39 = load ptr, ptr %gep, align 8
  %40 = call ptr %39({ ptr, ptr, ptr, i32 } %33, ptr nonnull %5)
  %41 = call { ptr, i160 } %40({ ptr, ptr, ptr, i32 } %33, { ptr, ptr, ptr, i32 } %33, ptr nonnull %5)
  %.fca.0.extract18 = extractvalue { ptr, i160 } %41, 0
  %42 = icmp ne ptr %.fca.0.extract18, @nil_typ
  %43 = icmp ne ptr %.fca.0.extract18, null
  %.not23 = and i1 %42, %43
  br i1 %.not23, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %._crit_edge1
  call void %.fca.0.extract1({ ptr, i160 } %41)
  %.pre = load ptr, ptr %22, align 8
  %.pre61 = load ptr, ptr %23, align 8
  %.pre62 = load i32, ptr %24, align 8
  br label %._crit_edge1

.critedge:                                        ; preds = %._crit_edge1
  ret void
}

define { ptr, i160 } @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, i160 } %3, { ptr } %4) {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract12, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract14, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract10)
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract10, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = tail call ptr %14(ptr %.fca.1.extract12)
  %16 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract10)
  %18 = getelementptr i8, ptr %13, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr %19({ ptr, ptr, ptr, i32 } %10, ptr nonnull %6)
  %21 = call { ptr, ptr, ptr, i32 } %20({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull %6)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %21, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %21, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %21, 2
  %hash_coef_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i49 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i50 = load i64, ptr %hash_coef_ptr.i.i47, align 4
  %tbl_size.i.i51 = load i64, ptr %tbl_size_ptr.i.i48, align 4
  %offset_tbl.i.i52 = load ptr, ptr %offset_tbl_ptr.i.i49, align 8
  %product.i.i.i53 = mul i64 %hash_coef.i.i50, 4189192806087951739
  %shifted.i.i.i54 = lshr i64 %product.i.i.i53, 32
  %xored.i.i.i55 = xor i64 %shifted.i.i.i54, %product.i.i.i53
  %hash.i.i.i56 = and i64 %xored.i.i.i55, %tbl_size.i.i51
  %offset_ptr.i.i57 = getelementptr i32, ptr %offset_tbl.i.i52, i64 %hash.i.i.i56
  %offset.i.i72 = load i32, ptr %offset_ptr.i.i57, align 4
  %22 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %22, i64 8
  store ptr %.fca.1.extract, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %22, i64 16
  store ptr %.fca.2.extract, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %22, i64 24
  store i32 %offset.i.i72, ptr %25, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %22)
  %27 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 184, ptr nonnull %.fca.0.extract10)
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %5
  %29 = phi i32 [ %offset.i.i72, %5 ], [ %.pre89, %._crit_edge ]
  %30 = phi ptr [ %.fca.2.extract, %5 ], [ %.pre88, %._crit_edge ]
  %31 = phi ptr [ %.fca.1.extract, %5 ], [ %.pre, %._crit_edge ]
  %.pn = phi { ptr, i160 } [ %3, %5 ], [ %45, %._crit_edge ]
  %32 = insertvalue { ptr, ptr, ptr, i32 } %27, ptr %31, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %30, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %29, 3
  %35 = load ptr, ptr %13, align 8
  %36 = call ptr %35(ptr %.fca.1.extract12)
  %37 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %38 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %.fca.0.extract)
  %39 = sext i32 %29 to i64
  %gep = getelementptr ptr, ptr %hash_coef_ptr.i.i47, i64 %39
  %40 = load ptr, ptr %gep, align 8
  %41 = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nonnull %6)
  %42 = call { ptr, i160 } %41({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %6)
  %.fca.0.extract38 = extractvalue { ptr, i160 } %42, 0
  %43 = icmp ne ptr %.fca.0.extract38, @nil_typ
  %44 = icmp ne ptr %.fca.0.extract38, null
  %.not45 = and i1 %43, %44
  br i1 %.not45, label %._crit_edge, label %46

._crit_edge:                                      ; preds = %._crit_edge1
  %45 = call { ptr, i160 } %.fca.0.extract1({ ptr, i160 } %.pn, { ptr, i160 } %42)
  %.pre = load ptr, ptr %23, align 8
  %.pre88 = load ptr, ptr %24, align 8
  %.pre89 = load i32, ptr %25, align 8
  br label %._crit_edge1

46:                                               ; preds = %._crit_edge1
  ret { ptr, i160 } %.pn
}

define noundef i1 @Iterable2_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract5, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract3)
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract3, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = tail call ptr %13(ptr %.fca.1.extract5)
  %15 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %16 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract3)
  %17 = getelementptr i8, ptr %12, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = call ptr %18({ ptr, ptr, ptr, i32 } %9, ptr nonnull %5)
  %20 = call { ptr, ptr, ptr, i32 } %19({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %hash_coef_ptr.i.i23 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i24 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i25 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i23, align 4
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i24, align 4
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i25, align 8
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, 4189192806087951739
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i48 = load i32, ptr %offset_ptr.i.i33, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr %.fca.1.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %21, i64 16
  store ptr %.fca.2.extract, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %21, i64 24
  store i32 %offset.i.i48, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %21)
  %26 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %27 = call ptr @llvm.invariant.start.p0(i64 184, ptr nonnull %.fca.0.extract3)
  br label %28

28:                                               ; preds = %46, %4
  %29 = load ptr, ptr %22, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %29, 1
  %31 = load ptr, ptr %23, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %31, 2
  %33 = load i32, ptr %24, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %33, 3
  %35 = load ptr, ptr %12, align 8
  %36 = call ptr %35(ptr %.fca.1.extract5)
  %37 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %38 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %.fca.0.extract)
  %39 = sext i32 %33 to i64
  %gep = getelementptr ptr, ptr %hash_coef_ptr.i.i23, i64 %39
  %40 = load ptr, ptr %gep, align 8
  %41 = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nonnull %5)
  %42 = call { ptr, i160 } %41({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %5)
  %.fca.0.extract18 = extractvalue { ptr, i160 } %42, 0
  %43 = icmp eq ptr %.fca.0.extract18, @nil_typ
  %44 = icmp eq ptr %.fca.0.extract18, null
  %45 = or i1 %43, %44
  br i1 %45, label %.critedge.cont, label %46

46:                                               ; preds = %28
  %47 = call i1 %.fca.0.extract1({ ptr, i160 } %42)
  br i1 %47, label %28, label %.critedge.cont

.critedge.cont:                                   ; preds = %46, %28
  ret i1 %45
}

define noundef i1 @Iterable2_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract5, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract3)
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract3, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = tail call ptr %13(ptr %.fca.1.extract5)
  %15 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %16 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract3)
  %17 = getelementptr i8, ptr %12, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = call ptr %18({ ptr, ptr, ptr, i32 } %9, ptr nonnull %5)
  %20 = call { ptr, ptr, ptr, i32 } %19({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %5)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %hash_coef_ptr.i.i25 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i26 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i28 = load i64, ptr %hash_coef_ptr.i.i25, align 4
  %tbl_size.i.i29 = load i64, ptr %tbl_size_ptr.i.i26, align 4
  %offset_tbl.i.i30 = load ptr, ptr %offset_tbl_ptr.i.i27, align 8
  %product.i.i.i31 = mul i64 %hash_coef.i.i28, 4189192806087951739
  %shifted.i.i.i32 = lshr i64 %product.i.i.i31, 32
  %xored.i.i.i33 = xor i64 %shifted.i.i.i32, %product.i.i.i31
  %hash.i.i.i34 = and i64 %xored.i.i.i33, %tbl_size.i.i29
  %offset_ptr.i.i35 = getelementptr i32, ptr %offset_tbl.i.i30, i64 %hash.i.i.i34
  %offset.i.i50 = load i32, ptr %offset_ptr.i.i35, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store ptr %.fca.0.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %21, i64 8
  store ptr %.fca.1.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %21, i64 16
  store ptr %.fca.2.extract, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %21, i64 24
  store i32 %offset.i.i50, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %21)
  %26 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %27 = call ptr @llvm.invariant.start.p0(i64 184, ptr nonnull %.fca.0.extract3)
  br label %28

28:                                               ; preds = %45, %4
  %29 = load ptr, ptr %22, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } %26, ptr %29, 1
  %31 = load ptr, ptr %23, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %31, 2
  %33 = load i32, ptr %24, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %33, 3
  %35 = load ptr, ptr %12, align 8
  %36 = call ptr %35(ptr %.fca.1.extract5)
  %37 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %38 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %.fca.0.extract)
  %39 = sext i32 %33 to i64
  %gep = getelementptr ptr, ptr %hash_coef_ptr.i.i25, i64 %39
  %40 = load ptr, ptr %gep, align 8
  %41 = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nonnull %5)
  %42 = call { ptr, i160 } %41({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %5)
  %.fca.0.extract18 = extractvalue { ptr, i160 } %42, 0
  %43 = icmp ne ptr %.fca.0.extract18, @nil_typ
  %44 = icmp ne ptr %.fca.0.extract18, null
  %.not23 = and i1 %43, %44
  br i1 %.not23, label %45, label %.critedge.cont

45:                                               ; preds = %28
  %46 = call i1 %.fca.0.extract1({ ptr, i160 } %42)
  br i1 %46, label %.critedge.cont, label %28

.critedge.cont:                                   ; preds = %28, %45
  ret i1 %.not23
}

define { ptr, ptr, ptr, i32 } @Iterable2_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readonly %2, { ptr } %3) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = tail call ptr %8(ptr %.fca.1.extract)
  %10 = load ptr, ptr %2, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %result.i = tail call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nonnull @current_ptr) #29
  store ptr %9, ptr %result.i, align 8
  %13 = getelementptr i8, ptr %result.i, i64 8
  store ptr %12, ptr %13, align 8
  %14 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i)
  %15 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr undef, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 9, 3
  %18 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %19 = load ptr, ptr %7, align 8
  %20 = tail call ptr %19(ptr %.fca.1.extract)
  %21 = tail call ptr @llvm.invariant.start.p0(i64 408, ptr nonnull @MapIterable2)
  %hash_coef.i.i61 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i62 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i63 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i64 = mul i64 %hash_coef.i.i61, 5693646204635713916
  %shifted.i.i.i65 = lshr i64 %product.i.i.i64, 32
  %xored.i.i.i66 = xor i64 %shifted.i.i.i65, %product.i.i.i64
  %hash.i.i.i67 = and i64 %xored.i.i.i66, %tbl_size.i.i62
  %offset_ptr.i.i68 = getelementptr i32, ptr %offset_tbl.i.i63, i64 %hash.i.i.i67
  %offset.i.i56 = load i32, ptr %offset_ptr.i.i68, align 4
  %22 = getelementptr i8, ptr %result.i, i64 16
  store ptr %.fca.0.extract1, ptr %22, align 8
  %23 = getelementptr i8, ptr %result.i, i64 24
  store ptr %.fca.1.extract, ptr %23, align 8
  %24 = getelementptr i8, ptr %result.i, i64 32
  store ptr %.fca.2.extract, ptr %24, align 8
  %25 = getelementptr i8, ptr %result.i, i64 40
  store i32 %offset.i.i56, ptr %25, align 4
  %26 = tail call ptr @llvm.invariant.start.p0(i64 408, ptr nonnull @MapIterable2)
  %27 = getelementptr i8, ptr %result.i, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %27, align 8
  ret { ptr, ptr, ptr, i32 } %17
}

define { ptr, ptr, ptr, i32 } @Iterable2_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr } %3) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = tail call ptr %8(ptr %.fca.1.extract)
  %result.i = tail call noalias dereferenceable_or_null(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nonnull @current_ptr) #29
  store ptr %9, ptr %result.i, align 8
  %10 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i)
  %11 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr undef, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 9, 3
  %14 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %15 = load ptr, ptr %7, align 8
  %16 = tail call ptr %15(ptr %.fca.1.extract)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr nonnull @FilterIterable2)
  %hash_coef.i.i61 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i62 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i63 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i64 = mul i64 %hash_coef.i.i61, 5693646204635713916
  %shifted.i.i.i65 = lshr i64 %product.i.i.i64, 32
  %xored.i.i.i66 = xor i64 %shifted.i.i.i65, %product.i.i.i64
  %hash.i.i.i67 = and i64 %xored.i.i.i66, %tbl_size.i.i62
  %offset_ptr.i.i68 = getelementptr i32, ptr %offset_tbl.i.i63, i64 %hash.i.i.i67
  %offset.i.i56 = load i32, ptr %offset_ptr.i.i68, align 4
  %18 = getelementptr i8, ptr %result.i, i64 8
  store ptr %.fca.0.extract1, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i, i64 16
  store ptr %.fca.1.extract, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i, i64 24
  store ptr %.fca.2.extract, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i, i64 32
  store i32 %offset.i.i56, ptr %21, align 4
  %22 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr nonnull @FilterIterable2)
  %23 = getelementptr i8, ptr %result.i, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %23, align 8
  ret { ptr, ptr, ptr, i32 } %13
}

define { ptr, ptr, ptr, i32 } @Iterable2_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = tail call ptr %8(ptr %.fca.1.extract3)
  %result.i = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nonnull @current_ptr) #29
  store ptr %9, ptr %result.i, align 8
  %10 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i)
  %11 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr undef, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 9, 3
  %14 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %15 = load ptr, ptr %7, align 8
  %16 = tail call ptr %15(ptr %.fca.1.extract3)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr nonnull @ChainIterable2)
  %hash_coef.i.i132 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i133 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i134 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i135 = mul i64 %hash_coef.i.i132, 5693646204635713916
  %shifted.i.i.i136 = lshr i64 %product.i.i.i135, 32
  %xored.i.i.i137 = xor i64 %shifted.i.i.i136, %product.i.i.i135
  %hash.i.i.i138 = and i64 %xored.i.i.i137, %tbl_size.i.i133
  %offset_ptr.i.i139 = getelementptr i32, ptr %offset_tbl.i.i134, i64 %hash.i.i.i138
  %offset.i.i126 = load i32, ptr %offset_ptr.i.i139, align 4
  %18 = getelementptr i8, ptr %result.i, i64 8
  store ptr %.fca.0.extract1, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i, i64 16
  store ptr %.fca.1.extract3, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i, i64 24
  store ptr %.fca.2.extract5, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i, i64 32
  store i32 %offset.i.i126, ptr %21, align 4
  %hash_coef.i.i104 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i105 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i106 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i107 = mul i64 %hash_coef.i.i104, 5693646204635713916
  %shifted.i.i.i108 = lshr i64 %product.i.i.i107, 32
  %xored.i.i.i109 = xor i64 %shifted.i.i.i108, %product.i.i.i107
  %hash.i.i.i110 = and i64 %xored.i.i.i109, %tbl_size.i.i105
  %offset_ptr.i.i111 = getelementptr i32, ptr %offset_tbl.i.i106, i64 %hash.i.i.i110
  %offset.i.i99 = load i32, ptr %offset_ptr.i.i111, align 4
  %22 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr nonnull @ChainIterable2)
  %23 = getelementptr i8, ptr %result.i, i64 40
  store ptr %.fca.0.extract, ptr %23, align 8
  %24 = getelementptr i8, ptr %result.i, i64 48
  store ptr %.fca.1.extract, ptr %24, align 8
  %25 = getelementptr i8, ptr %result.i, i64 56
  store ptr %.fca.2.extract, ptr %25, align 8
  %26 = getelementptr i8, ptr %result.i, i64 64
  store i32 %offset.i.i99, ptr %26, align 4
  ret { ptr, ptr, ptr, i32 } %13
}

define { ptr, ptr, ptr, i32 } @Iterable2_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = tail call ptr %8(ptr %.fca.1.extract3)
  %result.i = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nonnull @current_ptr) #29
  store ptr %9, ptr %result.i, align 8
  %10 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i)
  %11 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr undef, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 9, 3
  %14 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %15 = load ptr, ptr %7, align 8
  %16 = tail call ptr %15(ptr %.fca.1.extract3)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr nonnull @InterleaveIterable2)
  %hash_coef.i.i132 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i133 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i134 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i135 = mul i64 %hash_coef.i.i132, 5693646204635713916
  %shifted.i.i.i136 = lshr i64 %product.i.i.i135, 32
  %xored.i.i.i137 = xor i64 %shifted.i.i.i136, %product.i.i.i135
  %hash.i.i.i138 = and i64 %xored.i.i.i137, %tbl_size.i.i133
  %offset_ptr.i.i139 = getelementptr i32, ptr %offset_tbl.i.i134, i64 %hash.i.i.i138
  %offset.i.i126 = load i32, ptr %offset_ptr.i.i139, align 4
  %18 = getelementptr i8, ptr %result.i, i64 8
  store ptr %.fca.0.extract1, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i, i64 16
  store ptr %.fca.1.extract3, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i, i64 24
  store ptr %.fca.2.extract5, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i, i64 32
  store i32 %offset.i.i126, ptr %21, align 4
  %hash_coef.i.i104 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i105 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i106 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i107 = mul i64 %hash_coef.i.i104, 5693646204635713916
  %shifted.i.i.i108 = lshr i64 %product.i.i.i107, 32
  %xored.i.i.i109 = xor i64 %shifted.i.i.i108, %product.i.i.i107
  %hash.i.i.i110 = and i64 %xored.i.i.i109, %tbl_size.i.i105
  %offset_ptr.i.i111 = getelementptr i32, ptr %offset_tbl.i.i106, i64 %hash.i.i.i110
  %offset.i.i99 = load i32, ptr %offset_ptr.i.i111, align 4
  %22 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr nonnull @InterleaveIterable2)
  %23 = getelementptr i8, ptr %result.i, i64 40
  store ptr %.fca.0.extract, ptr %23, align 8
  %24 = getelementptr i8, ptr %result.i, i64 48
  store ptr %.fca.1.extract, ptr %24, align 8
  %25 = getelementptr i8, ptr %result.i, i64 56
  store ptr %.fca.2.extract, ptr %25, align 8
  %26 = getelementptr i8, ptr %result.i, i64 64
  store i32 %offset.i.i99, ptr %26, align 4
  ret { ptr, ptr, ptr, i32 } %13
}

define { ptr, ptr, ptr, i32 } @Iterable2_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i26 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract17)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = tail call ptr %8(ptr %.fca.1.extract19)
  %10 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract9)
  %11 = sext i32 %.fca.3.extract15 to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract9, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = tail call ptr %13(ptr %.fca.1.extract11)
  %result.i = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %15 = getelementptr i8, ptr %result.i, i64 16
  store ptr %14, ptr %15, align 8
  %16 = getelementptr i8, ptr %result.i, i64 8
  store ptr %9, ptr %16, align 8
  %17 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %17, align 8
  %18 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @Pair, ptr %result.i, align 8
  %result.i39 = tail call noalias dereferenceable_or_null(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nonnull @current_ptr) #29
  store ptr %9, ptr %result.i39, align 8
  %19 = getelementptr i8, ptr %result.i39, i64 8
  store ptr %14, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i39, i64 16
  store ptr %result.i, ptr %20, align 8
  %21 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i39)
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i39, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 9, 3
  %25 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract17)
  %26 = load ptr, ptr %7, align 8
  %27 = tail call ptr %26(ptr %.fca.1.extract19)
  %28 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract9)
  %29 = load ptr, ptr %12, align 8
  %30 = tail call ptr %29(ptr %.fca.1.extract11)
  %31 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr nonnull @ZipIterable2)
  %hash_coef.i.i148 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i149 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i150 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i151 = mul i64 %hash_coef.i.i148, 5693646204635713916
  %shifted.i.i.i152 = lshr i64 %product.i.i.i151, 32
  %xored.i.i.i153 = xor i64 %shifted.i.i.i152, %product.i.i.i151
  %hash.i.i.i154 = and i64 %xored.i.i.i153, %tbl_size.i.i149
  %offset_ptr.i.i155 = getelementptr i32, ptr %offset_tbl.i.i150, i64 %hash.i.i.i154
  %offset.i.i142 = load i32, ptr %offset_ptr.i.i155, align 4
  %32 = getelementptr i8, ptr %result.i39, i64 24
  store ptr %.fca.0.extract17, ptr %32, align 8
  %33 = getelementptr i8, ptr %result.i39, i64 32
  store ptr %.fca.1.extract19, ptr %33, align 8
  %34 = getelementptr i8, ptr %result.i39, i64 40
  store ptr %.fca.2.extract21, ptr %34, align 8
  %35 = getelementptr i8, ptr %result.i39, i64 48
  store i32 %offset.i.i142, ptr %35, align 4
  %hash_coef.i.i120 = load i64, ptr %hash_coef_ptr.i.i26, align 4
  %tbl_size.i.i121 = load i64, ptr %tbl_size_ptr.i.i27, align 4
  %offset_tbl.i.i122 = load ptr, ptr %offset_tbl_ptr.i.i28, align 8
  %product.i.i.i123 = mul i64 %hash_coef.i.i120, 5693646204635713916
  %shifted.i.i.i124 = lshr i64 %product.i.i.i123, 32
  %xored.i.i.i125 = xor i64 %shifted.i.i.i124, %product.i.i.i123
  %hash.i.i.i126 = and i64 %xored.i.i.i125, %tbl_size.i.i121
  %offset_ptr.i.i127 = getelementptr i32, ptr %offset_tbl.i.i122, i64 %hash.i.i.i126
  %offset.i.i115 = load i32, ptr %offset_ptr.i.i127, align 4
  %36 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr nonnull @ZipIterable2)
  %37 = getelementptr i8, ptr %result.i39, i64 56
  store ptr %.fca.0.extract9, ptr %37, align 8
  %38 = getelementptr i8, ptr %result.i39, i64 64
  store ptr %.fca.1.extract11, ptr %38, align 8
  %39 = getelementptr i8, ptr %result.i39, i64 72
  store ptr %.fca.2.extract13, ptr %39, align 8
  %40 = getelementptr i8, ptr %result.i39, i64 80
  store i32 %offset.i.i115, ptr %40, align 4
  ret { ptr, ptr, ptr, i32 } %24
}

define { ptr, ptr, ptr, i32 } @Iterable2_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i26 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract17)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract17, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = tail call ptr %8(ptr %.fca.1.extract19)
  %10 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract9)
  %11 = sext i32 %.fca.3.extract15 to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract9, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = tail call ptr %13(ptr %.fca.1.extract11)
  %result.i = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %15 = getelementptr i8, ptr %result.i, i64 16
  store ptr %14, ptr %15, align 8
  %16 = getelementptr i8, ptr %result.i, i64 8
  store ptr %9, ptr %16, align 8
  %17 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %17, align 8
  %18 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @Pair, ptr %result.i, align 8
  %result.i39 = tail call noalias dereferenceable_or_null(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nonnull @current_ptr) #29
  store ptr %9, ptr %result.i39, align 8
  %19 = getelementptr i8, ptr %result.i39, i64 8
  store ptr %14, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i39, i64 16
  store ptr %result.i, ptr %20, align 8
  %21 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i39)
  %22 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i39, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr undef, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 9, 3
  %25 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract17)
  %26 = load ptr, ptr %7, align 8
  %27 = tail call ptr %26(ptr %.fca.1.extract19)
  %28 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract9)
  %29 = load ptr, ptr %12, align 8
  %30 = tail call ptr %29(ptr %.fca.1.extract11)
  %31 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr nonnull @ProductIterable2)
  %hash_coef.i.i148 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i149 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i150 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i151 = mul i64 %hash_coef.i.i148, 5693646204635713916
  %shifted.i.i.i152 = lshr i64 %product.i.i.i151, 32
  %xored.i.i.i153 = xor i64 %shifted.i.i.i152, %product.i.i.i151
  %hash.i.i.i154 = and i64 %xored.i.i.i153, %tbl_size.i.i149
  %offset_ptr.i.i155 = getelementptr i32, ptr %offset_tbl.i.i150, i64 %hash.i.i.i154
  %offset.i.i142 = load i32, ptr %offset_ptr.i.i155, align 4
  %32 = getelementptr i8, ptr %result.i39, i64 24
  store ptr %.fca.0.extract17, ptr %32, align 8
  %33 = getelementptr i8, ptr %result.i39, i64 32
  store ptr %.fca.1.extract19, ptr %33, align 8
  %34 = getelementptr i8, ptr %result.i39, i64 40
  store ptr %.fca.2.extract21, ptr %34, align 8
  %35 = getelementptr i8, ptr %result.i39, i64 48
  store i32 %offset.i.i142, ptr %35, align 4
  %hash_coef.i.i120 = load i64, ptr %hash_coef_ptr.i.i26, align 4
  %tbl_size.i.i121 = load i64, ptr %tbl_size_ptr.i.i27, align 4
  %offset_tbl.i.i122 = load ptr, ptr %offset_tbl_ptr.i.i28, align 8
  %product.i.i.i123 = mul i64 %hash_coef.i.i120, 5693646204635713916
  %shifted.i.i.i124 = lshr i64 %product.i.i.i123, 32
  %xored.i.i.i125 = xor i64 %shifted.i.i.i124, %product.i.i.i123
  %hash.i.i.i126 = and i64 %xored.i.i.i125, %tbl_size.i.i121
  %offset_ptr.i.i127 = getelementptr i32, ptr %offset_tbl.i.i122, i64 %hash.i.i.i126
  %offset.i.i115 = load i32, ptr %offset_ptr.i.i127, align 4
  %36 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr nonnull @ProductIterable2)
  %37 = getelementptr i8, ptr %result.i39, i64 56
  store ptr %.fca.0.extract9, ptr %37, align 8
  %38 = getelementptr i8, ptr %result.i39, i64 64
  store ptr %.fca.1.extract11, ptr %38, align 8
  %39 = getelementptr i8, ptr %result.i39, i64 72
  store ptr %.fca.2.extract13, ptr %39, align 8
  %40 = getelementptr i8, ptr %result.i39, i64 80
  store i32 %offset.i.i115, ptr %40, align 4
  ret { ptr, ptr, ptr, i32 } %24
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_ProductIterable2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ProductIterable2_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 7827074759551300494
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract9)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract3, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract5, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %16)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4
  %17 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract9)
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %25)
  ret void
}

define { ptr, ptr, ptr, i32 } @ProductIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract43 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 7827074759551300494
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract41, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract43)
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract39 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i50 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i51 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i52 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i53 = load i64, ptr %hash_coef_ptr.i.i50, align 4
  %tbl_size.i.i54 = load i64, ptr %tbl_size_ptr.i.i51, align 4
  %offset_tbl.i.i55 = load ptr, ptr %offset_tbl_ptr.i.i52, align 8
  %product.i.i.i56 = mul i64 %hash_coef.i.i53, 5693646204635713916
  %shifted.i.i.i57 = lshr i64 %product.i.i.i56, 32
  %xored.i.i.i58 = xor i64 %shifted.i.i.i57, %product.i.i.i56
  %hash.i.i.i59 = and i64 %xored.i.i.i58, %tbl_size.i.i54
  %offset_ptr.i.i60 = getelementptr i32, ptr %offset_tbl.i.i55, i64 %hash.i.i.i59
  %offset.i.i61 = load i32, ptr %offset_ptr.i.i60, align 4
  %eq.i = icmp eq i32 %.fca.3.extract39, %offset.i.i61
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract35, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract37, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract39, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %17 = load ptr, ptr %7, align 8
  %18 = tail call ptr %17(ptr %.fca.1.extract43)
  %19 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %20 = getelementptr i8, ptr %7, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call ptr %21(ptr %.fca.1.extract43)
  %23 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %24 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract33)
  %25 = sext i32 %.fca.3.extract39 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract33, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr %28({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %30 = call { ptr, ptr, ptr, i32 } %29({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %31 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %32 = getelementptr i8, ptr %7, i64 32
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract43)
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %hash_coef_ptr.i.i78 = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i79 = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i80 = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i81 = load i64, ptr %hash_coef_ptr.i.i78, align 4
  %tbl_size.i.i82 = load i64, ptr %tbl_size_ptr.i.i79, align 4
  %offset_tbl.i.i83 = load ptr, ptr %offset_tbl_ptr.i.i80, align 8
  %product.i.i.i84 = mul i64 %hash_coef.i.i81, 5693646204635713916
  %shifted.i.i.i85 = lshr i64 %product.i.i.i84, 32
  %xored.i.i.i86 = xor i64 %shifted.i.i.i85, %product.i.i.i84
  %hash.i.i.i87 = and i64 %xored.i.i.i86, %tbl_size.i.i82
  %offset_ptr.i.i88 = getelementptr i32, ptr %offset_tbl.i.i83, i64 %hash.i.i.i87
  %offset.i.i89 = load i32, ptr %offset_ptr.i.i88, align 4
  %eq.i92 = icmp eq i32 %.fca.3.extract23, %offset.i.i89
  call void @llvm.assume(i1 %eq.i92) #30
  %36 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %37 = load ptr, ptr %7, align 8
  %38 = call ptr %37(ptr %.fca.1.extract43)
  %39 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %40 = load ptr, ptr %20, align 8
  %41 = call ptr %40(ptr %.fca.1.extract43)
  %result.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %42 = getelementptr i8, ptr %result.i, i64 16
  store ptr %41, ptr %42, align 8
  %43 = getelementptr i8, ptr %result.i, i64 8
  store ptr %38, ptr %43, align 8
  %44 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @Pair, ptr %result.i, align 8
  %result.i93 = call noalias dereferenceable_or_null(152) ptr @bump_malloc_inner(i64 noundef 152, ptr nonnull @current_ptr) #29
  store ptr %38, ptr %result.i93, align 8
  %46 = getelementptr i8, ptr %result.i93, i64 8
  store ptr %41, ptr %46, align 8
  %47 = getelementptr i8, ptr %result.i93, i64 16
  store ptr %result.i, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i93)
  %49 = alloca { ptr, ptr, ptr, i32 }, align 8
  %50 = getelementptr inbounds i8, ptr %49, i64 8
  %51 = getelementptr inbounds i8, ptr %49, i64 24
  store ptr @ProductIterator2, ptr %49, align 8
  store ptr %result.i93, ptr %50, align 8
  store i32 9, ptr %51, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %49)
  %53 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %54 = load ptr, ptr %8, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr, ptr, ptr, i32 } %55(ptr %.fca.1.extract43)
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %56, 3
  %hash_coef_ptr.i.i95 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i96 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i97 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i98 = load i64, ptr %hash_coef_ptr.i.i95, align 4
  %tbl_size.i.i99 = load i64, ptr %tbl_size_ptr.i.i96, align 4
  %offset_tbl.i.i100 = load ptr, ptr %offset_tbl_ptr.i.i97, align 8
  %product.i.i.i101 = mul i64 %hash_coef.i.i98, 5693646204635713916
  %shifted.i.i.i102 = lshr i64 %product.i.i.i101, 32
  %xored.i.i.i103 = xor i64 %shifted.i.i.i102, %product.i.i.i101
  %hash.i.i.i104 = and i64 %xored.i.i.i103, %tbl_size.i.i99
  %offset_ptr.i.i105 = getelementptr i32, ptr %offset_tbl.i.i100, i64 %hash.i.i.i104
  %offset.i.i106 = load i32, ptr %offset_ptr.i.i105, align 4
  %eq.i109 = icmp eq i32 %.fca.3.extract15, %offset.i.i106
  call void @llvm.assume(i1 %eq.i109) #30
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.1.extract11, 1
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.2.extract13, 2
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %.fca.3.extract15, 3
  %61 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %62 = load ptr, ptr %7, align 8
  %63 = call ptr %62(ptr %.fca.1.extract43)
  %64 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %65 = load ptr, ptr %20, align 8
  %66 = call ptr %65(ptr %.fca.1.extract43)
  %67 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %68 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract9)
  %69 = sext i32 %.fca.3.extract15 to i64
  %70 = getelementptr ptr, ptr %.fca.0.extract9, i64 %69
  %71 = getelementptr i8, ptr %70, i64 8
  %72 = load ptr, ptr %71, align 8
  %73 = call ptr %72({ ptr, ptr, ptr, i32 } %60, ptr nonnull %4)
  %74 = call { ptr, ptr, ptr, i32 } %73({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr nonnull %4)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %74, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %74, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %74, 2
  %hash_coef_ptr.i.i111 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i112 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i113 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %75 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %76 = load ptr, ptr %32, align 8
  %77 = load ptr, ptr %76, align 8
  %78 = call { ptr, ptr, ptr, i32 } %77(ptr %.fca.1.extract43)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %78, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %78, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %78, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %78, 3
  %hash_coef_ptr.i.i125 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i126 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i127 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i128 = load i64, ptr %hash_coef_ptr.i.i125, align 4
  %tbl_size.i.i129 = load i64, ptr %tbl_size_ptr.i.i126, align 4
  %offset_tbl.i.i130 = load ptr, ptr %offset_tbl_ptr.i.i127, align 8
  %product.i.i.i131 = mul i64 %hash_coef.i.i128, 5693646204635713916
  %shifted.i.i.i132 = lshr i64 %product.i.i.i131, 32
  %xored.i.i.i133 = xor i64 %shifted.i.i.i132, %product.i.i.i131
  %hash.i.i.i134 = and i64 %xored.i.i.i133, %tbl_size.i.i129
  %offset_ptr.i.i135 = getelementptr i32, ptr %offset_tbl.i.i130, i64 %hash.i.i.i134
  %offset.i.i136 = load i32, ptr %offset_ptr.i.i135, align 4
  %eq.i139 = icmp eq i32 %.fca.3.extract, %offset.i.i136
  call void @llvm.assume(i1 %eq.i139) #30
  %hash_coef.i.i144 = load i64, ptr %hash_coef_ptr.i.i111, align 4
  %tbl_size.i.i145 = load i64, ptr %tbl_size_ptr.i.i112, align 4
  %offset_tbl.i.i146 = load ptr, ptr %offset_tbl_ptr.i.i113, align 8
  %product.i.i.i147 = mul i64 %hash_coef.i.i144, 4189192806087951739
  %shifted.i.i.i148 = lshr i64 %product.i.i.i147, 32
  %xored.i.i.i149 = xor i64 %shifted.i.i.i148, %product.i.i.i147
  %hash.i.i.i150 = and i64 %xored.i.i.i149, %tbl_size.i.i145
  %offset_ptr.i.i151 = getelementptr i32, ptr %offset_tbl.i.i146, i64 %hash.i.i.i150
  %offset.i.i152 = load i32, ptr %offset_ptr.i.i151, align 4
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %.fca.1.extract3, 1
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %.fca.2.extract5, 2
  %82 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 %offset.i.i152, 3
  %83 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %.fca.1.extract, 1
  %85 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %.fca.2.extract, 2
  %86 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %.fca.3.extract, 3
  %87 = load ptr, ptr %49, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %87, 0
  %89 = load ptr, ptr %50, align 8
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, ptr %89, 1
  %91 = getelementptr inbounds i8, ptr %49, i64 16
  %92 = load ptr, ptr %91, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %90, ptr %92, 2
  %94 = load i32, ptr %51, align 8
  %95 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 %94, 3
  %96 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %97 = load ptr, ptr %7, align 8
  %98 = call ptr %97(ptr %.fca.1.extract43)
  %99 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract41)
  %100 = load ptr, ptr %20, align 8
  %101 = call ptr %100(ptr %.fca.1.extract43)
  %result.i168 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %102 = getelementptr i8, ptr %result.i168, i64 8
  store ptr %98, ptr %102, align 8
  %103 = getelementptr i8, ptr %result.i168, i64 16
  store ptr null, ptr %103, align 8
  %104 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i168)
  store ptr @Iterator2, ptr %result.i168, align 8
  %result.i169 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %105 = getelementptr i8, ptr %result.i169, i64 8
  store ptr %101, ptr %105, align 8
  %106 = getelementptr i8, ptr %result.i169, i64 16
  store ptr null, ptr %106, align 8
  %107 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i169)
  store ptr @Iterable2, ptr %result.i169, align 8
  %108 = alloca [2 x ptr], align 8
  store ptr %result.i168, ptr %108, align 8
  %109 = getelementptr inbounds i8, ptr %108, i64 8
  store ptr %result.i169, ptr %109, align 8
  %110 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %108)
  %111 = call ptr @llvm.invariant.start.p0(i64 112, ptr %87)
  %112 = sext i32 %94 to i64
  %113 = getelementptr ptr, ptr %87, i64 %112
  %114 = getelementptr i8, ptr %113, i64 56
  %115 = load ptr, ptr %114, align 8
  %116 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract1, ptr %116, align 8
  %117 = getelementptr inbounds i8, ptr %116, i64 8
  store ptr %.fca.0.extract, ptr %117, align 8
  %118 = call ptr %115({ ptr, ptr, ptr, i32 } %95, ptr nonnull %116)
  call void %118({ ptr, ptr, ptr, i32 } %95, { ptr, ptr, ptr, i32 } %95, ptr nonnull %108, { ptr, ptr, ptr, i32 } %82, { ptr, ptr, ptr, i32 } %86)
  %119 = load ptr, ptr %49, align 8
  %120 = load ptr, ptr %50, align 8
  %121 = load ptr, ptr %91, align 8
  %hash_coef_ptr.i.i171 = getelementptr i8, ptr %119, i64 8
  %tbl_size_ptr.i.i172 = getelementptr i8, ptr %119, i64 16
  %offset_tbl_ptr.i.i173 = getelementptr i8, ptr %119, i64 40
  %hash_coef.i.i174 = load i64, ptr %hash_coef_ptr.i.i171, align 4
  %tbl_size.i.i175 = load i64, ptr %tbl_size_ptr.i.i172, align 4
  %offset_tbl.i.i176 = load ptr, ptr %offset_tbl_ptr.i.i173, align 8
  %product.i.i.i177 = mul i64 %hash_coef.i.i174, 4189192806087951739
  %shifted.i.i.i178 = lshr i64 %product.i.i.i177, 32
  %xored.i.i.i179 = xor i64 %shifted.i.i.i178, %product.i.i.i177
  %hash.i.i.i180 = and i64 %xored.i.i.i179, %tbl_size.i.i175
  %offset_ptr.i.i181 = getelementptr i32, ptr %offset_tbl.i.i176, i64 %hash.i.i.i180
  %offset.i.i182 = load i32, ptr %offset_ptr.i.i181, align 4
  %122 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %123 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %120, 1
  %124 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %121, 2
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %offset.i.i182, 3
  ret { ptr, ptr, ptr, i32 } %125
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_ProductIterator2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 152, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator2_B_init_first_iteratorIterator2T_second_iterableIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ProductIterator2_init_first_iteratorIterator2T_second_iterableIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 4440657219728359865
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i44 = getelementptr i8, ptr %.fca.0.extract27, i64 8
  %tbl_size_ptr.i.i45 = getelementptr i8, ptr %.fca.0.extract27, i64 16
  %offset_tbl_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract27, i64 40
  %hash_coef.i.i47 = load i64, ptr %hash_coef_ptr.i.i44, align 4
  %tbl_size.i.i48 = load i64, ptr %tbl_size_ptr.i.i45, align 4
  %offset_tbl.i.i49 = load ptr, ptr %offset_tbl_ptr.i.i46, align 8
  %product.i.i.i50 = mul i64 %hash_coef.i.i47, 4189192806087951739
  %shifted.i.i.i51 = lshr i64 %product.i.i.i50, 32
  %xored.i.i.i52 = xor i64 %shifted.i.i.i51, %product.i.i.i50
  %hash.i.i.i53 = and i64 %xored.i.i.i52, %tbl_size.i.i48
  %offset_ptr.i.i54 = getelementptr i32, ptr %offset_tbl.i.i49, i64 %hash.i.i.i53
  %offset.i.i69 = load i32, ptr %offset_ptr.i.i54, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract35, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract29, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract31, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i69, 3
  tail call void %13(ptr %.fca.1.extract37, { ptr, ptr, ptr, i32 } %17)
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i72 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i.i73 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i.i74 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i.i75 = load i64, ptr %hash_coef_ptr.i.i72, align 4
  %tbl_size.i.i76 = load i64, ptr %tbl_size_ptr.i.i73, align 4
  %offset_tbl.i.i77 = load ptr, ptr %offset_tbl_ptr.i.i74, align 8
  %product.i.i.i78 = mul i64 %hash_coef.i.i75, 5693646204635713916
  %shifted.i.i.i79 = lshr i64 %product.i.i.i78, 32
  %xored.i.i.i80 = xor i64 %shifted.i.i.i79, %product.i.i.i78
  %hash.i.i.i81 = and i64 %xored.i.i.i80, %tbl_size.i.i76
  %offset_ptr.i.i82 = getelementptr i32, ptr %offset_tbl.i.i77, i64 %hash.i.i.i81
  %offset.i.i97 = load i32, ptr %offset_ptr.i.i82, align 4
  %18 = tail call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %19 = getelementptr i8, ptr %9, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract21, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract23, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i97, 3
  tail call void %22(ptr %.fca.1.extract37, { ptr, ptr, ptr, i32 } %26)
  %27 = tail call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %28 = load ptr, ptr %19, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call { ptr, ptr, ptr, i32 } %29(ptr %.fca.1.extract37)
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %30, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %30, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %30, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %30, 3
  %hash_coef_ptr.i.i100 = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i101 = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i102 = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i103 = load i64, ptr %hash_coef_ptr.i.i100, align 4
  %tbl_size.i.i104 = load i64, ptr %tbl_size_ptr.i.i101, align 4
  %offset_tbl.i.i105 = load ptr, ptr %offset_tbl_ptr.i.i102, align 8
  %product.i.i.i106 = mul i64 %hash_coef.i.i103, 5693646204635713916
  %shifted.i.i.i107 = lshr i64 %product.i.i.i106, 32
  %xored.i.i.i108 = xor i64 %shifted.i.i.i107, %product.i.i.i106
  %hash.i.i.i109 = and i64 %xored.i.i.i108, %tbl_size.i.i104
  %offset_ptr.i.i110 = getelementptr i32, ptr %offset_tbl.i.i105, i64 %hash.i.i.i109
  %offset.i.i111 = load i32, ptr %offset_ptr.i.i110, align 4
  %eq.i = icmp eq i32 %.fca.3.extract17, %offset.i.i111
  tail call void @llvm.assume(i1 %eq.i) #30
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract13, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract15, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %.fca.3.extract17, 3
  %35 = tail call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %36 = load ptr, ptr %9, align 8
  %37 = tail call ptr %36(ptr %.fca.1.extract37)
  %38 = tail call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %39 = getelementptr i8, ptr %9, i64 8
  %40 = load ptr, ptr %39, align 8
  %41 = tail call ptr %40(ptr %.fca.1.extract37)
  %42 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %43 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract11)
  %44 = sext i32 %.fca.3.extract17 to i64
  %45 = getelementptr ptr, ptr %.fca.0.extract11, i64 %44
  %46 = getelementptr i8, ptr %45, i64 8
  %47 = load ptr, ptr %46, align 8
  %48 = call ptr %47({ ptr, ptr, ptr, i32 } %34, ptr nonnull %6)
  %49 = call { ptr, ptr, ptr, i32 } %48({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull %6)
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %hash_coef_ptr.i.i114 = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i115 = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i116 = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i117 = load i64, ptr %hash_coef_ptr.i.i114, align 4
  %tbl_size.i.i118 = load i64, ptr %tbl_size_ptr.i.i115, align 4
  %offset_tbl.i.i119 = load ptr, ptr %offset_tbl_ptr.i.i116, align 8
  %product.i.i.i120 = mul i64 %hash_coef.i.i117, 4189192806087951739
  %shifted.i.i.i121 = lshr i64 %product.i.i.i120, 32
  %xored.i.i.i122 = xor i64 %shifted.i.i.i121, %product.i.i.i120
  %hash.i.i.i123 = and i64 %xored.i.i.i122, %tbl_size.i.i118
  %offset_ptr.i.i124 = getelementptr i32, ptr %offset_tbl.i.i119, i64 %hash.i.i.i123
  %offset.i.i139 = load i32, ptr %offset_ptr.i.i124, align 4
  %50 = call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %51 = getelementptr i8, ptr %9, i64 32
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr i8, ptr %52, i64 8
  %54 = load ptr, ptr %53, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.1.extract5, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.2.extract7, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %offset.i.i139, 3
  call void %54(ptr %.fca.1.extract37, { ptr, ptr, ptr, i32 } %58)
  %59 = call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %60 = load ptr, ptr %10, align 8
  %61 = load ptr, ptr %60, align 8
  %62 = call { ptr, ptr, ptr, i32 } %61(ptr %.fca.1.extract37)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %62, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %62, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %62, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %62, 3
  %hash_coef_ptr.i.i142 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i143 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i144 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i145 = load i64, ptr %hash_coef_ptr.i.i142, align 4
  %tbl_size.i.i146 = load i64, ptr %tbl_size_ptr.i.i143, align 4
  %offset_tbl.i.i147 = load ptr, ptr %offset_tbl_ptr.i.i144, align 8
  %product.i.i.i148 = mul i64 %hash_coef.i.i145, 4189192806087951739
  %shifted.i.i.i149 = lshr i64 %product.i.i.i148, 32
  %xored.i.i.i150 = xor i64 %shifted.i.i.i149, %product.i.i.i148
  %hash.i.i.i151 = and i64 %xored.i.i.i150, %tbl_size.i.i146
  %offset_ptr.i.i152 = getelementptr i32, ptr %offset_tbl.i.i147, i64 %hash.i.i.i151
  %offset.i.i153 = load i32, ptr %offset_ptr.i.i152, align 4
  %eq.i156 = icmp eq i32 %.fca.3.extract, %offset.i.i153
  call void @llvm.assume(i1 %eq.i156) #30
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %.fca.1.extract2, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %.fca.2.extract, 2
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %.fca.3.extract, 3
  %67 = call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %68 = load ptr, ptr %9, align 8
  %69 = call ptr %68(ptr %.fca.1.extract37)
  %70 = call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %71 = load ptr, ptr %39, align 8
  %72 = call ptr %71(ptr %.fca.1.extract37)
  %73 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %6)
  %74 = call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract1)
  %75 = sext i32 %.fca.3.extract to i64
  %76 = getelementptr ptr, ptr %.fca.0.extract1, i64 %75
  %77 = getelementptr i8, ptr %76, i64 8
  %78 = load ptr, ptr %77, align 8
  %79 = call ptr %78({ ptr, ptr, ptr, i32 } %66, ptr nonnull %6)
  %80 = call { ptr, i160 } %79({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr nonnull %6)
  %81 = call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract35)
  %82 = getelementptr i8, ptr %9, i64 48
  %83 = load ptr, ptr %82, align 8
  %84 = getelementptr i8, ptr %83, i64 8
  %85 = load ptr, ptr %84, align 8
  call void %85(ptr %.fca.1.extract37, { ptr, i160 } %80)
  ret void
}

define { ptr, i160 } @ProductIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 4440657219728359865
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 112, ptr %.fca.0.extract10)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract10, i64 %7
  %9 = getelementptr i8, ptr %8, i64 48
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr, i160 } %11(ptr %.fca.1.extract12)
  %.sroa.0.0233 = extractvalue { ptr, i160 } %12, 0
  %13 = icmp ne ptr %.sroa.0.0233, @nil_typ
  %14 = icmp ne ptr %.sroa.0.0233, null
  %.not73234 = and i1 %13, %14
  br i1 %.not73234, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %3
  %15 = tail call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %16 = getelementptr i8, ptr %8, i64 32
  %17 = getelementptr i8, ptr %8, i64 8
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = getelementptr i8, ptr %8, i64 40
  br label %20

20:                                               ; preds = %.lr.ph, %46
  %.pn235 = phi { ptr, i160 } [ %12, %.lr.ph ], [ %105, %46 ]
  %21 = load ptr, ptr %16, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = call { ptr, ptr, ptr, i32 } %22(ptr %.fca.1.extract12)
  %.fca.0.extract60 = extractvalue { ptr, ptr, ptr, i32 } %23, 0
  %.fca.1.extract62 = extractvalue { ptr, ptr, ptr, i32 } %23, 1
  %.fca.2.extract64 = extractvalue { ptr, ptr, ptr, i32 } %23, 2
  %.fca.3.extract66 = extractvalue { ptr, ptr, ptr, i32 } %23, 3
  %hash_coef_ptr.i.i75 = getelementptr i8, ptr %.fca.0.extract60, i64 8
  %tbl_size_ptr.i.i76 = getelementptr i8, ptr %.fca.0.extract60, i64 16
  %offset_tbl_ptr.i.i77 = getelementptr i8, ptr %.fca.0.extract60, i64 40
  %hash_coef.i.i78 = load i64, ptr %hash_coef_ptr.i.i75, align 4
  %tbl_size.i.i79 = load i64, ptr %tbl_size_ptr.i.i76, align 4
  %offset_tbl.i.i80 = load ptr, ptr %offset_tbl_ptr.i.i77, align 8
  %product.i.i.i81 = mul i64 %hash_coef.i.i78, 4189192806087951739
  %shifted.i.i.i82 = lshr i64 %product.i.i.i81, 32
  %xored.i.i.i83 = xor i64 %shifted.i.i.i82, %product.i.i.i81
  %hash.i.i.i84 = and i64 %xored.i.i.i83, %tbl_size.i.i79
  %offset_ptr.i.i85 = getelementptr i32, ptr %offset_tbl.i.i80, i64 %hash.i.i.i84
  %offset.i.i86 = load i32, ptr %offset_ptr.i.i85, align 4
  %eq.i = icmp eq i32 %.fca.3.extract66, %offset.i.i86
  call void @llvm.assume(i1 %eq.i) #30
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract60, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract62, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract64, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %.fca.3.extract66, 3
  %28 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %29 = load ptr, ptr %8, align 8
  %30 = call ptr %29(ptr %.fca.1.extract12)
  %31 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %32 = load ptr, ptr %17, align 8
  %33 = call ptr %32(ptr %.fca.1.extract12)
  %34 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %35 = call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract60)
  %36 = sext i32 %.fca.3.extract66 to i64
  %37 = getelementptr ptr, ptr %.fca.0.extract60, i64 %36
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = call ptr %39({ ptr, ptr, ptr, i32 } %27, ptr nonnull %4)
  %41 = call { ptr, i160 } %40({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull %4)
  %.fca.0.extract54 = extractvalue { ptr, i160 } %41, 0
  %42 = icmp eq ptr %.fca.0.extract54, @nil_typ
  %43 = icmp eq ptr %.fca.0.extract54, null
  %44 = or i1 %42, %43
  %45 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  br i1 %44, label %46, label %108

46:                                               ; preds = %20
  %47 = load ptr, ptr %18, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %.fca.1.extract12)
  %.fca.0.extract40 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract44 = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.3.extract46 = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %hash_coef_ptr.i.i89 = getelementptr i8, ptr %.fca.0.extract40, i64 8
  %tbl_size_ptr.i.i90 = getelementptr i8, ptr %.fca.0.extract40, i64 16
  %offset_tbl_ptr.i.i91 = getelementptr i8, ptr %.fca.0.extract40, i64 40
  %hash_coef.i.i92 = load i64, ptr %hash_coef_ptr.i.i89, align 4
  %tbl_size.i.i93 = load i64, ptr %tbl_size_ptr.i.i90, align 4
  %offset_tbl.i.i94 = load ptr, ptr %offset_tbl_ptr.i.i91, align 8
  %product.i.i.i95 = mul i64 %hash_coef.i.i92, 4189192806087951739
  %shifted.i.i.i96 = lshr i64 %product.i.i.i95, 32
  %xored.i.i.i97 = xor i64 %shifted.i.i.i96, %product.i.i.i95
  %hash.i.i.i98 = and i64 %xored.i.i.i97, %tbl_size.i.i93
  %offset_ptr.i.i99 = getelementptr i32, ptr %offset_tbl.i.i94, i64 %hash.i.i.i98
  %offset.i.i100 = load i32, ptr %offset_ptr.i.i99, align 4
  %eq.i103 = icmp eq i32 %.fca.3.extract46, %offset.i.i100
  call void @llvm.assume(i1 %eq.i103) #30
  %50 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract40, 0
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %.fca.1.extract42, 1
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %.fca.2.extract44, 2
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %.fca.3.extract46, 3
  %54 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %55 = load ptr, ptr %8, align 8
  %56 = call ptr %55(ptr %.fca.1.extract12)
  %57 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %58 = load ptr, ptr %17, align 8
  %59 = call ptr %58(ptr %.fca.1.extract12)
  %60 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %61 = call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract40)
  %62 = sext i32 %.fca.3.extract46 to i64
  %63 = getelementptr ptr, ptr %.fca.0.extract40, i64 %62
  %64 = getelementptr i8, ptr %63, i64 8
  %65 = load ptr, ptr %64, align 8
  %66 = call ptr %65({ ptr, ptr, ptr, i32 } %53, ptr nonnull %4)
  %67 = call { ptr, i160 } %66({ ptr, ptr, ptr, i32 } %53, { ptr, ptr, ptr, i32 } %53, ptr nonnull %4)
  %68 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %69 = load ptr, ptr %9, align 8
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = load ptr, ptr %70, align 8
  call void %71(ptr %.fca.1.extract12, { ptr, i160 } %67)
  %72 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %73 = load ptr, ptr %19, align 8
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %.fca.1.extract12)
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %75, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %75, 1
  %.fca.2.extract30 = extractvalue { ptr, ptr, ptr, i32 } %75, 2
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %75, 3
  %hash_coef_ptr.i.i105 = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i106 = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i107 = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i108 = load i64, ptr %hash_coef_ptr.i.i105, align 4
  %tbl_size.i.i109 = load i64, ptr %tbl_size_ptr.i.i106, align 4
  %offset_tbl.i.i110 = load ptr, ptr %offset_tbl_ptr.i.i107, align 8
  %product.i.i.i111 = mul i64 %hash_coef.i.i108, 5693646204635713916
  %shifted.i.i.i112 = lshr i64 %product.i.i.i111, 32
  %xored.i.i.i113 = xor i64 %shifted.i.i.i112, %product.i.i.i111
  %hash.i.i.i114 = and i64 %xored.i.i.i113, %tbl_size.i.i109
  %offset_ptr.i.i115 = getelementptr i32, ptr %offset_tbl.i.i110, i64 %hash.i.i.i114
  %offset.i.i116 = load i32, ptr %offset_ptr.i.i115, align 4
  %eq.i119 = icmp eq i32 %.fca.3.extract32, %offset.i.i116
  call void @llvm.assume(i1 %eq.i119) #30
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.fca.1.extract28, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.fca.2.extract30, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %.fca.3.extract32, 3
  %80 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %81 = load ptr, ptr %8, align 8
  %82 = call ptr %81(ptr %.fca.1.extract12)
  %83 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %84 = load ptr, ptr %17, align 8
  %85 = call ptr %84(ptr %.fca.1.extract12)
  %86 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %87 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract26)
  %88 = sext i32 %.fca.3.extract32 to i64
  %89 = getelementptr ptr, ptr %.fca.0.extract26, i64 %88
  %90 = getelementptr i8, ptr %89, i64 8
  %91 = load ptr, ptr %90, align 8
  %92 = call ptr %91({ ptr, ptr, ptr, i32 } %79, ptr nonnull %4)
  %93 = call { ptr, ptr, ptr, i32 } %92({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull %4)
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %93, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %93, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %93, 2
  %hash_coef_ptr.i.i121 = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i.i122 = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i.i123 = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i.i124 = load i64, ptr %hash_coef_ptr.i.i121, align 4
  %tbl_size.i.i125 = load i64, ptr %tbl_size_ptr.i.i122, align 4
  %offset_tbl.i.i126 = load ptr, ptr %offset_tbl_ptr.i.i123, align 8
  %product.i.i.i127 = mul i64 %hash_coef.i.i124, 4189192806087951739
  %shifted.i.i.i128 = lshr i64 %product.i.i.i127, 32
  %xored.i.i.i129 = xor i64 %shifted.i.i.i128, %product.i.i.i127
  %hash.i.i.i130 = and i64 %xored.i.i.i129, %tbl_size.i.i125
  %offset_ptr.i.i131 = getelementptr i32, ptr %offset_tbl.i.i126, i64 %hash.i.i.i130
  %offset.i.i146 = load i32, ptr %offset_ptr.i.i131, align 4
  %94 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %95 = load ptr, ptr %16, align 8
  %96 = getelementptr i8, ptr %95, i64 8
  %97 = load ptr, ptr %96, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %99 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %.fca.1.extract20, 1
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, ptr %.fca.2.extract22, 2
  %101 = insertvalue { ptr, ptr, ptr, i32 } %100, i32 %offset.i.i146, 3
  call void %97(ptr %.fca.1.extract12, { ptr, ptr, ptr, i32 } %101)
  %102 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %103 = load ptr, ptr %9, align 8
  %104 = load ptr, ptr %103, align 8
  %105 = call { ptr, i160 } %104(ptr %.fca.1.extract12)
  %.sroa.0.0 = extractvalue { ptr, i160 } %105, 0
  %106 = icmp ne ptr %.sroa.0.0, @nil_typ
  %107 = icmp ne ptr %.sroa.0.0, null
  %.not73 = and i1 %106, %107
  br i1 %.not73, label %20, label %.loopexit

108:                                              ; preds = %20
  %109 = load ptr, ptr %8, align 8
  %110 = call ptr %109(ptr %.fca.1.extract12)
  %111 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %112 = load ptr, ptr %17, align 8
  %113 = call ptr %112(ptr %.fca.1.extract12)
  %114 = load ptr, ptr %110, align 8
  %115 = getelementptr i8, ptr %114, i64 48
  %116 = load ptr, ptr %115, align 8
  %117 = call { i64, i64 } %116(ptr nonnull %110)
  %118 = extractvalue { i64, i64 } %117, 0
  %119 = extractvalue { i64, i64 } %117, 1
  %120 = urem i64 16, %119
  %121 = icmp eq i64 %120, 0
  %122 = sub i64 %119, %120
  %123 = select i1 %121, i64 0, i64 %122
  %124 = add i64 %118, 16
  %125 = add i64 %124, %123
  %126 = load ptr, ptr %113, align 8
  %127 = getelementptr i8, ptr %126, i64 48
  %128 = load ptr, ptr %127, align 8
  %129 = call { i64, i64 } %128(ptr nonnull %113)
  %130 = extractvalue { i64, i64 } %129, 0
  %131 = extractvalue { i64, i64 } %129, 1
  %132 = call i64 @llvm.umax.i64(i64 %119, i64 %131)
  %133 = call i64 @llvm.umax.i64(i64 %132, i64 8)
  %134 = urem i64 %125, %131
  %135 = icmp eq i64 %134, 0
  %136 = sub i64 %131, %134
  %137 = select i1 %135, i64 0, i64 %136
  %138 = add i64 %130, %125
  %139 = add i64 %138, %137
  %140 = urem i64 %139, %133
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %133, %140
  %143 = select i1 %141, i64 0, i64 %142
  %144 = add i64 %143, %139
  %result.i = call noalias ptr @bump_malloc_inner(i64 noundef %144, ptr nonnull @current_ptr) #29
  store ptr %110, ptr %result.i, align 8
  %145 = getelementptr i8, ptr %result.i, i64 8
  store ptr %113, ptr %145, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i)
  %147 = getelementptr inbounds i8, ptr %5, i64 8
  %148 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @Pair, ptr %5, align 8
  store ptr %result.i, ptr %147, align 8
  store i32 9, ptr %148, align 8
  %149 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %5)
  %150 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %151 = load ptr, ptr %8, align 8
  %152 = call ptr %151(ptr %.fca.1.extract12)
  %153 = call ptr @llvm.invariant.start.p0(i64 112, ptr nonnull %.fca.0.extract10)
  %154 = load ptr, ptr %17, align 8
  %155 = call ptr %154(ptr %.fca.1.extract12)
  %156 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @Pair)
  %157 = load ptr, ptr %result.i, align 8
  %158 = load ptr, ptr %157, align 8
  %159 = getelementptr i8, ptr %158, i64 48
  %160 = load ptr, ptr %159, align 8
  %161 = call { i64, i64 } %160(ptr nonnull %157)
  %162 = extractvalue { i64, i64 } %161, 1
  %163 = urem i64 16, %162
  %164 = icmp eq i64 %163, 0
  %reass.sub = sub i64 %162, %163
  %165 = add i64 %reass.sub, 16
  %166 = select i1 %164, i64 16, i64 %165
  %167 = getelementptr i8, ptr %result.i, i64 %166
  %168 = load ptr, ptr %result.i, align 8
  %169 = load ptr, ptr %168, align 8
  %170 = getelementptr i8, ptr %169, i64 64
  %171 = load ptr, ptr %170, align 8
  call void %171({ ptr, i160 } %.pn235, ptr nonnull %168, ptr %167)
  %172 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @Pair)
  %173 = load ptr, ptr %result.i, align 8
  %174 = load ptr, ptr %173, align 8
  %175 = getelementptr i8, ptr %174, i64 48
  %176 = load ptr, ptr %175, align 8
  %177 = call { i64, i64 } %176(ptr nonnull %173)
  %178 = extractvalue { i64, i64 } %177, 0
  %179 = extractvalue { i64, i64 } %177, 1
  %180 = urem i64 16, %179
  %181 = icmp eq i64 %180, 0
  %182 = sub i64 %179, %180
  %183 = select i1 %181, i64 0, i64 %182
  %184 = add i64 %178, 16
  %185 = add i64 %184, %183
  %186 = load ptr, ptr %145, align 8
  %187 = load ptr, ptr %186, align 8
  %188 = getelementptr i8, ptr %187, i64 48
  %189 = load ptr, ptr %188, align 8
  %190 = call { i64, i64 } %189(ptr nonnull %186)
  %191 = extractvalue { i64, i64 } %190, 1
  %192 = urem i64 %185, %191
  %193 = icmp eq i64 %192, 0
  %194 = sub i64 %191, %192
  %195 = select i1 %193, i64 0, i64 %194
  %196 = getelementptr i8, ptr %result.i, i64 %185
  %197 = getelementptr i8, ptr %196, i64 %195
  %198 = load ptr, ptr %145, align 8
  %199 = load ptr, ptr %198, align 8
  %200 = getelementptr i8, ptr %199, i64 64
  %201 = load ptr, ptr %200, align 8
  call void %201({ ptr, i160 } %41, ptr nonnull %198, ptr %197)
  %202 = load ptr, ptr %5, align 8
  %203 = load i160, ptr %147, align 8
  br label %.loopexit

.loopexit:                                        ; preds = %46, %3, %108
  %.reg2mem14.sroa.3.0 = phi i160 [ %203, %108 ], [ undef, %3 ], [ undef, %46 ]
  %.reg2mem14.sroa.0.0 = phi ptr [ %202, %108 ], [ @nil_typ, %3 ], [ @nil_typ, %46 ]
  %.reload15.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem14.sroa.0.0, 0
  %.reload15.fca.1.insert = insertvalue { ptr, i160 } %.reload15.fca.0.insert, i160 %.reg2mem14.sroa.3.0, 1
  ret { ptr, i160 } %.reload15.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @ProductIterator2_getter_current_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 4
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_current_first(ptr nocapture writeonly %0, { ptr, i160 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_second_iterable(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_second_iterable(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_second_iterator(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_second_iterator(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_first_iterator(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_first_iterator(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable2_getter_second(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable2_setter_second(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable2_getter_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable2_setter_first(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_ZipIterable2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ZipIterable2_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -3218950579047519815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract9)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract3, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract5, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %16)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4
  %17 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract9)
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %25)
  ret void
}

define { ptr, ptr, ptr, i32 } @ZipIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -3218950579047519815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract57, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract59)
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract51 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract53 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract55 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i66 = getelementptr i8, ptr %.fca.0.extract49, i64 8
  %tbl_size_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract49, i64 16
  %offset_tbl_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract49, i64 40
  %hash_coef.i.i69 = load i64, ptr %hash_coef_ptr.i.i66, align 4
  %tbl_size.i.i70 = load i64, ptr %tbl_size_ptr.i.i67, align 4
  %offset_tbl.i.i71 = load ptr, ptr %offset_tbl_ptr.i.i68, align 8
  %product.i.i.i72 = mul i64 %hash_coef.i.i69, 5693646204635713916
  %shifted.i.i.i73 = lshr i64 %product.i.i.i72, 32
  %xored.i.i.i74 = xor i64 %shifted.i.i.i73, %product.i.i.i72
  %hash.i.i.i75 = and i64 %xored.i.i.i74, %tbl_size.i.i70
  %offset_ptr.i.i76 = getelementptr i32, ptr %offset_tbl.i.i71, i64 %hash.i.i.i75
  %offset.i.i77 = load i32, ptr %offset_ptr.i.i76, align 4
  %eq.i = icmp eq i32 %.fca.3.extract55, %offset.i.i77
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract49, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract51, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract53, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract55, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %17 = load ptr, ptr %7, align 8
  %18 = tail call ptr %17(ptr %.fca.1.extract59)
  %19 = tail call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %20 = getelementptr i8, ptr %7, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call ptr %21(ptr %.fca.1.extract59)
  %23 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %24 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract49)
  %25 = sext i32 %.fca.3.extract55 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract49, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr %28({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %30 = call { ptr, ptr, ptr, i32 } %29({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %31 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %32 = getelementptr i8, ptr %7, i64 32
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr, ptr, ptr, i32 } %34(ptr %.fca.1.extract59)
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %35, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %35, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %35, 2
  %.fca.3.extract39 = extractvalue { ptr, ptr, ptr, i32 } %35, 3
  %hash_coef_ptr.i.i94 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i95 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i96 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i97 = load i64, ptr %hash_coef_ptr.i.i94, align 4
  %tbl_size.i.i98 = load i64, ptr %tbl_size_ptr.i.i95, align 4
  %offset_tbl.i.i99 = load ptr, ptr %offset_tbl_ptr.i.i96, align 8
  %product.i.i.i100 = mul i64 %hash_coef.i.i97, 5693646204635713916
  %shifted.i.i.i101 = lshr i64 %product.i.i.i100, 32
  %xored.i.i.i102 = xor i64 %shifted.i.i.i101, %product.i.i.i100
  %hash.i.i.i103 = and i64 %xored.i.i.i102, %tbl_size.i.i98
  %offset_ptr.i.i104 = getelementptr i32, ptr %offset_tbl.i.i99, i64 %hash.i.i.i103
  %offset.i.i105 = load i32, ptr %offset_ptr.i.i104, align 4
  %eq.i108 = icmp eq i32 %.fca.3.extract39, %offset.i.i105
  call void @llvm.assume(i1 %eq.i108) #30
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract35, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract37, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %.fca.3.extract39, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %41 = load ptr, ptr %7, align 8
  %42 = call ptr %41(ptr %.fca.1.extract59)
  %43 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %44 = load ptr, ptr %20, align 8
  %45 = call ptr %44(ptr %.fca.1.extract59)
  %46 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %47 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract33)
  %48 = sext i32 %.fca.3.extract39 to i64
  %49 = getelementptr ptr, ptr %.fca.0.extract33, i64 %48
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  %52 = call ptr %51({ ptr, ptr, ptr, i32 } %39, ptr nonnull %4)
  %53 = call { ptr, ptr, ptr, i32 } %52({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull %4)
  %54 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %55 = load ptr, ptr %7, align 8
  %56 = call ptr %55(ptr %.fca.1.extract59)
  %57 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %58 = load ptr, ptr %20, align 8
  %59 = call ptr %58(ptr %.fca.1.extract59)
  %result.i = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %60 = getelementptr i8, ptr %result.i, i64 16
  store ptr %59, ptr %60, align 8
  %61 = getelementptr i8, ptr %result.i, i64 8
  store ptr %56, ptr %61, align 8
  %62 = getelementptr i8, ptr %result.i, i64 24
  store ptr null, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i)
  store ptr @Pair, ptr %result.i, align 8
  %result.i123 = call noalias dereferenceable_or_null(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nonnull @current_ptr) #29
  store ptr %56, ptr %result.i123, align 8
  %64 = getelementptr i8, ptr %result.i123, i64 8
  store ptr %59, ptr %64, align 8
  %65 = getelementptr i8, ptr %result.i123, i64 16
  store ptr %result.i, ptr %65, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 24, ptr nonnull %result.i123)
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  %69 = getelementptr inbounds i8, ptr %67, i64 24
  store ptr @ZipIterator2, ptr %67, align 8
  store ptr %result.i123, ptr %68, align 8
  store i32 9, ptr %69, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %67)
  %71 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %72 = load ptr, ptr %8, align 8
  %73 = load ptr, ptr %72, align 8
  %74 = call { ptr, ptr, ptr, i32 } %73(ptr %.fca.1.extract59)
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %74, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %74, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %74, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %74, 3
  %hash_coef_ptr.i.i125 = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i126 = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i127 = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i128 = load i64, ptr %hash_coef_ptr.i.i125, align 4
  %tbl_size.i.i129 = load i64, ptr %tbl_size_ptr.i.i126, align 4
  %offset_tbl.i.i130 = load ptr, ptr %offset_tbl_ptr.i.i127, align 8
  %product.i.i.i131 = mul i64 %hash_coef.i.i128, 5693646204635713916
  %shifted.i.i.i132 = lshr i64 %product.i.i.i131, 32
  %xored.i.i.i133 = xor i64 %shifted.i.i.i132, %product.i.i.i131
  %hash.i.i.i134 = and i64 %xored.i.i.i133, %tbl_size.i.i129
  %offset_ptr.i.i135 = getelementptr i32, ptr %offset_tbl.i.i130, i64 %hash.i.i.i134
  %offset.i.i136 = load i32, ptr %offset_ptr.i.i135, align 4
  %eq.i139 = icmp eq i32 %.fca.3.extract23, %offset.i.i136
  call void @llvm.assume(i1 %eq.i139) #30
  %75 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %.fca.1.extract19, 1
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.fca.2.extract21, 2
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, i32 %.fca.3.extract23, 3
  %79 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %80 = load ptr, ptr %7, align 8
  %81 = call ptr %80(ptr %.fca.1.extract59)
  %82 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %83 = load ptr, ptr %20, align 8
  %84 = call ptr %83(ptr %.fca.1.extract59)
  %85 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %86 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract17)
  %87 = sext i32 %.fca.3.extract23 to i64
  %88 = getelementptr ptr, ptr %.fca.0.extract17, i64 %87
  %89 = getelementptr i8, ptr %88, i64 8
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr %90({ ptr, ptr, ptr, i32 } %78, ptr nonnull %4)
  %92 = call { ptr, ptr, ptr, i32 } %91({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr nonnull %4)
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %92, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %92, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %92, 2
  %hash_coef_ptr.i.i141 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i142 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i143 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %93 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %94 = load ptr, ptr %32, align 8
  %95 = load ptr, ptr %94, align 8
  %96 = call { ptr, ptr, ptr, i32 } %95(ptr %.fca.1.extract59)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %96, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %96, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %96, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %96, 3
  %hash_coef_ptr.i.i155 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i156 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i157 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i158 = load i64, ptr %hash_coef_ptr.i.i155, align 4
  %tbl_size.i.i159 = load i64, ptr %tbl_size_ptr.i.i156, align 4
  %offset_tbl.i.i160 = load ptr, ptr %offset_tbl_ptr.i.i157, align 8
  %product.i.i.i161 = mul i64 %hash_coef.i.i158, 5693646204635713916
  %shifted.i.i.i162 = lshr i64 %product.i.i.i161, 32
  %xored.i.i.i163 = xor i64 %shifted.i.i.i162, %product.i.i.i161
  %hash.i.i.i164 = and i64 %xored.i.i.i163, %tbl_size.i.i159
  %offset_ptr.i.i165 = getelementptr i32, ptr %offset_tbl.i.i160, i64 %hash.i.i.i164
  %offset.i.i166 = load i32, ptr %offset_ptr.i.i165, align 4
  %eq.i169 = icmp eq i32 %.fca.3.extract7, %offset.i.i166
  call void @llvm.assume(i1 %eq.i169) #30
  %97 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, ptr %.fca.1.extract3, 1
  %99 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %.fca.2.extract5, 2
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, i32 %.fca.3.extract7, 3
  %101 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %102 = load ptr, ptr %7, align 8
  %103 = call ptr %102(ptr %.fca.1.extract59)
  %104 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %105 = load ptr, ptr %20, align 8
  %106 = call ptr %105(ptr %.fca.1.extract59)
  %107 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %108 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %109 = sext i32 %.fca.3.extract7 to i64
  %110 = getelementptr ptr, ptr %.fca.0.extract1, i64 %109
  %111 = getelementptr i8, ptr %110, i64 8
  %112 = load ptr, ptr %111, align 8
  %113 = call ptr %112({ ptr, ptr, ptr, i32 } %100, ptr nonnull %4)
  %114 = call { ptr, ptr, ptr, i32 } %113({ ptr, ptr, ptr, i32 } %100, { ptr, ptr, ptr, i32 } %100, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %114, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %114, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %114, 2
  %hash_coef_ptr.i.i171 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i172 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i173 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i174 = load i64, ptr %hash_coef_ptr.i.i171, align 4
  %tbl_size.i.i175 = load i64, ptr %tbl_size_ptr.i.i172, align 4
  %offset_tbl.i.i176 = load ptr, ptr %offset_tbl_ptr.i.i173, align 8
  %product.i.i.i177 = mul i64 %hash_coef.i.i174, 4189192806087951739
  %shifted.i.i.i178 = lshr i64 %product.i.i.i177, 32
  %xored.i.i.i179 = xor i64 %shifted.i.i.i178, %product.i.i.i177
  %hash.i.i.i180 = and i64 %xored.i.i.i179, %tbl_size.i.i175
  %offset_ptr.i.i181 = getelementptr i32, ptr %offset_tbl.i.i176, i64 %hash.i.i.i180
  %hash_coef.i.i188 = load i64, ptr %hash_coef_ptr.i.i141, align 4
  %tbl_size.i.i189 = load i64, ptr %tbl_size_ptr.i.i142, align 4
  %offset_tbl.i.i190 = load ptr, ptr %offset_tbl_ptr.i.i143, align 8
  %product.i.i.i191 = mul i64 %hash_coef.i.i188, 4189192806087951739
  %shifted.i.i.i192 = lshr i64 %product.i.i.i191, 32
  %xored.i.i.i193 = xor i64 %shifted.i.i.i192, %product.i.i.i191
  %hash.i.i.i194 = and i64 %xored.i.i.i193, %tbl_size.i.i189
  %offset_ptr.i.i195 = getelementptr i32, ptr %offset_tbl.i.i190, i64 %hash.i.i.i194
  %offset.i.i196 = load i32, ptr %offset_ptr.i.i195, align 4
  %115 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %.fca.1.extract11, 1
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr %.fca.2.extract13, 2
  %118 = insertvalue { ptr, ptr, ptr, i32 } %117, i32 %offset.i.i196, 3
  %offset.i.i210 = load i32, ptr %offset_ptr.i.i181, align 4
  %119 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %120 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr %.fca.1.extract, 1
  %121 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %.fca.2.extract, 2
  %122 = insertvalue { ptr, ptr, ptr, i32 } %121, i32 %offset.i.i210, 3
  %123 = load ptr, ptr %67, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %123, 0
  %125 = load ptr, ptr %68, align 8
  %126 = insertvalue { ptr, ptr, ptr, i32 } %124, ptr %125, 1
  %127 = getelementptr inbounds i8, ptr %67, i64 16
  %128 = load ptr, ptr %127, align 8
  %129 = insertvalue { ptr, ptr, ptr, i32 } %126, ptr %128, 2
  %130 = load i32, ptr %69, align 8
  %131 = insertvalue { ptr, ptr, ptr, i32 } %129, i32 %130, 3
  %132 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %133 = load ptr, ptr %7, align 8
  %134 = call ptr %133(ptr %.fca.1.extract59)
  %135 = call ptr @llvm.invariant.start.p0(i64 416, ptr %.fca.0.extract57)
  %136 = load ptr, ptr %20, align 8
  %137 = call ptr %136(ptr %.fca.1.extract59)
  %result.i212 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %138 = getelementptr i8, ptr %result.i212, i64 8
  store ptr %134, ptr %138, align 8
  %139 = getelementptr i8, ptr %result.i212, i64 16
  store ptr null, ptr %139, align 8
  %140 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i212)
  store ptr @Iterator2, ptr %result.i212, align 8
  %result.i213 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %141 = getelementptr i8, ptr %result.i213, i64 8
  store ptr %137, ptr %141, align 8
  %142 = getelementptr i8, ptr %result.i213, i64 16
  store ptr null, ptr %142, align 8
  %143 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i213)
  store ptr @Iterator2, ptr %result.i213, align 8
  %144 = alloca [2 x ptr], align 8
  store ptr %result.i212, ptr %144, align 8
  %145 = getelementptr inbounds i8, ptr %144, i64 8
  store ptr %result.i213, ptr %145, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %144)
  %147 = call ptr @llvm.invariant.start.p0(i64 96, ptr %123)
  %148 = sext i32 %130 to i64
  %149 = getelementptr ptr, ptr %123, i64 %148
  %150 = getelementptr i8, ptr %149, i64 40
  %151 = load ptr, ptr %150, align 8
  %152 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract9, ptr %152, align 8
  %153 = getelementptr inbounds i8, ptr %152, i64 8
  store ptr %.fca.0.extract, ptr %153, align 8
  %154 = call ptr %151({ ptr, ptr, ptr, i32 } %131, ptr nonnull %152)
  call void %154({ ptr, ptr, ptr, i32 } %131, { ptr, ptr, ptr, i32 } %131, ptr nonnull %144, { ptr, ptr, ptr, i32 } %118, { ptr, ptr, ptr, i32 } %122)
  %155 = load ptr, ptr %67, align 8
  %156 = load ptr, ptr %68, align 8
  %157 = load ptr, ptr %127, align 8
  %hash_coef_ptr.i.i215 = getelementptr i8, ptr %155, i64 8
  %tbl_size_ptr.i.i216 = getelementptr i8, ptr %155, i64 16
  %offset_tbl_ptr.i.i217 = getelementptr i8, ptr %155, i64 40
  %hash_coef.i.i218 = load i64, ptr %hash_coef_ptr.i.i215, align 4
  %tbl_size.i.i219 = load i64, ptr %tbl_size_ptr.i.i216, align 4
  %offset_tbl.i.i220 = load ptr, ptr %offset_tbl_ptr.i.i217, align 8
  %product.i.i.i221 = mul i64 %hash_coef.i.i218, 4189192806087951739
  %shifted.i.i.i222 = lshr i64 %product.i.i.i221, 32
  %xored.i.i.i223 = xor i64 %shifted.i.i.i222, %product.i.i.i221
  %hash.i.i.i224 = and i64 %xored.i.i.i223, %tbl_size.i.i219
  %offset_ptr.i.i225 = getelementptr i32, ptr %offset_tbl.i.i220, i64 %hash.i.i.i224
  %offset.i.i226 = load i32, ptr %offset_ptr.i.i225, align 4
  %158 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %155, 0
  %159 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %156, 1
  %160 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %157, 2
  %161 = insertvalue { ptr, ptr, ptr, i32 } %160, i32 %offset.i.i226, 3
  ret { ptr, ptr, ptr, i32 } %161
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_ZipIterator2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_2(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator2_B_init_firstIterator2T_secondIterator2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ZipIterator2_init_firstIterator2T_secondIterator2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5502728639611621286
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 96, ptr %.fca.0.extract9)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract3, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract5, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %16)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4
  %17 = tail call ptr @llvm.invariant.start.p0(i64 96, ptr %.fca.0.extract9)
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %25)
  ret void
}

define { ptr, i160 } @ZipIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 5502728639611621286
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 96, ptr %.fca.0.extract30)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract30, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr, ptr, ptr, i32 } %11(ptr %.fca.1.extract32)
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %12, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %12, 1
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %12, 2
  %.fca.3.extract16 = extractvalue { ptr, ptr, ptr, i32 } %12, 3
  %hash_coef_ptr.i.i53 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i54 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i55 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i56 = load i64, ptr %hash_coef_ptr.i.i53, align 4
  %tbl_size.i.i57 = load i64, ptr %tbl_size_ptr.i.i54, align 4
  %offset_tbl.i.i58 = load ptr, ptr %offset_tbl_ptr.i.i55, align 8
  %product.i.i.i59 = mul i64 %hash_coef.i.i56, 4189192806087951739
  %shifted.i.i.i60 = lshr i64 %product.i.i.i59, 32
  %xored.i.i.i61 = xor i64 %shifted.i.i.i60, %product.i.i.i59
  %hash.i.i.i62 = and i64 %xored.i.i.i61, %tbl_size.i.i57
  %offset_ptr.i.i63 = getelementptr i32, ptr %offset_tbl.i.i58, i64 %hash.i.i.i62
  %offset.i.i64 = load i32, ptr %offset_ptr.i.i63, align 4
  %eq.i = icmp eq i32 %.fca.3.extract16, %offset.i.i64
  tail call void @llvm.assume(i1 %eq.i) #30
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract12, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract14, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %.fca.3.extract16, 3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 96, ptr %.fca.0.extract30)
  %18 = load ptr, ptr %8, align 8
  %19 = tail call ptr %18(ptr %.fca.1.extract32)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 96, ptr %.fca.0.extract30)
  %21 = getelementptr i8, ptr %8, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = tail call ptr %22(ptr %.fca.1.extract32)
  %24 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %25 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract10)
  %26 = sext i32 %.fca.3.extract16 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract10, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = call ptr %29({ ptr, ptr, ptr, i32 } %16, ptr nonnull %4)
  %31 = call { ptr, i160 } %30({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull %4)
  %.fca.0.extract4 = extractvalue { ptr, i160 } %31, 0
  %32 = call ptr @llvm.invariant.start.p0(i64 96, ptr %.fca.0.extract30)
  %33 = getelementptr i8, ptr %8, i64 32
  %34 = load ptr, ptr %33, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr, ptr, ptr, i32 } %35(ptr %.fca.1.extract32)
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %36, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %36, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %36, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %36, 3
  %hash_coef_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i69 = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i70 = load i64, ptr %hash_coef_ptr.i.i67, align 4
  %tbl_size.i.i71 = load i64, ptr %tbl_size_ptr.i.i68, align 4
  %offset_tbl.i.i72 = load ptr, ptr %offset_tbl_ptr.i.i69, align 8
  %product.i.i.i73 = mul i64 %hash_coef.i.i70, 4189192806087951739
  %shifted.i.i.i74 = lshr i64 %product.i.i.i73, 32
  %xored.i.i.i75 = xor i64 %shifted.i.i.i74, %product.i.i.i73
  %hash.i.i.i76 = and i64 %xored.i.i.i75, %tbl_size.i.i71
  %offset_ptr.i.i77 = getelementptr i32, ptr %offset_tbl.i.i72, i64 %hash.i.i.i76
  %offset.i.i78 = load i32, ptr %offset_ptr.i.i77, align 4
  %eq.i81 = icmp eq i32 %.fca.3.extract, %offset.i.i78
  call void @llvm.assume(i1 %eq.i81) #30
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.1.extract3, 1
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %.fca.2.extract, 2
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %.fca.3.extract, 3
  %41 = call ptr @llvm.invariant.start.p0(i64 96, ptr %.fca.0.extract30)
  %42 = load ptr, ptr %8, align 8
  %43 = call ptr %42(ptr %.fca.1.extract32)
  %44 = call ptr @llvm.invariant.start.p0(i64 96, ptr %.fca.0.extract30)
  %45 = load ptr, ptr %21, align 8
  %46 = call ptr %45(ptr %.fca.1.extract32)
  %47 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract2)
  %49 = sext i32 %.fca.3.extract to i64
  %50 = getelementptr ptr, ptr %.fca.0.extract2, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %53 = call ptr %52({ ptr, ptr, ptr, i32 } %40, ptr nonnull %4)
  %54 = call { ptr, i160 } %53({ ptr, ptr, ptr, i32 } %40, { ptr, ptr, ptr, i32 } %40, ptr nonnull %4)
  %55 = icmp ne ptr %.fca.0.extract4, @nil_typ
  %56 = icmp ne ptr %.fca.0.extract4, null
  %.not49 = and i1 %55, %56
  br i1 %.not49, label %57, label %.thread

57:                                               ; preds = %3
  %.fca.0.extract = extractvalue { ptr, i160 } %54, 0
  %58 = icmp ne ptr %.fca.0.extract, @nil_typ
  %59 = icmp ne ptr %.fca.0.extract, null
  %.not51 = and i1 %58, %59
  br i1 %.not51, label %60, label %.thread

60:                                               ; preds = %57
  %61 = call ptr @llvm.invariant.start.p0(i64 96, ptr nonnull %.fca.0.extract30)
  %62 = load ptr, ptr %8, align 8
  %63 = call ptr %62(ptr %.fca.1.extract32)
  %64 = call ptr @llvm.invariant.start.p0(i64 96, ptr nonnull %.fca.0.extract30)
  %65 = load ptr, ptr %21, align 8
  %66 = call ptr %65(ptr %.fca.1.extract32)
  %67 = load ptr, ptr %63, align 8
  %68 = getelementptr i8, ptr %67, i64 48
  %69 = load ptr, ptr %68, align 8
  %70 = call { i64, i64 } %69(ptr nonnull %63)
  %71 = extractvalue { i64, i64 } %70, 0
  %72 = extractvalue { i64, i64 } %70, 1
  %73 = urem i64 16, %72
  %74 = icmp eq i64 %73, 0
  %75 = sub i64 %72, %73
  %76 = select i1 %74, i64 0, i64 %75
  %77 = add i64 %71, 16
  %78 = add i64 %77, %76
  %79 = load ptr, ptr %66, align 8
  %80 = getelementptr i8, ptr %79, i64 48
  %81 = load ptr, ptr %80, align 8
  %82 = call { i64, i64 } %81(ptr nonnull %66)
  %83 = extractvalue { i64, i64 } %82, 0
  %84 = extractvalue { i64, i64 } %82, 1
  %85 = call i64 @llvm.umax.i64(i64 %72, i64 %84)
  %86 = call i64 @llvm.umax.i64(i64 %85, i64 8)
  %87 = urem i64 %78, %84
  %88 = icmp eq i64 %87, 0
  %89 = sub i64 %84, %87
  %90 = select i1 %88, i64 0, i64 %89
  %91 = add i64 %83, %78
  %92 = add i64 %91, %90
  %93 = urem i64 %92, %86
  %94 = icmp eq i64 %93, 0
  %95 = sub i64 %86, %93
  %96 = select i1 %94, i64 0, i64 %95
  %97 = add i64 %96, %92
  %result.i = call noalias ptr @bump_malloc_inner(i64 noundef %97, ptr nonnull @current_ptr) #29
  store ptr %63, ptr %result.i, align 8
  %98 = getelementptr i8, ptr %result.i, i64 8
  store ptr %66, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i)
  %100 = getelementptr inbounds i8, ptr %5, i64 8
  %101 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @Pair, ptr %5, align 8
  store ptr %result.i, ptr %100, align 8
  store i32 9, ptr %101, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %5)
  %103 = call ptr @llvm.invariant.start.p0(i64 96, ptr nonnull %.fca.0.extract30)
  %104 = load ptr, ptr %8, align 8
  %105 = call ptr %104(ptr %.fca.1.extract32)
  %106 = call ptr @llvm.invariant.start.p0(i64 96, ptr nonnull %.fca.0.extract30)
  %107 = load ptr, ptr %21, align 8
  %108 = call ptr %107(ptr %.fca.1.extract32)
  %109 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @Pair)
  %110 = load ptr, ptr %result.i, align 8
  %111 = load ptr, ptr %110, align 8
  %112 = getelementptr i8, ptr %111, i64 48
  %113 = load ptr, ptr %112, align 8
  %114 = call { i64, i64 } %113(ptr nonnull %110)
  %115 = extractvalue { i64, i64 } %114, 1
  %116 = urem i64 16, %115
  %117 = icmp eq i64 %116, 0
  %reass.sub = sub i64 %115, %116
  %118 = add i64 %reass.sub, 16
  %119 = select i1 %117, i64 16, i64 %118
  %120 = getelementptr i8, ptr %result.i, i64 %119
  %121 = load ptr, ptr %result.i, align 8
  %122 = load ptr, ptr %121, align 8
  %123 = getelementptr i8, ptr %122, i64 64
  %124 = load ptr, ptr %123, align 8
  call void %124({ ptr, i160 } %31, ptr nonnull %121, ptr %120)
  %125 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull @Pair)
  %126 = load ptr, ptr %result.i, align 8
  %127 = load ptr, ptr %126, align 8
  %128 = getelementptr i8, ptr %127, i64 48
  %129 = load ptr, ptr %128, align 8
  %130 = call { i64, i64 } %129(ptr nonnull %126)
  %131 = extractvalue { i64, i64 } %130, 0
  %132 = extractvalue { i64, i64 } %130, 1
  %133 = urem i64 16, %132
  %134 = icmp eq i64 %133, 0
  %135 = sub i64 %132, %133
  %136 = select i1 %134, i64 0, i64 %135
  %137 = add i64 %131, 16
  %138 = add i64 %137, %136
  %139 = load ptr, ptr %98, align 8
  %140 = load ptr, ptr %139, align 8
  %141 = getelementptr i8, ptr %140, i64 48
  %142 = load ptr, ptr %141, align 8
  %143 = call { i64, i64 } %142(ptr nonnull %139)
  %144 = extractvalue { i64, i64 } %143, 1
  %145 = urem i64 %138, %144
  %146 = icmp eq i64 %145, 0
  %147 = sub i64 %144, %145
  %148 = select i1 %146, i64 0, i64 %147
  %149 = getelementptr i8, ptr %result.i, i64 %138
  %150 = getelementptr i8, ptr %149, i64 %148
  %151 = load ptr, ptr %98, align 8
  %152 = load ptr, ptr %151, align 8
  %153 = getelementptr i8, ptr %152, i64 64
  %154 = load ptr, ptr %153, align 8
  call void %154({ ptr, i160 } %54, ptr nonnull %151, ptr %150)
  %155 = load ptr, ptr %5, align 8
  %156 = load i160, ptr %100, align 8
  br label %.thread

.thread:                                          ; preds = %3, %57, %60
  %.reg2mem15.sroa.3.0113 = phi i160 [ %156, %60 ], [ poison, %57 ], [ poison, %3 ]
  %157 = phi ptr [ %155, %60 ], [ @nil_typ, %57 ], [ @nil_typ, %3 ]
  %.reload12.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %157, 0
  %.reload12.fca.1.insert = insertvalue { ptr, i160 } %.reload12.fca.0.insert, i160 %.reg2mem15.sroa.3.0113, 1
  ret { ptr, i160 } %.reload12.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator2_getter_second(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator2_setter_second(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator2_getter_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator2_setter_first(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable2_getter_second(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable2_setter_second(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable2_getter_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable2_setter_first(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_InterleaveIterable2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterable2_field_InterleaveIterable2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @InterleaveIterable2_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -6258231685215461775
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract9)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract3, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract5, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %16)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4
  %17 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract9)
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %25)
  ret void
}

define { ptr, ptr, ptr, i32 } @InterleaveIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -6258231685215461775
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract57, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract59)
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract51 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract53 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract55 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i66 = getelementptr i8, ptr %.fca.0.extract49, i64 8
  %tbl_size_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract49, i64 16
  %offset_tbl_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract49, i64 40
  %hash_coef.i.i69 = load i64, ptr %hash_coef_ptr.i.i66, align 4
  %tbl_size.i.i70 = load i64, ptr %tbl_size_ptr.i.i67, align 4
  %offset_tbl.i.i71 = load ptr, ptr %offset_tbl_ptr.i.i68, align 8
  %product.i.i.i72 = mul i64 %hash_coef.i.i69, 5693646204635713916
  %shifted.i.i.i73 = lshr i64 %product.i.i.i72, 32
  %xored.i.i.i74 = xor i64 %shifted.i.i.i73, %product.i.i.i72
  %hash.i.i.i75 = and i64 %xored.i.i.i74, %tbl_size.i.i70
  %offset_ptr.i.i76 = getelementptr i32, ptr %offset_tbl.i.i71, i64 %hash.i.i.i75
  %offset.i.i77 = load i32, ptr %offset_ptr.i.i76, align 4
  %eq.i = icmp eq i32 %.fca.3.extract55, %offset.i.i77
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract49, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract51, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract53, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract55, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %17 = load ptr, ptr %7, align 8
  %18 = tail call ptr %17(ptr %.fca.1.extract59)
  %19 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract49)
  %21 = sext i32 %.fca.3.extract55 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract49, i64 %21
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr %24({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %26 = call { ptr, ptr, ptr, i32 } %25({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %27 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %28 = getelementptr i8, ptr %7, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr, ptr, ptr, i32 } %30(ptr %.fca.1.extract59)
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %31, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %31, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %31, 2
  %.fca.3.extract39 = extractvalue { ptr, ptr, ptr, i32 } %31, 3
  %hash_coef_ptr.i.i94 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i95 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i96 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i97 = load i64, ptr %hash_coef_ptr.i.i94, align 4
  %tbl_size.i.i98 = load i64, ptr %tbl_size_ptr.i.i95, align 4
  %offset_tbl.i.i99 = load ptr, ptr %offset_tbl_ptr.i.i96, align 8
  %product.i.i.i100 = mul i64 %hash_coef.i.i97, 5693646204635713916
  %shifted.i.i.i101 = lshr i64 %product.i.i.i100, 32
  %xored.i.i.i102 = xor i64 %shifted.i.i.i101, %product.i.i.i100
  %hash.i.i.i103 = and i64 %xored.i.i.i102, %tbl_size.i.i98
  %offset_ptr.i.i104 = getelementptr i32, ptr %offset_tbl.i.i99, i64 %hash.i.i.i103
  %offset.i.i105 = load i32, ptr %offset_ptr.i.i104, align 4
  %eq.i108 = icmp eq i32 %.fca.3.extract39, %offset.i.i105
  call void @llvm.assume(i1 %eq.i108) #30
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.1.extract35, 1
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %.fca.2.extract37, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %.fca.3.extract39, 3
  %36 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %37 = load ptr, ptr %7, align 8
  %38 = call ptr %37(ptr %.fca.1.extract59)
  %39 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract33)
  %41 = sext i32 %.fca.3.extract39 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract33, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %45 = call ptr %44({ ptr, ptr, ptr, i32 } %35, ptr nonnull %4)
  %46 = call { ptr, ptr, ptr, i32 } %45({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull %4)
  %47 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %48 = load ptr, ptr %7, align 8
  %49 = call ptr %48(ptr %.fca.1.extract59)
  %result.i = call noalias dereferenceable_or_null(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nonnull @current_ptr) #29
  store ptr %49, ptr %result.i, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  %52 = getelementptr inbounds i8, ptr %51, i64 8
  %53 = getelementptr inbounds i8, ptr %51, i64 24
  store ptr @InterleaveIterator2, ptr %51, align 8
  store ptr %result.i, ptr %52, align 8
  store i32 9, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %51)
  %55 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %56 = load ptr, ptr %8, align 8
  %57 = load ptr, ptr %56, align 8
  %58 = call { ptr, ptr, ptr, i32 } %57(ptr %.fca.1.extract59)
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %58, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %58, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %58, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %58, 3
  %hash_coef_ptr.i.i124 = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i125 = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i126 = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i127 = load i64, ptr %hash_coef_ptr.i.i124, align 4
  %tbl_size.i.i128 = load i64, ptr %tbl_size_ptr.i.i125, align 4
  %offset_tbl.i.i129 = load ptr, ptr %offset_tbl_ptr.i.i126, align 8
  %product.i.i.i130 = mul i64 %hash_coef.i.i127, 5693646204635713916
  %shifted.i.i.i131 = lshr i64 %product.i.i.i130, 32
  %xored.i.i.i132 = xor i64 %shifted.i.i.i131, %product.i.i.i130
  %hash.i.i.i133 = and i64 %xored.i.i.i132, %tbl_size.i.i128
  %offset_ptr.i.i134 = getelementptr i32, ptr %offset_tbl.i.i129, i64 %hash.i.i.i133
  %offset.i.i135 = load i32, ptr %offset_ptr.i.i134, align 4
  %eq.i138 = icmp eq i32 %.fca.3.extract23, %offset.i.i135
  call void @llvm.assume(i1 %eq.i138) #30
  %59 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %.fca.1.extract19, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.2.extract21, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %.fca.3.extract23, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %64 = load ptr, ptr %7, align 8
  %65 = call ptr %64(ptr %.fca.1.extract59)
  %66 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %67 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract17)
  %68 = sext i32 %.fca.3.extract23 to i64
  %69 = getelementptr ptr, ptr %.fca.0.extract17, i64 %68
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = load ptr, ptr %70, align 8
  %72 = call ptr %71({ ptr, ptr, ptr, i32 } %62, ptr nonnull %4)
  %73 = call { ptr, ptr, ptr, i32 } %72({ ptr, ptr, ptr, i32 } %62, { ptr, ptr, ptr, i32 } %62, ptr nonnull %4)
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %73, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %73, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %73, 2
  %hash_coef_ptr.i.i140 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i141 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i142 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %74 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %75 = load ptr, ptr %28, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = call { ptr, ptr, ptr, i32 } %76(ptr %.fca.1.extract59)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %77, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %77, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %77, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %77, 3
  %hash_coef_ptr.i.i154 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i155 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i156 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i157 = load i64, ptr %hash_coef_ptr.i.i154, align 4
  %tbl_size.i.i158 = load i64, ptr %tbl_size_ptr.i.i155, align 4
  %offset_tbl.i.i159 = load ptr, ptr %offset_tbl_ptr.i.i156, align 8
  %product.i.i.i160 = mul i64 %hash_coef.i.i157, 5693646204635713916
  %shifted.i.i.i161 = lshr i64 %product.i.i.i160, 32
  %xored.i.i.i162 = xor i64 %shifted.i.i.i161, %product.i.i.i160
  %hash.i.i.i163 = and i64 %xored.i.i.i162, %tbl_size.i.i158
  %offset_ptr.i.i164 = getelementptr i32, ptr %offset_tbl.i.i159, i64 %hash.i.i.i163
  %offset.i.i165 = load i32, ptr %offset_ptr.i.i164, align 4
  %eq.i168 = icmp eq i32 %.fca.3.extract7, %offset.i.i165
  call void @llvm.assume(i1 %eq.i168) #30
  %78 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %.fca.1.extract3, 1
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %.fca.2.extract5, 2
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, i32 %.fca.3.extract7, 3
  %82 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %83 = load ptr, ptr %7, align 8
  %84 = call ptr %83(ptr %.fca.1.extract59)
  %85 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %86 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %87 = sext i32 %.fca.3.extract7 to i64
  %88 = getelementptr ptr, ptr %.fca.0.extract1, i64 %87
  %89 = getelementptr i8, ptr %88, i64 8
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr %90({ ptr, ptr, ptr, i32 } %81, ptr nonnull %4)
  %92 = call { ptr, ptr, ptr, i32 } %91({ ptr, ptr, ptr, i32 } %81, { ptr, ptr, ptr, i32 } %81, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %92, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %92, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %92, 2
  %hash_coef_ptr.i.i170 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i171 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i172 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i173 = load i64, ptr %hash_coef_ptr.i.i170, align 4
  %tbl_size.i.i174 = load i64, ptr %tbl_size_ptr.i.i171, align 4
  %offset_tbl.i.i175 = load ptr, ptr %offset_tbl_ptr.i.i172, align 8
  %product.i.i.i176 = mul i64 %hash_coef.i.i173, 4189192806087951739
  %shifted.i.i.i177 = lshr i64 %product.i.i.i176, 32
  %xored.i.i.i178 = xor i64 %shifted.i.i.i177, %product.i.i.i176
  %hash.i.i.i179 = and i64 %xored.i.i.i178, %tbl_size.i.i174
  %offset_ptr.i.i180 = getelementptr i32, ptr %offset_tbl.i.i175, i64 %hash.i.i.i179
  %hash_coef.i.i187 = load i64, ptr %hash_coef_ptr.i.i140, align 4
  %tbl_size.i.i188 = load i64, ptr %tbl_size_ptr.i.i141, align 4
  %offset_tbl.i.i189 = load ptr, ptr %offset_tbl_ptr.i.i142, align 8
  %product.i.i.i190 = mul i64 %hash_coef.i.i187, 4189192806087951739
  %shifted.i.i.i191 = lshr i64 %product.i.i.i190, 32
  %xored.i.i.i192 = xor i64 %shifted.i.i.i191, %product.i.i.i190
  %hash.i.i.i193 = and i64 %xored.i.i.i192, %tbl_size.i.i188
  %offset_ptr.i.i194 = getelementptr i32, ptr %offset_tbl.i.i189, i64 %hash.i.i.i193
  %offset.i.i195 = load i32, ptr %offset_ptr.i.i194, align 4
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %.fca.1.extract11, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %.fca.2.extract13, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %offset.i.i195, 3
  %offset.i.i209 = load i32, ptr %offset_ptr.i.i180, align 4
  %97 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, ptr %.fca.1.extract, 1
  %99 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %.fca.2.extract, 2
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, i32 %offset.i.i209, 3
  %101 = load ptr, ptr %51, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %101, 0
  %103 = load ptr, ptr %52, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 1
  %105 = getelementptr inbounds i8, ptr %51, i64 16
  %106 = load ptr, ptr %105, align 8
  %107 = insertvalue { ptr, ptr, ptr, i32 } %104, ptr %106, 2
  %108 = load i32, ptr %53, align 8
  %109 = insertvalue { ptr, ptr, ptr, i32 } %107, i32 %108, 3
  %110 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %111 = load ptr, ptr %7, align 8
  %112 = call ptr %111(ptr %.fca.1.extract59)
  %result.i211 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %113 = getelementptr i8, ptr %result.i211, i64 8
  store ptr %112, ptr %113, align 8
  %114 = getelementptr i8, ptr %result.i211, i64 16
  store ptr null, ptr %114, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i211)
  store ptr @Iterator2, ptr %result.i211, align 8
  %result.i212 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %116 = getelementptr i8, ptr %result.i212, i64 8
  store ptr %112, ptr %116, align 8
  %117 = getelementptr i8, ptr %result.i212, i64 16
  store ptr null, ptr %117, align 8
  %118 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i212)
  store ptr @Iterator2, ptr %result.i212, align 8
  %119 = alloca [2 x ptr], align 8
  store ptr %result.i211, ptr %119, align 8
  %120 = getelementptr inbounds i8, ptr %119, i64 8
  store ptr %result.i212, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %119)
  %122 = call ptr @llvm.invariant.start.p0(i64 88, ptr %101)
  %123 = sext i32 %108 to i64
  %124 = getelementptr ptr, ptr %101, i64 %123
  %125 = getelementptr i8, ptr %124, i64 32
  %126 = load ptr, ptr %125, align 8
  %127 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract9, ptr %127, align 8
  %128 = getelementptr inbounds i8, ptr %127, i64 8
  store ptr %.fca.0.extract, ptr %128, align 8
  %129 = call ptr %126({ ptr, ptr, ptr, i32 } %109, ptr nonnull %127)
  call void %129({ ptr, ptr, ptr, i32 } %109, { ptr, ptr, ptr, i32 } %109, ptr nonnull %119, { ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %100)
  %130 = load ptr, ptr %51, align 8
  %131 = load ptr, ptr %52, align 8
  %132 = load ptr, ptr %105, align 8
  %hash_coef_ptr.i.i214 = getelementptr i8, ptr %130, i64 8
  %tbl_size_ptr.i.i215 = getelementptr i8, ptr %130, i64 16
  %offset_tbl_ptr.i.i216 = getelementptr i8, ptr %130, i64 40
  %hash_coef.i.i217 = load i64, ptr %hash_coef_ptr.i.i214, align 4
  %tbl_size.i.i218 = load i64, ptr %tbl_size_ptr.i.i215, align 4
  %offset_tbl.i.i219 = load ptr, ptr %offset_tbl_ptr.i.i216, align 8
  %product.i.i.i220 = mul i64 %hash_coef.i.i217, 4189192806087951739
  %shifted.i.i.i221 = lshr i64 %product.i.i.i220, 32
  %xored.i.i.i222 = xor i64 %shifted.i.i.i221, %product.i.i.i220
  %hash.i.i.i223 = and i64 %xored.i.i.i222, %tbl_size.i.i218
  %offset_ptr.i.i224 = getelementptr i32, ptr %offset_tbl.i.i219, i64 %hash.i.i.i223
  %offset.i.i225 = load i32, ptr %offset_ptr.i.i224, align 4
  %133 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %130, 0
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, ptr %131, 1
  %135 = insertvalue { ptr, ptr, ptr, i32 } %134, ptr %132, 2
  %136 = insertvalue { ptr, ptr, ptr, i32 } %135, i32 %offset.i.i225, 3
  ret { ptr, ptr, ptr, i32 } %136
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_InterleaveIterator2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterator2_field_InterleaveIterator2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator2_B_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @InterleaveIterator2_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6709847746581360093
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract9)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract3, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract5, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %16)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4
  %17 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract9)
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %25)
  %26 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract9)
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract11, i1 true)
  ret void
}

define { ptr, i160 } @InterleaveIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6709847746581360093
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract3)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract3, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract4)
  %12 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr nonnull %.fca.0.extract3)
  %13 = load ptr, ptr %8, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %not. = xor i1 %11, true
  %.104 = select i1 %11, i64 8, i64 16
  tail call void %15(ptr %.fca.1.extract4, i1 %not.)
  %16 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr nonnull %.fca.0.extract3)
  %17 = getelementptr i8, ptr %7, i64 %.104
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr, ptr, ptr, i32 } %19(ptr %.fca.1.extract4)
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %20, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %20, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %20, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %20, 3
  %hash_coef_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i49 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i50 = load i64, ptr %hash_coef_ptr.i.i47, align 4
  %tbl_size.i.i51 = load i64, ptr %tbl_size_ptr.i.i48, align 4
  %offset_tbl.i.i52 = load ptr, ptr %offset_tbl_ptr.i.i49, align 8
  %product.i.i.i53 = mul i64 %hash_coef.i.i50, 4189192806087951739
  %shifted.i.i.i54 = lshr i64 %product.i.i.i53, 32
  %xored.i.i.i55 = xor i64 %shifted.i.i.i54, %product.i.i.i53
  %hash.i.i.i56 = and i64 %xored.i.i.i55, %tbl_size.i.i51
  %offset_ptr.i.i57 = getelementptr i32, ptr %offset_tbl.i.i52, i64 %hash.i.i.i56
  %offset.i.i58 = load i32, ptr %offset_ptr.i.i57, align 4
  %eq.i61 = icmp eq i32 %.fca.3.extract15, %offset.i.i58
  tail call void @llvm.assume(i1 %eq.i61) #30
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract11, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract13, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %.fca.3.extract15, 3
  %25 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr nonnull %.fca.0.extract3)
  %26 = load ptr, ptr %7, align 8
  %27 = tail call ptr %26(ptr %.fca.1.extract4)
  %28 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %29 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract9)
  %30 = sext i32 %.fca.3.extract15 to i64
  %31 = getelementptr ptr, ptr %.fca.0.extract9, i64 %30
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = call ptr %33({ ptr, ptr, ptr, i32 } %24, ptr nonnull %4)
  %35 = call { ptr, i160 } %34({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull %4)
  ret { ptr, i160 } %35
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @InterleaveIterator2_getter_on_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_on_first(ptr nocapture writeonly %0, i1 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator2_getter_second(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_second(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator2_getter_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_first(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable2_getter_second(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable2_setter_second(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable2_getter_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable2_setter_first(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_ChainIterable2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterable2_field_ChainIterable2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ChainIterable2_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5233298072945030060
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract9)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract3, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract5, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %16)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4
  %17 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract9)
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %25)
  ret void
}

define { ptr, ptr, ptr, i32 } @ChainIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract57 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract59 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract57, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5233298072945030060
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract57, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract59)
  %.fca.0.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract51 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract53 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract55 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i66 = getelementptr i8, ptr %.fca.0.extract49, i64 8
  %tbl_size_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract49, i64 16
  %offset_tbl_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract49, i64 40
  %hash_coef.i.i69 = load i64, ptr %hash_coef_ptr.i.i66, align 4
  %tbl_size.i.i70 = load i64, ptr %tbl_size_ptr.i.i67, align 4
  %offset_tbl.i.i71 = load ptr, ptr %offset_tbl_ptr.i.i68, align 8
  %product.i.i.i72 = mul i64 %hash_coef.i.i69, 5693646204635713916
  %shifted.i.i.i73 = lshr i64 %product.i.i.i72, 32
  %xored.i.i.i74 = xor i64 %shifted.i.i.i73, %product.i.i.i72
  %hash.i.i.i75 = and i64 %xored.i.i.i74, %tbl_size.i.i70
  %offset_ptr.i.i76 = getelementptr i32, ptr %offset_tbl.i.i71, i64 %hash.i.i.i75
  %offset.i.i77 = load i32, ptr %offset_ptr.i.i76, align 4
  %eq.i = icmp eq i32 %.fca.3.extract55, %offset.i.i77
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract49, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract51, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract53, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract55, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %17 = load ptr, ptr %7, align 8
  %18 = tail call ptr %17(ptr %.fca.1.extract59)
  %19 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract49)
  %21 = sext i32 %.fca.3.extract55 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract49, i64 %21
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr %24({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %26 = call { ptr, ptr, ptr, i32 } %25({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %27 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %28 = getelementptr i8, ptr %7, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr, ptr, ptr, i32 } %30(ptr %.fca.1.extract59)
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %31, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %31, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %31, 2
  %.fca.3.extract39 = extractvalue { ptr, ptr, ptr, i32 } %31, 3
  %hash_coef_ptr.i.i94 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i95 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i96 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i97 = load i64, ptr %hash_coef_ptr.i.i94, align 4
  %tbl_size.i.i98 = load i64, ptr %tbl_size_ptr.i.i95, align 4
  %offset_tbl.i.i99 = load ptr, ptr %offset_tbl_ptr.i.i96, align 8
  %product.i.i.i100 = mul i64 %hash_coef.i.i97, 5693646204635713916
  %shifted.i.i.i101 = lshr i64 %product.i.i.i100, 32
  %xored.i.i.i102 = xor i64 %shifted.i.i.i101, %product.i.i.i100
  %hash.i.i.i103 = and i64 %xored.i.i.i102, %tbl_size.i.i98
  %offset_ptr.i.i104 = getelementptr i32, ptr %offset_tbl.i.i99, i64 %hash.i.i.i103
  %offset.i.i105 = load i32, ptr %offset_ptr.i.i104, align 4
  %eq.i108 = icmp eq i32 %.fca.3.extract39, %offset.i.i105
  call void @llvm.assume(i1 %eq.i108) #30
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.1.extract35, 1
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %.fca.2.extract37, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %.fca.3.extract39, 3
  %36 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %37 = load ptr, ptr %7, align 8
  %38 = call ptr %37(ptr %.fca.1.extract59)
  %39 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract33)
  %41 = sext i32 %.fca.3.extract39 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract33, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %45 = call ptr %44({ ptr, ptr, ptr, i32 } %35, ptr nonnull %4)
  %46 = call { ptr, ptr, ptr, i32 } %45({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull %4)
  %47 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %48 = load ptr, ptr %7, align 8
  %49 = call ptr %48(ptr %.fca.1.extract59)
  %result.i = call noalias dereferenceable_or_null(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nonnull @current_ptr) #29
  store ptr %49, ptr %result.i, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  %52 = getelementptr inbounds i8, ptr %51, i64 8
  %53 = getelementptr inbounds i8, ptr %51, i64 24
  store ptr @ChainIterator2, ptr %51, align 8
  store ptr %result.i, ptr %52, align 8
  store i32 9, ptr %53, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %51)
  %55 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %56 = load ptr, ptr %8, align 8
  %57 = load ptr, ptr %56, align 8
  %58 = call { ptr, ptr, ptr, i32 } %57(ptr %.fca.1.extract59)
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %58, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %58, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %58, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %58, 3
  %hash_coef_ptr.i.i124 = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i125 = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i126 = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i127 = load i64, ptr %hash_coef_ptr.i.i124, align 4
  %tbl_size.i.i128 = load i64, ptr %tbl_size_ptr.i.i125, align 4
  %offset_tbl.i.i129 = load ptr, ptr %offset_tbl_ptr.i.i126, align 8
  %product.i.i.i130 = mul i64 %hash_coef.i.i127, 5693646204635713916
  %shifted.i.i.i131 = lshr i64 %product.i.i.i130, 32
  %xored.i.i.i132 = xor i64 %shifted.i.i.i131, %product.i.i.i130
  %hash.i.i.i133 = and i64 %xored.i.i.i132, %tbl_size.i.i128
  %offset_ptr.i.i134 = getelementptr i32, ptr %offset_tbl.i.i129, i64 %hash.i.i.i133
  %offset.i.i135 = load i32, ptr %offset_ptr.i.i134, align 4
  %eq.i138 = icmp eq i32 %.fca.3.extract23, %offset.i.i135
  call void @llvm.assume(i1 %eq.i138) #30
  %59 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %.fca.1.extract19, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.2.extract21, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %.fca.3.extract23, 3
  %63 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %64 = load ptr, ptr %7, align 8
  %65 = call ptr %64(ptr %.fca.1.extract59)
  %66 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %67 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract17)
  %68 = sext i32 %.fca.3.extract23 to i64
  %69 = getelementptr ptr, ptr %.fca.0.extract17, i64 %68
  %70 = getelementptr i8, ptr %69, i64 8
  %71 = load ptr, ptr %70, align 8
  %72 = call ptr %71({ ptr, ptr, ptr, i32 } %62, ptr nonnull %4)
  %73 = call { ptr, ptr, ptr, i32 } %72({ ptr, ptr, ptr, i32 } %62, { ptr, ptr, ptr, i32 } %62, ptr nonnull %4)
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %73, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %73, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %73, 2
  %hash_coef_ptr.i.i140 = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i141 = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i142 = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %74 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %75 = load ptr, ptr %28, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = call { ptr, ptr, ptr, i32 } %76(ptr %.fca.1.extract59)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %77, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %77, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %77, 2
  %.fca.3.extract7 = extractvalue { ptr, ptr, ptr, i32 } %77, 3
  %hash_coef_ptr.i.i154 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i155 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i156 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i157 = load i64, ptr %hash_coef_ptr.i.i154, align 4
  %tbl_size.i.i158 = load i64, ptr %tbl_size_ptr.i.i155, align 4
  %offset_tbl.i.i159 = load ptr, ptr %offset_tbl_ptr.i.i156, align 8
  %product.i.i.i160 = mul i64 %hash_coef.i.i157, 5693646204635713916
  %shifted.i.i.i161 = lshr i64 %product.i.i.i160, 32
  %xored.i.i.i162 = xor i64 %shifted.i.i.i161, %product.i.i.i160
  %hash.i.i.i163 = and i64 %xored.i.i.i162, %tbl_size.i.i158
  %offset_ptr.i.i164 = getelementptr i32, ptr %offset_tbl.i.i159, i64 %hash.i.i.i163
  %offset.i.i165 = load i32, ptr %offset_ptr.i.i164, align 4
  %eq.i168 = icmp eq i32 %.fca.3.extract7, %offset.i.i165
  call void @llvm.assume(i1 %eq.i168) #30
  %78 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %.fca.1.extract3, 1
  %80 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %.fca.2.extract5, 2
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, i32 %.fca.3.extract7, 3
  %82 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %83 = load ptr, ptr %7, align 8
  %84 = call ptr %83(ptr %.fca.1.extract59)
  %85 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %86 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract1)
  %87 = sext i32 %.fca.3.extract7 to i64
  %88 = getelementptr ptr, ptr %.fca.0.extract1, i64 %87
  %89 = getelementptr i8, ptr %88, i64 8
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr %90({ ptr, ptr, ptr, i32 } %81, ptr nonnull %4)
  %92 = call { ptr, ptr, ptr, i32 } %91({ ptr, ptr, ptr, i32 } %81, { ptr, ptr, ptr, i32 } %81, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %92, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %92, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %92, 2
  %hash_coef_ptr.i.i170 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i171 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i172 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i173 = load i64, ptr %hash_coef_ptr.i.i170, align 4
  %tbl_size.i.i174 = load i64, ptr %tbl_size_ptr.i.i171, align 4
  %offset_tbl.i.i175 = load ptr, ptr %offset_tbl_ptr.i.i172, align 8
  %product.i.i.i176 = mul i64 %hash_coef.i.i173, 4189192806087951739
  %shifted.i.i.i177 = lshr i64 %product.i.i.i176, 32
  %xored.i.i.i178 = xor i64 %shifted.i.i.i177, %product.i.i.i176
  %hash.i.i.i179 = and i64 %xored.i.i.i178, %tbl_size.i.i174
  %offset_ptr.i.i180 = getelementptr i32, ptr %offset_tbl.i.i175, i64 %hash.i.i.i179
  %hash_coef.i.i187 = load i64, ptr %hash_coef_ptr.i.i140, align 4
  %tbl_size.i.i188 = load i64, ptr %tbl_size_ptr.i.i141, align 4
  %offset_tbl.i.i189 = load ptr, ptr %offset_tbl_ptr.i.i142, align 8
  %product.i.i.i190 = mul i64 %hash_coef.i.i187, 4189192806087951739
  %shifted.i.i.i191 = lshr i64 %product.i.i.i190, 32
  %xored.i.i.i192 = xor i64 %shifted.i.i.i191, %product.i.i.i190
  %hash.i.i.i193 = and i64 %xored.i.i.i192, %tbl_size.i.i188
  %offset_ptr.i.i194 = getelementptr i32, ptr %offset_tbl.i.i189, i64 %hash.i.i.i193
  %offset.i.i195 = load i32, ptr %offset_ptr.i.i194, align 4
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %.fca.1.extract11, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %.fca.2.extract13, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %offset.i.i195, 3
  %offset.i.i209 = load i32, ptr %offset_ptr.i.i180, align 4
  %97 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, ptr %.fca.1.extract, 1
  %99 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %.fca.2.extract, 2
  %100 = insertvalue { ptr, ptr, ptr, i32 } %99, i32 %offset.i.i209, 3
  %101 = load ptr, ptr %51, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %101, 0
  %103 = load ptr, ptr %52, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 1
  %105 = getelementptr inbounds i8, ptr %51, i64 16
  %106 = load ptr, ptr %105, align 8
  %107 = insertvalue { ptr, ptr, ptr, i32 } %104, ptr %106, 2
  %108 = load i32, ptr %53, align 8
  %109 = insertvalue { ptr, ptr, ptr, i32 } %107, i32 %108, 3
  %110 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract57)
  %111 = load ptr, ptr %7, align 8
  %112 = call ptr %111(ptr %.fca.1.extract59)
  %result.i211 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %113 = getelementptr i8, ptr %result.i211, i64 8
  store ptr %112, ptr %113, align 8
  %114 = getelementptr i8, ptr %result.i211, i64 16
  store ptr null, ptr %114, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i211)
  store ptr @Iterator2, ptr %result.i211, align 8
  %result.i212 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %116 = getelementptr i8, ptr %result.i212, i64 8
  store ptr %112, ptr %116, align 8
  %117 = getelementptr i8, ptr %result.i212, i64 16
  store ptr null, ptr %117, align 8
  %118 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i212)
  store ptr @Iterator2, ptr %result.i212, align 8
  %119 = alloca [2 x ptr], align 8
  store ptr %result.i211, ptr %119, align 8
  %120 = getelementptr inbounds i8, ptr %119, i64 8
  store ptr %result.i212, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %119)
  %122 = call ptr @llvm.invariant.start.p0(i64 88, ptr %101)
  %123 = sext i32 %108 to i64
  %124 = getelementptr ptr, ptr %101, i64 %123
  %125 = getelementptr i8, ptr %124, i64 32
  %126 = load ptr, ptr %125, align 8
  %127 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract9, ptr %127, align 8
  %128 = getelementptr inbounds i8, ptr %127, i64 8
  store ptr %.fca.0.extract, ptr %128, align 8
  %129 = call ptr %126({ ptr, ptr, ptr, i32 } %109, ptr nonnull %127)
  call void %129({ ptr, ptr, ptr, i32 } %109, { ptr, ptr, ptr, i32 } %109, ptr nonnull %119, { ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %100)
  %130 = load ptr, ptr %51, align 8
  %131 = load ptr, ptr %52, align 8
  %132 = load ptr, ptr %105, align 8
  %hash_coef_ptr.i.i214 = getelementptr i8, ptr %130, i64 8
  %tbl_size_ptr.i.i215 = getelementptr i8, ptr %130, i64 16
  %offset_tbl_ptr.i.i216 = getelementptr i8, ptr %130, i64 40
  %hash_coef.i.i217 = load i64, ptr %hash_coef_ptr.i.i214, align 4
  %tbl_size.i.i218 = load i64, ptr %tbl_size_ptr.i.i215, align 4
  %offset_tbl.i.i219 = load ptr, ptr %offset_tbl_ptr.i.i216, align 8
  %product.i.i.i220 = mul i64 %hash_coef.i.i217, 4189192806087951739
  %shifted.i.i.i221 = lshr i64 %product.i.i.i220, 32
  %xored.i.i.i222 = xor i64 %shifted.i.i.i221, %product.i.i.i220
  %hash.i.i.i223 = and i64 %xored.i.i.i222, %tbl_size.i.i218
  %offset_ptr.i.i224 = getelementptr i32, ptr %offset_tbl.i.i219, i64 %hash.i.i.i223
  %offset.i.i225 = load i32, ptr %offset_ptr.i.i224, align 4
  %133 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %130, 0
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, ptr %131, 1
  %135 = insertvalue { ptr, ptr, ptr, i32 } %134, ptr %132, 2
  %136 = insertvalue { ptr, ptr, ptr, i32 } %135, i32 %offset.i.i225, 3
  ret { ptr, ptr, ptr, i32 } %136
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_ChainIterator2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterator2_field_ChainIterator2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator2_B_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ChainIterator2_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -228267985060461774
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract9)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract3, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract5, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %16)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4
  %17 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract9)
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract11, { ptr, ptr, ptr, i32 } %25)
  %26 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract9)
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract11, i1 true)
  ret void
}

define { ptr, i160 } @ChainIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -228267985060461774
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract3)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract3, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract4)
  %12 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr nonnull %.fca.0.extract3)
  br i1 %11, label %33, label %13

13:                                               ; preds = %3
  %14 = getelementptr i8, ptr %7, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = tail call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract4)
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract27 = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %hash_coef_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i34 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i32, align 4
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i33, align 4
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i34, align 8
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 4189192806087951739
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4
  %eq.i = icmp eq i32 %.fca.3.extract29, %offset.i.i43
  tail call void @llvm.assume(i1 %eq.i) #30
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract23, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract25, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract27, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract29, 3
  %22 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr nonnull %.fca.0.extract3)
  %23 = load ptr, ptr %7, align 8
  %24 = tail call ptr %23(ptr %.fca.1.extract4)
  %25 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %26 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract23)
  %27 = sext i32 %.fca.3.extract29 to i64
  %28 = getelementptr ptr, ptr %.fca.0.extract23, i64 %27
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  %31 = call ptr %30({ ptr, ptr, ptr, i32 } %21, ptr nonnull %4)
  %32 = call { ptr, i160 } %31({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull %4)
  %.fca.0.extract18 = extractvalue { ptr, i160 } %32, 0
  br label %60

33:                                               ; preds = %3
  %34 = getelementptr i8, ptr %7, i64 8
  %35 = load ptr, ptr %34, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = tail call { ptr, ptr, ptr, i32 } %36(ptr %.fca.1.extract4)
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %37, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %37, 1
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %37, 2
  %.fca.3.extract16 = extractvalue { ptr, ptr, ptr, i32 } %37, 3
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i56, align 4
  %eq.i60 = icmp eq i32 %.fca.3.extract16, %offset.i.i57
  tail call void @llvm.assume(i1 %eq.i60) #30
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %.fca.1.extract12, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.2.extract14, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %.fca.3.extract16, 3
  %42 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr nonnull %.fca.0.extract3)
  %43 = load ptr, ptr %7, align 8
  %44 = tail call ptr %43(ptr %.fca.1.extract4)
  %45 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %46 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract10)
  %47 = sext i32 %.fca.3.extract16 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract10, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr %50({ ptr, ptr, ptr, i32 } %41, ptr nonnull %4)
  %52 = call { ptr, i160 } %51({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull %4)
  %.fca.0.extract5 = extractvalue { ptr, i160 } %52, 0
  %53 = icmp eq ptr %.fca.0.extract5, @nil_typ
  %54 = icmp eq ptr %.fca.0.extract5, null
  %55 = or i1 %53, %54
  br i1 %55, label %._crit_edge.preheader, label %60

._crit_edge.preheader:                            ; preds = %33
  %56 = call ptr @llvm.invariant.start.p0(i64 88, ptr nonnull %.fca.0.extract3)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %._crit_edge
  %57 = load ptr, ptr %8, align 8
  %58 = getelementptr i8, ptr %57, i64 8
  %59 = load ptr, ptr %58, align 8
  call void %59(ptr %.fca.1.extract4, i1 false)
  br label %._crit_edge

60:                                               ; preds = %33, %13
  %.pn = phi { ptr, i160 } [ %32, %13 ], [ %52, %33 ]
  %.reg2mem19.sroa.0.0 = phi ptr [ %.fca.0.extract18, %13 ], [ %.fca.0.extract5, %33 ]
  %.reload20.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem19.sroa.0.0, 0
  %.reg2mem19.sroa.3.0 = extractvalue { ptr, i160 } %.pn, 1
  %.reload20.fca.1.insert = insertvalue { ptr, i160 } %.reload20.fca.0.insert, i160 %.reg2mem19.sroa.3.0, 1
  ret { ptr, i160 } %.reload20.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @ChainIterator2_getter_on_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_on_first(ptr nocapture writeonly %0, i1 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator2_getter_second(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_second(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator2_getter_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_first(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable2_getter_second(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable2_setter_second(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable2_getter_first(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable2_setter_first(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_FilterIterable2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterable2_field_FilterIterable2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_init_iterableIterable2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @FilterIterable2_init_iterableIterable2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 1178467452958968374
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 5693646204635713916
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract2)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract4, { ptr, ptr, ptr, i32 } %16)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract2)
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract4, { ptr } %4)
  ret void
}

define { ptr, ptr, ptr, i32 } @FilterIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 1178467452958968374
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract26)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract26, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract28)
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract24 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i35 = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i.i36 = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i.i37 = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i.i38 = load i64, ptr %hash_coef_ptr.i.i35, align 4
  %tbl_size.i.i39 = load i64, ptr %tbl_size_ptr.i.i36, align 4
  %offset_tbl.i.i40 = load ptr, ptr %offset_tbl_ptr.i.i37, align 8
  %product.i.i.i41 = mul i64 %hash_coef.i.i38, 5693646204635713916
  %shifted.i.i.i42 = lshr i64 %product.i.i.i41, 32
  %xored.i.i.i43 = xor i64 %shifted.i.i.i42, %product.i.i.i41
  %hash.i.i.i44 = and i64 %xored.i.i.i43, %tbl_size.i.i39
  %offset_ptr.i.i45 = getelementptr i32, ptr %offset_tbl.i.i40, i64 %hash.i.i.i44
  %offset.i.i46 = load i32, ptr %offset_ptr.i.i45, align 4
  %eq.i = icmp eq i32 %.fca.3.extract24, %offset.i.i46
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract20, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract22, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract24, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract26)
  %17 = load ptr, ptr %7, align 8
  %18 = tail call ptr %17(ptr %.fca.1.extract28)
  %19 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract18)
  %21 = sext i32 %.fca.3.extract24 to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract18, i64 %21
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr %24({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %26 = call { ptr, ptr, ptr, i32 } %25({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %27 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract26)
  %28 = getelementptr i8, ptr %7, i64 16
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %.fca.1.extract28)
  %32 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract26)
  %33 = load ptr, ptr %7, align 8
  %34 = call ptr %33(ptr %.fca.1.extract28)
  %result.i = call noalias dereferenceable_or_null(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nonnull @current_ptr) #29
  store ptr %34, ptr %result.i, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 8, ptr nonnull %result.i)
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  %37 = getelementptr inbounds i8, ptr %36, i64 8
  %38 = getelementptr inbounds i8, ptr %36, i64 24
  store ptr @FilterIterator2, ptr %36, align 8
  store ptr %result.i, ptr %37, align 8
  store i32 9, ptr %38, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %36)
  %40 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract26)
  %41 = load ptr, ptr %8, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call { ptr, ptr, ptr, i32 } %42(ptr %.fca.1.extract28)
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %43, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %43, 1
  %.fca.2.extract6 = extractvalue { ptr, ptr, ptr, i32 } %43, 2
  %.fca.3.extract8 = extractvalue { ptr, ptr, ptr, i32 } %43, 3
  %hash_coef_ptr.i.i63 = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i64 = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i65 = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i66 = load i64, ptr %hash_coef_ptr.i.i63, align 4
  %tbl_size.i.i67 = load i64, ptr %tbl_size_ptr.i.i64, align 4
  %offset_tbl.i.i68 = load ptr, ptr %offset_tbl_ptr.i.i65, align 8
  %product.i.i.i69 = mul i64 %hash_coef.i.i66, 5693646204635713916
  %shifted.i.i.i70 = lshr i64 %product.i.i.i69, 32
  %xored.i.i.i71 = xor i64 %shifted.i.i.i70, %product.i.i.i69
  %hash.i.i.i72 = and i64 %xored.i.i.i71, %tbl_size.i.i67
  %offset_ptr.i.i73 = getelementptr i32, ptr %offset_tbl.i.i68, i64 %hash.i.i.i72
  %offset.i.i74 = load i32, ptr %offset_ptr.i.i73, align 4
  %eq.i77 = icmp eq i32 %.fca.3.extract8, %offset.i.i74
  call void @llvm.assume(i1 %eq.i77) #30
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.1.extract4, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.2.extract6, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %.fca.3.extract8, 3
  %48 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract26)
  %49 = load ptr, ptr %7, align 8
  %50 = call ptr %49(ptr %.fca.1.extract28)
  %51 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %52 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract2)
  %53 = sext i32 %.fca.3.extract8 to i64
  %54 = getelementptr ptr, ptr %.fca.0.extract2, i64 %53
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  %57 = call ptr %56({ ptr, ptr, ptr, i32 } %47, ptr nonnull %4)
  %58 = call { ptr, ptr, ptr, i32 } %57({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull %4)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %58, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %58, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %58, 2
  %hash_coef_ptr.i.i79 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i80 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i81 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %59 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract26)
  %60 = load ptr, ptr %28, align 8
  %61 = load ptr, ptr %60, align 8
  %62 = call { ptr } %61(ptr %.fca.1.extract28)
  %hash_coef.i.i96 = load i64, ptr %hash_coef_ptr.i.i79, align 4
  %tbl_size.i.i97 = load i64, ptr %tbl_size_ptr.i.i80, align 4
  %offset_tbl.i.i98 = load ptr, ptr %offset_tbl_ptr.i.i81, align 8
  %product.i.i.i99 = mul i64 %hash_coef.i.i96, 4189192806087951739
  %shifted.i.i.i100 = lshr i64 %product.i.i.i99, 32
  %xored.i.i.i101 = xor i64 %shifted.i.i.i100, %product.i.i.i99
  %hash.i.i.i102 = and i64 %xored.i.i.i101, %tbl_size.i.i97
  %offset_ptr.i.i103 = getelementptr i32, ptr %offset_tbl.i.i98, i64 %hash.i.i.i102
  %offset.i.i104 = load i32, ptr %offset_ptr.i.i103, align 4
  %63 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr %.fca.1.extract, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %.fca.2.extract, 2
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %offset.i.i104, 3
  %67 = load ptr, ptr %36, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %67, 0
  %69 = load ptr, ptr %37, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %69, 1
  %71 = getelementptr inbounds i8, ptr %36, i64 16
  %72 = load ptr, ptr %71, align 8
  %73 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %72, 2
  %74 = load i32, ptr %38, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 %74, 3
  %76 = call ptr @llvm.invariant.start.p0(i64 400, ptr %.fca.0.extract26)
  %77 = load ptr, ptr %7, align 8
  %78 = call ptr %77(ptr %.fca.1.extract28)
  %result.i106 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %79 = getelementptr i8, ptr %result.i106, i64 8
  store ptr %78, ptr %79, align 8
  %80 = getelementptr i8, ptr %result.i106, i64 16
  store ptr null, ptr %80, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i106)
  store ptr @Iterator2, ptr %result.i106, align 8
  %result.i107 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %82 = getelementptr i8, ptr %result.i107, i64 16
  store ptr %78, ptr %82, align 8
  %83 = getelementptr i8, ptr %result.i107, i64 8
  store ptr @_parameterization_Ptri1, ptr %83, align 8
  %84 = getelementptr i8, ptr %result.i107, i64 24
  store ptr null, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i107)
  store ptr @function_typ, ptr %result.i107, align 8
  %86 = alloca [2 x ptr], align 8
  store ptr %result.i106, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %86, i64 8
  store ptr %result.i107, ptr %87, align 8
  %88 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %86)
  %89 = call ptr @llvm.invariant.start.p0(i64 80, ptr %67)
  %90 = sext i32 %74 to i64
  %91 = getelementptr ptr, ptr %67, i64 %90
  %92 = getelementptr i8, ptr %91, i64 24
  %93 = load ptr, ptr %92, align 8
  %94 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract1, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %94, i64 8
  store ptr @function_typ, ptr %95, align 8
  %96 = call ptr %93({ ptr, ptr, ptr, i32 } %75, ptr nonnull %94)
  call void %96({ ptr, ptr, ptr, i32 } %75, { ptr, ptr, ptr, i32 } %75, ptr nonnull %86, { ptr, ptr, ptr, i32 } %66, { ptr } %62)
  %97 = load ptr, ptr %36, align 8
  %98 = load ptr, ptr %37, align 8
  %99 = load ptr, ptr %71, align 8
  %hash_coef_ptr.i.i109 = getelementptr i8, ptr %97, i64 8
  %tbl_size_ptr.i.i110 = getelementptr i8, ptr %97, i64 16
  %offset_tbl_ptr.i.i111 = getelementptr i8, ptr %97, i64 40
  %hash_coef.i.i112 = load i64, ptr %hash_coef_ptr.i.i109, align 4
  %tbl_size.i.i113 = load i64, ptr %tbl_size_ptr.i.i110, align 4
  %offset_tbl.i.i114 = load ptr, ptr %offset_tbl_ptr.i.i111, align 8
  %product.i.i.i115 = mul i64 %hash_coef.i.i112, 4189192806087951739
  %shifted.i.i.i116 = lshr i64 %product.i.i.i115, 32
  %xored.i.i.i117 = xor i64 %shifted.i.i.i116, %product.i.i.i115
  %hash.i.i.i118 = and i64 %xored.i.i.i117, %tbl_size.i.i113
  %offset_ptr.i.i119 = getelementptr i32, ptr %offset_tbl.i.i114, i64 %hash.i.i.i118
  %offset.i.i120 = load i32, ptr %offset_ptr.i.i119, align 4
  %100 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %101 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %98, 1
  %102 = insertvalue { ptr, ptr, ptr, i32 } %101, ptr %99, 2
  %103 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %offset.i.i120, 3
  ret { ptr, ptr, ptr, i32 } %103
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_FilterIterator2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterator2_field_FilterIterator2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator2_B_init_iteratorIterator2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @FilterIterator2_init_iteratorIterator2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 8213847504843366470
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 4189192806087951739
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract2)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract4, { ptr, ptr, ptr, i32 } %16)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract2)
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract4, { ptr } %4)
  ret void
}

define { ptr, i160 } @FilterIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 8213847504843366470
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract14)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract16)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i49 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i50 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i51 = load i64, ptr %hash_coef_ptr.i.i48, align 4
  %tbl_size.i.i52 = load i64, ptr %tbl_size_ptr.i.i49, align 4
  %offset_tbl.i.i53 = load ptr, ptr %offset_tbl_ptr.i.i50, align 8
  %product.i.i.i54 = mul i64 %hash_coef.i.i51, 4189192806087951739
  %shifted.i.i.i55 = lshr i64 %product.i.i.i54, 32
  %xored.i.i.i56 = xor i64 %shifted.i.i.i55, %product.i.i.i54
  %hash.i.i.i57 = and i64 %xored.i.i.i56, %tbl_size.i.i52
  %offset_ptr.i.i58 = getelementptr i32, ptr %offset_tbl.i.i53, i64 %hash.i.i.i57
  %offset.i.i59 = load i32, ptr %offset_ptr.i.i58, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i59
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract14)
  %17 = load ptr, ptr %7, align 8
  %18 = tail call ptr %17(ptr %.fca.1.extract16)
  %19 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract1)
  %21 = sext i32 %.fca.3.extract to i64
  %22 = getelementptr ptr, ptr %.fca.0.extract1, i64 %21
  %23 = getelementptr i8, ptr %22, i64 8
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr %24({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %26 = call { ptr, i160 } %25({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %.sroa.0.0107 = extractvalue { ptr, i160 } %26, 0
  %27 = icmp ne ptr %.sroa.0.0107, @nil_typ
  %28 = icmp ne ptr %.sroa.0.0107, null
  %.not46109 = and i1 %27, %28
  br i1 %.not46109, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %29 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull %.fca.0.extract14)
  %30 = getelementptr i8, ptr %7, i64 16
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr } %32(ptr %.fca.1.extract16)
  %.fca.0.extract34117 = extractvalue { ptr } %33, 0
  %34 = call i1 %.fca.0.extract34117({ ptr, i160 } %26)
  br i1 %34, label %._crit_edge.loopexit, label %.lr.ph119.preheader

.lr.ph119.preheader:                              ; preds = %.lr.ph
  %35 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull %.fca.0.extract14)
  br label %.lr.ph119

36:                                               ; preds = %.lr.ph119
  %37 = load ptr, ptr %30, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr %.fca.1.extract16)
  %.fca.0.extract34 = extractvalue { ptr } %39, 0
  %40 = call i1 %.fca.0.extract34({ ptr, i160 } %58)
  br i1 %40, label %._crit_edge.loopexit, label %.lr.ph119

.lr.ph119:                                        ; preds = %.lr.ph119.preheader, %36
  %.pn110118 = phi { ptr, i160 } [ %58, %36 ], [ %26, %.lr.ph119.preheader ]
  %41 = load ptr, ptr %8, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call { ptr, ptr, ptr, i32 } %42(ptr %.fca.1.extract16)
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %43, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %43, 1
  %.fca.2.extract30 = extractvalue { ptr, ptr, ptr, i32 } %43, 2
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %43, 3
  %hash_coef_ptr.i.i62 = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i63 = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i64 = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i65 = load i64, ptr %hash_coef_ptr.i.i62, align 4
  %tbl_size.i.i66 = load i64, ptr %tbl_size_ptr.i.i63, align 4
  %offset_tbl.i.i67 = load ptr, ptr %offset_tbl_ptr.i.i64, align 8
  %product.i.i.i68 = mul i64 %hash_coef.i.i65, 4189192806087951739
  %shifted.i.i.i69 = lshr i64 %product.i.i.i68, 32
  %xored.i.i.i70 = xor i64 %shifted.i.i.i69, %product.i.i.i68
  %hash.i.i.i71 = and i64 %xored.i.i.i70, %tbl_size.i.i66
  %offset_ptr.i.i72 = getelementptr i32, ptr %offset_tbl.i.i67, i64 %hash.i.i.i71
  %offset.i.i73 = load i32, ptr %offset_ptr.i.i72, align 4
  %eq.i76 = icmp eq i32 %.fca.3.extract32, %offset.i.i73
  call void @llvm.assume(i1 %eq.i76) #30
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.1.extract28, 1
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.2.extract30, 2
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %.fca.3.extract32, 3
  %48 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull %.fca.0.extract14)
  %49 = load ptr, ptr %7, align 8
  %50 = call ptr %49(ptr %.fca.1.extract16)
  %51 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %52 = call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract26)
  %53 = sext i32 %.fca.3.extract32 to i64
  %54 = getelementptr ptr, ptr %.fca.0.extract26, i64 %53
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  %57 = call ptr %56({ ptr, ptr, ptr, i32 } %47, ptr nonnull %4)
  %58 = call { ptr, i160 } %57({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr nonnull %4)
  %.sroa.0.0 = extractvalue { ptr, i160 } %58, 0
  %59 = icmp ne ptr %.sroa.0.0, @nil_typ
  %60 = icmp ne ptr %.sroa.0.0, null
  %.not46 = and i1 %59, %60
  br i1 %.not46, label %36, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph119, %36, %.lr.ph
  %.pn110.lcssa = phi { ptr, i160 } [ %26, %.lr.ph ], [ %.pn110118, %.lr.ph119 ], [ %58, %36 ]
  %.ph = phi ptr [ %.sroa.0.0107, %.lr.ph ], [ @nil_typ, %.lr.ph119 ], [ %.sroa.0.0, %36 ]
  %.sroa.3.0112.le = extractvalue { ptr, i160 } %.pn110.lcssa, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.1.ph104 = phi i160 [ undef, %3 ], [ %.sroa.3.0112.le, %._crit_edge.loopexit ]
  %61 = phi ptr [ @nil_typ, %3 ], [ %.ph, %._crit_edge.loopexit ]
  %.reload15.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %61, 0
  %.reload15.fca.1.insert = insertvalue { ptr, i160 } %.reload15.fca.0.insert, i160 %.1.ph104, 1
  ret { ptr, i160 } %.reload15.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterator2_getter_f(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator2_setter_f(ptr nocapture writeonly %0, { ptr } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterator2_getter_iterator(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator2_setter_iterator(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterable2_getter_f(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable2_setter_f(ptr nocapture writeonly %0, { ptr } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterable2_getter_iterable(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable2_setter_iterable(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_MapIterable2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable2_field_MapIterable2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable2_field_MapIterable2_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_init_iterableIterable2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @MapIterable2_init_iterableIterable2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -1724859134596891929
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 5693646204635713916
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract2)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract4, { ptr, ptr, ptr, i32 } %16)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract2)
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract4, { ptr } %4)
  ret void
}

define { ptr, ptr, ptr, i32 } @MapIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -1724859134596891929
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract26, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract28)
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract24 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i35 = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i.i36 = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i.i37 = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i.i38 = load i64, ptr %hash_coef_ptr.i.i35, align 4
  %tbl_size.i.i39 = load i64, ptr %tbl_size_ptr.i.i36, align 4
  %offset_tbl.i.i40 = load ptr, ptr %offset_tbl_ptr.i.i37, align 8
  %product.i.i.i41 = mul i64 %hash_coef.i.i38, 5693646204635713916
  %shifted.i.i.i42 = lshr i64 %product.i.i.i41, 32
  %xored.i.i.i43 = xor i64 %shifted.i.i.i42, %product.i.i.i41
  %hash.i.i.i44 = and i64 %xored.i.i.i43, %tbl_size.i.i39
  %offset_ptr.i.i45 = getelementptr i32, ptr %offset_tbl.i.i40, i64 %hash.i.i.i44
  %offset.i.i46 = load i32, ptr %offset_ptr.i.i45, align 4
  %eq.i = icmp eq i32 %.fca.3.extract24, %offset.i.i46
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract20, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract22, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract24, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %17 = load ptr, ptr %7, align 8
  %18 = tail call ptr %17(ptr %.fca.1.extract28)
  %19 = tail call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %20 = getelementptr i8, ptr %7, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call ptr %21(ptr %.fca.1.extract28)
  %23 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %24 = tail call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract18)
  %25 = sext i32 %.fca.3.extract24 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract18, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr %28({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %30 = call { ptr, ptr, ptr, i32 } %29({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %31 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %32 = getelementptr i8, ptr %7, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr %.fca.1.extract28)
  %36 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %37 = load ptr, ptr %7, align 8
  %38 = call ptr %37(ptr %.fca.1.extract28)
  %39 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %40 = load ptr, ptr %20, align 8
  %41 = call ptr %40(ptr %.fca.1.extract28)
  %result.i = call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nonnull @current_ptr) #29
  store ptr %38, ptr %result.i, align 8
  %42 = getelementptr i8, ptr %result.i, i64 8
  store ptr %41, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %result.i)
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = getelementptr inbounds i8, ptr %44, i64 8
  %46 = getelementptr inbounds i8, ptr %44, i64 24
  store ptr @MapIterator2, ptr %44, align 8
  store ptr %result.i, ptr %45, align 8
  store i32 9, ptr %46, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %44)
  %48 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %49 = load ptr, ptr %8, align 8
  %50 = load ptr, ptr %49, align 8
  %51 = call { ptr, ptr, ptr, i32 } %50(ptr %.fca.1.extract28)
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %51, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %51, 1
  %.fca.2.extract6 = extractvalue { ptr, ptr, ptr, i32 } %51, 2
  %.fca.3.extract8 = extractvalue { ptr, ptr, ptr, i32 } %51, 3
  %hash_coef_ptr.i.i63 = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i64 = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i65 = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i66 = load i64, ptr %hash_coef_ptr.i.i63, align 4
  %tbl_size.i.i67 = load i64, ptr %tbl_size_ptr.i.i64, align 4
  %offset_tbl.i.i68 = load ptr, ptr %offset_tbl_ptr.i.i65, align 8
  %product.i.i.i69 = mul i64 %hash_coef.i.i66, 5693646204635713916
  %shifted.i.i.i70 = lshr i64 %product.i.i.i69, 32
  %xored.i.i.i71 = xor i64 %shifted.i.i.i70, %product.i.i.i69
  %hash.i.i.i72 = and i64 %xored.i.i.i71, %tbl_size.i.i67
  %offset_ptr.i.i73 = getelementptr i32, ptr %offset_tbl.i.i68, i64 %hash.i.i.i72
  %offset.i.i74 = load i32, ptr %offset_ptr.i.i73, align 4
  %eq.i77 = icmp eq i32 %.fca.3.extract8, %offset.i.i74
  call void @llvm.assume(i1 %eq.i77) #30
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %.fca.1.extract4, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %.fca.2.extract6, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %.fca.3.extract8, 3
  %56 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %57 = load ptr, ptr %7, align 8
  %58 = call ptr %57(ptr %.fca.1.extract28)
  %59 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %60 = load ptr, ptr %20, align 8
  %61 = call ptr %60(ptr %.fca.1.extract28)
  %62 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %63 = call ptr @llvm.invariant.start.p0(i64 184, ptr %.fca.0.extract2)
  %64 = sext i32 %.fca.3.extract8 to i64
  %65 = getelementptr ptr, ptr %.fca.0.extract2, i64 %64
  %66 = getelementptr i8, ptr %65, i64 8
  %67 = load ptr, ptr %66, align 8
  %68 = call ptr %67({ ptr, ptr, ptr, i32 } %55, ptr nonnull %4)
  %69 = call { ptr, ptr, ptr, i32 } %68({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull %4)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %69, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %69, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %69, 2
  %hash_coef_ptr.i.i79 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i80 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i81 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %70 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %71 = load ptr, ptr %32, align 8
  %72 = load ptr, ptr %71, align 8
  %73 = call { ptr } %72(ptr %.fca.1.extract28)
  %hash_coef.i.i96 = load i64, ptr %hash_coef_ptr.i.i79, align 4
  %tbl_size.i.i97 = load i64, ptr %tbl_size_ptr.i.i80, align 4
  %offset_tbl.i.i98 = load ptr, ptr %offset_tbl_ptr.i.i81, align 8
  %product.i.i.i99 = mul i64 %hash_coef.i.i96, 4189192806087951739
  %shifted.i.i.i100 = lshr i64 %product.i.i.i99, 32
  %xored.i.i.i101 = xor i64 %shifted.i.i.i100, %product.i.i.i99
  %hash.i.i.i102 = and i64 %xored.i.i.i101, %tbl_size.i.i97
  %offset_ptr.i.i103 = getelementptr i32, ptr %offset_tbl.i.i98, i64 %hash.i.i.i102
  %offset.i.i104 = load i32, ptr %offset_ptr.i.i103, align 4
  %74 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %.fca.1.extract, 1
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %.fca.2.extract, 2
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %offset.i.i104, 3
  %78 = load ptr, ptr %44, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = load ptr, ptr %45, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 1
  %82 = getelementptr inbounds i8, ptr %44, i64 16
  %83 = load ptr, ptr %82, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %83, 2
  %85 = load i32, ptr %46, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, i32 %85, 3
  %87 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %88 = load ptr, ptr %7, align 8
  %89 = call ptr %88(ptr %.fca.1.extract28)
  %90 = call ptr @llvm.invariant.start.p0(i64 408, ptr %.fca.0.extract26)
  %91 = load ptr, ptr %20, align 8
  %92 = call ptr %91(ptr %.fca.1.extract28)
  %result.i106 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nonnull @current_ptr) #29
  %93 = getelementptr i8, ptr %result.i106, i64 8
  store ptr %89, ptr %93, align 8
  %94 = getelementptr i8, ptr %result.i106, i64 16
  store ptr null, ptr %94, align 8
  %95 = call ptr @llvm.invariant.start.p0(i64 16, ptr %result.i106)
  store ptr @Iterator2, ptr %result.i106, align 8
  %result.i107 = call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nonnull @current_ptr) #29
  %96 = getelementptr i8, ptr %result.i107, i64 16
  store ptr %89, ptr %96, align 8
  %97 = getelementptr i8, ptr %result.i107, i64 8
  store ptr %92, ptr %97, align 8
  %98 = getelementptr i8, ptr %result.i107, i64 24
  store ptr null, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 24, ptr %result.i107)
  store ptr @function_typ, ptr %result.i107, align 8
  %100 = alloca [2 x ptr], align 8
  store ptr %result.i106, ptr %100, align 8
  %101 = getelementptr inbounds i8, ptr %100, i64 8
  store ptr %result.i107, ptr %101, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 4, ptr nonnull %100)
  %103 = call ptr @llvm.invariant.start.p0(i64 88, ptr %78)
  %104 = sext i32 %85 to i64
  %105 = getelementptr ptr, ptr %78, i64 %104
  %106 = getelementptr i8, ptr %105, i64 32
  %107 = load ptr, ptr %106, align 8
  %108 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract1, ptr %108, align 8
  %109 = getelementptr inbounds i8, ptr %108, i64 8
  store ptr @function_typ, ptr %109, align 8
  %110 = call ptr %107({ ptr, ptr, ptr, i32 } %86, ptr nonnull %108)
  call void %110({ ptr, ptr, ptr, i32 } %86, { ptr, ptr, ptr, i32 } %86, ptr nonnull %100, { ptr, ptr, ptr, i32 } %77, { ptr } %73)
  %111 = load ptr, ptr %44, align 8
  %112 = load ptr, ptr %45, align 8
  %113 = load ptr, ptr %82, align 8
  %hash_coef_ptr.i.i109 = getelementptr i8, ptr %111, i64 8
  %tbl_size_ptr.i.i110 = getelementptr i8, ptr %111, i64 16
  %offset_tbl_ptr.i.i111 = getelementptr i8, ptr %111, i64 40
  %hash_coef.i.i112 = load i64, ptr %hash_coef_ptr.i.i109, align 4
  %tbl_size.i.i113 = load i64, ptr %tbl_size_ptr.i.i110, align 4
  %offset_tbl.i.i114 = load ptr, ptr %offset_tbl_ptr.i.i111, align 8
  %product.i.i.i115 = mul i64 %hash_coef.i.i112, 4189192806087951739
  %shifted.i.i.i116 = lshr i64 %product.i.i.i115, 32
  %xored.i.i.i117 = xor i64 %shifted.i.i.i116, %product.i.i.i115
  %hash.i.i.i118 = and i64 %xored.i.i.i117, %tbl_size.i.i113
  %offset_ptr.i.i119 = getelementptr i32, ptr %offset_tbl.i.i114, i64 %hash.i.i.i118
  %offset.i.i120 = load i32, ptr %offset_ptr.i.i119, align 4
  %114 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %111, 0
  %115 = insertvalue { ptr, ptr, ptr, i32 } %114, ptr %112, 1
  %116 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %113, 2
  %117 = insertvalue { ptr, ptr, ptr, i32 } %116, i32 %offset.i.i120, 3
  ret { ptr, ptr, ptr, i32 } %117
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_MapIterator2(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator2_field_MapIterator2_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator2_field_MapIterator2_1(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator2_B_init_iteratorIterator2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @MapIterator2_init_iteratorIterator2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -10255947709272500
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 4189192806087951739
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract2)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract4, { ptr, ptr, ptr, i32 } %16)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract2)
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract4, { ptr } %4)
  ret void
}

define { ptr, i160 } @MapIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -10255947709272500
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract12)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract12, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract14)
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i35 = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i36 = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i37 = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i38 = load i64, ptr %hash_coef_ptr.i.i35, align 4
  %tbl_size.i.i39 = load i64, ptr %tbl_size_ptr.i.i36, align 4
  %offset_tbl.i.i40 = load ptr, ptr %offset_tbl_ptr.i.i37, align 8
  %product.i.i.i41 = mul i64 %hash_coef.i.i38, 4189192806087951739
  %shifted.i.i.i42 = lshr i64 %product.i.i.i41, 32
  %xored.i.i.i43 = xor i64 %shifted.i.i.i42, %product.i.i.i41
  %hash.i.i.i44 = and i64 %xored.i.i.i43, %tbl_size.i.i39
  %offset_ptr.i.i45 = getelementptr i32, ptr %offset_tbl.i.i40, i64 %hash.i.i.i44
  %offset.i.i46 = load i32, ptr %offset_ptr.i.i45, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i46
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract12)
  %17 = load ptr, ptr %7, align 8
  %18 = tail call ptr %17(ptr %.fca.1.extract14)
  %19 = tail call ptr @llvm.invariant.start.p0(i64 88, ptr %.fca.0.extract12)
  %20 = getelementptr i8, ptr %7, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call ptr %21(ptr %.fca.1.extract14)
  %23 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %24 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %.fca.0.extract2)
  %25 = sext i32 %.fca.3.extract to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract2, i64 %25
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr %28({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %30 = call { ptr, i160 } %29({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr, i160 } %30, 0
  %31 = icmp ne ptr %.fca.0.extract, @nil_typ
  %32 = icmp ne ptr %.fca.0.extract, null
  %.not33 = and i1 %31, %32
  br i1 %.not33, label %33, label %40

33:                                               ; preds = %3
  %34 = call ptr @llvm.invariant.start.p0(i64 88, ptr nonnull %.fca.0.extract12)
  %35 = getelementptr i8, ptr %7, i64 24
  %36 = load ptr, ptr %35, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr } %37(ptr %.fca.1.extract14)
  %.fca.0.extract25 = extractvalue { ptr } %38, 0
  %39 = call { ptr, i160 } %.fca.0.extract25({ ptr, i160 } %30)
  %.fca.0.extract20 = extractvalue { ptr, i160 } %39, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %39, 1
  br label %40

40:                                               ; preds = %3, %33
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract20, %33 ], [ @nil_typ, %3 ]
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract22, %33 ], [ undef, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterator2_getter_f(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator2_setter_f(ptr nocapture writeonly %0, { ptr } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterator2_getter_iterator(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator2_setter_iterator(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterable2_getter_f(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable2_setter_f(ptr nocapture writeonly %0, { ptr } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterable2_getter_iterable(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable2_setter_iterable(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_ArrayIterator(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract1)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i35, 3
  tail call void %11(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %15)
  %16 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract1)
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract3, i32 0)
  ret void
}

define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract9)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract9, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract11)
  %14 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract9)
  %15 = getelementptr i8, ptr %9, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract11)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %hash_coef_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i34 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i32, align 4
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i33, align 4
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i34, align 8
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, -5261542750394134544
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i43
  tail call void @llvm.assume(i1 %eq.i) #30
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract, 3
  %23 = tail call ptr @llvm.invariant.start.p0(i64 80, ptr %.fca.0.extract9)
  %24 = load ptr, ptr %9, align 8
  %25 = tail call ptr %24(ptr %.fca.1.extract11)
  %26 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %27 = tail call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract)
  %28 = sext i32 %.fca.3.extract to i64
  %29 = getelementptr ptr, ptr %.fca.0.extract, i64 %28
  %30 = getelementptr i8, ptr %29, i64 64
  %31 = load ptr, ptr %30, align 8
  %32 = call ptr %31({ ptr, ptr, ptr, i32 } %22, ptr nonnull %4)
  %33 = call i32 %32({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull %4)
  %.not = icmp slt i32 %13, %33
  br i1 %.not, label %34, label %68

34:                                               ; preds = %3
  %35 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull %.fca.0.extract9)
  %36 = load ptr, ptr %10, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call i32 %37(ptr %.fca.1.extract11)
  %39 = add i32 %38, 1
  %40 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull %.fca.0.extract9)
  %41 = load ptr, ptr %10, align 8
  %42 = getelementptr i8, ptr %41, i64 8
  %43 = load ptr, ptr %42, align 8
  call void %43(ptr %.fca.1.extract11, i32 %39)
  %44 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull %.fca.0.extract9)
  %45 = load ptr, ptr %10, align 8
  %46 = load ptr, ptr %45, align 8
  %47 = call i32 %46(ptr %.fca.1.extract11)
  %48 = add i32 %47, -1
  %49 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull %.fca.0.extract9)
  %50 = load ptr, ptr %15, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = call { ptr, ptr, ptr, i32 } %51(ptr %.fca.1.extract11)
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %52, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %52, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %52, 2
  %.fca.3.extract27 = extractvalue { ptr, ptr, ptr, i32 } %52, 3
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, -5261542750394134544
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i56, align 4
  %eq.i60 = icmp eq i32 %.fca.3.extract27, %offset.i.i57
  call void @llvm.assume(i1 %eq.i60) #30
  %53 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %.fca.1.extract23, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %.fca.2.extract25, 2
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 %.fca.3.extract27, 3
  %57 = call ptr @llvm.invariant.start.p0(i64 80, ptr nonnull %.fca.0.extract9)
  %58 = load ptr, ptr %9, align 8
  %59 = call ptr %58(ptr %.fca.1.extract11)
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %60 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %5)
  %61 = call ptr @llvm.invariant.start.p0(i64 600, ptr %.fca.0.extract21)
  %62 = sext i32 %.fca.3.extract27 to i64
  %63 = getelementptr ptr, ptr %.fca.0.extract21, i64 %62
  %64 = getelementptr i8, ptr %63, i64 120
  %65 = load ptr, ptr %64, align 8
  store ptr @i32_typ, ptr %6, align 8
  %66 = call ptr %65({ ptr, ptr, ptr, i32 } %56, ptr nonnull %6)
  %67 = call { ptr, i160 } %66({ ptr, ptr, ptr, i32 } %56, { ptr, ptr, ptr, i32 } %56, ptr nonnull %5, i32 %48)
  %.fca.0.extract17 = extractvalue { ptr, i160 } %67, 0
  %.fca.1.extract19 = extractvalue { ptr, i160 } %67, 1
  br label %68

68:                                               ; preds = %3, %34
  %.reg2mem5.sroa.3.0 = phi i160 [ %.fca.1.extract19, %34 ], [ undef, %3 ]
  %.reg2mem5.sroa.0.0 = phi ptr [ %.fca.0.extract17, %34 ], [ @nil_typ, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture writeonly %0, { ptr } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Iterator2_field_Iterator2_0(ptr nocapture readonly %0) local_unnamed_addr #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Iterable2_field_Iterable2_0(ptr nocapture readonly %0) local_unnamed_addr #0 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Object(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Iterator(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Iterable(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Representable(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 80
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) #7 {
  %result.i = tail call noalias dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nonnull @current_ptr) #29
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %result.i, align 8
  %result.i1 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i1, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 9, 3
  store ptr %result.i, ptr %result.i1, align 8
  %7 = getelementptr i8, ptr %result.i1, i64 8
  store i32 6, ptr %7, align 4
  %8 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %9 = getelementptr i8, ptr %result.i1, i64 12
  store i32 7, ptr %9, align 4
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_String(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferPtri8_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 24, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_bytes_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_xPtri8({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_extend_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_pop_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %result.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nonnull @current_ptr) #29
  %4 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %9(ptr %.fca.1.extract, { ptr } %10)
  %11 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %12 = getelementptr i8, ptr %6, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 1)
  %16 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, i32 0)
  ret void
}

define void @String_init_bytesBufferPtri8_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr } %3, i32 %4, i32 %5) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract1, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3)
  %13 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4)
  %18 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 %5)
  ret void
}

define i32 @String_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract)
  ret i32 %10
}

define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract)
  ret i32 %10
}

define { ptr } @String_bytes_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract1, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { ptr } %8(ptr %.fca.1.extract)
  ret { ptr } %9
}

define { ptr, ptr, ptr, i32 } @String_append_xPtri8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i8 %3) {
  %.sroa.079 = alloca ptr, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %.sroa.075 = alloca ptr, align 8
  %.sroa.176 = alloca ptr, align 8
  %.sroa.277 = alloca ptr, align 8
  %.sroa.378 = alloca i32, align 8
  %.sroa.074 = alloca ptr, align 8
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %.sroa.073 = alloca ptr, align 8
  %.sroa.1 = alloca ptr, align 8
  %.sroa.2 = alloca ptr, align 8
  %.sroa.3 = alloca i32, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %13 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call i32 %18(ptr %.fca.1.extract)
  %20 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %21 = getelementptr i8, ptr %15, i64 16
  %22 = load ptr, ptr %21, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = tail call i32 %23(ptr %.fca.1.extract)
  %25 = icmp slt i32 %19, %24
  br i1 %25, label %.thread, label %26

26:                                               ; preds = %4
  %27 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %28 = load ptr, ptr %21, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call i32 %29(ptr %.fca.1.extract)
  %31 = shl i32 %30, 1
  %32 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %33 = load ptr, ptr %21, align 8
  %34 = getelementptr i8, ptr %33, i64 8
  %35 = load ptr, ptr %34, align 8
  tail call void %35(ptr %.fca.1.extract, i32 %31)
  %36 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %37 = load ptr, ptr %15, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = tail call { ptr } %38(ptr %.fca.1.extract)
  %.fca.0.extract7 = extractvalue { ptr } %39, 0
  %40 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %41 = load ptr, ptr %21, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = tail call i32 %42(ptr %.fca.1.extract)
  %44 = sext i32 %43 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %44, ptr nonnull @current_ptr) #29
  %45 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %46 = load ptr, ptr %15, align 8
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %49 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %48(ptr %.fca.1.extract, { ptr } %49)
  %50 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %51 = load ptr, ptr %16, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = tail call i32 %52(ptr %.fca.1.extract)
  %54 = icmp sgt i32 %53, 0
  br i1 %54, label %.lr.ph, label %.thread

.lr.ph:                                           ; preds = %26
  %55 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %.lr.ph, %._crit_edge
  %.reg2mem42.081 = phi i32 [ 0, %.lr.ph ], [ %63, %._crit_edge ]
  %56 = zext nneg i32 %.reg2mem42.081 to i64
  %57 = getelementptr i8, ptr %.fca.0.extract7, i64 %56
  %58 = load ptr, ptr %15, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = tail call { ptr } %59(ptr %.fca.1.extract)
  %.fca.0.extract4 = extractvalue { ptr } %60, 0
  %61 = getelementptr i8, ptr %.fca.0.extract4, i64 %56
  %62 = load i8, ptr %57, align 1
  store i8 %62, ptr %61, align 1
  %63 = add nuw nsw i32 %.reg2mem42.081, 1
  %64 = load ptr, ptr %16, align 8
  %65 = load ptr, ptr %64, align 8
  %66 = tail call i32 %65(ptr %.fca.1.extract)
  %67 = icmp slt i32 %63, %66
  br i1 %67, label %._crit_edge, label %.thread

.thread:                                          ; preds = %._crit_edge, %26, %4
  %.sroa.phi = phi ptr [ %.sroa.176, %4 ], [ %.sroa.1, %26 ], [ %.sroa.1, %._crit_edge ]
  %.sroa.phi64 = phi ptr [ %.sroa.277, %4 ], [ %.sroa.2, %26 ], [ %.sroa.2, %._crit_edge ]
  %.sroa.phi67 = phi ptr [ %.sroa.378, %4 ], [ %.sroa.3, %26 ], [ %.sroa.3, %._crit_edge ]
  %68 = phi ptr [ %.sroa.075, %4 ], [ %.sroa.073, %26 ], [ %.sroa.073, %._crit_edge ]
  %69 = phi ptr [ %8, %4 ], [ %12, %26 ], [ %12, %._crit_edge ]
  %70 = phi ptr [ %7, %4 ], [ %11, %26 ], [ %11, %._crit_edge ]
  %71 = phi ptr [ %6, %4 ], [ %10, %26 ], [ %10, %._crit_edge ]
  %72 = phi ptr [ %5, %4 ], [ %9, %26 ], [ %9, %._crit_edge ]
  %73 = phi ptr [ %.sroa.079, %4 ], [ %.sroa.074, %26 ], [ %.sroa.074, %._crit_edge ]
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %74 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %75 = load ptr, ptr %15, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = tail call { ptr } %76(ptr %.fca.1.extract)
  %78 = extractvalue { ptr } %77, 0
  store ptr %78, ptr %73, align 8
  %79 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %80 = load ptr, ptr %16, align 8
  %81 = load ptr, ptr %80, align 8
  %82 = tail call i32 %81(ptr %.fca.1.extract)
  store i32 %82, ptr %72, align 4
  %83 = load ptr, ptr %73, align 8
  %84 = sext i32 %82 to i64
  %85 = getelementptr i8, ptr %83, i64 %84
  store i8 %3, ptr %85, align 1
  %86 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %87 = load ptr, ptr %16, align 8
  %88 = load ptr, ptr %87, align 8
  %89 = tail call i32 %88(ptr %.fca.1.extract)
  store i32 %89, ptr %71, align 4
  store i32 1, ptr %70, align 4
  %90 = add i32 %89, 1
  store i32 %90, ptr %69, align 4
  %91 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %92 = load ptr, ptr %16, align 8
  %93 = getelementptr i8, ptr %92, i64 8
  %94 = load ptr, ptr %93, align 8
  tail call void %94(ptr %.fca.1.extract, i32 %90)
  store ptr %.fca.0.extract, ptr %68, align 8
  store ptr %.fca.1.extract, ptr %.sroa.phi, align 8
  store ptr %.fca.2.extract, ptr %.sroa.phi64, align 8
  store i32 %offset.i.i, ptr %.sroa.phi67, align 8
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 6499063144389013426
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i22 = load i32, ptr %offset_ptr.i.i21, align 4
  store i32 %offset.i.i22, ptr %.sroa.phi67, align 8
  %95 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, ptr %.fca.1.extract, 1
  %97 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %.fca.2.extract, 2
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, i32 %offset.i.i22, 3
  ret { ptr, ptr, ptr, i32 } %98
}

define { ptr, ptr, ptr, i32 } @String_extend_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %.sroa.0130 = alloca ptr, align 8
  %.sroa.1131 = alloca ptr, align 8
  %.sroa.2132 = alloca ptr, align 8
  %.sroa.3133 = alloca i32, align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %.sroa.0129 = alloca ptr, align 8
  %.sroa.1 = alloca ptr, align 8
  %.sroa.2 = alloca ptr, align 8
  %.sroa.3 = alloca i32, align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i40 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i42 = load i64, ptr %hash_coef_ptr.i.i39, align 4
  %tbl_size.i.i43 = load i64, ptr %tbl_size_ptr.i.i40, align 4
  %offset_tbl.i.i44 = load ptr, ptr %offset_tbl_ptr.i.i41, align 8
  %product.i.i.i45 = mul i64 %hash_coef.i.i42, 6499063144389013426
  %shifted.i.i.i46 = lshr i64 %product.i.i.i45, 32
  %xored.i.i.i47 = xor i64 %shifted.i.i.i46, %product.i.i.i45
  %hash.i.i.i48 = and i64 %xored.i.i.i47, %tbl_size.i.i43
  %offset_ptr.i.i49 = getelementptr i32, ptr %offset_tbl.i.i44, i64 %hash.i.i.i48
  %offset.i.i50 = load i32, ptr %offset_ptr.i.i49, align 4
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i.i50, 3
  %15 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %16 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %17 = sext i32 %offset.i.i50 to i64
  %18 = getelementptr ptr, ptr %.fca.0.extract1, i64 %17
  %19 = getelementptr i8, ptr %18, i64 56
  %20 = load ptr, ptr %19, align 8
  %21 = call ptr %20({ ptr, ptr, ptr, i32 } %14, ptr nonnull %5)
  %22 = call { ptr } %21({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull %5)
  %.fca.0.extract = extractvalue { ptr } %22, 0
  %23 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %23, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %23)
  %25 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %26 = call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %27 = getelementptr i8, ptr %18, i64 40
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr %28({ ptr, ptr, ptr, i32 } %14, ptr nonnull %5)
  %30 = call i32 %29({ ptr, ptr, ptr, i32 } %14, { ptr, ptr, ptr, i32 } %14, ptr nonnull %5)
  %31 = call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract17)
  %32 = sext i32 %offset.i.i to i64
  %33 = getelementptr ptr, ptr %.fca.0.extract17, i64 %32
  %34 = getelementptr i8, ptr %33, i64 8
  %35 = load ptr, ptr %34, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call i32 %36(ptr %.fca.1.extract19)
  %38 = add i32 %37, %30
  %39 = call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract17)
  %40 = getelementptr i8, ptr %33, i64 16
  %41 = load ptr, ptr %40, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = call i32 %42(ptr %.fca.1.extract19)
  %44 = icmp slt i32 %38, %43
  %45 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %46 = load ptr, ptr %34, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call i32 %47(ptr %.fca.1.extract19)
  br i1 %44, label %49, label %73

49:                                               ; preds = %4
  %50 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %51 = load ptr, ptr %34, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr %.fca.1.extract19)
  %54 = add i32 %53, %30
  %55 = icmp slt i32 %48, %54
  br i1 %55, label %.lr.ph146, label %.thread

.lr.ph146:                                        ; preds = %49
  %56 = load ptr, ptr %23, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  br label %._crit_edge

._crit_edge:                                      ; preds = %.lr.ph146, %._crit_edge
  %.reg2mem97.0144 = phi i32 [ %48, %.lr.ph146 ], [ %66, %._crit_edge ]
  %.reg2mem95.0143 = phi i32 [ 0, %.lr.ph146 ], [ %67, %._crit_edge ]
  %58 = sext i32 %.reg2mem95.0143 to i64
  %59 = getelementptr i8, ptr %56, i64 %58
  %60 = load ptr, ptr %33, align 8
  %61 = load ptr, ptr %60, align 8
  %62 = call { ptr } %61(ptr %.fca.1.extract19)
  %.fca.0.extract35 = extractvalue { ptr } %62, 0
  %63 = sext i32 %.reg2mem97.0144 to i64
  %64 = getelementptr i8, ptr %.fca.0.extract35, i64 %63
  %65 = load i8, ptr %59, align 1
  store i8 %65, ptr %64, align 1
  %66 = add nsw i32 %.reg2mem97.0144, 1
  %67 = add i32 %.reg2mem95.0143, 1
  %68 = load ptr, ptr %34, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = call i32 %69(ptr %.fca.1.extract19)
  %71 = add i32 %70, %30
  %72 = icmp slt i32 %66, %71
  br i1 %72, label %._crit_edge, label %.thread

73:                                               ; preds = %4
  %74 = add i32 %48, %30
  %75 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %76 = load ptr, ptr %40, align 8
  %77 = getelementptr i8, ptr %76, i64 8
  %78 = load ptr, ptr %77, align 8
  call void %78(ptr %.fca.1.extract19, i32 %74)
  %79 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %80 = load ptr, ptr %33, align 8
  %81 = load ptr, ptr %80, align 8
  %82 = call { ptr } %81(ptr %.fca.1.extract19)
  %.fca.0.extract32 = extractvalue { ptr } %82, 0
  store ptr %.fca.0.extract32, ptr %8, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %8)
  %84 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %85 = load ptr, ptr %40, align 8
  %86 = load ptr, ptr %85, align 8
  %87 = call i32 %86(ptr %.fca.1.extract19)
  %88 = sext i32 %87 to i64
  %result.i = call noalias ptr @bump_malloc_inner(i64 noundef %88, ptr nonnull @current_ptr) #29
  %89 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %90 = load ptr, ptr %33, align 8
  %91 = getelementptr i8, ptr %90, i64 8
  %92 = load ptr, ptr %91, align 8
  %93 = insertvalue { ptr } undef, ptr %result.i, 0
  call void %92(ptr %.fca.1.extract19, { ptr } %93)
  %94 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %95 = load ptr, ptr %34, align 8
  %96 = load ptr, ptr %95, align 8
  %97 = call i32 %96(ptr %.fca.1.extract19)
  %98 = add i32 %97, %30
  %99 = icmp sgt i32 %98, 0
  br i1 %99, label %.lr.ph, label %.thread

.lr.ph:                                           ; preds = %73
  %100 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %101 = load ptr, ptr %23, align 8
  %102 = load ptr, ptr %8, align 8
  br label %103

103:                                              ; preds = %.lr.ph, %._crit_edge1
  %.reg2mem89.0141 = phi i32 [ 0, %.lr.ph ], [ %.reg2mem85.0, %._crit_edge1 ]
  %.reg2mem87.0140 = phi i32 [ 0, %.lr.ph ], [ %.reg2mem83.0, %._crit_edge1 ]
  %104 = load ptr, ptr %34, align 8
  %105 = load ptr, ptr %104, align 8
  %106 = call i32 %105(ptr %.fca.1.extract19)
  %107 = icmp slt i32 %.reg2mem89.0141, %106
  %108 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %109 = load ptr, ptr %33, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = call { ptr } %110(ptr %.fca.1.extract19)
  %.fca.0.extract28 = extractvalue { ptr } %111, 0
  br i1 %107, label %112, label %117

112:                                              ; preds = %103
  %113 = zext nneg i32 %.reg2mem89.0141 to i64
  %114 = getelementptr i8, ptr %102, i64 %113
  %115 = getelementptr i8, ptr %.fca.0.extract28, i64 %113
  %116 = load i8, ptr %114, align 1
  store i8 %116, ptr %115, align 1
  br label %._crit_edge1

117:                                              ; preds = %103
  %118 = sext i32 %.reg2mem87.0140 to i64
  %119 = getelementptr i8, ptr %101, i64 %118
  %120 = zext nneg i32 %.reg2mem89.0141 to i64
  %121 = getelementptr i8, ptr %.fca.0.extract28, i64 %120
  %122 = load i8, ptr %119, align 1
  store i8 %122, ptr %121, align 1
  %123 = add i32 %.reg2mem87.0140, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %112, %117
  %.reg2mem83.0 = phi i32 [ %.reg2mem87.0140, %112 ], [ %123, %117 ]
  %.reg2mem85.0 = add nuw nsw i32 %.reg2mem89.0141, 1
  %124 = load ptr, ptr %34, align 8
  %125 = load ptr, ptr %124, align 8
  %126 = call i32 %125(ptr %.fca.1.extract19)
  %127 = add i32 %126, %30
  %128 = icmp slt i32 %.reg2mem85.0, %127
  br i1 %128, label %103, label %.thread

.thread:                                          ; preds = %._crit_edge1, %._crit_edge, %73, %49
  %.sroa.phi = phi ptr [ %.sroa.1131, %49 ], [ %.sroa.1, %73 ], [ %.sroa.1131, %._crit_edge ], [ %.sroa.1, %._crit_edge1 ]
  %.sroa.phi120 = phi ptr [ %.sroa.2132, %49 ], [ %.sroa.2, %73 ], [ %.sroa.2132, %._crit_edge ], [ %.sroa.2, %._crit_edge1 ]
  %.sroa.phi123 = phi ptr [ %.sroa.3133, %49 ], [ %.sroa.3, %73 ], [ %.sroa.3133, %._crit_edge ], [ %.sroa.3, %._crit_edge1 ]
  %129 = phi ptr [ %.sroa.0130, %49 ], [ %.sroa.0129, %73 ], [ %.sroa.0130, %._crit_edge ], [ %.sroa.0129, %._crit_edge1 ]
  %130 = phi ptr [ %7, %49 ], [ %10, %73 ], [ %7, %._crit_edge ], [ %10, %._crit_edge1 ]
  %131 = phi ptr [ %6, %49 ], [ %9, %73 ], [ %6, %._crit_edge ], [ %9, %._crit_edge1 ]
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %132 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %133 = load ptr, ptr %34, align 8
  %134 = load ptr, ptr %133, align 8
  %135 = call i32 %134(ptr %.fca.1.extract19)
  store i32 %135, ptr %131, align 4
  %136 = add i32 %135, %30
  store i32 %136, ptr %130, align 4
  %137 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract17)
  %138 = load ptr, ptr %34, align 8
  %139 = getelementptr i8, ptr %138, i64 8
  %140 = load ptr, ptr %139, align 8
  call void %140(ptr %.fca.1.extract19, i32 %136)
  store ptr %.fca.0.extract17, ptr %129, align 8
  store ptr %.fca.1.extract19, ptr %.sroa.phi, align 8
  store ptr %.fca.2.extract21, ptr %.sroa.phi120, align 8
  store i32 %offset.i.i, ptr %.sroa.phi123, align 8
  %hash_coef.i.i56 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i57 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i58 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i59 = mul i64 %hash_coef.i.i56, 6499063144389013426
  %shifted.i.i.i60 = lshr i64 %product.i.i.i59, 32
  %xored.i.i.i61 = xor i64 %shifted.i.i.i60, %product.i.i.i59
  %hash.i.i.i62 = and i64 %xored.i.i.i61, %tbl_size.i.i57
  %offset_ptr.i.i63 = getelementptr i32, ptr %offset_tbl.i.i58, i64 %hash.i.i.i62
  %offset.i.i64 = load i32, ptr %offset_ptr.i.i63, align 4
  store i32 %offset.i.i64, ptr %.sroa.phi123, align 8
  %141 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %142 = insertvalue { ptr, ptr, ptr, i32 } %141, ptr %.fca.1.extract19, 1
  %143 = insertvalue { ptr, ptr, ptr, i32 } %142, ptr %.fca.2.extract21, 2
  %144 = insertvalue { ptr, ptr, ptr, i32 } %143, i32 %offset.i.i64, 3
  ret { ptr, ptr, ptr, i32 } %144
}

define i8 @String__index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract)
  %12 = add i32 %11, -1
  %13 = icmp sgt i32 %3, %12
  br i1 %13, label %14, label %._crit_edge

14:                                               ; preds = %4
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture writeonly %into_callee_buf.i, ptr nonnull @into_caller_buf) #32
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %14
  %15 = icmp sgt i32 %3, -1
  %16 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  br i1 %15, label %17, label %23

17:                                               ; preds = %._crit_edge
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract)
  %.fca.0.extract3 = extractvalue { ptr } %20, 0
  %21 = zext nneg i32 %3 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract3, i64 %21
  br label %41

23:                                               ; preds = %._crit_edge
  %24 = load ptr, ptr %8, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = tail call i32 %25(ptr %.fca.1.extract)
  %27 = add i32 %26, %3
  %28 = icmp slt i32 %27, 0
  br i1 %28, label %29, label %._crit_edge1

29:                                               ; preds = %23
  %current_coroutine.i6 = load ptr, ptr @current_coroutine, align 8
  %into_callee_buf.i7 = getelementptr i8, ptr %current_coroutine.i6, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture writeonly %into_callee_buf.i7, ptr nonnull @into_caller_buf) #32
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %23, %29
  %30 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %31 = load ptr, ptr %7, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = tail call { ptr } %32(ptr %.fca.1.extract)
  %.fca.0.extract1 = extractvalue { ptr } %33, 0
  %34 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = tail call i32 %36(ptr %.fca.1.extract)
  %38 = add i32 %37, %3
  %39 = sext i32 %38 to i64
  %40 = getelementptr i8, ptr %.fca.0.extract1, i64 %39
  br label %41

41:                                               ; preds = %._crit_edge1, %17
  %.reg2mem6.0.in = phi ptr [ %22, %17 ], [ %40, %._crit_edge1 ]
  %.reg2mem6.0 = load i8, ptr %.reg2mem6.0.in, align 1
  ret i8 %.reg2mem6.0
}

define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca i1, align 1
  %7 = alloca i1, align 1
  %8 = alloca i1, align 1
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i21 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i22 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i23 = load i64, ptr %hash_coef_ptr.i.i20, align 4
  %tbl_size.i.i24 = load i64, ptr %tbl_size_ptr.i.i21, align 4
  %offset_tbl.i.i25 = load ptr, ptr %offset_tbl_ptr.i.i22, align 8
  %product.i.i.i26 = mul i64 %hash_coef.i.i23, 6499063144389013426
  %shifted.i.i.i27 = lshr i64 %product.i.i.i26, 32
  %xored.i.i.i28 = xor i64 %shifted.i.i.i27, %product.i.i.i26
  %hash.i.i.i29 = and i64 %xored.i.i.i28, %tbl_size.i.i24
  %offset_ptr.i.i30 = getelementptr i32, ptr %offset_tbl.i.i25, i64 %hash.i.i.i29
  %offset.i.i31 = load i32, ptr %offset_ptr.i.i30, align 4
  %9 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract5)
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract5, i64 %10
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract7)
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i.i31, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %21 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %22 = sext i32 %offset.i.i31 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract, i64 %22
  %24 = getelementptr i8, ptr %23, i64 40
  %25 = load ptr, ptr %24, align 8
  %26 = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nonnull %5)
  %27 = call i32 %26({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %5)
  %.not = icmp eq i32 %15, %27
  br i1 %.not, label %.preheader, label %.thread

.preheader:                                       ; preds = %4
  %28 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract5)
  %29 = getelementptr i8, ptr %23, i64 56
  br label %30

30:                                               ; preds = %.preheader, %34
  %.reg2mem44.0 = phi i32 [ %49, %34 ], [ 0, %.preheader ]
  %31 = load ptr, ptr %12, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call i32 %32(ptr %.fca.1.extract7)
  %.not50 = icmp sge i32 %.reg2mem44.0, %33
  br i1 %.not50, label %.thread, label %34

34:                                               ; preds = %30
  %35 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract5)
  %36 = load ptr, ptr %11, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr } %37(ptr %.fca.1.extract7)
  %.fca.0.extract15 = extractvalue { ptr } %38, 0
  %39 = zext nneg i32 %.reg2mem44.0 to i64
  %40 = getelementptr i8, ptr %.fca.0.extract15, i64 %39
  %41 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %5)
  %42 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %43 = load ptr, ptr %29, align 8
  %44 = call ptr %43({ ptr, ptr, ptr, i32 } %19, ptr nonnull %5)
  %45 = call { ptr } %44({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull %5)
  %.fca.0.extract13 = extractvalue { ptr } %45, 0
  %46 = getelementptr i8, ptr %.fca.0.extract13, i64 %39
  %47 = load i8, ptr %40, align 1
  %48 = load i8, ptr %46, align 1
  %.not18 = icmp eq i8 %47, %48
  %49 = add nuw nsw i32 %.reg2mem44.0, 1
  br i1 %.not18, label %30, label %.thread

.thread:                                          ; preds = %34, %30, %4
  %.reg2mem34.0 = phi i1 [ false, %4 ], [ %.not50, %30 ], [ %.not50, %34 ]
  %.reg2mem32.0 = phi ptr [ %6, %4 ], [ %7, %34 ], [ %8, %30 ]
  store i1 %.reg2mem34.0, ptr %.reg2mem32.0, align 1
  ret i1 %.reg2mem34.0
}

define { ptr, i8 } @String_pop_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract3)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract4)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %33, label %12

12:                                               ; preds = %3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract3)
  %14 = load ptr, ptr %7, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract4)
  %17 = add i32 %16, -1
  %18 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract3)
  %19 = load ptr, ptr %7, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract4, i32 %17)
  %22 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract3)
  %23 = load ptr, ptr %6, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = tail call { ptr } %24(ptr %.fca.1.extract4)
  %.fca.0.extract5 = extractvalue { ptr } %25, 0
  %26 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract3)
  %27 = load ptr, ptr %7, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = tail call i32 %28(ptr %.fca.1.extract4)
  %30 = sext i32 %29 to i64
  %31 = getelementptr i8, ptr %.fca.0.extract5, i64 %30
  %32 = load i8, ptr %31, align 1
  br label %33

33:                                               ; preds = %3, %12
  %.reg2mem5.sroa.3.0 = phi i8 [ %32, %12 ], [ undef, %3 ]
  %.reg2mem5.sroa.0.0 = phi ptr [ @i8_typ, %12 ], [ @nil_typ, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i8 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i8 } %.reload6.fca.0.insert, i8 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i8 } %.reload6.fca.1.insert
}

define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract)
  %11 = sext i32 %10 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %11, ptr nonnull @current_ptr) #29
  %12 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract)
  %16 = icmp sgt i32 %15, 0
  br i1 %16, label %.lr.ph, label %._crit_edge._crit_edge

.lr.ph:                                           ; preds = %3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %.lr.ph, %._crit_edge
  %.reg2mem17.061 = phi i32 [ 0, %.lr.ph ], [ %25, %._crit_edge ]
  %18 = load ptr, ptr %6, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract)
  %.fca.0.extract4 = extractvalue { ptr } %20, 0
  %21 = zext nneg i32 %.reg2mem17.061 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract4, i64 %21
  %23 = getelementptr i8, ptr %result.i, i64 %21
  %24 = load i8, ptr %22, align 1
  store i8 %24, ptr %23, align 1
  %25 = add nuw nsw i32 %.reg2mem17.061, 1
  %26 = load ptr, ptr %7, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = tail call i32 %27(ptr %.fca.1.extract)
  %29 = icmp slt i32 %25, %28
  br i1 %29, label %._crit_edge, label %._crit_edge._crit_edge

._crit_edge._crit_edge:                           ; preds = %._crit_edge, %3
  %30 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %31 = load ptr, ptr %7, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = tail call i32 %32(ptr %.fca.1.extract)
  %34 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %35 = load ptr, ptr %7, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = tail call i32 %36(ptr %.fca.1.extract)
  %result.i7 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %38 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %39 = load ptr, ptr %7, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = tail call i32 %40(ptr %.fca.1.extract)
  %42 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %43 = load ptr, ptr %7, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = tail call i32 %44(ptr %.fca.1.extract)
  %46 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr undef, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 9, 3
  store ptr %result.i, ptr %result.i7, align 8
  %49 = getelementptr i8, ptr %result.i7, i64 8
  store i32 %41, ptr %49, align 4
  %50 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %51 = getelementptr i8, ptr %result.i7, i64 12
  store i32 %45, ptr %51, align 4
  ret { ptr, ptr, ptr, i32 } %48
}

define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract)
  %11 = add i32 %10, 1
  %12 = sext i32 %11 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %12, ptr nonnull @current_ptr) #29
  %13 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %14 = load ptr, ptr %7, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract)
  %17 = icmp sgt i32 %16, 0
  br i1 %17, label %.lr.ph, label %._crit_edge._crit_edge

.lr.ph:                                           ; preds = %3
  %18 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %.lr.ph, %._crit_edge
  %.reg2mem17.017 = phi i32 [ 0, %.lr.ph ], [ %26, %._crit_edge ]
  %19 = load ptr, ptr %6, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { ptr } %20(ptr %.fca.1.extract)
  %.fca.0.extract4 = extractvalue { ptr } %21, 0
  %22 = zext nneg i32 %.reg2mem17.017 to i64
  %23 = getelementptr i8, ptr %.fca.0.extract4, i64 %22
  %24 = getelementptr i8, ptr %result.i, i64 %22
  %25 = load i8, ptr %23, align 1
  store i8 %25, ptr %24, align 1
  %26 = add nuw nsw i32 %.reg2mem17.017, 1
  %27 = load ptr, ptr %7, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = tail call i32 %28(ptr %.fca.1.extract)
  %30 = icmp slt i32 %26, %29
  br i1 %30, label %._crit_edge, label %._crit_edge._crit_edge

._crit_edge._crit_edge:                           ; preds = %._crit_edge, %3
  %31 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull %.fca.0.extract)
  %32 = load ptr, ptr %7, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call i32 %33(ptr %.fca.1.extract)
  %35 = sext i32 %34 to i64
  %36 = getelementptr i8, ptr %result.i, i64 %35
  store i8 0, ptr %36, align 1
  %37 = insertvalue { ptr } undef, ptr %result.i, 0
  ret { ptr } %37
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) #8 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %result.i = tail call noalias dereferenceable_or_null(40) ptr @bump_malloc_inner(i64 noundef 40, ptr nonnull @current_ptr) #29
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = tail call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull @StringIterator)
  %hash_coef.i.i45 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i46 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i47 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i48 = mul i64 %hash_coef.i.i45, 6499063144389013426
  %shifted.i.i.i49 = lshr i64 %product.i.i.i48, 32
  %xored.i.i.i50 = xor i64 %shifted.i.i.i49, %product.i.i.i48
  %hash.i.i.i51 = and i64 %xored.i.i.i50, %tbl_size.i.i46
  %offset_ptr.i.i52 = getelementptr i32, ptr %offset_tbl.i.i47, i64 %hash.i.i.i51
  %offset.i.i = load i32, ptr %offset_ptr.i.i52, align 4
  store ptr %.fca.0.extract, ptr %result.i, align 8
  %7 = getelementptr i8, ptr %result.i, i64 8
  store ptr %.fca.1.extract, ptr %7, align 8
  %8 = getelementptr i8, ptr %result.i, i64 16
  store ptr %.fca.2.extract, ptr %8, align 8
  %9 = getelementptr i8, ptr %result.i, i64 24
  store i32 %offset.i.i, ptr %9, align 4
  %10 = tail call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull @StringIterator)
  %11 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 15, 3
  ret { ptr, ptr, ptr, i32 } %11
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) #9 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i13 = load i32, ptr %offset_ptr.i.i, align 4
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i.i13, 3
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_StringIterator(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 48, ptr %.fca.0.extract1)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i.i35, 3
  tail call void %10(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %14)
  %15 = tail call ptr @llvm.invariant.start.p0(i64 48, ptr %.fca.0.extract1)
  %16 = getelementptr i8, ptr %7, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  tail call void %19(ptr %.fca.1.extract3, i32 0)
  ret void
}

define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %8 = tail call ptr @llvm.invariant.start.p0(i64 48, ptr %.fca.0.extract9)
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract9, i64 %9
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = tail call i32 %13(ptr %.fca.1.extract11)
  %15 = tail call ptr @llvm.invariant.start.p0(i64 48, ptr %.fca.0.extract9)
  %16 = load ptr, ptr %10, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract11)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %hash_coef_ptr.i.i37 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i38 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i40 = load i64, ptr %hash_coef_ptr.i.i37, align 4
  %tbl_size.i.i41 = load i64, ptr %tbl_size_ptr.i.i38, align 4
  %offset_tbl.i.i42 = load ptr, ptr %offset_tbl_ptr.i.i39, align 8
  %product.i.i.i43 = mul i64 %hash_coef.i.i40, 6499063144389013426
  %shifted.i.i.i44 = lshr i64 %product.i.i.i43, 32
  %xored.i.i.i45 = xor i64 %shifted.i.i.i44, %product.i.i.i43
  %hash.i.i.i46 = and i64 %xored.i.i.i45, %tbl_size.i.i41
  %offset_ptr.i.i47 = getelementptr i32, ptr %offset_tbl.i.i42, i64 %hash.i.i.i46
  %offset.i.i48 = load i32, ptr %offset_ptr.i.i47, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i48
  tail call void @llvm.assume(i1 %eq.i) #30
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %24 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract)
  %25 = sext i32 %.fca.3.extract to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 40
  %28 = load ptr, ptr %27, align 8
  %29 = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nonnull %4)
  %30 = call i32 %29({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull %4)
  %31 = icmp slt i32 %14, %30
  br i1 %31, label %32, label %106

32:                                               ; preds = %3
  %33 = call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull %.fca.0.extract9)
  %34 = load ptr, ptr %11, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %.fca.1.extract11)
  %37 = add i32 %36, 1
  %38 = call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull %.fca.0.extract9)
  %39 = load ptr, ptr %11, align 8
  %40 = getelementptr i8, ptr %39, i64 8
  %41 = load ptr, ptr %40, align 8
  call void %41(ptr %.fca.1.extract11, i32 %37)
  %42 = call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull %.fca.0.extract9)
  %43 = load ptr, ptr %10, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract11)
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract34 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %hash_coef_ptr.i.i51 = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i.i52 = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i.i53 = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i.i54 = load i64, ptr %hash_coef_ptr.i.i51, align 4
  %tbl_size.i.i55 = load i64, ptr %tbl_size_ptr.i.i52, align 4
  %offset_tbl.i.i56 = load ptr, ptr %offset_tbl_ptr.i.i53, align 8
  %product.i.i.i57 = mul i64 %hash_coef.i.i54, 6499063144389013426
  %shifted.i.i.i58 = lshr i64 %product.i.i.i57, 32
  %xored.i.i.i59 = xor i64 %shifted.i.i.i58, %product.i.i.i57
  %hash.i.i.i60 = and i64 %xored.i.i.i59, %tbl_size.i.i55
  %offset_ptr.i.i61 = getelementptr i32, ptr %offset_tbl.i.i56, i64 %hash.i.i.i60
  %offset.i.i62 = load i32, ptr %offset_ptr.i.i61, align 4
  %eq.i65 = icmp eq i32 %.fca.3.extract34, %offset.i.i62
  call void @llvm.assume(i1 %eq.i65) #30
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract30, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract32, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract34, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract28)
  %52 = sext i32 %.fca.3.extract34 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract28, i64 %52
  %54 = getelementptr i8, ptr %53, i64 56
  %55 = load ptr, ptr %54, align 8
  %56 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nonnull %4)
  %57 = call { ptr } %56({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull %4)
  %58 = call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull %.fca.0.extract9)
  %59 = load ptr, ptr %11, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = call i32 %60(ptr %.fca.1.extract11)
  %result.i = call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nonnull @current_ptr) #29
  %62 = getelementptr inbounds i8, ptr %5, i64 8
  %63 = getelementptr inbounds i8, ptr %5, i64 24
  store ptr @Character, ptr %5, align 8
  store ptr %result.i, ptr %62, align 8
  store i32 9, ptr %63, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 16, ptr nonnull %5)
  %65 = call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull %.fca.0.extract9)
  %66 = load ptr, ptr %10, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr, ptr, ptr, i32 } %67(ptr %.fca.1.extract11)
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %68, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %68, 1
  %.fca.2.extract24 = extractvalue { ptr, ptr, ptr, i32 } %68, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %68, 3
  %hash_coef_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i.i69 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i.i70 = load i64, ptr %hash_coef_ptr.i.i67, align 4
  %tbl_size.i.i71 = load i64, ptr %tbl_size_ptr.i.i68, align 4
  %offset_tbl.i.i72 = load ptr, ptr %offset_tbl_ptr.i.i69, align 8
  %product.i.i.i73 = mul i64 %hash_coef.i.i70, 6499063144389013426
  %shifted.i.i.i74 = lshr i64 %product.i.i.i73, 32
  %xored.i.i.i75 = xor i64 %shifted.i.i.i74, %product.i.i.i73
  %hash.i.i.i76 = and i64 %xored.i.i.i75, %tbl_size.i.i71
  %offset_ptr.i.i77 = getelementptr i32, ptr %offset_tbl.i.i72, i64 %hash.i.i.i76
  %offset.i.i78 = load i32, ptr %offset_ptr.i.i77, align 4
  %eq.i81 = icmp eq i32 %.fca.3.extract26, %offset.i.i78
  call void @llvm.assume(i1 %eq.i81) #30
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %.fca.1.extract22, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %.fca.2.extract24, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %.fca.3.extract26, 3
  %73 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %74 = call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract20)
  %75 = sext i32 %.fca.3.extract26 to i64
  %76 = getelementptr ptr, ptr %.fca.0.extract20, i64 %75
  %77 = getelementptr i8, ptr %76, i64 56
  %78 = load ptr, ptr %77, align 8
  %79 = call ptr %78({ ptr, ptr, ptr, i32 } %72, ptr nonnull %4)
  %80 = call { ptr } %79({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull %4)
  %.fca.0.extract17 = extractvalue { ptr } %80, 0
  %81 = call ptr @llvm.invariant.start.p0(i64 48, ptr nonnull %.fca.0.extract9)
  %82 = load ptr, ptr %11, align 8
  %83 = load ptr, ptr %82, align 8
  %84 = call i32 %83(ptr %.fca.1.extract11)
  %85 = add i32 %84, -1
  %86 = sext i32 %85 to i64
  %87 = getelementptr i8, ptr %.fca.0.extract17, i64 %86
  %88 = load i8, ptr %87, align 1
  %89 = load ptr, ptr %5, align 8
  %90 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %89, 0
  %91 = load ptr, ptr %62, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } %90, ptr %91, 1
  %93 = getelementptr inbounds i8, ptr %5, i64 16
  %94 = load ptr, ptr %93, align 8
  %95 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %94, 2
  %96 = load i32, ptr %63, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %96, 3
  store ptr @_parameterization_Ptri8, ptr %6, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 1, ptr nonnull %6)
  %99 = call ptr @llvm.invariant.start.p0(i64 40, ptr %89)
  %100 = sext i32 %96 to i64
  %101 = getelementptr ptr, ptr %89, i64 %100
  %102 = getelementptr i8, ptr %101, i64 16
  %103 = load ptr, ptr %102, align 8
  store ptr @i8_typ, ptr %7, align 8
  %104 = call ptr %103({ ptr, ptr, ptr, i32 } %97, ptr nonnull %7)
  call void %104({ ptr, ptr, ptr, i32 } %97, { ptr, ptr, ptr, i32 } %97, ptr nonnull %6, i8 %88)
  %105 = load i160, ptr %62, align 8
  br label %106

106:                                              ; preds = %3, %32
  %.reg2mem5.sroa.3.0 = phi i160 [ %105, %32 ], [ undef, %3 ]
  %.reg2mem5.sroa.0.0 = phi ptr [ %89, %32 ], [ @nil_typ, %3 ]
  %.reload6.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem5.sroa.0.0, 0
  %.reload6.fca.1.insert = insertvalue { ptr, i160 } %.reload6.fca.0.insert, i160 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i160 } %.reload6.fca.1.insert
}

define linkonce_odr { i64, i64 } @_size_i8_typ(ptr %0) {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

define linkonce_odr { ptr, i160 } @_box_i8_typ(ptr %0, ptr %1) {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

define linkonce_odr void @_unbox_i8_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Character(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_byte_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 96
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_bytePtri8({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define i8 @Character_byte_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 40, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i8 %8(ptr %.fca.1.extract)
  ret i8 %9
}

define void @Character_init_bytePtri8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i8 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 40, ptr %.fca.0.extract)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  tail call void %10(ptr %.fca.1.extract, i8 %3)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i8 @Character_getter_byte(ptr nocapture readonly %0) #0 {
  %2 = load i8, ptr %0, align 1
  ret i8 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_byte(ptr nocapture writeonly %0, i8 %1) #4 {
  store i8 %1, ptr %0, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_index(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_index(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 4
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_length(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_length(ptr nocapture writeonly %0, i32 %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture readonly %0) #0 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture writeonly %0, { ptr } %1) #4 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Exception(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract1)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i35, 3
  tail call void %11(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %15)
  %16 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract1)
  %17 = load ptr, ptr %7, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  tail call void %19(ptr %.fca.1.extract3, i32 0)
  %result.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nonnull @current_ptr) #29
  %result.i37 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i37, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 9, 3
  store ptr %result.i, ptr %result.i37, align 8
  %23 = getelementptr i8, ptr %result.i37, i64 8
  store i32 0, ptr %23, align 4
  %24 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %25 = getelementptr i8, ptr %result.i37, i64 12
  store i32 1, ptr %25, align 4
  %26 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract1)
  %27 = getelementptr i8, ptr %7, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %22)
  ret void
}

define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract)
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  tail call void %9(ptr %.fca.1.extract, i32 0)
  %result.i = tail call noalias dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nonnull @current_ptr) #29
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i, align 8
  %result.i2 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i2, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 9, 3
  store ptr %result.i, ptr %result.i2, align 8
  %13 = getelementptr i8, ptr %result.i2, i64 8
  store i32 6, ptr %13, align 4
  %14 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %15 = getelementptr i8, ptr %result.i2, i64 12
  store i32 7, ptr %15, align 4
  %16 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract)
  %17 = getelementptr i8, ptr %6, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %12)
  %result.i17 = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nonnull @current_ptr) #29
  %result.i18 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nonnull @current_ptr) #29
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i18, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 9, 3
  store ptr %result.i17, ptr %result.i18, align 8
  %24 = getelementptr i8, ptr %result.i18, i64 8
  store i32 0, ptr %24, align 4
  %25 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %26 = getelementptr i8, ptr %result.i18, i64 12
  store i32 1, ptr %26, align 4
  %27 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract)
  %28 = getelementptr i8, ptr %6, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  tail call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23)
  ret void
}

define void @Exception_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract1)
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract1, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract3, i32 %3)
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4
  %12 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract1)
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i35, 3
  tail call void %16(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %20)
  ret void
}

define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
.lr.ph.i:
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %result.i = tail call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nonnull @current_ptr) #29
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i, align 16
  %result.i.i = tail call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nonnull @current_ptr) #29
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i.i, ptr noundef nonnull align 1 dereferenceable(9) %result.i, i64 9, i1 false)
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  %result.i33 = tail call noalias dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nonnull @current_ptr) #29
  store <26 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110, i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105, i8 108, i8 101>, ptr %result.i33, align 32
  %result.i.i132 = tail call noalias dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nonnull @current_ptr) #29
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i.i132, ptr noundef nonnull align 1 dereferenceable(26) %result.i33, i64 26, i1 false)
  %4 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %puts27 = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i132)
  %5 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract19)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract19, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract21)
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i36 = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i37 = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i38 = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i39 = load i64, ptr %hash_coef_ptr.i.i36, align 4
  %tbl_size.i.i40 = load i64, ptr %tbl_size_ptr.i.i37, align 4
  %offset_tbl.i.i41 = load ptr, ptr %offset_tbl_ptr.i.i38, align 8
  %product.i.i.i42 = mul i64 %hash_coef.i.i39, 6499063144389013426
  %shifted.i.i.i43 = lshr i64 %product.i.i.i42, 32
  %xored.i.i.i44 = xor i64 %shifted.i.i.i43, %product.i.i.i42
  %hash.i.i.i45 = and i64 %xored.i.i.i44, %tbl_size.i.i40
  %offset_ptr.i.i46 = getelementptr i32, ptr %offset_tbl.i.i41, i64 %hash.i.i.i45
  %offset.i.i47 = load i32, ptr %offset_ptr.i.i46, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i47
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract10)
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract10, i64 %18
  %20 = getelementptr i8, ptr %19, i64 112
  %21 = load ptr, ptr %20, align 8
  %22 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nonnull %3)
  %23 = call { ptr } %22({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %3)
  %.fca.0.extract8 = extractvalue { ptr } %23, 0
  %puts28 = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract8)
  %result.i49 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_inner(i64 noundef 8, ptr nonnull @current_ptr) #29
  store <7 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101>, ptr %result.i49, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %result.i.i152 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_inner(i64 noundef 8, ptr nonnull @current_ptr) #29
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(7) %result.i.i152, ptr noundef nonnull align 1 dereferenceable(7) %result.i49, i64 7, i1 false)
  %25 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %26 = getelementptr i8, ptr %result.i.i152, i64 7
  store i8 0, ptr %26, align 1
  %puts29 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i152)
  %27 = call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract19)
  %28 = load ptr, ptr %7, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call i32 %29(ptr %.fca.1.extract21)
  %31 = call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %30)
  %result.i51 = call noalias dereferenceable_or_null(13) ptr @bump_malloc_inner(i64 noundef 13, ptr nonnull @current_ptr) #29
  store <12 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115, i8 115, i8 97, i8 103, i8 101>, ptr %result.i51, align 16
  %32 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %result.i.i172 = call noalias dereferenceable_or_null(13) ptr @bump_malloc_inner(i64 noundef 13, ptr nonnull @current_ptr) #29
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(12) %result.i.i172, ptr noundef nonnull align 1 dereferenceable(12) %result.i51, i64 12, i1 false)
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %33 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %34 = getelementptr i8, ptr %result.i.i172, i64 12
  store i8 0, ptr %34, align 1
  %puts30 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i172)
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract21, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract23, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %offset.i.i, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %40 = call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract19)
  %41 = getelementptr i8, ptr %7, i64 56
  %42 = load ptr, ptr %41, align 8
  %43 = call ptr %42({ ptr, ptr, ptr, i32 } %38, ptr nonnull %3)
  call void %43({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull %3)
  %result.i53 = call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nonnull @current_ptr) #29
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i53, align 16
  %44 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %result.i.i192 = call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nonnull @current_ptr) #29
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i.i192, ptr noundef nonnull align 1 dereferenceable(9) %result.i53, i64 9, i1 false)
  %45 = call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %46 = getelementptr i8, ptr %result.i.i192, i64 9
  store i8 0, ptr %46, align 1
  %puts31 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i192)
  ret void
}

define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr %.fca.0.extract2)
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract2, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract4)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 6499063144389013426
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i22 = load i32, ptr %offset_ptr.i.i21, align 4
  %eq.i = icmp eq i32 %.fca.3.extract, %offset.i.i22
  tail call void @llvm.assume(i1 %eq.i) #30
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %4)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 112
  %21 = load ptr, ptr %20, align 8
  %22 = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %23 = call { ptr } %22({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull %4)
  %.fca.0.extract = extractvalue { ptr } %23, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #10

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture readonly %0) #0 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture writeonly %0, { ptr, ptr, ptr, i32 } %1) #4 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture readonly %0) #0 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture writeonly %0, i32 %1) #4 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 80
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @report_exception({ ptr } %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %3 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %4 = load { ptr, i160 }, ptr %3, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %5 = icmp ne ptr %.fca.0.extract, @nil_typ
  %6 = icmp ne ptr %.fca.0.extract, null
  %.not4 = and i1 %5, %6
  br i1 %.not4, label %7, label %._crit_edge

7:                                                ; preds = %1
  %.fca.1.extract = extractvalue { ptr, i160 } %4, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %8 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %9 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %8, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %9, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %offset.i.i, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %2)
  %15 = tail call ptr @llvm.invariant.start.p0(i64 104, ptr nonnull %.fca.0.extract)
  %16 = sext i32 %offset.i.i to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract, i64 %16
  %18 = getelementptr i8, ptr %17, i64 48
  %19 = load ptr, ptr %18, align 8
  %20 = call ptr %19({ ptr, ptr, ptr, i32 } %13, ptr nonnull %2)
  call void %20({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull %2)
  br label %._crit_edge

._crit_edge:                                      ; preds = %1, %7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_IO(ptr nocapture readnone %0) #5 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @IO_B__Self_print_xPtri64__Self_print_xPtri8__Self_print_xPtrf64__Self_print_xString__Self_print_xPtri1__Self_print_xRepresentable__Self_print_xPtri32__Self_print_xCharacter__Self_print_xNil(ptr nocapture %0) #11 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 8, ptr %0)
  %3 = load ptr, ptr %0, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = tail call i1 %10(i64 %9, i64 %8, i64 -5126806859456325683, i64 ptrtoint (ptr @nil_typ to i64), ptr readonly %11) #0
  %12 = icmp eq ptr %3, null
  %13 = or i1 %12, %result.i
  br i1 %13, label %21, label %14

14:                                               ; preds = %1
  %result.i3 = tail call i1 %10(i64 %9, i64 %8, i64 2582149688529881115, i64 ptrtoint (ptr @i8_typ to i64), ptr readonly %11) #0
  br i1 %result.i3, label %21, label %15

15:                                               ; preds = %14
  %result.i4 = tail call i1 %10(i64 %9, i64 %8, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %11) #0
  %result.i5 = tail call i1 %10(i64 %9, i64 %8, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %11) #0
  %not.result.i4 = xor i1 %result.i4, true
  %.reg2mem49.0 = select i1 %not.result.i4, i1 true, i1 %result.i5
  br i1 %.reg2mem49.0, label %16, label %21

16:                                               ; preds = %15
  %result.i6 = tail call i1 %10(i64 %9, i64 %8, i64 -757315540097298781, i64 ptrtoint (ptr @f64_typ to i64), ptr readonly %11) #0
  br i1 %result.i6, label %21, label %17

17:                                               ; preds = %16
  %not.result.i5 = xor i1 %result.i5, true
  %.reg2mem47.0 = or i1 %result.i4, %not.result.i5
  br i1 %.reg2mem47.0, label %18, label %21

18:                                               ; preds = %17
  %result.i9 = tail call i1 %10(i64 %9, i64 %8, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %11) #0
  %result.i9.not = xor i1 %result.i9, true
  %.reg2mem45.0 = or i1 %result.i4, %result.i5
  %or.cond = select i1 %result.i9.not, i1 true, i1 %.reg2mem45.0
  br i1 %or.cond, label %.critedge, label %21

.critedge:                                        ; preds = %18
  %result.i12 = tail call i1 %10(i64 %9, i64 %8, i64 -2253724949814257982, i64 ptrtoint (ptr @i32_typ to i64), ptr readonly %11) #0
  br i1 %result.i12, label %21, label %19

19:                                               ; preds = %.critedge
  %result.i13 = tail call i1 %10(i64 %9, i64 %8, i64 5801531371504802705, i64 ptrtoint (ptr @bool_typ to i64), ptr readonly %11) #0
  %20 = select i1 %result.i13, i32 5, i32 1
  br label %21

21:                                               ; preds = %18, %14, %15, %16, %17, %.critedge, %19, %1
  %.reg2mem29.0 = phi i32 [ 9, %1 ], [ 2, %14 ], [ 3, %16 ], [ %20, %19 ], [ 7, %.critedge ], [ 8, %17 ], [ 4, %15 ], [ 6, %18 ]
  %22 = zext nneg i32 %.reg2mem29.0 to i64
  %23 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %22
  %24 = getelementptr i8, ptr %23, i64 72
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri64(ptr nocapture readnone %0, { ptr, i160 } %1) #10 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = tail call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i64_string, i64 %.sroa.1.8.extract.trunc)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri8(ptr nocapture readnone %0, { ptr, i160 } %1) #10 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  %3 = sext i8 %.sroa.1.8.extract.trunc to i32
  %4 = tail call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %3)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtrf64(ptr nocapture readnone %0, { ptr, i160 } %1) #10 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = tail call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @float_string, double %3)
  ret void
}

define void @IO__Self_print_xString(ptr nocapture readnone %0, { ptr, i160 } %1) {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %11 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract1, i64 %12
  %14 = getelementptr i8, ptr %13, i64 112
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nonnull %3)
  %17 = call { ptr } %16({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %3)
  %.fca.0.extract = extractvalue { ptr } %17, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri1(ptr nocapture readnone %0, { ptr, i160 } %1) #10 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %3 = trunc i160 %.fca.1.extract to i1
  br i1 %3, label %4, label %5

4:                                                ; preds = %2
  %result.i = tail call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nonnull @current_ptr) #29
  store <4 x i8> <i8 116, i8 114, i8 117, i8 101>, ptr %result.i, align 4
  br label %.lr.ph.i

5:                                                ; preds = %2
  %result.i8 = tail call noalias dereferenceable_or_null(6) ptr @bump_malloc_inner(i64 noundef 6, ptr nonnull @current_ptr) #29
  store <5 x i8> <i8 102, i8 97, i8 108, i8 115, i8 101>, ptr %result.i8, align 8
  br label %.lr.ph.i

.lr.ph.i:                                         ; preds = %4, %5
  %result.i8.sink = phi ptr [ %result.i8, %5 ], [ %result.i, %4 ]
  %.sink27 = phi i32 [ 5, %5 ], [ 4, %4 ]
  %6 = add nuw nsw i32 %.sink27, 1
  %7 = zext nneg i32 %6 to i64
  %result.i.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %7, ptr nonnull @current_ptr) #29
  %8 = zext nneg i32 %.sink27 to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(1) %result.i.i, ptr noundef nonnull align 1 dereferenceable(1) %result.i8.sink, i64 %8, i1 false)
  %9 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %10 = zext nneg i32 %.sink27 to i64
  %11 = getelementptr i8, ptr %result.i.i, i64 %10
  store i8 0, ptr %11, align 1
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  ret void
}

define void @IO__Self_print_xRepresentable(ptr nocapture readnone %0, { ptr, i160 } %1) {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract4 = extractvalue { ptr, i160 } %1, 1
  %.sroa.321.8.extract.trunc = trunc i160 %.fca.1.extract4 to i64
  %4 = inttoptr i64 %.sroa.321.8.extract.trunc to ptr
  %.sroa.522.8.extract.shift = lshr i160 %.fca.1.extract4, 64
  %.sroa.522.8.extract.trunc = trunc i160 %.sroa.522.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.522.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260840641129990118
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %11 = tail call ptr @llvm.invariant.start.p0(i64 16, ptr %.fca.0.extract2)
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract2, i64 %12
  %14 = load ptr, ptr %13, align 8
  %15 = call ptr %14({ ptr, ptr, ptr, i32 } %9, ptr nonnull %3)
  %16 = call { ptr, ptr, ptr, i32 } %15({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %3)
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i7 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i8 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i10 = load i64, ptr %hash_coef_ptr.i.i7, align 4
  %tbl_size.i.i11 = load i64, ptr %tbl_size_ptr.i.i8, align 4
  %offset_tbl.i.i12 = load ptr, ptr %offset_tbl_ptr.i.i9, align 8
  %product.i.i.i13 = mul i64 %hash_coef.i.i10, 6499063144389013426
  %shifted.i.i.i14 = lshr i64 %product.i.i.i13, 32
  %xored.i.i.i15 = xor i64 %shifted.i.i.i14, %product.i.i.i13
  %hash.i.i.i16 = and i64 %xored.i.i.i15, %tbl_size.i.i11
  %offset_ptr.i.i17 = getelementptr i32, ptr %offset_tbl.i.i12, i64 %hash.i.i.i16
  %offset.i.i18 = load i32, ptr %offset_ptr.i.i17, align 4
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i18, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %22 = call ptr @llvm.invariant.start.p0(i64 280, ptr %.fca.0.extract1)
  %23 = sext i32 %offset.i.i18 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract1, i64 %23
  %25 = getelementptr i8, ptr %24, i64 112
  %26 = load ptr, ptr %25, align 8
  %27 = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nonnull %3)
  %28 = call { ptr } %27({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull %3)
  %.fca.0.extract = extractvalue { ptr } %28, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri32(ptr nocapture readnone %0, { ptr, i160 } %1) #10 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 (ptr, ...) @printf(ptr nonnull dereferenceable(1) @i32_string, i32 %.sroa.1.8.extract.trunc)
  ret void
}

define void @IO__Self_print_xCharacter(ptr nocapture readnone %0, { ptr, i160 } %1) {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %result.i = tail call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nonnull @current_ptr) #29
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 0, ptr nonnull %3)
  %11 = tail call ptr @llvm.invariant.start.p0(i64 40, ptr %.fca.0.extract)
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nonnull %3)
  %17 = call i8 %16({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull %3)
  store i8 %17, ptr %result.i, align 1
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %result.i)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xNil(ptr nocapture readnone %0, { ptr, i160 } %1) #10 {
.lr.ph.i:
  %result.i = tail call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  store <3 x i8> <i8 110, i8 105, i8 108>, ptr %result.i, align 4
  %result.i.i = tail call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nonnull @current_ptr) #29
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i, ptr noundef nonnull align 1 dereferenceable(3) %result.i, i64 3, i1 false)
  %2 = tail call ptr @llvm.invariant.start.p0(i64 280, ptr nonnull @String)
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  ret void
}

define linkonce_odr { i64, i64 } @_size_f64_typ(ptr %0) {
  ret { i64, i64 } { i64 8, i64 8 }
}

define linkonce_odr { ptr, i160 } @_box_f64_typ(ptr %0, ptr %1) {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

define linkonce_odr void @_unbox_f64_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @adjust_trampoline(ptr readonly %tramp) local_unnamed_addr #0 {
  %ret = tail call ptr @llvm.adjust.trampoline(ptr %tramp) #31
  ret ptr %ret
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #12

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none)
define noalias ptr @bump_malloc(i64 noundef %size) local_unnamed_addr #13 {
  %result = tail call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nonnull @current_ptr) #29
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture %current_ptr) local_unnamed_addr #14 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  ret ptr %current
}

define { i64, i64 } @_size_tuple_typ(ptr nocapture readonly %0) local_unnamed_addr {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %1, %.lr.ph
  %.reg2mem20.010.reg2mem.0 = phi i64 [ %12, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011.reg2mem.0 = phi i64 [ %18, %.lr.ph ], [ 0, %1 ]
  %.reg2mem14.0 = phi i64 [ %19, %.lr.ph ], [ 1, %1 ]
  %.in.reg2mem.0 = phi i64 [ %21, %.lr.ph ], [ %3, %1 ]
  %5 = inttoptr i64 %.in.reg2mem.0 to ptr
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr i8, ptr %6, i64 48
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { i64, i64 } %8(ptr nonnull %5)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = extractvalue { i64, i64 } %9, 1
  %12 = tail call i64 @llvm.umax.i64(i64 %11, i64 %.reg2mem20.010.reg2mem.0)
  %13 = urem i64 %.reg2mem22.011.reg2mem.0, %11
  %14 = icmp eq i64 %13, 0
  %15 = sub i64 %11, %13
  %16 = select i1 %14, i64 0, i64 %15
  %17 = add i64 %10, %.reg2mem22.011.reg2mem.0
  %18 = add i64 %17, %16
  %19 = add i64 %.reg2mem14.0, 1
  %20 = getelementptr ptr, ptr %0, i64 %19
  %21 = load i64, ptr %20, align 4
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem22.0.lcssa.reg2mem.0 = phi i64 [ 0, %1 ], [ %18, %.lr.ph ]
  %.reg2mem20.0.lcssa.reg2mem.0 = phi i64 [ 1, %1 ], [ %12, %.lr.ph ]
  %23 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0, %.reg2mem20.0.lcssa.reg2mem.0
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = add i64 %26, %.reg2mem22.0.lcssa.reg2mem.0
  %28 = insertvalue { i64, i64 } undef, i64 %27, 0
  %29 = insertvalue { i64, i64 } %28, i64 %.reg2mem20.0.lcssa.reg2mem.0, 1
  ret { i64, i64 } %29
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #15

define { i64, i64 } @_size_union_typ(ptr nocapture readonly %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %1, %.lr.ph
  %.reg2mem20.010.reg2mem.0 = phi i64 [ %12, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011.reg2mem.0 = phi i64 [ %18, %.lr.ph ], [ 0, %1 ]
  %.reg2mem14.0 = phi i64 [ %19, %.lr.ph ], [ 1, %1 ]
  %.in.reg2mem.0 = phi i64 [ %21, %.lr.ph ], [ %3, %1 ]
  %5 = inttoptr i64 %.in.reg2mem.0 to ptr
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr i8, ptr %6, i64 48
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { i64, i64 } %8(ptr nonnull %5)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = extractvalue { i64, i64 } %9, 1
  %12 = tail call i64 @llvm.umax.i64(i64 %11, i64 %.reg2mem20.010.reg2mem.0)
  %13 = urem i64 %.reg2mem22.011.reg2mem.0, %11
  %14 = icmp eq i64 %13, 0
  %15 = sub i64 %11, %13
  %16 = select i1 %14, i64 0, i64 %15
  %17 = add i64 %10, %.reg2mem22.011.reg2mem.0
  %18 = tail call i64 @llvm.umax.i64(i64 %17, i64 %16)
  %19 = add i64 %.reg2mem14.0, 1
  %20 = getelementptr ptr, ptr %0, i64 %19
  %21 = load i64, ptr %20, align 4
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %.lr.ph.._crit_edge_crit_edge, label %.lr.ph

.lr.ph.._crit_edge_crit_edge:                     ; preds = %.lr.ph
  %23 = add i64 %18, 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %1, %.lr.ph.._crit_edge_crit_edge
  %.reg2mem22.0.lcssa.reg2mem.0 = phi i64 [ %23, %.lr.ph.._crit_edge_crit_edge ], [ 8, %1 ]
  %.reg2mem20.0.lcssa.reg2mem.0 = phi i64 [ %12, %.lr.ph.._crit_edge_crit_edge ], [ 1, %1 ]
  %24 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0, %.reg2mem20.0.lcssa.reg2mem.0
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %27, %.reg2mem22.0.lcssa.reg2mem.0
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa.reg2mem.0, 1
  ret { i64, i64 } %30
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr nocapture readonly %1, ptr nocapture writeonly %2) {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %3, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %3 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %3 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 48
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = tail call i64 @llvm.umax.i64(i64 %20, i64 %19)
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %.lr.ph.._crit_edge_crit_edge.i, label %.lr.ph.i

.lr.ph.._crit_edge_crit_edge.i:                   ; preds = %.lr.ph.i
  %26 = add i64 %21, 8
  br label %_size_union_typ.exit

_size_union_typ.exit:                             ; preds = %3, %.lr.ph.._crit_edge_crit_edge.i
  %.reg2mem22.0.lcssa.reg2mem.0.i = phi i64 [ %26, %.lr.ph.._crit_edge_crit_edge.i ], [ 8, %3 ]
  %.reg2mem20.0.lcssa.reg2mem.0.i = phi i64 [ %15, %.lr.ph.._crit_edge_crit_edge.i ], [ 1, %3 ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0.i, %.reg2mem20.0.lcssa.reg2mem.0.i
  %30 = icmp eq i64 %29, 0
  %31 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add i64 %32, %.reg2mem22.0.lcssa.reg2mem.0.i
  %34 = icmp slt i64 %33, 17
  %35 = icmp eq i64 %33, 32
  %36 = select i1 %34, ptr %.fca.1.gep, ptr %28
  %37 = select i1 %35, ptr %4, ptr %36
  call void @llvm.memcpy.inline.p0.p0.i64(ptr align 1 %2, ptr align 1 %37, i64 %33, i1 false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_Default(ptr nocapture readonly %fat_ptr, ptr nocapture readnone %parameterization) #0 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 4
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr nocapture readnone %parameterization, ptr nocapture writeonly %destination) #4 {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 4
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr %tramp) local_unnamed_addr #16 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr %tramp, i64 16, i32 64, ptr nonnull %oldProtect) #16
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) local_unnamed_addr #16

define noundef ptr @coroutine_create(ptr %func, ptr %arg_passer) local_unnamed_addr {
  %stack = tail call noalias dereferenceable_or_null(8388608) ptr @VirtualAlloc(ptr null, i64 8388608, i32 12288, i32 4) #33
  store ptr %func, ptr %stack, align 8
  %stack_top = getelementptr i8, ptr %stack, i64 8388608
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr i8, ptr %stack, i64 8
  %arg_passer_slot = getelementptr i8, ptr %stack, i64 32
  %into_callee_second_word = getelementptr i8, ptr %stack, i64 16
  %into_callee_third_word = getelementptr i8, ptr %stack, i64 24
  store i64 %stack_top_aligned, ptr %into_callee_buf, align 4
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 4
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr i8, ptr %stack, i64 40
  store i1 false, ptr %is_finished, align 1
  tail call void @coroutine_trampoline(ptr %into_callee_second_word)
  ret ptr %stack
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare noalias ptr @VirtualAlloc(ptr, i64, i32, i32) local_unnamed_addr #17

declare void @coroutine_trampoline(ptr) local_unnamed_addr

define void @setup_landing_pad() {
  %region = tail call noalias dereferenceable_or_null(21474836480) ptr @VirtualAlloc(ptr null, i64 21474836480, i32 12288, i32 4) #33
  store ptr %region, ptr @current_ptr, align 8
  %sp = tail call ptr @llvm.stacksave.p0() #34
  store ptr %sp, ptr @into_caller_buf, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %sp, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %stack.i = tail call noalias dereferenceable_or_null(8388608) ptr @VirtualAlloc(ptr null, i64 8388608, i32 12288, i32 4) #33
  store ptr @setup_landing_pad, ptr %stack.i, align 8
  %stack_top.i = getelementptr i8, ptr %stack.i, i64 8388608
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr i8, ptr %stack.i, i64 8
  %arg_passer_slot.i = getelementptr i8, ptr %stack.i, i64 32
  %into_callee_second_word.i = getelementptr i8, ptr %stack.i, i64 16
  %into_callee_third_word.i = getelementptr i8, ptr %stack.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 4
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 4
  store ptr @arg_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr i8, ptr %stack.i, i64 40
  store i1 false, ptr %is_finished.i, align 1
  tail call void @coroutine_trampoline(ptr %into_callee_second_word.i)
  store ptr %stack.i, ptr @current_coroutine, align 8
  %retval.i = load i1, ptr @always_one, align 1
  br i1 %retval.i, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = tail call i32 @printf(ptr nonnull @string_string.59, ptr nonnull @exception_message)
  %cc.unpack = load ptr, ptr @current_coroutine, align 8
  %cc1 = insertvalue { ptr } poison, ptr %cc.unpack, 0
  tail call void @report_exception({ ptr } %cc1)
  tail call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #18

define void @arg_passer(ptr nocapture readonly %current_coroutine) {
  %func = load ptr, ptr %current_coroutine, align 8
  tail call void %func()
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define i1 @returns_one() local_unnamed_addr #19 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

declare void @exit() local_unnamed_addr

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define i32 @get_offset(ptr nocapture readonly %vptr, ptr nocapture readonly %id_ptr) local_unnamed_addr #9 {
  %id = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr = getelementptr i8, ptr %vptr, i64 40
  %hash_coef = load i64, ptr %hash_coef_ptr, align 4
  %tbl_size = load i64, ptr %tbl_size_ptr, align 4
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %product.i = mul i64 %hash_coef, %id
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %hash.i
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) local_unnamed_addr #5 {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %shifted, %product
  %hash = and i64 %xored, %tbl_size
  ret i64 %hash
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: write)
define void @assume_offset(ptr nocapture readonly %fat_ptr, ptr nocapture readonly %id_ptr) local_unnamed_addr #20 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id.i = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr.i = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %vptr, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, %id.i
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %destination = getelementptr i8, ptr %fat_ptr, i64 24
  %dest_value = load i32, ptr %destination, align 4
  %eq = icmp eq i32 %dest_value, %offset.i
  tail call void @llvm.assume(i1 %eq) #30
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)
declare void @llvm.assume(i1 noundef) #21

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @set_offset(ptr nocapture %fat_ptr, ptr nocapture readonly %id_ptr) local_unnamed_addr #1 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id.i = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr.i = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %vptr, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, %id.i
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %destination = getelementptr i8, ptr %fat_ptr, i64 24
  store i32 %offset.i, ptr %destination, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nocapture readonly %supertype_tbl) #22 {
  %product.i = mul i64 %cand_id, %hash_coef
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash.i
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr nocapture readonly %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr readonly %supertype_tbl) local_unnamed_addr #22 {
  %result = tail call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #0
  ret i1 %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @arg_buffer_filler(ptr nocapture readnone %coroutine) local_unnamed_addr #5 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define ptr @get_current_coroutine() local_unnamed_addr #19 {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture writeonly %from_buf, ptr %to_buf) #23 {
  %from_buf_second_word = getelementptr i8, ptr %from_buf, i64 8
  %from_buf_third_word = getelementptr i8, ptr %from_buf, i64 16
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = tail call ptr @llvm.stacksave.p0() #34
  store ptr %sp, ptr %from_buf, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %retval.i = load i1, ptr @always_one, align 1
  br i1 %retval.i, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  tail call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #24
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #24

; Function Attrs: nounwind
define void @coroutine_yield(ptr nocapture writeonly %current_coroutine) local_unnamed_addr #25 {
  %into_callee_buf = getelementptr i8, ptr %current_coroutine, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture writeonly %into_callee_buf, ptr nonnull @into_caller_buf) #32
  ret void
}

; Function Attrs: nounwind
define void @coroutine_call(ptr %coroutine) local_unnamed_addr #25 {
  %old_into_caller.unpack = load ptr, ptr @into_caller_buf, align 8
  %old_into_caller.unpack1 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  %old_into_caller.unpack2 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr i8, ptr %coroutine, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nonnull writeonly @into_caller_buf, ptr %into_callee_buf) #32
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store ptr %old_into_caller.unpack, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack1, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %old_into_caller.unpack2, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #26

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #26

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #10

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #27

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #27

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #28

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #2 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #3 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
attributes #5 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
attributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) }
attributes #7 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) }
attributes #8 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: read, inaccessiblemem: none) }
attributes #9 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #10 = { nofree nounwind }
attributes #11 = { mustprogress willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #12 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #13 = { mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none) "alloc-family"="malloc" }
attributes #14 = { mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite) "alloc-family"="malloc" }
attributes #15 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #16 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #17 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #18 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #19 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) }
attributes #20 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: write) }
attributes #21 = { mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #22 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) }
attributes #23 = { noinline nounwind memory(readwrite) }
attributes #24 = { noreturn nounwind }
attributes #25 = { nounwind }
attributes #26 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #27 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #28 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #29 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #30 = { mustprogress nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #31 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #32 = { nounwind memory(readwrite) }
attributes #33 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(1) "alloc-family"="malloc" }
attributes #34 = { mustprogress nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
