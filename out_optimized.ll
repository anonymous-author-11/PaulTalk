; ModuleID = 'out_reg2mem.ll'
source_filename = "llvm-link"

@lmasg_Warning_Remove_returned_Nil_for_key_ = internal unnamed_addr constant [37 x i8] c"Warning: Remove returned Nil for key "
@fcfel_Warning_Remove_returned_wrong_value_for_key_ = internal unnamed_addr constant [45 x i8] c"Warning: Remove returned wrong value for key "
@swkjg_Error_Nil_returned_during_random_hit_test_for_key_ = internal unnamed_addr constant [51 x i8] c"Error: Nil returned during random hit test for key "
@fhtqp__unique_keys_for_random_hit_test = internal unnamed_addr constant [33 x i8] c" unique keys for random hit test."
@gvbps_Error_Nil_returned_during_sequential_hit_test_for_key_ = internal unnamed_addr constant [55 x i8] c"Error: Nil returned during sequential hit test for key "
@_parameterization_PairPtri32._Ptri1 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_Ptri32, ptr @_parameterization_Ptri1, ptr null]
@_parameterization_PairPtri32._Ptri32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_Ptri32, ptr @_parameterization_Ptri32, ptr null]
@PRNG_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = constant [4 x i32] [i32 15, i32 10, i32 10, i32 0]
@PRNG = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_data_size_PRNG, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedPtri32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedPtri32, ptr @PRNG_next_] }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i32_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i128_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @i128_typ, ptr @any_typ, ptr null]
@i128_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@f64_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@nothing_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @nothing_typ]
@nothing_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@coroutine_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @coroutine_typ]
@coroutine_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@function_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @buffer_typ, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@tuple_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @tuple_typ]
@tuple_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@union_typ_hashtbl = constant [4 x ptr] [ptr @union_typ, ptr null, ptr @any_typ, ptr @Object]
@union_typ_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@Object_hashtbl = constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@_parameterization_Nil = linkonce_odr constant [2 x ptr] [ptr @nil_typ, ptr null]
@Entry_hashtbl = constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = constant [4 x i32] [i32 10, i32 25, i32 10, i32 0]
@Entry = constant { [3 x i64], [7 x ptr], [15 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_data_size_Entry, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [15 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_primary_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_init_keyK_valueV_primary_hashPtri32, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_primary_hash_, ptr @Entry_B_to_pair_, ptr @Entry_init_keyK_valueV_primary_hashPtri32, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_primary_hash_, ptr @Entry_to_pair_] }
@CuckooMap_hashtbl = constant [8 x ptr] [ptr null, ptr @CuckooMap, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr @HashMap, ptr @Object]
@CuckooMap_offset_tbl = constant [8 x i32] [i32 0, i32 10, i32 259, i32 10, i32 282, i32 199, i32 79, i32 282]
@CuckooMap = constant { [3 x i64], [7 x ptr], [272 x ptr] } { [3 x i64] [i64 3547150501766965522, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @CuckooMap_hashtbl, ptr @CuckooMap_offset_tbl, ptr @_data_size_CuckooMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [272 x ptr] [ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_field_table1, ptr @CuckooMap_field_table2, ptr @CuckooMap_field_table_len, ptr @CuckooMap_field_size, ptr @CuckooMap_field_hasher, ptr @CuckooMap_field_eq, ptr @CuckooMap_B__Self_max_displacements_, ptr @CuckooMap_B_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1, ptr @CuckooMap_B_hash1_keyK, ptr @CuckooMap_B_hash2_from_primary_primary_hashPtri32, ptr @CuckooMap_B_index1_primary_hashPtri32, ptr @CuckooMap_B_index2_primary_hashPtri32, ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32, ptr @CuckooMap_B_resize_, ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_B_insert_keyK_valueV, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Ptri1, ptr @CuckooMap_B_any_fFunctionT_to_Ptri1, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap__Self_max_displacements_, ptr @CuckooMap_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1, ptr @CuckooMap_hash1_keyK, ptr @CuckooMap_hash2_from_primary_primary_hashPtri32, ptr @CuckooMap_index1_primary_hashPtri32, ptr @CuckooMap_index2_primary_hashPtri32, ptr @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V, ptr @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32, ptr @CuckooMap_resize_, ptr @CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil, ptr @CuckooMap_insert_keyK_valueV, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Ptri1, ptr @CuckooMap_B_any_fFunctionT_to_Ptri1, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Ptri1, ptr @CuckooMap_B_any_fFunctionT_to_Ptri1, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Ptri1, ptr @CuckooMap_B_any_fFunctionT_to_Ptri1, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Ptri1, ptr @CuckooMap_B_any_fFunctionT_to_Ptri1, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_0, ptr @CuckooMap_field_CuckooMap_1, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_size_, ptr @CuckooMap_B_get_keyK, ptr @CuckooMap_B__set_index_keyK_valueV, ptr @CuckooMap_B_remove_keyK, ptr @CuckooMap_B_clear_, ptr @CuckooMap_B__index_keyK, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Ptri1, ptr @CuckooMap_B_any_fFunctionT_to_Ptri1, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_size_, ptr @CuckooMap_get_keyK, ptr @CuckooMap__set_index_keyK_valueV, ptr @CuckooMap_remove_keyK, ptr @CuckooMap_clear_, ptr @Map__index_keyK, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Ptri1, ptr @CuckooMap_B_any_fFunctionT_to_Ptri1, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @CuckooMap_field_CuckooMap_6, ptr @CuckooMap_B_iterator_, ptr @CuckooMap_B_each_fFunctionT_to_Nothing, ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @CuckooMap_B_all_fFunctionT_to_Ptri1, ptr @CuckooMap_B_any_fFunctionT_to_Ptri1, ptr @CuckooMap_B_map_fFunctionT_to_U, ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1, ptr @CuckooMap_B_chain_otherIterableT, ptr @CuckooMap_B_interleave_otherIterableT, ptr @CuckooMap_B_zip_otherIterableU, ptr @CuckooMap_B_product_otherIterableU, ptr @CuckooMap_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@CuckooMapIterator_hashtbl = constant [8 x ptr] [ptr @CuckooMapIterator, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr null]
@CuckooMapIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 27, i32 24, i32 27, i32 0, i32 10, i32 0]
@CuckooMapIterator = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 -1975748647346050920, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @CuckooMapIterator_hashtbl, ptr @CuckooMapIterator_offset_tbl, ptr @_data_size_CuckooMapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @CuckooMapIterator_field_CuckooMapIterator_0, ptr @CuckooMapIterator_field_CuckooMapIterator_1, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_field_map_table1, ptr @CuckooMapIterator_field_map_table2, ptr @CuckooMapIterator_field_table_len, ptr @CuckooMapIterator_field_index, ptr @CuckooMapIterator_field_on_second, ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_lenPtri32, ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_lenPtri32, ptr @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil, ptr @CuckooMapIterator_next_, ptr @CuckooMapIterator_field_CuckooMapIterator_2, ptr @CuckooMapIterator_B_next_, ptr @CuckooMapIterator_next_] }
@Entry_field_primary_hash = internal constant { ptr, ptr } { ptr @Entry_getter_primary_hash, ptr @Entry_setter_primary_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@CuckooMap_field_table1 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table1, ptr @CuckooMap_setter_table1 }
@CuckooMap_field_table2 = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table2, ptr @CuckooMap_setter_table2 }
@CuckooMap_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMap_getter_table_len, ptr @CuckooMap_setter_table_len }
@CuckooMap_field_size = internal constant { ptr, ptr } { ptr @CuckooMap_getter_size, ptr @CuckooMap_setter_size }
@CuckooMap_field_hasher = internal constant { ptr, ptr } { ptr @CuckooMap_getter_hasher, ptr @CuckooMap_setter_hasher }
@CuckooMap_field_eq = internal constant { ptr, ptr } { ptr @CuckooMap_getter_eq, ptr @CuckooMap_setter_eq }
@CuckooMapIterator_field_map_table1 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table1, ptr @CuckooMapIterator_setter_map_table1 }
@CuckooMapIterator_field_map_table2 = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_map_table2, ptr @CuckooMapIterator_setter_map_table2 }
@CuckooMapIterator_field_table_len = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_table_len, ptr @CuckooMapIterator_setter_table_len }
@CuckooMapIterator_field_index = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_index, ptr @CuckooMapIterator_setter_index }
@CuckooMapIterator_field_on_second = internal constant { ptr, ptr } { ptr @CuckooMapIterator_getter_on_second, ptr @CuckooMapIterator_setter_on_second }
@KeyNotFound_hashtbl = constant [4 x ptr] [ptr @Object, ptr @KeyNotFound, ptr @any_typ, ptr @Exception]
@KeyNotFound_offset_tbl = constant [4 x i32] [i32 36, i32 10, i32 10, i32 23]
@KeyNotFound = constant { [3 x i64], [7 x ptr], [26 x ptr] } { [3 x i64] [i64 2946564862774055400, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @KeyNotFound_hashtbl, ptr @KeyNotFound_offset_tbl, ptr @_data_size_KeyNotFound, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [26 x ptr] [ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberPtri32_file_nameString, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberPtri32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @KeyNotFound_field_line_number, ptr @KeyNotFound_field_file_name, ptr @KeyNotFound_field_message, ptr @KeyNotFound_B_init_messageString, ptr @KeyNotFound_B_init_, ptr @KeyNotFound_B_set_info_line_numberPtri32_file_nameString, ptr @KeyNotFound_B_report_, ptr @KeyNotFound_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberPtri32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@Map_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr null, ptr @Object]
@Map_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 47, i32 10, i32 70, i32 10, i32 0, i32 70]
@Map = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5249855671126779970, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Map_hashtbl, ptr @Map_offset_tbl, ptr @_data_size_Map, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@HashMap_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Map, ptr @HashMap, ptr @Object]
@HashMap_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 107, i32 10, i32 130, i32 47, i32 10, i32 130]
@HashMap = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_data_size_HashMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@KeyNotFound_field_line_number = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_line_number, ptr @KeyNotFound_setter_line_number }
@KeyNotFound_field_file_name = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_file_name, ptr @KeyNotFound_setter_file_name }
@KeyNotFound_field_message = internal constant { ptr, ptr } { ptr @KeyNotFound_getter_message, ptr @KeyNotFound_setter_message }
@_parameterization_Character = linkonce_odr constant [2 x ptr] [ptr @Character, ptr null]
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 12]
@String_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr @Representable, ptr @Container, ptr @Object, ptr null, ptr null, ptr @String]
@String_offset_tbl = constant [8 x i32] [i32 10, i32 64, i32 87, i32 87, i32 87, i32 0, i32 0, i32 10]
@Character_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = constant [4 x i32] [i32 15, i32 0, i32 10, i32 10]
@StringIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @StringIterator, ptr null]
@StringIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 0, i32 17, i32 10, i32 0]
@Exception_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = constant [4 x i32] [i32 23, i32 0, i32 10, i32 10]
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_length = internal constant { ptr, ptr } { ptr @String_getter_length, ptr @String_setter_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_byte = internal constant { ptr, ptr } { ptr @Character_getter_byte, ptr @Character_setter_byte }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_index, ptr @StringIterator_setter_index }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@_parameterization_Ptri1 = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 10, i32 0]
@Container_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container]
@Container_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Iterator_hashtbl = constant [4 x ptr] [ptr @Iterator, ptr @any_typ, ptr @Container, ptr @Object]
@Iterator_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 13, i32 13]
@Iterable_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Object]
@Iterable_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 33, i32 33]
@MapIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @MapIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@MapIterable_offset_tbl = constant [8 x i32] [i32 0, i32 61, i32 10, i32 38, i32 61, i32 0, i32 0, i32 10]
@MapIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @MapIterator, ptr @Container, ptr null, ptr @Iterator, ptr null, ptr null]
@MapIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 10, i32 21, i32 0, i32 18, i32 0, i32 0]
@FilterIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @FilterIterable, ptr null, ptr @Container, ptr @Iterable, ptr null]
@FilterIterable_offset_tbl = constant [8 x i32] [i32 0, i32 60, i32 10, i32 10, i32 0, i32 60, i32 37, i32 0]
@FilterIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterator, ptr @FilterIterator, ptr null]
@FilterIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 0, i32 17, i32 10, i32 0]
@ChainIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @ChainIterable, ptr @Container, ptr null, ptr null, ptr @Object]
@ChainIterable_offset_tbl = constant [8 x i32] [i32 10, i32 37, i32 0, i32 10, i32 60, i32 0, i32 0, i32 60]
@ChainIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ChainIterator]
@ChainIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 21, i32 18, i32 21, i32 0, i32 10, i32 10]
@InterleaveIterable_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @InterleaveIterable, ptr @Iterable, ptr @Object, ptr null, ptr null, ptr @any_typ]
@InterleaveIterable_offset_tbl = constant [8 x i32] [i32 0, i32 60, i32 10, i32 37, i32 60, i32 0, i32 0, i32 10]
@InterleaveIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @InterleaveIterator, ptr @Iterator, ptr null, ptr null]
@InterleaveIterator_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 0, i32 21, i32 10, i32 18, i32 0, i32 0]
@ZipIterable_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Container, ptr null, ptr @ZipIterable, ptr @Object]
@ZipIterable_offset_tbl = constant [8 x i32] [i32 10, i32 39, i32 0, i32 0, i32 62, i32 0, i32 10, i32 62]
@ZipIterator_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Container, ptr @Iterator, ptr @Object, ptr null, ptr @any_typ, ptr @ZipIterator]
@ZipIterator_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 22, i32 19, i32 22, i32 0, i32 10, i32 10]
@ProductIterable_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @ProductIterable, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr null]
@ProductIterable_offset_tbl = constant [8 x i32] [i32 62, i32 10, i32 10, i32 62, i32 0, i32 39, i32 0, i32 0]
@ProductIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @Iterator, ptr null, ptr @Container, ptr @Object, ptr null, ptr @ProductIterator]
@ProductIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 21, i32 0, i32 24, i32 24, i32 0, i32 10]
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@MapIterable_field_iterable = internal constant { ptr, ptr } { ptr @MapIterable_getter_iterable, ptr @MapIterable_setter_iterable }
@MapIterable_field_f = internal constant { ptr, ptr } { ptr @MapIterable_getter_f, ptr @MapIterable_setter_f }
@MapIterator_field_iterator = internal constant { ptr, ptr } { ptr @MapIterator_getter_iterator, ptr @MapIterator_setter_iterator }
@MapIterator_field_f = internal constant { ptr, ptr } { ptr @MapIterator_getter_f, ptr @MapIterator_setter_f }
@FilterIterable_field_iterable = internal constant { ptr, ptr } { ptr @FilterIterable_getter_iterable, ptr @FilterIterable_setter_iterable }
@FilterIterable_field_f = internal constant { ptr, ptr } { ptr @FilterIterable_getter_f, ptr @FilterIterable_setter_f }
@FilterIterator_field_iterator = internal constant { ptr, ptr } { ptr @FilterIterator_getter_iterator, ptr @FilterIterator_setter_iterator }
@FilterIterator_field_f = internal constant { ptr, ptr } { ptr @FilterIterator_getter_f, ptr @FilterIterator_setter_f }
@ChainIterable_field_first = internal constant { ptr, ptr } { ptr @ChainIterable_getter_first, ptr @ChainIterable_setter_first }
@ChainIterable_field_second = internal constant { ptr, ptr } { ptr @ChainIterable_getter_second, ptr @ChainIterable_setter_second }
@ChainIterator_field_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_first, ptr @ChainIterator_setter_first }
@ChainIterator_field_second = internal constant { ptr, ptr } { ptr @ChainIterator_getter_second, ptr @ChainIterator_setter_second }
@ChainIterator_field_on_first = internal constant { ptr, ptr } { ptr @ChainIterator_getter_on_first, ptr @ChainIterator_setter_on_first }
@InterleaveIterable_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_first, ptr @InterleaveIterable_setter_first }
@InterleaveIterable_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterable_getter_second, ptr @InterleaveIterable_setter_second }
@InterleaveIterator_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_first, ptr @InterleaveIterator_setter_first }
@InterleaveIterator_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_second, ptr @InterleaveIterator_setter_second }
@InterleaveIterator_field_on_first = internal constant { ptr, ptr } { ptr @InterleaveIterator_getter_on_first, ptr @InterleaveIterator_setter_on_first }
@ZipIterable_field_first = internal constant { ptr, ptr } { ptr @ZipIterable_getter_first, ptr @ZipIterable_setter_first }
@ZipIterable_field_second = internal constant { ptr, ptr } { ptr @ZipIterable_getter_second, ptr @ZipIterable_setter_second }
@ZipIterator_field_first = internal constant { ptr, ptr } { ptr @ZipIterator_getter_first, ptr @ZipIterator_setter_first }
@ZipIterator_field_second = internal constant { ptr, ptr } { ptr @ZipIterator_getter_second, ptr @ZipIterator_setter_second }
@ProductIterable_field_first = internal constant { ptr, ptr } { ptr @ProductIterable_getter_first, ptr @ProductIterable_setter_first }
@ProductIterable_field_second = internal constant { ptr, ptr } { ptr @ProductIterable_getter_second, ptr @ProductIterable_setter_second }
@ProductIterator_field_first_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_first_iterator, ptr @ProductIterator_setter_first_iterator }
@ProductIterator_field_second_iterator = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterator, ptr @ProductIterator_setter_second_iterator }
@ProductIterator_field_second_iterable = internal constant { ptr, ptr } { ptr @ProductIterator_getter_second_iterable, ptr @ProductIterator_setter_second_iterable }
@ProductIterator_field_current_first = internal constant { ptr, ptr } { ptr @ProductIterator_getter_current_first, ptr @ProductIterator_setter_current_first }
@Math_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Math]
@Math_offset_tbl = constant [4 x i32] [i32 27, i32 0, i32 10, i32 10]
@Math = constant { [3 x i64], [7 x ptr], [17 x ptr] } { [3 x i64] [i64 8094150130346788308, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Math_hashtbl, ptr @Math_offset_tbl, ptr @_data_size_Math, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [17 x ptr] [ptr @Math_B__Self_sqrt_xPtrf64, ptr @Math_B__Self_abs_xPtrf64__Self_abs_xPtri32, ptr @Math_B__Self_max_aPtrf64_bPtrf64__Self_max_aPtri32_bPtri32, ptr @Math_B__Self_min_aPtrf64_bPtrf64__Self_min_aPtri32_bPtri32, ptr @Math_B__Self_round_xPtrf64, ptr @Math_B__Self_floor_xPtrf64, ptr @Math_B__Self_ceiling_xPtrf64, ptr @Math__Self_sqrt_xPtrf64, ptr @Math__Self_abs_xPtrf64, ptr @Math__Self_abs_xPtri32, ptr @Math__Self_max_aPtrf64_bPtrf64, ptr @Math__Self_max_aPtri32_bPtri32, ptr @Math__Self_min_aPtrf64_bPtrf64, ptr @Math__Self_min_aPtri32_bPtri32, ptr @Math__Self_round_xPtrf64, ptr @Math__Self_floor_xPtrf64, ptr @Math__Self_ceiling_xPtrf64] }
@Range_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable, ptr null, ptr @Range]
@Range_offset_tbl = constant [8 x i32] [i32 65, i32 10, i32 0, i32 65, i32 0, i32 42, i32 0, i32 10]
@Range = constant { [3 x i64], [7 x ptr], [55 x ptr] } { [3 x i64] [i64 5490049236840671069, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Range_hashtbl, ptr @Range_offset_tbl, ptr @_data_size_Range, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [55 x ptr] [ptr @Range_field_start, ptr @Range_field_end, ptr @Range_field_step, ptr @Range_field_Range_0, ptr @Range_B_init_endPtri32, ptr @Range_B_init_startPtri32_endPtri32, ptr @Range_B_step_stepPtri32, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Ptri1, ptr @Range_B_any_fFunctionT_to_Ptri1, ptr @Range_B_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Ptri1, ptr @Range_B_chain_otherIterableT, ptr @Range_B_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU, ptr @Range_B_product_otherIterableU, ptr @Range_init_endPtri32, ptr @Range_init_startPtri32_endPtri32, ptr @Range_step_stepPtri32, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Ptri1, ptr @Range_B_any_fFunctionT_to_Ptri1, ptr @Range_B_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Ptri1, ptr @Range_B_chain_otherIterableT, ptr @Range_B_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU, ptr @Range_B_product_otherIterableU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@RangeIterator_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @Iterator, ptr @RangeIterator, ptr @Container, ptr @Object, ptr null, ptr null]
@RangeIterator_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 18, i32 10, i32 21, i32 21, i32 0, i32 0]
@RangeIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -913562485944406675, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @RangeIterator_hashtbl, ptr @RangeIterator_offset_tbl, ptr @_data_size_RangeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @RangeIterator_field_counter, ptr @RangeIterator_field_end, ptr @RangeIterator_field_step, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_init_counterPtri32_endPtri32_stepPtri32, ptr @RangeIterator_B_next_, ptr @RangeIterator_init_counterPtri32_endPtri32_stepPtri32, ptr @RangeIterator_next_, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_next_, ptr @RangeIterator_next_] }
@Range_field_start = internal constant { ptr, ptr } { ptr @Range_getter_start, ptr @Range_setter_start }
@Range_field_end = internal constant { ptr, ptr } { ptr @Range_getter_end, ptr @Range_setter_end }
@Range_field_step = internal constant { ptr, ptr } { ptr @Range_getter_step, ptr @Range_setter_step }
@RangeIterator_field_counter = internal constant { ptr, ptr } { ptr @RangeIterator_getter_counter, ptr @RangeIterator_setter_counter }
@RangeIterator_field_end = internal constant { ptr, ptr } { ptr @RangeIterator_getter_end, ptr @RangeIterator_setter_end }
@RangeIterator_field_step = internal constant { ptr, ptr } { ptr @RangeIterator_getter_step, ptr @RangeIterator_setter_step }
@IO_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 20]
@Blocking_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Blocking, ptr null]
@Blocking_offset_tbl = constant [4 x i32] [i32 12, i32 10, i32 10, i32 0]
@Blocking = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 847773162914674935, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Blocking_hashtbl, ptr @Blocking_offset_tbl, ptr @_data_size_Blocking, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Blocking_B_init_, ptr @Blocking_init_] }
@Channel_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Channel]
@Channel_offset_tbl = constant [4 x i32] [i32 18, i32 10, i32 0, i32 10]
@Channel = constant { [3 x i64], [7 x ptr], [8 x ptr] } { [3 x i64] [i64 -3668118116639750450, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Channel_hashtbl, ptr @Channel_offset_tbl, ptr @_data_size_Channel, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [8 x ptr] [ptr @Channel_field_Channel_0, ptr @Channel_field_value, ptr @Channel_B_init_, ptr @Channel_B_get_, ptr @Channel_B_put_new_valueT, ptr @Channel_init_, ptr @Channel_get_, ptr @Channel_put_new_valueT] }
@Channel_field_value = internal constant { ptr, ptr } { ptr @Channel_getter_value, ptr @Channel_setter_value }
@Array_hashtbl = constant [8 x ptr] [ptr null, ptr null, ptr @Iterable, ptr @any_typ, ptr @Container, ptr @Array, ptr @Representable, ptr @Object]
@Array_offset_tbl = constant [8 x i32] [i32 0, i32 0, i32 68, i32 10, i32 91, i32 10, i32 91, i32 91]
@Array = constant { [3 x i64], [7 x ptr], [83 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427388331, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_data_size_Array, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [83 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_B__Self_from_iterable_iterableIterableT, ptr @Array_B_init_, ptr @Array_B_init_capacityPtri32, ptr @Array_B_init_lengthPtri32_capacityPtri32, ptr @Array_B_init_bufferBufferT_lengthPtri32_capacityPtri32, ptr @Array_B_length_, ptr @Array_B_capacity_, ptr @Array_B_append_xT, ptr @Array_B_extend_otherArrayT, ptr @Array_B_reserve_new_capacityPtri32, ptr @Array_B__index_xPtri32, ptr @Array_B__set_index_xPtri32_valueT, ptr @Array_B_throw_oob_xPtri32, ptr @Array_B_unchecked_index_xPtri32, ptr @Array_B_unchecked_insert_xPtri32_valueT, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Ptri1, ptr @Array_B_any_fFunctionT_to_Ptri1, ptr @Array_B_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Ptri1, ptr @Array_B_chain_otherIterableT, ptr @Array_B_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU, ptr @Array_B_product_otherIterableU, ptr @Array_B_repr_, ptr @Array__Self_from_iterable_iterableIterableT, ptr @Array_init_, ptr @Array_init_capacityPtri32, ptr @Array_init_lengthPtri32_capacityPtri32, ptr @Array_init_bufferBufferT_lengthPtri32_capacityPtri32, ptr @Array_length_, ptr @Array_capacity_, ptr @Array_append_xT, ptr @Array_extend_otherArrayT, ptr @Array_reserve_new_capacityPtri32, ptr @Array__index_xPtri32, ptr @Array__set_index_xPtri32_valueT, ptr @Array_throw_oob_xPtri32, ptr @Array_unchecked_index_xPtri32, ptr @Array_unchecked_insert_xPtri32_valueT, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_repr_, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Ptri1, ptr @Array_B_any_fFunctionT_to_Ptri1, ptr @Array_B_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Ptri1, ptr @Array_B_chain_otherIterableT, ptr @Array_B_interleave_otherIterableT, ptr @Array_B_zip_otherIterableU, ptr @Array_B_product_otherIterableU, ptr @Array_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Array_B_repr_, ptr @Array_repr_] }
@ArrayIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @ArrayIterator, ptr @Iterator, ptr null, ptr null]
@ArrayIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 10, i32 17, i32 0, i32 0]
@ArrayIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_data_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@_parameterization_Ptri64 = linkonce_odr constant [2 x ptr] [ptr @i64_typ, ptr null]
@_parameterization_File = linkonce_odr constant [2 x ptr] [ptr @File, ptr null]
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@_parameterization_Ptri32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@i128_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -8755878215469463641, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i128_typ_hashtbl, ptr @i128_typ_offset_tbl, ptr @_data_size_i128_typ, ptr @_box_i128_typ, ptr @_unbox_i128_typ, ptr @_data_size_i128_typ], [0 x ptr] undef }
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@nothing_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -3334456163433371378, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @nothing_typ_hashtbl, ptr @nothing_typ_offset_tbl, ptr @_data_size_nothing_typ, ptr @_box_nothing_typ, ptr @_unbox_nothing_typ, ptr @_data_size_nothing_typ], [0 x ptr] undef }
@coroutine_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7194361020959218064, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @coroutine_typ_hashtbl, ptr @coroutine_typ_offset_tbl, ptr @_data_size_coroutine_typ, ptr @_box_coroutine_typ, ptr @_unbox_coroutine_typ, ptr @_data_size_coroutine_typ], [0 x ptr] undef }
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@tuple_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3422634369532007740, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @tuple_typ_hashtbl, ptr @tuple_typ_offset_tbl, ptr @_data_size_tuple_typ, ptr @_box_tuple_typ, ptr @_unbox_tuple_typ, ptr @_data_size_tuple_typ], [0 x ptr] undef }
@union_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7543233778997666740, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @union_typ_hashtbl, ptr @union_typ_offset_tbl, ptr @_data_size_union_typ, ptr @_box_union_typ, ptr @_unbox_union_typ, ptr @_data_size_union_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Pair = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_init_firstT_secondU, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_] }
@Container = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 9056556090793359372, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Container_hashtbl, ptr @Container_offset_tbl, ptr @_data_size_Container, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388349, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388477, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@MapIterable = constant { [3 x i64], [7 x ptr], [51 x ptr] } { [3 x i64] [i64 -7488770571603291722, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterable_hashtbl, ptr @MapIterable_offset_tbl, ptr @_data_size_MapIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [51 x ptr] [ptr @MapIterable_field_MapIterable_0, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_field_iterable, ptr @MapIterable_field_f, ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Ptri1, ptr @MapIterable_B_any_fFunctionT_to_Ptri1, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Ptri1, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_init_iterableIterableT_fFunctionT_to_U, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MapIterable_field_MapIterable_1, ptr @MapIterable_B_iterator_, ptr @MapIterable_B_each_fFunctionT_to_Nothing, ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable_B_all_fFunctionT_to_Ptri1, ptr @MapIterable_B_any_fFunctionT_to_Ptri1, ptr @MapIterable_B_map_fFunctionT_to_U, ptr @MapIterable_B_filter_fFunctionT_to_Ptri1, ptr @MapIterable_B_chain_otherIterableT, ptr @MapIterable_B_interleave_otherIterableT, ptr @MapIterable_B_zip_otherIterableU, ptr @MapIterable_B_product_otherIterableU, ptr @MapIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MapIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -146553482626734782, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterator_hashtbl, ptr @MapIterator_offset_tbl, ptr @_data_size_MapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @MapIterator_field_MapIterator_0, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_field_iterator, ptr @MapIterator_field_f, ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_B_next_, ptr @MapIterator_init_iteratorIteratorT_fFunctionT_to_U, ptr @MapIterator_next_, ptr @MapIterator_field_MapIterator_1, ptr @MapIterator_B_next_, ptr @MapIterator_next_] }
@FilterIterable = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 8498466713076104350, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterable_hashtbl, ptr @FilterIterable_offset_tbl, ptr @_data_size_FilterIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_field_iterable, ptr @FilterIterable_field_f, ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Ptri1, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Ptri1, ptr @FilterIterable_B_any_fFunctionT_to_Ptri1, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Ptri1, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_init_iterableIterableT_fFunctionT_to_Ptri1, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @FilterIterable_field_FilterIterable_0, ptr @FilterIterable_B_iterator_, ptr @FilterIterable_B_each_fFunctionT_to_Nothing, ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable_B_all_fFunctionT_to_Ptri1, ptr @FilterIterable_B_any_fFunctionT_to_Ptri1, ptr @FilterIterable_B_map_fFunctionT_to_U, ptr @FilterIterable_B_filter_fFunctionT_to_Ptri1, ptr @FilterIterable_B_chain_otherIterableT, ptr @FilterIterable_B_interleave_otherIterableT, ptr @FilterIterable_B_zip_otherIterableU, ptr @FilterIterable_B_product_otherIterableU, ptr @FilterIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@FilterIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -1221365496900303883, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterator_hashtbl, ptr @FilterIterator_offset_tbl, ptr @_data_size_FilterIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_field_iterator, ptr @FilterIterator_field_f, ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Ptri1, ptr @FilterIterator_B_next_, ptr @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Ptri1, ptr @FilterIterator_next_, ptr @FilterIterator_field_FilterIterator_0, ptr @FilterIterator_B_next_, ptr @FilterIterator_next_] }
@ChainIterable = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 -2370247058431047815, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterable_hashtbl, ptr @ChainIterable_offset_tbl, ptr @_data_size_ChainIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_field_first, ptr @ChainIterable_field_second, ptr @ChainIterable_B_init_firstIterableT_secondIterableT, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Ptri1, ptr @ChainIterable_B_any_fFunctionT_to_Ptri1, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Ptri1, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_init_firstIterableT_secondIterableT, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainIterable_field_ChainIterable_0, ptr @ChainIterable_B_iterator_, ptr @ChainIterable_B_each_fFunctionT_to_Nothing, ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable_B_all_fFunctionT_to_Ptri1, ptr @ChainIterable_B_any_fFunctionT_to_Ptri1, ptr @ChainIterable_B_map_fFunctionT_to_U, ptr @ChainIterable_B_filter_fFunctionT_to_Ptri1, ptr @ChainIterable_B_chain_otherIterableT, ptr @ChainIterable_B_interleave_otherIterableT, ptr @ChainIterable_B_zip_otherIterableU, ptr @ChainIterable_B_product_otherIterableU, ptr @ChainIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6043157723929225452, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterator_hashtbl, ptr @ChainIterator_offset_tbl, ptr @_data_size_ChainIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_field_first, ptr @ChainIterator_field_second, ptr @ChainIterator_field_on_first, ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_B_next_, ptr @ChainIterator_init_firstIteratorT_secondIteratorT, ptr @ChainIterator_next_, ptr @ChainIterator_field_ChainIterator_0, ptr @ChainIterator_B_next_, ptr @ChainIterator_next_] }
@InterleaveIterable = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 4936782714255954462, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterable_hashtbl, ptr @InterleaveIterable_offset_tbl, ptr @_data_size_InterleaveIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_field_first, ptr @InterleaveIterable_field_second, ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Ptri1, ptr @InterleaveIterable_B_any_fFunctionT_to_Ptri1, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Ptri1, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_init_firstIterableT_secondIterableT, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleaveIterable_field_InterleaveIterable_0, ptr @InterleaveIterable_B_iterator_, ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable_B_all_fFunctionT_to_Ptri1, ptr @InterleaveIterable_B_any_fFunctionT_to_Ptri1, ptr @InterleaveIterable_B_map_fFunctionT_to_U, ptr @InterleaveIterable_B_filter_fFunctionT_to_Ptri1, ptr @InterleaveIterable_B_chain_otherIterableT, ptr @InterleaveIterable_B_interleave_otherIterableT, ptr @InterleaveIterable_B_zip_otherIterableU, ptr @InterleaveIterable_B_product_otherIterableU, ptr @InterleaveIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleaveIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3924664358248524505, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterator_hashtbl, ptr @InterleaveIterator_offset_tbl, ptr @_data_size_InterleaveIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_field_first, ptr @InterleaveIterator_field_second, ptr @InterleaveIterator_field_on_first, ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_init_firstIteratorT_secondIteratorT, ptr @InterleaveIterator_next_, ptr @InterleaveIterator_field_InterleaveIterator_0, ptr @InterleaveIterator_B_next_, ptr @InterleaveIterator_next_] }
@ZipIterable = constant { [3 x i64], [7 x ptr], [52 x ptr] } { [3 x i64] [i64 35232740166152944, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterable_hashtbl, ptr @ZipIterable_offset_tbl, ptr @_data_size_ZipIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [52 x ptr] [ptr @ZipIterable_field_ZipIterable_0, ptr @ZipIterable_field_ZipIterable_1, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_field_first, ptr @ZipIterable_field_second, ptr @ZipIterable_B_init_firstIterableT_secondIterableU, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Ptri1, ptr @ZipIterable_B_any_fFunctionT_to_Ptri1, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Ptri1, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_init_firstIterableT_secondIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZipIterable_field_ZipIterable_2, ptr @ZipIterable_B_iterator_, ptr @ZipIterable_B_each_fFunctionT_to_Nothing, ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable_B_all_fFunctionT_to_Ptri1, ptr @ZipIterable_B_any_fFunctionT_to_Ptri1, ptr @ZipIterable_B_map_fFunctionT_to_U, ptr @ZipIterable_B_filter_fFunctionT_to_Ptri1, ptr @ZipIterable_B_chain_otherIterableT, ptr @ZipIterable_B_interleave_otherIterableT, ptr @ZipIterable_B_zip_otherIterableU, ptr @ZipIterable_B_product_otherIterableU, ptr @ZipIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZipIterator = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 -2141114445739585318, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterator_hashtbl, ptr @ZipIterator_offset_tbl, ptr @_data_size_ZipIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @ZipIterator_field_ZipIterator_0, ptr @ZipIterator_field_ZipIterator_1, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_field_first, ptr @ZipIterator_field_second, ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_B_next_, ptr @ZipIterator_init_firstIteratorT_secondIteratorU, ptr @ZipIterator_next_, ptr @ZipIterator_field_ZipIterator_2, ptr @ZipIterator_B_next_, ptr @ZipIterator_next_] }
@ProductIterable = constant { [3 x i64], [7 x ptr], [52 x ptr] } { [3 x i64] [i64 4128338911757318636, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterable_hashtbl, ptr @ProductIterable_offset_tbl, ptr @_data_size_ProductIterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [52 x ptr] [ptr @ProductIterable_field_ProductIterable_0, ptr @ProductIterable_field_ProductIterable_1, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_field_first, ptr @ProductIterable_field_second, ptr @ProductIterable_B_init_firstIterableT_secondIterableU, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Ptri1, ptr @ProductIterable_B_any_fFunctionT_to_Ptri1, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Ptri1, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_init_firstIterableT_secondIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductIterable_field_ProductIterable_2, ptr @ProductIterable_B_iterator_, ptr @ProductIterable_B_each_fFunctionT_to_Nothing, ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable_B_all_fFunctionT_to_Ptri1, ptr @ProductIterable_B_any_fFunctionT_to_Ptri1, ptr @ProductIterable_B_map_fFunctionT_to_U, ptr @ProductIterable_B_filter_fFunctionT_to_Ptri1, ptr @ProductIterable_B_chain_otherIterableT, ptr @ProductIterable_B_interleave_otherIterableT, ptr @ProductIterable_B_zip_otherIterableU, ptr @ProductIterable_B_product_otherIterableU, ptr @ProductIterable_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductIterator = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 1697250377212095568, i64 4611686018427388157, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterator_hashtbl, ptr @ProductIterator_offset_tbl, ptr @_data_size_ProductIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @ProductIterator_field_ProductIterator_0, ptr @ProductIterator_field_ProductIterator_1, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_field_first_iterator, ptr @ProductIterator_field_second_iterator, ptr @ProductIterator_field_second_iterable, ptr @ProductIterator_field_current_first, ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_B_next_, ptr @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU, ptr @ProductIterator_next_, ptr @ProductIterator_field_ProductIterator_2, ptr @ProductIterator_B_next_, ptr @ProductIterator_next_] }
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@String = constant { [3 x i64], [7 x ptr], [79 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427388601, i64 7], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [79 x ptr] [ptr @String_field_bytes, ptr @String_field_length, ptr @String_field_capacity, ptr @String_field_String_0, ptr @String_B__Self_from_c_string_c_stringBufferPtri8, ptr @String_B_init_, ptr @String_B_init_bytesBufferPtri8_lengthPtri32_capacityPtri32, ptr @String_B_length_, ptr @String_B_capacity_, ptr @String_B_bytes_, ptr @String_B_c_string_, ptr @String_B_append_xPtri8, ptr @String_B_extend_strString, ptr @String_B__index_xPtri32, ptr @String_B__EQ_otherString, ptr @String_B_pop_, ptr @String_B_copy_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Ptri1, ptr @String_B_any_fFunctionT_to_Ptri1, ptr @String_B_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Ptri1, ptr @String_B_chain_otherIterableT, ptr @String_B_interleave_otherIterableT, ptr @String_B_zip_otherIterableU, ptr @String_B_product_otherIterableU, ptr @String_B_repr_, ptr @String__Self_from_c_string_c_stringBufferPtri8, ptr @String_init_, ptr @String_init_bytesBufferPtri8_lengthPtri32_capacityPtri32, ptr @String_length_, ptr @String_capacity_, ptr @String_bytes_, ptr @String_c_string_, ptr @String_append_xPtri8, ptr @String_extend_strString, ptr @String__index_xPtri32, ptr @String__EQ_otherString, ptr @String_pop_, ptr @String_copy_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_repr_, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Ptri1, ptr @String_B_any_fFunctionT_to_Ptri1, ptr @String_B_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Ptri1, ptr @String_B_chain_otherIterableT, ptr @String_B_interleave_otherIterableT, ptr @String_B_zip_otherIterableU, ptr @String_B_product_otherIterableU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Ptri1, ptr @Iterable_any_fFunctionT_to_Ptri1, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Ptri1, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_B_repr_, ptr @String_repr_] }
@Character = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @Character_field_byte, ptr @Character_B_byte_, ptr @Character_B_init_bytePtri8, ptr @Character_byte_, ptr @Character_init_bytePtri8] }
@StringIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_index, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_] }
@Exception = constant { [3 x i64], [7 x ptr], [13 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [13 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberPtri32_file_nameString, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberPtri32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@IO = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_data_size_IO, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @IO_B__Self_print_xString__Self_print_xPtri1__Self_print_xPtri32__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xPtrf64__Self_print_xNil__Self_print_xPtri64__Self_print_xPtri8, ptr @IO__Self_print_xString, ptr @IO__Self_print_xPtri1, ptr @IO__Self_print_xPtri32, ptr @IO__Self_print_xCharacter, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xPtrf64, ptr @IO__Self_print_xNil, ptr @IO__Self_print_xPtri64, ptr @IO__Self_print_xPtri8] }
@FileSystemError_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @FileSystemError, ptr @Object, ptr @Exception]
@FileSystemError_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 36, i32 23]
@FileSystemError = constant { [3 x i64], [7 x ptr], [26 x ptr] } { [3 x i64] [i64 -4504708879057548074, i64 4611686018427388291, i64 3], [7 x ptr] [ptr @subtype_test, ptr @FileSystemError_hashtbl, ptr @FileSystemError_offset_tbl, ptr @_data_size_FileSystemError, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [26 x ptr] [ptr @FileSystemError_field_line_number, ptr @FileSystemError_field_file_name, ptr @FileSystemError_field_message, ptr @FileSystemError_B_init_messageString, ptr @FileSystemError_B_init_, ptr @FileSystemError_B_set_info_line_numberPtri32_file_nameString, ptr @FileSystemError_B_report_, ptr @FileSystemError_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberPtri32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @FileSystemError_field_line_number, ptr @FileSystemError_field_file_name, ptr @FileSystemError_field_message, ptr @FileSystemError_B_init_messageString, ptr @FileSystemError_B_init_, ptr @FileSystemError_B_set_info_line_numberPtri32_file_nameString, ptr @FileSystemError_B_report_, ptr @FileSystemError_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberPtri32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@File_hashtbl = constant [4 x ptr] [ptr @File, ptr null, ptr @any_typ, ptr @Object]
@File_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 30]
@File = constant { [3 x i64], [7 x ptr], [20 x ptr] } { [3 x i64] [i64 -2227788838181535664, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @File_hashtbl, ptr @File_offset_tbl, ptr @_data_size_File, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [20 x ptr] [ptr @File_field_name, ptr @File_field_mode, ptr @File_field_handle, ptr @File_field_open, ptr @File_B_init_nameString_modeString, ptr @File_B__set_mode_modeString, ptr @File_B_reopen_, ptr @File_B_close_, ptr @File_B_size_, ptr @File_B_read_, ptr @File_B_read_byte_, ptr @File_B_write_textString, ptr @File_init_nameString_modeString, ptr @File__set_mode_modeString, ptr @File_reopen_, ptr @File_close_, ptr @File_size_, ptr @File_read_, ptr @File_read_byte_, ptr @File_write_textString] }
@FileProcessor_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @FileProcessor, ptr null]
@FileProcessor_offset_tbl = constant [4 x i32] [i32 13, i32 10, i32 10, i32 0]
@FileProcessor = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 4146660827496349788, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @FileProcessor_hashtbl, ptr @FileProcessor_offset_tbl, ptr @_data_size_FileProcessor, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@FileReader_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @FileProcessor, ptr @FileReader]
@FileReader_offset_tbl = constant [4 x i32] [i32 18, i32 10, i32 15, i32 10]
@FileReader = constant { [3 x i64], [7 x ptr], [8 x ptr] } { [3 x i64] [i64 5641023583277533454, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @FileReader_hashtbl, ptr @FileReader_offset_tbl, ptr @_data_size_FileReader, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [8 x ptr] [ptr @FileReader_field_FileReader_0, ptr @FileReader_B_init_, ptr @FileReader_B_process_fileFile, ptr @FileReader_init_, ptr @FileReader_process_fileFile, ptr @FileReader_field_FileReader_0, ptr @FileReader_B_process_fileFile, ptr @FileReader_process_fileFile] }
@FileWriter_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @FileProcessor, ptr @FileWriter]
@FileWriter_offset_tbl = constant [4 x i32] [i32 19, i32 10, i32 16, i32 10]
@FileWriter = constant { [3 x i64], [7 x ptr], [9 x ptr] } { [3 x i64] [i64 2522433070607690589, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @FileWriter_hashtbl, ptr @FileWriter_offset_tbl, ptr @_data_size_FileWriter, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [9 x ptr] [ptr @FileWriter_field_text, ptr @FileWriter_field_FileWriter_0, ptr @FileWriter_B_init_textString, ptr @FileWriter_B_process_fileFile, ptr @FileWriter_init_textString, ptr @FileWriter_process_fileFile, ptr @FileWriter_field_FileWriter_0, ptr @FileWriter_B_process_fileFile, ptr @FileWriter_process_fileFile] }
@FileSystem_hashtbl = constant [4 x ptr] [ptr @Object, ptr @FileSystem, ptr @any_typ, ptr null]
@FileSystem_offset_tbl = constant [4 x i32] [i32 17, i32 10, i32 10, i32 0]
@FileSystem = constant { [3 x i64], [7 x ptr], [7 x ptr] } { [3 x i64] [i64 5344209596779946859, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @FileSystem_hashtbl, ptr @FileSystem_offset_tbl, ptr @_data_size_FileSystem, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [7 x ptr] [ptr @FileSystem_B__Self_process_file_file_nameString_modeString_processorFunctionFile_to_T__Self_process_file_file_nameString_modeString_processorFileProcessorT, ptr @FileSystem_B__Self_read_file_file_nameString, ptr @FileSystem_B__Self_write_file_file_nameString_textString, ptr @FileSystem__Self_process_file_file_nameString_modeString_processorFunctionFile_to_T, ptr @FileSystem__Self_process_file_file_nameString_modeString_processorFileProcessorT, ptr @FileSystem__Self_read_file_file_nameString, ptr @FileSystem__Self_write_file_file_nameString_textString] }
@FileSystemError_field_line_number = internal constant { ptr, ptr } { ptr @FileSystemError_getter_line_number, ptr @FileSystemError_setter_line_number }
@FileSystemError_field_file_name = internal constant { ptr, ptr } { ptr @FileSystemError_getter_file_name, ptr @FileSystemError_setter_file_name }
@FileSystemError_field_message = internal constant { ptr, ptr } { ptr @FileSystemError_getter_message, ptr @FileSystemError_setter_message }
@File_field_name = internal constant { ptr, ptr } { ptr @File_getter_name, ptr @File_setter_name }
@File_field_mode = internal constant { ptr, ptr } { ptr @File_getter_mode, ptr @File_setter_mode }
@File_field_handle = internal constant { ptr, ptr } { ptr @File_getter_handle, ptr @File_setter_handle }
@File_field_open = internal constant { ptr, ptr } { ptr @File_getter_open, ptr @File_setter_open }
@FileWriter_field_text = internal constant { ptr, ptr } { ptr @FileWriter_getter_text, ptr @FileWriter_setter_text }
@string_string.113 = internal constant [4 x i8] c"%s\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local local_unnamed_addr global ptr null
@always_one = linkonce thread_local local_unnamed_addr global i1 true
@current_ptr = internal thread_local global ptr null

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_PRNG(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @PRNG_init_initial_seedPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull %.fca.0.extract) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %. = tail call i32 @llvm.smax.i32(i32 %3, i32 1)
  tail call void %10(ptr %.fca.1.extract, i32 %.) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !4
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i32 %8(ptr %.fca.1.extract) #37
  %10 = mul i32 %9, 1103515245
  %11 = add i32 %10, 12345
  %12 = and i32 %11, 2147483647
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #35
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 %12) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #35
  %17 = load ptr, ptr %6, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call i32 %18(ptr %.fca.1.extract) #37
  ret i32 %19
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

define i1 @wgpehabsqq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @jytlqghthm(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @vzdjjwynyr(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @pycmovwgqt(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @thuccbiyie(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @mfvrojumog(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @vwrhczetrx(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @lystgjlake(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @afcwmpmbdj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @cjkjdjoefc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @cpgcncwmpd(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @dwgqcbbuns(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @krjmirxnlg(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @svlbjxscwh(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @sabllqfhim(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @nyirajlwbb(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @uzenkwklxl(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @sztlnbvhek(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @bnwmaetavp(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @rabbojnpqi(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

; Function Attrs: nounwind
define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !7
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !7
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !7
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !7
  %4 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %5 = ptrtoint ptr %.fca.1.extract to i64
  %6 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i.i to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %6 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext214 = zext i64 %5 to i160
  %.sroa.3.8.insert.insert215 = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext214
  %7 = insertvalue { ptr, i160 } %4, i160 %.sroa.3.8.insert.insert215, 1
  %8 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8) #35
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  %11 = icmp eq ptr %.fca.0.extract, @f64_typ
  br i1 %11, label %._crit_edge.lr.ph.i, label %12

12:                                               ; preds = %3
  %13 = icmp eq ptr %.fca.0.extract, @i64_typ
  br i1 %13, label %._crit_edge.lr.ph.i, label %14

14:                                               ; preds = %12
  %15 = icmp eq ptr %.fca.0.extract, @i32_typ
  br i1 %15, label %._crit_edge.lr.ph.i, label %16

16:                                               ; preds = %14
  %17 = icmp eq ptr %.fca.0.extract, @bool_typ
  br i1 %17, label %._crit_edge.lr.ph.i, label %18

18:                                               ; preds = %16
  %19 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %20 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %21 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %22 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %23 = load ptr, ptr %19, align 8
  %24 = load ptr, ptr %20, align 8
  %result.i.i = tail call i1 %23(i64 %22, i64 %21, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %24) #5
  br i1 %result.i.i, label %25, label %.critedge.i

25:                                               ; preds = %18
  %result.i13.i = tail call i1 %23(i64 %22, i64 %21, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %24) #5
  %result.i14.i = tail call i1 %23(i64 %22, i64 %21, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %24) #5
  %.reg2mem43.0.i = select i1 %result.i13.i, i1 true, i1 %result.i14.i
  br i1 %.reg2mem43.0.i, label %.critedge.i, label %._crit_edge.lr.ph.i

.critedge.i:                                      ; preds = %25, %18
  %26 = icmp eq ptr %.fca.0.extract, @nil_typ
  %27 = icmp eq ptr %.fca.0.extract, null
  %28 = or i1 %26, %27
  br i1 %28, label %._crit_edge.lr.ph.i, label %29

29:                                               ; preds = %.critedge.i
  %result.i15.i = tail call i1 %23(i64 %22, i64 %21, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %24) #5
  %result.i16.i = tail call i1 %23(i64 %22, i64 %21, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %24) #5
  %not.result.i15.i = xor i1 %result.i15.i, true
  %.reg2mem39.0.i = select i1 %not.result.i15.i, i1 true, i1 %result.i16.i
  br i1 %.reg2mem39.0.i, label %30, label %._crit_edge.lr.ph.i

30:                                               ; preds = %29
  %31 = icmp eq ptr %.fca.0.extract, @i8_typ
  %32 = select i1 %31, i32 9, i32 4
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %3, %12, %14, %16, %25, %.critedge.i, %29, %30
  %.reg2mem25.0.i = phi i32 [ 6, %3 ], [ 8, %12 ], [ 3, %14 ], [ 2, %16 ], [ 7, %.critedge.i ], [ 1, %29 ], [ 5, %25 ], [ %32, %30 ]
  %33 = zext nneg i32 %.reg2mem25.0.i to i64
  %34 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %33
  %35 = getelementptr i8, ptr %34, i64 80
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr nonnull align 8 dereferenceable(8) %8, { ptr, i160 } %7) #7
  %result.i98 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98, align 16
  %result.i.i356 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356, ptr noundef nonnull align 16 dereferenceable(14) %result.i98, i64 14, i1 false)
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356)
  %37 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1) #17
  %result.i104 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104, align 16
  %result.i.i370 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370, ptr noundef nonnull align 16 dereferenceable(14) %result.i104, i64 14, i1 false)
  %puts.i294 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370)
  %38 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2) #17
  %result.i110 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110, align 4
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i389 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389, ptr noundef nonnull align 4 dereferenceable(3) %result.i110, i64 3, i1 false)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts.i314 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389)
  %41 = icmp sgt i32 %1, 0
  br i1 %41, label %._crit_edge1, label %._crit_edge

._crit_edge1:                                     ; preds = %._crit_edge.lr.ph.i
  %42 = icmp sgt i64 %2, 0
  br i1 %42, label %43, label %._crit_edge.lr.ph.i409

43:                                               ; preds = %._crit_edge1
  %44 = mul i64 %2, 1000000
  %45 = zext nneg i32 %1 to i64
  %46 = sdiv i64 %44, %45
  br label %._crit_edge.lr.ph.i409

._crit_edge.lr.ph.i409:                           ; preds = %43, %._crit_edge1
  %.0 = phi i64 [ %46, %43 ], [ 0, %._crit_edge1 ]
  %result.i115 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115, align 16
  %result.i.i408 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408, ptr noundef nonnull align 16 dereferenceable(15) %result.i115, i64 15, i1 false)
  %puts.i334 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408)
  %47 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0) #17
  %result.i121 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121, align 4
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i427 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427, ptr noundef nonnull align 4 dereferenceable(3) %result.i121, i64 3, i1 false)
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts.i354 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i409
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %oldProtect.i154 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %result.i150 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i150, align 8
  %15 = getelementptr inbounds i8, ptr %result.i150, i64 8
  store ptr @_parameterization_Ptri32, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i150, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i150) #39
  %result.i151 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i152 = call i32 @VirtualProtect(ptr nofree %result.i151, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i151, ptr noalias nofree noundef nonnull readnone @rabbojnpqi, ptr noalias nofree noundef nonnull readnone @i32_hasher) #39
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i151) #40
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i151) #39
  %result.i153 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i154)
  %result.i155 = call i32 @VirtualProtect(ptr nofree %result.i153, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i154) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i154)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i153, ptr noalias nofree noundef nonnull readnone @bnwmaetavp, ptr noalias nofree noundef nonnull readnone @i32_eq) #39
  %ret.i156 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i153) #40
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i153) #39
  %20 = getelementptr inbounds i8, ptr %result.i150, i64 48
  store ptr %ret.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i150, i64 56
  store ptr %ret.i156, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i150, i64 40
  store i32 8, ptr %22, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %23 = getelementptr inbounds i8, ptr %result.i150, i64 24
  store ptr %result.i.i, ptr %23, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %24 = getelementptr inbounds i8, ptr %result.i150, i64 32
  store ptr %result.i9.i, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %26 = call i64 @clock()
  %27 = icmp sgt i32 %0, 0
  br i1 %27, label %._crit_edge.preheader, label %1064

._crit_edge.preheader:                            ; preds = %1
  %28 = getelementptr inbounds i8, ptr %result.i150, i64 44
  %29 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i150, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr undef, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 10, 3
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %CuckooMap_insert_keyK_valueV.exit
  %.0213 = phi i32 [ %32, %CuckooMap_insert_keyK_valueV.exit ], [ 0, %._crit_edge.preheader ]
  %32 = add nuw nsw i32 %.0213, 1
  %.sroa.0131.0.insert.ext = zext nneg i32 %.0213 to i160
  %33 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0131.0.insert.ext, 1
  %.sroa.0128.0.insert.ext = zext nneg i32 %32 to i160
  %34 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0128.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %35 = load ptr, ptr %20, align 8
  %36 = call i32 %35({ ptr, i160 } %33) #7
  %37 = load i32, ptr %22, align 8
  %38 = add i32 %37, -1
  %39 = and i32 %38, %36
  %40 = load ptr, ptr %23, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %42 = sext i32 %39 to i64
  %43 = shl nsw i64 %42, 5
  %44 = getelementptr i8, ptr %40, i64 %43
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr i8, ptr %44, i64 8
  %47 = icmp ne ptr %45, @nil_typ
  %48 = icmp ne ptr %45, null
  %.not64.i = and i1 %47, %48
  br i1 %.not64.i, label %49, label %147

49:                                               ; preds = %._crit_edge
  %50 = load i64, ptr %46, align 4
  %.sroa_idx.i = getelementptr i8, ptr %44, i64 16
  %51 = load i64, ptr %.sroa_idx.i, align 4
  %52 = inttoptr i64 %50 to ptr
  %53 = inttoptr i64 %51 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %45, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %45, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %45, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !10
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !10
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !10
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !10
  %54 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %45, 0
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %52, 1
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %53, 2
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %offset.i.i77.i, 3
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %45) #35
  %60 = sext i32 %offset.i.i77.i to i64
  %61 = getelementptr ptr, ptr %45, i64 %60
  %62 = getelementptr i8, ptr %61, i64 64
  %63 = load ptr, ptr %62, align 8
  %result.i.i397 = call ptr %63({ ptr, ptr, ptr, i32 } %57, ptr nocapture nofree noundef nonnull readonly %2) #16
  %64 = call i32 %result.i.i397({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull align 8 %2) #7
  %65 = icmp eq i32 %64, %36
  br i1 %65, label %._crit_edge.i398, label %147

._crit_edge.i398:                                 ; preds = %49
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %45)
  %68 = getelementptr i8, ptr %61, i64 48
  %69 = load ptr, ptr %68, align 8
  %result.i79.i399 = call ptr %69({ ptr, ptr, ptr, i32 } %57, ptr nocapture nofree noundef nonnull readonly %2) #16
  %70 = call { ptr, i160 } %result.i79.i399({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull align 8 %2) #7
  %71 = load ptr, ptr %21, align 8
  %72 = call i1 %71({ ptr, i160 } %70, { ptr, i160 } %33) #7
  br i1 %72, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %147

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i398
  %73 = load ptr, ptr %result.i150, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %75 = load ptr, ptr %15, align 8
  %76 = load ptr, ptr %73, align 8, !alias.scope !13
  %77 = getelementptr i8, ptr %76, i64 72
  %78 = load ptr, ptr %77, align 8, !alias.scope !13
  %result.i.i.i400 = call { i64, i64 } %78(ptr nocapture nofree nonnull readonly %73) #5, !alias.scope !13
  %79 = extractvalue { i64, i64 } %result.i.i.i400, 0
  %80 = extractvalue { i64, i64 } %result.i.i.i400, 1
  %81 = urem i64 20, %80
  %82 = icmp eq i64 %81, 0
  %83 = sub i64 %80, %81
  %84 = select i1 %82, i64 0, i64 %83
  %85 = add i64 %79, 20
  %86 = add i64 %85, %84
  %87 = load ptr, ptr %75, align 8, !alias.scope !13
  %88 = getelementptr i8, ptr %87, i64 72
  %89 = load ptr, ptr %88, align 8, !alias.scope !13
  %result.i1.i.i401 = call { i64, i64 } %89(ptr nocapture nofree nonnull readonly %75) #5, !alias.scope !13
  %90 = extractvalue { i64, i64 } %result.i1.i.i401, 0
  %91 = extractvalue { i64, i64 } %result.i1.i.i401, 1
  %92 = call i64 @llvm.umax.i64(i64 %80, i64 %91)
  %93 = call i64 @llvm.umax.i64(i64 %92, i64 8)
  %94 = urem i64 %86, %91
  %95 = icmp eq i64 %94, 0
  %96 = sub i64 %91, %94
  %97 = select i1 %95, i64 0, i64 %96
  %98 = add i64 %90, %86
  %99 = add i64 %98, %97
  %100 = urem i64 %99, %93
  %101 = icmp eq i64 %100, 0
  %102 = sub i64 %93, %100
  %103 = select i1 %101, i64 0, i64 %102
  %104 = add i64 %103, %99
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %104, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %73, ptr %result.i83.i, align 8
  %105 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %75, ptr %105, align 8
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %108 = load ptr, ptr %73, align 8
  %109 = getelementptr i8, ptr %108, i64 72
  %110 = load ptr, ptr %109, align 8
  %result.i.i118.i = call { i64, i64 } %110(ptr nocapture nofree nonnull readonly %73) #5
  %111 = extractvalue { i64, i64 } %result.i.i118.i, 1
  %112 = urem i64 20, %111
  %113 = icmp eq i64 %112, 0
  %reass.sub1448 = sub i64 %111, %112
  %114 = add i64 %reass.sub1448, 20
  %115 = select i1 %113, i64 20, i64 %114
  %116 = getelementptr i8, ptr %result.i83.i, i64 %115
  %117 = getelementptr i8, ptr %108, i64 64
  %118 = load ptr, ptr %117, align 8
  call void %118({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %73, ptr nocapture nofree writeonly %116) #1
  %119 = load ptr, ptr %result.i83.i, align 8
  %120 = load ptr, ptr %119, align 8
  %121 = getelementptr i8, ptr %120, i64 72
  %122 = load ptr, ptr %121, align 8
  %result.i.i119.i = call { i64, i64 } %122(ptr nocapture nofree nonnull readonly %119) #5
  %123 = extractvalue { i64, i64 } %result.i.i119.i, 0
  %124 = extractvalue { i64, i64 } %result.i.i119.i, 1
  %125 = urem i64 20, %124
  %126 = icmp eq i64 %125, 0
  %127 = sub i64 %124, %125
  %128 = select i1 %126, i64 0, i64 %127
  %129 = add i64 %123, 20
  %130 = add i64 %129, %128
  %131 = load ptr, ptr %105, align 8
  %132 = load ptr, ptr %131, align 8
  %133 = getelementptr i8, ptr %132, i64 72
  %134 = load ptr, ptr %133, align 8
  %result.i1.i120.i = call { i64, i64 } %134(ptr nocapture nofree nonnull readonly %131) #5
  %135 = extractvalue { i64, i64 } %result.i1.i120.i, 1
  %136 = urem i64 %130, %135
  %137 = icmp eq i64 %136, 0
  %138 = sub i64 %135, %136
  %139 = select i1 %137, i64 0, i64 %138
  %140 = getelementptr i8, ptr %result.i83.i, i64 %130
  %141 = getelementptr i8, ptr %140, i64 %139
  %142 = getelementptr i8, ptr %132, i64 64
  %143 = load ptr, ptr %142, align 8
  call void %143({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %131, ptr nocapture nofree writeonly %141) #1
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %145 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %36, ptr %145, align 8
  store ptr @Entry, ptr %44, align 8
  %146 = ptrtoint ptr %result.i83.i to i64
  store i64 %146, ptr %46, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %44, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

147:                                              ; preds = %._crit_edge.i398, %._crit_edge, %49
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %148 = add i32 %36, 2127912214
  %149 = shl i32 %36, 12
  %150 = add i32 %148, %149
  %151 = ashr i32 %150, 19
  %152 = xor i32 %150, %151
  %153 = xor i32 %152, -949894596
  %154 = add i32 %153, 374761393
  %155 = shl i32 %153, 5
  %156 = add i32 %154, %155
  %157 = add i32 %156, -744332180
  %158 = shl i32 %156, 9
  %159 = xor i32 %157, %158
  %160 = add i32 %159, -42973499
  %161 = shl i32 %159, 3
  %162 = add i32 %160, %161
  %163 = ashr i32 %162, 16
  %164 = xor i32 %162, %163
  %165 = xor i32 %164, -1252372727
  %166 = load i32, ptr %22, align 8
  %167 = add i32 %166, -1
  %168 = and i32 %167, %165
  %169 = load ptr, ptr %24, align 8
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %171 = sext i32 %168 to i64
  %172 = shl nsw i64 %171, 5
  %173 = getelementptr i8, ptr %169, i64 %172
  %174 = load ptr, ptr %173, align 8
  %175 = getelementptr i8, ptr %173, i64 8
  %176 = icmp ne ptr %174, @nil_typ
  %177 = icmp ne ptr %174, null
  %.not64.i430 = and i1 %176, %177
  br i1 %.not64.i430, label %178, label %276

178:                                              ; preds = %147
  %179 = load i64, ptr %175, align 4
  %.sroa_idx.i432 = getelementptr i8, ptr %173, i64 16
  %180 = load i64, ptr %.sroa_idx.i432, align 4
  %181 = inttoptr i64 %179 to ptr
  %182 = inttoptr i64 %180 to ptr
  %hash_coef_ptr.i.i66.i433 = getelementptr i8, ptr %174, i64 8
  %tbl_size_ptr.i.i67.i434 = getelementptr i8, ptr %174, i64 16
  %offset_tbl_ptr.i.i68.i435 = getelementptr i8, ptr %174, i64 40
  %hash_coef.i.i69.i436 = load i64, ptr %hash_coef_ptr.i.i66.i433, align 4, !noalias !16
  %tbl_size.i.i70.i437 = load i64, ptr %tbl_size_ptr.i.i67.i434, align 4, !noalias !16
  %offset_tbl.i.i71.i438 = load ptr, ptr %offset_tbl_ptr.i.i68.i435, align 8, !noalias !16
  %product.i.i.i72.i439 = mul i64 %hash_coef.i.i69.i436, 4015701072841558310
  %shifted.i.i.i73.i440 = lshr i64 %product.i.i.i72.i439, 32
  %xored.i.i.i74.i441 = xor i64 %shifted.i.i.i73.i440, %product.i.i.i72.i439
  %hash.i.i.i75.i442 = and i64 %xored.i.i.i74.i441, %tbl_size.i.i70.i437
  %offset_ptr.i.i76.i443 = getelementptr i32, ptr %offset_tbl.i.i71.i438, i64 %hash.i.i.i75.i442
  %offset.i.i77.i444 = load i32, ptr %offset_ptr.i.i76.i443, align 4, !noalias !16
  %183 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %174, 0
  %184 = insertvalue { ptr, ptr, ptr, i32 } %183, ptr %181, 1
  %185 = insertvalue { ptr, ptr, ptr, i32 } %184, ptr %182, 2
  %186 = insertvalue { ptr, ptr, ptr, i32 } %185, i32 %offset.i.i77.i444, 3
  %187 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %174) #35
  %189 = sext i32 %offset.i.i77.i444 to i64
  %190 = getelementptr ptr, ptr %174, i64 %189
  %191 = getelementptr i8, ptr %190, i64 64
  %192 = load ptr, ptr %191, align 8
  %result.i.i445 = call ptr %192({ ptr, ptr, ptr, i32 } %186, ptr nocapture nofree noundef nonnull readonly %2) #16
  %193 = call i32 %result.i.i445({ ptr, ptr, ptr, i32 } %186, { ptr, ptr, ptr, i32 } %186, ptr nonnull align 8 %2) #7
  %194 = icmp eq i32 %193, %36
  br i1 %194, label %._crit_edge.i446, label %276

._crit_edge.i446:                                 ; preds = %178
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %174)
  %197 = getelementptr i8, ptr %190, i64 48
  %198 = load ptr, ptr %197, align 8
  %result.i79.i447 = call ptr %198({ ptr, ptr, ptr, i32 } %186, ptr nocapture nofree noundef nonnull readonly %2) #16
  %199 = call { ptr, i160 } %result.i79.i447({ ptr, ptr, ptr, i32 } %186, { ptr, ptr, ptr, i32 } %186, ptr nonnull align 8 %2) #7
  %200 = load ptr, ptr %21, align 8
  %201 = call i1 %200({ ptr, i160 } %199, { ptr, i160 } %33) #7
  br i1 %201, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit459, label %276

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit459: ; preds = %._crit_edge.i446
  %202 = load ptr, ptr %result.i150, align 8
  %203 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %204 = load ptr, ptr %15, align 8
  %205 = load ptr, ptr %202, align 8, !alias.scope !19
  %206 = getelementptr i8, ptr %205, i64 72
  %207 = load ptr, ptr %206, align 8, !alias.scope !19
  %result.i.i.i451 = call { i64, i64 } %207(ptr nocapture nofree nonnull readonly %202) #5, !alias.scope !19
  %208 = extractvalue { i64, i64 } %result.i.i.i451, 0
  %209 = extractvalue { i64, i64 } %result.i.i.i451, 1
  %210 = urem i64 20, %209
  %211 = icmp eq i64 %210, 0
  %212 = sub i64 %209, %210
  %213 = select i1 %211, i64 0, i64 %212
  %214 = add i64 %208, 20
  %215 = add i64 %214, %213
  %216 = load ptr, ptr %204, align 8, !alias.scope !19
  %217 = getelementptr i8, ptr %216, i64 72
  %218 = load ptr, ptr %217, align 8, !alias.scope !19
  %result.i1.i.i452 = call { i64, i64 } %218(ptr nocapture nofree nonnull readonly %204) #5, !alias.scope !19
  %219 = extractvalue { i64, i64 } %result.i1.i.i452, 0
  %220 = extractvalue { i64, i64 } %result.i1.i.i452, 1
  %221 = call i64 @llvm.umax.i64(i64 %209, i64 %220)
  %222 = call i64 @llvm.umax.i64(i64 %221, i64 8)
  %223 = urem i64 %215, %220
  %224 = icmp eq i64 %223, 0
  %225 = sub i64 %220, %223
  %226 = select i1 %224, i64 0, i64 %225
  %227 = add i64 %219, %215
  %228 = add i64 %227, %226
  %229 = urem i64 %228, %222
  %230 = icmp eq i64 %229, 0
  %231 = sub i64 %222, %229
  %232 = select i1 %230, i64 0, i64 %231
  %233 = add i64 %232, %228
  %result.i83.i453 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %233, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %202, ptr %result.i83.i453, align 8
  %234 = getelementptr inbounds i8, ptr %result.i83.i453, i64 8
  store ptr %204, ptr %234, align 8
  %235 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i453)
  %236 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %237 = load ptr, ptr %202, align 8
  %238 = getelementptr i8, ptr %237, i64 72
  %239 = load ptr, ptr %238, align 8
  %result.i.i118.i454 = call { i64, i64 } %239(ptr nocapture nofree nonnull readonly %202) #5
  %240 = extractvalue { i64, i64 } %result.i.i118.i454, 1
  %241 = urem i64 20, %240
  %242 = icmp eq i64 %241, 0
  %reass.sub1447 = sub i64 %240, %241
  %243 = add i64 %reass.sub1447, 20
  %244 = select i1 %242, i64 20, i64 %243
  %245 = getelementptr i8, ptr %result.i83.i453, i64 %244
  %246 = getelementptr i8, ptr %237, i64 64
  %247 = load ptr, ptr %246, align 8
  call void %247({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %202, ptr nocapture nofree writeonly %245) #1
  %248 = load ptr, ptr %result.i83.i453, align 8
  %249 = load ptr, ptr %248, align 8
  %250 = getelementptr i8, ptr %249, i64 72
  %251 = load ptr, ptr %250, align 8
  %result.i.i119.i456 = call { i64, i64 } %251(ptr nocapture nofree nonnull readonly %248) #5
  %252 = extractvalue { i64, i64 } %result.i.i119.i456, 0
  %253 = extractvalue { i64, i64 } %result.i.i119.i456, 1
  %254 = urem i64 20, %253
  %255 = icmp eq i64 %254, 0
  %256 = sub i64 %253, %254
  %257 = select i1 %255, i64 0, i64 %256
  %258 = add i64 %252, 20
  %259 = add i64 %258, %257
  %260 = load ptr, ptr %234, align 8
  %261 = load ptr, ptr %260, align 8
  %262 = getelementptr i8, ptr %261, i64 72
  %263 = load ptr, ptr %262, align 8
  %result.i1.i120.i457 = call { i64, i64 } %263(ptr nocapture nofree nonnull readonly %260) #5
  %264 = extractvalue { i64, i64 } %result.i1.i120.i457, 1
  %265 = urem i64 %259, %264
  %266 = icmp eq i64 %265, 0
  %267 = sub i64 %264, %265
  %268 = select i1 %266, i64 0, i64 %267
  %269 = getelementptr i8, ptr %result.i83.i453, i64 %259
  %270 = getelementptr i8, ptr %269, i64 %268
  %271 = getelementptr i8, ptr %261, i64 64
  %272 = load ptr, ptr %271, align 8
  call void %272({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %260, ptr nocapture nofree writeonly %270) #1
  %273 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %274 = getelementptr inbounds i8, ptr %result.i83.i453, i64 16
  store i32 %36, ptr %274, align 8
  store ptr @Entry, ptr %173, align 8
  %275 = ptrtoint ptr %result.i83.i453 to i64
  store i64 %275, ptr %175, align 4
  %.sroa_idx28.i458 = getelementptr i8, ptr %173, i64 24
  store i32 10, ptr %.sroa_idx28.i458, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

276:                                              ; preds = %._crit_edge.i446, %147, %178
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %277 = load i32, ptr %28, align 4
  %278 = load i32, ptr %22, align 8
  %.not.i = icmp slt i32 %277, %278
  br i1 %.not.i, label %._crit_edge.i, label %279

279:                                              ; preds = %276
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %281 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %282 = load ptr, ptr %23, align 8
  %283 = load ptr, ptr %24, align 8
  %284 = shl i32 %278, 1
  %spec.select.i474 = call i32 @llvm.smax.i32(i32 %284, i32 16)
  store i32 %spec.select.i474, ptr %22, align 8
  %285 = zext nneg i32 %spec.select.i474 to i64
  %286 = shl nuw nsw i64 %285, 5
  %result.i.i475 = call noalias ptr @bump_malloc_inner(i64 noundef %286, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i475, ptr %23, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %286, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i, ptr %24, align 8
  store i32 0, ptr %28, align 4
  %287 = icmp sgt i32 %278, 0
  br i1 %287, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %279, %._crit_edge.i796
  %.060.i = phi i32 [ %306, %._crit_edge.i796 ], [ 0, %279 ]
  %288 = zext nneg i32 %.060.i to i64
  %289 = shl nuw nsw i64 %288, 5
  %290 = getelementptr i8, ptr %282, i64 %289
  %291 = load ptr, ptr %290, align 8
  %292 = icmp ne ptr %291, @nil_typ
  %293 = icmp ne ptr %291, null
  %.not16.i = and i1 %292, %293
  br i1 %.not16.i, label %294, label %._crit_edge.i796

294:                                              ; preds = %.lr.ph.i
  %295 = getelementptr i8, ptr %290, i64 8
  %296 = load i64, ptr %295, align 4
  %.sroa_idx.i797 = getelementptr i8, ptr %290, i64 16
  %297 = load i64, ptr %.sroa_idx.i797, align 4
  %298 = inttoptr i64 %296 to ptr
  %299 = inttoptr i64 %297 to ptr
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %291, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %291, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %291, i64 40
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i43.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !23
  %300 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %291, 0
  %301 = insertvalue { ptr, ptr, ptr, i32 } %300, ptr %298, 1
  %302 = insertvalue { ptr, ptr, ptr, i32 } %301, ptr %299, 2
  %303 = insertvalue { ptr, ptr, ptr, i32 } %302, i32 %offset.i.i43.i, 3
  %304 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %305 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %303) #7
  br label %._crit_edge.i796

._crit_edge.i796:                                 ; preds = %294, %.lr.ph.i
  %306 = add nuw nsw i32 %.060.i, 1
  %307 = icmp slt i32 %306, %278
  br i1 %307, label %.lr.ph.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i796, %._crit_edge.i815
  %.060.i813 = phi i32 [ %326, %._crit_edge.i815 ], [ 0, %._crit_edge.i796 ]
  %308 = zext nneg i32 %.060.i813 to i64
  %309 = shl nuw nsw i64 %308, 5
  %310 = getelementptr i8, ptr %283, i64 %309
  %311 = load ptr, ptr %310, align 8
  %312 = icmp ne ptr %311, @nil_typ
  %313 = icmp ne ptr %311, null
  %.not16.i814 = and i1 %312, %313
  br i1 %.not16.i814, label %314, label %._crit_edge.i815

314:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %315 = getelementptr i8, ptr %310, i64 8
  %316 = load i64, ptr %315, align 4
  %.sroa_idx.i816 = getelementptr i8, ptr %310, i64 16
  %317 = load i64, ptr %.sroa_idx.i816, align 4
  %318 = inttoptr i64 %316 to ptr
  %319 = inttoptr i64 %317 to ptr
  %hash_coef_ptr.i.i18.i817 = getelementptr i8, ptr %311, i64 8
  %tbl_size_ptr.i.i19.i818 = getelementptr i8, ptr %311, i64 16
  %offset_tbl_ptr.i.i20.i819 = getelementptr i8, ptr %311, i64 40
  %hash_coef.i.i21.i820 = load i64, ptr %hash_coef_ptr.i.i18.i817, align 4, !noalias !22
  %tbl_size.i.i22.i821 = load i64, ptr %tbl_size_ptr.i.i19.i818, align 4, !noalias !22
  %offset_tbl.i.i23.i822 = load ptr, ptr %offset_tbl_ptr.i.i20.i819, align 8, !noalias !22
  %product.i.i.i24.i823 = mul i64 %hash_coef.i.i21.i820, 4015701072841558310
  %shifted.i.i.i25.i824 = lshr i64 %product.i.i.i24.i823, 32
  %xored.i.i.i26.i825 = xor i64 %shifted.i.i.i25.i824, %product.i.i.i24.i823
  %hash.i.i.i27.i826 = and i64 %xored.i.i.i26.i825, %tbl_size.i.i22.i821
  %offset_ptr.i.i28.i827 = getelementptr i32, ptr %offset_tbl.i.i23.i822, i64 %hash.i.i.i27.i826
  %offset.i.i43.i828 = load i32, ptr %offset_ptr.i.i28.i827, align 4, !noalias !26
  %320 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %311, 0
  %321 = insertvalue { ptr, ptr, ptr, i32 } %320, ptr %318, 1
  %322 = insertvalue { ptr, ptr, ptr, i32 } %321, ptr %319, 2
  %323 = insertvalue { ptr, ptr, ptr, i32 } %322, i32 %offset.i.i43.i828, 3
  %324 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %325 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %323) #7
  br label %._crit_edge.i815

._crit_edge.i815:                                 ; preds = %314, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %326 = add nuw nsw i32 %.060.i813, 1
  %327 = icmp slt i32 %326, %278
  br i1 %327, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i815, %279, %276
  %328 = load ptr, ptr %result.i150, align 8
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %330 = load ptr, ptr %15, align 8
  %331 = load ptr, ptr %328, align 8
  %332 = getelementptr i8, ptr %331, i64 72
  %333 = load ptr, ptr %332, align 8
  %result.i.i.i = call { i64, i64 } %333(ptr nocapture nofree nonnull readonly %328) #5
  %334 = extractvalue { i64, i64 } %result.i.i.i, 0
  %335 = extractvalue { i64, i64 } %result.i.i.i, 1
  %336 = urem i64 20, %335
  %337 = icmp eq i64 %336, 0
  %338 = sub i64 %335, %336
  %339 = select i1 %337, i64 0, i64 %338
  %340 = add i64 %334, 20
  %341 = add i64 %340, %339
  %342 = load ptr, ptr %330, align 8
  %343 = getelementptr i8, ptr %342, i64 72
  %344 = load ptr, ptr %343, align 8
  %result.i1.i.i = call { i64, i64 } %344(ptr nocapture nofree nonnull readonly %330) #5
  %345 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %346 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %347 = call i64 @llvm.umax.i64(i64 %335, i64 %346)
  %348 = call i64 @llvm.umax.i64(i64 %347, i64 8)
  %349 = urem i64 %341, %346
  %350 = icmp eq i64 %349, 0
  %351 = sub i64 %346, %349
  %352 = select i1 %350, i64 0, i64 %351
  %353 = add i64 %345, %341
  %354 = add i64 %353, %352
  %355 = urem i64 %354, %348
  %356 = icmp eq i64 %355, 0
  %357 = sub i64 %348, %355
  %358 = select i1 %356, i64 0, i64 %357
  %359 = add i64 %358, %354
  %result.i90.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %359, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %328, ptr %result.i90.i, align 8
  %360 = getelementptr inbounds i8, ptr %result.i90.i, i64 8
  store ptr %330, ptr %360, align 8
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i)
  %362 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %363 = load ptr, ptr %328, align 8
  %364 = getelementptr i8, ptr %363, i64 72
  %365 = load ptr, ptr %364, align 8
  %result.i.i196.i = call { i64, i64 } %365(ptr nocapture nofree nonnull readonly %328) #5
  %366 = extractvalue { i64, i64 } %result.i.i196.i, 1
  %367 = urem i64 20, %366
  %368 = icmp eq i64 %367, 0
  %reass.sub = sub i64 %366, %367
  %369 = add i64 %reass.sub, 20
  %370 = select i1 %368, i64 20, i64 %369
  %371 = getelementptr i8, ptr %result.i90.i, i64 %370
  %372 = getelementptr i8, ptr %363, i64 64
  %373 = load ptr, ptr %372, align 8
  call void %373({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %328, ptr nocapture nofree writeonly %371) #1
  %374 = load ptr, ptr %result.i90.i, align 8
  %375 = load ptr, ptr %374, align 8
  %376 = getelementptr i8, ptr %375, i64 72
  %377 = load ptr, ptr %376, align 8
  %result.i.i197.i = call { i64, i64 } %377(ptr nocapture nofree nonnull readonly %374) #5
  %378 = extractvalue { i64, i64 } %result.i.i197.i, 0
  %379 = extractvalue { i64, i64 } %result.i.i197.i, 1
  %380 = urem i64 20, %379
  %381 = icmp eq i64 %380, 0
  %382 = sub i64 %379, %380
  %383 = select i1 %381, i64 0, i64 %382
  %384 = add i64 %378, 20
  %385 = add i64 %384, %383
  %386 = load ptr, ptr %360, align 8
  %387 = load ptr, ptr %386, align 8
  %388 = getelementptr i8, ptr %387, i64 72
  %389 = load ptr, ptr %388, align 8
  %result.i1.i198.i = call { i64, i64 } %389(ptr nocapture nofree nonnull readonly %386) #5
  %390 = extractvalue { i64, i64 } %result.i1.i198.i, 1
  %391 = urem i64 %385, %390
  %392 = icmp eq i64 %391, 0
  %393 = sub i64 %390, %391
  %394 = select i1 %392, i64 0, i64 %393
  %395 = getelementptr i8, ptr %result.i90.i, i64 %385
  %396 = getelementptr i8, ptr %395, i64 %394
  %397 = getelementptr i8, ptr %387, i64 64
  %398 = load ptr, ptr %397, align 8
  call void %398({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %386, ptr nocapture nofree writeonly %396) #1
  %399 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %400 = getelementptr inbounds i8, ptr %result.i90.i, i64 16
  store i32 %36, ptr %400, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %404

404:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %405, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %471, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i90.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i492, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %405 = add nuw nsw i32 %.0566.i, 1
  %406 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %407 = insertvalue { ptr, ptr, ptr, i32 } %406, ptr %.sroa.6.0563.i, 1
  %408 = insertvalue { ptr, ptr, ptr, i32 } %407, ptr %.sroa.12.0562.i, 2
  %409 = insertvalue { ptr, ptr, ptr, i32 } %408, i32 %.sroa.17.0561.i, 3
  %410 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %411 = sext i32 %.sroa.17.0561.i to i64
  %412 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %411
  %413 = getelementptr i8, ptr %412, i64 64
  %414 = load ptr, ptr %413, align 8
  %result.i125.i490 = call ptr %414({ ptr, ptr, ptr, i32 } %409, ptr nocapture nofree noundef nonnull readonly %2) #16
  %415 = call i32 %result.i125.i490({ ptr, ptr, ptr, i32 } %409, { ptr, ptr, ptr, i32 } %409, ptr nonnull align 8 %2) #7
  %416 = ptrtoint ptr %.sroa.6.0563.i to i64
  %417 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %418, label %434

418:                                              ; preds = %404
  %419 = load i32, ptr %22, align 8
  %420 = add i32 %419, -1
  %421 = and i32 %420, %415
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %423 = load ptr, ptr %23, align 8
  %424 = sext i32 %421 to i64
  %425 = shl nsw i64 %424, 5
  %426 = getelementptr i8, ptr %423, i64 %425
  %427 = load ptr, ptr %426, align 8
  %428 = getelementptr i8, ptr %426, i64 8
  %429 = load i160, ptr %428, align 4
  store ptr %.sroa.0.0564.i, ptr %426, align 8
  store i64 %416, ptr %428, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %426, i64 16
  store i64 %417, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %426, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %430 = icmp ne ptr %427, @nil_typ
  %431 = icmp ne ptr %427, null
  %.not92.i = and i1 %430, %431
  %extract.i = lshr i160 %429, 64
  %432 = insertelement <2 x i160> poison, i160 %429, i64 0
  %433 = insertelement <2 x i160> %432, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

434:                                              ; preds = %404
  %435 = add i32 %415, 2127912214
  %436 = shl i32 %415, 12
  %437 = add i32 %435, %436
  %438 = ashr i32 %437, 19
  %439 = xor i32 %437, %438
  %440 = xor i32 %439, -949894596
  %441 = add i32 %440, 374761393
  %442 = shl i32 %440, 5
  %443 = add i32 %441, %442
  %444 = add i32 %443, -744332180
  %445 = shl i32 %443, 9
  %446 = xor i32 %444, %445
  %447 = add i32 %446, -42973499
  %448 = shl i32 %446, 3
  %449 = add i32 %447, %448
  %450 = ashr i32 %449, 16
  %451 = xor i32 %449, %450
  %452 = xor i32 %451, -1252372727
  %453 = load i32, ptr %22, align 8
  %454 = add i32 %453, -1
  %455 = and i32 %454, %452
  %456 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %457 = load ptr, ptr %24, align 8
  %458 = sext i32 %455 to i64
  %459 = shl nsw i64 %458, 5
  %460 = getelementptr i8, ptr %457, i64 %459
  %461 = load ptr, ptr %460, align 8
  %462 = getelementptr i8, ptr %460, i64 8
  %463 = load i160, ptr %462, align 4
  store ptr %.sroa.0.0564.i, ptr %460, align 8
  store i64 %416, ptr %462, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %460, i64 16
  store i64 %417, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %460, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %464 = icmp ne ptr %461, @nil_typ
  %465 = icmp ne ptr %461, null
  %.not90.i = and i1 %464, %465
  %extract607.i = lshr i160 %463, 64
  %466 = insertelement <2 x i160> poison, i160 %463, i64 0
  %467 = insertelement <2 x i160> %466, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %434, %418
  %vptr.i142.sroa.speculated.i = phi ptr [ %427, %418 ], [ %461, %434 ]
  %.in = phi <2 x i160> [ %433, %418 ], [ %467, %434 ]
  %468 = trunc <2 x i160> %.in to <2 x i64>
  %469 = extractelement <2 x i64> %468, i64 1
  %spec.select.i492 = inttoptr i64 %469 to ptr
  %470 = extractelement <2 x i64> %468, i64 0
  %spec.select539.i = inttoptr i64 %470 to ptr
  %471 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %472 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %473 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %474 = icmp ult i32 %.0566.i, 99
  br i1 %474, label %404, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %418, %434
  %475 = phi ptr [ %14, %434 ], [ %13, %418 ]
  %476 = load i32, ptr %28, align 4
  store i32 %476, ptr %475, align 4
  %477 = add i32 %476, 1
  %478 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %477, ptr %28, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  %479 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %479, label %CuckooMap_insert_keyK_valueV.exit, label %480

480:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %481 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %482 = load ptr, ptr %23, align 8
  %483 = load ptr, ptr %24, align 8
  %484 = load i32, ptr %22, align 8
  %485 = shl i32 %484, 1
  %spec.select.i509 = call i32 @llvm.smax.i32(i32 %485, i32 16)
  store i32 %spec.select.i509, ptr %22, align 8
  %486 = zext nneg i32 %spec.select.i509 to i64
  %487 = shl nuw nsw i64 %486, 5
  %result.i.i510 = call noalias ptr @bump_malloc_inner(i64 noundef %487, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i510, ptr %23, align 8
  %result.i20.i511 = call noalias ptr @bump_malloc_inner(i64 noundef %487, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i511, ptr %24, align 8
  store i32 0, ptr %28, align 4
  %488 = icmp sgt i32 %484, 0
  br i1 %488, label %.lr.ph.i862, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931

.lr.ph.i862:                                      ; preds = %480, %._crit_edge.i877
  %.060.i875 = phi i32 [ %577, %._crit_edge.i877 ], [ 0, %480 ]
  %489 = zext nneg i32 %.060.i875 to i64
  %490 = shl nuw nsw i64 %489, 5
  %491 = getelementptr i8, ptr %482, i64 %490
  %492 = load ptr, ptr %491, align 8
  %493 = icmp ne ptr %492, @nil_typ
  %494 = icmp ne ptr %492, null
  %.not16.i876 = and i1 %493, %494
  br i1 %.not16.i876, label %495, label %._crit_edge.i877

495:                                              ; preds = %.lr.ph.i862
  %496 = getelementptr i8, ptr %491, i64 8
  %497 = load <2 x i64>, ptr %496, align 4
  %hash_coef_ptr.i.i18.i879 = getelementptr i8, ptr %492, i64 8
  %tbl_size_ptr.i.i19.i880 = getelementptr i8, ptr %492, i64 16
  %offset_tbl_ptr.i.i20.i881 = getelementptr i8, ptr %492, i64 40
  %498 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i879, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i880, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i881, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !29
  %499 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %500 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %502

502:                                              ; preds = %.cont.cont.i1054, %495
  %.0566.i1042 = phi i32 [ 0, %495 ], [ %506, %.cont.cont.i1054 ]
  %.070565.i1043 = phi i1 [ true, %495 ], [ %568, %.cont.cont.i1054 ]
  %.sroa.0.0564.i1044 = phi ptr [ %492, %495 ], [ %vptr.i142.sroa.speculated.i1057, %.cont.cont.i1054 ]
  %.sroa.17.0561.i1047 = phi i32 [ %offset.i.i121.i, %495 ], [ %offset.i.i154.i1071, %.cont.cont.i1054 ]
  %503 = phi <2 x i64> [ %497, %495 ], [ %567, %.cont.cont.i1054 ]
  %504 = extractelement <2 x i64> %503, i64 1
  %.sroa.12.0562.i1046 = inttoptr i64 %504 to ptr
  %505 = extractelement <2 x i64> %503, i64 0
  %.sroa.6.0563.i1045 = inttoptr i64 %505 to ptr
  %506 = add nuw nsw i32 %.0566.i1042, 1
  %507 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1044, 0
  %508 = insertvalue { ptr, ptr, ptr, i32 } %507, ptr %.sroa.6.0563.i1045, 1
  %509 = insertvalue { ptr, ptr, ptr, i32 } %508, ptr %.sroa.12.0562.i1046, 2
  %510 = insertvalue { ptr, ptr, ptr, i32 } %509, i32 %.sroa.17.0561.i1047, 3
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1044)
  %512 = sext i32 %.sroa.17.0561.i1047 to i64
  %513 = getelementptr ptr, ptr %.sroa.0.0564.i1044, i64 %512
  %514 = getelementptr i8, ptr %513, i64 64
  %515 = load ptr, ptr %514, align 8
  %result.i125.i = call ptr %515({ ptr, ptr, ptr, i32 } %510, ptr nocapture nofree noundef nonnull readonly %2) #16
  %516 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %510, { ptr, ptr, ptr, i32 } %510, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1043, label %517, label %533

517:                                              ; preds = %502
  %518 = load i32, ptr %22, align 8
  %519 = add i32 %518, -1
  %520 = and i32 %519, %516
  %521 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %522 = load ptr, ptr %23, align 8
  %523 = sext i32 %520 to i64
  %524 = shl nsw i64 %523, 5
  %525 = getelementptr i8, ptr %522, i64 %524
  %526 = load ptr, ptr %525, align 8
  %527 = getelementptr i8, ptr %525, i64 8
  %528 = load i160, ptr %527, align 4
  store ptr %.sroa.0.0564.i1044, ptr %525, align 8
  store i64 %505, ptr %527, align 4
  %.sroa_idx157.i1073 = getelementptr i8, ptr %525, i64 16
  store i64 %504, ptr %.sroa_idx157.i1073, align 4
  %.sroa_idx158.i1074 = getelementptr i8, ptr %525, i64 24
  store i32 %.sroa.17.0561.i1047, ptr %.sroa_idx158.i1074, align 4
  %529 = icmp ne ptr %526, @nil_typ
  %530 = icmp ne ptr %526, null
  %.not92.i1075 = and i1 %529, %530
  %extract.i1077 = lshr i160 %528, 64
  %531 = insertelement <2 x i160> poison, i160 %528, i64 0
  %532 = insertelement <2 x i160> %531, i160 %extract.i1077, i64 1
  br i1 %.not92.i1075, label %.cont.cont.i1054, label %572

533:                                              ; preds = %502
  %534 = add i32 %516, 2127912214
  %535 = shl i32 %516, 12
  %536 = add i32 %534, %535
  %537 = ashr i32 %536, 19
  %538 = xor i32 %536, %537
  %539 = xor i32 %538, -949894596
  %540 = add i32 %539, 374761393
  %541 = shl i32 %539, 5
  %542 = add i32 %540, %541
  %543 = add i32 %542, -744332180
  %544 = shl i32 %542, 9
  %545 = xor i32 %543, %544
  %546 = add i32 %545, -42973499
  %547 = shl i32 %545, 3
  %548 = add i32 %546, %547
  %549 = ashr i32 %548, 16
  %550 = xor i32 %548, %549
  %551 = xor i32 %550, -1252372727
  %552 = load i32, ptr %22, align 8
  %553 = add i32 %552, -1
  %554 = and i32 %553, %551
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %556 = load ptr, ptr %24, align 8
  %557 = sext i32 %554 to i64
  %558 = shl nsw i64 %557, 5
  %559 = getelementptr i8, ptr %556, i64 %558
  %560 = load ptr, ptr %559, align 8
  %561 = getelementptr i8, ptr %559, i64 8
  %562 = load i160, ptr %561, align 4
  store ptr %.sroa.0.0564.i1044, ptr %559, align 8
  store i64 %505, ptr %561, align 4
  %.sroa_idx161.i1048 = getelementptr i8, ptr %559, i64 16
  store i64 %504, ptr %.sroa_idx161.i1048, align 4
  %.sroa_idx162.i1049 = getelementptr i8, ptr %559, i64 24
  store i32 %.sroa.17.0561.i1047, ptr %.sroa_idx162.i1049, align 4
  %563 = icmp ne ptr %560, @nil_typ
  %564 = icmp ne ptr %560, null
  %.not90.i1050 = and i1 %563, %564
  %extract607.i1052 = lshr i160 %562, 64
  %565 = insertelement <2 x i160> poison, i160 %562, i64 0
  %566 = insertelement <2 x i160> %565, i160 %extract607.i1052, i64 1
  br i1 %.not90.i1050, label %.cont.cont.i1054, label %572

.cont.cont.i1054:                                 ; preds = %533, %517
  %vptr.i142.sroa.speculated.i1057 = phi ptr [ %526, %517 ], [ %560, %533 ]
  %.in1449 = phi <2 x i160> [ %532, %517 ], [ %566, %533 ]
  %567 = trunc <2 x i160> %.in1449 to <2 x i64>
  %568 = xor i1 %.070565.i1043, true
  %hash_coef_ptr.i.i143.i1060 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1057, i64 8
  %tbl_size_ptr.i.i144.i1061 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1057, i64 16
  %offset_tbl_ptr.i.i145.i1062 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1057, i64 40
  %hash_coef.i.i146.i1063 = load i64, ptr %hash_coef_ptr.i.i143.i1060, align 4
  %tbl_size.i.i147.i1064 = load i64, ptr %tbl_size_ptr.i.i144.i1061, align 4
  %offset_tbl.i.i148.i1065 = load ptr, ptr %offset_tbl_ptr.i.i145.i1062, align 8
  %product.i.i.i149.i1066 = mul i64 %hash_coef.i.i146.i1063, 4015701072841558310
  %shifted.i.i.i150.i1067 = lshr i64 %product.i.i.i149.i1066, 32
  %xored.i.i.i151.i1068 = xor i64 %shifted.i.i.i150.i1067, %product.i.i.i149.i1066
  %hash.i.i.i152.i1069 = and i64 %xored.i.i.i151.i1068, %tbl_size.i.i147.i1064
  %offset_ptr.i.i153.i1070 = getelementptr i32, ptr %offset_tbl.i.i148.i1065, i64 %hash.i.i.i152.i1069
  %offset.i.i154.i1071 = load i32, ptr %offset_ptr.i.i153.i1070, align 4
  %569 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %570 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %571 = icmp ult i32 %.0566.i1042, 99
  br i1 %571, label %502, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1079

572:                                              ; preds = %533, %517
  %573 = phi ptr [ %10, %533 ], [ %9, %517 ]
  %574 = load i32, ptr %28, align 4
  store i32 %574, ptr %573, align 4
  %575 = add i32 %574, 1
  %576 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %575, ptr %28, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1079

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1079: ; preds = %.cont.cont.i1054, %572
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i877

._crit_edge.i877:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1079, %.lr.ph.i862
  %577 = add nuw nsw i32 %.060.i875, 1
  %578 = icmp slt i32 %577, %484
  br i1 %578, label %.lr.ph.i862, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895: ; preds = %._crit_edge.i877, %._crit_edge.i913
  %.060.i911 = phi i32 [ %667, %._crit_edge.i913 ], [ 0, %._crit_edge.i877 ]
  %579 = zext nneg i32 %.060.i911 to i64
  %580 = shl nuw nsw i64 %579, 5
  %581 = getelementptr i8, ptr %483, i64 %580
  %582 = load ptr, ptr %581, align 8
  %583 = icmp ne ptr %582, @nil_typ
  %584 = icmp ne ptr %582, null
  %.not16.i912 = and i1 %583, %584
  br i1 %.not16.i912, label %585, label %._crit_edge.i913

585:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895
  %586 = getelementptr i8, ptr %581, i64 8
  %587 = load <2 x i64>, ptr %586, align 4
  %hash_coef_ptr.i.i18.i915 = getelementptr i8, ptr %582, i64 8
  %tbl_size_ptr.i.i19.i916 = getelementptr i8, ptr %582, i64 16
  %offset_tbl_ptr.i.i20.i917 = getelementptr i8, ptr %582, i64 40
  %588 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i1097 = load i64, ptr %hash_coef_ptr.i.i18.i915, align 4, !noalias !22
  %tbl_size.i.i100.i1098 = load i64, ptr %tbl_size_ptr.i.i19.i916, align 4, !noalias !22
  %offset_tbl.i.i101.i1099 = load ptr, ptr %offset_tbl_ptr.i.i20.i917, align 8, !noalias !22
  %product.i.i.i102.i1100 = mul i64 %hash_coef.i.i99.i1097, 4015701072841558310
  %shifted.i.i.i103.i1101 = lshr i64 %product.i.i.i102.i1100, 32
  %xored.i.i.i104.i1102 = xor i64 %shifted.i.i.i103.i1101, %product.i.i.i102.i1100
  %hash.i.i.i105.i1103 = and i64 %xored.i.i.i104.i1102, %tbl_size.i.i100.i1098
  %offset_ptr.i.i106.i1104 = getelementptr i32, ptr %offset_tbl.i.i101.i1099, i64 %hash.i.i.i105.i1103
  %offset.i.i121.i1105 = load i32, ptr %offset_ptr.i.i106.i1104, align 4, !noalias !32
  %589 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %590 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %591 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %592

592:                                              ; preds = %.cont.cont.i1126, %585
  %.0566.i1106 = phi i32 [ 0, %585 ], [ %596, %.cont.cont.i1126 ]
  %.070565.i1107 = phi i1 [ true, %585 ], [ %658, %.cont.cont.i1126 ]
  %.sroa.0.0564.i1108 = phi ptr [ %582, %585 ], [ %vptr.i142.sroa.speculated.i1129, %.cont.cont.i1126 ]
  %.sroa.17.0561.i1111 = phi i32 [ %offset.i.i121.i1105, %585 ], [ %offset.i.i154.i1143, %.cont.cont.i1126 ]
  %593 = phi <2 x i64> [ %587, %585 ], [ %657, %.cont.cont.i1126 ]
  %594 = extractelement <2 x i64> %593, i64 1
  %.sroa.12.0562.i1110 = inttoptr i64 %594 to ptr
  %595 = extractelement <2 x i64> %593, i64 0
  %.sroa.6.0563.i1109 = inttoptr i64 %595 to ptr
  %596 = add nuw nsw i32 %.0566.i1106, 1
  %597 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1108, 0
  %598 = insertvalue { ptr, ptr, ptr, i32 } %597, ptr %.sroa.6.0563.i1109, 1
  %599 = insertvalue { ptr, ptr, ptr, i32 } %598, ptr %.sroa.12.0562.i1110, 2
  %600 = insertvalue { ptr, ptr, ptr, i32 } %599, i32 %.sroa.17.0561.i1111, 3
  %601 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1108)
  %602 = sext i32 %.sroa.17.0561.i1111 to i64
  %603 = getelementptr ptr, ptr %.sroa.0.0564.i1108, i64 %602
  %604 = getelementptr i8, ptr %603, i64 64
  %605 = load ptr, ptr %604, align 8
  %result.i125.i1112 = call ptr %605({ ptr, ptr, ptr, i32 } %600, ptr nocapture nofree noundef nonnull readonly %2) #16
  %606 = call i32 %result.i125.i1112({ ptr, ptr, ptr, i32 } %600, { ptr, ptr, ptr, i32 } %600, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1107, label %607, label %623

607:                                              ; preds = %592
  %608 = load i32, ptr %22, align 8
  %609 = add i32 %608, -1
  %610 = and i32 %609, %606
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %612 = load ptr, ptr %23, align 8
  %613 = sext i32 %610 to i64
  %614 = shl nsw i64 %613, 5
  %615 = getelementptr i8, ptr %612, i64 %614
  %616 = load ptr, ptr %615, align 8
  %617 = getelementptr i8, ptr %615, i64 8
  %618 = load i160, ptr %617, align 4
  store ptr %.sroa.0.0564.i1108, ptr %615, align 8
  store i64 %595, ptr %617, align 4
  %.sroa_idx157.i1155 = getelementptr i8, ptr %615, i64 16
  store i64 %594, ptr %.sroa_idx157.i1155, align 4
  %.sroa_idx158.i1156 = getelementptr i8, ptr %615, i64 24
  store i32 %.sroa.17.0561.i1111, ptr %.sroa_idx158.i1156, align 4
  %619 = icmp ne ptr %616, @nil_typ
  %620 = icmp ne ptr %616, null
  %.not92.i1157 = and i1 %619, %620
  %extract.i1159 = lshr i160 %618, 64
  %621 = insertelement <2 x i160> poison, i160 %618, i64 0
  %622 = insertelement <2 x i160> %621, i160 %extract.i1159, i64 1
  br i1 %.not92.i1157, label %.cont.cont.i1126, label %662

623:                                              ; preds = %592
  %624 = add i32 %606, 2127912214
  %625 = shl i32 %606, 12
  %626 = add i32 %624, %625
  %627 = ashr i32 %626, 19
  %628 = xor i32 %626, %627
  %629 = xor i32 %628, -949894596
  %630 = add i32 %629, 374761393
  %631 = shl i32 %629, 5
  %632 = add i32 %630, %631
  %633 = add i32 %632, -744332180
  %634 = shl i32 %632, 9
  %635 = xor i32 %633, %634
  %636 = add i32 %635, -42973499
  %637 = shl i32 %635, 3
  %638 = add i32 %636, %637
  %639 = ashr i32 %638, 16
  %640 = xor i32 %638, %639
  %641 = xor i32 %640, -1252372727
  %642 = load i32, ptr %22, align 8
  %643 = add i32 %642, -1
  %644 = and i32 %643, %641
  %645 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %646 = load ptr, ptr %24, align 8
  %647 = sext i32 %644 to i64
  %648 = shl nsw i64 %647, 5
  %649 = getelementptr i8, ptr %646, i64 %648
  %650 = load ptr, ptr %649, align 8
  %651 = getelementptr i8, ptr %649, i64 8
  %652 = load i160, ptr %651, align 4
  store ptr %.sroa.0.0564.i1108, ptr %649, align 8
  store i64 %595, ptr %651, align 4
  %.sroa_idx161.i1116 = getelementptr i8, ptr %649, i64 16
  store i64 %594, ptr %.sroa_idx161.i1116, align 4
  %.sroa_idx162.i1117 = getelementptr i8, ptr %649, i64 24
  store i32 %.sroa.17.0561.i1111, ptr %.sroa_idx162.i1117, align 4
  %653 = icmp ne ptr %650, @nil_typ
  %654 = icmp ne ptr %650, null
  %.not90.i1118 = and i1 %653, %654
  %extract607.i1120 = lshr i160 %652, 64
  %655 = insertelement <2 x i160> poison, i160 %652, i64 0
  %656 = insertelement <2 x i160> %655, i160 %extract607.i1120, i64 1
  br i1 %.not90.i1118, label %.cont.cont.i1126, label %662

.cont.cont.i1126:                                 ; preds = %623, %607
  %vptr.i142.sroa.speculated.i1129 = phi ptr [ %616, %607 ], [ %650, %623 ]
  %.in1450 = phi <2 x i160> [ %622, %607 ], [ %656, %623 ]
  %657 = trunc <2 x i160> %.in1450 to <2 x i64>
  %658 = xor i1 %.070565.i1107, true
  %hash_coef_ptr.i.i143.i1132 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1129, i64 8
  %tbl_size_ptr.i.i144.i1133 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1129, i64 16
  %offset_tbl_ptr.i.i145.i1134 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1129, i64 40
  %hash_coef.i.i146.i1135 = load i64, ptr %hash_coef_ptr.i.i143.i1132, align 4
  %tbl_size.i.i147.i1136 = load i64, ptr %tbl_size_ptr.i.i144.i1133, align 4
  %offset_tbl.i.i148.i1137 = load ptr, ptr %offset_tbl_ptr.i.i145.i1134, align 8
  %product.i.i.i149.i1138 = mul i64 %hash_coef.i.i146.i1135, 4015701072841558310
  %shifted.i.i.i150.i1139 = lshr i64 %product.i.i.i149.i1138, 32
  %xored.i.i.i151.i1140 = xor i64 %shifted.i.i.i150.i1139, %product.i.i.i149.i1138
  %hash.i.i.i152.i1141 = and i64 %xored.i.i.i151.i1140, %tbl_size.i.i147.i1136
  %offset_ptr.i.i153.i1142 = getelementptr i32, ptr %offset_tbl.i.i148.i1137, i64 %hash.i.i.i152.i1141
  %offset.i.i154.i1143 = load i32, ptr %offset_ptr.i.i153.i1142, align 4
  %659 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %660 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %661 = icmp ult i32 %.0566.i1106, 99
  br i1 %661, label %592, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161

662:                                              ; preds = %623, %607
  %663 = phi ptr [ %8, %623 ], [ %7, %607 ]
  %664 = load i32, ptr %28, align 4
  store i32 %664, ptr %663, align 4
  %665 = add i32 %664, 1
  %666 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %665, ptr %28, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161: ; preds = %.cont.cont.i1126, %662
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i913

._crit_edge.i913:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895
  %667 = add nuw nsw i32 %.060.i911, 1
  %668 = icmp slt i32 %667, %484
  br i1 %668, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931: ; preds = %._crit_edge.i913, %480
  %669 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i534 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i535 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i536 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i537 = mul i64 %hash_coef.i.i99.i534, 4015701072841558310
  %shifted.i.i.i103.i538 = lshr i64 %product.i.i.i102.i537, 32
  %xored.i.i.i104.i539 = xor i64 %shifted.i.i.i103.i538, %product.i.i.i102.i537
  %hash.i.i.i105.i540 = and i64 %xored.i.i.i104.i539, %tbl_size.i.i100.i535
  %offset_ptr.i.i106.i541 = getelementptr i32, ptr %offset_tbl.i.i101.i536, i64 %hash.i.i.i105.i540
  %offset.i.i121.i542 = load i32, ptr %offset_ptr.i.i106.i541, align 4, !noalias !35
  %670 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %673

673:                                              ; preds = %.cont.cont.i564, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931
  %.0566.i544 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931 ], [ %677, %.cont.cont.i564 ]
  %.070565.i545 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931 ], [ %739, %.cont.cont.i564 ]
  %.sroa.0.0564.i546 = phi ptr [ %vptr.i142.sroa.speculated.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931 ], [ %vptr.i142.sroa.speculated.i567, %.cont.cont.i564 ]
  %.sroa.17.0561.i549 = phi i32 [ %offset.i.i121.i542, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931 ], [ %offset.i.i154.i581, %.cont.cont.i564 ]
  %674 = phi <2 x i64> [ %468, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931 ], [ %738, %.cont.cont.i564 ]
  %675 = extractelement <2 x i64> %674, i64 1
  %.sroa.12.0562.i548 = inttoptr i64 %675 to ptr
  %676 = extractelement <2 x i64> %674, i64 0
  %.sroa.6.0563.i547 = inttoptr i64 %676 to ptr
  %677 = add nuw nsw i32 %.0566.i544, 1
  %678 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i546, 0
  %679 = insertvalue { ptr, ptr, ptr, i32 } %678, ptr %.sroa.6.0563.i547, 1
  %680 = insertvalue { ptr, ptr, ptr, i32 } %679, ptr %.sroa.12.0562.i548, 2
  %681 = insertvalue { ptr, ptr, ptr, i32 } %680, i32 %.sroa.17.0561.i549, 3
  %682 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i546)
  %683 = sext i32 %.sroa.17.0561.i549 to i64
  %684 = getelementptr ptr, ptr %.sroa.0.0564.i546, i64 %683
  %685 = getelementptr i8, ptr %684, i64 64
  %686 = load ptr, ptr %685, align 8
  %result.i125.i550 = call ptr %686({ ptr, ptr, ptr, i32 } %681, ptr nocapture nofree noundef nonnull readonly %2) #16
  %687 = call i32 %result.i125.i550({ ptr, ptr, ptr, i32 } %681, { ptr, ptr, ptr, i32 } %681, ptr nonnull align 8 %2) #7
  br i1 %.070565.i545, label %688, label %704

688:                                              ; preds = %673
  %689 = load i32, ptr %22, align 8
  %690 = add i32 %689, -1
  %691 = and i32 %690, %687
  %692 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %693 = load ptr, ptr %23, align 8
  %694 = sext i32 %691 to i64
  %695 = shl nsw i64 %694, 5
  %696 = getelementptr i8, ptr %693, i64 %695
  %697 = load ptr, ptr %696, align 8
  %698 = getelementptr i8, ptr %696, i64 8
  %699 = load i160, ptr %698, align 4
  store ptr %.sroa.0.0564.i546, ptr %696, align 8
  store i64 %676, ptr %698, align 4
  %.sroa_idx157.i593 = getelementptr i8, ptr %696, i64 16
  store i64 %675, ptr %.sroa_idx157.i593, align 4
  %.sroa_idx158.i594 = getelementptr i8, ptr %696, i64 24
  store i32 %.sroa.17.0561.i549, ptr %.sroa_idx158.i594, align 4
  %700 = icmp ne ptr %697, @nil_typ
  %701 = icmp ne ptr %697, null
  %.not92.i595 = and i1 %700, %701
  %extract.i597 = lshr i160 %699, 64
  %702 = insertelement <2 x i160> poison, i160 %699, i64 0
  %703 = insertelement <2 x i160> %702, i160 %extract.i597, i64 1
  br i1 %.not92.i595, label %.cont.cont.i564, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.thread

704:                                              ; preds = %673
  %705 = add i32 %687, 2127912214
  %706 = shl i32 %687, 12
  %707 = add i32 %705, %706
  %708 = ashr i32 %707, 19
  %709 = xor i32 %707, %708
  %710 = xor i32 %709, -949894596
  %711 = add i32 %710, 374761393
  %712 = shl i32 %710, 5
  %713 = add i32 %711, %712
  %714 = add i32 %713, -744332180
  %715 = shl i32 %713, 9
  %716 = xor i32 %714, %715
  %717 = add i32 %716, -42973499
  %718 = shl i32 %716, 3
  %719 = add i32 %717, %718
  %720 = ashr i32 %719, 16
  %721 = xor i32 %719, %720
  %722 = xor i32 %721, -1252372727
  %723 = load i32, ptr %22, align 8
  %724 = add i32 %723, -1
  %725 = and i32 %724, %722
  %726 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %727 = load ptr, ptr %24, align 8
  %728 = sext i32 %725 to i64
  %729 = shl nsw i64 %728, 5
  %730 = getelementptr i8, ptr %727, i64 %729
  %731 = load ptr, ptr %730, align 8
  %732 = getelementptr i8, ptr %730, i64 8
  %733 = load i160, ptr %732, align 4
  store ptr %.sroa.0.0564.i546, ptr %730, align 8
  store i64 %676, ptr %732, align 4
  %.sroa_idx161.i554 = getelementptr i8, ptr %730, i64 16
  store i64 %675, ptr %.sroa_idx161.i554, align 4
  %.sroa_idx162.i555 = getelementptr i8, ptr %730, i64 24
  store i32 %.sroa.17.0561.i549, ptr %.sroa_idx162.i555, align 4
  %734 = icmp ne ptr %731, @nil_typ
  %735 = icmp ne ptr %731, null
  %.not90.i556 = and i1 %734, %735
  %extract607.i558 = lshr i160 %733, 64
  %736 = insertelement <2 x i160> poison, i160 %733, i64 0
  %737 = insertelement <2 x i160> %736, i160 %extract607.i558, i64 1
  br i1 %.not90.i556, label %.cont.cont.i564, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.thread

.cont.cont.i564:                                  ; preds = %704, %688
  %vptr.i142.sroa.speculated.i567 = phi ptr [ %697, %688 ], [ %731, %704 ]
  %.in1451 = phi <2 x i160> [ %703, %688 ], [ %737, %704 ]
  %738 = trunc <2 x i160> %.in1451 to <2 x i64>
  %739 = xor i1 %.070565.i545, true
  %hash_coef_ptr.i.i143.i570 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i567, i64 8
  %tbl_size_ptr.i.i144.i571 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i567, i64 16
  %offset_tbl_ptr.i.i145.i572 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i567, i64 40
  %hash_coef.i.i146.i573 = load i64, ptr %hash_coef_ptr.i.i143.i570, align 4
  %tbl_size.i.i147.i574 = load i64, ptr %tbl_size_ptr.i.i144.i571, align 4
  %offset_tbl.i.i148.i575 = load ptr, ptr %offset_tbl_ptr.i.i145.i572, align 8
  %product.i.i.i149.i576 = mul i64 %hash_coef.i.i146.i573, 4015701072841558310
  %shifted.i.i.i150.i577 = lshr i64 %product.i.i.i149.i576, 32
  %xored.i.i.i151.i578 = xor i64 %shifted.i.i.i150.i577, %product.i.i.i149.i576
  %hash.i.i.i152.i579 = and i64 %xored.i.i.i151.i578, %tbl_size.i.i147.i574
  %offset_ptr.i.i153.i580 = getelementptr i32, ptr %offset_tbl.i.i148.i575, i64 %hash.i.i.i152.i579
  %offset.i.i154.i581 = load i32, ptr %offset_ptr.i.i153.i580, align 4
  %740 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %741 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %742 = icmp ult i32 %.0566.i544, 99
  br i1 %742, label %673, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.thread: ; preds = %688, %704
  %743 = phi ptr [ %12, %704 ], [ %11, %688 ]
  %744 = load i32, ptr %28, align 4
  store i32 %744, ptr %743, align 4
  %745 = add i32 %744, 1
  %746 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %745, ptr %28, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599: ; preds = %.cont.cont.i564
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  %747 = icmp eq ptr %vptr.i142.sroa.speculated.i567, null
  br i1 %747, label %CuckooMap_insert_keyK_valueV.exit, label %748

748:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599
  %749 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %750 = load ptr, ptr %23, align 8
  %751 = load ptr, ptr %24, align 8
  %752 = load i32, ptr %22, align 8
  %753 = shl i32 %752, 1
  %spec.select.i615 = call i32 @llvm.smax.i32(i32 %753, i32 16)
  store i32 %spec.select.i615, ptr %22, align 8
  %754 = zext nneg i32 %spec.select.i615 to i64
  %755 = shl nuw nsw i64 %754, 5
  %result.i.i616 = call noalias ptr @bump_malloc_inner(i64 noundef %755, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i616, ptr %23, align 8
  %result.i20.i617 = call noalias ptr @bump_malloc_inner(i64 noundef %755, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i617, ptr %24, align 8
  store i32 0, ptr %28, align 4
  %756 = icmp sgt i32 %752, 0
  br i1 %756, label %.lr.ph.i961, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.thread: ; preds = %748
  %757 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i961:                                      ; preds = %748, %._crit_edge.i976
  %.060.i974 = phi i32 [ %846, %._crit_edge.i976 ], [ 0, %748 ]
  %758 = zext nneg i32 %.060.i974 to i64
  %759 = shl nuw nsw i64 %758, 5
  %760 = getelementptr i8, ptr %750, i64 %759
  %761 = load ptr, ptr %760, align 8
  %762 = icmp ne ptr %761, @nil_typ
  %763 = icmp ne ptr %761, null
  %.not16.i975 = and i1 %762, %763
  br i1 %.not16.i975, label %764, label %._crit_edge.i976

764:                                              ; preds = %.lr.ph.i961
  %765 = getelementptr i8, ptr %760, i64 8
  %766 = load <2 x i64>, ptr %765, align 4
  %hash_coef_ptr.i.i18.i978 = getelementptr i8, ptr %761, i64 8
  %tbl_size_ptr.i.i19.i979 = getelementptr i8, ptr %761, i64 16
  %offset_tbl_ptr.i.i20.i980 = getelementptr i8, ptr %761, i64 40
  %767 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i1179 = load i64, ptr %hash_coef_ptr.i.i18.i978, align 4, !noalias !22
  %tbl_size.i.i100.i1180 = load i64, ptr %tbl_size_ptr.i.i19.i979, align 4, !noalias !22
  %offset_tbl.i.i101.i1181 = load ptr, ptr %offset_tbl_ptr.i.i20.i980, align 8, !noalias !22
  %product.i.i.i102.i1182 = mul i64 %hash_coef.i.i99.i1179, 4015701072841558310
  %shifted.i.i.i103.i1183 = lshr i64 %product.i.i.i102.i1182, 32
  %xored.i.i.i104.i1184 = xor i64 %shifted.i.i.i103.i1183, %product.i.i.i102.i1182
  %hash.i.i.i105.i1185 = and i64 %xored.i.i.i104.i1184, %tbl_size.i.i100.i1180
  %offset_ptr.i.i106.i1186 = getelementptr i32, ptr %offset_tbl.i.i101.i1181, i64 %hash.i.i.i105.i1185
  %offset.i.i121.i1187 = load i32, ptr %offset_ptr.i.i106.i1186, align 4, !noalias !38
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %770 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %771

771:                                              ; preds = %.cont.cont.i1208, %764
  %.0566.i1188 = phi i32 [ 0, %764 ], [ %775, %.cont.cont.i1208 ]
  %.070565.i1189 = phi i1 [ true, %764 ], [ %837, %.cont.cont.i1208 ]
  %.sroa.0.0564.i1190 = phi ptr [ %761, %764 ], [ %vptr.i142.sroa.speculated.i1211, %.cont.cont.i1208 ]
  %.sroa.17.0561.i1193 = phi i32 [ %offset.i.i121.i1187, %764 ], [ %offset.i.i154.i1225, %.cont.cont.i1208 ]
  %772 = phi <2 x i64> [ %766, %764 ], [ %836, %.cont.cont.i1208 ]
  %773 = extractelement <2 x i64> %772, i64 1
  %.sroa.12.0562.i1192 = inttoptr i64 %773 to ptr
  %774 = extractelement <2 x i64> %772, i64 0
  %.sroa.6.0563.i1191 = inttoptr i64 %774 to ptr
  %775 = add nuw nsw i32 %.0566.i1188, 1
  %776 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1190, 0
  %777 = insertvalue { ptr, ptr, ptr, i32 } %776, ptr %.sroa.6.0563.i1191, 1
  %778 = insertvalue { ptr, ptr, ptr, i32 } %777, ptr %.sroa.12.0562.i1192, 2
  %779 = insertvalue { ptr, ptr, ptr, i32 } %778, i32 %.sroa.17.0561.i1193, 3
  %780 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1190)
  %781 = sext i32 %.sroa.17.0561.i1193 to i64
  %782 = getelementptr ptr, ptr %.sroa.0.0564.i1190, i64 %781
  %783 = getelementptr i8, ptr %782, i64 64
  %784 = load ptr, ptr %783, align 8
  %result.i125.i1194 = call ptr %784({ ptr, ptr, ptr, i32 } %779, ptr nocapture nofree noundef nonnull readonly %2) #16
  %785 = call i32 %result.i125.i1194({ ptr, ptr, ptr, i32 } %779, { ptr, ptr, ptr, i32 } %779, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1189, label %786, label %802

786:                                              ; preds = %771
  %787 = load i32, ptr %22, align 8
  %788 = add i32 %787, -1
  %789 = and i32 %788, %785
  %790 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %791 = load ptr, ptr %23, align 8
  %792 = sext i32 %789 to i64
  %793 = shl nsw i64 %792, 5
  %794 = getelementptr i8, ptr %791, i64 %793
  %795 = load ptr, ptr %794, align 8
  %796 = getelementptr i8, ptr %794, i64 8
  %797 = load i160, ptr %796, align 4
  store ptr %.sroa.0.0564.i1190, ptr %794, align 8
  store i64 %774, ptr %796, align 4
  %.sroa_idx157.i1237 = getelementptr i8, ptr %794, i64 16
  store i64 %773, ptr %.sroa_idx157.i1237, align 4
  %.sroa_idx158.i1238 = getelementptr i8, ptr %794, i64 24
  store i32 %.sroa.17.0561.i1193, ptr %.sroa_idx158.i1238, align 4
  %798 = icmp ne ptr %795, @nil_typ
  %799 = icmp ne ptr %795, null
  %.not92.i1239 = and i1 %798, %799
  %extract.i1241 = lshr i160 %797, 64
  %800 = insertelement <2 x i160> poison, i160 %797, i64 0
  %801 = insertelement <2 x i160> %800, i160 %extract.i1241, i64 1
  br i1 %.not92.i1239, label %.cont.cont.i1208, label %841

802:                                              ; preds = %771
  %803 = add i32 %785, 2127912214
  %804 = shl i32 %785, 12
  %805 = add i32 %803, %804
  %806 = ashr i32 %805, 19
  %807 = xor i32 %805, %806
  %808 = xor i32 %807, -949894596
  %809 = add i32 %808, 374761393
  %810 = shl i32 %808, 5
  %811 = add i32 %809, %810
  %812 = add i32 %811, -744332180
  %813 = shl i32 %811, 9
  %814 = xor i32 %812, %813
  %815 = add i32 %814, -42973499
  %816 = shl i32 %814, 3
  %817 = add i32 %815, %816
  %818 = ashr i32 %817, 16
  %819 = xor i32 %817, %818
  %820 = xor i32 %819, -1252372727
  %821 = load i32, ptr %22, align 8
  %822 = add i32 %821, -1
  %823 = and i32 %822, %820
  %824 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %825 = load ptr, ptr %24, align 8
  %826 = sext i32 %823 to i64
  %827 = shl nsw i64 %826, 5
  %828 = getelementptr i8, ptr %825, i64 %827
  %829 = load ptr, ptr %828, align 8
  %830 = getelementptr i8, ptr %828, i64 8
  %831 = load i160, ptr %830, align 4
  store ptr %.sroa.0.0564.i1190, ptr %828, align 8
  store i64 %774, ptr %830, align 4
  %.sroa_idx161.i1198 = getelementptr i8, ptr %828, i64 16
  store i64 %773, ptr %.sroa_idx161.i1198, align 4
  %.sroa_idx162.i1199 = getelementptr i8, ptr %828, i64 24
  store i32 %.sroa.17.0561.i1193, ptr %.sroa_idx162.i1199, align 4
  %832 = icmp ne ptr %829, @nil_typ
  %833 = icmp ne ptr %829, null
  %.not90.i1200 = and i1 %832, %833
  %extract607.i1202 = lshr i160 %831, 64
  %834 = insertelement <2 x i160> poison, i160 %831, i64 0
  %835 = insertelement <2 x i160> %834, i160 %extract607.i1202, i64 1
  br i1 %.not90.i1200, label %.cont.cont.i1208, label %841

.cont.cont.i1208:                                 ; preds = %802, %786
  %vptr.i142.sroa.speculated.i1211 = phi ptr [ %795, %786 ], [ %829, %802 ]
  %.in1452 = phi <2 x i160> [ %801, %786 ], [ %835, %802 ]
  %836 = trunc <2 x i160> %.in1452 to <2 x i64>
  %837 = xor i1 %.070565.i1189, true
  %hash_coef_ptr.i.i143.i1214 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1211, i64 8
  %tbl_size_ptr.i.i144.i1215 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1211, i64 16
  %offset_tbl_ptr.i.i145.i1216 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1211, i64 40
  %hash_coef.i.i146.i1217 = load i64, ptr %hash_coef_ptr.i.i143.i1214, align 4
  %tbl_size.i.i147.i1218 = load i64, ptr %tbl_size_ptr.i.i144.i1215, align 4
  %offset_tbl.i.i148.i1219 = load ptr, ptr %offset_tbl_ptr.i.i145.i1216, align 8
  %product.i.i.i149.i1220 = mul i64 %hash_coef.i.i146.i1217, 4015701072841558310
  %shifted.i.i.i150.i1221 = lshr i64 %product.i.i.i149.i1220, 32
  %xored.i.i.i151.i1222 = xor i64 %shifted.i.i.i150.i1221, %product.i.i.i149.i1220
  %hash.i.i.i152.i1223 = and i64 %xored.i.i.i151.i1222, %tbl_size.i.i147.i1218
  %offset_ptr.i.i153.i1224 = getelementptr i32, ptr %offset_tbl.i.i148.i1219, i64 %hash.i.i.i152.i1223
  %offset.i.i154.i1225 = load i32, ptr %offset_ptr.i.i153.i1224, align 4
  %838 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %839 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %840 = icmp ult i32 %.0566.i1188, 99
  br i1 %840, label %771, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1243

841:                                              ; preds = %802, %786
  %842 = phi ptr [ %6, %802 ], [ %5, %786 ]
  %843 = load i32, ptr %28, align 4
  store i32 %843, ptr %842, align 4
  %844 = add i32 %843, 1
  %845 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %844, ptr %28, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1243

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1243: ; preds = %.cont.cont.i1208, %841
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i976

._crit_edge.i976:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1243, %.lr.ph.i961
  %846 = add nuw nsw i32 %.060.i974, 1
  %847 = icmp slt i32 %846, %752
  br i1 %847, label %.lr.ph.i961, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994: ; preds = %._crit_edge.i976
  %848 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %849

849:                                              ; preds = %._crit_edge.i1012, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994
  %.060.i1010 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994 ], [ %938, %._crit_edge.i1012 ]
  %850 = zext nneg i32 %.060.i1010 to i64
  %851 = shl nuw nsw i64 %850, 5
  %852 = getelementptr i8, ptr %751, i64 %851
  %853 = load ptr, ptr %852, align 8
  %854 = icmp ne ptr %853, @nil_typ
  %855 = icmp ne ptr %853, null
  %.not16.i1011 = and i1 %854, %855
  br i1 %.not16.i1011, label %856, label %._crit_edge.i1012

856:                                              ; preds = %849
  %857 = getelementptr i8, ptr %852, i64 8
  %858 = load <2 x i64>, ptr %857, align 4
  %hash_coef_ptr.i.i18.i1014 = getelementptr i8, ptr %853, i64 8
  %tbl_size_ptr.i.i19.i1015 = getelementptr i8, ptr %853, i64 16
  %offset_tbl_ptr.i.i20.i1016 = getelementptr i8, ptr %853, i64 40
  %859 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i1261 = load i64, ptr %hash_coef_ptr.i.i18.i1014, align 4, !noalias !22
  %tbl_size.i.i100.i1262 = load i64, ptr %tbl_size_ptr.i.i19.i1015, align 4, !noalias !22
  %offset_tbl.i.i101.i1263 = load ptr, ptr %offset_tbl_ptr.i.i20.i1016, align 8, !noalias !22
  %product.i.i.i102.i1264 = mul i64 %hash_coef.i.i99.i1261, 4015701072841558310
  %shifted.i.i.i103.i1265 = lshr i64 %product.i.i.i102.i1264, 32
  %xored.i.i.i104.i1266 = xor i64 %shifted.i.i.i103.i1265, %product.i.i.i102.i1264
  %hash.i.i.i105.i1267 = and i64 %xored.i.i.i104.i1266, %tbl_size.i.i100.i1262
  %offset_ptr.i.i106.i1268 = getelementptr i32, ptr %offset_tbl.i.i101.i1263, i64 %hash.i.i.i105.i1267
  %offset.i.i121.i1269 = load i32, ptr %offset_ptr.i.i106.i1268, align 4, !noalias !41
  %860 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %861 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %862 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %863

863:                                              ; preds = %.cont.cont.i1290, %856
  %.0566.i1270 = phi i32 [ 0, %856 ], [ %867, %.cont.cont.i1290 ]
  %.070565.i1271 = phi i1 [ true, %856 ], [ %929, %.cont.cont.i1290 ]
  %.sroa.0.0564.i1272 = phi ptr [ %853, %856 ], [ %vptr.i142.sroa.speculated.i1293, %.cont.cont.i1290 ]
  %.sroa.17.0561.i1275 = phi i32 [ %offset.i.i121.i1269, %856 ], [ %offset.i.i154.i1307, %.cont.cont.i1290 ]
  %864 = phi <2 x i64> [ %858, %856 ], [ %928, %.cont.cont.i1290 ]
  %865 = extractelement <2 x i64> %864, i64 1
  %.sroa.12.0562.i1274 = inttoptr i64 %865 to ptr
  %866 = extractelement <2 x i64> %864, i64 0
  %.sroa.6.0563.i1273 = inttoptr i64 %866 to ptr
  %867 = add nuw nsw i32 %.0566.i1270, 1
  %868 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1272, 0
  %869 = insertvalue { ptr, ptr, ptr, i32 } %868, ptr %.sroa.6.0563.i1273, 1
  %870 = insertvalue { ptr, ptr, ptr, i32 } %869, ptr %.sroa.12.0562.i1274, 2
  %871 = insertvalue { ptr, ptr, ptr, i32 } %870, i32 %.sroa.17.0561.i1275, 3
  %872 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1272)
  %873 = sext i32 %.sroa.17.0561.i1275 to i64
  %874 = getelementptr ptr, ptr %.sroa.0.0564.i1272, i64 %873
  %875 = getelementptr i8, ptr %874, i64 64
  %876 = load ptr, ptr %875, align 8
  %result.i125.i1276 = call ptr %876({ ptr, ptr, ptr, i32 } %871, ptr nocapture nofree noundef nonnull readonly %2) #16
  %877 = call i32 %result.i125.i1276({ ptr, ptr, ptr, i32 } %871, { ptr, ptr, ptr, i32 } %871, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1271, label %878, label %894

878:                                              ; preds = %863
  %879 = load i32, ptr %22, align 8
  %880 = add i32 %879, -1
  %881 = and i32 %880, %877
  %882 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %883 = load ptr, ptr %23, align 8
  %884 = sext i32 %881 to i64
  %885 = shl nsw i64 %884, 5
  %886 = getelementptr i8, ptr %883, i64 %885
  %887 = load ptr, ptr %886, align 8
  %888 = getelementptr i8, ptr %886, i64 8
  %889 = load i160, ptr %888, align 4
  store ptr %.sroa.0.0564.i1272, ptr %886, align 8
  store i64 %866, ptr %888, align 4
  %.sroa_idx157.i1319 = getelementptr i8, ptr %886, i64 16
  store i64 %865, ptr %.sroa_idx157.i1319, align 4
  %.sroa_idx158.i1320 = getelementptr i8, ptr %886, i64 24
  store i32 %.sroa.17.0561.i1275, ptr %.sroa_idx158.i1320, align 4
  %890 = icmp ne ptr %887, @nil_typ
  %891 = icmp ne ptr %887, null
  %.not92.i1321 = and i1 %890, %891
  %extract.i1323 = lshr i160 %889, 64
  %892 = insertelement <2 x i160> poison, i160 %889, i64 0
  %893 = insertelement <2 x i160> %892, i160 %extract.i1323, i64 1
  br i1 %.not92.i1321, label %.cont.cont.i1290, label %933

894:                                              ; preds = %863
  %895 = add i32 %877, 2127912214
  %896 = shl i32 %877, 12
  %897 = add i32 %895, %896
  %898 = ashr i32 %897, 19
  %899 = xor i32 %897, %898
  %900 = xor i32 %899, -949894596
  %901 = add i32 %900, 374761393
  %902 = shl i32 %900, 5
  %903 = add i32 %901, %902
  %904 = add i32 %903, -744332180
  %905 = shl i32 %903, 9
  %906 = xor i32 %904, %905
  %907 = add i32 %906, -42973499
  %908 = shl i32 %906, 3
  %909 = add i32 %907, %908
  %910 = ashr i32 %909, 16
  %911 = xor i32 %909, %910
  %912 = xor i32 %911, -1252372727
  %913 = load i32, ptr %22, align 8
  %914 = add i32 %913, -1
  %915 = and i32 %914, %912
  %916 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %917 = load ptr, ptr %24, align 8
  %918 = sext i32 %915 to i64
  %919 = shl nsw i64 %918, 5
  %920 = getelementptr i8, ptr %917, i64 %919
  %921 = load ptr, ptr %920, align 8
  %922 = getelementptr i8, ptr %920, i64 8
  %923 = load i160, ptr %922, align 4
  store ptr %.sroa.0.0564.i1272, ptr %920, align 8
  store i64 %866, ptr %922, align 4
  %.sroa_idx161.i1280 = getelementptr i8, ptr %920, i64 16
  store i64 %865, ptr %.sroa_idx161.i1280, align 4
  %.sroa_idx162.i1281 = getelementptr i8, ptr %920, i64 24
  store i32 %.sroa.17.0561.i1275, ptr %.sroa_idx162.i1281, align 4
  %924 = icmp ne ptr %921, @nil_typ
  %925 = icmp ne ptr %921, null
  %.not90.i1282 = and i1 %924, %925
  %extract607.i1284 = lshr i160 %923, 64
  %926 = insertelement <2 x i160> poison, i160 %923, i64 0
  %927 = insertelement <2 x i160> %926, i160 %extract607.i1284, i64 1
  br i1 %.not90.i1282, label %.cont.cont.i1290, label %933

.cont.cont.i1290:                                 ; preds = %894, %878
  %vptr.i142.sroa.speculated.i1293 = phi ptr [ %887, %878 ], [ %921, %894 ]
  %.in1453 = phi <2 x i160> [ %893, %878 ], [ %927, %894 ]
  %928 = trunc <2 x i160> %.in1453 to <2 x i64>
  %929 = xor i1 %.070565.i1271, true
  %hash_coef_ptr.i.i143.i1296 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1293, i64 8
  %tbl_size_ptr.i.i144.i1297 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1293, i64 16
  %offset_tbl_ptr.i.i145.i1298 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1293, i64 40
  %hash_coef.i.i146.i1299 = load i64, ptr %hash_coef_ptr.i.i143.i1296, align 4
  %tbl_size.i.i147.i1300 = load i64, ptr %tbl_size_ptr.i.i144.i1297, align 4
  %offset_tbl.i.i148.i1301 = load ptr, ptr %offset_tbl_ptr.i.i145.i1298, align 8
  %product.i.i.i149.i1302 = mul i64 %hash_coef.i.i146.i1299, 4015701072841558310
  %shifted.i.i.i150.i1303 = lshr i64 %product.i.i.i149.i1302, 32
  %xored.i.i.i151.i1304 = xor i64 %shifted.i.i.i150.i1303, %product.i.i.i149.i1302
  %hash.i.i.i152.i1305 = and i64 %xored.i.i.i151.i1304, %tbl_size.i.i147.i1300
  %offset_ptr.i.i153.i1306 = getelementptr i32, ptr %offset_tbl.i.i148.i1301, i64 %hash.i.i.i152.i1305
  %offset.i.i154.i1307 = load i32, ptr %offset_ptr.i.i153.i1306, align 4
  %930 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %931 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %932 = icmp ult i32 %.0566.i1270, 99
  br i1 %932, label %863, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1325

933:                                              ; preds = %894, %878
  %934 = phi ptr [ %4, %894 ], [ %3, %878 ]
  %935 = load i32, ptr %28, align 4
  store i32 %935, ptr %934, align 4
  %936 = add i32 %935, 1
  %937 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %936, ptr %28, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1325

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1325: ; preds = %.cont.cont.i1290, %933
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i1012

._crit_edge.i1012:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1325, %849
  %938 = add nuw nsw i32 %.060.i1010, 1
  %939 = icmp slt i32 %938, %752
  br i1 %939, label %849, label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i1012, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit459, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %940 = icmp slt i32 %32, %0
  br i1 %940, label %._crit_edge, label %._crit_edge2

._crit_edge2:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit
  %941 = call i64 @clock()
  %942 = add nsw i32 %0, -1
  %.sroa.0117.0.insert.ext = zext nneg i32 %942 to i160
  %943 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext, 1
  %944 = load ptr, ptr %20, align 8
  %945 = call i32 %944({ ptr, i160 } %943) #7
  %946 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %947 = load i32, ptr %22, align 8
  %948 = add i32 %947, -1
  %949 = and i32 %948, %945
  %950 = load ptr, ptr %23, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %951 = sext i32 %949 to i64
  %952 = shl nsw i64 %951, 5
  %953 = getelementptr i8, ptr %950, i64 %952
  %954 = load ptr, ptr %953, align 8
  %955 = icmp ne ptr %954, @nil_typ
  %956 = icmp ne ptr %954, null
  %.not44.i = and i1 %955, %956
  br i1 %.not44.i, label %957, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

957:                                              ; preds = %._crit_edge2
  %958 = getelementptr i8, ptr %953, i64 8
  %959 = load i64, ptr %958, align 4
  %.sroa_idx.i662 = getelementptr i8, ptr %953, i64 16
  %960 = load i64, ptr %.sroa_idx.i662, align 4
  %961 = inttoptr i64 %959 to ptr
  %962 = inttoptr i64 %960 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %954, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %954, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %954, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !44
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !44
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !44
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !44
  %963 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %954, 0
  %964 = insertvalue { ptr, ptr, ptr, i32 } %963, ptr %961, 1
  %965 = insertvalue { ptr, ptr, ptr, i32 } %964, ptr %962, 2
  %966 = insertvalue { ptr, ptr, ptr, i32 } %965, i32 %offset.i.i57.i, 3
  %967 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %968 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %954) #35
  %969 = sext i32 %offset.i.i57.i to i64
  %970 = getelementptr ptr, ptr %954, i64 %969
  %971 = getelementptr i8, ptr %970, i64 64
  %972 = load ptr, ptr %971, align 8
  %result.i.i663 = call ptr %972({ ptr, ptr, ptr, i32 } %966, ptr nocapture nofree noundef nonnull readonly %2) #16
  %973 = call i32 %result.i.i663({ ptr, ptr, ptr, i32 } %966, { ptr, ptr, ptr, i32 } %966, ptr nonnull align 8 %2) #7
  %974 = icmp eq i32 %973, %945
  br i1 %974, label %._crit_edge.i664, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i664:                                 ; preds = %957
  %975 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %976 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %954)
  %977 = getelementptr i8, ptr %970, i64 48
  %978 = load ptr, ptr %977, align 8
  %result.i59.i = call ptr %978({ ptr, ptr, ptr, i32 } %966, ptr nocapture nofree noundef nonnull readonly %2) #16
  %979 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %966, { ptr, ptr, ptr, i32 } %966, ptr nonnull align 8 %2) #7
  %980 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %981 = load ptr, ptr %21, align 8
  %982 = call i1 %981({ ptr, i160 } %979, { ptr, i160 } %943) #7
  br i1 %982, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i664, %._crit_edge2, %957
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %990

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i664
  %983 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %954)
  %985 = getelementptr i8, ptr %970, i64 56
  %986 = load ptr, ptr %985, align 8
  %result.i60.i = call ptr %986({ ptr, ptr, ptr, i32 } %966, ptr nocapture nofree noundef nonnull readonly %2) #16
  %987 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %966, { ptr, ptr, ptr, i32 } %966, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %987, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %988 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %989 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %988, %989
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %990

990:                                              ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %991 = add i32 %945, 2127912214
  %992 = shl i32 %945, 12
  %993 = add i32 %991, %992
  %994 = ashr i32 %993, 19
  %995 = xor i32 %993, %994
  %996 = xor i32 %995, -949894596
  %997 = add i32 %996, 374761393
  %998 = shl i32 %996, 5
  %999 = add i32 %997, %998
  %1000 = add i32 %999, -744332180
  %1001 = shl i32 %999, 9
  %1002 = xor i32 %1000, %1001
  %1003 = add i32 %1002, -42973499
  %1004 = shl i32 %1002, 3
  %1005 = add i32 %1003, %1004
  %1006 = ashr i32 %1005, 16
  %1007 = xor i32 %1005, %1006
  %1008 = xor i32 %1007, -1252372727
  %1009 = load i32, ptr %22, align 8
  %1010 = add i32 %1009, -1
  %1011 = and i32 %1010, %1008
  %1012 = load ptr, ptr %24, align 8
  %1013 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1014 = sext i32 %1011 to i64
  %1015 = shl nsw i64 %1014, 5
  %1016 = getelementptr i8, ptr %1012, i64 %1015
  %1017 = load ptr, ptr %1016, align 8
  %1018 = icmp ne ptr %1017, @nil_typ
  %1019 = icmp ne ptr %1017, null
  %.not44.i694 = and i1 %1018, %1019
  br i1 %.not44.i694, label %1020, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718

1020:                                             ; preds = %990
  %1021 = getelementptr i8, ptr %1016, i64 8
  %1022 = load i64, ptr %1021, align 4
  %.sroa_idx.i698 = getelementptr i8, ptr %1016, i64 16
  %1023 = load i64, ptr %.sroa_idx.i698, align 4
  %1024 = inttoptr i64 %1022 to ptr
  %1025 = inttoptr i64 %1023 to ptr
  %hash_coef_ptr.i.i46.i699 = getelementptr i8, ptr %1017, i64 8
  %tbl_size_ptr.i.i47.i700 = getelementptr i8, ptr %1017, i64 16
  %offset_tbl_ptr.i.i48.i701 = getelementptr i8, ptr %1017, i64 40
  %hash_coef.i.i49.i702 = load i64, ptr %hash_coef_ptr.i.i46.i699, align 4, !noalias !47
  %tbl_size.i.i50.i703 = load i64, ptr %tbl_size_ptr.i.i47.i700, align 4, !noalias !47
  %offset_tbl.i.i51.i704 = load ptr, ptr %offset_tbl_ptr.i.i48.i701, align 8, !noalias !47
  %product.i.i.i52.i705 = mul i64 %hash_coef.i.i49.i702, 4015701072841558310
  %shifted.i.i.i53.i706 = lshr i64 %product.i.i.i52.i705, 32
  %xored.i.i.i54.i707 = xor i64 %shifted.i.i.i53.i706, %product.i.i.i52.i705
  %hash.i.i.i55.i708 = and i64 %xored.i.i.i54.i707, %tbl_size.i.i50.i703
  %offset_ptr.i.i56.i709 = getelementptr i32, ptr %offset_tbl.i.i51.i704, i64 %hash.i.i.i55.i708
  %offset.i.i57.i710 = load i32, ptr %offset_ptr.i.i56.i709, align 4, !noalias !47
  %1026 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1017, 0
  %1027 = insertvalue { ptr, ptr, ptr, i32 } %1026, ptr %1024, 1
  %1028 = insertvalue { ptr, ptr, ptr, i32 } %1027, ptr %1025, 2
  %1029 = insertvalue { ptr, ptr, ptr, i32 } %1028, i32 %offset.i.i57.i710, 3
  %1030 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1031 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1017) #35
  %1032 = sext i32 %offset.i.i57.i710 to i64
  %1033 = getelementptr ptr, ptr %1017, i64 %1032
  %1034 = getelementptr i8, ptr %1033, i64 64
  %1035 = load ptr, ptr %1034, align 8
  %result.i.i711 = call ptr %1035({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1036 = call i32 %result.i.i711({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 %2) #7
  %1037 = icmp eq i32 %1036, %945
  br i1 %1037, label %._crit_edge.i712, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718

._crit_edge.i712:                                 ; preds = %1020
  %1038 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1039 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1017)
  %1040 = getelementptr i8, ptr %1033, i64 48
  %1041 = load ptr, ptr %1040, align 8
  %result.i59.i713 = call ptr %1041({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1042 = call { ptr, i160 } %result.i59.i713({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 %2) #7
  %1043 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1044 = load ptr, ptr %21, align 8
  %1045 = call i1 %1044({ ptr, i160 } %1042, { ptr, i160 } %943) #7
  br i1 %1045, label %1046, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718

1046:                                             ; preds = %._crit_edge.i712
  %1047 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1048 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1017)
  %1049 = getelementptr i8, ptr %1033, i64 56
  %1050 = load ptr, ptr %1049, align 8
  %result.i60.i715 = call ptr %1050({ ptr, ptr, ptr, i32 } %1029, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1051 = call { ptr, i160 } %result.i60.i715({ ptr, ptr, ptr, i32 } %1029, { ptr, ptr, ptr, i32 } %1029, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i716 = extractvalue { ptr, i160 } %1051, 0
  %.fca.1.extract22.i717 = extractvalue { ptr, i160 } %1051, 1
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718: ; preds = %990, %1020, %._crit_edge.i712, %1046
  %.reg2mem43.sroa.3.077.i695 = phi i160 [ %.fca.1.extract22.i717, %1046 ], [ poison, %._crit_edge.i712 ], [ poison, %990 ], [ poison, %1020 ]
  %1052 = phi ptr [ %.fca.0.extract21.i716, %1046 ], [ @nil_typ, %._crit_edge.i712 ], [ @nil_typ, %990 ], [ @nil_typ, %1020 ]
  %.reload40.fca.0.insert.i696 = insertvalue { ptr, i160 } poison, ptr %1052, 0
  %.reload40.fca.1.insert.i697 = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i696, i160 %.reg2mem43.sroa.3.077.i695, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1053 = icmp ne ptr %1052, @nil_typ
  %1054 = icmp ne ptr %1052, null
  %.not65.not.not.i = and i1 %1053, %1054
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %1052, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718
  %.pn.i = phi { ptr, i160 } [ %987, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %.reload40.fca.1.insert.i697, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718 ]
  %1055 = phi ptr [ %.fca.0.extract21.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718 ]
  %1056 = icmp ne ptr %1055, @nil_typ
  %1057 = icmp ne ptr %1055, null
  %.not143 = and i1 %1056, %1057
  br i1 %.not143, label %._crit_edge3, label %._crit_edge4

._crit_edge3:                                     ; preds = %CuckooMap_get_keyK.exit
  %.fca.1.extract..sroa.354.0106.i = extractvalue { ptr, i160 } %.pn.i, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0106.i to i32
  %.not147 = icmp eq i32 %0, %.sroa.2.8.extract.trunc
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %CuckooMap_get_keyK.exit, %._crit_edge3
  %.2 = phi i1 [ %.not147, %._crit_edge3 ], [ false, %CuckooMap_get_keyK.exit ]
  %1058 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1059 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %1060 = load i32, ptr %28, align 4
  %.not148 = icmp eq i32 %1060, %0
  %1061 = select i1 %.not148, i1 %.2, i1 false
  %1062 = select i1 %1061, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %1063 = bitcast <4 x i8> %1062 to i32
  br label %._crit_edge.lr.ph.i

1064:                                             ; preds = %1
  %1065 = call i64 @clock()
  %1066 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %1064, %._crit_edge4
  %1068 = phi i64 [ %941, %._crit_edge4 ], [ %1065, %1064 ]
  %.reg2mem15.0.in = phi i32 [ %1063, %._crit_edge4 ], [ 1397965136, %1064 ]
  %result.i162 = call noalias align 32 dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i162, align 32
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1071 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i732 = call noalias dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(17) %result.i.i732, ptr noundef nonnull align 32 dereferenceable(17) %result.i162, i64 17, i1 false)
  %1072 = sub i64 %1068, %26
  %1073 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %1074 = getelementptr i8, ptr %result.i.i732, i64 17
  store i8 0, ptr %1074, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i732)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i98.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98.i, align 16
  %result.i.i356.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i98.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356.i)
  %1075 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #17
  %result.i104.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104.i, align 16
  %result.i.i370.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i104.i, i64 14, i1 false)
  %puts.i294.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370.i)
  %1076 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1072) #17
  %result.i110.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110.i, align 4
  %result.i.i389.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i110.i, i64 3, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  br i1 %27, label %._crit_edge1.i, label %._crit_edge.lr.ph.i748

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i
  %1077 = icmp sgt i64 %1072, 0
  br i1 %1077, label %1078, label %._crit_edge.lr.ph.i409.i

1078:                                             ; preds = %._crit_edge1.i
  %1079 = mul i64 %1072, 1000000
  %1080 = zext nneg i32 %0 to i64
  %1081 = sdiv i64 %1079, %1080
  br label %._crit_edge.lr.ph.i409.i

._crit_edge.lr.ph.i409.i:                         ; preds = %1078, %._crit_edge1.i
  %.0.i = phi i64 [ %1081, %1078 ], [ 0, %._crit_edge1.i ]
  %result.i115.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115.i, align 16
  %result.i.i408.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i115.i, i64 15, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  %1082 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i121.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121.i, align 4
  %1083 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i427.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i121.i, i64 3, i1 false)
  %1084 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  br label %._crit_edge.lr.ph.i748

._crit_edge.lr.ph.i748:                           ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i409.i
  %result.i166 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i166, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1085 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1086 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i747 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i747, ptr noundef nonnull align 32 dereferenceable(18) %result.i166, i64 18, i1 false)
  %1087 = getelementptr i8, ptr %result.i.i747, i64 18
  store i8 0, ptr %1087, align 1
  %puts.i348 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i747)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1088 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1089 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i766 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store i32 %.reg2mem15.0.in, ptr %result.i.i766, align 1
  %1091 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %1092 = getelementptr i8, ptr %result.i.i766, i64 4
  store i8 0, ptr %1092, align 1
  %puts.i368 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i766)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #4

declare i64 @clock() local_unnamed_addr

define void @benchmark_insert_random(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %oldProtect.i317 = alloca i32, align 4
  %oldProtect.i313 = alloca i32, align 4
  %oldProtect.i272 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0231.sroa.0 = alloca i8, align 8
  %result.i268 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i268, align 8
  %27 = getelementptr inbounds i8, ptr %result.i268, i64 8
  store ptr @_parameterization_Ptri32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i268, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %28, align 8
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i268) #39
  %result.i269 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i270 = call i32 @VirtualProtect(ptr nofree %result.i269, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i269, ptr noalias nofree noundef nonnull readnone @sztlnbvhek, ptr noalias nofree noundef nonnull readnone @i32_hasher) #39
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i269) #40
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i269) #39
  %result.i271 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i272)
  %result.i273 = call i32 @VirtualProtect(ptr nofree %result.i271, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i272) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i272)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i271, ptr noalias nofree noundef nonnull readnone @uzenkwklxl, ptr noalias nofree noundef nonnull readnone @i32_eq) #39
  %ret.i274 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i271) #40
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i271) #39
  %32 = getelementptr inbounds i8, ptr %result.i268, i64 48
  store ptr %ret.i, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i268, i64 56
  store ptr %ret.i274, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i268, i64 40
  store i32 8, ptr %34, align 8
  %result.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %35 = getelementptr inbounds i8, ptr %result.i268, i64 24
  store ptr %result.i.i, ptr %35, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %36 = getelementptr inbounds i8, ptr %result.i268, i64 32
  store ptr %result.i9.i, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  %38 = sext i32 %0 to i64
  %39 = shl nsw i64 %38, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %39, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #35
  %result.i311 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i311, align 8
  %41 = getelementptr inbounds i8, ptr %result.i311, i64 8
  store ptr @_parameterization_Ptri1, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i311, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %42, align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i311)
  %result.i312 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i313)
  %result.i314 = call i32 @VirtualProtect(ptr nofree %result.i312, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i313) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i313)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i312, ptr noalias nofree noundef nonnull readnone @nyirajlwbb, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i315 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i312) #40
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i312)
  %result.i316 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i317)
  %result.i318 = call i32 @VirtualProtect(ptr nofree %result.i316, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i317) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i317)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i316, ptr noalias nofree noundef nonnull readnone @sabllqfhim, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i319 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i316) #40
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i316)
  %46 = getelementptr inbounds i8, ptr %result.i311, i64 48
  store ptr %ret.i315, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i311, i64 56
  store ptr %ret.i319, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i311, i64 40
  store i32 8, ptr %48, align 8
  %result.i.i505 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %49 = getelementptr inbounds i8, ptr %result.i311, i64 24
  store ptr %result.i.i505, ptr %49, align 8
  %result.i9.i506 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %50 = getelementptr inbounds i8, ptr %result.i311, i64 32
  store ptr %result.i9.i506, ptr %50, align 8
  %51 = icmp sgt i32 %0, 0
  br i1 %51, label %._crit_edge.lr.ph, label %._crit_edge2._crit_edge.thread

._crit_edge2._crit_edge.thread:                   ; preds = %1
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %54 = call i64 @clock()
  %55 = call i64 @clock()
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph:                                ; preds = %1
  %58 = add nsw i32 %0, -1
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %62 = getelementptr inbounds i8, ptr %result.i311, i64 44
  %63 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i311, 1
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr undef, 2
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 10, 3
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %CuckooMap_insert_keyK_valueV.exit
  %66 = phi i32 [ 123, %._crit_edge.lr.ph ], [ %69, %CuckooMap_insert_keyK_valueV.exit ]
  %.0464 = phi i32 [ -1, %._crit_edge.lr.ph ], [ %spec.select, %CuckooMap_insert_keyK_valueV.exit ]
  %.0247463 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %981, %CuckooMap_insert_keyK_valueV.exit ]
  %67 = mul i32 %66, 1103515245
  %68 = add i32 %67, 12345
  %69 = and i32 %68, 2147483647
  %.sroa.0241.0.insert.ext = zext nneg i32 %69 to i160
  %70 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0241.0.insert.ext, 1
  %71 = zext nneg i32 %.0247463 to i64
  %72 = shl nuw nsw i64 %71, 2
  %73 = getelementptr i8, ptr %result.i4.i, i64 %72
  store i32 %69, ptr %73, align 1
  %74 = icmp eq i32 %.0247463, %58
  %spec.select = select i1 %74, i32 %69, i32 %.0464
  store i1 true, ptr %.sroa.0231.sroa.0, align 8
  %.sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.0. = load i8, ptr %.sroa.0231.sroa.0, align 8
  %.sroa.0231.0.insert.ext = zext i8 %.sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.0. to i160
  %75 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0231.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %76 = load ptr, ptr %46, align 8
  %77 = call i32 %76({ ptr, i160 } %70) #7
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %79 = load i32, ptr %48, align 8
  %80 = add i32 %79, -1
  %81 = and i32 %80, %77
  %82 = load ptr, ptr %49, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %83 = sext i32 %81 to i64
  %84 = shl nsw i64 %83, 5
  %85 = getelementptr i8, ptr %82, i64 %84
  %86 = load ptr, ptr %85, align 8
  %87 = getelementptr i8, ptr %85, i64 8
  %88 = icmp ne ptr %86, @nil_typ
  %89 = icmp ne ptr %86, null
  %.not64.i = and i1 %88, %89
  br i1 %.not64.i, label %90, label %188

90:                                               ; preds = %._crit_edge
  %91 = load i64, ptr %87, align 4
  %.sroa_idx.i = getelementptr i8, ptr %85, i64 16
  %92 = load i64, ptr %.sroa_idx.i, align 4
  %93 = inttoptr i64 %91 to ptr
  %94 = inttoptr i64 %92 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %86, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %86, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %86, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !50
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !50
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !50
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !50
  %95 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %86, 0
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, ptr %93, 1
  %97 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %94, 2
  %98 = insertvalue { ptr, ptr, ptr, i32 } %97, i32 %offset.i.i77.i, 3
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %86) #35
  %101 = sext i32 %offset.i.i77.i to i64
  %102 = getelementptr ptr, ptr %86, i64 %101
  %103 = getelementptr i8, ptr %102, i64 64
  %104 = load ptr, ptr %103, align 8
  %result.i.i882 = call ptr %104({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly %2) #16
  %105 = call i32 %result.i.i882({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %2) #7
  %106 = icmp eq i32 %105, %77
  br i1 %106, label %._crit_edge.i883, label %188

._crit_edge.i883:                                 ; preds = %90
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %108 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %86)
  %109 = getelementptr i8, ptr %102, i64 48
  %110 = load ptr, ptr %109, align 8
  %result.i79.i884 = call ptr %110({ ptr, ptr, ptr, i32 } %98, ptr nocapture nofree noundef nonnull readonly %2) #16
  %111 = call { ptr, i160 } %result.i79.i884({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr nonnull align 8 %2) #7
  %112 = load ptr, ptr %47, align 8
  %113 = call i1 %112({ ptr, i160 } %111, { ptr, i160 } %70) #7
  br i1 %113, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %188

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i883
  %114 = load ptr, ptr %result.i311, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %116 = load ptr, ptr %41, align 8
  %117 = load ptr, ptr %114, align 8, !alias.scope !53
  %118 = getelementptr i8, ptr %117, i64 72
  %119 = load ptr, ptr %118, align 8, !alias.scope !53
  %result.i.i.i885 = call { i64, i64 } %119(ptr nocapture nofree nonnull readonly %114) #5, !alias.scope !53
  %120 = extractvalue { i64, i64 } %result.i.i.i885, 0
  %121 = extractvalue { i64, i64 } %result.i.i.i885, 1
  %122 = urem i64 20, %121
  %123 = icmp eq i64 %122, 0
  %124 = sub i64 %121, %122
  %125 = select i1 %123, i64 0, i64 %124
  %126 = add i64 %120, 20
  %127 = add i64 %126, %125
  %128 = load ptr, ptr %116, align 8, !alias.scope !53
  %129 = getelementptr i8, ptr %128, i64 72
  %130 = load ptr, ptr %129, align 8, !alias.scope !53
  %result.i1.i.i886 = call { i64, i64 } %130(ptr nocapture nofree nonnull readonly %116) #5, !alias.scope !53
  %131 = extractvalue { i64, i64 } %result.i1.i.i886, 0
  %132 = extractvalue { i64, i64 } %result.i1.i.i886, 1
  %133 = call i64 @llvm.umax.i64(i64 %121, i64 %132)
  %134 = call i64 @llvm.umax.i64(i64 %133, i64 8)
  %135 = urem i64 %127, %132
  %136 = icmp eq i64 %135, 0
  %137 = sub i64 %132, %135
  %138 = select i1 %136, i64 0, i64 %137
  %139 = add i64 %131, %127
  %140 = add i64 %139, %138
  %141 = urem i64 %140, %134
  %142 = icmp eq i64 %141, 0
  %143 = sub i64 %134, %141
  %144 = select i1 %142, i64 0, i64 %143
  %145 = add i64 %144, %140
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %145, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %114, ptr %result.i83.i, align 8
  %146 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %116, ptr %146, align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %149 = load ptr, ptr %114, align 8
  %150 = getelementptr i8, ptr %149, i64 72
  %151 = load ptr, ptr %150, align 8
  %result.i.i118.i = call { i64, i64 } %151(ptr nocapture nofree nonnull readonly %114) #5
  %152 = extractvalue { i64, i64 } %result.i.i118.i, 1
  %153 = urem i64 20, %152
  %154 = icmp eq i64 %153, 0
  %reass.sub3125 = sub i64 %152, %153
  %155 = add i64 %reass.sub3125, 20
  %156 = select i1 %154, i64 20, i64 %155
  %157 = getelementptr i8, ptr %result.i83.i, i64 %156
  %158 = getelementptr i8, ptr %149, i64 64
  %159 = load ptr, ptr %158, align 8
  call void %159({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %114, ptr nocapture nofree writeonly %157) #1
  %160 = load ptr, ptr %result.i83.i, align 8
  %161 = load ptr, ptr %160, align 8
  %162 = getelementptr i8, ptr %161, i64 72
  %163 = load ptr, ptr %162, align 8
  %result.i.i119.i = call { i64, i64 } %163(ptr nocapture nofree nonnull readonly %160) #5
  %164 = extractvalue { i64, i64 } %result.i.i119.i, 0
  %165 = extractvalue { i64, i64 } %result.i.i119.i, 1
  %166 = urem i64 20, %165
  %167 = icmp eq i64 %166, 0
  %168 = sub i64 %165, %166
  %169 = select i1 %167, i64 0, i64 %168
  %170 = add i64 %164, 20
  %171 = add i64 %170, %169
  %172 = load ptr, ptr %146, align 8
  %173 = load ptr, ptr %172, align 8
  %174 = getelementptr i8, ptr %173, i64 72
  %175 = load ptr, ptr %174, align 8
  %result.i1.i120.i = call { i64, i64 } %175(ptr nocapture nofree nonnull readonly %172) #5
  %176 = extractvalue { i64, i64 } %result.i1.i120.i, 1
  %177 = urem i64 %171, %176
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %176, %177
  %180 = select i1 %178, i64 0, i64 %179
  %181 = getelementptr i8, ptr %result.i83.i, i64 %171
  %182 = getelementptr i8, ptr %181, i64 %180
  %183 = getelementptr i8, ptr %173, i64 64
  %184 = load ptr, ptr %183, align 8
  call void %184({ ptr, i160 } %75, ptr nocapture nofree nonnull readonly %172, ptr nocapture nofree writeonly %182) #1
  %185 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %186 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %77, ptr %186, align 8
  store ptr @Entry, ptr %85, align 8
  %187 = ptrtoint ptr %result.i83.i to i64
  store i64 %187, ptr %87, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %85, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

188:                                              ; preds = %._crit_edge.i883, %._crit_edge, %90
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %189 = add i32 %77, 2127912214
  %190 = shl i32 %77, 12
  %191 = add i32 %189, %190
  %192 = ashr i32 %191, 19
  %193 = xor i32 %191, %192
  %194 = xor i32 %193, -949894596
  %195 = add i32 %194, 374761393
  %196 = shl i32 %194, 5
  %197 = add i32 %195, %196
  %198 = add i32 %197, -744332180
  %199 = shl i32 %197, 9
  %200 = xor i32 %198, %199
  %201 = add i32 %200, -42973499
  %202 = shl i32 %200, 3
  %203 = add i32 %201, %202
  %204 = ashr i32 %203, 16
  %205 = xor i32 %203, %204
  %206 = xor i32 %205, -1252372727
  %207 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %208 = load i32, ptr %48, align 8
  %209 = add i32 %208, -1
  %210 = and i32 %209, %206
  %211 = load ptr, ptr %50, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %212 = sext i32 %210 to i64
  %213 = shl nsw i64 %212, 5
  %214 = getelementptr i8, ptr %211, i64 %213
  %215 = load ptr, ptr %214, align 8
  %216 = getelementptr i8, ptr %214, i64 8
  %217 = icmp ne ptr %215, @nil_typ
  %218 = icmp ne ptr %215, null
  %.not64.i915 = and i1 %217, %218
  br i1 %.not64.i915, label %219, label %317

219:                                              ; preds = %188
  %220 = load i64, ptr %216, align 4
  %.sroa_idx.i917 = getelementptr i8, ptr %214, i64 16
  %221 = load i64, ptr %.sroa_idx.i917, align 4
  %222 = inttoptr i64 %220 to ptr
  %223 = inttoptr i64 %221 to ptr
  %hash_coef_ptr.i.i66.i918 = getelementptr i8, ptr %215, i64 8
  %tbl_size_ptr.i.i67.i919 = getelementptr i8, ptr %215, i64 16
  %offset_tbl_ptr.i.i68.i920 = getelementptr i8, ptr %215, i64 40
  %hash_coef.i.i69.i921 = load i64, ptr %hash_coef_ptr.i.i66.i918, align 4, !noalias !56
  %tbl_size.i.i70.i922 = load i64, ptr %tbl_size_ptr.i.i67.i919, align 4, !noalias !56
  %offset_tbl.i.i71.i923 = load ptr, ptr %offset_tbl_ptr.i.i68.i920, align 8, !noalias !56
  %product.i.i.i72.i924 = mul i64 %hash_coef.i.i69.i921, 4015701072841558310
  %shifted.i.i.i73.i925 = lshr i64 %product.i.i.i72.i924, 32
  %xored.i.i.i74.i926 = xor i64 %shifted.i.i.i73.i925, %product.i.i.i72.i924
  %hash.i.i.i75.i927 = and i64 %xored.i.i.i74.i926, %tbl_size.i.i70.i922
  %offset_ptr.i.i76.i928 = getelementptr i32, ptr %offset_tbl.i.i71.i923, i64 %hash.i.i.i75.i927
  %offset.i.i77.i929 = load i32, ptr %offset_ptr.i.i76.i928, align 4, !noalias !56
  %224 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %215, 0
  %225 = insertvalue { ptr, ptr, ptr, i32 } %224, ptr %222, 1
  %226 = insertvalue { ptr, ptr, ptr, i32 } %225, ptr %223, 2
  %227 = insertvalue { ptr, ptr, ptr, i32 } %226, i32 %offset.i.i77.i929, 3
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %215) #35
  %230 = sext i32 %offset.i.i77.i929 to i64
  %231 = getelementptr ptr, ptr %215, i64 %230
  %232 = getelementptr i8, ptr %231, i64 64
  %233 = load ptr, ptr %232, align 8
  %result.i.i930 = call ptr %233({ ptr, ptr, ptr, i32 } %227, ptr nocapture nofree noundef nonnull readonly %2) #16
  %234 = call i32 %result.i.i930({ ptr, ptr, ptr, i32 } %227, { ptr, ptr, ptr, i32 } %227, ptr nonnull align 8 %2) #7
  %235 = icmp eq i32 %234, %77
  br i1 %235, label %._crit_edge.i931, label %317

._crit_edge.i931:                                 ; preds = %219
  %236 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %237 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %215)
  %238 = getelementptr i8, ptr %231, i64 48
  %239 = load ptr, ptr %238, align 8
  %result.i79.i932 = call ptr %239({ ptr, ptr, ptr, i32 } %227, ptr nocapture nofree noundef nonnull readonly %2) #16
  %240 = call { ptr, i160 } %result.i79.i932({ ptr, ptr, ptr, i32 } %227, { ptr, ptr, ptr, i32 } %227, ptr nonnull align 8 %2) #7
  %241 = load ptr, ptr %47, align 8
  %242 = call i1 %241({ ptr, i160 } %240, { ptr, i160 } %70) #7
  br i1 %242, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit944, label %317

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit944: ; preds = %._crit_edge.i931
  %243 = load ptr, ptr %result.i311, align 8
  %244 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %245 = load ptr, ptr %41, align 8
  %246 = load ptr, ptr %243, align 8, !alias.scope !59
  %247 = getelementptr i8, ptr %246, i64 72
  %248 = load ptr, ptr %247, align 8, !alias.scope !59
  %result.i.i.i936 = call { i64, i64 } %248(ptr nocapture nofree nonnull readonly %243) #5, !alias.scope !59
  %249 = extractvalue { i64, i64 } %result.i.i.i936, 0
  %250 = extractvalue { i64, i64 } %result.i.i.i936, 1
  %251 = urem i64 20, %250
  %252 = icmp eq i64 %251, 0
  %253 = sub i64 %250, %251
  %254 = select i1 %252, i64 0, i64 %253
  %255 = add i64 %249, 20
  %256 = add i64 %255, %254
  %257 = load ptr, ptr %245, align 8, !alias.scope !59
  %258 = getelementptr i8, ptr %257, i64 72
  %259 = load ptr, ptr %258, align 8, !alias.scope !59
  %result.i1.i.i937 = call { i64, i64 } %259(ptr nocapture nofree nonnull readonly %245) #5, !alias.scope !59
  %260 = extractvalue { i64, i64 } %result.i1.i.i937, 0
  %261 = extractvalue { i64, i64 } %result.i1.i.i937, 1
  %262 = call i64 @llvm.umax.i64(i64 %250, i64 %261)
  %263 = call i64 @llvm.umax.i64(i64 %262, i64 8)
  %264 = urem i64 %256, %261
  %265 = icmp eq i64 %264, 0
  %266 = sub i64 %261, %264
  %267 = select i1 %265, i64 0, i64 %266
  %268 = add i64 %260, %256
  %269 = add i64 %268, %267
  %270 = urem i64 %269, %263
  %271 = icmp eq i64 %270, 0
  %272 = sub i64 %263, %270
  %273 = select i1 %271, i64 0, i64 %272
  %274 = add i64 %273, %269
  %result.i83.i938 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %274, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %243, ptr %result.i83.i938, align 8
  %275 = getelementptr inbounds i8, ptr %result.i83.i938, i64 8
  store ptr %245, ptr %275, align 8
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i938)
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %278 = load ptr, ptr %243, align 8
  %279 = getelementptr i8, ptr %278, i64 72
  %280 = load ptr, ptr %279, align 8
  %result.i.i118.i939 = call { i64, i64 } %280(ptr nocapture nofree nonnull readonly %243) #5
  %281 = extractvalue { i64, i64 } %result.i.i118.i939, 1
  %282 = urem i64 20, %281
  %283 = icmp eq i64 %282, 0
  %reass.sub3124 = sub i64 %281, %282
  %284 = add i64 %reass.sub3124, 20
  %285 = select i1 %283, i64 20, i64 %284
  %286 = getelementptr i8, ptr %result.i83.i938, i64 %285
  %287 = getelementptr i8, ptr %278, i64 64
  %288 = load ptr, ptr %287, align 8
  call void %288({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %243, ptr nocapture nofree writeonly %286) #1
  %289 = load ptr, ptr %result.i83.i938, align 8
  %290 = load ptr, ptr %289, align 8
  %291 = getelementptr i8, ptr %290, i64 72
  %292 = load ptr, ptr %291, align 8
  %result.i.i119.i941 = call { i64, i64 } %292(ptr nocapture nofree nonnull readonly %289) #5
  %293 = extractvalue { i64, i64 } %result.i.i119.i941, 0
  %294 = extractvalue { i64, i64 } %result.i.i119.i941, 1
  %295 = urem i64 20, %294
  %296 = icmp eq i64 %295, 0
  %297 = sub i64 %294, %295
  %298 = select i1 %296, i64 0, i64 %297
  %299 = add i64 %293, 20
  %300 = add i64 %299, %298
  %301 = load ptr, ptr %275, align 8
  %302 = load ptr, ptr %301, align 8
  %303 = getelementptr i8, ptr %302, i64 72
  %304 = load ptr, ptr %303, align 8
  %result.i1.i120.i942 = call { i64, i64 } %304(ptr nocapture nofree nonnull readonly %301) #5
  %305 = extractvalue { i64, i64 } %result.i1.i120.i942, 1
  %306 = urem i64 %300, %305
  %307 = icmp eq i64 %306, 0
  %308 = sub i64 %305, %306
  %309 = select i1 %307, i64 0, i64 %308
  %310 = getelementptr i8, ptr %result.i83.i938, i64 %300
  %311 = getelementptr i8, ptr %310, i64 %309
  %312 = getelementptr i8, ptr %302, i64 64
  %313 = load ptr, ptr %312, align 8
  call void %313({ ptr, i160 } %75, ptr nocapture nofree nonnull readonly %301, ptr nocapture nofree writeonly %311) #1
  %314 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %315 = getelementptr inbounds i8, ptr %result.i83.i938, i64 16
  store i32 %77, ptr %315, align 8
  store ptr @Entry, ptr %214, align 8
  %316 = ptrtoint ptr %result.i83.i938 to i64
  store i64 %316, ptr %216, align 4
  %.sroa_idx28.i943 = getelementptr i8, ptr %214, i64 24
  store i32 10, ptr %.sroa_idx28.i943, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

317:                                              ; preds = %._crit_edge.i931, %188, %219
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %318 = load i32, ptr %62, align 4
  %319 = load i32, ptr %48, align 8
  %.not.i = icmp slt i32 %318, %319
  br i1 %.not.i, label %._crit_edge.i, label %320

320:                                              ; preds = %317
  %321 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %322 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %323 = load ptr, ptr %49, align 8
  %324 = load ptr, ptr %50, align 8
  %325 = shl i32 %319, 1
  %spec.select.i959 = call i32 @llvm.smax.i32(i32 %325, i32 16)
  store i32 %spec.select.i959, ptr %48, align 8
  %326 = zext nneg i32 %spec.select.i959 to i64
  %327 = shl nuw nsw i64 %326, 5
  %result.i.i960 = call noalias ptr @bump_malloc_inner(i64 noundef %327, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i960, ptr %49, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %327, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i, ptr %50, align 8
  store i32 0, ptr %62, align 4
  %328 = icmp sgt i32 %319, 0
  br i1 %328, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %320, %._crit_edge.i1717
  %.060.i = phi i32 [ %347, %._crit_edge.i1717 ], [ 0, %320 ]
  %329 = zext nneg i32 %.060.i to i64
  %330 = shl nuw nsw i64 %329, 5
  %331 = getelementptr i8, ptr %323, i64 %330
  %332 = load ptr, ptr %331, align 8
  %333 = icmp ne ptr %332, @nil_typ
  %334 = icmp ne ptr %332, null
  %.not16.i = and i1 %333, %334
  br i1 %.not16.i, label %335, label %._crit_edge.i1717

335:                                              ; preds = %.lr.ph.i
  %336 = getelementptr i8, ptr %331, i64 8
  %337 = load i64, ptr %336, align 4
  %.sroa_idx.i1718 = getelementptr i8, ptr %331, i64 16
  %338 = load i64, ptr %.sroa_idx.i1718, align 4
  %339 = inttoptr i64 %337 to ptr
  %340 = inttoptr i64 %338 to ptr
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %332, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %332, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %332, i64 40
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i43.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !62
  %341 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %332, 0
  %342 = insertvalue { ptr, ptr, ptr, i32 } %341, ptr %339, 1
  %343 = insertvalue { ptr, ptr, ptr, i32 } %342, ptr %340, 2
  %344 = insertvalue { ptr, ptr, ptr, i32 } %343, i32 %offset.i.i43.i, 3
  %345 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %346 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %65, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %344) #7
  br label %._crit_edge.i1717

._crit_edge.i1717:                                ; preds = %335, %.lr.ph.i
  %347 = add nuw nsw i32 %.060.i, 1
  %348 = icmp slt i32 %347, %319
  br i1 %348, label %.lr.ph.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i1717, %._crit_edge.i1736
  %.060.i1734 = phi i32 [ %367, %._crit_edge.i1736 ], [ 0, %._crit_edge.i1717 ]
  %349 = zext nneg i32 %.060.i1734 to i64
  %350 = shl nuw nsw i64 %349, 5
  %351 = getelementptr i8, ptr %324, i64 %350
  %352 = load ptr, ptr %351, align 8
  %353 = icmp ne ptr %352, @nil_typ
  %354 = icmp ne ptr %352, null
  %.not16.i1735 = and i1 %353, %354
  br i1 %.not16.i1735, label %355, label %._crit_edge.i1736

355:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %356 = getelementptr i8, ptr %351, i64 8
  %357 = load i64, ptr %356, align 4
  %.sroa_idx.i1737 = getelementptr i8, ptr %351, i64 16
  %358 = load i64, ptr %.sroa_idx.i1737, align 4
  %359 = inttoptr i64 %357 to ptr
  %360 = inttoptr i64 %358 to ptr
  %hash_coef_ptr.i.i18.i1738 = getelementptr i8, ptr %352, i64 8
  %tbl_size_ptr.i.i19.i1739 = getelementptr i8, ptr %352, i64 16
  %offset_tbl_ptr.i.i20.i1740 = getelementptr i8, ptr %352, i64 40
  %hash_coef.i.i21.i1741 = load i64, ptr %hash_coef_ptr.i.i18.i1738, align 4, !noalias !22
  %tbl_size.i.i22.i1742 = load i64, ptr %tbl_size_ptr.i.i19.i1739, align 4, !noalias !22
  %offset_tbl.i.i23.i1743 = load ptr, ptr %offset_tbl_ptr.i.i20.i1740, align 8, !noalias !22
  %product.i.i.i24.i1744 = mul i64 %hash_coef.i.i21.i1741, 4015701072841558310
  %shifted.i.i.i25.i1745 = lshr i64 %product.i.i.i24.i1744, 32
  %xored.i.i.i26.i1746 = xor i64 %shifted.i.i.i25.i1745, %product.i.i.i24.i1744
  %hash.i.i.i27.i1747 = and i64 %xored.i.i.i26.i1746, %tbl_size.i.i22.i1742
  %offset_ptr.i.i28.i1748 = getelementptr i32, ptr %offset_tbl.i.i23.i1743, i64 %hash.i.i.i27.i1747
  %offset.i.i43.i1749 = load i32, ptr %offset_ptr.i.i28.i1748, align 4, !noalias !65
  %361 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %352, 0
  %362 = insertvalue { ptr, ptr, ptr, i32 } %361, ptr %359, 1
  %363 = insertvalue { ptr, ptr, ptr, i32 } %362, ptr %360, 2
  %364 = insertvalue { ptr, ptr, ptr, i32 } %363, i32 %offset.i.i43.i1749, 3
  %365 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %366 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %65, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %364) #7
  br label %._crit_edge.i1736

._crit_edge.i1736:                                ; preds = %355, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %367 = add nuw nsw i32 %.060.i1734, 1
  %368 = icmp slt i32 %367, %319
  br i1 %368, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i1736, %320, %317
  %369 = load ptr, ptr %result.i311, align 8
  %370 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %371 = load ptr, ptr %41, align 8
  %372 = load ptr, ptr %369, align 8
  %373 = getelementptr i8, ptr %372, i64 72
  %374 = load ptr, ptr %373, align 8
  %result.i.i.i = call { i64, i64 } %374(ptr nocapture nofree nonnull readonly %369) #5
  %375 = extractvalue { i64, i64 } %result.i.i.i, 0
  %376 = extractvalue { i64, i64 } %result.i.i.i, 1
  %377 = urem i64 20, %376
  %378 = icmp eq i64 %377, 0
  %379 = sub i64 %376, %377
  %380 = select i1 %378, i64 0, i64 %379
  %381 = add i64 %375, 20
  %382 = add i64 %381, %380
  %383 = load ptr, ptr %371, align 8
  %384 = getelementptr i8, ptr %383, i64 72
  %385 = load ptr, ptr %384, align 8
  %result.i1.i.i = call { i64, i64 } %385(ptr nocapture nofree nonnull readonly %371) #5
  %386 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %387 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %388 = call i64 @llvm.umax.i64(i64 %376, i64 %387)
  %389 = call i64 @llvm.umax.i64(i64 %388, i64 8)
  %390 = urem i64 %382, %387
  %391 = icmp eq i64 %390, 0
  %392 = sub i64 %387, %390
  %393 = select i1 %391, i64 0, i64 %392
  %394 = add i64 %386, %382
  %395 = add i64 %394, %393
  %396 = urem i64 %395, %389
  %397 = icmp eq i64 %396, 0
  %398 = sub i64 %389, %396
  %399 = select i1 %397, i64 0, i64 %398
  %400 = add i64 %399, %395
  %result.i90.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %400, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %369, ptr %result.i90.i, align 8
  %401 = getelementptr inbounds i8, ptr %result.i90.i, i64 8
  store ptr %371, ptr %401, align 8
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i)
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %404 = load ptr, ptr %369, align 8
  %405 = getelementptr i8, ptr %404, i64 72
  %406 = load ptr, ptr %405, align 8
  %result.i.i196.i = call { i64, i64 } %406(ptr nocapture nofree nonnull readonly %369) #5
  %407 = extractvalue { i64, i64 } %result.i.i196.i, 1
  %408 = urem i64 20, %407
  %409 = icmp eq i64 %408, 0
  %reass.sub3123 = sub i64 %407, %408
  %410 = add i64 %reass.sub3123, 20
  %411 = select i1 %409, i64 20, i64 %410
  %412 = getelementptr i8, ptr %result.i90.i, i64 %411
  %413 = getelementptr i8, ptr %404, i64 64
  %414 = load ptr, ptr %413, align 8
  call void %414({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %369, ptr nocapture nofree writeonly %412) #1
  %415 = load ptr, ptr %result.i90.i, align 8
  %416 = load ptr, ptr %415, align 8
  %417 = getelementptr i8, ptr %416, i64 72
  %418 = load ptr, ptr %417, align 8
  %result.i.i197.i = call { i64, i64 } %418(ptr nocapture nofree nonnull readonly %415) #5
  %419 = extractvalue { i64, i64 } %result.i.i197.i, 0
  %420 = extractvalue { i64, i64 } %result.i.i197.i, 1
  %421 = urem i64 20, %420
  %422 = icmp eq i64 %421, 0
  %423 = sub i64 %420, %421
  %424 = select i1 %422, i64 0, i64 %423
  %425 = add i64 %419, 20
  %426 = add i64 %425, %424
  %427 = load ptr, ptr %401, align 8
  %428 = load ptr, ptr %427, align 8
  %429 = getelementptr i8, ptr %428, i64 72
  %430 = load ptr, ptr %429, align 8
  %result.i1.i198.i = call { i64, i64 } %430(ptr nocapture nofree nonnull readonly %427) #5
  %431 = extractvalue { i64, i64 } %result.i1.i198.i, 1
  %432 = urem i64 %426, %431
  %433 = icmp eq i64 %432, 0
  %434 = sub i64 %431, %432
  %435 = select i1 %433, i64 0, i64 %434
  %436 = getelementptr i8, ptr %result.i90.i, i64 %426
  %437 = getelementptr i8, ptr %436, i64 %435
  %438 = getelementptr i8, ptr %428, i64 64
  %439 = load ptr, ptr %438, align 8
  call void %439({ ptr, i160 } %75, ptr nocapture nofree nonnull readonly %427, ptr nocapture nofree writeonly %437) #1
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %441 = getelementptr inbounds i8, ptr %result.i90.i, i64 16
  store i32 %77, ptr %441, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %26)
  %442 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %443 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %444 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %445

445:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %446, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %512, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i90.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i977, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %446 = add nuw nsw i32 %.0566.i, 1
  %447 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %448 = insertvalue { ptr, ptr, ptr, i32 } %447, ptr %.sroa.6.0563.i, 1
  %449 = insertvalue { ptr, ptr, ptr, i32 } %448, ptr %.sroa.12.0562.i, 2
  %450 = insertvalue { ptr, ptr, ptr, i32 } %449, i32 %.sroa.17.0561.i, 3
  %451 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %452 = sext i32 %.sroa.17.0561.i to i64
  %453 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %452
  %454 = getelementptr i8, ptr %453, i64 64
  %455 = load ptr, ptr %454, align 8
  %result.i125.i975 = call ptr %455({ ptr, ptr, ptr, i32 } %450, ptr nocapture nofree noundef nonnull readonly %2) #16
  %456 = call i32 %result.i125.i975({ ptr, ptr, ptr, i32 } %450, { ptr, ptr, ptr, i32 } %450, ptr nonnull align 8 %2) #7
  %457 = ptrtoint ptr %.sroa.6.0563.i to i64
  %458 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %459, label %475

459:                                              ; preds = %445
  %460 = load i32, ptr %48, align 8
  %461 = add i32 %460, -1
  %462 = and i32 %461, %456
  %463 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %464 = load ptr, ptr %49, align 8
  %465 = sext i32 %462 to i64
  %466 = shl nsw i64 %465, 5
  %467 = getelementptr i8, ptr %464, i64 %466
  %468 = load ptr, ptr %467, align 8
  %469 = getelementptr i8, ptr %467, i64 8
  %470 = load i160, ptr %469, align 4
  store ptr %.sroa.0.0564.i, ptr %467, align 8
  store i64 %457, ptr %469, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %467, i64 16
  store i64 %458, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %467, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %471 = icmp ne ptr %468, @nil_typ
  %472 = icmp ne ptr %468, null
  %.not92.i = and i1 %471, %472
  %extract.i = lshr i160 %470, 64
  %473 = insertelement <2 x i160> poison, i160 %470, i64 0
  %474 = insertelement <2 x i160> %473, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

475:                                              ; preds = %445
  %476 = add i32 %456, 2127912214
  %477 = shl i32 %456, 12
  %478 = add i32 %476, %477
  %479 = ashr i32 %478, 19
  %480 = xor i32 %478, %479
  %481 = xor i32 %480, -949894596
  %482 = add i32 %481, 374761393
  %483 = shl i32 %481, 5
  %484 = add i32 %482, %483
  %485 = add i32 %484, -744332180
  %486 = shl i32 %484, 9
  %487 = xor i32 %485, %486
  %488 = add i32 %487, -42973499
  %489 = shl i32 %487, 3
  %490 = add i32 %488, %489
  %491 = ashr i32 %490, 16
  %492 = xor i32 %490, %491
  %493 = xor i32 %492, -1252372727
  %494 = load i32, ptr %48, align 8
  %495 = add i32 %494, -1
  %496 = and i32 %495, %493
  %497 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %498 = load ptr, ptr %50, align 8
  %499 = sext i32 %496 to i64
  %500 = shl nsw i64 %499, 5
  %501 = getelementptr i8, ptr %498, i64 %500
  %502 = load ptr, ptr %501, align 8
  %503 = getelementptr i8, ptr %501, i64 8
  %504 = load i160, ptr %503, align 4
  store ptr %.sroa.0.0564.i, ptr %501, align 8
  store i64 %457, ptr %503, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %501, i64 16
  store i64 %458, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %501, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %505 = icmp ne ptr %502, @nil_typ
  %506 = icmp ne ptr %502, null
  %.not90.i = and i1 %505, %506
  %extract607.i = lshr i160 %504, 64
  %507 = insertelement <2 x i160> poison, i160 %504, i64 0
  %508 = insertelement <2 x i160> %507, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %475, %459
  %vptr.i142.sroa.speculated.i = phi ptr [ %468, %459 ], [ %502, %475 ]
  %.in = phi <2 x i160> [ %474, %459 ], [ %508, %475 ]
  %509 = trunc <2 x i160> %.in to <2 x i64>
  %510 = extractelement <2 x i64> %509, i64 1
  %spec.select.i977 = inttoptr i64 %510 to ptr
  %511 = extractelement <2 x i64> %509, i64 0
  %spec.select539.i = inttoptr i64 %511 to ptr
  %512 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %513 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %515 = icmp ult i32 %.0566.i, 99
  br i1 %515, label %445, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %459, %475
  %516 = phi ptr [ %26, %475 ], [ %25, %459 ]
  %517 = load i32, ptr %62, align 4
  store i32 %517, ptr %516, align 4
  %518 = add i32 %517, 1
  %519 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %518, ptr %62, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  %520 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %520, label %CuckooMap_insert_keyK_valueV.exit, label %521

521:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %522 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %523 = load ptr, ptr %49, align 8
  %524 = load ptr, ptr %50, align 8
  %525 = load i32, ptr %48, align 8
  %526 = shl i32 %525, 1
  %spec.select.i994 = call i32 @llvm.smax.i32(i32 %526, i32 16)
  store i32 %spec.select.i994, ptr %48, align 8
  %527 = zext nneg i32 %spec.select.i994 to i64
  %528 = shl nuw nsw i64 %527, 5
  %result.i.i995 = call noalias ptr @bump_malloc_inner(i64 noundef %528, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i995, ptr %49, align 8
  %result.i20.i996 = call noalias ptr @bump_malloc_inner(i64 noundef %528, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i996, ptr %50, align 8
  store i32 0, ptr %62, align 4
  %529 = icmp sgt i32 %525, 0
  br i1 %529, label %.lr.ph.i1783, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852

.lr.ph.i1783:                                     ; preds = %521, %._crit_edge.i1798
  %.060.i1796 = phi i32 [ %618, %._crit_edge.i1798 ], [ 0, %521 ]
  %530 = zext nneg i32 %.060.i1796 to i64
  %531 = shl nuw nsw i64 %530, 5
  %532 = getelementptr i8, ptr %523, i64 %531
  %533 = load ptr, ptr %532, align 8
  %534 = icmp ne ptr %533, @nil_typ
  %535 = icmp ne ptr %533, null
  %.not16.i1797 = and i1 %534, %535
  br i1 %.not16.i1797, label %536, label %._crit_edge.i1798

536:                                              ; preds = %.lr.ph.i1783
  %537 = getelementptr i8, ptr %532, i64 8
  %538 = load <2 x i64>, ptr %537, align 4
  %hash_coef_ptr.i.i18.i1800 = getelementptr i8, ptr %533, i64 8
  %tbl_size_ptr.i.i19.i1801 = getelementptr i8, ptr %533, i64 16
  %offset_tbl_ptr.i.i20.i1802 = getelementptr i8, ptr %533, i64 40
  %539 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i1800, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i1801, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i1802, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !68
  %540 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %541 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %542 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %543

543:                                              ; preds = %.cont.cont.i2258, %536
  %.0566.i2246 = phi i32 [ 0, %536 ], [ %547, %.cont.cont.i2258 ]
  %.070565.i2247 = phi i1 [ true, %536 ], [ %609, %.cont.cont.i2258 ]
  %.sroa.0.0564.i2248 = phi ptr [ %533, %536 ], [ %vptr.i142.sroa.speculated.i2261, %.cont.cont.i2258 ]
  %.sroa.17.0561.i2251 = phi i32 [ %offset.i.i121.i, %536 ], [ %offset.i.i154.i2275, %.cont.cont.i2258 ]
  %544 = phi <2 x i64> [ %538, %536 ], [ %608, %.cont.cont.i2258 ]
  %545 = extractelement <2 x i64> %544, i64 1
  %.sroa.12.0562.i2250 = inttoptr i64 %545 to ptr
  %546 = extractelement <2 x i64> %544, i64 0
  %.sroa.6.0563.i2249 = inttoptr i64 %546 to ptr
  %547 = add nuw nsw i32 %.0566.i2246, 1
  %548 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2248, 0
  %549 = insertvalue { ptr, ptr, ptr, i32 } %548, ptr %.sroa.6.0563.i2249, 1
  %550 = insertvalue { ptr, ptr, ptr, i32 } %549, ptr %.sroa.12.0562.i2250, 2
  %551 = insertvalue { ptr, ptr, ptr, i32 } %550, i32 %.sroa.17.0561.i2251, 3
  %552 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2248)
  %553 = sext i32 %.sroa.17.0561.i2251 to i64
  %554 = getelementptr ptr, ptr %.sroa.0.0564.i2248, i64 %553
  %555 = getelementptr i8, ptr %554, i64 64
  %556 = load ptr, ptr %555, align 8
  %result.i125.i = call ptr %556({ ptr, ptr, ptr, i32 } %551, ptr nocapture nofree noundef nonnull readonly %2) #16
  %557 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %551, { ptr, ptr, ptr, i32 } %551, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2247, label %558, label %574

558:                                              ; preds = %543
  %559 = load i32, ptr %48, align 8
  %560 = add i32 %559, -1
  %561 = and i32 %560, %557
  %562 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %563 = load ptr, ptr %49, align 8
  %564 = sext i32 %561 to i64
  %565 = shl nsw i64 %564, 5
  %566 = getelementptr i8, ptr %563, i64 %565
  %567 = load ptr, ptr %566, align 8
  %568 = getelementptr i8, ptr %566, i64 8
  %569 = load i160, ptr %568, align 4
  store ptr %.sroa.0.0564.i2248, ptr %566, align 8
  store i64 %546, ptr %568, align 4
  %.sroa_idx157.i2277 = getelementptr i8, ptr %566, i64 16
  store i64 %545, ptr %.sroa_idx157.i2277, align 4
  %.sroa_idx158.i2278 = getelementptr i8, ptr %566, i64 24
  store i32 %.sroa.17.0561.i2251, ptr %.sroa_idx158.i2278, align 4
  %570 = icmp ne ptr %567, @nil_typ
  %571 = icmp ne ptr %567, null
  %.not92.i2279 = and i1 %570, %571
  %extract.i2281 = lshr i160 %569, 64
  %572 = insertelement <2 x i160> poison, i160 %569, i64 0
  %573 = insertelement <2 x i160> %572, i160 %extract.i2281, i64 1
  br i1 %.not92.i2279, label %.cont.cont.i2258, label %613

574:                                              ; preds = %543
  %575 = add i32 %557, 2127912214
  %576 = shl i32 %557, 12
  %577 = add i32 %575, %576
  %578 = ashr i32 %577, 19
  %579 = xor i32 %577, %578
  %580 = xor i32 %579, -949894596
  %581 = add i32 %580, 374761393
  %582 = shl i32 %580, 5
  %583 = add i32 %581, %582
  %584 = add i32 %583, -744332180
  %585 = shl i32 %583, 9
  %586 = xor i32 %584, %585
  %587 = add i32 %586, -42973499
  %588 = shl i32 %586, 3
  %589 = add i32 %587, %588
  %590 = ashr i32 %589, 16
  %591 = xor i32 %589, %590
  %592 = xor i32 %591, -1252372727
  %593 = load i32, ptr %48, align 8
  %594 = add i32 %593, -1
  %595 = and i32 %594, %592
  %596 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %597 = load ptr, ptr %50, align 8
  %598 = sext i32 %595 to i64
  %599 = shl nsw i64 %598, 5
  %600 = getelementptr i8, ptr %597, i64 %599
  %601 = load ptr, ptr %600, align 8
  %602 = getelementptr i8, ptr %600, i64 8
  %603 = load i160, ptr %602, align 4
  store ptr %.sroa.0.0564.i2248, ptr %600, align 8
  store i64 %546, ptr %602, align 4
  %.sroa_idx161.i2252 = getelementptr i8, ptr %600, i64 16
  store i64 %545, ptr %.sroa_idx161.i2252, align 4
  %.sroa_idx162.i2253 = getelementptr i8, ptr %600, i64 24
  store i32 %.sroa.17.0561.i2251, ptr %.sroa_idx162.i2253, align 4
  %604 = icmp ne ptr %601, @nil_typ
  %605 = icmp ne ptr %601, null
  %.not90.i2254 = and i1 %604, %605
  %extract607.i2256 = lshr i160 %603, 64
  %606 = insertelement <2 x i160> poison, i160 %603, i64 0
  %607 = insertelement <2 x i160> %606, i160 %extract607.i2256, i64 1
  br i1 %.not90.i2254, label %.cont.cont.i2258, label %613

.cont.cont.i2258:                                 ; preds = %574, %558
  %vptr.i142.sroa.speculated.i2261 = phi ptr [ %567, %558 ], [ %601, %574 ]
  %.in3128 = phi <2 x i160> [ %573, %558 ], [ %607, %574 ]
  %608 = trunc <2 x i160> %.in3128 to <2 x i64>
  %609 = xor i1 %.070565.i2247, true
  %hash_coef_ptr.i.i143.i2264 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2261, i64 8
  %tbl_size_ptr.i.i144.i2265 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2261, i64 16
  %offset_tbl_ptr.i.i145.i2266 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2261, i64 40
  %hash_coef.i.i146.i2267 = load i64, ptr %hash_coef_ptr.i.i143.i2264, align 4
  %tbl_size.i.i147.i2268 = load i64, ptr %tbl_size_ptr.i.i144.i2265, align 4
  %offset_tbl.i.i148.i2269 = load ptr, ptr %offset_tbl_ptr.i.i145.i2266, align 8
  %product.i.i.i149.i2270 = mul i64 %hash_coef.i.i146.i2267, 4015701072841558310
  %shifted.i.i.i150.i2271 = lshr i64 %product.i.i.i149.i2270, 32
  %xored.i.i.i151.i2272 = xor i64 %shifted.i.i.i150.i2271, %product.i.i.i149.i2270
  %hash.i.i.i152.i2273 = and i64 %xored.i.i.i151.i2272, %tbl_size.i.i147.i2268
  %offset_ptr.i.i153.i2274 = getelementptr i32, ptr %offset_tbl.i.i148.i2269, i64 %hash.i.i.i152.i2273
  %offset.i.i154.i2275 = load i32, ptr %offset_ptr.i.i153.i2274, align 4
  %610 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %612 = icmp ult i32 %.0566.i2246, 99
  br i1 %612, label %543, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2283

613:                                              ; preds = %574, %558
  %614 = phi ptr [ %18, %574 ], [ %17, %558 ]
  %615 = load i32, ptr %62, align 4
  store i32 %615, ptr %614, align 4
  %616 = add i32 %615, 1
  %617 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %616, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2283

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2283: ; preds = %.cont.cont.i2258, %613
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i1798

._crit_edge.i1798:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2283, %.lr.ph.i1783
  %618 = add nuw nsw i32 %.060.i1796, 1
  %619 = icmp slt i32 %618, %525
  br i1 %619, label %.lr.ph.i1783, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1816

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1816: ; preds = %._crit_edge.i1798, %._crit_edge.i1834
  %.060.i1832 = phi i32 [ %708, %._crit_edge.i1834 ], [ 0, %._crit_edge.i1798 ]
  %620 = zext nneg i32 %.060.i1832 to i64
  %621 = shl nuw nsw i64 %620, 5
  %622 = getelementptr i8, ptr %524, i64 %621
  %623 = load ptr, ptr %622, align 8
  %624 = icmp ne ptr %623, @nil_typ
  %625 = icmp ne ptr %623, null
  %.not16.i1833 = and i1 %624, %625
  br i1 %.not16.i1833, label %626, label %._crit_edge.i1834

626:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1816
  %627 = getelementptr i8, ptr %622, i64 8
  %628 = load <2 x i64>, ptr %627, align 4
  %hash_coef_ptr.i.i18.i1836 = getelementptr i8, ptr %623, i64 8
  %tbl_size_ptr.i.i19.i1837 = getelementptr i8, ptr %623, i64 16
  %offset_tbl_ptr.i.i20.i1838 = getelementptr i8, ptr %623, i64 40
  %629 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i2301 = load i64, ptr %hash_coef_ptr.i.i18.i1836, align 4, !noalias !22
  %tbl_size.i.i100.i2302 = load i64, ptr %tbl_size_ptr.i.i19.i1837, align 4, !noalias !22
  %offset_tbl.i.i101.i2303 = load ptr, ptr %offset_tbl_ptr.i.i20.i1838, align 8, !noalias !22
  %product.i.i.i102.i2304 = mul i64 %hash_coef.i.i99.i2301, 4015701072841558310
  %shifted.i.i.i103.i2305 = lshr i64 %product.i.i.i102.i2304, 32
  %xored.i.i.i104.i2306 = xor i64 %shifted.i.i.i103.i2305, %product.i.i.i102.i2304
  %hash.i.i.i105.i2307 = and i64 %xored.i.i.i104.i2306, %tbl_size.i.i100.i2302
  %offset_ptr.i.i106.i2308 = getelementptr i32, ptr %offset_tbl.i.i101.i2303, i64 %hash.i.i.i105.i2307
  %offset.i.i121.i2309 = load i32, ptr %offset_ptr.i.i106.i2308, align 4, !noalias !71
  %630 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %631 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %632 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %633

633:                                              ; preds = %.cont.cont.i2330, %626
  %.0566.i2310 = phi i32 [ 0, %626 ], [ %637, %.cont.cont.i2330 ]
  %.070565.i2311 = phi i1 [ true, %626 ], [ %699, %.cont.cont.i2330 ]
  %.sroa.0.0564.i2312 = phi ptr [ %623, %626 ], [ %vptr.i142.sroa.speculated.i2333, %.cont.cont.i2330 ]
  %.sroa.17.0561.i2315 = phi i32 [ %offset.i.i121.i2309, %626 ], [ %offset.i.i154.i2347, %.cont.cont.i2330 ]
  %634 = phi <2 x i64> [ %628, %626 ], [ %698, %.cont.cont.i2330 ]
  %635 = extractelement <2 x i64> %634, i64 1
  %.sroa.12.0562.i2314 = inttoptr i64 %635 to ptr
  %636 = extractelement <2 x i64> %634, i64 0
  %.sroa.6.0563.i2313 = inttoptr i64 %636 to ptr
  %637 = add nuw nsw i32 %.0566.i2310, 1
  %638 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2312, 0
  %639 = insertvalue { ptr, ptr, ptr, i32 } %638, ptr %.sroa.6.0563.i2313, 1
  %640 = insertvalue { ptr, ptr, ptr, i32 } %639, ptr %.sroa.12.0562.i2314, 2
  %641 = insertvalue { ptr, ptr, ptr, i32 } %640, i32 %.sroa.17.0561.i2315, 3
  %642 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2312)
  %643 = sext i32 %.sroa.17.0561.i2315 to i64
  %644 = getelementptr ptr, ptr %.sroa.0.0564.i2312, i64 %643
  %645 = getelementptr i8, ptr %644, i64 64
  %646 = load ptr, ptr %645, align 8
  %result.i125.i2316 = call ptr %646({ ptr, ptr, ptr, i32 } %641, ptr nocapture nofree noundef nonnull readonly %2) #16
  %647 = call i32 %result.i125.i2316({ ptr, ptr, ptr, i32 } %641, { ptr, ptr, ptr, i32 } %641, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2311, label %648, label %664

648:                                              ; preds = %633
  %649 = load i32, ptr %48, align 8
  %650 = add i32 %649, -1
  %651 = and i32 %650, %647
  %652 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %653 = load ptr, ptr %49, align 8
  %654 = sext i32 %651 to i64
  %655 = shl nsw i64 %654, 5
  %656 = getelementptr i8, ptr %653, i64 %655
  %657 = load ptr, ptr %656, align 8
  %658 = getelementptr i8, ptr %656, i64 8
  %659 = load i160, ptr %658, align 4
  store ptr %.sroa.0.0564.i2312, ptr %656, align 8
  store i64 %636, ptr %658, align 4
  %.sroa_idx157.i2359 = getelementptr i8, ptr %656, i64 16
  store i64 %635, ptr %.sroa_idx157.i2359, align 4
  %.sroa_idx158.i2360 = getelementptr i8, ptr %656, i64 24
  store i32 %.sroa.17.0561.i2315, ptr %.sroa_idx158.i2360, align 4
  %660 = icmp ne ptr %657, @nil_typ
  %661 = icmp ne ptr %657, null
  %.not92.i2361 = and i1 %660, %661
  %extract.i2363 = lshr i160 %659, 64
  %662 = insertelement <2 x i160> poison, i160 %659, i64 0
  %663 = insertelement <2 x i160> %662, i160 %extract.i2363, i64 1
  br i1 %.not92.i2361, label %.cont.cont.i2330, label %703

664:                                              ; preds = %633
  %665 = add i32 %647, 2127912214
  %666 = shl i32 %647, 12
  %667 = add i32 %665, %666
  %668 = ashr i32 %667, 19
  %669 = xor i32 %667, %668
  %670 = xor i32 %669, -949894596
  %671 = add i32 %670, 374761393
  %672 = shl i32 %670, 5
  %673 = add i32 %671, %672
  %674 = add i32 %673, -744332180
  %675 = shl i32 %673, 9
  %676 = xor i32 %674, %675
  %677 = add i32 %676, -42973499
  %678 = shl i32 %676, 3
  %679 = add i32 %677, %678
  %680 = ashr i32 %679, 16
  %681 = xor i32 %679, %680
  %682 = xor i32 %681, -1252372727
  %683 = load i32, ptr %48, align 8
  %684 = add i32 %683, -1
  %685 = and i32 %684, %682
  %686 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %687 = load ptr, ptr %50, align 8
  %688 = sext i32 %685 to i64
  %689 = shl nsw i64 %688, 5
  %690 = getelementptr i8, ptr %687, i64 %689
  %691 = load ptr, ptr %690, align 8
  %692 = getelementptr i8, ptr %690, i64 8
  %693 = load i160, ptr %692, align 4
  store ptr %.sroa.0.0564.i2312, ptr %690, align 8
  store i64 %636, ptr %692, align 4
  %.sroa_idx161.i2320 = getelementptr i8, ptr %690, i64 16
  store i64 %635, ptr %.sroa_idx161.i2320, align 4
  %.sroa_idx162.i2321 = getelementptr i8, ptr %690, i64 24
  store i32 %.sroa.17.0561.i2315, ptr %.sroa_idx162.i2321, align 4
  %694 = icmp ne ptr %691, @nil_typ
  %695 = icmp ne ptr %691, null
  %.not90.i2322 = and i1 %694, %695
  %extract607.i2324 = lshr i160 %693, 64
  %696 = insertelement <2 x i160> poison, i160 %693, i64 0
  %697 = insertelement <2 x i160> %696, i160 %extract607.i2324, i64 1
  br i1 %.not90.i2322, label %.cont.cont.i2330, label %703

.cont.cont.i2330:                                 ; preds = %664, %648
  %vptr.i142.sroa.speculated.i2333 = phi ptr [ %657, %648 ], [ %691, %664 ]
  %.in3129 = phi <2 x i160> [ %663, %648 ], [ %697, %664 ]
  %698 = trunc <2 x i160> %.in3129 to <2 x i64>
  %699 = xor i1 %.070565.i2311, true
  %hash_coef_ptr.i.i143.i2336 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2333, i64 8
  %tbl_size_ptr.i.i144.i2337 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2333, i64 16
  %offset_tbl_ptr.i.i145.i2338 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2333, i64 40
  %hash_coef.i.i146.i2339 = load i64, ptr %hash_coef_ptr.i.i143.i2336, align 4
  %tbl_size.i.i147.i2340 = load i64, ptr %tbl_size_ptr.i.i144.i2337, align 4
  %offset_tbl.i.i148.i2341 = load ptr, ptr %offset_tbl_ptr.i.i145.i2338, align 8
  %product.i.i.i149.i2342 = mul i64 %hash_coef.i.i146.i2339, 4015701072841558310
  %shifted.i.i.i150.i2343 = lshr i64 %product.i.i.i149.i2342, 32
  %xored.i.i.i151.i2344 = xor i64 %shifted.i.i.i150.i2343, %product.i.i.i149.i2342
  %hash.i.i.i152.i2345 = and i64 %xored.i.i.i151.i2344, %tbl_size.i.i147.i2340
  %offset_ptr.i.i153.i2346 = getelementptr i32, ptr %offset_tbl.i.i148.i2341, i64 %hash.i.i.i152.i2345
  %offset.i.i154.i2347 = load i32, ptr %offset_ptr.i.i153.i2346, align 4
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %702 = icmp ult i32 %.0566.i2310, 99
  br i1 %702, label %633, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2365

703:                                              ; preds = %664, %648
  %704 = phi ptr [ %16, %664 ], [ %15, %648 ]
  %705 = load i32, ptr %62, align 4
  store i32 %705, ptr %704, align 4
  %706 = add i32 %705, 1
  %707 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %706, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2365

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2365: ; preds = %.cont.cont.i2330, %703
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i1834

._crit_edge.i1834:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2365, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1816
  %708 = add nuw nsw i32 %.060.i1832, 1
  %709 = icmp slt i32 %708, %525
  br i1 %709, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1816, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852: ; preds = %._crit_edge.i1834, %521
  %710 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %hash_coef.i.i99.i1019 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i1020 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1021 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i1022 = mul i64 %hash_coef.i.i99.i1019, 4015701072841558310
  %shifted.i.i.i103.i1023 = lshr i64 %product.i.i.i102.i1022, 32
  %xored.i.i.i104.i1024 = xor i64 %shifted.i.i.i103.i1023, %product.i.i.i102.i1022
  %hash.i.i.i105.i1025 = and i64 %xored.i.i.i104.i1024, %tbl_size.i.i100.i1020
  %offset_ptr.i.i106.i1026 = getelementptr i32, ptr %offset_tbl.i.i101.i1021, i64 %hash.i.i.i105.i1025
  %offset.i.i121.i1027 = load i32, ptr %offset_ptr.i.i106.i1026, align 4, !noalias !74
  %711 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %712 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %713 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %714

714:                                              ; preds = %.cont.cont.i1049, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852
  %.0566.i1029 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852 ], [ %718, %.cont.cont.i1049 ]
  %.070565.i1030 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852 ], [ %780, %.cont.cont.i1049 ]
  %.sroa.0.0564.i1031 = phi ptr [ %vptr.i142.sroa.speculated.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852 ], [ %vptr.i142.sroa.speculated.i1052, %.cont.cont.i1049 ]
  %.sroa.17.0561.i1034 = phi i32 [ %offset.i.i121.i1027, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852 ], [ %offset.i.i154.i1066, %.cont.cont.i1049 ]
  %715 = phi <2 x i64> [ %509, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1852 ], [ %779, %.cont.cont.i1049 ]
  %716 = extractelement <2 x i64> %715, i64 1
  %.sroa.12.0562.i1033 = inttoptr i64 %716 to ptr
  %717 = extractelement <2 x i64> %715, i64 0
  %.sroa.6.0563.i1032 = inttoptr i64 %717 to ptr
  %718 = add nuw nsw i32 %.0566.i1029, 1
  %719 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1031, 0
  %720 = insertvalue { ptr, ptr, ptr, i32 } %719, ptr %.sroa.6.0563.i1032, 1
  %721 = insertvalue { ptr, ptr, ptr, i32 } %720, ptr %.sroa.12.0562.i1033, 2
  %722 = insertvalue { ptr, ptr, ptr, i32 } %721, i32 %.sroa.17.0561.i1034, 3
  %723 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1031)
  %724 = sext i32 %.sroa.17.0561.i1034 to i64
  %725 = getelementptr ptr, ptr %.sroa.0.0564.i1031, i64 %724
  %726 = getelementptr i8, ptr %725, i64 64
  %727 = load ptr, ptr %726, align 8
  %result.i125.i1035 = call ptr %727({ ptr, ptr, ptr, i32 } %722, ptr nocapture nofree noundef nonnull readonly %2) #16
  %728 = call i32 %result.i125.i1035({ ptr, ptr, ptr, i32 } %722, { ptr, ptr, ptr, i32 } %722, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1030, label %729, label %745

729:                                              ; preds = %714
  %730 = load i32, ptr %48, align 8
  %731 = add i32 %730, -1
  %732 = and i32 %731, %728
  %733 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %734 = load ptr, ptr %49, align 8
  %735 = sext i32 %732 to i64
  %736 = shl nsw i64 %735, 5
  %737 = getelementptr i8, ptr %734, i64 %736
  %738 = load ptr, ptr %737, align 8
  %739 = getelementptr i8, ptr %737, i64 8
  %740 = load i160, ptr %739, align 4
  store ptr %.sroa.0.0564.i1031, ptr %737, align 8
  store i64 %717, ptr %739, align 4
  %.sroa_idx157.i1078 = getelementptr i8, ptr %737, i64 16
  store i64 %716, ptr %.sroa_idx157.i1078, align 4
  %.sroa_idx158.i1079 = getelementptr i8, ptr %737, i64 24
  store i32 %.sroa.17.0561.i1034, ptr %.sroa_idx158.i1079, align 4
  %741 = icmp ne ptr %738, @nil_typ
  %742 = icmp ne ptr %738, null
  %.not92.i1080 = and i1 %741, %742
  %extract.i1082 = lshr i160 %740, 64
  %743 = insertelement <2 x i160> poison, i160 %740, i64 0
  %744 = insertelement <2 x i160> %743, i160 %extract.i1082, i64 1
  br i1 %.not92.i1080, label %.cont.cont.i1049, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1084.thread

745:                                              ; preds = %714
  %746 = add i32 %728, 2127912214
  %747 = shl i32 %728, 12
  %748 = add i32 %746, %747
  %749 = ashr i32 %748, 19
  %750 = xor i32 %748, %749
  %751 = xor i32 %750, -949894596
  %752 = add i32 %751, 374761393
  %753 = shl i32 %751, 5
  %754 = add i32 %752, %753
  %755 = add i32 %754, -744332180
  %756 = shl i32 %754, 9
  %757 = xor i32 %755, %756
  %758 = add i32 %757, -42973499
  %759 = shl i32 %757, 3
  %760 = add i32 %758, %759
  %761 = ashr i32 %760, 16
  %762 = xor i32 %760, %761
  %763 = xor i32 %762, -1252372727
  %764 = load i32, ptr %48, align 8
  %765 = add i32 %764, -1
  %766 = and i32 %765, %763
  %767 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %768 = load ptr, ptr %50, align 8
  %769 = sext i32 %766 to i64
  %770 = shl nsw i64 %769, 5
  %771 = getelementptr i8, ptr %768, i64 %770
  %772 = load ptr, ptr %771, align 8
  %773 = getelementptr i8, ptr %771, i64 8
  %774 = load i160, ptr %773, align 4
  store ptr %.sroa.0.0564.i1031, ptr %771, align 8
  store i64 %717, ptr %773, align 4
  %.sroa_idx161.i1039 = getelementptr i8, ptr %771, i64 16
  store i64 %716, ptr %.sroa_idx161.i1039, align 4
  %.sroa_idx162.i1040 = getelementptr i8, ptr %771, i64 24
  store i32 %.sroa.17.0561.i1034, ptr %.sroa_idx162.i1040, align 4
  %775 = icmp ne ptr %772, @nil_typ
  %776 = icmp ne ptr %772, null
  %.not90.i1041 = and i1 %775, %776
  %extract607.i1043 = lshr i160 %774, 64
  %777 = insertelement <2 x i160> poison, i160 %774, i64 0
  %778 = insertelement <2 x i160> %777, i160 %extract607.i1043, i64 1
  br i1 %.not90.i1041, label %.cont.cont.i1049, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1084.thread

.cont.cont.i1049:                                 ; preds = %745, %729
  %vptr.i142.sroa.speculated.i1052 = phi ptr [ %738, %729 ], [ %772, %745 ]
  %.in3130 = phi <2 x i160> [ %744, %729 ], [ %778, %745 ]
  %779 = trunc <2 x i160> %.in3130 to <2 x i64>
  %780 = xor i1 %.070565.i1030, true
  %hash_coef_ptr.i.i143.i1055 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1052, i64 8
  %tbl_size_ptr.i.i144.i1056 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1052, i64 16
  %offset_tbl_ptr.i.i145.i1057 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1052, i64 40
  %hash_coef.i.i146.i1058 = load i64, ptr %hash_coef_ptr.i.i143.i1055, align 4
  %tbl_size.i.i147.i1059 = load i64, ptr %tbl_size_ptr.i.i144.i1056, align 4
  %offset_tbl.i.i148.i1060 = load ptr, ptr %offset_tbl_ptr.i.i145.i1057, align 8
  %product.i.i.i149.i1061 = mul i64 %hash_coef.i.i146.i1058, 4015701072841558310
  %shifted.i.i.i150.i1062 = lshr i64 %product.i.i.i149.i1061, 32
  %xored.i.i.i151.i1063 = xor i64 %shifted.i.i.i150.i1062, %product.i.i.i149.i1061
  %hash.i.i.i152.i1064 = and i64 %xored.i.i.i151.i1063, %tbl_size.i.i147.i1059
  %offset_ptr.i.i153.i1065 = getelementptr i32, ptr %offset_tbl.i.i148.i1060, i64 %hash.i.i.i152.i1064
  %offset.i.i154.i1066 = load i32, ptr %offset_ptr.i.i153.i1065, align 4
  %781 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %782 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %783 = icmp ult i32 %.0566.i1029, 99
  br i1 %783, label %714, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1084

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1084.thread: ; preds = %729, %745
  %784 = phi ptr [ %24, %745 ], [ %23, %729 ]
  %785 = load i32, ptr %62, align 4
  store i32 %785, ptr %784, align 4
  %786 = add i32 %785, 1
  %787 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %786, ptr %62, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1084: ; preds = %.cont.cont.i1049
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  %788 = icmp eq ptr %vptr.i142.sroa.speculated.i1052, null
  br i1 %788, label %CuckooMap_insert_keyK_valueV.exit, label %789

789:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1084
  %790 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %791 = load ptr, ptr %49, align 8
  %792 = load ptr, ptr %50, align 8
  %793 = load i32, ptr %48, align 8
  %794 = shl i32 %793, 1
  %spec.select.i1100 = call i32 @llvm.smax.i32(i32 %794, i32 16)
  store i32 %spec.select.i1100, ptr %48, align 8
  %795 = zext nneg i32 %spec.select.i1100 to i64
  %796 = shl nuw nsw i64 %795, 5
  %result.i.i1101 = call noalias ptr @bump_malloc_inner(i64 noundef %796, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1101, ptr %49, align 8
  %result.i20.i1102 = call noalias ptr @bump_malloc_inner(i64 noundef %796, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1102, ptr %50, align 8
  store i32 0, ptr %62, align 4
  %797 = icmp sgt i32 %793, 0
  br i1 %797, label %.lr.ph.i1882, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1915.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1915.thread: ; preds = %789
  %798 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i1882:                                     ; preds = %789, %._crit_edge.i1897
  %.060.i1895 = phi i32 [ %887, %._crit_edge.i1897 ], [ 0, %789 ]
  %799 = zext nneg i32 %.060.i1895 to i64
  %800 = shl nuw nsw i64 %799, 5
  %801 = getelementptr i8, ptr %791, i64 %800
  %802 = load ptr, ptr %801, align 8
  %803 = icmp ne ptr %802, @nil_typ
  %804 = icmp ne ptr %802, null
  %.not16.i1896 = and i1 %803, %804
  br i1 %.not16.i1896, label %805, label %._crit_edge.i1897

805:                                              ; preds = %.lr.ph.i1882
  %806 = getelementptr i8, ptr %801, i64 8
  %807 = load <2 x i64>, ptr %806, align 4
  %hash_coef_ptr.i.i18.i1899 = getelementptr i8, ptr %802, i64 8
  %tbl_size_ptr.i.i19.i1900 = getelementptr i8, ptr %802, i64 16
  %offset_tbl_ptr.i.i20.i1901 = getelementptr i8, ptr %802, i64 40
  %808 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i2383 = load i64, ptr %hash_coef_ptr.i.i18.i1899, align 4, !noalias !22
  %tbl_size.i.i100.i2384 = load i64, ptr %tbl_size_ptr.i.i19.i1900, align 4, !noalias !22
  %offset_tbl.i.i101.i2385 = load ptr, ptr %offset_tbl_ptr.i.i20.i1901, align 8, !noalias !22
  %product.i.i.i102.i2386 = mul i64 %hash_coef.i.i99.i2383, 4015701072841558310
  %shifted.i.i.i103.i2387 = lshr i64 %product.i.i.i102.i2386, 32
  %xored.i.i.i104.i2388 = xor i64 %shifted.i.i.i103.i2387, %product.i.i.i102.i2386
  %hash.i.i.i105.i2389 = and i64 %xored.i.i.i104.i2388, %tbl_size.i.i100.i2384
  %offset_ptr.i.i106.i2390 = getelementptr i32, ptr %offset_tbl.i.i101.i2385, i64 %hash.i.i.i105.i2389
  %offset.i.i121.i2391 = load i32, ptr %offset_ptr.i.i106.i2390, align 4, !noalias !77
  %809 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %810 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %811 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %812

812:                                              ; preds = %.cont.cont.i2412, %805
  %.0566.i2392 = phi i32 [ 0, %805 ], [ %816, %.cont.cont.i2412 ]
  %.070565.i2393 = phi i1 [ true, %805 ], [ %878, %.cont.cont.i2412 ]
  %.sroa.0.0564.i2394 = phi ptr [ %802, %805 ], [ %vptr.i142.sroa.speculated.i2415, %.cont.cont.i2412 ]
  %.sroa.17.0561.i2397 = phi i32 [ %offset.i.i121.i2391, %805 ], [ %offset.i.i154.i2429, %.cont.cont.i2412 ]
  %813 = phi <2 x i64> [ %807, %805 ], [ %877, %.cont.cont.i2412 ]
  %814 = extractelement <2 x i64> %813, i64 1
  %.sroa.12.0562.i2396 = inttoptr i64 %814 to ptr
  %815 = extractelement <2 x i64> %813, i64 0
  %.sroa.6.0563.i2395 = inttoptr i64 %815 to ptr
  %816 = add nuw nsw i32 %.0566.i2392, 1
  %817 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2394, 0
  %818 = insertvalue { ptr, ptr, ptr, i32 } %817, ptr %.sroa.6.0563.i2395, 1
  %819 = insertvalue { ptr, ptr, ptr, i32 } %818, ptr %.sroa.12.0562.i2396, 2
  %820 = insertvalue { ptr, ptr, ptr, i32 } %819, i32 %.sroa.17.0561.i2397, 3
  %821 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2394)
  %822 = sext i32 %.sroa.17.0561.i2397 to i64
  %823 = getelementptr ptr, ptr %.sroa.0.0564.i2394, i64 %822
  %824 = getelementptr i8, ptr %823, i64 64
  %825 = load ptr, ptr %824, align 8
  %result.i125.i2398 = call ptr %825({ ptr, ptr, ptr, i32 } %820, ptr nocapture nofree noundef nonnull readonly %2) #16
  %826 = call i32 %result.i125.i2398({ ptr, ptr, ptr, i32 } %820, { ptr, ptr, ptr, i32 } %820, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2393, label %827, label %843

827:                                              ; preds = %812
  %828 = load i32, ptr %48, align 8
  %829 = add i32 %828, -1
  %830 = and i32 %829, %826
  %831 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %832 = load ptr, ptr %49, align 8
  %833 = sext i32 %830 to i64
  %834 = shl nsw i64 %833, 5
  %835 = getelementptr i8, ptr %832, i64 %834
  %836 = load ptr, ptr %835, align 8
  %837 = getelementptr i8, ptr %835, i64 8
  %838 = load i160, ptr %837, align 4
  store ptr %.sroa.0.0564.i2394, ptr %835, align 8
  store i64 %815, ptr %837, align 4
  %.sroa_idx157.i2441 = getelementptr i8, ptr %835, i64 16
  store i64 %814, ptr %.sroa_idx157.i2441, align 4
  %.sroa_idx158.i2442 = getelementptr i8, ptr %835, i64 24
  store i32 %.sroa.17.0561.i2397, ptr %.sroa_idx158.i2442, align 4
  %839 = icmp ne ptr %836, @nil_typ
  %840 = icmp ne ptr %836, null
  %.not92.i2443 = and i1 %839, %840
  %extract.i2445 = lshr i160 %838, 64
  %841 = insertelement <2 x i160> poison, i160 %838, i64 0
  %842 = insertelement <2 x i160> %841, i160 %extract.i2445, i64 1
  br i1 %.not92.i2443, label %.cont.cont.i2412, label %882

843:                                              ; preds = %812
  %844 = add i32 %826, 2127912214
  %845 = shl i32 %826, 12
  %846 = add i32 %844, %845
  %847 = ashr i32 %846, 19
  %848 = xor i32 %846, %847
  %849 = xor i32 %848, -949894596
  %850 = add i32 %849, 374761393
  %851 = shl i32 %849, 5
  %852 = add i32 %850, %851
  %853 = add i32 %852, -744332180
  %854 = shl i32 %852, 9
  %855 = xor i32 %853, %854
  %856 = add i32 %855, -42973499
  %857 = shl i32 %855, 3
  %858 = add i32 %856, %857
  %859 = ashr i32 %858, 16
  %860 = xor i32 %858, %859
  %861 = xor i32 %860, -1252372727
  %862 = load i32, ptr %48, align 8
  %863 = add i32 %862, -1
  %864 = and i32 %863, %861
  %865 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %866 = load ptr, ptr %50, align 8
  %867 = sext i32 %864 to i64
  %868 = shl nsw i64 %867, 5
  %869 = getelementptr i8, ptr %866, i64 %868
  %870 = load ptr, ptr %869, align 8
  %871 = getelementptr i8, ptr %869, i64 8
  %872 = load i160, ptr %871, align 4
  store ptr %.sroa.0.0564.i2394, ptr %869, align 8
  store i64 %815, ptr %871, align 4
  %.sroa_idx161.i2402 = getelementptr i8, ptr %869, i64 16
  store i64 %814, ptr %.sroa_idx161.i2402, align 4
  %.sroa_idx162.i2403 = getelementptr i8, ptr %869, i64 24
  store i32 %.sroa.17.0561.i2397, ptr %.sroa_idx162.i2403, align 4
  %873 = icmp ne ptr %870, @nil_typ
  %874 = icmp ne ptr %870, null
  %.not90.i2404 = and i1 %873, %874
  %extract607.i2406 = lshr i160 %872, 64
  %875 = insertelement <2 x i160> poison, i160 %872, i64 0
  %876 = insertelement <2 x i160> %875, i160 %extract607.i2406, i64 1
  br i1 %.not90.i2404, label %.cont.cont.i2412, label %882

.cont.cont.i2412:                                 ; preds = %843, %827
  %vptr.i142.sroa.speculated.i2415 = phi ptr [ %836, %827 ], [ %870, %843 ]
  %.in3131 = phi <2 x i160> [ %842, %827 ], [ %876, %843 ]
  %877 = trunc <2 x i160> %.in3131 to <2 x i64>
  %878 = xor i1 %.070565.i2393, true
  %hash_coef_ptr.i.i143.i2418 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2415, i64 8
  %tbl_size_ptr.i.i144.i2419 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2415, i64 16
  %offset_tbl_ptr.i.i145.i2420 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2415, i64 40
  %hash_coef.i.i146.i2421 = load i64, ptr %hash_coef_ptr.i.i143.i2418, align 4
  %tbl_size.i.i147.i2422 = load i64, ptr %tbl_size_ptr.i.i144.i2419, align 4
  %offset_tbl.i.i148.i2423 = load ptr, ptr %offset_tbl_ptr.i.i145.i2420, align 8
  %product.i.i.i149.i2424 = mul i64 %hash_coef.i.i146.i2421, 4015701072841558310
  %shifted.i.i.i150.i2425 = lshr i64 %product.i.i.i149.i2424, 32
  %xored.i.i.i151.i2426 = xor i64 %shifted.i.i.i150.i2425, %product.i.i.i149.i2424
  %hash.i.i.i152.i2427 = and i64 %xored.i.i.i151.i2426, %tbl_size.i.i147.i2422
  %offset_ptr.i.i153.i2428 = getelementptr i32, ptr %offset_tbl.i.i148.i2423, i64 %hash.i.i.i152.i2427
  %offset.i.i154.i2429 = load i32, ptr %offset_ptr.i.i153.i2428, align 4
  %879 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %880 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %881 = icmp ult i32 %.0566.i2392, 99
  br i1 %881, label %812, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2447

882:                                              ; preds = %843, %827
  %883 = phi ptr [ %14, %843 ], [ %13, %827 ]
  %884 = load i32, ptr %62, align 4
  store i32 %884, ptr %883, align 4
  %885 = add i32 %884, 1
  %886 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %885, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2447

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2447: ; preds = %.cont.cont.i2412, %882
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i1897

._crit_edge.i1897:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2447, %.lr.ph.i1882
  %887 = add nuw nsw i32 %.060.i1895, 1
  %888 = icmp slt i32 %887, %793
  br i1 %888, label %.lr.ph.i1882, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1915

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1915: ; preds = %._crit_edge.i1897
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %890

890:                                              ; preds = %._crit_edge.i1933, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1915
  %.060.i1931 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1915 ], [ %979, %._crit_edge.i1933 ]
  %891 = zext nneg i32 %.060.i1931 to i64
  %892 = shl nuw nsw i64 %891, 5
  %893 = getelementptr i8, ptr %792, i64 %892
  %894 = load ptr, ptr %893, align 8
  %895 = icmp ne ptr %894, @nil_typ
  %896 = icmp ne ptr %894, null
  %.not16.i1932 = and i1 %895, %896
  br i1 %.not16.i1932, label %897, label %._crit_edge.i1933

897:                                              ; preds = %890
  %898 = getelementptr i8, ptr %893, i64 8
  %899 = load <2 x i64>, ptr %898, align 4
  %hash_coef_ptr.i.i18.i1935 = getelementptr i8, ptr %894, i64 8
  %tbl_size_ptr.i.i19.i1936 = getelementptr i8, ptr %894, i64 16
  %offset_tbl_ptr.i.i20.i1937 = getelementptr i8, ptr %894, i64 40
  %900 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i2465 = load i64, ptr %hash_coef_ptr.i.i18.i1935, align 4, !noalias !22
  %tbl_size.i.i100.i2466 = load i64, ptr %tbl_size_ptr.i.i19.i1936, align 4, !noalias !22
  %offset_tbl.i.i101.i2467 = load ptr, ptr %offset_tbl_ptr.i.i20.i1937, align 8, !noalias !22
  %product.i.i.i102.i2468 = mul i64 %hash_coef.i.i99.i2465, 4015701072841558310
  %shifted.i.i.i103.i2469 = lshr i64 %product.i.i.i102.i2468, 32
  %xored.i.i.i104.i2470 = xor i64 %shifted.i.i.i103.i2469, %product.i.i.i102.i2468
  %hash.i.i.i105.i2471 = and i64 %xored.i.i.i104.i2470, %tbl_size.i.i100.i2466
  %offset_ptr.i.i106.i2472 = getelementptr i32, ptr %offset_tbl.i.i101.i2467, i64 %hash.i.i.i105.i2471
  %offset.i.i121.i2473 = load i32, ptr %offset_ptr.i.i106.i2472, align 4, !noalias !80
  %901 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %902 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %903 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %904

904:                                              ; preds = %.cont.cont.i2494, %897
  %.0566.i2474 = phi i32 [ 0, %897 ], [ %908, %.cont.cont.i2494 ]
  %.070565.i2475 = phi i1 [ true, %897 ], [ %970, %.cont.cont.i2494 ]
  %.sroa.0.0564.i2476 = phi ptr [ %894, %897 ], [ %vptr.i142.sroa.speculated.i2497, %.cont.cont.i2494 ]
  %.sroa.17.0561.i2479 = phi i32 [ %offset.i.i121.i2473, %897 ], [ %offset.i.i154.i2511, %.cont.cont.i2494 ]
  %905 = phi <2 x i64> [ %899, %897 ], [ %969, %.cont.cont.i2494 ]
  %906 = extractelement <2 x i64> %905, i64 1
  %.sroa.12.0562.i2478 = inttoptr i64 %906 to ptr
  %907 = extractelement <2 x i64> %905, i64 0
  %.sroa.6.0563.i2477 = inttoptr i64 %907 to ptr
  %908 = add nuw nsw i32 %.0566.i2474, 1
  %909 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2476, 0
  %910 = insertvalue { ptr, ptr, ptr, i32 } %909, ptr %.sroa.6.0563.i2477, 1
  %911 = insertvalue { ptr, ptr, ptr, i32 } %910, ptr %.sroa.12.0562.i2478, 2
  %912 = insertvalue { ptr, ptr, ptr, i32 } %911, i32 %.sroa.17.0561.i2479, 3
  %913 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2476)
  %914 = sext i32 %.sroa.17.0561.i2479 to i64
  %915 = getelementptr ptr, ptr %.sroa.0.0564.i2476, i64 %914
  %916 = getelementptr i8, ptr %915, i64 64
  %917 = load ptr, ptr %916, align 8
  %result.i125.i2480 = call ptr %917({ ptr, ptr, ptr, i32 } %912, ptr nocapture nofree noundef nonnull readonly %2) #16
  %918 = call i32 %result.i125.i2480({ ptr, ptr, ptr, i32 } %912, { ptr, ptr, ptr, i32 } %912, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2475, label %919, label %935

919:                                              ; preds = %904
  %920 = load i32, ptr %48, align 8
  %921 = add i32 %920, -1
  %922 = and i32 %921, %918
  %923 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %924 = load ptr, ptr %49, align 8
  %925 = sext i32 %922 to i64
  %926 = shl nsw i64 %925, 5
  %927 = getelementptr i8, ptr %924, i64 %926
  %928 = load ptr, ptr %927, align 8
  %929 = getelementptr i8, ptr %927, i64 8
  %930 = load i160, ptr %929, align 4
  store ptr %.sroa.0.0564.i2476, ptr %927, align 8
  store i64 %907, ptr %929, align 4
  %.sroa_idx157.i2523 = getelementptr i8, ptr %927, i64 16
  store i64 %906, ptr %.sroa_idx157.i2523, align 4
  %.sroa_idx158.i2524 = getelementptr i8, ptr %927, i64 24
  store i32 %.sroa.17.0561.i2479, ptr %.sroa_idx158.i2524, align 4
  %931 = icmp ne ptr %928, @nil_typ
  %932 = icmp ne ptr %928, null
  %.not92.i2525 = and i1 %931, %932
  %extract.i2527 = lshr i160 %930, 64
  %933 = insertelement <2 x i160> poison, i160 %930, i64 0
  %934 = insertelement <2 x i160> %933, i160 %extract.i2527, i64 1
  br i1 %.not92.i2525, label %.cont.cont.i2494, label %974

935:                                              ; preds = %904
  %936 = add i32 %918, 2127912214
  %937 = shl i32 %918, 12
  %938 = add i32 %936, %937
  %939 = ashr i32 %938, 19
  %940 = xor i32 %938, %939
  %941 = xor i32 %940, -949894596
  %942 = add i32 %941, 374761393
  %943 = shl i32 %941, 5
  %944 = add i32 %942, %943
  %945 = add i32 %944, -744332180
  %946 = shl i32 %944, 9
  %947 = xor i32 %945, %946
  %948 = add i32 %947, -42973499
  %949 = shl i32 %947, 3
  %950 = add i32 %948, %949
  %951 = ashr i32 %950, 16
  %952 = xor i32 %950, %951
  %953 = xor i32 %952, -1252372727
  %954 = load i32, ptr %48, align 8
  %955 = add i32 %954, -1
  %956 = and i32 %955, %953
  %957 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %958 = load ptr, ptr %50, align 8
  %959 = sext i32 %956 to i64
  %960 = shl nsw i64 %959, 5
  %961 = getelementptr i8, ptr %958, i64 %960
  %962 = load ptr, ptr %961, align 8
  %963 = getelementptr i8, ptr %961, i64 8
  %964 = load i160, ptr %963, align 4
  store ptr %.sroa.0.0564.i2476, ptr %961, align 8
  store i64 %907, ptr %963, align 4
  %.sroa_idx161.i2484 = getelementptr i8, ptr %961, i64 16
  store i64 %906, ptr %.sroa_idx161.i2484, align 4
  %.sroa_idx162.i2485 = getelementptr i8, ptr %961, i64 24
  store i32 %.sroa.17.0561.i2479, ptr %.sroa_idx162.i2485, align 4
  %965 = icmp ne ptr %962, @nil_typ
  %966 = icmp ne ptr %962, null
  %.not90.i2486 = and i1 %965, %966
  %extract607.i2488 = lshr i160 %964, 64
  %967 = insertelement <2 x i160> poison, i160 %964, i64 0
  %968 = insertelement <2 x i160> %967, i160 %extract607.i2488, i64 1
  br i1 %.not90.i2486, label %.cont.cont.i2494, label %974

.cont.cont.i2494:                                 ; preds = %935, %919
  %vptr.i142.sroa.speculated.i2497 = phi ptr [ %928, %919 ], [ %962, %935 ]
  %.in3132 = phi <2 x i160> [ %934, %919 ], [ %968, %935 ]
  %969 = trunc <2 x i160> %.in3132 to <2 x i64>
  %970 = xor i1 %.070565.i2475, true
  %hash_coef_ptr.i.i143.i2500 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2497, i64 8
  %tbl_size_ptr.i.i144.i2501 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2497, i64 16
  %offset_tbl_ptr.i.i145.i2502 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2497, i64 40
  %hash_coef.i.i146.i2503 = load i64, ptr %hash_coef_ptr.i.i143.i2500, align 4
  %tbl_size.i.i147.i2504 = load i64, ptr %tbl_size_ptr.i.i144.i2501, align 4
  %offset_tbl.i.i148.i2505 = load ptr, ptr %offset_tbl_ptr.i.i145.i2502, align 8
  %product.i.i.i149.i2506 = mul i64 %hash_coef.i.i146.i2503, 4015701072841558310
  %shifted.i.i.i150.i2507 = lshr i64 %product.i.i.i149.i2506, 32
  %xored.i.i.i151.i2508 = xor i64 %shifted.i.i.i150.i2507, %product.i.i.i149.i2506
  %hash.i.i.i152.i2509 = and i64 %xored.i.i.i151.i2508, %tbl_size.i.i147.i2504
  %offset_ptr.i.i153.i2510 = getelementptr i32, ptr %offset_tbl.i.i148.i2505, i64 %hash.i.i.i152.i2509
  %offset.i.i154.i2511 = load i32, ptr %offset_ptr.i.i153.i2510, align 4
  %971 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %973 = icmp ult i32 %.0566.i2474, 99
  br i1 %973, label %904, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2529

974:                                              ; preds = %935, %919
  %975 = phi ptr [ %12, %935 ], [ %11, %919 ]
  %976 = load i32, ptr %62, align 4
  store i32 %976, ptr %975, align 4
  %977 = add i32 %976, 1
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %977, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2529

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2529: ; preds = %.cont.cont.i2494, %974
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %._crit_edge.i1933

._crit_edge.i1933:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2529, %890
  %979 = add nuw nsw i32 %.060.i1931, 1
  %980 = icmp slt i32 %979, %793
  br i1 %980, label %890, label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i1933, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1915.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1084.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit944, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1084
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %981 = add nuw nsw i32 %.0247463, 1
  %982 = icmp slt i32 %981, %0
  br i1 %982, label %._crit_edge, label %._crit_edge2._crit_edge

._crit_edge2._crit_edge:                          ; preds = %CuckooMap_insert_keyK_valueV.exit
  %983 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %985 = load i32, ptr %62, align 4
  %986 = call i64 @clock()
  %987 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %988 = getelementptr inbounds i8, ptr %result.i268, i64 44
  %989 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i268, 1
  %990 = insertvalue { ptr, ptr, ptr, i32 } %989, ptr undef, 2
  %991 = insertvalue { ptr, ptr, ptr, i32 } %990, i32 10, 3
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge2._crit_edge, %CuckooMap_insert_keyK_valueV.exit712
  %.2249465 = phi i32 [ %1905, %CuckooMap_insert_keyK_valueV.exit712 ], [ 0, %._crit_edge2._crit_edge ]
  %992 = zext nneg i32 %.2249465 to i64
  %993 = shl nuw nsw i64 %992, 2
  %994 = getelementptr i8, ptr %result.i4.i, i64 %993
  %995 = load i32, ptr %994, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %995 to i160
  %996 = add i32 %995, 1
  %997 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %.sroa.0211.0.insert.ext = zext i32 %996 to i160
  %998 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0211.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %999 = load ptr, ptr %32, align 8
  %1000 = call i32 %999({ ptr, i160 } %997) #7
  %1001 = load i32, ptr %34, align 8
  %1002 = add i32 %1001, -1
  %1003 = and i32 %1002, %1000
  %1004 = load ptr, ptr %35, align 8
  %1005 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1006 = sext i32 %1003 to i64
  %1007 = shl nsw i64 %1006, 5
  %1008 = getelementptr i8, ptr %1004, i64 %1007
  %1009 = load ptr, ptr %1008, align 8
  %1010 = getelementptr i8, ptr %1008, i64 8
  %1011 = icmp ne ptr %1009, @nil_typ
  %1012 = icmp ne ptr %1009, null
  %.not64.i1148 = and i1 %1011, %1012
  br i1 %.not64.i1148, label %1013, label %1111

1013:                                             ; preds = %._crit_edge3
  %1014 = load i64, ptr %1010, align 4
  %.sroa_idx.i1150 = getelementptr i8, ptr %1008, i64 16
  %1015 = load i64, ptr %.sroa_idx.i1150, align 4
  %1016 = inttoptr i64 %1014 to ptr
  %1017 = inttoptr i64 %1015 to ptr
  %hash_coef_ptr.i.i66.i1151 = getelementptr i8, ptr %1009, i64 8
  %tbl_size_ptr.i.i67.i1152 = getelementptr i8, ptr %1009, i64 16
  %offset_tbl_ptr.i.i68.i1153 = getelementptr i8, ptr %1009, i64 40
  %hash_coef.i.i69.i1154 = load i64, ptr %hash_coef_ptr.i.i66.i1151, align 4, !noalias !83
  %tbl_size.i.i70.i1155 = load i64, ptr %tbl_size_ptr.i.i67.i1152, align 4, !noalias !83
  %offset_tbl.i.i71.i1156 = load ptr, ptr %offset_tbl_ptr.i.i68.i1153, align 8, !noalias !83
  %product.i.i.i72.i1157 = mul i64 %hash_coef.i.i69.i1154, 4015701072841558310
  %shifted.i.i.i73.i1158 = lshr i64 %product.i.i.i72.i1157, 32
  %xored.i.i.i74.i1159 = xor i64 %shifted.i.i.i73.i1158, %product.i.i.i72.i1157
  %hash.i.i.i75.i1160 = and i64 %xored.i.i.i74.i1159, %tbl_size.i.i70.i1155
  %offset_ptr.i.i76.i1161 = getelementptr i32, ptr %offset_tbl.i.i71.i1156, i64 %hash.i.i.i75.i1160
  %offset.i.i77.i1162 = load i32, ptr %offset_ptr.i.i76.i1161, align 4, !noalias !83
  %1018 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1009, 0
  %1019 = insertvalue { ptr, ptr, ptr, i32 } %1018, ptr %1016, 1
  %1020 = insertvalue { ptr, ptr, ptr, i32 } %1019, ptr %1017, 2
  %1021 = insertvalue { ptr, ptr, ptr, i32 } %1020, i32 %offset.i.i77.i1162, 3
  %1022 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1023 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1009) #35
  %1024 = sext i32 %offset.i.i77.i1162 to i64
  %1025 = getelementptr ptr, ptr %1009, i64 %1024
  %1026 = getelementptr i8, ptr %1025, i64 64
  %1027 = load ptr, ptr %1026, align 8
  %result.i.i1163 = call ptr %1027({ ptr, ptr, ptr, i32 } %1021, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1028 = call i32 %result.i.i1163({ ptr, ptr, ptr, i32 } %1021, { ptr, ptr, ptr, i32 } %1021, ptr nonnull align 8 %2) #7
  %1029 = icmp eq i32 %1028, %1000
  br i1 %1029, label %._crit_edge.i1164, label %1111

._crit_edge.i1164:                                ; preds = %1013
  %1030 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1031 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1009)
  %1032 = getelementptr i8, ptr %1025, i64 48
  %1033 = load ptr, ptr %1032, align 8
  %result.i79.i1165 = call ptr %1033({ ptr, ptr, ptr, i32 } %1021, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1034 = call { ptr, i160 } %result.i79.i1165({ ptr, ptr, ptr, i32 } %1021, { ptr, ptr, ptr, i32 } %1021, ptr nonnull align 8 %2) #7
  %1035 = load ptr, ptr %33, align 8
  %1036 = call i1 %1035({ ptr, i160 } %1034, { ptr, i160 } %997) #7
  br i1 %1036, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1177, label %1111

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1177: ; preds = %._crit_edge.i1164
  %1037 = load ptr, ptr %result.i268, align 8
  %1038 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1039 = load ptr, ptr %27, align 8
  %1040 = load ptr, ptr %1037, align 8, !alias.scope !86
  %1041 = getelementptr i8, ptr %1040, i64 72
  %1042 = load ptr, ptr %1041, align 8, !alias.scope !86
  %result.i.i.i1169 = call { i64, i64 } %1042(ptr nocapture nofree nonnull readonly %1037) #5, !alias.scope !86
  %1043 = extractvalue { i64, i64 } %result.i.i.i1169, 0
  %1044 = extractvalue { i64, i64 } %result.i.i.i1169, 1
  %1045 = urem i64 20, %1044
  %1046 = icmp eq i64 %1045, 0
  %1047 = sub i64 %1044, %1045
  %1048 = select i1 %1046, i64 0, i64 %1047
  %1049 = add i64 %1043, 20
  %1050 = add i64 %1049, %1048
  %1051 = load ptr, ptr %1039, align 8, !alias.scope !86
  %1052 = getelementptr i8, ptr %1051, i64 72
  %1053 = load ptr, ptr %1052, align 8, !alias.scope !86
  %result.i1.i.i1170 = call { i64, i64 } %1053(ptr nocapture nofree nonnull readonly %1039) #5, !alias.scope !86
  %1054 = extractvalue { i64, i64 } %result.i1.i.i1170, 0
  %1055 = extractvalue { i64, i64 } %result.i1.i.i1170, 1
  %1056 = call i64 @llvm.umax.i64(i64 %1044, i64 %1055)
  %1057 = call i64 @llvm.umax.i64(i64 %1056, i64 8)
  %1058 = urem i64 %1050, %1055
  %1059 = icmp eq i64 %1058, 0
  %1060 = sub i64 %1055, %1058
  %1061 = select i1 %1059, i64 0, i64 %1060
  %1062 = add i64 %1054, %1050
  %1063 = add i64 %1062, %1061
  %1064 = urem i64 %1063, %1057
  %1065 = icmp eq i64 %1064, 0
  %1066 = sub i64 %1057, %1064
  %1067 = select i1 %1065, i64 0, i64 %1066
  %1068 = add i64 %1067, %1063
  %result.i83.i1171 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1068, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1037, ptr %result.i83.i1171, align 8
  %1069 = getelementptr inbounds i8, ptr %result.i83.i1171, i64 8
  store ptr %1039, ptr %1069, align 8
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1171)
  %1071 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1072 = load ptr, ptr %1037, align 8
  %1073 = getelementptr i8, ptr %1072, i64 72
  %1074 = load ptr, ptr %1073, align 8
  %result.i.i118.i1172 = call { i64, i64 } %1074(ptr nocapture nofree nonnull readonly %1037) #5
  %1075 = extractvalue { i64, i64 } %result.i.i118.i1172, 1
  %1076 = urem i64 20, %1075
  %1077 = icmp eq i64 %1076, 0
  %reass.sub = sub i64 %1075, %1076
  %1078 = add i64 %reass.sub, 20
  %1079 = select i1 %1077, i64 20, i64 %1078
  %1080 = getelementptr i8, ptr %result.i83.i1171, i64 %1079
  %1081 = getelementptr i8, ptr %1072, i64 64
  %1082 = load ptr, ptr %1081, align 8
  call void %1082({ ptr, i160 } %997, ptr nocapture nofree nonnull readonly %1037, ptr nocapture nofree writeonly %1080) #1
  %1083 = load ptr, ptr %result.i83.i1171, align 8
  %1084 = load ptr, ptr %1083, align 8
  %1085 = getelementptr i8, ptr %1084, i64 72
  %1086 = load ptr, ptr %1085, align 8
  %result.i.i119.i1174 = call { i64, i64 } %1086(ptr nocapture nofree nonnull readonly %1083) #5
  %1087 = extractvalue { i64, i64 } %result.i.i119.i1174, 0
  %1088 = extractvalue { i64, i64 } %result.i.i119.i1174, 1
  %1089 = urem i64 20, %1088
  %1090 = icmp eq i64 %1089, 0
  %1091 = sub i64 %1088, %1089
  %1092 = select i1 %1090, i64 0, i64 %1091
  %1093 = add i64 %1087, 20
  %1094 = add i64 %1093, %1092
  %1095 = load ptr, ptr %1069, align 8
  %1096 = load ptr, ptr %1095, align 8
  %1097 = getelementptr i8, ptr %1096, i64 72
  %1098 = load ptr, ptr %1097, align 8
  %result.i1.i120.i1175 = call { i64, i64 } %1098(ptr nocapture nofree nonnull readonly %1095) #5
  %1099 = extractvalue { i64, i64 } %result.i1.i120.i1175, 1
  %1100 = urem i64 %1094, %1099
  %1101 = icmp eq i64 %1100, 0
  %1102 = sub i64 %1099, %1100
  %1103 = select i1 %1101, i64 0, i64 %1102
  %1104 = getelementptr i8, ptr %result.i83.i1171, i64 %1094
  %1105 = getelementptr i8, ptr %1104, i64 %1103
  %1106 = getelementptr i8, ptr %1096, i64 64
  %1107 = load ptr, ptr %1106, align 8
  call void %1107({ ptr, i160 } %998, ptr nocapture nofree nonnull readonly %1095, ptr nocapture nofree writeonly %1105) #1
  %1108 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1109 = getelementptr inbounds i8, ptr %result.i83.i1171, i64 16
  store i32 %1000, ptr %1109, align 8
  store ptr @Entry, ptr %1008, align 8
  %1110 = ptrtoint ptr %result.i83.i1171 to i64
  store i64 %1110, ptr %1010, align 4
  %.sroa_idx28.i1176 = getelementptr i8, ptr %1008, i64 24
  store i32 10, ptr %.sroa_idx28.i1176, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit712

1111:                                             ; preds = %._crit_edge.i1164, %._crit_edge3, %1013
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1112 = add i32 %1000, 2127912214
  %1113 = shl i32 %1000, 12
  %1114 = add i32 %1112, %1113
  %1115 = ashr i32 %1114, 19
  %1116 = xor i32 %1114, %1115
  %1117 = xor i32 %1116, -949894596
  %1118 = add i32 %1117, 374761393
  %1119 = shl i32 %1117, 5
  %1120 = add i32 %1118, %1119
  %1121 = add i32 %1120, -744332180
  %1122 = shl i32 %1120, 9
  %1123 = xor i32 %1121, %1122
  %1124 = add i32 %1123, -42973499
  %1125 = shl i32 %1123, 3
  %1126 = add i32 %1124, %1125
  %1127 = ashr i32 %1126, 16
  %1128 = xor i32 %1126, %1127
  %1129 = xor i32 %1128, -1252372727
  %1130 = load i32, ptr %34, align 8
  %1131 = add i32 %1130, -1
  %1132 = and i32 %1131, %1129
  %1133 = load ptr, ptr %36, align 8
  %1134 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1135 = sext i32 %1132 to i64
  %1136 = shl nsw i64 %1135, 5
  %1137 = getelementptr i8, ptr %1133, i64 %1136
  %1138 = load ptr, ptr %1137, align 8
  %1139 = getelementptr i8, ptr %1137, i64 8
  %1140 = icmp ne ptr %1138, @nil_typ
  %1141 = icmp ne ptr %1138, null
  %.not64.i1207 = and i1 %1140, %1141
  br i1 %.not64.i1207, label %1142, label %1241

1142:                                             ; preds = %1111
  %1143 = load i64, ptr %1139, align 4
  %.sroa_idx.i1209 = getelementptr i8, ptr %1137, i64 16
  %1144 = load i64, ptr %.sroa_idx.i1209, align 4
  %1145 = inttoptr i64 %1143 to ptr
  %1146 = inttoptr i64 %1144 to ptr
  %hash_coef_ptr.i.i66.i1210 = getelementptr i8, ptr %1138, i64 8
  %tbl_size_ptr.i.i67.i1211 = getelementptr i8, ptr %1138, i64 16
  %offset_tbl_ptr.i.i68.i1212 = getelementptr i8, ptr %1138, i64 40
  %hash_coef.i.i69.i1213 = load i64, ptr %hash_coef_ptr.i.i66.i1210, align 4, !noalias !89
  %tbl_size.i.i70.i1214 = load i64, ptr %tbl_size_ptr.i.i67.i1211, align 4, !noalias !89
  %offset_tbl.i.i71.i1215 = load ptr, ptr %offset_tbl_ptr.i.i68.i1212, align 8, !noalias !89
  %product.i.i.i72.i1216 = mul i64 %hash_coef.i.i69.i1213, 4015701072841558310
  %shifted.i.i.i73.i1217 = lshr i64 %product.i.i.i72.i1216, 32
  %xored.i.i.i74.i1218 = xor i64 %shifted.i.i.i73.i1217, %product.i.i.i72.i1216
  %hash.i.i.i75.i1219 = and i64 %xored.i.i.i74.i1218, %tbl_size.i.i70.i1214
  %offset_ptr.i.i76.i1220 = getelementptr i32, ptr %offset_tbl.i.i71.i1215, i64 %hash.i.i.i75.i1219
  %offset.i.i77.i1221 = load i32, ptr %offset_ptr.i.i76.i1220, align 4, !noalias !89
  %1147 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1138, 0
  %1148 = insertvalue { ptr, ptr, ptr, i32 } %1147, ptr %1145, 1
  %1149 = insertvalue { ptr, ptr, ptr, i32 } %1148, ptr %1146, 2
  %1150 = insertvalue { ptr, ptr, ptr, i32 } %1149, i32 %offset.i.i77.i1221, 3
  %1151 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1152 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1138) #35
  %1153 = sext i32 %offset.i.i77.i1221 to i64
  %1154 = getelementptr ptr, ptr %1138, i64 %1153
  %1155 = getelementptr i8, ptr %1154, i64 64
  %1156 = load ptr, ptr %1155, align 8
  %result.i.i1222 = call ptr %1156({ ptr, ptr, ptr, i32 } %1150, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1157 = call i32 %result.i.i1222({ ptr, ptr, ptr, i32 } %1150, { ptr, ptr, ptr, i32 } %1150, ptr nonnull align 8 %2) #7
  %1158 = icmp eq i32 %1157, %1000
  br i1 %1158, label %._crit_edge.i1223, label %1241

._crit_edge.i1223:                                ; preds = %1142
  %1159 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1160 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1138)
  %1161 = getelementptr i8, ptr %1154, i64 48
  %1162 = load ptr, ptr %1161, align 8
  %result.i79.i1224 = call ptr %1162({ ptr, ptr, ptr, i32 } %1150, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1163 = call { ptr, i160 } %result.i79.i1224({ ptr, ptr, ptr, i32 } %1150, { ptr, ptr, ptr, i32 } %1150, ptr nonnull align 8 %2) #7
  %1164 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1165 = load ptr, ptr %33, align 8
  %1166 = call i1 %1165({ ptr, i160 } %1163, { ptr, i160 } %997) #7
  br i1 %1166, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1236, label %1241

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1236: ; preds = %._crit_edge.i1223
  %1167 = load ptr, ptr %result.i268, align 8
  %1168 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1169 = load ptr, ptr %27, align 8
  %1170 = load ptr, ptr %1167, align 8, !alias.scope !92
  %1171 = getelementptr i8, ptr %1170, i64 72
  %1172 = load ptr, ptr %1171, align 8, !alias.scope !92
  %result.i.i.i1228 = call { i64, i64 } %1172(ptr nocapture nofree nonnull readonly %1167) #5, !alias.scope !92
  %1173 = extractvalue { i64, i64 } %result.i.i.i1228, 0
  %1174 = extractvalue { i64, i64 } %result.i.i.i1228, 1
  %1175 = urem i64 20, %1174
  %1176 = icmp eq i64 %1175, 0
  %1177 = sub i64 %1174, %1175
  %1178 = select i1 %1176, i64 0, i64 %1177
  %1179 = add i64 %1173, 20
  %1180 = add i64 %1179, %1178
  %1181 = load ptr, ptr %1169, align 8, !alias.scope !92
  %1182 = getelementptr i8, ptr %1181, i64 72
  %1183 = load ptr, ptr %1182, align 8, !alias.scope !92
  %result.i1.i.i1229 = call { i64, i64 } %1183(ptr nocapture nofree nonnull readonly %1169) #5, !alias.scope !92
  %1184 = extractvalue { i64, i64 } %result.i1.i.i1229, 0
  %1185 = extractvalue { i64, i64 } %result.i1.i.i1229, 1
  %1186 = call i64 @llvm.umax.i64(i64 %1174, i64 %1185)
  %1187 = call i64 @llvm.umax.i64(i64 %1186, i64 8)
  %1188 = urem i64 %1180, %1185
  %1189 = icmp eq i64 %1188, 0
  %1190 = sub i64 %1185, %1188
  %1191 = select i1 %1189, i64 0, i64 %1190
  %1192 = add i64 %1184, %1180
  %1193 = add i64 %1192, %1191
  %1194 = urem i64 %1193, %1187
  %1195 = icmp eq i64 %1194, 0
  %1196 = sub i64 %1187, %1194
  %1197 = select i1 %1195, i64 0, i64 %1196
  %1198 = add i64 %1197, %1193
  %result.i83.i1230 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1198, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1167, ptr %result.i83.i1230, align 8
  %1199 = getelementptr inbounds i8, ptr %result.i83.i1230, i64 8
  store ptr %1169, ptr %1199, align 8
  %1200 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1230)
  %1201 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1202 = load ptr, ptr %1167, align 8
  %1203 = getelementptr i8, ptr %1202, i64 72
  %1204 = load ptr, ptr %1203, align 8
  %result.i.i118.i1231 = call { i64, i64 } %1204(ptr nocapture nofree nonnull readonly %1167) #5
  %1205 = extractvalue { i64, i64 } %result.i.i118.i1231, 1
  %1206 = urem i64 20, %1205
  %1207 = icmp eq i64 %1206, 0
  %reass.sub3127 = sub i64 %1205, %1206
  %1208 = add i64 %reass.sub3127, 20
  %1209 = select i1 %1207, i64 20, i64 %1208
  %1210 = getelementptr i8, ptr %result.i83.i1230, i64 %1209
  %1211 = getelementptr i8, ptr %1202, i64 64
  %1212 = load ptr, ptr %1211, align 8
  call void %1212({ ptr, i160 } %997, ptr nocapture nofree nonnull readonly %1167, ptr nocapture nofree writeonly %1210) #1
  %1213 = load ptr, ptr %result.i83.i1230, align 8
  %1214 = load ptr, ptr %1213, align 8
  %1215 = getelementptr i8, ptr %1214, i64 72
  %1216 = load ptr, ptr %1215, align 8
  %result.i.i119.i1233 = call { i64, i64 } %1216(ptr nocapture nofree nonnull readonly %1213) #5
  %1217 = extractvalue { i64, i64 } %result.i.i119.i1233, 0
  %1218 = extractvalue { i64, i64 } %result.i.i119.i1233, 1
  %1219 = urem i64 20, %1218
  %1220 = icmp eq i64 %1219, 0
  %1221 = sub i64 %1218, %1219
  %1222 = select i1 %1220, i64 0, i64 %1221
  %1223 = add i64 %1217, 20
  %1224 = add i64 %1223, %1222
  %1225 = load ptr, ptr %1199, align 8
  %1226 = load ptr, ptr %1225, align 8
  %1227 = getelementptr i8, ptr %1226, i64 72
  %1228 = load ptr, ptr %1227, align 8
  %result.i1.i120.i1234 = call { i64, i64 } %1228(ptr nocapture nofree nonnull readonly %1225) #5
  %1229 = extractvalue { i64, i64 } %result.i1.i120.i1234, 1
  %1230 = urem i64 %1224, %1229
  %1231 = icmp eq i64 %1230, 0
  %1232 = sub i64 %1229, %1230
  %1233 = select i1 %1231, i64 0, i64 %1232
  %1234 = getelementptr i8, ptr %result.i83.i1230, i64 %1224
  %1235 = getelementptr i8, ptr %1234, i64 %1233
  %1236 = getelementptr i8, ptr %1226, i64 64
  %1237 = load ptr, ptr %1236, align 8
  call void %1237({ ptr, i160 } %998, ptr nocapture nofree nonnull readonly %1225, ptr nocapture nofree writeonly %1235) #1
  %1238 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1239 = getelementptr inbounds i8, ptr %result.i83.i1230, i64 16
  store i32 %1000, ptr %1239, align 8
  store ptr @Entry, ptr %1137, align 8
  %1240 = ptrtoint ptr %result.i83.i1230 to i64
  store i64 %1240, ptr %1139, align 4
  %.sroa_idx28.i1235 = getelementptr i8, ptr %1137, i64 24
  store i32 10, ptr %.sroa_idx28.i1235, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit712

1241:                                             ; preds = %._crit_edge.i1223, %1111, %1142
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1242 = load i32, ptr %988, align 4
  %1243 = load i32, ptr %34, align 8
  %.not.i670 = icmp slt i32 %1242, %1243
  br i1 %.not.i670, label %._crit_edge.i672, label %1244

1244:                                             ; preds = %1241
  %1245 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1246 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1247 = load ptr, ptr %35, align 8
  %1248 = load ptr, ptr %36, align 8
  %1249 = shl i32 %1243, 1
  %spec.select.i1252 = call i32 @llvm.smax.i32(i32 %1249, i32 16)
  store i32 %spec.select.i1252, ptr %34, align 8
  %1250 = zext nneg i32 %spec.select.i1252 to i64
  %1251 = shl nuw nsw i64 %1250, 5
  %result.i.i1253 = call noalias ptr @bump_malloc_inner(i64 noundef %1251, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1253, ptr %35, align 8
  %result.i20.i1254 = call noalias ptr @bump_malloc_inner(i64 noundef %1251, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1254, ptr %36, align 8
  store i32 0, ptr %988, align 4
  %1252 = icmp sgt i32 %1243, 0
  br i1 %1252, label %.lr.ph.i1954, label %._crit_edge.i672

.lr.ph.i1954:                                     ; preds = %1244, %._crit_edge.i1969
  %.060.i1967 = phi i32 [ %1271, %._crit_edge.i1969 ], [ 0, %1244 ]
  %1253 = zext nneg i32 %.060.i1967 to i64
  %1254 = shl nuw nsw i64 %1253, 5
  %1255 = getelementptr i8, ptr %1247, i64 %1254
  %1256 = load ptr, ptr %1255, align 8
  %1257 = icmp ne ptr %1256, @nil_typ
  %1258 = icmp ne ptr %1256, null
  %.not16.i1968 = and i1 %1257, %1258
  br i1 %.not16.i1968, label %1259, label %._crit_edge.i1969

1259:                                             ; preds = %.lr.ph.i1954
  %1260 = getelementptr i8, ptr %1255, i64 8
  %1261 = load i64, ptr %1260, align 4
  %.sroa_idx.i1970 = getelementptr i8, ptr %1255, i64 16
  %1262 = load i64, ptr %.sroa_idx.i1970, align 4
  %1263 = inttoptr i64 %1261 to ptr
  %1264 = inttoptr i64 %1262 to ptr
  %hash_coef_ptr.i.i18.i1971 = getelementptr i8, ptr %1256, i64 8
  %tbl_size_ptr.i.i19.i1972 = getelementptr i8, ptr %1256, i64 16
  %offset_tbl_ptr.i.i20.i1973 = getelementptr i8, ptr %1256, i64 40
  %hash_coef.i.i21.i1974 = load i64, ptr %hash_coef_ptr.i.i18.i1971, align 4, !noalias !22
  %tbl_size.i.i22.i1975 = load i64, ptr %tbl_size_ptr.i.i19.i1972, align 4, !noalias !22
  %offset_tbl.i.i23.i1976 = load ptr, ptr %offset_tbl_ptr.i.i20.i1973, align 8, !noalias !22
  %product.i.i.i24.i1977 = mul i64 %hash_coef.i.i21.i1974, 4015701072841558310
  %shifted.i.i.i25.i1978 = lshr i64 %product.i.i.i24.i1977, 32
  %xored.i.i.i26.i1979 = xor i64 %shifted.i.i.i25.i1978, %product.i.i.i24.i1977
  %hash.i.i.i27.i1980 = and i64 %xored.i.i.i26.i1979, %tbl_size.i.i22.i1975
  %offset_ptr.i.i28.i1981 = getelementptr i32, ptr %offset_tbl.i.i23.i1976, i64 %hash.i.i.i27.i1980
  %offset.i.i43.i1982 = load i32, ptr %offset_ptr.i.i28.i1981, align 4, !noalias !95
  %1265 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1256, 0
  %1266 = insertvalue { ptr, ptr, ptr, i32 } %1265, ptr %1263, 1
  %1267 = insertvalue { ptr, ptr, ptr, i32 } %1266, ptr %1264, 2
  %1268 = insertvalue { ptr, ptr, ptr, i32 } %1267, i32 %offset.i.i43.i1982, 3
  %1269 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %1270 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %991, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %1268) #7
  br label %._crit_edge.i1969

._crit_edge.i1969:                                ; preds = %1259, %.lr.ph.i1954
  %1271 = add nuw nsw i32 %.060.i1967, 1
  %1272 = icmp slt i32 %1271, %1243
  br i1 %1272, label %.lr.ph.i1954, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1987

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1987: ; preds = %._crit_edge.i1969, %._crit_edge.i2005
  %.060.i2003 = phi i32 [ %1291, %._crit_edge.i2005 ], [ 0, %._crit_edge.i1969 ]
  %1273 = zext nneg i32 %.060.i2003 to i64
  %1274 = shl nuw nsw i64 %1273, 5
  %1275 = getelementptr i8, ptr %1248, i64 %1274
  %1276 = load ptr, ptr %1275, align 8
  %1277 = icmp ne ptr %1276, @nil_typ
  %1278 = icmp ne ptr %1276, null
  %.not16.i2004 = and i1 %1277, %1278
  br i1 %.not16.i2004, label %1279, label %._crit_edge.i2005

1279:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1987
  %1280 = getelementptr i8, ptr %1275, i64 8
  %1281 = load i64, ptr %1280, align 4
  %.sroa_idx.i2006 = getelementptr i8, ptr %1275, i64 16
  %1282 = load i64, ptr %.sroa_idx.i2006, align 4
  %1283 = inttoptr i64 %1281 to ptr
  %1284 = inttoptr i64 %1282 to ptr
  %hash_coef_ptr.i.i18.i2007 = getelementptr i8, ptr %1276, i64 8
  %tbl_size_ptr.i.i19.i2008 = getelementptr i8, ptr %1276, i64 16
  %offset_tbl_ptr.i.i20.i2009 = getelementptr i8, ptr %1276, i64 40
  %hash_coef.i.i21.i2010 = load i64, ptr %hash_coef_ptr.i.i18.i2007, align 4, !noalias !22
  %tbl_size.i.i22.i2011 = load i64, ptr %tbl_size_ptr.i.i19.i2008, align 4, !noalias !22
  %offset_tbl.i.i23.i2012 = load ptr, ptr %offset_tbl_ptr.i.i20.i2009, align 8, !noalias !22
  %product.i.i.i24.i2013 = mul i64 %hash_coef.i.i21.i2010, 4015701072841558310
  %shifted.i.i.i25.i2014 = lshr i64 %product.i.i.i24.i2013, 32
  %xored.i.i.i26.i2015 = xor i64 %shifted.i.i.i25.i2014, %product.i.i.i24.i2013
  %hash.i.i.i27.i2016 = and i64 %xored.i.i.i26.i2015, %tbl_size.i.i22.i2011
  %offset_ptr.i.i28.i2017 = getelementptr i32, ptr %offset_tbl.i.i23.i2012, i64 %hash.i.i.i27.i2016
  %offset.i.i43.i2018 = load i32, ptr %offset_ptr.i.i28.i2017, align 4, !noalias !98
  %1285 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1276, 0
  %1286 = insertvalue { ptr, ptr, ptr, i32 } %1285, ptr %1283, 1
  %1287 = insertvalue { ptr, ptr, ptr, i32 } %1286, ptr %1284, 2
  %1288 = insertvalue { ptr, ptr, ptr, i32 } %1287, i32 %offset.i.i43.i2018, 3
  %1289 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %1290 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %991, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %1288) #7
  br label %._crit_edge.i2005

._crit_edge.i2005:                                ; preds = %1279, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1987
  %1291 = add nuw nsw i32 %.060.i2003, 1
  %1292 = icmp slt i32 %1291, %1243
  br i1 %1292, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1987, label %._crit_edge.i672

._crit_edge.i672:                                 ; preds = %._crit_edge.i2005, %1244, %1241
  %1293 = load ptr, ptr %result.i268, align 8
  %1294 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1295 = load ptr, ptr %27, align 8
  %1296 = load ptr, ptr %1293, align 8
  %1297 = getelementptr i8, ptr %1296, i64 72
  %1298 = load ptr, ptr %1297, align 8
  %result.i.i.i675 = call { i64, i64 } %1298(ptr nocapture nofree nonnull readonly %1293) #5
  %1299 = extractvalue { i64, i64 } %result.i.i.i675, 0
  %1300 = extractvalue { i64, i64 } %result.i.i.i675, 1
  %1301 = urem i64 20, %1300
  %1302 = icmp eq i64 %1301, 0
  %1303 = sub i64 %1300, %1301
  %1304 = select i1 %1302, i64 0, i64 %1303
  %1305 = add i64 %1299, 20
  %1306 = add i64 %1305, %1304
  %1307 = load ptr, ptr %1295, align 8
  %1308 = getelementptr i8, ptr %1307, i64 72
  %1309 = load ptr, ptr %1308, align 8
  %result.i1.i.i676 = call { i64, i64 } %1309(ptr nocapture nofree nonnull readonly %1295) #5
  %1310 = extractvalue { i64, i64 } %result.i1.i.i676, 0
  %1311 = extractvalue { i64, i64 } %result.i1.i.i676, 1
  %1312 = call i64 @llvm.umax.i64(i64 %1300, i64 %1311)
  %1313 = call i64 @llvm.umax.i64(i64 %1312, i64 8)
  %1314 = urem i64 %1306, %1311
  %1315 = icmp eq i64 %1314, 0
  %1316 = sub i64 %1311, %1314
  %1317 = select i1 %1315, i64 0, i64 %1316
  %1318 = add i64 %1310, %1306
  %1319 = add i64 %1318, %1317
  %1320 = urem i64 %1319, %1313
  %1321 = icmp eq i64 %1320, 0
  %1322 = sub i64 %1313, %1320
  %1323 = select i1 %1321, i64 0, i64 %1322
  %1324 = add i64 %1323, %1319
  %result.i90.i677 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1324, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1293, ptr %result.i90.i677, align 8
  %1325 = getelementptr inbounds i8, ptr %result.i90.i677, i64 8
  store ptr %1295, ptr %1325, align 8
  %1326 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i677)
  %1327 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1328 = load ptr, ptr %1293, align 8
  %1329 = getelementptr i8, ptr %1328, i64 72
  %1330 = load ptr, ptr %1329, align 8
  %result.i.i196.i678 = call { i64, i64 } %1330(ptr nocapture nofree nonnull readonly %1293) #5
  %1331 = extractvalue { i64, i64 } %result.i.i196.i678, 1
  %1332 = urem i64 20, %1331
  %1333 = icmp eq i64 %1332, 0
  %reass.sub3126 = sub i64 %1331, %1332
  %1334 = add i64 %reass.sub3126, 20
  %1335 = select i1 %1333, i64 20, i64 %1334
  %1336 = getelementptr i8, ptr %result.i90.i677, i64 %1335
  %1337 = getelementptr i8, ptr %1328, i64 64
  %1338 = load ptr, ptr %1337, align 8
  call void %1338({ ptr, i160 } %997, ptr nocapture nofree nonnull readonly %1293, ptr nocapture nofree writeonly %1336) #1
  %1339 = load ptr, ptr %result.i90.i677, align 8
  %1340 = load ptr, ptr %1339, align 8
  %1341 = getelementptr i8, ptr %1340, i64 72
  %1342 = load ptr, ptr %1341, align 8
  %result.i.i197.i680 = call { i64, i64 } %1342(ptr nocapture nofree nonnull readonly %1339) #5
  %1343 = extractvalue { i64, i64 } %result.i.i197.i680, 0
  %1344 = extractvalue { i64, i64 } %result.i.i197.i680, 1
  %1345 = urem i64 20, %1344
  %1346 = icmp eq i64 %1345, 0
  %1347 = sub i64 %1344, %1345
  %1348 = select i1 %1346, i64 0, i64 %1347
  %1349 = add i64 %1343, 20
  %1350 = add i64 %1349, %1348
  %1351 = load ptr, ptr %1325, align 8
  %1352 = load ptr, ptr %1351, align 8
  %1353 = getelementptr i8, ptr %1352, i64 72
  %1354 = load ptr, ptr %1353, align 8
  %result.i1.i198.i681 = call { i64, i64 } %1354(ptr nocapture nofree nonnull readonly %1351) #5
  %1355 = extractvalue { i64, i64 } %result.i1.i198.i681, 1
  %1356 = urem i64 %1350, %1355
  %1357 = icmp eq i64 %1356, 0
  %1358 = sub i64 %1355, %1356
  %1359 = select i1 %1357, i64 0, i64 %1358
  %1360 = getelementptr i8, ptr %result.i90.i677, i64 %1350
  %1361 = getelementptr i8, ptr %1360, i64 %1359
  %1362 = getelementptr i8, ptr %1352, i64 64
  %1363 = load ptr, ptr %1362, align 8
  call void %1363({ ptr, i160 } %998, ptr nocapture nofree nonnull readonly %1351, ptr nocapture nofree writeonly %1361) #1
  %1364 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1365 = getelementptr inbounds i8, ptr %result.i90.i677, i64 16
  store i32 %1000, ptr %1365, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %1366 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1367 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1368 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1369

1369:                                             ; preds = %.cont.cont.i1307, %._crit_edge.i672
  %.0566.i1287 = phi i32 [ 0, %._crit_edge.i672 ], [ %1370, %.cont.cont.i1307 ]
  %.070565.i1288 = phi i1 [ true, %._crit_edge.i672 ], [ %1436, %.cont.cont.i1307 ]
  %.sroa.0.0564.i1289 = phi ptr [ @Entry, %._crit_edge.i672 ], [ %vptr.i142.sroa.speculated.i1310, %.cont.cont.i1307 ]
  %.sroa.6.0563.i1290 = phi ptr [ %result.i90.i677, %._crit_edge.i672 ], [ %spec.select539.i1312, %.cont.cont.i1307 ]
  %.sroa.12.0562.i1291 = phi ptr [ undef, %._crit_edge.i672 ], [ %spec.select.i1311, %.cont.cont.i1307 ]
  %.sroa.17.0561.i1292 = phi i32 [ 10, %._crit_edge.i672 ], [ %offset.i.i154.i1324, %.cont.cont.i1307 ]
  %1370 = add nuw nsw i32 %.0566.i1287, 1
  %1371 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1289, 0
  %1372 = insertvalue { ptr, ptr, ptr, i32 } %1371, ptr %.sroa.6.0563.i1290, 1
  %1373 = insertvalue { ptr, ptr, ptr, i32 } %1372, ptr %.sroa.12.0562.i1291, 2
  %1374 = insertvalue { ptr, ptr, ptr, i32 } %1373, i32 %.sroa.17.0561.i1292, 3
  %1375 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1289)
  %1376 = sext i32 %.sroa.17.0561.i1292 to i64
  %1377 = getelementptr ptr, ptr %.sroa.0.0564.i1289, i64 %1376
  %1378 = getelementptr i8, ptr %1377, i64 64
  %1379 = load ptr, ptr %1378, align 8
  %result.i125.i1293 = call ptr %1379({ ptr, ptr, ptr, i32 } %1374, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1380 = call i32 %result.i125.i1293({ ptr, ptr, ptr, i32 } %1374, { ptr, ptr, ptr, i32 } %1374, ptr nonnull align 8 %2) #7
  %1381 = ptrtoint ptr %.sroa.6.0563.i1290 to i64
  %1382 = ptrtoint ptr %.sroa.12.0562.i1291 to i64
  br i1 %.070565.i1288, label %1383, label %1399

1383:                                             ; preds = %1369
  %1384 = load i32, ptr %34, align 8
  %1385 = add i32 %1384, -1
  %1386 = and i32 %1385, %1380
  %1387 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1388 = load ptr, ptr %35, align 8
  %1389 = sext i32 %1386 to i64
  %1390 = shl nsw i64 %1389, 5
  %1391 = getelementptr i8, ptr %1388, i64 %1390
  %1392 = load ptr, ptr %1391, align 8
  %1393 = getelementptr i8, ptr %1391, i64 8
  %1394 = load i160, ptr %1393, align 4
  store ptr %.sroa.0.0564.i1289, ptr %1391, align 8
  store i64 %1381, ptr %1393, align 4
  %.sroa_idx157.i1336 = getelementptr i8, ptr %1391, i64 16
  store i64 %1382, ptr %.sroa_idx157.i1336, align 4
  %.sroa_idx158.i1337 = getelementptr i8, ptr %1391, i64 24
  store i32 %.sroa.17.0561.i1292, ptr %.sroa_idx158.i1337, align 4
  %1395 = icmp ne ptr %1392, @nil_typ
  %1396 = icmp ne ptr %1392, null
  %.not92.i1338 = and i1 %1395, %1396
  %extract.i1340 = lshr i160 %1394, 64
  %1397 = insertelement <2 x i160> poison, i160 %1394, i64 0
  %1398 = insertelement <2 x i160> %1397, i160 %extract.i1340, i64 1
  br i1 %.not92.i1338, label %.cont.cont.i1307, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1342.thread

1399:                                             ; preds = %1369
  %1400 = add i32 %1380, 2127912214
  %1401 = shl i32 %1380, 12
  %1402 = add i32 %1400, %1401
  %1403 = ashr i32 %1402, 19
  %1404 = xor i32 %1402, %1403
  %1405 = xor i32 %1404, -949894596
  %1406 = add i32 %1405, 374761393
  %1407 = shl i32 %1405, 5
  %1408 = add i32 %1406, %1407
  %1409 = add i32 %1408, -744332180
  %1410 = shl i32 %1408, 9
  %1411 = xor i32 %1409, %1410
  %1412 = add i32 %1411, -42973499
  %1413 = shl i32 %1411, 3
  %1414 = add i32 %1412, %1413
  %1415 = ashr i32 %1414, 16
  %1416 = xor i32 %1414, %1415
  %1417 = xor i32 %1416, -1252372727
  %1418 = load i32, ptr %34, align 8
  %1419 = add i32 %1418, -1
  %1420 = and i32 %1419, %1417
  %1421 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1422 = load ptr, ptr %36, align 8
  %1423 = sext i32 %1420 to i64
  %1424 = shl nsw i64 %1423, 5
  %1425 = getelementptr i8, ptr %1422, i64 %1424
  %1426 = load ptr, ptr %1425, align 8
  %1427 = getelementptr i8, ptr %1425, i64 8
  %1428 = load i160, ptr %1427, align 4
  store ptr %.sroa.0.0564.i1289, ptr %1425, align 8
  store i64 %1381, ptr %1427, align 4
  %.sroa_idx161.i1297 = getelementptr i8, ptr %1425, i64 16
  store i64 %1382, ptr %.sroa_idx161.i1297, align 4
  %.sroa_idx162.i1298 = getelementptr i8, ptr %1425, i64 24
  store i32 %.sroa.17.0561.i1292, ptr %.sroa_idx162.i1298, align 4
  %1429 = icmp ne ptr %1426, @nil_typ
  %1430 = icmp ne ptr %1426, null
  %.not90.i1299 = and i1 %1429, %1430
  %extract607.i1301 = lshr i160 %1428, 64
  %1431 = insertelement <2 x i160> poison, i160 %1428, i64 0
  %1432 = insertelement <2 x i160> %1431, i160 %extract607.i1301, i64 1
  br i1 %.not90.i1299, label %.cont.cont.i1307, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1342.thread

.cont.cont.i1307:                                 ; preds = %1399, %1383
  %vptr.i142.sroa.speculated.i1310 = phi ptr [ %1392, %1383 ], [ %1426, %1399 ]
  %.in3133 = phi <2 x i160> [ %1398, %1383 ], [ %1432, %1399 ]
  %1433 = trunc <2 x i160> %.in3133 to <2 x i64>
  %1434 = extractelement <2 x i64> %1433, i64 1
  %spec.select.i1311 = inttoptr i64 %1434 to ptr
  %1435 = extractelement <2 x i64> %1433, i64 0
  %spec.select539.i1312 = inttoptr i64 %1435 to ptr
  %1436 = xor i1 %.070565.i1288, true
  %hash_coef_ptr.i.i143.i1313 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1310, i64 8
  %tbl_size_ptr.i.i144.i1314 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1310, i64 16
  %offset_tbl_ptr.i.i145.i1315 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1310, i64 40
  %hash_coef.i.i146.i1316 = load i64, ptr %hash_coef_ptr.i.i143.i1313, align 4
  %tbl_size.i.i147.i1317 = load i64, ptr %tbl_size_ptr.i.i144.i1314, align 4
  %offset_tbl.i.i148.i1318 = load ptr, ptr %offset_tbl_ptr.i.i145.i1315, align 8
  %product.i.i.i149.i1319 = mul i64 %hash_coef.i.i146.i1316, 4015701072841558310
  %shifted.i.i.i150.i1320 = lshr i64 %product.i.i.i149.i1319, 32
  %xored.i.i.i151.i1321 = xor i64 %shifted.i.i.i150.i1320, %product.i.i.i149.i1319
  %hash.i.i.i152.i1322 = and i64 %xored.i.i.i151.i1321, %tbl_size.i.i147.i1317
  %offset_ptr.i.i153.i1323 = getelementptr i32, ptr %offset_tbl.i.i148.i1318, i64 %hash.i.i.i152.i1322
  %offset.i.i154.i1324 = load i32, ptr %offset_ptr.i.i153.i1323, align 4
  %1437 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1438 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1439 = icmp ult i32 %.0566.i1287, 99
  br i1 %1439, label %1369, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1342

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1342.thread: ; preds = %1383, %1399
  %1440 = phi ptr [ %22, %1399 ], [ %21, %1383 ]
  %1441 = load i32, ptr %988, align 4
  store i32 %1441, ptr %1440, align 4
  %1442 = add i32 %1441, 1
  %1443 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1442, ptr %988, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %CuckooMap_insert_keyK_valueV.exit712

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1342: ; preds = %.cont.cont.i1307
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  %1444 = icmp eq ptr %vptr.i142.sroa.speculated.i1310, null
  br i1 %1444, label %CuckooMap_insert_keyK_valueV.exit712, label %1445

1445:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1342
  %1446 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1447 = load ptr, ptr %35, align 8
  %1448 = load ptr, ptr %36, align 8
  %1449 = load i32, ptr %34, align 8
  %1450 = shl i32 %1449, 1
  %spec.select.i1358 = call i32 @llvm.smax.i32(i32 %1450, i32 16)
  store i32 %spec.select.i1358, ptr %34, align 8
  %1451 = zext nneg i32 %spec.select.i1358 to i64
  %1452 = shl nuw nsw i64 %1451, 5
  %result.i.i1359 = call noalias ptr @bump_malloc_inner(i64 noundef %1452, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1359, ptr %35, align 8
  %result.i20.i1360 = call noalias ptr @bump_malloc_inner(i64 noundef %1452, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1360, ptr %36, align 8
  store i32 0, ptr %988, align 4
  %1453 = icmp sgt i32 %1449, 0
  br i1 %1453, label %.lr.ph.i2053, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122

.lr.ph.i2053:                                     ; preds = %1445, %._crit_edge.i2068
  %.060.i2066 = phi i32 [ %1542, %._crit_edge.i2068 ], [ 0, %1445 ]
  %1454 = zext nneg i32 %.060.i2066 to i64
  %1455 = shl nuw nsw i64 %1454, 5
  %1456 = getelementptr i8, ptr %1447, i64 %1455
  %1457 = load ptr, ptr %1456, align 8
  %1458 = icmp ne ptr %1457, @nil_typ
  %1459 = icmp ne ptr %1457, null
  %.not16.i2067 = and i1 %1458, %1459
  br i1 %.not16.i2067, label %1460, label %._crit_edge.i2068

1460:                                             ; preds = %.lr.ph.i2053
  %1461 = getelementptr i8, ptr %1456, i64 8
  %1462 = load <2 x i64>, ptr %1461, align 4
  %hash_coef_ptr.i.i18.i2070 = getelementptr i8, ptr %1457, i64 8
  %tbl_size_ptr.i.i19.i2071 = getelementptr i8, ptr %1457, i64 16
  %offset_tbl_ptr.i.i20.i2072 = getelementptr i8, ptr %1457, i64 40
  %1463 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i2547 = load i64, ptr %hash_coef_ptr.i.i18.i2070, align 4, !noalias !22
  %tbl_size.i.i100.i2548 = load i64, ptr %tbl_size_ptr.i.i19.i2071, align 4, !noalias !22
  %offset_tbl.i.i101.i2549 = load ptr, ptr %offset_tbl_ptr.i.i20.i2072, align 8, !noalias !22
  %product.i.i.i102.i2550 = mul i64 %hash_coef.i.i99.i2547, 4015701072841558310
  %shifted.i.i.i103.i2551 = lshr i64 %product.i.i.i102.i2550, 32
  %xored.i.i.i104.i2552 = xor i64 %shifted.i.i.i103.i2551, %product.i.i.i102.i2550
  %hash.i.i.i105.i2553 = and i64 %xored.i.i.i104.i2552, %tbl_size.i.i100.i2548
  %offset_ptr.i.i106.i2554 = getelementptr i32, ptr %offset_tbl.i.i101.i2549, i64 %hash.i.i.i105.i2553
  %offset.i.i121.i2555 = load i32, ptr %offset_ptr.i.i106.i2554, align 4, !noalias !101
  %1464 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1465 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1466 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1467

1467:                                             ; preds = %.cont.cont.i2576, %1460
  %.0566.i2556 = phi i32 [ 0, %1460 ], [ %1471, %.cont.cont.i2576 ]
  %.070565.i2557 = phi i1 [ true, %1460 ], [ %1533, %.cont.cont.i2576 ]
  %.sroa.0.0564.i2558 = phi ptr [ %1457, %1460 ], [ %vptr.i142.sroa.speculated.i2579, %.cont.cont.i2576 ]
  %.sroa.17.0561.i2561 = phi i32 [ %offset.i.i121.i2555, %1460 ], [ %offset.i.i154.i2593, %.cont.cont.i2576 ]
  %1468 = phi <2 x i64> [ %1462, %1460 ], [ %1532, %.cont.cont.i2576 ]
  %1469 = extractelement <2 x i64> %1468, i64 1
  %.sroa.12.0562.i2560 = inttoptr i64 %1469 to ptr
  %1470 = extractelement <2 x i64> %1468, i64 0
  %.sroa.6.0563.i2559 = inttoptr i64 %1470 to ptr
  %1471 = add nuw nsw i32 %.0566.i2556, 1
  %1472 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2558, 0
  %1473 = insertvalue { ptr, ptr, ptr, i32 } %1472, ptr %.sroa.6.0563.i2559, 1
  %1474 = insertvalue { ptr, ptr, ptr, i32 } %1473, ptr %.sroa.12.0562.i2560, 2
  %1475 = insertvalue { ptr, ptr, ptr, i32 } %1474, i32 %.sroa.17.0561.i2561, 3
  %1476 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2558)
  %1477 = sext i32 %.sroa.17.0561.i2561 to i64
  %1478 = getelementptr ptr, ptr %.sroa.0.0564.i2558, i64 %1477
  %1479 = getelementptr i8, ptr %1478, i64 64
  %1480 = load ptr, ptr %1479, align 8
  %result.i125.i2562 = call ptr %1480({ ptr, ptr, ptr, i32 } %1475, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1481 = call i32 %result.i125.i2562({ ptr, ptr, ptr, i32 } %1475, { ptr, ptr, ptr, i32 } %1475, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2557, label %1482, label %1498

1482:                                             ; preds = %1467
  %1483 = load i32, ptr %34, align 8
  %1484 = add i32 %1483, -1
  %1485 = and i32 %1484, %1481
  %1486 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1487 = load ptr, ptr %35, align 8
  %1488 = sext i32 %1485 to i64
  %1489 = shl nsw i64 %1488, 5
  %1490 = getelementptr i8, ptr %1487, i64 %1489
  %1491 = load ptr, ptr %1490, align 8
  %1492 = getelementptr i8, ptr %1490, i64 8
  %1493 = load i160, ptr %1492, align 4
  store ptr %.sroa.0.0564.i2558, ptr %1490, align 8
  store i64 %1470, ptr %1492, align 4
  %.sroa_idx157.i2605 = getelementptr i8, ptr %1490, i64 16
  store i64 %1469, ptr %.sroa_idx157.i2605, align 4
  %.sroa_idx158.i2606 = getelementptr i8, ptr %1490, i64 24
  store i32 %.sroa.17.0561.i2561, ptr %.sroa_idx158.i2606, align 4
  %1494 = icmp ne ptr %1491, @nil_typ
  %1495 = icmp ne ptr %1491, null
  %.not92.i2607 = and i1 %1494, %1495
  %extract.i2609 = lshr i160 %1493, 64
  %1496 = insertelement <2 x i160> poison, i160 %1493, i64 0
  %1497 = insertelement <2 x i160> %1496, i160 %extract.i2609, i64 1
  br i1 %.not92.i2607, label %.cont.cont.i2576, label %1537

1498:                                             ; preds = %1467
  %1499 = add i32 %1481, 2127912214
  %1500 = shl i32 %1481, 12
  %1501 = add i32 %1499, %1500
  %1502 = ashr i32 %1501, 19
  %1503 = xor i32 %1501, %1502
  %1504 = xor i32 %1503, -949894596
  %1505 = add i32 %1504, 374761393
  %1506 = shl i32 %1504, 5
  %1507 = add i32 %1505, %1506
  %1508 = add i32 %1507, -744332180
  %1509 = shl i32 %1507, 9
  %1510 = xor i32 %1508, %1509
  %1511 = add i32 %1510, -42973499
  %1512 = shl i32 %1510, 3
  %1513 = add i32 %1511, %1512
  %1514 = ashr i32 %1513, 16
  %1515 = xor i32 %1513, %1514
  %1516 = xor i32 %1515, -1252372727
  %1517 = load i32, ptr %34, align 8
  %1518 = add i32 %1517, -1
  %1519 = and i32 %1518, %1516
  %1520 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1521 = load ptr, ptr %36, align 8
  %1522 = sext i32 %1519 to i64
  %1523 = shl nsw i64 %1522, 5
  %1524 = getelementptr i8, ptr %1521, i64 %1523
  %1525 = load ptr, ptr %1524, align 8
  %1526 = getelementptr i8, ptr %1524, i64 8
  %1527 = load i160, ptr %1526, align 4
  store ptr %.sroa.0.0564.i2558, ptr %1524, align 8
  store i64 %1470, ptr %1526, align 4
  %.sroa_idx161.i2566 = getelementptr i8, ptr %1524, i64 16
  store i64 %1469, ptr %.sroa_idx161.i2566, align 4
  %.sroa_idx162.i2567 = getelementptr i8, ptr %1524, i64 24
  store i32 %.sroa.17.0561.i2561, ptr %.sroa_idx162.i2567, align 4
  %1528 = icmp ne ptr %1525, @nil_typ
  %1529 = icmp ne ptr %1525, null
  %.not90.i2568 = and i1 %1528, %1529
  %extract607.i2570 = lshr i160 %1527, 64
  %1530 = insertelement <2 x i160> poison, i160 %1527, i64 0
  %1531 = insertelement <2 x i160> %1530, i160 %extract607.i2570, i64 1
  br i1 %.not90.i2568, label %.cont.cont.i2576, label %1537

.cont.cont.i2576:                                 ; preds = %1498, %1482
  %vptr.i142.sroa.speculated.i2579 = phi ptr [ %1491, %1482 ], [ %1525, %1498 ]
  %.in3134 = phi <2 x i160> [ %1497, %1482 ], [ %1531, %1498 ]
  %1532 = trunc <2 x i160> %.in3134 to <2 x i64>
  %1533 = xor i1 %.070565.i2557, true
  %hash_coef_ptr.i.i143.i2582 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2579, i64 8
  %tbl_size_ptr.i.i144.i2583 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2579, i64 16
  %offset_tbl_ptr.i.i145.i2584 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2579, i64 40
  %hash_coef.i.i146.i2585 = load i64, ptr %hash_coef_ptr.i.i143.i2582, align 4
  %tbl_size.i.i147.i2586 = load i64, ptr %tbl_size_ptr.i.i144.i2583, align 4
  %offset_tbl.i.i148.i2587 = load ptr, ptr %offset_tbl_ptr.i.i145.i2584, align 8
  %product.i.i.i149.i2588 = mul i64 %hash_coef.i.i146.i2585, 4015701072841558310
  %shifted.i.i.i150.i2589 = lshr i64 %product.i.i.i149.i2588, 32
  %xored.i.i.i151.i2590 = xor i64 %shifted.i.i.i150.i2589, %product.i.i.i149.i2588
  %hash.i.i.i152.i2591 = and i64 %xored.i.i.i151.i2590, %tbl_size.i.i147.i2586
  %offset_ptr.i.i153.i2592 = getelementptr i32, ptr %offset_tbl.i.i148.i2587, i64 %hash.i.i.i152.i2591
  %offset.i.i154.i2593 = load i32, ptr %offset_ptr.i.i153.i2592, align 4
  %1534 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1535 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1536 = icmp ult i32 %.0566.i2556, 99
  br i1 %1536, label %1467, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2611

1537:                                             ; preds = %1498, %1482
  %1538 = phi ptr [ %10, %1498 ], [ %9, %1482 ]
  %1539 = load i32, ptr %988, align 4
  store i32 %1539, ptr %1538, align 4
  %1540 = add i32 %1539, 1
  %1541 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1540, ptr %988, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2611

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2611: ; preds = %.cont.cont.i2576, %1537
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i2068

._crit_edge.i2068:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2611, %.lr.ph.i2053
  %1542 = add nuw nsw i32 %.060.i2066, 1
  %1543 = icmp slt i32 %1542, %1449
  br i1 %1543, label %.lr.ph.i2053, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2086

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2086: ; preds = %._crit_edge.i2068, %._crit_edge.i2104
  %.060.i2102 = phi i32 [ %1632, %._crit_edge.i2104 ], [ 0, %._crit_edge.i2068 ]
  %1544 = zext nneg i32 %.060.i2102 to i64
  %1545 = shl nuw nsw i64 %1544, 5
  %1546 = getelementptr i8, ptr %1448, i64 %1545
  %1547 = load ptr, ptr %1546, align 8
  %1548 = icmp ne ptr %1547, @nil_typ
  %1549 = icmp ne ptr %1547, null
  %.not16.i2103 = and i1 %1548, %1549
  br i1 %.not16.i2103, label %1550, label %._crit_edge.i2104

1550:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2086
  %1551 = getelementptr i8, ptr %1546, i64 8
  %1552 = load <2 x i64>, ptr %1551, align 4
  %hash_coef_ptr.i.i18.i2106 = getelementptr i8, ptr %1547, i64 8
  %tbl_size_ptr.i.i19.i2107 = getelementptr i8, ptr %1547, i64 16
  %offset_tbl_ptr.i.i20.i2108 = getelementptr i8, ptr %1547, i64 40
  %1553 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i2629 = load i64, ptr %hash_coef_ptr.i.i18.i2106, align 4, !noalias !22
  %tbl_size.i.i100.i2630 = load i64, ptr %tbl_size_ptr.i.i19.i2107, align 4, !noalias !22
  %offset_tbl.i.i101.i2631 = load ptr, ptr %offset_tbl_ptr.i.i20.i2108, align 8, !noalias !22
  %product.i.i.i102.i2632 = mul i64 %hash_coef.i.i99.i2629, 4015701072841558310
  %shifted.i.i.i103.i2633 = lshr i64 %product.i.i.i102.i2632, 32
  %xored.i.i.i104.i2634 = xor i64 %shifted.i.i.i103.i2633, %product.i.i.i102.i2632
  %hash.i.i.i105.i2635 = and i64 %xored.i.i.i104.i2634, %tbl_size.i.i100.i2630
  %offset_ptr.i.i106.i2636 = getelementptr i32, ptr %offset_tbl.i.i101.i2631, i64 %hash.i.i.i105.i2635
  %offset.i.i121.i2637 = load i32, ptr %offset_ptr.i.i106.i2636, align 4, !noalias !104
  %1554 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1555 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1556 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1557

1557:                                             ; preds = %.cont.cont.i2658, %1550
  %.0566.i2638 = phi i32 [ 0, %1550 ], [ %1561, %.cont.cont.i2658 ]
  %.070565.i2639 = phi i1 [ true, %1550 ], [ %1623, %.cont.cont.i2658 ]
  %.sroa.0.0564.i2640 = phi ptr [ %1547, %1550 ], [ %vptr.i142.sroa.speculated.i2661, %.cont.cont.i2658 ]
  %.sroa.17.0561.i2643 = phi i32 [ %offset.i.i121.i2637, %1550 ], [ %offset.i.i154.i2675, %.cont.cont.i2658 ]
  %1558 = phi <2 x i64> [ %1552, %1550 ], [ %1622, %.cont.cont.i2658 ]
  %1559 = extractelement <2 x i64> %1558, i64 1
  %.sroa.12.0562.i2642 = inttoptr i64 %1559 to ptr
  %1560 = extractelement <2 x i64> %1558, i64 0
  %.sroa.6.0563.i2641 = inttoptr i64 %1560 to ptr
  %1561 = add nuw nsw i32 %.0566.i2638, 1
  %1562 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2640, 0
  %1563 = insertvalue { ptr, ptr, ptr, i32 } %1562, ptr %.sroa.6.0563.i2641, 1
  %1564 = insertvalue { ptr, ptr, ptr, i32 } %1563, ptr %.sroa.12.0562.i2642, 2
  %1565 = insertvalue { ptr, ptr, ptr, i32 } %1564, i32 %.sroa.17.0561.i2643, 3
  %1566 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2640)
  %1567 = sext i32 %.sroa.17.0561.i2643 to i64
  %1568 = getelementptr ptr, ptr %.sroa.0.0564.i2640, i64 %1567
  %1569 = getelementptr i8, ptr %1568, i64 64
  %1570 = load ptr, ptr %1569, align 8
  %result.i125.i2644 = call ptr %1570({ ptr, ptr, ptr, i32 } %1565, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1571 = call i32 %result.i125.i2644({ ptr, ptr, ptr, i32 } %1565, { ptr, ptr, ptr, i32 } %1565, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2639, label %1572, label %1588

1572:                                             ; preds = %1557
  %1573 = load i32, ptr %34, align 8
  %1574 = add i32 %1573, -1
  %1575 = and i32 %1574, %1571
  %1576 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1577 = load ptr, ptr %35, align 8
  %1578 = sext i32 %1575 to i64
  %1579 = shl nsw i64 %1578, 5
  %1580 = getelementptr i8, ptr %1577, i64 %1579
  %1581 = load ptr, ptr %1580, align 8
  %1582 = getelementptr i8, ptr %1580, i64 8
  %1583 = load i160, ptr %1582, align 4
  store ptr %.sroa.0.0564.i2640, ptr %1580, align 8
  store i64 %1560, ptr %1582, align 4
  %.sroa_idx157.i2687 = getelementptr i8, ptr %1580, i64 16
  store i64 %1559, ptr %.sroa_idx157.i2687, align 4
  %.sroa_idx158.i2688 = getelementptr i8, ptr %1580, i64 24
  store i32 %.sroa.17.0561.i2643, ptr %.sroa_idx158.i2688, align 4
  %1584 = icmp ne ptr %1581, @nil_typ
  %1585 = icmp ne ptr %1581, null
  %.not92.i2689 = and i1 %1584, %1585
  %extract.i2691 = lshr i160 %1583, 64
  %1586 = insertelement <2 x i160> poison, i160 %1583, i64 0
  %1587 = insertelement <2 x i160> %1586, i160 %extract.i2691, i64 1
  br i1 %.not92.i2689, label %.cont.cont.i2658, label %1627

1588:                                             ; preds = %1557
  %1589 = add i32 %1571, 2127912214
  %1590 = shl i32 %1571, 12
  %1591 = add i32 %1589, %1590
  %1592 = ashr i32 %1591, 19
  %1593 = xor i32 %1591, %1592
  %1594 = xor i32 %1593, -949894596
  %1595 = add i32 %1594, 374761393
  %1596 = shl i32 %1594, 5
  %1597 = add i32 %1595, %1596
  %1598 = add i32 %1597, -744332180
  %1599 = shl i32 %1597, 9
  %1600 = xor i32 %1598, %1599
  %1601 = add i32 %1600, -42973499
  %1602 = shl i32 %1600, 3
  %1603 = add i32 %1601, %1602
  %1604 = ashr i32 %1603, 16
  %1605 = xor i32 %1603, %1604
  %1606 = xor i32 %1605, -1252372727
  %1607 = load i32, ptr %34, align 8
  %1608 = add i32 %1607, -1
  %1609 = and i32 %1608, %1606
  %1610 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1611 = load ptr, ptr %36, align 8
  %1612 = sext i32 %1609 to i64
  %1613 = shl nsw i64 %1612, 5
  %1614 = getelementptr i8, ptr %1611, i64 %1613
  %1615 = load ptr, ptr %1614, align 8
  %1616 = getelementptr i8, ptr %1614, i64 8
  %1617 = load i160, ptr %1616, align 4
  store ptr %.sroa.0.0564.i2640, ptr %1614, align 8
  store i64 %1560, ptr %1616, align 4
  %.sroa_idx161.i2648 = getelementptr i8, ptr %1614, i64 16
  store i64 %1559, ptr %.sroa_idx161.i2648, align 4
  %.sroa_idx162.i2649 = getelementptr i8, ptr %1614, i64 24
  store i32 %.sroa.17.0561.i2643, ptr %.sroa_idx162.i2649, align 4
  %1618 = icmp ne ptr %1615, @nil_typ
  %1619 = icmp ne ptr %1615, null
  %.not90.i2650 = and i1 %1618, %1619
  %extract607.i2652 = lshr i160 %1617, 64
  %1620 = insertelement <2 x i160> poison, i160 %1617, i64 0
  %1621 = insertelement <2 x i160> %1620, i160 %extract607.i2652, i64 1
  br i1 %.not90.i2650, label %.cont.cont.i2658, label %1627

.cont.cont.i2658:                                 ; preds = %1588, %1572
  %vptr.i142.sroa.speculated.i2661 = phi ptr [ %1581, %1572 ], [ %1615, %1588 ]
  %.in3135 = phi <2 x i160> [ %1587, %1572 ], [ %1621, %1588 ]
  %1622 = trunc <2 x i160> %.in3135 to <2 x i64>
  %1623 = xor i1 %.070565.i2639, true
  %hash_coef_ptr.i.i143.i2664 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2661, i64 8
  %tbl_size_ptr.i.i144.i2665 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2661, i64 16
  %offset_tbl_ptr.i.i145.i2666 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2661, i64 40
  %hash_coef.i.i146.i2667 = load i64, ptr %hash_coef_ptr.i.i143.i2664, align 4
  %tbl_size.i.i147.i2668 = load i64, ptr %tbl_size_ptr.i.i144.i2665, align 4
  %offset_tbl.i.i148.i2669 = load ptr, ptr %offset_tbl_ptr.i.i145.i2666, align 8
  %product.i.i.i149.i2670 = mul i64 %hash_coef.i.i146.i2667, 4015701072841558310
  %shifted.i.i.i150.i2671 = lshr i64 %product.i.i.i149.i2670, 32
  %xored.i.i.i151.i2672 = xor i64 %shifted.i.i.i150.i2671, %product.i.i.i149.i2670
  %hash.i.i.i152.i2673 = and i64 %xored.i.i.i151.i2672, %tbl_size.i.i147.i2668
  %offset_ptr.i.i153.i2674 = getelementptr i32, ptr %offset_tbl.i.i148.i2669, i64 %hash.i.i.i152.i2673
  %offset.i.i154.i2675 = load i32, ptr %offset_ptr.i.i153.i2674, align 4
  %1624 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1625 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1626 = icmp ult i32 %.0566.i2638, 99
  br i1 %1626, label %1557, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2693

1627:                                             ; preds = %1588, %1572
  %1628 = phi ptr [ %8, %1588 ], [ %7, %1572 ]
  %1629 = load i32, ptr %988, align 4
  store i32 %1629, ptr %1628, align 4
  %1630 = add i32 %1629, 1
  %1631 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1630, ptr %988, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2693

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2693: ; preds = %.cont.cont.i2658, %1627
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i2104

._crit_edge.i2104:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2693, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2086
  %1632 = add nuw nsw i32 %.060.i2102, 1
  %1633 = icmp slt i32 %1632, %1449
  br i1 %1633, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2086, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122: ; preds = %._crit_edge.i2104, %1445
  %1634 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i1383 = load i64, ptr %hash_coef_ptr.i.i143.i1313, align 4, !noalias !22
  %tbl_size.i.i100.i1384 = load i64, ptr %tbl_size_ptr.i.i144.i1314, align 4, !noalias !22
  %offset_tbl.i.i101.i1385 = load ptr, ptr %offset_tbl_ptr.i.i145.i1315, align 8, !noalias !22
  %product.i.i.i102.i1386 = mul i64 %hash_coef.i.i99.i1383, 4015701072841558310
  %shifted.i.i.i103.i1387 = lshr i64 %product.i.i.i102.i1386, 32
  %xored.i.i.i104.i1388 = xor i64 %shifted.i.i.i103.i1387, %product.i.i.i102.i1386
  %hash.i.i.i105.i1389 = and i64 %xored.i.i.i104.i1388, %tbl_size.i.i100.i1384
  %offset_ptr.i.i106.i1390 = getelementptr i32, ptr %offset_tbl.i.i101.i1385, i64 %hash.i.i.i105.i1389
  %offset.i.i121.i1391 = load i32, ptr %offset_ptr.i.i106.i1390, align 4, !noalias !107
  %1635 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1636 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1637 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1638

1638:                                             ; preds = %.cont.cont.i1413, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122
  %.0566.i1393 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122 ], [ %1642, %.cont.cont.i1413 ]
  %.070565.i1394 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122 ], [ %1704, %.cont.cont.i1413 ]
  %.sroa.0.0564.i1395 = phi ptr [ %vptr.i142.sroa.speculated.i1310, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122 ], [ %vptr.i142.sroa.speculated.i1416, %.cont.cont.i1413 ]
  %.sroa.17.0561.i1398 = phi i32 [ %offset.i.i121.i1391, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122 ], [ %offset.i.i154.i1430, %.cont.cont.i1413 ]
  %1639 = phi <2 x i64> [ %1433, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2122 ], [ %1703, %.cont.cont.i1413 ]
  %1640 = extractelement <2 x i64> %1639, i64 1
  %.sroa.12.0562.i1397 = inttoptr i64 %1640 to ptr
  %1641 = extractelement <2 x i64> %1639, i64 0
  %.sroa.6.0563.i1396 = inttoptr i64 %1641 to ptr
  %1642 = add nuw nsw i32 %.0566.i1393, 1
  %1643 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1395, 0
  %1644 = insertvalue { ptr, ptr, ptr, i32 } %1643, ptr %.sroa.6.0563.i1396, 1
  %1645 = insertvalue { ptr, ptr, ptr, i32 } %1644, ptr %.sroa.12.0562.i1397, 2
  %1646 = insertvalue { ptr, ptr, ptr, i32 } %1645, i32 %.sroa.17.0561.i1398, 3
  %1647 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1395)
  %1648 = sext i32 %.sroa.17.0561.i1398 to i64
  %1649 = getelementptr ptr, ptr %.sroa.0.0564.i1395, i64 %1648
  %1650 = getelementptr i8, ptr %1649, i64 64
  %1651 = load ptr, ptr %1650, align 8
  %result.i125.i1399 = call ptr %1651({ ptr, ptr, ptr, i32 } %1646, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1652 = call i32 %result.i125.i1399({ ptr, ptr, ptr, i32 } %1646, { ptr, ptr, ptr, i32 } %1646, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1394, label %1653, label %1669

1653:                                             ; preds = %1638
  %1654 = load i32, ptr %34, align 8
  %1655 = add i32 %1654, -1
  %1656 = and i32 %1655, %1652
  %1657 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1658 = load ptr, ptr %35, align 8
  %1659 = sext i32 %1656 to i64
  %1660 = shl nsw i64 %1659, 5
  %1661 = getelementptr i8, ptr %1658, i64 %1660
  %1662 = load ptr, ptr %1661, align 8
  %1663 = getelementptr i8, ptr %1661, i64 8
  %1664 = load i160, ptr %1663, align 4
  store ptr %.sroa.0.0564.i1395, ptr %1661, align 8
  store i64 %1641, ptr %1663, align 4
  %.sroa_idx157.i1442 = getelementptr i8, ptr %1661, i64 16
  store i64 %1640, ptr %.sroa_idx157.i1442, align 4
  %.sroa_idx158.i1443 = getelementptr i8, ptr %1661, i64 24
  store i32 %.sroa.17.0561.i1398, ptr %.sroa_idx158.i1443, align 4
  %1665 = icmp ne ptr %1662, @nil_typ
  %1666 = icmp ne ptr %1662, null
  %.not92.i1444 = and i1 %1665, %1666
  %extract.i1446 = lshr i160 %1664, 64
  %1667 = insertelement <2 x i160> poison, i160 %1664, i64 0
  %1668 = insertelement <2 x i160> %1667, i160 %extract.i1446, i64 1
  br i1 %.not92.i1444, label %.cont.cont.i1413, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1448.thread

1669:                                             ; preds = %1638
  %1670 = add i32 %1652, 2127912214
  %1671 = shl i32 %1652, 12
  %1672 = add i32 %1670, %1671
  %1673 = ashr i32 %1672, 19
  %1674 = xor i32 %1672, %1673
  %1675 = xor i32 %1674, -949894596
  %1676 = add i32 %1675, 374761393
  %1677 = shl i32 %1675, 5
  %1678 = add i32 %1676, %1677
  %1679 = add i32 %1678, -744332180
  %1680 = shl i32 %1678, 9
  %1681 = xor i32 %1679, %1680
  %1682 = add i32 %1681, -42973499
  %1683 = shl i32 %1681, 3
  %1684 = add i32 %1682, %1683
  %1685 = ashr i32 %1684, 16
  %1686 = xor i32 %1684, %1685
  %1687 = xor i32 %1686, -1252372727
  %1688 = load i32, ptr %34, align 8
  %1689 = add i32 %1688, -1
  %1690 = and i32 %1689, %1687
  %1691 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1692 = load ptr, ptr %36, align 8
  %1693 = sext i32 %1690 to i64
  %1694 = shl nsw i64 %1693, 5
  %1695 = getelementptr i8, ptr %1692, i64 %1694
  %1696 = load ptr, ptr %1695, align 8
  %1697 = getelementptr i8, ptr %1695, i64 8
  %1698 = load i160, ptr %1697, align 4
  store ptr %.sroa.0.0564.i1395, ptr %1695, align 8
  store i64 %1641, ptr %1697, align 4
  %.sroa_idx161.i1403 = getelementptr i8, ptr %1695, i64 16
  store i64 %1640, ptr %.sroa_idx161.i1403, align 4
  %.sroa_idx162.i1404 = getelementptr i8, ptr %1695, i64 24
  store i32 %.sroa.17.0561.i1398, ptr %.sroa_idx162.i1404, align 4
  %1699 = icmp ne ptr %1696, @nil_typ
  %1700 = icmp ne ptr %1696, null
  %.not90.i1405 = and i1 %1699, %1700
  %extract607.i1407 = lshr i160 %1698, 64
  %1701 = insertelement <2 x i160> poison, i160 %1698, i64 0
  %1702 = insertelement <2 x i160> %1701, i160 %extract607.i1407, i64 1
  br i1 %.not90.i1405, label %.cont.cont.i1413, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1448.thread

.cont.cont.i1413:                                 ; preds = %1669, %1653
  %vptr.i142.sroa.speculated.i1416 = phi ptr [ %1662, %1653 ], [ %1696, %1669 ]
  %.in3136 = phi <2 x i160> [ %1668, %1653 ], [ %1702, %1669 ]
  %1703 = trunc <2 x i160> %.in3136 to <2 x i64>
  %1704 = xor i1 %.070565.i1394, true
  %hash_coef_ptr.i.i143.i1419 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1416, i64 8
  %tbl_size_ptr.i.i144.i1420 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1416, i64 16
  %offset_tbl_ptr.i.i145.i1421 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1416, i64 40
  %hash_coef.i.i146.i1422 = load i64, ptr %hash_coef_ptr.i.i143.i1419, align 4
  %tbl_size.i.i147.i1423 = load i64, ptr %tbl_size_ptr.i.i144.i1420, align 4
  %offset_tbl.i.i148.i1424 = load ptr, ptr %offset_tbl_ptr.i.i145.i1421, align 8
  %product.i.i.i149.i1425 = mul i64 %hash_coef.i.i146.i1422, 4015701072841558310
  %shifted.i.i.i150.i1426 = lshr i64 %product.i.i.i149.i1425, 32
  %xored.i.i.i151.i1427 = xor i64 %shifted.i.i.i150.i1426, %product.i.i.i149.i1425
  %hash.i.i.i152.i1428 = and i64 %xored.i.i.i151.i1427, %tbl_size.i.i147.i1423
  %offset_ptr.i.i153.i1429 = getelementptr i32, ptr %offset_tbl.i.i148.i1424, i64 %hash.i.i.i152.i1428
  %offset.i.i154.i1430 = load i32, ptr %offset_ptr.i.i153.i1429, align 4
  %1705 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1706 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1707 = icmp ult i32 %.0566.i1393, 99
  br i1 %1707, label %1638, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1448

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1448.thread: ; preds = %1653, %1669
  %1708 = phi ptr [ %20, %1669 ], [ %19, %1653 ]
  %1709 = load i32, ptr %988, align 4
  store i32 %1709, ptr %1708, align 4
  %1710 = add i32 %1709, 1
  %1711 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1710, ptr %988, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %CuckooMap_insert_keyK_valueV.exit712

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1448: ; preds = %.cont.cont.i1413
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  %1712 = icmp eq ptr %vptr.i142.sroa.speculated.i1416, null
  br i1 %1712, label %CuckooMap_insert_keyK_valueV.exit712, label %1713

1713:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1448
  %1714 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1715 = load ptr, ptr %35, align 8
  %1716 = load ptr, ptr %36, align 8
  %1717 = load i32, ptr %34, align 8
  %1718 = shl i32 %1717, 1
  %spec.select.i1464 = call i32 @llvm.smax.i32(i32 %1718, i32 16)
  store i32 %spec.select.i1464, ptr %34, align 8
  %1719 = zext nneg i32 %spec.select.i1464 to i64
  %1720 = shl nuw nsw i64 %1719, 5
  %result.i.i1465 = call noalias ptr @bump_malloc_inner(i64 noundef %1720, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1465, ptr %35, align 8
  %result.i20.i1466 = call noalias ptr @bump_malloc_inner(i64 noundef %1720, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1466, ptr %36, align 8
  store i32 0, ptr %988, align 4
  %1721 = icmp sgt i32 %1717, 0
  br i1 %1721, label %.lr.ph.i2152, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2185.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2185.thread: ; preds = %1713
  %1722 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit712

.lr.ph.i2152:                                     ; preds = %1713, %._crit_edge.i2167
  %.060.i2165 = phi i32 [ %1811, %._crit_edge.i2167 ], [ 0, %1713 ]
  %1723 = zext nneg i32 %.060.i2165 to i64
  %1724 = shl nuw nsw i64 %1723, 5
  %1725 = getelementptr i8, ptr %1715, i64 %1724
  %1726 = load ptr, ptr %1725, align 8
  %1727 = icmp ne ptr %1726, @nil_typ
  %1728 = icmp ne ptr %1726, null
  %.not16.i2166 = and i1 %1727, %1728
  br i1 %.not16.i2166, label %1729, label %._crit_edge.i2167

1729:                                             ; preds = %.lr.ph.i2152
  %1730 = getelementptr i8, ptr %1725, i64 8
  %1731 = load <2 x i64>, ptr %1730, align 4
  %hash_coef_ptr.i.i18.i2169 = getelementptr i8, ptr %1726, i64 8
  %tbl_size_ptr.i.i19.i2170 = getelementptr i8, ptr %1726, i64 16
  %offset_tbl_ptr.i.i20.i2171 = getelementptr i8, ptr %1726, i64 40
  %1732 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i2711 = load i64, ptr %hash_coef_ptr.i.i18.i2169, align 4, !noalias !22
  %tbl_size.i.i100.i2712 = load i64, ptr %tbl_size_ptr.i.i19.i2170, align 4, !noalias !22
  %offset_tbl.i.i101.i2713 = load ptr, ptr %offset_tbl_ptr.i.i20.i2171, align 8, !noalias !22
  %product.i.i.i102.i2714 = mul i64 %hash_coef.i.i99.i2711, 4015701072841558310
  %shifted.i.i.i103.i2715 = lshr i64 %product.i.i.i102.i2714, 32
  %xored.i.i.i104.i2716 = xor i64 %shifted.i.i.i103.i2715, %product.i.i.i102.i2714
  %hash.i.i.i105.i2717 = and i64 %xored.i.i.i104.i2716, %tbl_size.i.i100.i2712
  %offset_ptr.i.i106.i2718 = getelementptr i32, ptr %offset_tbl.i.i101.i2713, i64 %hash.i.i.i105.i2717
  %offset.i.i121.i2719 = load i32, ptr %offset_ptr.i.i106.i2718, align 4, !noalias !110
  %1733 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1734 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1735 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1736

1736:                                             ; preds = %.cont.cont.i2740, %1729
  %.0566.i2720 = phi i32 [ 0, %1729 ], [ %1740, %.cont.cont.i2740 ]
  %.070565.i2721 = phi i1 [ true, %1729 ], [ %1802, %.cont.cont.i2740 ]
  %.sroa.0.0564.i2722 = phi ptr [ %1726, %1729 ], [ %vptr.i142.sroa.speculated.i2743, %.cont.cont.i2740 ]
  %.sroa.17.0561.i2725 = phi i32 [ %offset.i.i121.i2719, %1729 ], [ %offset.i.i154.i2757, %.cont.cont.i2740 ]
  %1737 = phi <2 x i64> [ %1731, %1729 ], [ %1801, %.cont.cont.i2740 ]
  %1738 = extractelement <2 x i64> %1737, i64 1
  %.sroa.12.0562.i2724 = inttoptr i64 %1738 to ptr
  %1739 = extractelement <2 x i64> %1737, i64 0
  %.sroa.6.0563.i2723 = inttoptr i64 %1739 to ptr
  %1740 = add nuw nsw i32 %.0566.i2720, 1
  %1741 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2722, 0
  %1742 = insertvalue { ptr, ptr, ptr, i32 } %1741, ptr %.sroa.6.0563.i2723, 1
  %1743 = insertvalue { ptr, ptr, ptr, i32 } %1742, ptr %.sroa.12.0562.i2724, 2
  %1744 = insertvalue { ptr, ptr, ptr, i32 } %1743, i32 %.sroa.17.0561.i2725, 3
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2722)
  %1746 = sext i32 %.sroa.17.0561.i2725 to i64
  %1747 = getelementptr ptr, ptr %.sroa.0.0564.i2722, i64 %1746
  %1748 = getelementptr i8, ptr %1747, i64 64
  %1749 = load ptr, ptr %1748, align 8
  %result.i125.i2726 = call ptr %1749({ ptr, ptr, ptr, i32 } %1744, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1750 = call i32 %result.i125.i2726({ ptr, ptr, ptr, i32 } %1744, { ptr, ptr, ptr, i32 } %1744, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2721, label %1751, label %1767

1751:                                             ; preds = %1736
  %1752 = load i32, ptr %34, align 8
  %1753 = add i32 %1752, -1
  %1754 = and i32 %1753, %1750
  %1755 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1756 = load ptr, ptr %35, align 8
  %1757 = sext i32 %1754 to i64
  %1758 = shl nsw i64 %1757, 5
  %1759 = getelementptr i8, ptr %1756, i64 %1758
  %1760 = load ptr, ptr %1759, align 8
  %1761 = getelementptr i8, ptr %1759, i64 8
  %1762 = load i160, ptr %1761, align 4
  store ptr %.sroa.0.0564.i2722, ptr %1759, align 8
  store i64 %1739, ptr %1761, align 4
  %.sroa_idx157.i2769 = getelementptr i8, ptr %1759, i64 16
  store i64 %1738, ptr %.sroa_idx157.i2769, align 4
  %.sroa_idx158.i2770 = getelementptr i8, ptr %1759, i64 24
  store i32 %.sroa.17.0561.i2725, ptr %.sroa_idx158.i2770, align 4
  %1763 = icmp ne ptr %1760, @nil_typ
  %1764 = icmp ne ptr %1760, null
  %.not92.i2771 = and i1 %1763, %1764
  %extract.i2773 = lshr i160 %1762, 64
  %1765 = insertelement <2 x i160> poison, i160 %1762, i64 0
  %1766 = insertelement <2 x i160> %1765, i160 %extract.i2773, i64 1
  br i1 %.not92.i2771, label %.cont.cont.i2740, label %1806

1767:                                             ; preds = %1736
  %1768 = add i32 %1750, 2127912214
  %1769 = shl i32 %1750, 12
  %1770 = add i32 %1768, %1769
  %1771 = ashr i32 %1770, 19
  %1772 = xor i32 %1770, %1771
  %1773 = xor i32 %1772, -949894596
  %1774 = add i32 %1773, 374761393
  %1775 = shl i32 %1773, 5
  %1776 = add i32 %1774, %1775
  %1777 = add i32 %1776, -744332180
  %1778 = shl i32 %1776, 9
  %1779 = xor i32 %1777, %1778
  %1780 = add i32 %1779, -42973499
  %1781 = shl i32 %1779, 3
  %1782 = add i32 %1780, %1781
  %1783 = ashr i32 %1782, 16
  %1784 = xor i32 %1782, %1783
  %1785 = xor i32 %1784, -1252372727
  %1786 = load i32, ptr %34, align 8
  %1787 = add i32 %1786, -1
  %1788 = and i32 %1787, %1785
  %1789 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1790 = load ptr, ptr %36, align 8
  %1791 = sext i32 %1788 to i64
  %1792 = shl nsw i64 %1791, 5
  %1793 = getelementptr i8, ptr %1790, i64 %1792
  %1794 = load ptr, ptr %1793, align 8
  %1795 = getelementptr i8, ptr %1793, i64 8
  %1796 = load i160, ptr %1795, align 4
  store ptr %.sroa.0.0564.i2722, ptr %1793, align 8
  store i64 %1739, ptr %1795, align 4
  %.sroa_idx161.i2730 = getelementptr i8, ptr %1793, i64 16
  store i64 %1738, ptr %.sroa_idx161.i2730, align 4
  %.sroa_idx162.i2731 = getelementptr i8, ptr %1793, i64 24
  store i32 %.sroa.17.0561.i2725, ptr %.sroa_idx162.i2731, align 4
  %1797 = icmp ne ptr %1794, @nil_typ
  %1798 = icmp ne ptr %1794, null
  %.not90.i2732 = and i1 %1797, %1798
  %extract607.i2734 = lshr i160 %1796, 64
  %1799 = insertelement <2 x i160> poison, i160 %1796, i64 0
  %1800 = insertelement <2 x i160> %1799, i160 %extract607.i2734, i64 1
  br i1 %.not90.i2732, label %.cont.cont.i2740, label %1806

.cont.cont.i2740:                                 ; preds = %1767, %1751
  %vptr.i142.sroa.speculated.i2743 = phi ptr [ %1760, %1751 ], [ %1794, %1767 ]
  %.in3137 = phi <2 x i160> [ %1766, %1751 ], [ %1800, %1767 ]
  %1801 = trunc <2 x i160> %.in3137 to <2 x i64>
  %1802 = xor i1 %.070565.i2721, true
  %hash_coef_ptr.i.i143.i2746 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2743, i64 8
  %tbl_size_ptr.i.i144.i2747 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2743, i64 16
  %offset_tbl_ptr.i.i145.i2748 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2743, i64 40
  %hash_coef.i.i146.i2749 = load i64, ptr %hash_coef_ptr.i.i143.i2746, align 4
  %tbl_size.i.i147.i2750 = load i64, ptr %tbl_size_ptr.i.i144.i2747, align 4
  %offset_tbl.i.i148.i2751 = load ptr, ptr %offset_tbl_ptr.i.i145.i2748, align 8
  %product.i.i.i149.i2752 = mul i64 %hash_coef.i.i146.i2749, 4015701072841558310
  %shifted.i.i.i150.i2753 = lshr i64 %product.i.i.i149.i2752, 32
  %xored.i.i.i151.i2754 = xor i64 %shifted.i.i.i150.i2753, %product.i.i.i149.i2752
  %hash.i.i.i152.i2755 = and i64 %xored.i.i.i151.i2754, %tbl_size.i.i147.i2750
  %offset_ptr.i.i153.i2756 = getelementptr i32, ptr %offset_tbl.i.i148.i2751, i64 %hash.i.i.i152.i2755
  %offset.i.i154.i2757 = load i32, ptr %offset_ptr.i.i153.i2756, align 4
  %1803 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1804 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1805 = icmp ult i32 %.0566.i2720, 99
  br i1 %1805, label %1736, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2775

1806:                                             ; preds = %1767, %1751
  %1807 = phi ptr [ %6, %1767 ], [ %5, %1751 ]
  %1808 = load i32, ptr %988, align 4
  store i32 %1808, ptr %1807, align 4
  %1809 = add i32 %1808, 1
  %1810 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1809, ptr %988, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2775

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2775: ; preds = %.cont.cont.i2740, %1806
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i2167

._crit_edge.i2167:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2775, %.lr.ph.i2152
  %1811 = add nuw nsw i32 %.060.i2165, 1
  %1812 = icmp slt i32 %1811, %1717
  br i1 %1812, label %.lr.ph.i2152, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2185

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2185: ; preds = %._crit_edge.i2167
  %1813 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %1814

1814:                                             ; preds = %._crit_edge.i2203, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2185
  %.060.i2201 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2185 ], [ %1903, %._crit_edge.i2203 ]
  %1815 = zext nneg i32 %.060.i2201 to i64
  %1816 = shl nuw nsw i64 %1815, 5
  %1817 = getelementptr i8, ptr %1716, i64 %1816
  %1818 = load ptr, ptr %1817, align 8
  %1819 = icmp ne ptr %1818, @nil_typ
  %1820 = icmp ne ptr %1818, null
  %.not16.i2202 = and i1 %1819, %1820
  br i1 %.not16.i2202, label %1821, label %._crit_edge.i2203

1821:                                             ; preds = %1814
  %1822 = getelementptr i8, ptr %1817, i64 8
  %1823 = load <2 x i64>, ptr %1822, align 4
  %hash_coef_ptr.i.i18.i2205 = getelementptr i8, ptr %1818, i64 8
  %tbl_size_ptr.i.i19.i2206 = getelementptr i8, ptr %1818, i64 16
  %offset_tbl_ptr.i.i20.i2207 = getelementptr i8, ptr %1818, i64 40
  %1824 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i2793 = load i64, ptr %hash_coef_ptr.i.i18.i2205, align 4, !noalias !22
  %tbl_size.i.i100.i2794 = load i64, ptr %tbl_size_ptr.i.i19.i2206, align 4, !noalias !22
  %offset_tbl.i.i101.i2795 = load ptr, ptr %offset_tbl_ptr.i.i20.i2207, align 8, !noalias !22
  %product.i.i.i102.i2796 = mul i64 %hash_coef.i.i99.i2793, 4015701072841558310
  %shifted.i.i.i103.i2797 = lshr i64 %product.i.i.i102.i2796, 32
  %xored.i.i.i104.i2798 = xor i64 %shifted.i.i.i103.i2797, %product.i.i.i102.i2796
  %hash.i.i.i105.i2799 = and i64 %xored.i.i.i104.i2798, %tbl_size.i.i100.i2794
  %offset_ptr.i.i106.i2800 = getelementptr i32, ptr %offset_tbl.i.i101.i2795, i64 %hash.i.i.i105.i2799
  %offset.i.i121.i2801 = load i32, ptr %offset_ptr.i.i106.i2800, align 4, !noalias !113
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1826 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1827 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1828

1828:                                             ; preds = %.cont.cont.i2822, %1821
  %.0566.i2802 = phi i32 [ 0, %1821 ], [ %1832, %.cont.cont.i2822 ]
  %.070565.i2803 = phi i1 [ true, %1821 ], [ %1894, %.cont.cont.i2822 ]
  %.sroa.0.0564.i2804 = phi ptr [ %1818, %1821 ], [ %vptr.i142.sroa.speculated.i2825, %.cont.cont.i2822 ]
  %.sroa.17.0561.i2807 = phi i32 [ %offset.i.i121.i2801, %1821 ], [ %offset.i.i154.i2839, %.cont.cont.i2822 ]
  %1829 = phi <2 x i64> [ %1823, %1821 ], [ %1893, %.cont.cont.i2822 ]
  %1830 = extractelement <2 x i64> %1829, i64 1
  %.sroa.12.0562.i2806 = inttoptr i64 %1830 to ptr
  %1831 = extractelement <2 x i64> %1829, i64 0
  %.sroa.6.0563.i2805 = inttoptr i64 %1831 to ptr
  %1832 = add nuw nsw i32 %.0566.i2802, 1
  %1833 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2804, 0
  %1834 = insertvalue { ptr, ptr, ptr, i32 } %1833, ptr %.sroa.6.0563.i2805, 1
  %1835 = insertvalue { ptr, ptr, ptr, i32 } %1834, ptr %.sroa.12.0562.i2806, 2
  %1836 = insertvalue { ptr, ptr, ptr, i32 } %1835, i32 %.sroa.17.0561.i2807, 3
  %1837 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2804)
  %1838 = sext i32 %.sroa.17.0561.i2807 to i64
  %1839 = getelementptr ptr, ptr %.sroa.0.0564.i2804, i64 %1838
  %1840 = getelementptr i8, ptr %1839, i64 64
  %1841 = load ptr, ptr %1840, align 8
  %result.i125.i2808 = call ptr %1841({ ptr, ptr, ptr, i32 } %1836, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1842 = call i32 %result.i125.i2808({ ptr, ptr, ptr, i32 } %1836, { ptr, ptr, ptr, i32 } %1836, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2803, label %1843, label %1859

1843:                                             ; preds = %1828
  %1844 = load i32, ptr %34, align 8
  %1845 = add i32 %1844, -1
  %1846 = and i32 %1845, %1842
  %1847 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1848 = load ptr, ptr %35, align 8
  %1849 = sext i32 %1846 to i64
  %1850 = shl nsw i64 %1849, 5
  %1851 = getelementptr i8, ptr %1848, i64 %1850
  %1852 = load ptr, ptr %1851, align 8
  %1853 = getelementptr i8, ptr %1851, i64 8
  %1854 = load i160, ptr %1853, align 4
  store ptr %.sroa.0.0564.i2804, ptr %1851, align 8
  store i64 %1831, ptr %1853, align 4
  %.sroa_idx157.i2851 = getelementptr i8, ptr %1851, i64 16
  store i64 %1830, ptr %.sroa_idx157.i2851, align 4
  %.sroa_idx158.i2852 = getelementptr i8, ptr %1851, i64 24
  store i32 %.sroa.17.0561.i2807, ptr %.sroa_idx158.i2852, align 4
  %1855 = icmp ne ptr %1852, @nil_typ
  %1856 = icmp ne ptr %1852, null
  %.not92.i2853 = and i1 %1855, %1856
  %extract.i2855 = lshr i160 %1854, 64
  %1857 = insertelement <2 x i160> poison, i160 %1854, i64 0
  %1858 = insertelement <2 x i160> %1857, i160 %extract.i2855, i64 1
  br i1 %.not92.i2853, label %.cont.cont.i2822, label %1898

1859:                                             ; preds = %1828
  %1860 = add i32 %1842, 2127912214
  %1861 = shl i32 %1842, 12
  %1862 = add i32 %1860, %1861
  %1863 = ashr i32 %1862, 19
  %1864 = xor i32 %1862, %1863
  %1865 = xor i32 %1864, -949894596
  %1866 = add i32 %1865, 374761393
  %1867 = shl i32 %1865, 5
  %1868 = add i32 %1866, %1867
  %1869 = add i32 %1868, -744332180
  %1870 = shl i32 %1868, 9
  %1871 = xor i32 %1869, %1870
  %1872 = add i32 %1871, -42973499
  %1873 = shl i32 %1871, 3
  %1874 = add i32 %1872, %1873
  %1875 = ashr i32 %1874, 16
  %1876 = xor i32 %1874, %1875
  %1877 = xor i32 %1876, -1252372727
  %1878 = load i32, ptr %34, align 8
  %1879 = add i32 %1878, -1
  %1880 = and i32 %1879, %1877
  %1881 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1882 = load ptr, ptr %36, align 8
  %1883 = sext i32 %1880 to i64
  %1884 = shl nsw i64 %1883, 5
  %1885 = getelementptr i8, ptr %1882, i64 %1884
  %1886 = load ptr, ptr %1885, align 8
  %1887 = getelementptr i8, ptr %1885, i64 8
  %1888 = load i160, ptr %1887, align 4
  store ptr %.sroa.0.0564.i2804, ptr %1885, align 8
  store i64 %1831, ptr %1887, align 4
  %.sroa_idx161.i2812 = getelementptr i8, ptr %1885, i64 16
  store i64 %1830, ptr %.sroa_idx161.i2812, align 4
  %.sroa_idx162.i2813 = getelementptr i8, ptr %1885, i64 24
  store i32 %.sroa.17.0561.i2807, ptr %.sroa_idx162.i2813, align 4
  %1889 = icmp ne ptr %1886, @nil_typ
  %1890 = icmp ne ptr %1886, null
  %.not90.i2814 = and i1 %1889, %1890
  %extract607.i2816 = lshr i160 %1888, 64
  %1891 = insertelement <2 x i160> poison, i160 %1888, i64 0
  %1892 = insertelement <2 x i160> %1891, i160 %extract607.i2816, i64 1
  br i1 %.not90.i2814, label %.cont.cont.i2822, label %1898

.cont.cont.i2822:                                 ; preds = %1859, %1843
  %vptr.i142.sroa.speculated.i2825 = phi ptr [ %1852, %1843 ], [ %1886, %1859 ]
  %.in3138 = phi <2 x i160> [ %1858, %1843 ], [ %1892, %1859 ]
  %1893 = trunc <2 x i160> %.in3138 to <2 x i64>
  %1894 = xor i1 %.070565.i2803, true
  %hash_coef_ptr.i.i143.i2828 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2825, i64 8
  %tbl_size_ptr.i.i144.i2829 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2825, i64 16
  %offset_tbl_ptr.i.i145.i2830 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2825, i64 40
  %hash_coef.i.i146.i2831 = load i64, ptr %hash_coef_ptr.i.i143.i2828, align 4
  %tbl_size.i.i147.i2832 = load i64, ptr %tbl_size_ptr.i.i144.i2829, align 4
  %offset_tbl.i.i148.i2833 = load ptr, ptr %offset_tbl_ptr.i.i145.i2830, align 8
  %product.i.i.i149.i2834 = mul i64 %hash_coef.i.i146.i2831, 4015701072841558310
  %shifted.i.i.i150.i2835 = lshr i64 %product.i.i.i149.i2834, 32
  %xored.i.i.i151.i2836 = xor i64 %shifted.i.i.i150.i2835, %product.i.i.i149.i2834
  %hash.i.i.i152.i2837 = and i64 %xored.i.i.i151.i2836, %tbl_size.i.i147.i2832
  %offset_ptr.i.i153.i2838 = getelementptr i32, ptr %offset_tbl.i.i148.i2833, i64 %hash.i.i.i152.i2837
  %offset.i.i154.i2839 = load i32, ptr %offset_ptr.i.i153.i2838, align 4
  %1895 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1896 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1897 = icmp ult i32 %.0566.i2802, 99
  br i1 %1897, label %1828, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2857

1898:                                             ; preds = %1859, %1843
  %1899 = phi ptr [ %4, %1859 ], [ %3, %1843 ]
  %1900 = load i32, ptr %988, align 4
  store i32 %1900, ptr %1899, align 4
  %1901 = add i32 %1900, 1
  %1902 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1901, ptr %988, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2857

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2857: ; preds = %.cont.cont.i2822, %1898
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i2203

._crit_edge.i2203:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2857, %1814
  %1903 = add nuw nsw i32 %.060.i2201, 1
  %1904 = icmp slt i32 %1903, %1717
  br i1 %1904, label %1814, label %CuckooMap_insert_keyK_valueV.exit712

CuckooMap_insert_keyK_valueV.exit712:             ; preds = %._crit_edge.i2203, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2185.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1448.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1342.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1236, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1177, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1342, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1448
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1905 = add nuw nsw i32 %.2249465, 1
  %1906 = icmp slt i32 %1905, %0
  br i1 %1906, label %._crit_edge3, label %._crit_edge5

._crit_edge5:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit712
  %1907 = call i64 @clock()
  %.sroa.0202.0.insert.ext = zext i32 %spec.select to i160
  %1908 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0202.0.insert.ext, 1
  %1909 = load ptr, ptr %32, align 8
  %1910 = call i32 %1909({ ptr, i160 } %1908) #7
  %1911 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %1912 = load i32, ptr %34, align 8
  %1913 = add i32 %1912, -1
  %1914 = and i32 %1913, %1910
  %1915 = load ptr, ptr %35, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1916 = sext i32 %1914 to i64
  %1917 = shl nsw i64 %1916, 5
  %1918 = getelementptr i8, ptr %1915, i64 %1917
  %1919 = load ptr, ptr %1918, align 8
  %1920 = icmp ne ptr %1919, @nil_typ
  %1921 = icmp ne ptr %1919, null
  %.not44.i = and i1 %1920, %1921
  br i1 %.not44.i, label %1922, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

1922:                                             ; preds = %._crit_edge5
  %1923 = getelementptr i8, ptr %1918, i64 8
  %1924 = load i64, ptr %1923, align 4
  %.sroa_idx.i1511 = getelementptr i8, ptr %1918, i64 16
  %1925 = load i64, ptr %.sroa_idx.i1511, align 4
  %1926 = inttoptr i64 %1924 to ptr
  %1927 = inttoptr i64 %1925 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %1919, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %1919, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %1919, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !116
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !116
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !116
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !116
  %1928 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1919, 0
  %1929 = insertvalue { ptr, ptr, ptr, i32 } %1928, ptr %1926, 1
  %1930 = insertvalue { ptr, ptr, ptr, i32 } %1929, ptr %1927, 2
  %1931 = insertvalue { ptr, ptr, ptr, i32 } %1930, i32 %offset.i.i57.i, 3
  %1932 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1933 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1919) #35
  %1934 = sext i32 %offset.i.i57.i to i64
  %1935 = getelementptr ptr, ptr %1919, i64 %1934
  %1936 = getelementptr i8, ptr %1935, i64 64
  %1937 = load ptr, ptr %1936, align 8
  %result.i.i1512 = call ptr %1937({ ptr, ptr, ptr, i32 } %1931, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1938 = call i32 %result.i.i1512({ ptr, ptr, ptr, i32 } %1931, { ptr, ptr, ptr, i32 } %1931, ptr nonnull align 8 %2) #7
  %1939 = icmp eq i32 %1938, %1910
  br i1 %1939, label %._crit_edge.i1513, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i1513:                                ; preds = %1922
  %1940 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1941 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1919)
  %1942 = getelementptr i8, ptr %1935, i64 48
  %1943 = load ptr, ptr %1942, align 8
  %result.i59.i = call ptr %1943({ ptr, ptr, ptr, i32 } %1931, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1944 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %1931, { ptr, ptr, ptr, i32 } %1931, ptr nonnull align 8 %2) #7
  %1945 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1946 = load ptr, ptr %33, align 8
  %1947 = call i1 %1946({ ptr, i160 } %1944, { ptr, i160 } %1908) #7
  br i1 %1947, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i1513, %._crit_edge5, %1922
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %1955

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1513
  %1948 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1949 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1919)
  %1950 = getelementptr i8, ptr %1935, i64 56
  %1951 = load ptr, ptr %1950, align 8
  %result.i60.i = call ptr %1951({ ptr, ptr, ptr, i32 } %1931, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1952 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %1931, { ptr, ptr, ptr, i32 } %1931, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %1952, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1953 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %1954 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %1953, %1954
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %1955

1955:                                             ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %1956 = add i32 %1910, 2127912214
  %1957 = shl i32 %1910, 12
  %1958 = add i32 %1956, %1957
  %1959 = ashr i32 %1958, 19
  %1960 = xor i32 %1958, %1959
  %1961 = xor i32 %1960, -949894596
  %1962 = add i32 %1961, 374761393
  %1963 = shl i32 %1961, 5
  %1964 = add i32 %1962, %1963
  %1965 = add i32 %1964, -744332180
  %1966 = shl i32 %1964, 9
  %1967 = xor i32 %1965, %1966
  %1968 = add i32 %1967, -42973499
  %1969 = shl i32 %1967, 3
  %1970 = add i32 %1968, %1969
  %1971 = ashr i32 %1970, 16
  %1972 = xor i32 %1970, %1971
  %1973 = xor i32 %1972, -1252372727
  %1974 = load i32, ptr %34, align 8
  %1975 = add i32 %1974, -1
  %1976 = and i32 %1975, %1973
  %1977 = load ptr, ptr %36, align 8
  %1978 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1979 = sext i32 %1976 to i64
  %1980 = shl nsw i64 %1979, 5
  %1981 = getelementptr i8, ptr %1977, i64 %1980
  %1982 = load ptr, ptr %1981, align 8
  %1983 = icmp ne ptr %1982, @nil_typ
  %1984 = icmp ne ptr %1982, null
  %.not44.i1543 = and i1 %1983, %1984
  br i1 %.not44.i1543, label %1985, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1567

1985:                                             ; preds = %1955
  %1986 = getelementptr i8, ptr %1981, i64 8
  %1987 = load i64, ptr %1986, align 4
  %.sroa_idx.i1547 = getelementptr i8, ptr %1981, i64 16
  %1988 = load i64, ptr %.sroa_idx.i1547, align 4
  %1989 = inttoptr i64 %1987 to ptr
  %1990 = inttoptr i64 %1988 to ptr
  %hash_coef_ptr.i.i46.i1548 = getelementptr i8, ptr %1982, i64 8
  %tbl_size_ptr.i.i47.i1549 = getelementptr i8, ptr %1982, i64 16
  %offset_tbl_ptr.i.i48.i1550 = getelementptr i8, ptr %1982, i64 40
  %hash_coef.i.i49.i1551 = load i64, ptr %hash_coef_ptr.i.i46.i1548, align 4, !noalias !119
  %tbl_size.i.i50.i1552 = load i64, ptr %tbl_size_ptr.i.i47.i1549, align 4, !noalias !119
  %offset_tbl.i.i51.i1553 = load ptr, ptr %offset_tbl_ptr.i.i48.i1550, align 8, !noalias !119
  %product.i.i.i52.i1554 = mul i64 %hash_coef.i.i49.i1551, 4015701072841558310
  %shifted.i.i.i53.i1555 = lshr i64 %product.i.i.i52.i1554, 32
  %xored.i.i.i54.i1556 = xor i64 %shifted.i.i.i53.i1555, %product.i.i.i52.i1554
  %hash.i.i.i55.i1557 = and i64 %xored.i.i.i54.i1556, %tbl_size.i.i50.i1552
  %offset_ptr.i.i56.i1558 = getelementptr i32, ptr %offset_tbl.i.i51.i1553, i64 %hash.i.i.i55.i1557
  %offset.i.i57.i1559 = load i32, ptr %offset_ptr.i.i56.i1558, align 4, !noalias !119
  %1991 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1982, 0
  %1992 = insertvalue { ptr, ptr, ptr, i32 } %1991, ptr %1989, 1
  %1993 = insertvalue { ptr, ptr, ptr, i32 } %1992, ptr %1990, 2
  %1994 = insertvalue { ptr, ptr, ptr, i32 } %1993, i32 %offset.i.i57.i1559, 3
  %1995 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1996 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1982) #35
  %1997 = sext i32 %offset.i.i57.i1559 to i64
  %1998 = getelementptr ptr, ptr %1982, i64 %1997
  %1999 = getelementptr i8, ptr %1998, i64 64
  %2000 = load ptr, ptr %1999, align 8
  %result.i.i1560 = call ptr %2000({ ptr, ptr, ptr, i32 } %1994, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2001 = call i32 %result.i.i1560({ ptr, ptr, ptr, i32 } %1994, { ptr, ptr, ptr, i32 } %1994, ptr nonnull align 8 %2) #7
  %2002 = icmp eq i32 %2001, %1910
  br i1 %2002, label %._crit_edge.i1561, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1567

._crit_edge.i1561:                                ; preds = %1985
  %2003 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2004 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1982)
  %2005 = getelementptr i8, ptr %1998, i64 48
  %2006 = load ptr, ptr %2005, align 8
  %result.i59.i1562 = call ptr %2006({ ptr, ptr, ptr, i32 } %1994, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2007 = call { ptr, i160 } %result.i59.i1562({ ptr, ptr, ptr, i32 } %1994, { ptr, ptr, ptr, i32 } %1994, ptr nonnull align 8 %2) #7
  %2008 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2009 = load ptr, ptr %33, align 8
  %2010 = call i1 %2009({ ptr, i160 } %2007, { ptr, i160 } %1908) #7
  br i1 %2010, label %2011, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1567

2011:                                             ; preds = %._crit_edge.i1561
  %2012 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2013 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1982)
  %2014 = getelementptr i8, ptr %1998, i64 56
  %2015 = load ptr, ptr %2014, align 8
  %result.i60.i1564 = call ptr %2015({ ptr, ptr, ptr, i32 } %1994, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2016 = call { ptr, i160 } %result.i60.i1564({ ptr, ptr, ptr, i32 } %1994, { ptr, ptr, ptr, i32 } %1994, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1565 = extractvalue { ptr, i160 } %2016, 0
  %.fca.1.extract22.i1566 = extractvalue { ptr, i160 } %2016, 1
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1567

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1567: ; preds = %1955, %1985, %._crit_edge.i1561, %2011
  %.reg2mem43.sroa.3.077.i1544 = phi i160 [ %.fca.1.extract22.i1566, %2011 ], [ poison, %._crit_edge.i1561 ], [ poison, %1955 ], [ poison, %1985 ]
  %2017 = phi ptr [ %.fca.0.extract21.i1565, %2011 ], [ @nil_typ, %._crit_edge.i1561 ], [ @nil_typ, %1955 ], [ @nil_typ, %1985 ]
  %.reload40.fca.0.insert.i1545 = insertvalue { ptr, i160 } poison, ptr %2017, 0
  %.reload40.fca.1.insert.i1546 = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i1545, i160 %.reg2mem43.sroa.3.077.i1544, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2018 = icmp ne ptr %2017, @nil_typ
  %2019 = icmp ne ptr %2017, null
  %.not65.not.not.i = and i1 %2018, %2019
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %2017, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1567
  %.pn.i = phi { ptr, i160 } [ %1952, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %.reload40.fca.1.insert.i1546, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1567 ]
  %2020 = phi ptr [ %.fca.0.extract21.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1567 ]
  %2021 = icmp ne ptr %2020, @nil_typ
  %2022 = icmp ne ptr %2020, null
  %.not260 = and i1 %2021, %2022
  br i1 %.not260, label %._crit_edge6, label %._crit_edge7

._crit_edge6:                                     ; preds = %CuckooMap_get_keyK.exit
  %.fca.1.extract..sroa.354.0106.i = extractvalue { ptr, i160 } %.pn.i, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0106.i to i32
  %2023 = add i32 %spec.select, 1
  %.not264 = icmp eq i32 %2023, %.sroa.2.8.extract.trunc
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %CuckooMap_get_keyK.exit, %._crit_edge6
  %.2252 = phi i1 [ %.not264, %._crit_edge6 ], [ false, %CuckooMap_get_keyK.exit ]
  %2024 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2025 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %2026 = load i32, ptr %988, align 4
  %.not265 = icmp eq i32 %2026, %985
  %2027 = select i1 %.not265, i1 %.2252, i1 false
  %2028 = select i1 %2027, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge2._crit_edge.thread, %._crit_edge7
  %2029 = phi i64 [ %986, %._crit_edge7 ], [ %54, %._crit_edge2._crit_edge.thread ]
  %2030 = phi i32 [ %985, %._crit_edge7 ], [ 0, %._crit_edge2._crit_edge.thread ]
  %2031 = phi i64 [ %1907, %._crit_edge7 ], [ %55, %._crit_edge2._crit_edge.thread ]
  %.reg2mem21.0.in = phi <4 x i8> [ %2028, %._crit_edge7 ], [ <i8 80, i8 65, i8 83, i8 83>, %._crit_edge2._crit_edge.thread ]
  %result.i344 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i344, align 16
  %2032 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2033 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2034 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1581 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i1581, ptr noundef nonnull align 16 dereferenceable(13) %result.i344, i64 13, i1 false)
  %2035 = sub i64 %2031, %2029
  %2036 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2037 = getelementptr i8, ptr %result.i.i1581, i64 13
  store i8 0, ptr %2037, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1581)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i98.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98.i, align 16
  %result.i.i356.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i98.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356.i)
  %2038 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #17
  %result.i104.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104.i, align 16
  %result.i.i370.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i104.i, i64 14, i1 false)
  %puts.i294.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370.i)
  %2039 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2035) #17
  %result.i110.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110.i, align 4
  %result.i.i389.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i110.i, i64 3, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  br i1 %51, label %._crit_edge1.i, label %._crit_edge.lr.ph.i1597

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i
  %2040 = icmp sgt i64 %2035, 0
  br i1 %2040, label %2041, label %._crit_edge.lr.ph.i409.i

2041:                                             ; preds = %._crit_edge1.i
  %2042 = mul i64 %2035, 1000000
  %2043 = zext nneg i32 %0 to i64
  %2044 = sdiv i64 %2042, %2043
  br label %._crit_edge.lr.ph.i409.i

._crit_edge.lr.ph.i409.i:                         ; preds = %2041, %._crit_edge1.i
  %.0.i = phi i64 [ %2044, %2041 ], [ 0, %._crit_edge1.i ]
  %result.i115.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115.i, align 16
  %result.i.i408.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i115.i, i64 15, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  %2045 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i121.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121.i, align 4
  %result.i.i427.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i121.i, i64 3, i1 false)
  %2046 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  br label %._crit_edge.lr.ph.i1597

._crit_edge.lr.ph.i1597:                          ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i409.i
  %result.i348 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i348, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2047 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2048 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1596 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i1596, ptr noundef nonnull align 32 dereferenceable(18) %result.i348, i64 18, i1 false)
  %2049 = getelementptr i8, ptr %result.i.i1596, i64 18
  store i8 0, ptr %2049, align 1
  %puts.i790 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1596)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2050 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2051 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1615 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <4 x i8> %.reg2mem21.0.in, ptr %result.i.i1615, align 1
  %2052 = getelementptr i8, ptr %result.i.i1615, i64 4
  store i8 0, ptr %2052, align 1
  %puts.i810 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1615)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i363 = call noalias align 32 dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %result.i363, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2053 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2054 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1634 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(27) %result.i.i1634, ptr noundef nonnull align 32 dereferenceable(27) %result.i363, i64 27, i1 false)
  %2055 = getelementptr i8, ptr %result.i.i1634, i64 27
  store i8 0, ptr %2055, align 1
  %puts.i830 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1634)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2056 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %2030) #17
  %2057 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2058 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2059 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1653 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store i8 41, ptr %result.i.i1653, align 1
  %2060 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2061 = getelementptr i8, ptr %result.i.i1653, i64 1
  store i8 0, ptr %2061, align 1
  %puts.i850 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1653)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %oldProtect.i155 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %result.i151 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i151, align 8
  %15 = getelementptr inbounds i8, ptr %result.i151, i64 8
  store ptr @_parameterization_Ptri32, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i151, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i151) #39
  %result.i152 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i153 = call i32 @VirtualProtect(ptr nofree %result.i152, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i152, ptr noalias nofree noundef nonnull readnone @svlbjxscwh, ptr noalias nofree noundef nonnull readnone @i32_hasher) #39
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i152) #40
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i152) #39
  %result.i154 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i155)
  %result.i156 = call i32 @VirtualProtect(ptr nofree %result.i154, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i155) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i155)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i154, ptr noalias nofree noundef nonnull readnone @krjmirxnlg, ptr noalias nofree noundef nonnull readnone @i32_eq) #39
  %ret.i157 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i154) #40
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i154) #39
  %20 = getelementptr inbounds i8, ptr %result.i151, i64 48
  store ptr %ret.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i151, i64 56
  store ptr %ret.i157, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i151, i64 40
  store i32 8, ptr %22, align 8
  %result.i.i261 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %23 = getelementptr inbounds i8, ptr %result.i151, i64 24
  store ptr %result.i.i261, ptr %23, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %24 = getelementptr inbounds i8, ptr %result.i151, i64 32
  store ptr %result.i9.i, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %26 = icmp sgt i32 %0, 0
  br i1 %26, label %._crit_edge.preheader, label %._crit_edge1._crit_edge.thread

._crit_edge.preheader:                            ; preds = %1
  %27 = getelementptr inbounds i8, ptr %result.i151, i64 44
  %28 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i151, 1
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr undef, 2
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, i32 10, 3
  br label %._crit_edge

._crit_edge1._crit_edge.thread:                   ; preds = %1
  %31 = call i64 @clock()
  br label %._crit_edge.lr.ph.i802

._crit_edge:                                      ; preds = %._crit_edge.preheader, %CuckooMap_insert_keyK_valueV.exit
  %.0251 = phi i32 [ %32, %CuckooMap_insert_keyK_valueV.exit ], [ 0, %._crit_edge.preheader ]
  %.0139250 = phi i64 [ %941, %CuckooMap_insert_keyK_valueV.exit ], [ 0, %._crit_edge.preheader ]
  %32 = add nuw nsw i32 %.0251, 1
  %.sroa.0133.0.insert.ext = zext nneg i32 %.0251 to i160
  %33 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0133.0.insert.ext, 1
  %.sroa.0130.0.insert.ext = zext nneg i32 %32 to i160
  %34 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0130.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %35 = load ptr, ptr %20, align 8
  %36 = call i32 %35({ ptr, i160 } %33) #7
  %37 = load i32, ptr %22, align 8
  %38 = add i32 %37, -1
  %39 = and i32 %38, %36
  %40 = load ptr, ptr %23, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %42 = sext i32 %39 to i64
  %43 = shl nsw i64 %42, 5
  %44 = getelementptr i8, ptr %40, i64 %43
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr i8, ptr %44, i64 8
  %47 = icmp ne ptr %45, @nil_typ
  %48 = icmp ne ptr %45, null
  %.not64.i = and i1 %47, %48
  br i1 %.not64.i, label %49, label %147

49:                                               ; preds = %._crit_edge
  %50 = load i64, ptr %46, align 4
  %.sroa_idx.i = getelementptr i8, ptr %44, i64 16
  %51 = load i64, ptr %.sroa_idx.i, align 4
  %52 = inttoptr i64 %50 to ptr
  %53 = inttoptr i64 %51 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %45, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %45, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %45, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !122
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !122
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !122
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !122
  %54 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %45, 0
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %52, 1
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %53, 2
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %offset.i.i77.i, 3
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %45) #35
  %60 = sext i32 %offset.i.i77.i to i64
  %61 = getelementptr ptr, ptr %45, i64 %60
  %62 = getelementptr i8, ptr %61, i64 64
  %63 = load ptr, ptr %62, align 8
  %result.i.i = call ptr %63({ ptr, ptr, ptr, i32 } %57, ptr nocapture nofree noundef nonnull readonly %2) #16
  %64 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull align 8 %2) #7
  %65 = icmp eq i32 %64, %36
  br i1 %65, label %._crit_edge.i452, label %147

._crit_edge.i452:                                 ; preds = %49
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %45)
  %68 = getelementptr i8, ptr %61, i64 48
  %69 = load ptr, ptr %68, align 8
  %result.i79.i453 = call ptr %69({ ptr, ptr, ptr, i32 } %57, ptr nocapture nofree noundef nonnull readonly %2) #16
  %70 = call { ptr, i160 } %result.i79.i453({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull align 8 %2) #7
  %71 = load ptr, ptr %21, align 8
  %72 = call i1 %71({ ptr, i160 } %70, { ptr, i160 } %33) #7
  br i1 %72, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %147

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i452
  %73 = load ptr, ptr %result.i151, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %75 = load ptr, ptr %15, align 8
  %76 = load ptr, ptr %73, align 8, !alias.scope !125
  %77 = getelementptr i8, ptr %76, i64 72
  %78 = load ptr, ptr %77, align 8, !alias.scope !125
  %result.i.i.i454 = call { i64, i64 } %78(ptr nocapture nofree nonnull readonly %73) #5, !alias.scope !125
  %79 = extractvalue { i64, i64 } %result.i.i.i454, 0
  %80 = extractvalue { i64, i64 } %result.i.i.i454, 1
  %81 = urem i64 20, %80
  %82 = icmp eq i64 %81, 0
  %83 = sub i64 %80, %81
  %84 = select i1 %82, i64 0, i64 %83
  %85 = add i64 %79, 20
  %86 = add i64 %85, %84
  %87 = load ptr, ptr %75, align 8, !alias.scope !125
  %88 = getelementptr i8, ptr %87, i64 72
  %89 = load ptr, ptr %88, align 8, !alias.scope !125
  %result.i1.i.i455 = call { i64, i64 } %89(ptr nocapture nofree nonnull readonly %75) #5, !alias.scope !125
  %90 = extractvalue { i64, i64 } %result.i1.i.i455, 0
  %91 = extractvalue { i64, i64 } %result.i1.i.i455, 1
  %92 = call i64 @llvm.umax.i64(i64 %80, i64 %91)
  %93 = call i64 @llvm.umax.i64(i64 %92, i64 8)
  %94 = urem i64 %86, %91
  %95 = icmp eq i64 %94, 0
  %96 = sub i64 %91, %94
  %97 = select i1 %95, i64 0, i64 %96
  %98 = add i64 %90, %86
  %99 = add i64 %98, %97
  %100 = urem i64 %99, %93
  %101 = icmp eq i64 %100, 0
  %102 = sub i64 %93, %100
  %103 = select i1 %101, i64 0, i64 %102
  %104 = add i64 %103, %99
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %104, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %73, ptr %result.i83.i, align 8
  %105 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %75, ptr %105, align 8
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %108 = load ptr, ptr %73, align 8
  %109 = getelementptr i8, ptr %108, i64 72
  %110 = load ptr, ptr %109, align 8
  %result.i.i118.i = call { i64, i64 } %110(ptr nocapture nofree nonnull readonly %73) #5
  %111 = extractvalue { i64, i64 } %result.i.i118.i, 1
  %112 = urem i64 20, %111
  %113 = icmp eq i64 %112, 0
  %reass.sub1521 = sub i64 %111, %112
  %114 = add i64 %reass.sub1521, 20
  %115 = select i1 %113, i64 20, i64 %114
  %116 = getelementptr i8, ptr %result.i83.i, i64 %115
  %117 = getelementptr i8, ptr %108, i64 64
  %118 = load ptr, ptr %117, align 8
  call void %118({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %73, ptr nocapture nofree writeonly %116) #1
  %119 = load ptr, ptr %result.i83.i, align 8
  %120 = load ptr, ptr %119, align 8
  %121 = getelementptr i8, ptr %120, i64 72
  %122 = load ptr, ptr %121, align 8
  %result.i.i119.i = call { i64, i64 } %122(ptr nocapture nofree nonnull readonly %119) #5
  %123 = extractvalue { i64, i64 } %result.i.i119.i, 0
  %124 = extractvalue { i64, i64 } %result.i.i119.i, 1
  %125 = urem i64 20, %124
  %126 = icmp eq i64 %125, 0
  %127 = sub i64 %124, %125
  %128 = select i1 %126, i64 0, i64 %127
  %129 = add i64 %123, 20
  %130 = add i64 %129, %128
  %131 = load ptr, ptr %105, align 8
  %132 = load ptr, ptr %131, align 8
  %133 = getelementptr i8, ptr %132, i64 72
  %134 = load ptr, ptr %133, align 8
  %result.i1.i120.i = call { i64, i64 } %134(ptr nocapture nofree nonnull readonly %131) #5
  %135 = extractvalue { i64, i64 } %result.i1.i120.i, 1
  %136 = urem i64 %130, %135
  %137 = icmp eq i64 %136, 0
  %138 = sub i64 %135, %136
  %139 = select i1 %137, i64 0, i64 %138
  %140 = getelementptr i8, ptr %result.i83.i, i64 %130
  %141 = getelementptr i8, ptr %140, i64 %139
  %142 = getelementptr i8, ptr %132, i64 64
  %143 = load ptr, ptr %142, align 8
  call void %143({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %131, ptr nocapture nofree writeonly %141) #1
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %145 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %36, ptr %145, align 8
  store ptr @Entry, ptr %44, align 8
  %146 = ptrtoint ptr %result.i83.i to i64
  store i64 %146, ptr %46, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %44, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

147:                                              ; preds = %._crit_edge.i452, %._crit_edge, %49
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %148 = add i32 %36, 2127912214
  %149 = shl i32 %36, 12
  %150 = add i32 %148, %149
  %151 = ashr i32 %150, 19
  %152 = xor i32 %150, %151
  %153 = xor i32 %152, -949894596
  %154 = add i32 %153, 374761393
  %155 = shl i32 %153, 5
  %156 = add i32 %154, %155
  %157 = add i32 %156, -744332180
  %158 = shl i32 %156, 9
  %159 = xor i32 %157, %158
  %160 = add i32 %159, -42973499
  %161 = shl i32 %159, 3
  %162 = add i32 %160, %161
  %163 = ashr i32 %162, 16
  %164 = xor i32 %162, %163
  %165 = xor i32 %164, -1252372727
  %166 = load i32, ptr %22, align 8
  %167 = add i32 %166, -1
  %168 = and i32 %167, %165
  %169 = load ptr, ptr %24, align 8
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %171 = sext i32 %168 to i64
  %172 = shl nsw i64 %171, 5
  %173 = getelementptr i8, ptr %169, i64 %172
  %174 = load ptr, ptr %173, align 8
  %175 = getelementptr i8, ptr %173, i64 8
  %176 = icmp ne ptr %174, @nil_typ
  %177 = icmp ne ptr %174, null
  %.not64.i484 = and i1 %176, %177
  br i1 %.not64.i484, label %178, label %276

178:                                              ; preds = %147
  %179 = load i64, ptr %175, align 4
  %.sroa_idx.i486 = getelementptr i8, ptr %173, i64 16
  %180 = load i64, ptr %.sroa_idx.i486, align 4
  %181 = inttoptr i64 %179 to ptr
  %182 = inttoptr i64 %180 to ptr
  %hash_coef_ptr.i.i66.i487 = getelementptr i8, ptr %174, i64 8
  %tbl_size_ptr.i.i67.i488 = getelementptr i8, ptr %174, i64 16
  %offset_tbl_ptr.i.i68.i489 = getelementptr i8, ptr %174, i64 40
  %hash_coef.i.i69.i490 = load i64, ptr %hash_coef_ptr.i.i66.i487, align 4, !noalias !128
  %tbl_size.i.i70.i491 = load i64, ptr %tbl_size_ptr.i.i67.i488, align 4, !noalias !128
  %offset_tbl.i.i71.i492 = load ptr, ptr %offset_tbl_ptr.i.i68.i489, align 8, !noalias !128
  %product.i.i.i72.i493 = mul i64 %hash_coef.i.i69.i490, 4015701072841558310
  %shifted.i.i.i73.i494 = lshr i64 %product.i.i.i72.i493, 32
  %xored.i.i.i74.i495 = xor i64 %shifted.i.i.i73.i494, %product.i.i.i72.i493
  %hash.i.i.i75.i496 = and i64 %xored.i.i.i74.i495, %tbl_size.i.i70.i491
  %offset_ptr.i.i76.i497 = getelementptr i32, ptr %offset_tbl.i.i71.i492, i64 %hash.i.i.i75.i496
  %offset.i.i77.i498 = load i32, ptr %offset_ptr.i.i76.i497, align 4, !noalias !128
  %183 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %174, 0
  %184 = insertvalue { ptr, ptr, ptr, i32 } %183, ptr %181, 1
  %185 = insertvalue { ptr, ptr, ptr, i32 } %184, ptr %182, 2
  %186 = insertvalue { ptr, ptr, ptr, i32 } %185, i32 %offset.i.i77.i498, 3
  %187 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %174) #35
  %189 = sext i32 %offset.i.i77.i498 to i64
  %190 = getelementptr ptr, ptr %174, i64 %189
  %191 = getelementptr i8, ptr %190, i64 64
  %192 = load ptr, ptr %191, align 8
  %result.i.i499 = call ptr %192({ ptr, ptr, ptr, i32 } %186, ptr nocapture nofree noundef nonnull readonly %2) #16
  %193 = call i32 %result.i.i499({ ptr, ptr, ptr, i32 } %186, { ptr, ptr, ptr, i32 } %186, ptr nonnull align 8 %2) #7
  %194 = icmp eq i32 %193, %36
  br i1 %194, label %._crit_edge.i500, label %276

._crit_edge.i500:                                 ; preds = %178
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %174)
  %197 = getelementptr i8, ptr %190, i64 48
  %198 = load ptr, ptr %197, align 8
  %result.i79.i501 = call ptr %198({ ptr, ptr, ptr, i32 } %186, ptr nocapture nofree noundef nonnull readonly %2) #16
  %199 = call { ptr, i160 } %result.i79.i501({ ptr, ptr, ptr, i32 } %186, { ptr, ptr, ptr, i32 } %186, ptr nonnull align 8 %2) #7
  %200 = load ptr, ptr %21, align 8
  %201 = call i1 %200({ ptr, i160 } %199, { ptr, i160 } %33) #7
  br i1 %201, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit513, label %276

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit513: ; preds = %._crit_edge.i500
  %202 = load ptr, ptr %result.i151, align 8
  %203 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %204 = load ptr, ptr %15, align 8
  %205 = load ptr, ptr %202, align 8, !alias.scope !131
  %206 = getelementptr i8, ptr %205, i64 72
  %207 = load ptr, ptr %206, align 8, !alias.scope !131
  %result.i.i.i505 = call { i64, i64 } %207(ptr nocapture nofree nonnull readonly %202) #5, !alias.scope !131
  %208 = extractvalue { i64, i64 } %result.i.i.i505, 0
  %209 = extractvalue { i64, i64 } %result.i.i.i505, 1
  %210 = urem i64 20, %209
  %211 = icmp eq i64 %210, 0
  %212 = sub i64 %209, %210
  %213 = select i1 %211, i64 0, i64 %212
  %214 = add i64 %208, 20
  %215 = add i64 %214, %213
  %216 = load ptr, ptr %204, align 8, !alias.scope !131
  %217 = getelementptr i8, ptr %216, i64 72
  %218 = load ptr, ptr %217, align 8, !alias.scope !131
  %result.i1.i.i506 = call { i64, i64 } %218(ptr nocapture nofree nonnull readonly %204) #5, !alias.scope !131
  %219 = extractvalue { i64, i64 } %result.i1.i.i506, 0
  %220 = extractvalue { i64, i64 } %result.i1.i.i506, 1
  %221 = call i64 @llvm.umax.i64(i64 %209, i64 %220)
  %222 = call i64 @llvm.umax.i64(i64 %221, i64 8)
  %223 = urem i64 %215, %220
  %224 = icmp eq i64 %223, 0
  %225 = sub i64 %220, %223
  %226 = select i1 %224, i64 0, i64 %225
  %227 = add i64 %219, %215
  %228 = add i64 %227, %226
  %229 = urem i64 %228, %222
  %230 = icmp eq i64 %229, 0
  %231 = sub i64 %222, %229
  %232 = select i1 %230, i64 0, i64 %231
  %233 = add i64 %232, %228
  %result.i83.i507 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %233, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %202, ptr %result.i83.i507, align 8
  %234 = getelementptr inbounds i8, ptr %result.i83.i507, i64 8
  store ptr %204, ptr %234, align 8
  %235 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i507)
  %236 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %237 = load ptr, ptr %202, align 8
  %238 = getelementptr i8, ptr %237, i64 72
  %239 = load ptr, ptr %238, align 8
  %result.i.i118.i508 = call { i64, i64 } %239(ptr nocapture nofree nonnull readonly %202) #5
  %240 = extractvalue { i64, i64 } %result.i.i118.i508, 1
  %241 = urem i64 20, %240
  %242 = icmp eq i64 %241, 0
  %reass.sub1520 = sub i64 %240, %241
  %243 = add i64 %reass.sub1520, 20
  %244 = select i1 %242, i64 20, i64 %243
  %245 = getelementptr i8, ptr %result.i83.i507, i64 %244
  %246 = getelementptr i8, ptr %237, i64 64
  %247 = load ptr, ptr %246, align 8
  call void %247({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %202, ptr nocapture nofree writeonly %245) #1
  %248 = load ptr, ptr %result.i83.i507, align 8
  %249 = load ptr, ptr %248, align 8
  %250 = getelementptr i8, ptr %249, i64 72
  %251 = load ptr, ptr %250, align 8
  %result.i.i119.i510 = call { i64, i64 } %251(ptr nocapture nofree nonnull readonly %248) #5
  %252 = extractvalue { i64, i64 } %result.i.i119.i510, 0
  %253 = extractvalue { i64, i64 } %result.i.i119.i510, 1
  %254 = urem i64 20, %253
  %255 = icmp eq i64 %254, 0
  %256 = sub i64 %253, %254
  %257 = select i1 %255, i64 0, i64 %256
  %258 = add i64 %252, 20
  %259 = add i64 %258, %257
  %260 = load ptr, ptr %234, align 8
  %261 = load ptr, ptr %260, align 8
  %262 = getelementptr i8, ptr %261, i64 72
  %263 = load ptr, ptr %262, align 8
  %result.i1.i120.i511 = call { i64, i64 } %263(ptr nocapture nofree nonnull readonly %260) #5
  %264 = extractvalue { i64, i64 } %result.i1.i120.i511, 1
  %265 = urem i64 %259, %264
  %266 = icmp eq i64 %265, 0
  %267 = sub i64 %264, %265
  %268 = select i1 %266, i64 0, i64 %267
  %269 = getelementptr i8, ptr %result.i83.i507, i64 %259
  %270 = getelementptr i8, ptr %269, i64 %268
  %271 = getelementptr i8, ptr %261, i64 64
  %272 = load ptr, ptr %271, align 8
  call void %272({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %260, ptr nocapture nofree writeonly %270) #1
  %273 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %274 = getelementptr inbounds i8, ptr %result.i83.i507, i64 16
  store i32 %36, ptr %274, align 8
  store ptr @Entry, ptr %173, align 8
  %275 = ptrtoint ptr %result.i83.i507 to i64
  store i64 %275, ptr %175, align 4
  %.sroa_idx28.i512 = getelementptr i8, ptr %173, i64 24
  store i32 10, ptr %.sroa_idx28.i512, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

276:                                              ; preds = %._crit_edge.i500, %147, %178
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %277 = load i32, ptr %27, align 4
  %278 = load i32, ptr %22, align 8
  %.not.i = icmp slt i32 %277, %278
  br i1 %.not.i, label %._crit_edge.i, label %279

279:                                              ; preds = %276
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %281 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %282 = load ptr, ptr %23, align 8
  %283 = load ptr, ptr %24, align 8
  %284 = shl i32 %278, 1
  %spec.select.i528 = call i32 @llvm.smax.i32(i32 %284, i32 16)
  store i32 %spec.select.i528, ptr %22, align 8
  %285 = zext nneg i32 %spec.select.i528 to i64
  %286 = shl nuw nsw i64 %285, 5
  %result.i.i529 = call noalias ptr @bump_malloc_inner(i64 noundef %286, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i529, ptr %23, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %286, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i, ptr %24, align 8
  store i32 0, ptr %27, align 4
  %287 = icmp sgt i32 %278, 0
  br i1 %287, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %279, %._crit_edge.i869
  %.060.i = phi i32 [ %306, %._crit_edge.i869 ], [ 0, %279 ]
  %288 = zext nneg i32 %.060.i to i64
  %289 = shl nuw nsw i64 %288, 5
  %290 = getelementptr i8, ptr %282, i64 %289
  %291 = load ptr, ptr %290, align 8
  %292 = icmp ne ptr %291, @nil_typ
  %293 = icmp ne ptr %291, null
  %.not16.i = and i1 %292, %293
  br i1 %.not16.i, label %294, label %._crit_edge.i869

294:                                              ; preds = %.lr.ph.i
  %295 = getelementptr i8, ptr %290, i64 8
  %296 = load i64, ptr %295, align 4
  %.sroa_idx.i870 = getelementptr i8, ptr %290, i64 16
  %297 = load i64, ptr %.sroa_idx.i870, align 4
  %298 = inttoptr i64 %296 to ptr
  %299 = inttoptr i64 %297 to ptr
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %291, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %291, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %291, i64 40
  %hash_coef.i.i21.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i22.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i23.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i24.i = mul i64 %hash_coef.i.i21.i, 4015701072841558310
  %shifted.i.i.i25.i = lshr i64 %product.i.i.i24.i, 32
  %xored.i.i.i26.i = xor i64 %shifted.i.i.i25.i, %product.i.i.i24.i
  %hash.i.i.i27.i = and i64 %xored.i.i.i26.i, %tbl_size.i.i22.i
  %offset_ptr.i.i28.i = getelementptr i32, ptr %offset_tbl.i.i23.i, i64 %hash.i.i.i27.i
  %offset.i.i43.i = load i32, ptr %offset_ptr.i.i28.i, align 4, !noalias !134
  %300 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %291, 0
  %301 = insertvalue { ptr, ptr, ptr, i32 } %300, ptr %298, 1
  %302 = insertvalue { ptr, ptr, ptr, i32 } %301, ptr %299, 2
  %303 = insertvalue { ptr, ptr, ptr, i32 } %302, i32 %offset.i.i43.i, 3
  %304 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %305 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %303) #7
  br label %._crit_edge.i869

._crit_edge.i869:                                 ; preds = %294, %.lr.ph.i
  %306 = add nuw nsw i32 %.060.i, 1
  %307 = icmp slt i32 %306, %278
  br i1 %307, label %.lr.ph.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i869, %._crit_edge.i888
  %.060.i886 = phi i32 [ %326, %._crit_edge.i888 ], [ 0, %._crit_edge.i869 ]
  %308 = zext nneg i32 %.060.i886 to i64
  %309 = shl nuw nsw i64 %308, 5
  %310 = getelementptr i8, ptr %283, i64 %309
  %311 = load ptr, ptr %310, align 8
  %312 = icmp ne ptr %311, @nil_typ
  %313 = icmp ne ptr %311, null
  %.not16.i887 = and i1 %312, %313
  br i1 %.not16.i887, label %314, label %._crit_edge.i888

314:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %315 = getelementptr i8, ptr %310, i64 8
  %316 = load i64, ptr %315, align 4
  %.sroa_idx.i889 = getelementptr i8, ptr %310, i64 16
  %317 = load i64, ptr %.sroa_idx.i889, align 4
  %318 = inttoptr i64 %316 to ptr
  %319 = inttoptr i64 %317 to ptr
  %hash_coef_ptr.i.i18.i890 = getelementptr i8, ptr %311, i64 8
  %tbl_size_ptr.i.i19.i891 = getelementptr i8, ptr %311, i64 16
  %offset_tbl_ptr.i.i20.i892 = getelementptr i8, ptr %311, i64 40
  %hash_coef.i.i21.i893 = load i64, ptr %hash_coef_ptr.i.i18.i890, align 4, !noalias !22
  %tbl_size.i.i22.i894 = load i64, ptr %tbl_size_ptr.i.i19.i891, align 4, !noalias !22
  %offset_tbl.i.i23.i895 = load ptr, ptr %offset_tbl_ptr.i.i20.i892, align 8, !noalias !22
  %product.i.i.i24.i896 = mul i64 %hash_coef.i.i21.i893, 4015701072841558310
  %shifted.i.i.i25.i897 = lshr i64 %product.i.i.i24.i896, 32
  %xored.i.i.i26.i898 = xor i64 %shifted.i.i.i25.i897, %product.i.i.i24.i896
  %hash.i.i.i27.i899 = and i64 %xored.i.i.i26.i898, %tbl_size.i.i22.i894
  %offset_ptr.i.i28.i900 = getelementptr i32, ptr %offset_tbl.i.i23.i895, i64 %hash.i.i.i27.i899
  %offset.i.i43.i901 = load i32, ptr %offset_ptr.i.i28.i900, align 4, !noalias !137
  %320 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %311, 0
  %321 = insertvalue { ptr, ptr, ptr, i32 } %320, ptr %318, 1
  %322 = insertvalue { ptr, ptr, ptr, i32 } %321, ptr %319, 2
  %323 = insertvalue { ptr, ptr, ptr, i32 } %322, i32 %offset.i.i43.i901, 3
  %324 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %325 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %323) #7
  br label %._crit_edge.i888

._crit_edge.i888:                                 ; preds = %314, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %326 = add nuw nsw i32 %.060.i886, 1
  %327 = icmp slt i32 %326, %278
  br i1 %327, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i888, %279, %276
  %328 = load ptr, ptr %result.i151, align 8
  %329 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %330 = load ptr, ptr %15, align 8
  %331 = load ptr, ptr %328, align 8
  %332 = getelementptr i8, ptr %331, i64 72
  %333 = load ptr, ptr %332, align 8
  %result.i.i.i = call { i64, i64 } %333(ptr nocapture nofree nonnull readonly %328) #5
  %334 = extractvalue { i64, i64 } %result.i.i.i, 0
  %335 = extractvalue { i64, i64 } %result.i.i.i, 1
  %336 = urem i64 20, %335
  %337 = icmp eq i64 %336, 0
  %338 = sub i64 %335, %336
  %339 = select i1 %337, i64 0, i64 %338
  %340 = add i64 %334, 20
  %341 = add i64 %340, %339
  %342 = load ptr, ptr %330, align 8
  %343 = getelementptr i8, ptr %342, i64 72
  %344 = load ptr, ptr %343, align 8
  %result.i1.i.i = call { i64, i64 } %344(ptr nocapture nofree nonnull readonly %330) #5
  %345 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %346 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %347 = call i64 @llvm.umax.i64(i64 %335, i64 %346)
  %348 = call i64 @llvm.umax.i64(i64 %347, i64 8)
  %349 = urem i64 %341, %346
  %350 = icmp eq i64 %349, 0
  %351 = sub i64 %346, %349
  %352 = select i1 %350, i64 0, i64 %351
  %353 = add i64 %345, %341
  %354 = add i64 %353, %352
  %355 = urem i64 %354, %348
  %356 = icmp eq i64 %355, 0
  %357 = sub i64 %348, %355
  %358 = select i1 %356, i64 0, i64 %357
  %359 = add i64 %358, %354
  %result.i90.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %359, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %328, ptr %result.i90.i, align 8
  %360 = getelementptr inbounds i8, ptr %result.i90.i, i64 8
  store ptr %330, ptr %360, align 8
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i)
  %362 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %363 = load ptr, ptr %328, align 8
  %364 = getelementptr i8, ptr %363, i64 72
  %365 = load ptr, ptr %364, align 8
  %result.i.i196.i = call { i64, i64 } %365(ptr nocapture nofree nonnull readonly %328) #5
  %366 = extractvalue { i64, i64 } %result.i.i196.i, 1
  %367 = urem i64 20, %366
  %368 = icmp eq i64 %367, 0
  %reass.sub = sub i64 %366, %367
  %369 = add i64 %reass.sub, 20
  %370 = select i1 %368, i64 20, i64 %369
  %371 = getelementptr i8, ptr %result.i90.i, i64 %370
  %372 = getelementptr i8, ptr %363, i64 64
  %373 = load ptr, ptr %372, align 8
  call void %373({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %328, ptr nocapture nofree writeonly %371) #1
  %374 = load ptr, ptr %result.i90.i, align 8
  %375 = load ptr, ptr %374, align 8
  %376 = getelementptr i8, ptr %375, i64 72
  %377 = load ptr, ptr %376, align 8
  %result.i.i197.i = call { i64, i64 } %377(ptr nocapture nofree nonnull readonly %374) #5
  %378 = extractvalue { i64, i64 } %result.i.i197.i, 0
  %379 = extractvalue { i64, i64 } %result.i.i197.i, 1
  %380 = urem i64 20, %379
  %381 = icmp eq i64 %380, 0
  %382 = sub i64 %379, %380
  %383 = select i1 %381, i64 0, i64 %382
  %384 = add i64 %378, 20
  %385 = add i64 %384, %383
  %386 = load ptr, ptr %360, align 8
  %387 = load ptr, ptr %386, align 8
  %388 = getelementptr i8, ptr %387, i64 72
  %389 = load ptr, ptr %388, align 8
  %result.i1.i198.i = call { i64, i64 } %389(ptr nocapture nofree nonnull readonly %386) #5
  %390 = extractvalue { i64, i64 } %result.i1.i198.i, 1
  %391 = urem i64 %385, %390
  %392 = icmp eq i64 %391, 0
  %393 = sub i64 %390, %391
  %394 = select i1 %392, i64 0, i64 %393
  %395 = getelementptr i8, ptr %result.i90.i, i64 %385
  %396 = getelementptr i8, ptr %395, i64 %394
  %397 = getelementptr i8, ptr %387, i64 64
  %398 = load ptr, ptr %397, align 8
  call void %398({ ptr, i160 } %34, ptr nocapture nofree nonnull readonly %386, ptr nocapture nofree writeonly %396) #1
  %399 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %400 = getelementptr inbounds i8, ptr %result.i90.i, i64 16
  store i32 %36, ptr %400, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %403 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %404

404:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %405, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %471, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i90.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i546, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %405 = add nuw nsw i32 %.0566.i, 1
  %406 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %407 = insertvalue { ptr, ptr, ptr, i32 } %406, ptr %.sroa.6.0563.i, 1
  %408 = insertvalue { ptr, ptr, ptr, i32 } %407, ptr %.sroa.12.0562.i, 2
  %409 = insertvalue { ptr, ptr, ptr, i32 } %408, i32 %.sroa.17.0561.i, 3
  %410 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %411 = sext i32 %.sroa.17.0561.i to i64
  %412 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %411
  %413 = getelementptr i8, ptr %412, i64 64
  %414 = load ptr, ptr %413, align 8
  %result.i125.i544 = call ptr %414({ ptr, ptr, ptr, i32 } %409, ptr nocapture nofree noundef nonnull readonly %2) #16
  %415 = call i32 %result.i125.i544({ ptr, ptr, ptr, i32 } %409, { ptr, ptr, ptr, i32 } %409, ptr nonnull align 8 %2) #7
  %416 = ptrtoint ptr %.sroa.6.0563.i to i64
  %417 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %418, label %434

418:                                              ; preds = %404
  %419 = load i32, ptr %22, align 8
  %420 = add i32 %419, -1
  %421 = and i32 %420, %415
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %423 = load ptr, ptr %23, align 8
  %424 = sext i32 %421 to i64
  %425 = shl nsw i64 %424, 5
  %426 = getelementptr i8, ptr %423, i64 %425
  %427 = load ptr, ptr %426, align 8
  %428 = getelementptr i8, ptr %426, i64 8
  %429 = load i160, ptr %428, align 4
  store ptr %.sroa.0.0564.i, ptr %426, align 8
  store i64 %416, ptr %428, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %426, i64 16
  store i64 %417, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %426, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %430 = icmp ne ptr %427, @nil_typ
  %431 = icmp ne ptr %427, null
  %.not92.i = and i1 %430, %431
  %extract.i = lshr i160 %429, 64
  %432 = insertelement <2 x i160> poison, i160 %429, i64 0
  %433 = insertelement <2 x i160> %432, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

434:                                              ; preds = %404
  %435 = add i32 %415, 2127912214
  %436 = shl i32 %415, 12
  %437 = add i32 %435, %436
  %438 = ashr i32 %437, 19
  %439 = xor i32 %437, %438
  %440 = xor i32 %439, -949894596
  %441 = add i32 %440, 374761393
  %442 = shl i32 %440, 5
  %443 = add i32 %441, %442
  %444 = add i32 %443, -744332180
  %445 = shl i32 %443, 9
  %446 = xor i32 %444, %445
  %447 = add i32 %446, -42973499
  %448 = shl i32 %446, 3
  %449 = add i32 %447, %448
  %450 = ashr i32 %449, 16
  %451 = xor i32 %449, %450
  %452 = xor i32 %451, -1252372727
  %453 = load i32, ptr %22, align 8
  %454 = add i32 %453, -1
  %455 = and i32 %454, %452
  %456 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %457 = load ptr, ptr %24, align 8
  %458 = sext i32 %455 to i64
  %459 = shl nsw i64 %458, 5
  %460 = getelementptr i8, ptr %457, i64 %459
  %461 = load ptr, ptr %460, align 8
  %462 = getelementptr i8, ptr %460, i64 8
  %463 = load i160, ptr %462, align 4
  store ptr %.sroa.0.0564.i, ptr %460, align 8
  store i64 %416, ptr %462, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %460, i64 16
  store i64 %417, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %460, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %464 = icmp ne ptr %461, @nil_typ
  %465 = icmp ne ptr %461, null
  %.not90.i = and i1 %464, %465
  %extract607.i = lshr i160 %463, 64
  %466 = insertelement <2 x i160> poison, i160 %463, i64 0
  %467 = insertelement <2 x i160> %466, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %434, %418
  %vptr.i142.sroa.speculated.i = phi ptr [ %427, %418 ], [ %461, %434 ]
  %.in = phi <2 x i160> [ %433, %418 ], [ %467, %434 ]
  %468 = trunc <2 x i160> %.in to <2 x i64>
  %469 = extractelement <2 x i64> %468, i64 1
  %spec.select.i546 = inttoptr i64 %469 to ptr
  %470 = extractelement <2 x i64> %468, i64 0
  %spec.select539.i = inttoptr i64 %470 to ptr
  %471 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %472 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %473 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %474 = icmp ult i32 %.0566.i, 99
  br i1 %474, label %404, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %418, %434
  %475 = phi ptr [ %14, %434 ], [ %13, %418 ]
  %476 = load i32, ptr %27, align 4
  store i32 %476, ptr %475, align 4
  %477 = add i32 %476, 1
  %478 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %477, ptr %27, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  %479 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %479, label %CuckooMap_insert_keyK_valueV.exit, label %480

480:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %481 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %482 = load ptr, ptr %23, align 8
  %483 = load ptr, ptr %24, align 8
  %484 = load i32, ptr %22, align 8
  %485 = shl i32 %484, 1
  %spec.select.i563 = call i32 @llvm.smax.i32(i32 %485, i32 16)
  store i32 %spec.select.i563, ptr %22, align 8
  %486 = zext nneg i32 %spec.select.i563 to i64
  %487 = shl nuw nsw i64 %486, 5
  %result.i.i564 = call noalias ptr @bump_malloc_inner(i64 noundef %487, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i564, ptr %23, align 8
  %result.i20.i565 = call noalias ptr @bump_malloc_inner(i64 noundef %487, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i565, ptr %24, align 8
  store i32 0, ptr %27, align 4
  %488 = icmp sgt i32 %484, 0
  br i1 %488, label %.lr.ph.i935, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004

.lr.ph.i935:                                      ; preds = %480, %._crit_edge.i950
  %.060.i948 = phi i32 [ %577, %._crit_edge.i950 ], [ 0, %480 ]
  %489 = zext nneg i32 %.060.i948 to i64
  %490 = shl nuw nsw i64 %489, 5
  %491 = getelementptr i8, ptr %482, i64 %490
  %492 = load ptr, ptr %491, align 8
  %493 = icmp ne ptr %492, @nil_typ
  %494 = icmp ne ptr %492, null
  %.not16.i949 = and i1 %493, %494
  br i1 %.not16.i949, label %495, label %._crit_edge.i950

495:                                              ; preds = %.lr.ph.i935
  %496 = getelementptr i8, ptr %491, i64 8
  %497 = load <2 x i64>, ptr %496, align 4
  %hash_coef_ptr.i.i18.i952 = getelementptr i8, ptr %492, i64 8
  %tbl_size_ptr.i.i19.i953 = getelementptr i8, ptr %492, i64 16
  %offset_tbl_ptr.i.i20.i954 = getelementptr i8, ptr %492, i64 40
  %498 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i952, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i953, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i954, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !140
  %499 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %500 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %501 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %502

502:                                              ; preds = %.cont.cont.i1127, %495
  %.0566.i1115 = phi i32 [ 0, %495 ], [ %506, %.cont.cont.i1127 ]
  %.070565.i1116 = phi i1 [ true, %495 ], [ %568, %.cont.cont.i1127 ]
  %.sroa.0.0564.i1117 = phi ptr [ %492, %495 ], [ %vptr.i142.sroa.speculated.i1130, %.cont.cont.i1127 ]
  %.sroa.17.0561.i1120 = phi i32 [ %offset.i.i121.i, %495 ], [ %offset.i.i154.i1144, %.cont.cont.i1127 ]
  %503 = phi <2 x i64> [ %497, %495 ], [ %567, %.cont.cont.i1127 ]
  %504 = extractelement <2 x i64> %503, i64 1
  %.sroa.12.0562.i1119 = inttoptr i64 %504 to ptr
  %505 = extractelement <2 x i64> %503, i64 0
  %.sroa.6.0563.i1118 = inttoptr i64 %505 to ptr
  %506 = add nuw nsw i32 %.0566.i1115, 1
  %507 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1117, 0
  %508 = insertvalue { ptr, ptr, ptr, i32 } %507, ptr %.sroa.6.0563.i1118, 1
  %509 = insertvalue { ptr, ptr, ptr, i32 } %508, ptr %.sroa.12.0562.i1119, 2
  %510 = insertvalue { ptr, ptr, ptr, i32 } %509, i32 %.sroa.17.0561.i1120, 3
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1117)
  %512 = sext i32 %.sroa.17.0561.i1120 to i64
  %513 = getelementptr ptr, ptr %.sroa.0.0564.i1117, i64 %512
  %514 = getelementptr i8, ptr %513, i64 64
  %515 = load ptr, ptr %514, align 8
  %result.i125.i = call ptr %515({ ptr, ptr, ptr, i32 } %510, ptr nocapture nofree noundef nonnull readonly %2) #16
  %516 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %510, { ptr, ptr, ptr, i32 } %510, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1116, label %517, label %533

517:                                              ; preds = %502
  %518 = load i32, ptr %22, align 8
  %519 = add i32 %518, -1
  %520 = and i32 %519, %516
  %521 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %522 = load ptr, ptr %23, align 8
  %523 = sext i32 %520 to i64
  %524 = shl nsw i64 %523, 5
  %525 = getelementptr i8, ptr %522, i64 %524
  %526 = load ptr, ptr %525, align 8
  %527 = getelementptr i8, ptr %525, i64 8
  %528 = load i160, ptr %527, align 4
  store ptr %.sroa.0.0564.i1117, ptr %525, align 8
  store i64 %505, ptr %527, align 4
  %.sroa_idx157.i1146 = getelementptr i8, ptr %525, i64 16
  store i64 %504, ptr %.sroa_idx157.i1146, align 4
  %.sroa_idx158.i1147 = getelementptr i8, ptr %525, i64 24
  store i32 %.sroa.17.0561.i1120, ptr %.sroa_idx158.i1147, align 4
  %529 = icmp ne ptr %526, @nil_typ
  %530 = icmp ne ptr %526, null
  %.not92.i1148 = and i1 %529, %530
  %extract.i1150 = lshr i160 %528, 64
  %531 = insertelement <2 x i160> poison, i160 %528, i64 0
  %532 = insertelement <2 x i160> %531, i160 %extract.i1150, i64 1
  br i1 %.not92.i1148, label %.cont.cont.i1127, label %572

533:                                              ; preds = %502
  %534 = add i32 %516, 2127912214
  %535 = shl i32 %516, 12
  %536 = add i32 %534, %535
  %537 = ashr i32 %536, 19
  %538 = xor i32 %536, %537
  %539 = xor i32 %538, -949894596
  %540 = add i32 %539, 374761393
  %541 = shl i32 %539, 5
  %542 = add i32 %540, %541
  %543 = add i32 %542, -744332180
  %544 = shl i32 %542, 9
  %545 = xor i32 %543, %544
  %546 = add i32 %545, -42973499
  %547 = shl i32 %545, 3
  %548 = add i32 %546, %547
  %549 = ashr i32 %548, 16
  %550 = xor i32 %548, %549
  %551 = xor i32 %550, -1252372727
  %552 = load i32, ptr %22, align 8
  %553 = add i32 %552, -1
  %554 = and i32 %553, %551
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %556 = load ptr, ptr %24, align 8
  %557 = sext i32 %554 to i64
  %558 = shl nsw i64 %557, 5
  %559 = getelementptr i8, ptr %556, i64 %558
  %560 = load ptr, ptr %559, align 8
  %561 = getelementptr i8, ptr %559, i64 8
  %562 = load i160, ptr %561, align 4
  store ptr %.sroa.0.0564.i1117, ptr %559, align 8
  store i64 %505, ptr %561, align 4
  %.sroa_idx161.i1121 = getelementptr i8, ptr %559, i64 16
  store i64 %504, ptr %.sroa_idx161.i1121, align 4
  %.sroa_idx162.i1122 = getelementptr i8, ptr %559, i64 24
  store i32 %.sroa.17.0561.i1120, ptr %.sroa_idx162.i1122, align 4
  %563 = icmp ne ptr %560, @nil_typ
  %564 = icmp ne ptr %560, null
  %.not90.i1123 = and i1 %563, %564
  %extract607.i1125 = lshr i160 %562, 64
  %565 = insertelement <2 x i160> poison, i160 %562, i64 0
  %566 = insertelement <2 x i160> %565, i160 %extract607.i1125, i64 1
  br i1 %.not90.i1123, label %.cont.cont.i1127, label %572

.cont.cont.i1127:                                 ; preds = %533, %517
  %vptr.i142.sroa.speculated.i1130 = phi ptr [ %526, %517 ], [ %560, %533 ]
  %.in1522 = phi <2 x i160> [ %532, %517 ], [ %566, %533 ]
  %567 = trunc <2 x i160> %.in1522 to <2 x i64>
  %568 = xor i1 %.070565.i1116, true
  %hash_coef_ptr.i.i143.i1133 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1130, i64 8
  %tbl_size_ptr.i.i144.i1134 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1130, i64 16
  %offset_tbl_ptr.i.i145.i1135 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1130, i64 40
  %hash_coef.i.i146.i1136 = load i64, ptr %hash_coef_ptr.i.i143.i1133, align 4
  %tbl_size.i.i147.i1137 = load i64, ptr %tbl_size_ptr.i.i144.i1134, align 4
  %offset_tbl.i.i148.i1138 = load ptr, ptr %offset_tbl_ptr.i.i145.i1135, align 8
  %product.i.i.i149.i1139 = mul i64 %hash_coef.i.i146.i1136, 4015701072841558310
  %shifted.i.i.i150.i1140 = lshr i64 %product.i.i.i149.i1139, 32
  %xored.i.i.i151.i1141 = xor i64 %shifted.i.i.i150.i1140, %product.i.i.i149.i1139
  %hash.i.i.i152.i1142 = and i64 %xored.i.i.i151.i1141, %tbl_size.i.i147.i1137
  %offset_ptr.i.i153.i1143 = getelementptr i32, ptr %offset_tbl.i.i148.i1138, i64 %hash.i.i.i152.i1142
  %offset.i.i154.i1144 = load i32, ptr %offset_ptr.i.i153.i1143, align 4
  %569 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %570 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %571 = icmp ult i32 %.0566.i1115, 99
  br i1 %571, label %502, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1152

572:                                              ; preds = %533, %517
  %573 = phi ptr [ %10, %533 ], [ %9, %517 ]
  %574 = load i32, ptr %27, align 4
  store i32 %574, ptr %573, align 4
  %575 = add i32 %574, 1
  %576 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %575, ptr %27, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1152

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1152: ; preds = %.cont.cont.i1127, %572
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i950

._crit_edge.i950:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1152, %.lr.ph.i935
  %577 = add nuw nsw i32 %.060.i948, 1
  %578 = icmp slt i32 %577, %484
  br i1 %578, label %.lr.ph.i935, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968: ; preds = %._crit_edge.i950, %._crit_edge.i986
  %.060.i984 = phi i32 [ %667, %._crit_edge.i986 ], [ 0, %._crit_edge.i950 ]
  %579 = zext nneg i32 %.060.i984 to i64
  %580 = shl nuw nsw i64 %579, 5
  %581 = getelementptr i8, ptr %483, i64 %580
  %582 = load ptr, ptr %581, align 8
  %583 = icmp ne ptr %582, @nil_typ
  %584 = icmp ne ptr %582, null
  %.not16.i985 = and i1 %583, %584
  br i1 %.not16.i985, label %585, label %._crit_edge.i986

585:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968
  %586 = getelementptr i8, ptr %581, i64 8
  %587 = load <2 x i64>, ptr %586, align 4
  %hash_coef_ptr.i.i18.i988 = getelementptr i8, ptr %582, i64 8
  %tbl_size_ptr.i.i19.i989 = getelementptr i8, ptr %582, i64 16
  %offset_tbl_ptr.i.i20.i990 = getelementptr i8, ptr %582, i64 40
  %588 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i1170 = load i64, ptr %hash_coef_ptr.i.i18.i988, align 4, !noalias !22
  %tbl_size.i.i100.i1171 = load i64, ptr %tbl_size_ptr.i.i19.i989, align 4, !noalias !22
  %offset_tbl.i.i101.i1172 = load ptr, ptr %offset_tbl_ptr.i.i20.i990, align 8, !noalias !22
  %product.i.i.i102.i1173 = mul i64 %hash_coef.i.i99.i1170, 4015701072841558310
  %shifted.i.i.i103.i1174 = lshr i64 %product.i.i.i102.i1173, 32
  %xored.i.i.i104.i1175 = xor i64 %shifted.i.i.i103.i1174, %product.i.i.i102.i1173
  %hash.i.i.i105.i1176 = and i64 %xored.i.i.i104.i1175, %tbl_size.i.i100.i1171
  %offset_ptr.i.i106.i1177 = getelementptr i32, ptr %offset_tbl.i.i101.i1172, i64 %hash.i.i.i105.i1176
  %offset.i.i121.i1178 = load i32, ptr %offset_ptr.i.i106.i1177, align 4, !noalias !143
  %589 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %590 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %591 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %592

592:                                              ; preds = %.cont.cont.i1199, %585
  %.0566.i1179 = phi i32 [ 0, %585 ], [ %596, %.cont.cont.i1199 ]
  %.070565.i1180 = phi i1 [ true, %585 ], [ %658, %.cont.cont.i1199 ]
  %.sroa.0.0564.i1181 = phi ptr [ %582, %585 ], [ %vptr.i142.sroa.speculated.i1202, %.cont.cont.i1199 ]
  %.sroa.17.0561.i1184 = phi i32 [ %offset.i.i121.i1178, %585 ], [ %offset.i.i154.i1216, %.cont.cont.i1199 ]
  %593 = phi <2 x i64> [ %587, %585 ], [ %657, %.cont.cont.i1199 ]
  %594 = extractelement <2 x i64> %593, i64 1
  %.sroa.12.0562.i1183 = inttoptr i64 %594 to ptr
  %595 = extractelement <2 x i64> %593, i64 0
  %.sroa.6.0563.i1182 = inttoptr i64 %595 to ptr
  %596 = add nuw nsw i32 %.0566.i1179, 1
  %597 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1181, 0
  %598 = insertvalue { ptr, ptr, ptr, i32 } %597, ptr %.sroa.6.0563.i1182, 1
  %599 = insertvalue { ptr, ptr, ptr, i32 } %598, ptr %.sroa.12.0562.i1183, 2
  %600 = insertvalue { ptr, ptr, ptr, i32 } %599, i32 %.sroa.17.0561.i1184, 3
  %601 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1181)
  %602 = sext i32 %.sroa.17.0561.i1184 to i64
  %603 = getelementptr ptr, ptr %.sroa.0.0564.i1181, i64 %602
  %604 = getelementptr i8, ptr %603, i64 64
  %605 = load ptr, ptr %604, align 8
  %result.i125.i1185 = call ptr %605({ ptr, ptr, ptr, i32 } %600, ptr nocapture nofree noundef nonnull readonly %2) #16
  %606 = call i32 %result.i125.i1185({ ptr, ptr, ptr, i32 } %600, { ptr, ptr, ptr, i32 } %600, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1180, label %607, label %623

607:                                              ; preds = %592
  %608 = load i32, ptr %22, align 8
  %609 = add i32 %608, -1
  %610 = and i32 %609, %606
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %612 = load ptr, ptr %23, align 8
  %613 = sext i32 %610 to i64
  %614 = shl nsw i64 %613, 5
  %615 = getelementptr i8, ptr %612, i64 %614
  %616 = load ptr, ptr %615, align 8
  %617 = getelementptr i8, ptr %615, i64 8
  %618 = load i160, ptr %617, align 4
  store ptr %.sroa.0.0564.i1181, ptr %615, align 8
  store i64 %595, ptr %617, align 4
  %.sroa_idx157.i1228 = getelementptr i8, ptr %615, i64 16
  store i64 %594, ptr %.sroa_idx157.i1228, align 4
  %.sroa_idx158.i1229 = getelementptr i8, ptr %615, i64 24
  store i32 %.sroa.17.0561.i1184, ptr %.sroa_idx158.i1229, align 4
  %619 = icmp ne ptr %616, @nil_typ
  %620 = icmp ne ptr %616, null
  %.not92.i1230 = and i1 %619, %620
  %extract.i1232 = lshr i160 %618, 64
  %621 = insertelement <2 x i160> poison, i160 %618, i64 0
  %622 = insertelement <2 x i160> %621, i160 %extract.i1232, i64 1
  br i1 %.not92.i1230, label %.cont.cont.i1199, label %662

623:                                              ; preds = %592
  %624 = add i32 %606, 2127912214
  %625 = shl i32 %606, 12
  %626 = add i32 %624, %625
  %627 = ashr i32 %626, 19
  %628 = xor i32 %626, %627
  %629 = xor i32 %628, -949894596
  %630 = add i32 %629, 374761393
  %631 = shl i32 %629, 5
  %632 = add i32 %630, %631
  %633 = add i32 %632, -744332180
  %634 = shl i32 %632, 9
  %635 = xor i32 %633, %634
  %636 = add i32 %635, -42973499
  %637 = shl i32 %635, 3
  %638 = add i32 %636, %637
  %639 = ashr i32 %638, 16
  %640 = xor i32 %638, %639
  %641 = xor i32 %640, -1252372727
  %642 = load i32, ptr %22, align 8
  %643 = add i32 %642, -1
  %644 = and i32 %643, %641
  %645 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %646 = load ptr, ptr %24, align 8
  %647 = sext i32 %644 to i64
  %648 = shl nsw i64 %647, 5
  %649 = getelementptr i8, ptr %646, i64 %648
  %650 = load ptr, ptr %649, align 8
  %651 = getelementptr i8, ptr %649, i64 8
  %652 = load i160, ptr %651, align 4
  store ptr %.sroa.0.0564.i1181, ptr %649, align 8
  store i64 %595, ptr %651, align 4
  %.sroa_idx161.i1189 = getelementptr i8, ptr %649, i64 16
  store i64 %594, ptr %.sroa_idx161.i1189, align 4
  %.sroa_idx162.i1190 = getelementptr i8, ptr %649, i64 24
  store i32 %.sroa.17.0561.i1184, ptr %.sroa_idx162.i1190, align 4
  %653 = icmp ne ptr %650, @nil_typ
  %654 = icmp ne ptr %650, null
  %.not90.i1191 = and i1 %653, %654
  %extract607.i1193 = lshr i160 %652, 64
  %655 = insertelement <2 x i160> poison, i160 %652, i64 0
  %656 = insertelement <2 x i160> %655, i160 %extract607.i1193, i64 1
  br i1 %.not90.i1191, label %.cont.cont.i1199, label %662

.cont.cont.i1199:                                 ; preds = %623, %607
  %vptr.i142.sroa.speculated.i1202 = phi ptr [ %616, %607 ], [ %650, %623 ]
  %.in1523 = phi <2 x i160> [ %622, %607 ], [ %656, %623 ]
  %657 = trunc <2 x i160> %.in1523 to <2 x i64>
  %658 = xor i1 %.070565.i1180, true
  %hash_coef_ptr.i.i143.i1205 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1202, i64 8
  %tbl_size_ptr.i.i144.i1206 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1202, i64 16
  %offset_tbl_ptr.i.i145.i1207 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1202, i64 40
  %hash_coef.i.i146.i1208 = load i64, ptr %hash_coef_ptr.i.i143.i1205, align 4
  %tbl_size.i.i147.i1209 = load i64, ptr %tbl_size_ptr.i.i144.i1206, align 4
  %offset_tbl.i.i148.i1210 = load ptr, ptr %offset_tbl_ptr.i.i145.i1207, align 8
  %product.i.i.i149.i1211 = mul i64 %hash_coef.i.i146.i1208, 4015701072841558310
  %shifted.i.i.i150.i1212 = lshr i64 %product.i.i.i149.i1211, 32
  %xored.i.i.i151.i1213 = xor i64 %shifted.i.i.i150.i1212, %product.i.i.i149.i1211
  %hash.i.i.i152.i1214 = and i64 %xored.i.i.i151.i1213, %tbl_size.i.i147.i1209
  %offset_ptr.i.i153.i1215 = getelementptr i32, ptr %offset_tbl.i.i148.i1210, i64 %hash.i.i.i152.i1214
  %offset.i.i154.i1216 = load i32, ptr %offset_ptr.i.i153.i1215, align 4
  %659 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %660 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %661 = icmp ult i32 %.0566.i1179, 99
  br i1 %661, label %592, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1234

662:                                              ; preds = %623, %607
  %663 = phi ptr [ %8, %623 ], [ %7, %607 ]
  %664 = load i32, ptr %27, align 4
  store i32 %664, ptr %663, align 4
  %665 = add i32 %664, 1
  %666 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %665, ptr %27, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1234

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1234: ; preds = %.cont.cont.i1199, %662
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i986

._crit_edge.i986:                                 ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1234, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968
  %667 = add nuw nsw i32 %.060.i984, 1
  %668 = icmp slt i32 %667, %484
  br i1 %668, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004: ; preds = %._crit_edge.i986, %480
  %669 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i588 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i589 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i590 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i591 = mul i64 %hash_coef.i.i99.i588, 4015701072841558310
  %shifted.i.i.i103.i592 = lshr i64 %product.i.i.i102.i591, 32
  %xored.i.i.i104.i593 = xor i64 %shifted.i.i.i103.i592, %product.i.i.i102.i591
  %hash.i.i.i105.i594 = and i64 %xored.i.i.i104.i593, %tbl_size.i.i100.i589
  %offset_ptr.i.i106.i595 = getelementptr i32, ptr %offset_tbl.i.i101.i590, i64 %hash.i.i.i105.i594
  %offset.i.i121.i596 = load i32, ptr %offset_ptr.i.i106.i595, align 4, !noalias !146
  %670 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %673

673:                                              ; preds = %.cont.cont.i618, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004
  %.0566.i598 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004 ], [ %677, %.cont.cont.i618 ]
  %.070565.i599 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004 ], [ %739, %.cont.cont.i618 ]
  %.sroa.0.0564.i600 = phi ptr [ %vptr.i142.sroa.speculated.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004 ], [ %vptr.i142.sroa.speculated.i621, %.cont.cont.i618 ]
  %.sroa.17.0561.i603 = phi i32 [ %offset.i.i121.i596, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004 ], [ %offset.i.i154.i635, %.cont.cont.i618 ]
  %674 = phi <2 x i64> [ %468, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004 ], [ %738, %.cont.cont.i618 ]
  %675 = extractelement <2 x i64> %674, i64 1
  %.sroa.12.0562.i602 = inttoptr i64 %675 to ptr
  %676 = extractelement <2 x i64> %674, i64 0
  %.sroa.6.0563.i601 = inttoptr i64 %676 to ptr
  %677 = add nuw nsw i32 %.0566.i598, 1
  %678 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i600, 0
  %679 = insertvalue { ptr, ptr, ptr, i32 } %678, ptr %.sroa.6.0563.i601, 1
  %680 = insertvalue { ptr, ptr, ptr, i32 } %679, ptr %.sroa.12.0562.i602, 2
  %681 = insertvalue { ptr, ptr, ptr, i32 } %680, i32 %.sroa.17.0561.i603, 3
  %682 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i600)
  %683 = sext i32 %.sroa.17.0561.i603 to i64
  %684 = getelementptr ptr, ptr %.sroa.0.0564.i600, i64 %683
  %685 = getelementptr i8, ptr %684, i64 64
  %686 = load ptr, ptr %685, align 8
  %result.i125.i604 = call ptr %686({ ptr, ptr, ptr, i32 } %681, ptr nocapture nofree noundef nonnull readonly %2) #16
  %687 = call i32 %result.i125.i604({ ptr, ptr, ptr, i32 } %681, { ptr, ptr, ptr, i32 } %681, ptr nonnull align 8 %2) #7
  br i1 %.070565.i599, label %688, label %704

688:                                              ; preds = %673
  %689 = load i32, ptr %22, align 8
  %690 = add i32 %689, -1
  %691 = and i32 %690, %687
  %692 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %693 = load ptr, ptr %23, align 8
  %694 = sext i32 %691 to i64
  %695 = shl nsw i64 %694, 5
  %696 = getelementptr i8, ptr %693, i64 %695
  %697 = load ptr, ptr %696, align 8
  %698 = getelementptr i8, ptr %696, i64 8
  %699 = load i160, ptr %698, align 4
  store ptr %.sroa.0.0564.i600, ptr %696, align 8
  store i64 %676, ptr %698, align 4
  %.sroa_idx157.i647 = getelementptr i8, ptr %696, i64 16
  store i64 %675, ptr %.sroa_idx157.i647, align 4
  %.sroa_idx158.i648 = getelementptr i8, ptr %696, i64 24
  store i32 %.sroa.17.0561.i603, ptr %.sroa_idx158.i648, align 4
  %700 = icmp ne ptr %697, @nil_typ
  %701 = icmp ne ptr %697, null
  %.not92.i649 = and i1 %700, %701
  %extract.i651 = lshr i160 %699, 64
  %702 = insertelement <2 x i160> poison, i160 %699, i64 0
  %703 = insertelement <2 x i160> %702, i160 %extract.i651, i64 1
  br i1 %.not92.i649, label %.cont.cont.i618, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.thread

704:                                              ; preds = %673
  %705 = add i32 %687, 2127912214
  %706 = shl i32 %687, 12
  %707 = add i32 %705, %706
  %708 = ashr i32 %707, 19
  %709 = xor i32 %707, %708
  %710 = xor i32 %709, -949894596
  %711 = add i32 %710, 374761393
  %712 = shl i32 %710, 5
  %713 = add i32 %711, %712
  %714 = add i32 %713, -744332180
  %715 = shl i32 %713, 9
  %716 = xor i32 %714, %715
  %717 = add i32 %716, -42973499
  %718 = shl i32 %716, 3
  %719 = add i32 %717, %718
  %720 = ashr i32 %719, 16
  %721 = xor i32 %719, %720
  %722 = xor i32 %721, -1252372727
  %723 = load i32, ptr %22, align 8
  %724 = add i32 %723, -1
  %725 = and i32 %724, %722
  %726 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %727 = load ptr, ptr %24, align 8
  %728 = sext i32 %725 to i64
  %729 = shl nsw i64 %728, 5
  %730 = getelementptr i8, ptr %727, i64 %729
  %731 = load ptr, ptr %730, align 8
  %732 = getelementptr i8, ptr %730, i64 8
  %733 = load i160, ptr %732, align 4
  store ptr %.sroa.0.0564.i600, ptr %730, align 8
  store i64 %676, ptr %732, align 4
  %.sroa_idx161.i608 = getelementptr i8, ptr %730, i64 16
  store i64 %675, ptr %.sroa_idx161.i608, align 4
  %.sroa_idx162.i609 = getelementptr i8, ptr %730, i64 24
  store i32 %.sroa.17.0561.i603, ptr %.sroa_idx162.i609, align 4
  %734 = icmp ne ptr %731, @nil_typ
  %735 = icmp ne ptr %731, null
  %.not90.i610 = and i1 %734, %735
  %extract607.i612 = lshr i160 %733, 64
  %736 = insertelement <2 x i160> poison, i160 %733, i64 0
  %737 = insertelement <2 x i160> %736, i160 %extract607.i612, i64 1
  br i1 %.not90.i610, label %.cont.cont.i618, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.thread

.cont.cont.i618:                                  ; preds = %704, %688
  %vptr.i142.sroa.speculated.i621 = phi ptr [ %697, %688 ], [ %731, %704 ]
  %.in1524 = phi <2 x i160> [ %703, %688 ], [ %737, %704 ]
  %738 = trunc <2 x i160> %.in1524 to <2 x i64>
  %739 = xor i1 %.070565.i599, true
  %hash_coef_ptr.i.i143.i624 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i621, i64 8
  %tbl_size_ptr.i.i144.i625 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i621, i64 16
  %offset_tbl_ptr.i.i145.i626 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i621, i64 40
  %hash_coef.i.i146.i627 = load i64, ptr %hash_coef_ptr.i.i143.i624, align 4
  %tbl_size.i.i147.i628 = load i64, ptr %tbl_size_ptr.i.i144.i625, align 4
  %offset_tbl.i.i148.i629 = load ptr, ptr %offset_tbl_ptr.i.i145.i626, align 8
  %product.i.i.i149.i630 = mul i64 %hash_coef.i.i146.i627, 4015701072841558310
  %shifted.i.i.i150.i631 = lshr i64 %product.i.i.i149.i630, 32
  %xored.i.i.i151.i632 = xor i64 %shifted.i.i.i150.i631, %product.i.i.i149.i630
  %hash.i.i.i152.i633 = and i64 %xored.i.i.i151.i632, %tbl_size.i.i147.i628
  %offset_ptr.i.i153.i634 = getelementptr i32, ptr %offset_tbl.i.i148.i629, i64 %hash.i.i.i152.i633
  %offset.i.i154.i635 = load i32, ptr %offset_ptr.i.i153.i634, align 4
  %740 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %741 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %742 = icmp ult i32 %.0566.i598, 99
  br i1 %742, label %673, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.thread: ; preds = %688, %704
  %743 = phi ptr [ %12, %704 ], [ %11, %688 ]
  %744 = load i32, ptr %27, align 4
  store i32 %744, ptr %743, align 4
  %745 = add i32 %744, 1
  %746 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %745, ptr %27, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653: ; preds = %.cont.cont.i618
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  %747 = icmp eq ptr %vptr.i142.sroa.speculated.i621, null
  br i1 %747, label %CuckooMap_insert_keyK_valueV.exit, label %748

748:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653
  %749 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %750 = load ptr, ptr %23, align 8
  %751 = load ptr, ptr %24, align 8
  %752 = load i32, ptr %22, align 8
  %753 = shl i32 %752, 1
  %spec.select.i669 = call i32 @llvm.smax.i32(i32 %753, i32 16)
  store i32 %spec.select.i669, ptr %22, align 8
  %754 = zext nneg i32 %spec.select.i669 to i64
  %755 = shl nuw nsw i64 %754, 5
  %result.i.i670 = call noalias ptr @bump_malloc_inner(i64 noundef %755, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i670, ptr %23, align 8
  %result.i20.i671 = call noalias ptr @bump_malloc_inner(i64 noundef %755, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i671, ptr %24, align 8
  store i32 0, ptr %27, align 4
  %756 = icmp sgt i32 %752, 0
  br i1 %756, label %.lr.ph.i1034, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.thread: ; preds = %748
  %757 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i1034:                                     ; preds = %748, %._crit_edge.i1049
  %.060.i1047 = phi i32 [ %846, %._crit_edge.i1049 ], [ 0, %748 ]
  %758 = zext nneg i32 %.060.i1047 to i64
  %759 = shl nuw nsw i64 %758, 5
  %760 = getelementptr i8, ptr %750, i64 %759
  %761 = load ptr, ptr %760, align 8
  %762 = icmp ne ptr %761, @nil_typ
  %763 = icmp ne ptr %761, null
  %.not16.i1048 = and i1 %762, %763
  br i1 %.not16.i1048, label %764, label %._crit_edge.i1049

764:                                              ; preds = %.lr.ph.i1034
  %765 = getelementptr i8, ptr %760, i64 8
  %766 = load <2 x i64>, ptr %765, align 4
  %hash_coef_ptr.i.i18.i1051 = getelementptr i8, ptr %761, i64 8
  %tbl_size_ptr.i.i19.i1052 = getelementptr i8, ptr %761, i64 16
  %offset_tbl_ptr.i.i20.i1053 = getelementptr i8, ptr %761, i64 40
  %767 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i1252 = load i64, ptr %hash_coef_ptr.i.i18.i1051, align 4, !noalias !22
  %tbl_size.i.i100.i1253 = load i64, ptr %tbl_size_ptr.i.i19.i1052, align 4, !noalias !22
  %offset_tbl.i.i101.i1254 = load ptr, ptr %offset_tbl_ptr.i.i20.i1053, align 8, !noalias !22
  %product.i.i.i102.i1255 = mul i64 %hash_coef.i.i99.i1252, 4015701072841558310
  %shifted.i.i.i103.i1256 = lshr i64 %product.i.i.i102.i1255, 32
  %xored.i.i.i104.i1257 = xor i64 %shifted.i.i.i103.i1256, %product.i.i.i102.i1255
  %hash.i.i.i105.i1258 = and i64 %xored.i.i.i104.i1257, %tbl_size.i.i100.i1253
  %offset_ptr.i.i106.i1259 = getelementptr i32, ptr %offset_tbl.i.i101.i1254, i64 %hash.i.i.i105.i1258
  %offset.i.i121.i1260 = load i32, ptr %offset_ptr.i.i106.i1259, align 4, !noalias !149
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %770 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %771

771:                                              ; preds = %.cont.cont.i1281, %764
  %.0566.i1261 = phi i32 [ 0, %764 ], [ %775, %.cont.cont.i1281 ]
  %.070565.i1262 = phi i1 [ true, %764 ], [ %837, %.cont.cont.i1281 ]
  %.sroa.0.0564.i1263 = phi ptr [ %761, %764 ], [ %vptr.i142.sroa.speculated.i1284, %.cont.cont.i1281 ]
  %.sroa.17.0561.i1266 = phi i32 [ %offset.i.i121.i1260, %764 ], [ %offset.i.i154.i1298, %.cont.cont.i1281 ]
  %772 = phi <2 x i64> [ %766, %764 ], [ %836, %.cont.cont.i1281 ]
  %773 = extractelement <2 x i64> %772, i64 1
  %.sroa.12.0562.i1265 = inttoptr i64 %773 to ptr
  %774 = extractelement <2 x i64> %772, i64 0
  %.sroa.6.0563.i1264 = inttoptr i64 %774 to ptr
  %775 = add nuw nsw i32 %.0566.i1261, 1
  %776 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1263, 0
  %777 = insertvalue { ptr, ptr, ptr, i32 } %776, ptr %.sroa.6.0563.i1264, 1
  %778 = insertvalue { ptr, ptr, ptr, i32 } %777, ptr %.sroa.12.0562.i1265, 2
  %779 = insertvalue { ptr, ptr, ptr, i32 } %778, i32 %.sroa.17.0561.i1266, 3
  %780 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1263)
  %781 = sext i32 %.sroa.17.0561.i1266 to i64
  %782 = getelementptr ptr, ptr %.sroa.0.0564.i1263, i64 %781
  %783 = getelementptr i8, ptr %782, i64 64
  %784 = load ptr, ptr %783, align 8
  %result.i125.i1267 = call ptr %784({ ptr, ptr, ptr, i32 } %779, ptr nocapture nofree noundef nonnull readonly %2) #16
  %785 = call i32 %result.i125.i1267({ ptr, ptr, ptr, i32 } %779, { ptr, ptr, ptr, i32 } %779, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1262, label %786, label %802

786:                                              ; preds = %771
  %787 = load i32, ptr %22, align 8
  %788 = add i32 %787, -1
  %789 = and i32 %788, %785
  %790 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %791 = load ptr, ptr %23, align 8
  %792 = sext i32 %789 to i64
  %793 = shl nsw i64 %792, 5
  %794 = getelementptr i8, ptr %791, i64 %793
  %795 = load ptr, ptr %794, align 8
  %796 = getelementptr i8, ptr %794, i64 8
  %797 = load i160, ptr %796, align 4
  store ptr %.sroa.0.0564.i1263, ptr %794, align 8
  store i64 %774, ptr %796, align 4
  %.sroa_idx157.i1310 = getelementptr i8, ptr %794, i64 16
  store i64 %773, ptr %.sroa_idx157.i1310, align 4
  %.sroa_idx158.i1311 = getelementptr i8, ptr %794, i64 24
  store i32 %.sroa.17.0561.i1266, ptr %.sroa_idx158.i1311, align 4
  %798 = icmp ne ptr %795, @nil_typ
  %799 = icmp ne ptr %795, null
  %.not92.i1312 = and i1 %798, %799
  %extract.i1314 = lshr i160 %797, 64
  %800 = insertelement <2 x i160> poison, i160 %797, i64 0
  %801 = insertelement <2 x i160> %800, i160 %extract.i1314, i64 1
  br i1 %.not92.i1312, label %.cont.cont.i1281, label %841

802:                                              ; preds = %771
  %803 = add i32 %785, 2127912214
  %804 = shl i32 %785, 12
  %805 = add i32 %803, %804
  %806 = ashr i32 %805, 19
  %807 = xor i32 %805, %806
  %808 = xor i32 %807, -949894596
  %809 = add i32 %808, 374761393
  %810 = shl i32 %808, 5
  %811 = add i32 %809, %810
  %812 = add i32 %811, -744332180
  %813 = shl i32 %811, 9
  %814 = xor i32 %812, %813
  %815 = add i32 %814, -42973499
  %816 = shl i32 %814, 3
  %817 = add i32 %815, %816
  %818 = ashr i32 %817, 16
  %819 = xor i32 %817, %818
  %820 = xor i32 %819, -1252372727
  %821 = load i32, ptr %22, align 8
  %822 = add i32 %821, -1
  %823 = and i32 %822, %820
  %824 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %825 = load ptr, ptr %24, align 8
  %826 = sext i32 %823 to i64
  %827 = shl nsw i64 %826, 5
  %828 = getelementptr i8, ptr %825, i64 %827
  %829 = load ptr, ptr %828, align 8
  %830 = getelementptr i8, ptr %828, i64 8
  %831 = load i160, ptr %830, align 4
  store ptr %.sroa.0.0564.i1263, ptr %828, align 8
  store i64 %774, ptr %830, align 4
  %.sroa_idx161.i1271 = getelementptr i8, ptr %828, i64 16
  store i64 %773, ptr %.sroa_idx161.i1271, align 4
  %.sroa_idx162.i1272 = getelementptr i8, ptr %828, i64 24
  store i32 %.sroa.17.0561.i1266, ptr %.sroa_idx162.i1272, align 4
  %832 = icmp ne ptr %829, @nil_typ
  %833 = icmp ne ptr %829, null
  %.not90.i1273 = and i1 %832, %833
  %extract607.i1275 = lshr i160 %831, 64
  %834 = insertelement <2 x i160> poison, i160 %831, i64 0
  %835 = insertelement <2 x i160> %834, i160 %extract607.i1275, i64 1
  br i1 %.not90.i1273, label %.cont.cont.i1281, label %841

.cont.cont.i1281:                                 ; preds = %802, %786
  %vptr.i142.sroa.speculated.i1284 = phi ptr [ %795, %786 ], [ %829, %802 ]
  %.in1525 = phi <2 x i160> [ %801, %786 ], [ %835, %802 ]
  %836 = trunc <2 x i160> %.in1525 to <2 x i64>
  %837 = xor i1 %.070565.i1262, true
  %hash_coef_ptr.i.i143.i1287 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1284, i64 8
  %tbl_size_ptr.i.i144.i1288 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1284, i64 16
  %offset_tbl_ptr.i.i145.i1289 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1284, i64 40
  %hash_coef.i.i146.i1290 = load i64, ptr %hash_coef_ptr.i.i143.i1287, align 4
  %tbl_size.i.i147.i1291 = load i64, ptr %tbl_size_ptr.i.i144.i1288, align 4
  %offset_tbl.i.i148.i1292 = load ptr, ptr %offset_tbl_ptr.i.i145.i1289, align 8
  %product.i.i.i149.i1293 = mul i64 %hash_coef.i.i146.i1290, 4015701072841558310
  %shifted.i.i.i150.i1294 = lshr i64 %product.i.i.i149.i1293, 32
  %xored.i.i.i151.i1295 = xor i64 %shifted.i.i.i150.i1294, %product.i.i.i149.i1293
  %hash.i.i.i152.i1296 = and i64 %xored.i.i.i151.i1295, %tbl_size.i.i147.i1291
  %offset_ptr.i.i153.i1297 = getelementptr i32, ptr %offset_tbl.i.i148.i1292, i64 %hash.i.i.i152.i1296
  %offset.i.i154.i1298 = load i32, ptr %offset_ptr.i.i153.i1297, align 4
  %838 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %839 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %840 = icmp ult i32 %.0566.i1261, 99
  br i1 %840, label %771, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1316

841:                                              ; preds = %802, %786
  %842 = phi ptr [ %6, %802 ], [ %5, %786 ]
  %843 = load i32, ptr %27, align 4
  store i32 %843, ptr %842, align 4
  %844 = add i32 %843, 1
  %845 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %844, ptr %27, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1316

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1316: ; preds = %.cont.cont.i1281, %841
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i1049

._crit_edge.i1049:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1316, %.lr.ph.i1034
  %846 = add nuw nsw i32 %.060.i1047, 1
  %847 = icmp slt i32 %846, %752
  br i1 %847, label %.lr.ph.i1034, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067: ; preds = %._crit_edge.i1049
  %848 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %849

849:                                              ; preds = %._crit_edge.i1085, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067
  %.060.i1083 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067 ], [ %938, %._crit_edge.i1085 ]
  %850 = zext nneg i32 %.060.i1083 to i64
  %851 = shl nuw nsw i64 %850, 5
  %852 = getelementptr i8, ptr %751, i64 %851
  %853 = load ptr, ptr %852, align 8
  %854 = icmp ne ptr %853, @nil_typ
  %855 = icmp ne ptr %853, null
  %.not16.i1084 = and i1 %854, %855
  br i1 %.not16.i1084, label %856, label %._crit_edge.i1085

856:                                              ; preds = %849
  %857 = getelementptr i8, ptr %852, i64 8
  %858 = load <2 x i64>, ptr %857, align 4
  %hash_coef_ptr.i.i18.i1087 = getelementptr i8, ptr %853, i64 8
  %tbl_size_ptr.i.i19.i1088 = getelementptr i8, ptr %853, i64 16
  %offset_tbl_ptr.i.i20.i1089 = getelementptr i8, ptr %853, i64 40
  %859 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i1334 = load i64, ptr %hash_coef_ptr.i.i18.i1087, align 4, !noalias !22
  %tbl_size.i.i100.i1335 = load i64, ptr %tbl_size_ptr.i.i19.i1088, align 4, !noalias !22
  %offset_tbl.i.i101.i1336 = load ptr, ptr %offset_tbl_ptr.i.i20.i1089, align 8, !noalias !22
  %product.i.i.i102.i1337 = mul i64 %hash_coef.i.i99.i1334, 4015701072841558310
  %shifted.i.i.i103.i1338 = lshr i64 %product.i.i.i102.i1337, 32
  %xored.i.i.i104.i1339 = xor i64 %shifted.i.i.i103.i1338, %product.i.i.i102.i1337
  %hash.i.i.i105.i1340 = and i64 %xored.i.i.i104.i1339, %tbl_size.i.i100.i1335
  %offset_ptr.i.i106.i1341 = getelementptr i32, ptr %offset_tbl.i.i101.i1336, i64 %hash.i.i.i105.i1340
  %offset.i.i121.i1342 = load i32, ptr %offset_ptr.i.i106.i1341, align 4, !noalias !152
  %860 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %861 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %862 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %863

863:                                              ; preds = %.cont.cont.i1363, %856
  %.0566.i1343 = phi i32 [ 0, %856 ], [ %867, %.cont.cont.i1363 ]
  %.070565.i1344 = phi i1 [ true, %856 ], [ %929, %.cont.cont.i1363 ]
  %.sroa.0.0564.i1345 = phi ptr [ %853, %856 ], [ %vptr.i142.sroa.speculated.i1366, %.cont.cont.i1363 ]
  %.sroa.17.0561.i1348 = phi i32 [ %offset.i.i121.i1342, %856 ], [ %offset.i.i154.i1380, %.cont.cont.i1363 ]
  %864 = phi <2 x i64> [ %858, %856 ], [ %928, %.cont.cont.i1363 ]
  %865 = extractelement <2 x i64> %864, i64 1
  %.sroa.12.0562.i1347 = inttoptr i64 %865 to ptr
  %866 = extractelement <2 x i64> %864, i64 0
  %.sroa.6.0563.i1346 = inttoptr i64 %866 to ptr
  %867 = add nuw nsw i32 %.0566.i1343, 1
  %868 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1345, 0
  %869 = insertvalue { ptr, ptr, ptr, i32 } %868, ptr %.sroa.6.0563.i1346, 1
  %870 = insertvalue { ptr, ptr, ptr, i32 } %869, ptr %.sroa.12.0562.i1347, 2
  %871 = insertvalue { ptr, ptr, ptr, i32 } %870, i32 %.sroa.17.0561.i1348, 3
  %872 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1345)
  %873 = sext i32 %.sroa.17.0561.i1348 to i64
  %874 = getelementptr ptr, ptr %.sroa.0.0564.i1345, i64 %873
  %875 = getelementptr i8, ptr %874, i64 64
  %876 = load ptr, ptr %875, align 8
  %result.i125.i1349 = call ptr %876({ ptr, ptr, ptr, i32 } %871, ptr nocapture nofree noundef nonnull readonly %2) #16
  %877 = call i32 %result.i125.i1349({ ptr, ptr, ptr, i32 } %871, { ptr, ptr, ptr, i32 } %871, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1344, label %878, label %894

878:                                              ; preds = %863
  %879 = load i32, ptr %22, align 8
  %880 = add i32 %879, -1
  %881 = and i32 %880, %877
  %882 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %883 = load ptr, ptr %23, align 8
  %884 = sext i32 %881 to i64
  %885 = shl nsw i64 %884, 5
  %886 = getelementptr i8, ptr %883, i64 %885
  %887 = load ptr, ptr %886, align 8
  %888 = getelementptr i8, ptr %886, i64 8
  %889 = load i160, ptr %888, align 4
  store ptr %.sroa.0.0564.i1345, ptr %886, align 8
  store i64 %866, ptr %888, align 4
  %.sroa_idx157.i1392 = getelementptr i8, ptr %886, i64 16
  store i64 %865, ptr %.sroa_idx157.i1392, align 4
  %.sroa_idx158.i1393 = getelementptr i8, ptr %886, i64 24
  store i32 %.sroa.17.0561.i1348, ptr %.sroa_idx158.i1393, align 4
  %890 = icmp ne ptr %887, @nil_typ
  %891 = icmp ne ptr %887, null
  %.not92.i1394 = and i1 %890, %891
  %extract.i1396 = lshr i160 %889, 64
  %892 = insertelement <2 x i160> poison, i160 %889, i64 0
  %893 = insertelement <2 x i160> %892, i160 %extract.i1396, i64 1
  br i1 %.not92.i1394, label %.cont.cont.i1363, label %933

894:                                              ; preds = %863
  %895 = add i32 %877, 2127912214
  %896 = shl i32 %877, 12
  %897 = add i32 %895, %896
  %898 = ashr i32 %897, 19
  %899 = xor i32 %897, %898
  %900 = xor i32 %899, -949894596
  %901 = add i32 %900, 374761393
  %902 = shl i32 %900, 5
  %903 = add i32 %901, %902
  %904 = add i32 %903, -744332180
  %905 = shl i32 %903, 9
  %906 = xor i32 %904, %905
  %907 = add i32 %906, -42973499
  %908 = shl i32 %906, 3
  %909 = add i32 %907, %908
  %910 = ashr i32 %909, 16
  %911 = xor i32 %909, %910
  %912 = xor i32 %911, -1252372727
  %913 = load i32, ptr %22, align 8
  %914 = add i32 %913, -1
  %915 = and i32 %914, %912
  %916 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %917 = load ptr, ptr %24, align 8
  %918 = sext i32 %915 to i64
  %919 = shl nsw i64 %918, 5
  %920 = getelementptr i8, ptr %917, i64 %919
  %921 = load ptr, ptr %920, align 8
  %922 = getelementptr i8, ptr %920, i64 8
  %923 = load i160, ptr %922, align 4
  store ptr %.sroa.0.0564.i1345, ptr %920, align 8
  store i64 %866, ptr %922, align 4
  %.sroa_idx161.i1353 = getelementptr i8, ptr %920, i64 16
  store i64 %865, ptr %.sroa_idx161.i1353, align 4
  %.sroa_idx162.i1354 = getelementptr i8, ptr %920, i64 24
  store i32 %.sroa.17.0561.i1348, ptr %.sroa_idx162.i1354, align 4
  %924 = icmp ne ptr %921, @nil_typ
  %925 = icmp ne ptr %921, null
  %.not90.i1355 = and i1 %924, %925
  %extract607.i1357 = lshr i160 %923, 64
  %926 = insertelement <2 x i160> poison, i160 %923, i64 0
  %927 = insertelement <2 x i160> %926, i160 %extract607.i1357, i64 1
  br i1 %.not90.i1355, label %.cont.cont.i1363, label %933

.cont.cont.i1363:                                 ; preds = %894, %878
  %vptr.i142.sroa.speculated.i1366 = phi ptr [ %887, %878 ], [ %921, %894 ]
  %.in1526 = phi <2 x i160> [ %893, %878 ], [ %927, %894 ]
  %928 = trunc <2 x i160> %.in1526 to <2 x i64>
  %929 = xor i1 %.070565.i1344, true
  %hash_coef_ptr.i.i143.i1369 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1366, i64 8
  %tbl_size_ptr.i.i144.i1370 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1366, i64 16
  %offset_tbl_ptr.i.i145.i1371 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1366, i64 40
  %hash_coef.i.i146.i1372 = load i64, ptr %hash_coef_ptr.i.i143.i1369, align 4
  %tbl_size.i.i147.i1373 = load i64, ptr %tbl_size_ptr.i.i144.i1370, align 4
  %offset_tbl.i.i148.i1374 = load ptr, ptr %offset_tbl_ptr.i.i145.i1371, align 8
  %product.i.i.i149.i1375 = mul i64 %hash_coef.i.i146.i1372, 4015701072841558310
  %shifted.i.i.i150.i1376 = lshr i64 %product.i.i.i149.i1375, 32
  %xored.i.i.i151.i1377 = xor i64 %shifted.i.i.i150.i1376, %product.i.i.i149.i1375
  %hash.i.i.i152.i1378 = and i64 %xored.i.i.i151.i1377, %tbl_size.i.i147.i1373
  %offset_ptr.i.i153.i1379 = getelementptr i32, ptr %offset_tbl.i.i148.i1374, i64 %hash.i.i.i152.i1378
  %offset.i.i154.i1380 = load i32, ptr %offset_ptr.i.i153.i1379, align 4
  %930 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %931 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %932 = icmp ult i32 %.0566.i1343, 99
  br i1 %932, label %863, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1398

933:                                              ; preds = %894, %878
  %934 = phi ptr [ %4, %894 ], [ %3, %878 ]
  %935 = load i32, ptr %27, align 4
  store i32 %935, ptr %934, align 4
  %936 = add i32 %935, 1
  %937 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %936, ptr %27, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1398

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1398: ; preds = %.cont.cont.i1363, %933
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i1085

._crit_edge.i1085:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1398, %849
  %938 = add nuw nsw i32 %.060.i1083, 1
  %939 = icmp slt i32 %938, %752
  br i1 %939, label %849, label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i1085, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit513, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %940 = zext nneg i32 %32 to i64
  %941 = add i64 %.0139250, %940
  %942 = icmp slt i32 %32, %0
  br i1 %942, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %CuckooMap_insert_keyK_valueV.exit
  %943 = call i64 @clock()
  br label %944

944:                                              ; preds = %.lr.ph, %._crit_edge2
  %.2254 = phi i32 [ 0, %.lr.ph ], [ %1072, %._crit_edge2 ]
  %.0141253 = phi i64 [ 0, %.lr.ph ], [ %.2143, %._crit_edge2 ]
  %.0144252 = phi i1 [ true, %.lr.ph ], [ %.2146, %._crit_edge2 ]
  %.sroa.0117.0.insert.ext = zext nneg i32 %.2254 to i160
  %945 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext, 1
  %946 = load ptr, ptr %20, align 8
  %947 = call i32 %946({ ptr, i160 } %945) #7
  %948 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %949 = load i32, ptr %22, align 8
  %950 = add i32 %949, -1
  %951 = and i32 %950, %947
  %952 = load ptr, ptr %23, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %953 = sext i32 %951 to i64
  %954 = shl nsw i64 %953, 5
  %955 = getelementptr i8, ptr %952, i64 %954
  %956 = load ptr, ptr %955, align 8
  %957 = icmp ne ptr %956, @nil_typ
  %958 = icmp ne ptr %956, null
  %.not44.i = and i1 %957, %958
  br i1 %.not44.i, label %959, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

959:                                              ; preds = %944
  %960 = getelementptr i8, ptr %955, i64 8
  %961 = load i64, ptr %960, align 4
  %.sroa_idx.i716 = getelementptr i8, ptr %955, i64 16
  %962 = load i64, ptr %.sroa_idx.i716, align 4
  %963 = inttoptr i64 %961 to ptr
  %964 = inttoptr i64 %962 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %956, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %956, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %956, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !155
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !155
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !155
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !155
  %965 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %956, 0
  %966 = insertvalue { ptr, ptr, ptr, i32 } %965, ptr %963, 1
  %967 = insertvalue { ptr, ptr, ptr, i32 } %966, ptr %964, 2
  %968 = insertvalue { ptr, ptr, ptr, i32 } %967, i32 %offset.i.i57.i, 3
  %969 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %970 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %956) #35
  %971 = sext i32 %offset.i.i57.i to i64
  %972 = getelementptr ptr, ptr %956, i64 %971
  %973 = getelementptr i8, ptr %972, i64 64
  %974 = load ptr, ptr %973, align 8
  %result.i.i717 = call ptr %974({ ptr, ptr, ptr, i32 } %968, ptr nocapture nofree noundef nonnull readonly %2) #16
  %975 = call i32 %result.i.i717({ ptr, ptr, ptr, i32 } %968, { ptr, ptr, ptr, i32 } %968, ptr nonnull align 8 %2) #7
  %976 = icmp eq i32 %975, %947
  br i1 %976, label %._crit_edge.i718, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i718:                                 ; preds = %959
  %977 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %956)
  %979 = getelementptr i8, ptr %972, i64 48
  %980 = load ptr, ptr %979, align 8
  %result.i59.i = call ptr %980({ ptr, ptr, ptr, i32 } %968, ptr nocapture nofree noundef nonnull readonly %2) #16
  %981 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %968, { ptr, ptr, ptr, i32 } %968, ptr nonnull align 8 %2) #7
  %982 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %983 = load ptr, ptr %21, align 8
  %984 = call i1 %983({ ptr, i160 } %981, { ptr, i160 } %945) #7
  br i1 %984, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i718, %944, %959
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %993

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i718
  %985 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %986 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %956)
  %987 = getelementptr i8, ptr %972, i64 56
  %988 = load ptr, ptr %987, align 8
  %result.i60.i = call ptr %988({ ptr, ptr, ptr, i32 } %968, ptr nocapture nofree noundef nonnull readonly %2) #16
  %989 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %968, { ptr, ptr, ptr, i32 } %968, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %989, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %991 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %992 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %991, %992
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %993

993:                                              ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %994 = add i32 %947, 2127912214
  %995 = shl i32 %947, 12
  %996 = add i32 %994, %995
  %997 = ashr i32 %996, 19
  %998 = xor i32 %996, %997
  %999 = xor i32 %998, -949894596
  %1000 = add i32 %999, 374761393
  %1001 = shl i32 %999, 5
  %1002 = add i32 %1000, %1001
  %1003 = add i32 %1002, -744332180
  %1004 = shl i32 %1002, 9
  %1005 = xor i32 %1003, %1004
  %1006 = add i32 %1005, -42973499
  %1007 = shl i32 %1005, 3
  %1008 = add i32 %1006, %1007
  %1009 = ashr i32 %1008, 16
  %1010 = xor i32 %1008, %1009
  %1011 = xor i32 %1010, -1252372727
  %1012 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1013 = load i32, ptr %22, align 8
  %1014 = add i32 %1013, -1
  %1015 = and i32 %1014, %1011
  %1016 = load ptr, ptr %24, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1017 = sext i32 %1015 to i64
  %1018 = shl nsw i64 %1017, 5
  %1019 = getelementptr i8, ptr %1016, i64 %1018
  %1020 = load ptr, ptr %1019, align 8
  %1021 = icmp ne ptr %1020, @nil_typ
  %1022 = icmp ne ptr %1020, null
  %.not44.i748 = and i1 %1021, %1022
  br i1 %.not44.i748, label %1023, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772

1023:                                             ; preds = %993
  %1024 = getelementptr i8, ptr %1019, i64 8
  %1025 = load i64, ptr %1024, align 4
  %.sroa_idx.i752 = getelementptr i8, ptr %1019, i64 16
  %1026 = load i64, ptr %.sroa_idx.i752, align 4
  %1027 = inttoptr i64 %1025 to ptr
  %1028 = inttoptr i64 %1026 to ptr
  %hash_coef_ptr.i.i46.i753 = getelementptr i8, ptr %1020, i64 8
  %tbl_size_ptr.i.i47.i754 = getelementptr i8, ptr %1020, i64 16
  %offset_tbl_ptr.i.i48.i755 = getelementptr i8, ptr %1020, i64 40
  %hash_coef.i.i49.i756 = load i64, ptr %hash_coef_ptr.i.i46.i753, align 4, !noalias !158
  %tbl_size.i.i50.i757 = load i64, ptr %tbl_size_ptr.i.i47.i754, align 4, !noalias !158
  %offset_tbl.i.i51.i758 = load ptr, ptr %offset_tbl_ptr.i.i48.i755, align 8, !noalias !158
  %product.i.i.i52.i759 = mul i64 %hash_coef.i.i49.i756, 4015701072841558310
  %shifted.i.i.i53.i760 = lshr i64 %product.i.i.i52.i759, 32
  %xored.i.i.i54.i761 = xor i64 %shifted.i.i.i53.i760, %product.i.i.i52.i759
  %hash.i.i.i55.i762 = and i64 %xored.i.i.i54.i761, %tbl_size.i.i50.i757
  %offset_ptr.i.i56.i763 = getelementptr i32, ptr %offset_tbl.i.i51.i758, i64 %hash.i.i.i55.i762
  %offset.i.i57.i764 = load i32, ptr %offset_ptr.i.i56.i763, align 4, !noalias !158
  %1029 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1020, 0
  %1030 = insertvalue { ptr, ptr, ptr, i32 } %1029, ptr %1027, 1
  %1031 = insertvalue { ptr, ptr, ptr, i32 } %1030, ptr %1028, 2
  %1032 = insertvalue { ptr, ptr, ptr, i32 } %1031, i32 %offset.i.i57.i764, 3
  %1033 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1034 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1020) #35
  %1035 = sext i32 %offset.i.i57.i764 to i64
  %1036 = getelementptr ptr, ptr %1020, i64 %1035
  %1037 = getelementptr i8, ptr %1036, i64 64
  %1038 = load ptr, ptr %1037, align 8
  %result.i.i765 = call ptr %1038({ ptr, ptr, ptr, i32 } %1032, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1039 = call i32 %result.i.i765({ ptr, ptr, ptr, i32 } %1032, { ptr, ptr, ptr, i32 } %1032, ptr nonnull align 8 %2) #7
  %1040 = icmp eq i32 %1039, %947
  br i1 %1040, label %._crit_edge.i766, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772

._crit_edge.i766:                                 ; preds = %1023
  %1041 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1042 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1020)
  %1043 = getelementptr i8, ptr %1036, i64 48
  %1044 = load ptr, ptr %1043, align 8
  %result.i59.i767 = call ptr %1044({ ptr, ptr, ptr, i32 } %1032, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1045 = call { ptr, i160 } %result.i59.i767({ ptr, ptr, ptr, i32 } %1032, { ptr, ptr, ptr, i32 } %1032, ptr nonnull align 8 %2) #7
  %1046 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1047 = load ptr, ptr %21, align 8
  %1048 = call i1 %1047({ ptr, i160 } %1045, { ptr, i160 } %945) #7
  br i1 %1048, label %1049, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772

1049:                                             ; preds = %._crit_edge.i766
  %1050 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1051 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1020)
  %1052 = getelementptr i8, ptr %1036, i64 56
  %1053 = load ptr, ptr %1052, align 8
  %result.i60.i769 = call ptr %1053({ ptr, ptr, ptr, i32 } %1032, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1054 = call { ptr, i160 } %result.i60.i769({ ptr, ptr, ptr, i32 } %1032, { ptr, ptr, ptr, i32 } %1032, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i770 = extractvalue { ptr, i160 } %1054, 0
  %.fca.1.extract22.i771 = extractvalue { ptr, i160 } %1054, 1
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772: ; preds = %993, %1023, %._crit_edge.i766, %1049
  %.reg2mem43.sroa.3.077.i749 = phi i160 [ %.fca.1.extract22.i771, %1049 ], [ poison, %._crit_edge.i766 ], [ poison, %993 ], [ poison, %1023 ]
  %1055 = phi ptr [ %.fca.0.extract21.i770, %1049 ], [ @nil_typ, %._crit_edge.i766 ], [ @nil_typ, %993 ], [ @nil_typ, %1023 ]
  %.reload40.fca.0.insert.i750 = insertvalue { ptr, i160 } poison, ptr %1055, 0
  %.reload40.fca.1.insert.i751 = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i750, i160 %.reg2mem43.sroa.3.077.i749, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1056 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1057 = icmp ne ptr %1055, @nil_typ
  %1058 = icmp ne ptr %1055, null
  %.not65.not.not.i = and i1 %1057, %1058
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %1055, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772
  %.pn.i = phi { ptr, i160 } [ %989, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %.reload40.fca.1.insert.i751, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772 ]
  %1059 = phi ptr [ %.fca.0.extract21.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772 ]
  %1060 = icmp ne ptr %1059, @nil_typ
  %1061 = icmp ne ptr %1059, null
  %.not150 = and i1 %1060, %1061
  br i1 %.not150, label %1062, label %._crit_edge.lr.ph.i

1062:                                             ; preds = %CuckooMap_get_keyK.exit
  %.fca.1.extract..sroa.354.0106.i = extractvalue { ptr, i160 } %.pn.i, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0106.i to i32
  %1063 = sext i32 %.sroa.2.8.extract.trunc to i64
  %1064 = add i64 %.0141253, %1063
  br label %._crit_edge2

._crit_edge.lr.ph.i:                              ; preds = %CuckooMap_get_keyK.exit
  %result.i161 = call noalias align 64 dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %1065 = load <55 x i8>, ptr @gvbps_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  store <55 x i8> %1065, ptr %result.i161, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1066 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i786 = call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(55) %result.i.i786, ptr noundef nonnull align 64 dereferenceable(55) %result.i161, i64 55, i1 false)
  %1068 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %1069 = getelementptr i8, ptr %result.i.i786, i64 55
  store i8 0, ptr %1069, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i786)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1071 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2254) #17
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %1062, %._crit_edge.lr.ph.i
  %.2146 = phi i1 [ %.0144252, %1062 ], [ false, %._crit_edge.lr.ph.i ]
  %.2143 = phi i64 [ %1064, %1062 ], [ %.0141253, %._crit_edge.lr.ph.i ]
  %1072 = add nuw nsw i32 %.2254, 1
  %1073 = icmp slt i32 %1072, %0
  br i1 %1073, label %944, label %._crit_edge.lr.ph.i802

._crit_edge.lr.ph.i802:                           ; preds = %._crit_edge2, %._crit_edge1._crit_edge.thread
  %1074 = phi i64 [ %31, %._crit_edge1._crit_edge.thread ], [ %943, %._crit_edge2 ]
  %.0139.lcssa260 = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %941, %._crit_edge2 ]
  %.0144.lcssa = phi i1 [ true, %._crit_edge1._crit_edge.thread ], [ %.2146, %._crit_edge2 ]
  %.0141.lcssa = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %.2143, %._crit_edge2 ]
  %1075 = call i64 @clock()
  %result.i167 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i167, align 32
  %1076 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1077 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1078 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i801 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i801, ptr noundef nonnull align 32 dereferenceable(18) %result.i167, i64 18, i1 false)
  %1079 = sub i64 %1075, %1074
  %1080 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %1081 = getelementptr i8, ptr %result.i.i801, i64 18
  store i8 0, ptr %1081, align 1
  %puts.i382 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i801)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i98.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98.i, align 16
  %result.i.i356.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i98.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356.i)
  %1082 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #17
  %result.i104.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104.i, align 16
  %result.i.i370.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i104.i, i64 14, i1 false)
  %puts.i294.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370.i)
  %1083 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1079) #17
  %result.i110.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110.i, align 4
  %result.i.i389.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i110.i, i64 3, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  br i1 %26, label %._crit_edge1.i, label %._crit_edge.lr.ph.i821

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i802
  %1084 = icmp sgt i64 %1079, 0
  br i1 %1084, label %1085, label %._crit_edge.lr.ph.i409.i

1085:                                             ; preds = %._crit_edge1.i
  %1086 = mul i64 %1079, 1000000
  %1087 = zext nneg i32 %0 to i64
  %1088 = sdiv i64 %1086, %1087
  br label %._crit_edge.lr.ph.i409.i

._crit_edge.lr.ph.i409.i:                         ; preds = %1085, %._crit_edge1.i
  %.0.i = phi i64 [ %1088, %1085 ], [ 0, %._crit_edge1.i ]
  %result.i115.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115.i, align 16
  %result.i.i408.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i115.i, i64 15, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  %1089 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i121.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121.i, align 4
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i427.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i121.i, i64 3, i1 false)
  %1091 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  br label %._crit_edge.lr.ph.i821

._crit_edge.lr.ph.i821:                           ; preds = %._crit_edge.lr.ph.i802, %._crit_edge.lr.ph.i409.i
  %.not = icmp eq i64 %.0141.lcssa, %.0139.lcssa260
  %result.i171 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i171, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1092 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1093 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i820 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i820, ptr noundef nonnull align 32 dereferenceable(18) %result.i171, i64 18, i1 false)
  %spec.select = select i1 %.not, i1 %.0144.lcssa, i1 false
  %1094 = getelementptr i8, ptr %result.i.i820, i64 18
  store i8 0, ptr %1094, align 1
  %puts.i402 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i820)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %spec.select, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %1095 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1096 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1097 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i839 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <4 x i8> %., ptr %result.i.i839, align 1
  %1098 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %1099 = getelementptr i8, ptr %result.i.i839, i64 4
  store i8 0, ptr %1099, align 1
  %puts.i422 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i839)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca i32, align 4
  %28 = alloca i32, align 4
  %29 = alloca i32, align 4
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i32, align 4
  %34 = alloca i32, align 4
  %oldProtect.i332 = alloca i32, align 4
  %oldProtect.i328 = alloca i32, align 4
  %oldProtect.i287 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0224.sroa.0 = alloca i8, align 8
  %result.i283 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i283, align 8
  %35 = getelementptr inbounds i8, ptr %result.i283, i64 8
  store ptr @_parameterization_Ptri32, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i283, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %36, align 8
  %37 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i283) #39
  %result.i284 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i285 = call i32 @VirtualProtect(ptr nofree %result.i284, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i284, ptr noalias nofree noundef nonnull readnone @dwgqcbbuns, ptr noalias nofree noundef nonnull readnone @i32_hasher) #39
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i284) #40
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i284) #39
  %result.i286 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i287)
  %result.i288 = call i32 @VirtualProtect(ptr nofree %result.i286, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i287) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i287)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i286, ptr noalias nofree noundef nonnull readnone @cpgcncwmpd, ptr noalias nofree noundef nonnull readnone @i32_eq) #39
  %ret.i289 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i286) #40
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i286) #39
  %40 = getelementptr inbounds i8, ptr %result.i283, i64 48
  store ptr %ret.i, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %result.i283, i64 56
  store ptr %ret.i289, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i283, i64 40
  store i32 8, ptr %42, align 8
  %result.i.i524 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %43 = getelementptr inbounds i8, ptr %result.i283, i64 24
  store ptr %result.i.i524, ptr %43, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %44 = getelementptr inbounds i8, ptr %result.i283, i64 32
  store ptr %result.i9.i, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  %46 = sext i32 %0 to i64
  %47 = shl nsw i64 %46, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %47, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #35
  %result.i326 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i326, align 8
  %49 = getelementptr inbounds i8, ptr %result.i326, i64 8
  store ptr @_parameterization_Ptri1, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i326, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i326)
  %result.i327 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i328)
  %result.i329 = call i32 @VirtualProtect(ptr nofree %result.i327, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i328) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i328)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i327, ptr noalias nofree noundef nonnull readnone @cjkjdjoefc, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i330 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i327) #40
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i327)
  %result.i331 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i332)
  %result.i333 = call i32 @VirtualProtect(ptr nofree %result.i331, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i332) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i332)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i331, ptr noalias nofree noundef nonnull readnone @afcwmpmbdj, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i334 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i331) #40
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i331)
  %54 = getelementptr inbounds i8, ptr %result.i326, i64 48
  store ptr %ret.i330, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i326, i64 56
  store ptr %ret.i334, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %result.i326, i64 40
  store i32 8, ptr %56, align 8
  %result.i.i564 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %57 = getelementptr inbounds i8, ptr %result.i326, i64 24
  store ptr %result.i.i564, ptr %57, align 8
  %result.i9.i565 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %58 = getelementptr inbounds i8, ptr %result.i326, i64 32
  store ptr %result.i9.i565, ptr %58, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %60 = mul i32 %0, 10
  %61 = icmp sgt i32 %0, 0
  %62 = icmp sgt i32 %60, 0
  %spec.select512 = and i1 %61, %62
  br i1 %spec.select512, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %65 = getelementptr inbounds i8, ptr %result.i283, i64 44
  %66 = getelementptr inbounds i8, ptr %result.i326, i64 44
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  br label %68

68:                                               ; preds = %.lr.ph, %._crit_edge1
  %69 = phi i32 [ 456, %.lr.ph ], [ %72, %._crit_edge1 ]
  %.0264515 = phi i32 [ 0, %.lr.ph ], [ %2296, %._crit_edge1 ]
  %.0266514 = phi i32 [ 0, %.lr.ph ], [ %.2268, %._crit_edge1 ]
  %.0275513 = phi i64 [ 0, %.lr.ph ], [ %.2277, %._crit_edge1 ]
  %70 = mul i32 %69, 1103515245
  %71 = add i32 %70, 12345
  %72 = and i32 %71, 2147483647
  %.sroa.0252.0.insert.ext = zext nneg i32 %72 to i160
  %73 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0252.0.insert.ext, 1
  %74 = load ptr, ptr %54, align 8
  %75 = call i32 %74({ ptr, i160 } %73) #7
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %77 = load i32, ptr %56, align 8
  %78 = add i32 %77, -1
  %79 = and i32 %78, %75
  %80 = load ptr, ptr %57, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %81 = sext i32 %79 to i64
  %82 = shl nsw i64 %81, 5
  %83 = getelementptr i8, ptr %80, i64 %82
  %84 = load ptr, ptr %83, align 8
  %85 = icmp ne ptr %84, @nil_typ
  %86 = icmp ne ptr %84, null
  %.not44.i = and i1 %85, %86
  br i1 %.not44.i, label %87, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

87:                                               ; preds = %68
  %88 = getelementptr i8, ptr %83, i64 8
  %89 = load i64, ptr %88, align 4
  %.sroa_idx.i = getelementptr i8, ptr %83, i64 16
  %90 = load i64, ptr %.sroa_idx.i, align 4
  %91 = inttoptr i64 %89 to ptr
  %92 = inttoptr i64 %90 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %84, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %84, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %84, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !161
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !161
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !161
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !161
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %84, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %91, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %92, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %offset.i.i57.i, 3
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84) #35
  %99 = sext i32 %offset.i.i57.i to i64
  %100 = getelementptr ptr, ptr %84, i64 %99
  %101 = getelementptr i8, ptr %100, i64 64
  %102 = load ptr, ptr %101, align 8
  %result.i.i = call ptr %102({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #16
  %103 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %104 = icmp eq i32 %103, %75
  br i1 %104, label %._crit_edge.i976, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i976:                                 ; preds = %87
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84)
  %107 = getelementptr i8, ptr %100, i64 48
  %108 = load ptr, ptr %107, align 8
  %result.i59.i = call ptr %108({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #16
  %109 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %111 = load ptr, ptr %55, align 8
  %112 = call i1 %111({ ptr, i160 } %109, { ptr, i160 } %73) #7
  br i1 %112, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i976, %68, %87
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %121

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i976
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84)
  %115 = getelementptr i8, ptr %100, i64 56
  %116 = load ptr, ptr %115, align 8
  %result.i60.i = call ptr %116({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #16
  %117 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %117, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %119 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %120 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %119, %120
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %121

121:                                              ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %122 = add i32 %75, 2127912214
  %123 = shl i32 %75, 12
  %124 = add i32 %122, %123
  %125 = ashr i32 %124, 19
  %126 = xor i32 %124, %125
  %127 = xor i32 %126, -949894596
  %128 = add i32 %127, 374761393
  %129 = shl i32 %127, 5
  %130 = add i32 %128, %129
  %131 = add i32 %130, -744332180
  %132 = shl i32 %130, 9
  %133 = xor i32 %131, %132
  %134 = add i32 %133, -42973499
  %135 = shl i32 %133, 3
  %136 = add i32 %134, %135
  %137 = ashr i32 %136, 16
  %138 = xor i32 %136, %137
  %139 = xor i32 %138, -1252372727
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %141 = load i32, ptr %56, align 8
  %142 = add i32 %141, -1
  %143 = and i32 %142, %139
  %144 = load ptr, ptr %58, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %145 = sext i32 %143 to i64
  %146 = shl nsw i64 %145, 5
  %147 = getelementptr i8, ptr %144, i64 %146
  %148 = load ptr, ptr %147, align 8
  %149 = icmp ne ptr %148, @nil_typ
  %150 = icmp ne ptr %148, null
  %.not44.i1005 = and i1 %149, %150
  br i1 %.not44.i1005, label %151, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1029

151:                                              ; preds = %121
  %152 = getelementptr i8, ptr %147, i64 8
  %153 = load i64, ptr %152, align 4
  %.sroa_idx.i1009 = getelementptr i8, ptr %147, i64 16
  %154 = load i64, ptr %.sroa_idx.i1009, align 4
  %155 = inttoptr i64 %153 to ptr
  %156 = inttoptr i64 %154 to ptr
  %hash_coef_ptr.i.i46.i1010 = getelementptr i8, ptr %148, i64 8
  %tbl_size_ptr.i.i47.i1011 = getelementptr i8, ptr %148, i64 16
  %offset_tbl_ptr.i.i48.i1012 = getelementptr i8, ptr %148, i64 40
  %hash_coef.i.i49.i1013 = load i64, ptr %hash_coef_ptr.i.i46.i1010, align 4, !noalias !164
  %tbl_size.i.i50.i1014 = load i64, ptr %tbl_size_ptr.i.i47.i1011, align 4, !noalias !164
  %offset_tbl.i.i51.i1015 = load ptr, ptr %offset_tbl_ptr.i.i48.i1012, align 8, !noalias !164
  %product.i.i.i52.i1016 = mul i64 %hash_coef.i.i49.i1013, 4015701072841558310
  %shifted.i.i.i53.i1017 = lshr i64 %product.i.i.i52.i1016, 32
  %xored.i.i.i54.i1018 = xor i64 %shifted.i.i.i53.i1017, %product.i.i.i52.i1016
  %hash.i.i.i55.i1019 = and i64 %xored.i.i.i54.i1018, %tbl_size.i.i50.i1014
  %offset_ptr.i.i56.i1020 = getelementptr i32, ptr %offset_tbl.i.i51.i1015, i64 %hash.i.i.i55.i1019
  %offset.i.i57.i1021 = load i32, ptr %offset_ptr.i.i56.i1020, align 4, !noalias !164
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %148, 0
  %158 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %155, 1
  %159 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %156, 2
  %160 = insertvalue { ptr, ptr, ptr, i32 } %159, i32 %offset.i.i57.i1021, 3
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148) #35
  %163 = sext i32 %offset.i.i57.i1021 to i64
  %164 = getelementptr ptr, ptr %148, i64 %163
  %165 = getelementptr i8, ptr %164, i64 64
  %166 = load ptr, ptr %165, align 8
  %result.i.i1022 = call ptr %166({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #16
  %167 = call i32 %result.i.i1022({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %168 = icmp eq i32 %167, %75
  br i1 %168, label %._crit_edge.i1023, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1029

._crit_edge.i1023:                                ; preds = %151
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148)
  %171 = getelementptr i8, ptr %164, i64 48
  %172 = load ptr, ptr %171, align 8
  %result.i59.i1024 = call ptr %172({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #16
  %173 = call { ptr, i160 } %result.i59.i1024({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %175 = load ptr, ptr %55, align 8
  %176 = call i1 %175({ ptr, i160 } %173, { ptr, i160 } %73) #7
  br i1 %176, label %177, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1029

177:                                              ; preds = %._crit_edge.i1023
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148)
  %180 = getelementptr i8, ptr %164, i64 56
  %181 = load ptr, ptr %180, align 8
  %result.i60.i1026 = call ptr %181({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #16
  %182 = call { ptr, i160 } %result.i60.i1026({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1027 = extractvalue { ptr, i160 } %182, 0
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1029

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1029: ; preds = %121, %151, %._crit_edge.i1023, %177
  %183 = phi ptr [ %.fca.0.extract21.i1027, %177 ], [ @nil_typ, %._crit_edge.i1023 ], [ @nil_typ, %121 ], [ @nil_typ, %151 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %184 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %185 = icmp ne ptr %183, @nil_typ
  %186 = icmp ne ptr %183, null
  %.not65.not.not.i = and i1 %185, %186
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %183, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1029
  %187 = phi ptr [ %.fca.0.extract21.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1029 ]
  %188 = icmp eq ptr %187, @nil_typ
  %189 = icmp eq ptr %187, null
  %190 = or i1 %188, %189
  br i1 %190, label %191, label %._crit_edge1

191:                                              ; preds = %CuckooMap_get_keyK.exit
  %192 = add nuw i32 %72, 1
  %.sroa.0234.0.insert.ext = zext i32 %192 to i160
  %193 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0234.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %194 = load ptr, ptr %40, align 8
  %195 = call i32 %194({ ptr, i160 } %73) #7
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %197 = load i32, ptr %42, align 8
  %198 = add i32 %197, -1
  %199 = and i32 %198, %195
  %200 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %201 = sext i32 %199 to i64
  %202 = shl nsw i64 %201, 5
  %203 = getelementptr i8, ptr %200, i64 %202
  %204 = load ptr, ptr %203, align 8
  %205 = getelementptr i8, ptr %203, i64 8
  %206 = icmp ne ptr %204, @nil_typ
  %207 = icmp ne ptr %204, null
  %.not64.i = and i1 %206, %207
  br i1 %.not64.i, label %208, label %306

208:                                              ; preds = %191
  %209 = load i64, ptr %205, align 4
  %.sroa_idx.i1070 = getelementptr i8, ptr %203, i64 16
  %210 = load i64, ptr %.sroa_idx.i1070, align 4
  %211 = inttoptr i64 %209 to ptr
  %212 = inttoptr i64 %210 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %204, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %204, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %204, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !167
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !167
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !167
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !167
  %213 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %204, 0
  %214 = insertvalue { ptr, ptr, ptr, i32 } %213, ptr %211, 1
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %212, 2
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, i32 %offset.i.i77.i, 3
  %217 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %218 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %204) #35
  %219 = sext i32 %offset.i.i77.i to i64
  %220 = getelementptr ptr, ptr %204, i64 %219
  %221 = getelementptr i8, ptr %220, i64 64
  %222 = load ptr, ptr %221, align 8
  %result.i.i1071 = call ptr %222({ ptr, ptr, ptr, i32 } %216, ptr nocapture nofree noundef nonnull readonly %2) #16
  %223 = call i32 %result.i.i1071({ ptr, ptr, ptr, i32 } %216, { ptr, ptr, ptr, i32 } %216, ptr nonnull align 8 %2) #7
  %224 = icmp eq i32 %223, %195
  br i1 %224, label %._crit_edge.i1072, label %306

._crit_edge.i1072:                                ; preds = %208
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %226 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %204)
  %227 = getelementptr i8, ptr %220, i64 48
  %228 = load ptr, ptr %227, align 8
  %result.i79.i1073 = call ptr %228({ ptr, ptr, ptr, i32 } %216, ptr nocapture nofree noundef nonnull readonly %2) #16
  %229 = call { ptr, i160 } %result.i79.i1073({ ptr, ptr, ptr, i32 } %216, { ptr, ptr, ptr, i32 } %216, ptr nonnull align 8 %2) #7
  %230 = load ptr, ptr %41, align 8
  %231 = call i1 %230({ ptr, i160 } %229, { ptr, i160 } %73) #7
  br i1 %231, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %306

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1072
  %232 = load ptr, ptr %result.i283, align 8
  %233 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %234 = load ptr, ptr %35, align 8
  %235 = load ptr, ptr %232, align 8, !alias.scope !170
  %236 = getelementptr i8, ptr %235, i64 72
  %237 = load ptr, ptr %236, align 8, !alias.scope !170
  %result.i.i.i1074 = call { i64, i64 } %237(ptr nocapture nofree nonnull readonly %232) #5, !alias.scope !170
  %238 = extractvalue { i64, i64 } %result.i.i.i1074, 0
  %239 = extractvalue { i64, i64 } %result.i.i.i1074, 1
  %240 = urem i64 20, %239
  %241 = icmp eq i64 %240, 0
  %242 = sub i64 %239, %240
  %243 = select i1 %241, i64 0, i64 %242
  %244 = add i64 %238, 20
  %245 = add i64 %244, %243
  %246 = load ptr, ptr %234, align 8, !alias.scope !170
  %247 = getelementptr i8, ptr %246, i64 72
  %248 = load ptr, ptr %247, align 8, !alias.scope !170
  %result.i1.i.i1075 = call { i64, i64 } %248(ptr nocapture nofree nonnull readonly %234) #5, !alias.scope !170
  %249 = extractvalue { i64, i64 } %result.i1.i.i1075, 0
  %250 = extractvalue { i64, i64 } %result.i1.i.i1075, 1
  %251 = call i64 @llvm.umax.i64(i64 %239, i64 %250)
  %252 = call i64 @llvm.umax.i64(i64 %251, i64 8)
  %253 = urem i64 %245, %250
  %254 = icmp eq i64 %253, 0
  %255 = sub i64 %250, %253
  %256 = select i1 %254, i64 0, i64 %255
  %257 = add i64 %249, %245
  %258 = add i64 %257, %256
  %259 = urem i64 %258, %252
  %260 = icmp eq i64 %259, 0
  %261 = sub i64 %252, %259
  %262 = select i1 %260, i64 0, i64 %261
  %263 = add i64 %262, %258
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %263, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %232, ptr %result.i83.i, align 8
  %264 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %234, ptr %264, align 8
  %265 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %267 = load ptr, ptr %232, align 8
  %268 = getelementptr i8, ptr %267, i64 72
  %269 = load ptr, ptr %268, align 8
  %result.i.i118.i = call { i64, i64 } %269(ptr nocapture nofree nonnull readonly %232) #5
  %270 = extractvalue { i64, i64 } %result.i.i118.i, 1
  %271 = urem i64 20, %270
  %272 = icmp eq i64 %271, 0
  %reass.sub3813 = sub i64 %270, %271
  %273 = add i64 %reass.sub3813, 20
  %274 = select i1 %272, i64 20, i64 %273
  %275 = getelementptr i8, ptr %result.i83.i, i64 %274
  %276 = getelementptr i8, ptr %267, i64 64
  %277 = load ptr, ptr %276, align 8
  call void %277({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %232, ptr nocapture nofree writeonly %275) #1
  %278 = load ptr, ptr %result.i83.i, align 8
  %279 = load ptr, ptr %278, align 8
  %280 = getelementptr i8, ptr %279, i64 72
  %281 = load ptr, ptr %280, align 8
  %result.i.i119.i = call { i64, i64 } %281(ptr nocapture nofree nonnull readonly %278) #5
  %282 = extractvalue { i64, i64 } %result.i.i119.i, 0
  %283 = extractvalue { i64, i64 } %result.i.i119.i, 1
  %284 = urem i64 20, %283
  %285 = icmp eq i64 %284, 0
  %286 = sub i64 %283, %284
  %287 = select i1 %285, i64 0, i64 %286
  %288 = add i64 %282, 20
  %289 = add i64 %288, %287
  %290 = load ptr, ptr %264, align 8
  %291 = load ptr, ptr %290, align 8
  %292 = getelementptr i8, ptr %291, i64 72
  %293 = load ptr, ptr %292, align 8
  %result.i1.i120.i = call { i64, i64 } %293(ptr nocapture nofree nonnull readonly %290) #5
  %294 = extractvalue { i64, i64 } %result.i1.i120.i, 1
  %295 = urem i64 %289, %294
  %296 = icmp eq i64 %295, 0
  %297 = sub i64 %294, %295
  %298 = select i1 %296, i64 0, i64 %297
  %299 = getelementptr i8, ptr %result.i83.i, i64 %289
  %300 = getelementptr i8, ptr %299, i64 %298
  %301 = getelementptr i8, ptr %291, i64 64
  %302 = load ptr, ptr %301, align 8
  call void %302({ ptr, i160 } %193, ptr nocapture nofree nonnull readonly %290, ptr nocapture nofree writeonly %300) #1
  %303 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %304 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %195, ptr %304, align 8
  store ptr @Entry, ptr %203, align 8
  %305 = ptrtoint ptr %result.i83.i to i64
  store i64 %305, ptr %205, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %203, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

306:                                              ; preds = %._crit_edge.i1072, %191, %208
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %307 = add i32 %195, 2127912214
  %308 = shl i32 %195, 12
  %309 = add i32 %307, %308
  %310 = ashr i32 %309, 19
  %311 = xor i32 %309, %310
  %312 = xor i32 %311, -949894596
  %313 = add i32 %312, 374761393
  %314 = shl i32 %312, 5
  %315 = add i32 %313, %314
  %316 = add i32 %315, -744332180
  %317 = shl i32 %315, 9
  %318 = xor i32 %316, %317
  %319 = add i32 %318, -42973499
  %320 = shl i32 %318, 3
  %321 = add i32 %319, %320
  %322 = ashr i32 %321, 16
  %323 = xor i32 %321, %322
  %324 = xor i32 %323, -1252372727
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %326 = load i32, ptr %42, align 8
  %327 = add i32 %326, -1
  %328 = and i32 %327, %324
  %329 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %330 = sext i32 %328 to i64
  %331 = shl nsw i64 %330, 5
  %332 = getelementptr i8, ptr %329, i64 %331
  %333 = load ptr, ptr %332, align 8
  %334 = getelementptr i8, ptr %332, i64 8
  %335 = icmp ne ptr %333, @nil_typ
  %336 = icmp ne ptr %333, null
  %.not64.i1105 = and i1 %335, %336
  br i1 %.not64.i1105, label %337, label %436

337:                                              ; preds = %306
  %338 = load i64, ptr %334, align 4
  %.sroa_idx.i1107 = getelementptr i8, ptr %332, i64 16
  %339 = load i64, ptr %.sroa_idx.i1107, align 4
  %340 = inttoptr i64 %338 to ptr
  %341 = inttoptr i64 %339 to ptr
  %hash_coef_ptr.i.i66.i1108 = getelementptr i8, ptr %333, i64 8
  %tbl_size_ptr.i.i67.i1109 = getelementptr i8, ptr %333, i64 16
  %offset_tbl_ptr.i.i68.i1110 = getelementptr i8, ptr %333, i64 40
  %hash_coef.i.i69.i1111 = load i64, ptr %hash_coef_ptr.i.i66.i1108, align 4, !noalias !173
  %tbl_size.i.i70.i1112 = load i64, ptr %tbl_size_ptr.i.i67.i1109, align 4, !noalias !173
  %offset_tbl.i.i71.i1113 = load ptr, ptr %offset_tbl_ptr.i.i68.i1110, align 8, !noalias !173
  %product.i.i.i72.i1114 = mul i64 %hash_coef.i.i69.i1111, 4015701072841558310
  %shifted.i.i.i73.i1115 = lshr i64 %product.i.i.i72.i1114, 32
  %xored.i.i.i74.i1116 = xor i64 %shifted.i.i.i73.i1115, %product.i.i.i72.i1114
  %hash.i.i.i75.i1117 = and i64 %xored.i.i.i74.i1116, %tbl_size.i.i70.i1112
  %offset_ptr.i.i76.i1118 = getelementptr i32, ptr %offset_tbl.i.i71.i1113, i64 %hash.i.i.i75.i1117
  %offset.i.i77.i1119 = load i32, ptr %offset_ptr.i.i76.i1118, align 4, !noalias !173
  %342 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %333, 0
  %343 = insertvalue { ptr, ptr, ptr, i32 } %342, ptr %340, 1
  %344 = insertvalue { ptr, ptr, ptr, i32 } %343, ptr %341, 2
  %345 = insertvalue { ptr, ptr, ptr, i32 } %344, i32 %offset.i.i77.i1119, 3
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %333) #35
  %348 = sext i32 %offset.i.i77.i1119 to i64
  %349 = getelementptr ptr, ptr %333, i64 %348
  %350 = getelementptr i8, ptr %349, i64 64
  %351 = load ptr, ptr %350, align 8
  %result.i.i1120 = call ptr %351({ ptr, ptr, ptr, i32 } %345, ptr nocapture nofree noundef nonnull readonly %2) #16
  %352 = call i32 %result.i.i1120({ ptr, ptr, ptr, i32 } %345, { ptr, ptr, ptr, i32 } %345, ptr nonnull align 8 %2) #7
  %353 = icmp eq i32 %352, %195
  br i1 %353, label %._crit_edge.i1121, label %436

._crit_edge.i1121:                                ; preds = %337
  %354 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %355 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %333)
  %356 = getelementptr i8, ptr %349, i64 48
  %357 = load ptr, ptr %356, align 8
  %result.i79.i1122 = call ptr %357({ ptr, ptr, ptr, i32 } %345, ptr nocapture nofree noundef nonnull readonly %2) #16
  %358 = call { ptr, i160 } %result.i79.i1122({ ptr, ptr, ptr, i32 } %345, { ptr, ptr, ptr, i32 } %345, ptr nonnull align 8 %2) #7
  %359 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %360 = load ptr, ptr %41, align 8
  %361 = call i1 %360({ ptr, i160 } %358, { ptr, i160 } %73) #7
  br i1 %361, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1134, label %436

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1134: ; preds = %._crit_edge.i1121
  %362 = load ptr, ptr %result.i283, align 8
  %363 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %364 = load ptr, ptr %35, align 8
  %365 = load ptr, ptr %362, align 8, !alias.scope !176
  %366 = getelementptr i8, ptr %365, i64 72
  %367 = load ptr, ptr %366, align 8, !alias.scope !176
  %result.i.i.i1126 = call { i64, i64 } %367(ptr nocapture nofree nonnull readonly %362) #5, !alias.scope !176
  %368 = extractvalue { i64, i64 } %result.i.i.i1126, 0
  %369 = extractvalue { i64, i64 } %result.i.i.i1126, 1
  %370 = urem i64 20, %369
  %371 = icmp eq i64 %370, 0
  %372 = sub i64 %369, %370
  %373 = select i1 %371, i64 0, i64 %372
  %374 = add i64 %368, 20
  %375 = add i64 %374, %373
  %376 = load ptr, ptr %364, align 8, !alias.scope !176
  %377 = getelementptr i8, ptr %376, i64 72
  %378 = load ptr, ptr %377, align 8, !alias.scope !176
  %result.i1.i.i1127 = call { i64, i64 } %378(ptr nocapture nofree nonnull readonly %364) #5, !alias.scope !176
  %379 = extractvalue { i64, i64 } %result.i1.i.i1127, 0
  %380 = extractvalue { i64, i64 } %result.i1.i.i1127, 1
  %381 = call i64 @llvm.umax.i64(i64 %369, i64 %380)
  %382 = call i64 @llvm.umax.i64(i64 %381, i64 8)
  %383 = urem i64 %375, %380
  %384 = icmp eq i64 %383, 0
  %385 = sub i64 %380, %383
  %386 = select i1 %384, i64 0, i64 %385
  %387 = add i64 %379, %375
  %388 = add i64 %387, %386
  %389 = urem i64 %388, %382
  %390 = icmp eq i64 %389, 0
  %391 = sub i64 %382, %389
  %392 = select i1 %390, i64 0, i64 %391
  %393 = add i64 %392, %388
  %result.i83.i1128 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %393, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %362, ptr %result.i83.i1128, align 8
  %394 = getelementptr inbounds i8, ptr %result.i83.i1128, i64 8
  store ptr %364, ptr %394, align 8
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1128)
  %396 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %397 = load ptr, ptr %362, align 8
  %398 = getelementptr i8, ptr %397, i64 72
  %399 = load ptr, ptr %398, align 8
  %result.i.i118.i1129 = call { i64, i64 } %399(ptr nocapture nofree nonnull readonly %362) #5
  %400 = extractvalue { i64, i64 } %result.i.i118.i1129, 1
  %401 = urem i64 20, %400
  %402 = icmp eq i64 %401, 0
  %reass.sub3812 = sub i64 %400, %401
  %403 = add i64 %reass.sub3812, 20
  %404 = select i1 %402, i64 20, i64 %403
  %405 = getelementptr i8, ptr %result.i83.i1128, i64 %404
  %406 = getelementptr i8, ptr %397, i64 64
  %407 = load ptr, ptr %406, align 8
  call void %407({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %362, ptr nocapture nofree writeonly %405) #1
  %408 = load ptr, ptr %result.i83.i1128, align 8
  %409 = load ptr, ptr %408, align 8
  %410 = getelementptr i8, ptr %409, i64 72
  %411 = load ptr, ptr %410, align 8
  %result.i.i119.i1131 = call { i64, i64 } %411(ptr nocapture nofree nonnull readonly %408) #5
  %412 = extractvalue { i64, i64 } %result.i.i119.i1131, 0
  %413 = extractvalue { i64, i64 } %result.i.i119.i1131, 1
  %414 = urem i64 20, %413
  %415 = icmp eq i64 %414, 0
  %416 = sub i64 %413, %414
  %417 = select i1 %415, i64 0, i64 %416
  %418 = add i64 %412, 20
  %419 = add i64 %418, %417
  %420 = load ptr, ptr %394, align 8
  %421 = load ptr, ptr %420, align 8
  %422 = getelementptr i8, ptr %421, i64 72
  %423 = load ptr, ptr %422, align 8
  %result.i1.i120.i1132 = call { i64, i64 } %423(ptr nocapture nofree nonnull readonly %420) #5
  %424 = extractvalue { i64, i64 } %result.i1.i120.i1132, 1
  %425 = urem i64 %419, %424
  %426 = icmp eq i64 %425, 0
  %427 = sub i64 %424, %425
  %428 = select i1 %426, i64 0, i64 %427
  %429 = getelementptr i8, ptr %result.i83.i1128, i64 %419
  %430 = getelementptr i8, ptr %429, i64 %428
  %431 = getelementptr i8, ptr %421, i64 64
  %432 = load ptr, ptr %431, align 8
  call void %432({ ptr, i160 } %193, ptr nocapture nofree nonnull readonly %420, ptr nocapture nofree writeonly %430) #1
  %433 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %434 = getelementptr inbounds i8, ptr %result.i83.i1128, i64 16
  store i32 %195, ptr %434, align 8
  store ptr @Entry, ptr %332, align 8
  %435 = ptrtoint ptr %result.i83.i1128 to i64
  store i64 %435, ptr %334, align 4
  %.sroa_idx28.i1133 = getelementptr i8, ptr %332, i64 24
  store i32 10, ptr %.sroa_idx28.i1133, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

436:                                              ; preds = %._crit_edge.i1121, %306, %337
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %437 = load i32, ptr %65, align 4
  %438 = load i32, ptr %42, align 8
  %.not.i = icmp slt i32 %437, %438
  br i1 %.not.i, label %._crit_edge.i, label %439

439:                                              ; preds = %436
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %441 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %442 = load ptr, ptr %43, align 8
  %443 = load ptr, ptr %44, align 8
  %444 = shl i32 %438, 1
  %spec.select.i1149 = call i32 @llvm.smax.i32(i32 %444, i32 16)
  store i32 %spec.select.i1149, ptr %42, align 8
  %445 = zext nneg i32 %spec.select.i1149 to i64
  %446 = shl nuw nsw i64 %445, 5
  %result.i.i1150 = call noalias ptr @bump_malloc_inner(i64 noundef %446, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1150, ptr %43, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %446, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %447 = icmp sgt i32 %438, 0
  br i1 %447, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %439, %._crit_edge.i1960
  %.060.i = phi i32 [ %536, %._crit_edge.i1960 ], [ 0, %439 ]
  %448 = zext nneg i32 %.060.i to i64
  %449 = shl nuw nsw i64 %448, 5
  %450 = getelementptr i8, ptr %442, i64 %449
  %451 = load ptr, ptr %450, align 8
  %452 = icmp ne ptr %451, @nil_typ
  %453 = icmp ne ptr %451, null
  %.not16.i = and i1 %452, %453
  br i1 %.not16.i, label %454, label %._crit_edge.i1960

454:                                              ; preds = %.lr.ph.i
  %455 = getelementptr i8, ptr %450, i64 8
  %456 = load <2 x i64>, ptr %455, align 4
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %451, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %451, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %451, i64 40
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %26)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !179
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %459 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %461

461:                                              ; preds = %.cont.cont.i2502, %454
  %.0566.i2490 = phi i32 [ 0, %454 ], [ %465, %.cont.cont.i2502 ]
  %.070565.i2491 = phi i1 [ true, %454 ], [ %527, %.cont.cont.i2502 ]
  %.sroa.0.0564.i2492 = phi ptr [ %451, %454 ], [ %vptr.i142.sroa.speculated.i2505, %.cont.cont.i2502 ]
  %.sroa.17.0561.i2495 = phi i32 [ %offset.i.i121.i, %454 ], [ %offset.i.i154.i2519, %.cont.cont.i2502 ]
  %462 = phi <2 x i64> [ %456, %454 ], [ %526, %.cont.cont.i2502 ]
  %463 = extractelement <2 x i64> %462, i64 1
  %.sroa.12.0562.i2494 = inttoptr i64 %463 to ptr
  %464 = extractelement <2 x i64> %462, i64 0
  %.sroa.6.0563.i2493 = inttoptr i64 %464 to ptr
  %465 = add nuw nsw i32 %.0566.i2490, 1
  %466 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2492, 0
  %467 = insertvalue { ptr, ptr, ptr, i32 } %466, ptr %.sroa.6.0563.i2493, 1
  %468 = insertvalue { ptr, ptr, ptr, i32 } %467, ptr %.sroa.12.0562.i2494, 2
  %469 = insertvalue { ptr, ptr, ptr, i32 } %468, i32 %.sroa.17.0561.i2495, 3
  %470 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2492)
  %471 = sext i32 %.sroa.17.0561.i2495 to i64
  %472 = getelementptr ptr, ptr %.sroa.0.0564.i2492, i64 %471
  %473 = getelementptr i8, ptr %472, i64 64
  %474 = load ptr, ptr %473, align 8
  %result.i125.i = call ptr %474({ ptr, ptr, ptr, i32 } %469, ptr nocapture nofree noundef nonnull readonly %2) #16
  %475 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %469, { ptr, ptr, ptr, i32 } %469, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2491, label %476, label %492

476:                                              ; preds = %461
  %477 = load i32, ptr %42, align 8
  %478 = add i32 %477, -1
  %479 = and i32 %478, %475
  %480 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %481 = load ptr, ptr %43, align 8
  %482 = sext i32 %479 to i64
  %483 = shl nsw i64 %482, 5
  %484 = getelementptr i8, ptr %481, i64 %483
  %485 = load ptr, ptr %484, align 8
  %486 = getelementptr i8, ptr %484, i64 8
  %487 = load i160, ptr %486, align 4
  store ptr %.sroa.0.0564.i2492, ptr %484, align 8
  store i64 %464, ptr %486, align 4
  %.sroa_idx157.i2521 = getelementptr i8, ptr %484, i64 16
  store i64 %463, ptr %.sroa_idx157.i2521, align 4
  %.sroa_idx158.i2522 = getelementptr i8, ptr %484, i64 24
  store i32 %.sroa.17.0561.i2495, ptr %.sroa_idx158.i2522, align 4
  %488 = icmp ne ptr %485, @nil_typ
  %489 = icmp ne ptr %485, null
  %.not92.i2523 = and i1 %488, %489
  %extract.i2525 = lshr i160 %487, 64
  %490 = insertelement <2 x i160> poison, i160 %487, i64 0
  %491 = insertelement <2 x i160> %490, i160 %extract.i2525, i64 1
  br i1 %.not92.i2523, label %.cont.cont.i2502, label %531

492:                                              ; preds = %461
  %493 = add i32 %475, 2127912214
  %494 = shl i32 %475, 12
  %495 = add i32 %493, %494
  %496 = ashr i32 %495, 19
  %497 = xor i32 %495, %496
  %498 = xor i32 %497, -949894596
  %499 = add i32 %498, 374761393
  %500 = shl i32 %498, 5
  %501 = add i32 %499, %500
  %502 = add i32 %501, -744332180
  %503 = shl i32 %501, 9
  %504 = xor i32 %502, %503
  %505 = add i32 %504, -42973499
  %506 = shl i32 %504, 3
  %507 = add i32 %505, %506
  %508 = ashr i32 %507, 16
  %509 = xor i32 %507, %508
  %510 = xor i32 %509, -1252372727
  %511 = load i32, ptr %42, align 8
  %512 = add i32 %511, -1
  %513 = and i32 %512, %510
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %515 = load ptr, ptr %44, align 8
  %516 = sext i32 %513 to i64
  %517 = shl nsw i64 %516, 5
  %518 = getelementptr i8, ptr %515, i64 %517
  %519 = load ptr, ptr %518, align 8
  %520 = getelementptr i8, ptr %518, i64 8
  %521 = load i160, ptr %520, align 4
  store ptr %.sroa.0.0564.i2492, ptr %518, align 8
  store i64 %464, ptr %520, align 4
  %.sroa_idx161.i2496 = getelementptr i8, ptr %518, i64 16
  store i64 %463, ptr %.sroa_idx161.i2496, align 4
  %.sroa_idx162.i2497 = getelementptr i8, ptr %518, i64 24
  store i32 %.sroa.17.0561.i2495, ptr %.sroa_idx162.i2497, align 4
  %522 = icmp ne ptr %519, @nil_typ
  %523 = icmp ne ptr %519, null
  %.not90.i2498 = and i1 %522, %523
  %extract607.i2500 = lshr i160 %521, 64
  %524 = insertelement <2 x i160> poison, i160 %521, i64 0
  %525 = insertelement <2 x i160> %524, i160 %extract607.i2500, i64 1
  br i1 %.not90.i2498, label %.cont.cont.i2502, label %531

.cont.cont.i2502:                                 ; preds = %492, %476
  %vptr.i142.sroa.speculated.i2505 = phi ptr [ %485, %476 ], [ %519, %492 ]
  %.in = phi <2 x i160> [ %491, %476 ], [ %525, %492 ]
  %526 = trunc <2 x i160> %.in to <2 x i64>
  %527 = xor i1 %.070565.i2491, true
  %hash_coef_ptr.i.i143.i2508 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2505, i64 8
  %tbl_size_ptr.i.i144.i2509 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2505, i64 16
  %offset_tbl_ptr.i.i145.i2510 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2505, i64 40
  %hash_coef.i.i146.i2511 = load i64, ptr %hash_coef_ptr.i.i143.i2508, align 4
  %tbl_size.i.i147.i2512 = load i64, ptr %tbl_size_ptr.i.i144.i2509, align 4
  %offset_tbl.i.i148.i2513 = load ptr, ptr %offset_tbl_ptr.i.i145.i2510, align 8
  %product.i.i.i149.i2514 = mul i64 %hash_coef.i.i146.i2511, 4015701072841558310
  %shifted.i.i.i150.i2515 = lshr i64 %product.i.i.i149.i2514, 32
  %xored.i.i.i151.i2516 = xor i64 %shifted.i.i.i150.i2515, %product.i.i.i149.i2514
  %hash.i.i.i152.i2517 = and i64 %xored.i.i.i151.i2516, %tbl_size.i.i147.i2512
  %offset_ptr.i.i153.i2518 = getelementptr i32, ptr %offset_tbl.i.i148.i2513, i64 %hash.i.i.i152.i2517
  %offset.i.i154.i2519 = load i32, ptr %offset_ptr.i.i153.i2518, align 4
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %529 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %530 = icmp ult i32 %.0566.i2490, 99
  br i1 %530, label %461, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2527

531:                                              ; preds = %492, %476
  %532 = phi ptr [ %26, %492 ], [ %25, %476 ]
  %533 = load i32, ptr %65, align 4
  store i32 %533, ptr %532, align 4
  %534 = add i32 %533, 1
  %535 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %534, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2527

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2527: ; preds = %.cont.cont.i2502, %531
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  br label %._crit_edge.i1960

._crit_edge.i1960:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2527, %.lr.ph.i
  %536 = add nuw nsw i32 %.060.i, 1
  %537 = icmp slt i32 %536, %438
  br i1 %537, label %.lr.ph.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i1960, %._crit_edge.i1979
  %.060.i1977 = phi i32 [ %626, %._crit_edge.i1979 ], [ 0, %._crit_edge.i1960 ]
  %538 = zext nneg i32 %.060.i1977 to i64
  %539 = shl nuw nsw i64 %538, 5
  %540 = getelementptr i8, ptr %443, i64 %539
  %541 = load ptr, ptr %540, align 8
  %542 = icmp ne ptr %541, @nil_typ
  %543 = icmp ne ptr %541, null
  %.not16.i1978 = and i1 %542, %543
  br i1 %.not16.i1978, label %544, label %._crit_edge.i1979

544:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %545 = getelementptr i8, ptr %540, i64 8
  %546 = load <2 x i64>, ptr %545, align 4
  %hash_coef_ptr.i.i18.i1981 = getelementptr i8, ptr %541, i64 8
  %tbl_size_ptr.i.i19.i1982 = getelementptr i8, ptr %541, i64 16
  %offset_tbl_ptr.i.i20.i1983 = getelementptr i8, ptr %541, i64 40
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %hash_coef.i.i99.i2545 = load i64, ptr %hash_coef_ptr.i.i18.i1981, align 4, !noalias !22
  %tbl_size.i.i100.i2546 = load i64, ptr %tbl_size_ptr.i.i19.i1982, align 4, !noalias !22
  %offset_tbl.i.i101.i2547 = load ptr, ptr %offset_tbl_ptr.i.i20.i1983, align 8, !noalias !22
  %product.i.i.i102.i2548 = mul i64 %hash_coef.i.i99.i2545, 4015701072841558310
  %shifted.i.i.i103.i2549 = lshr i64 %product.i.i.i102.i2548, 32
  %xored.i.i.i104.i2550 = xor i64 %shifted.i.i.i103.i2549, %product.i.i.i102.i2548
  %hash.i.i.i105.i2551 = and i64 %xored.i.i.i104.i2550, %tbl_size.i.i100.i2546
  %offset_ptr.i.i106.i2552 = getelementptr i32, ptr %offset_tbl.i.i101.i2547, i64 %hash.i.i.i105.i2551
  %offset.i.i121.i2553 = load i32, ptr %offset_ptr.i.i106.i2552, align 4, !noalias !182
  %548 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %550 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %551

551:                                              ; preds = %.cont.cont.i2574, %544
  %.0566.i2554 = phi i32 [ 0, %544 ], [ %555, %.cont.cont.i2574 ]
  %.070565.i2555 = phi i1 [ true, %544 ], [ %617, %.cont.cont.i2574 ]
  %.sroa.0.0564.i2556 = phi ptr [ %541, %544 ], [ %vptr.i142.sroa.speculated.i2577, %.cont.cont.i2574 ]
  %.sroa.17.0561.i2559 = phi i32 [ %offset.i.i121.i2553, %544 ], [ %offset.i.i154.i2591, %.cont.cont.i2574 ]
  %552 = phi <2 x i64> [ %546, %544 ], [ %616, %.cont.cont.i2574 ]
  %553 = extractelement <2 x i64> %552, i64 1
  %.sroa.12.0562.i2558 = inttoptr i64 %553 to ptr
  %554 = extractelement <2 x i64> %552, i64 0
  %.sroa.6.0563.i2557 = inttoptr i64 %554 to ptr
  %555 = add nuw nsw i32 %.0566.i2554, 1
  %556 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2556, 0
  %557 = insertvalue { ptr, ptr, ptr, i32 } %556, ptr %.sroa.6.0563.i2557, 1
  %558 = insertvalue { ptr, ptr, ptr, i32 } %557, ptr %.sroa.12.0562.i2558, 2
  %559 = insertvalue { ptr, ptr, ptr, i32 } %558, i32 %.sroa.17.0561.i2559, 3
  %560 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2556)
  %561 = sext i32 %.sroa.17.0561.i2559 to i64
  %562 = getelementptr ptr, ptr %.sroa.0.0564.i2556, i64 %561
  %563 = getelementptr i8, ptr %562, i64 64
  %564 = load ptr, ptr %563, align 8
  %result.i125.i2560 = call ptr %564({ ptr, ptr, ptr, i32 } %559, ptr nocapture nofree noundef nonnull readonly %2) #16
  %565 = call i32 %result.i125.i2560({ ptr, ptr, ptr, i32 } %559, { ptr, ptr, ptr, i32 } %559, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2555, label %566, label %582

566:                                              ; preds = %551
  %567 = load i32, ptr %42, align 8
  %568 = add i32 %567, -1
  %569 = and i32 %568, %565
  %570 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %571 = load ptr, ptr %43, align 8
  %572 = sext i32 %569 to i64
  %573 = shl nsw i64 %572, 5
  %574 = getelementptr i8, ptr %571, i64 %573
  %575 = load ptr, ptr %574, align 8
  %576 = getelementptr i8, ptr %574, i64 8
  %577 = load i160, ptr %576, align 4
  store ptr %.sroa.0.0564.i2556, ptr %574, align 8
  store i64 %554, ptr %576, align 4
  %.sroa_idx157.i2603 = getelementptr i8, ptr %574, i64 16
  store i64 %553, ptr %.sroa_idx157.i2603, align 4
  %.sroa_idx158.i2604 = getelementptr i8, ptr %574, i64 24
  store i32 %.sroa.17.0561.i2559, ptr %.sroa_idx158.i2604, align 4
  %578 = icmp ne ptr %575, @nil_typ
  %579 = icmp ne ptr %575, null
  %.not92.i2605 = and i1 %578, %579
  %extract.i2607 = lshr i160 %577, 64
  %580 = insertelement <2 x i160> poison, i160 %577, i64 0
  %581 = insertelement <2 x i160> %580, i160 %extract.i2607, i64 1
  br i1 %.not92.i2605, label %.cont.cont.i2574, label %621

582:                                              ; preds = %551
  %583 = add i32 %565, 2127912214
  %584 = shl i32 %565, 12
  %585 = add i32 %583, %584
  %586 = ashr i32 %585, 19
  %587 = xor i32 %585, %586
  %588 = xor i32 %587, -949894596
  %589 = add i32 %588, 374761393
  %590 = shl i32 %588, 5
  %591 = add i32 %589, %590
  %592 = add i32 %591, -744332180
  %593 = shl i32 %591, 9
  %594 = xor i32 %592, %593
  %595 = add i32 %594, -42973499
  %596 = shl i32 %594, 3
  %597 = add i32 %595, %596
  %598 = ashr i32 %597, 16
  %599 = xor i32 %597, %598
  %600 = xor i32 %599, -1252372727
  %601 = load i32, ptr %42, align 8
  %602 = add i32 %601, -1
  %603 = and i32 %602, %600
  %604 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %605 = load ptr, ptr %44, align 8
  %606 = sext i32 %603 to i64
  %607 = shl nsw i64 %606, 5
  %608 = getelementptr i8, ptr %605, i64 %607
  %609 = load ptr, ptr %608, align 8
  %610 = getelementptr i8, ptr %608, i64 8
  %611 = load i160, ptr %610, align 4
  store ptr %.sroa.0.0564.i2556, ptr %608, align 8
  store i64 %554, ptr %610, align 4
  %.sroa_idx161.i2564 = getelementptr i8, ptr %608, i64 16
  store i64 %553, ptr %.sroa_idx161.i2564, align 4
  %.sroa_idx162.i2565 = getelementptr i8, ptr %608, i64 24
  store i32 %.sroa.17.0561.i2559, ptr %.sroa_idx162.i2565, align 4
  %612 = icmp ne ptr %609, @nil_typ
  %613 = icmp ne ptr %609, null
  %.not90.i2566 = and i1 %612, %613
  %extract607.i2568 = lshr i160 %611, 64
  %614 = insertelement <2 x i160> poison, i160 %611, i64 0
  %615 = insertelement <2 x i160> %614, i160 %extract607.i2568, i64 1
  br i1 %.not90.i2566, label %.cont.cont.i2574, label %621

.cont.cont.i2574:                                 ; preds = %582, %566
  %vptr.i142.sroa.speculated.i2577 = phi ptr [ %575, %566 ], [ %609, %582 ]
  %.in3816 = phi <2 x i160> [ %581, %566 ], [ %615, %582 ]
  %616 = trunc <2 x i160> %.in3816 to <2 x i64>
  %617 = xor i1 %.070565.i2555, true
  %hash_coef_ptr.i.i143.i2580 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2577, i64 8
  %tbl_size_ptr.i.i144.i2581 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2577, i64 16
  %offset_tbl_ptr.i.i145.i2582 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2577, i64 40
  %hash_coef.i.i146.i2583 = load i64, ptr %hash_coef_ptr.i.i143.i2580, align 4
  %tbl_size.i.i147.i2584 = load i64, ptr %tbl_size_ptr.i.i144.i2581, align 4
  %offset_tbl.i.i148.i2585 = load ptr, ptr %offset_tbl_ptr.i.i145.i2582, align 8
  %product.i.i.i149.i2586 = mul i64 %hash_coef.i.i146.i2583, 4015701072841558310
  %shifted.i.i.i150.i2587 = lshr i64 %product.i.i.i149.i2586, 32
  %xored.i.i.i151.i2588 = xor i64 %shifted.i.i.i150.i2587, %product.i.i.i149.i2586
  %hash.i.i.i152.i2589 = and i64 %xored.i.i.i151.i2588, %tbl_size.i.i147.i2584
  %offset_ptr.i.i153.i2590 = getelementptr i32, ptr %offset_tbl.i.i148.i2585, i64 %hash.i.i.i152.i2589
  %offset.i.i154.i2591 = load i32, ptr %offset_ptr.i.i153.i2590, align 4
  %618 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %619 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %620 = icmp ult i32 %.0566.i2554, 99
  br i1 %620, label %551, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2609

621:                                              ; preds = %582, %566
  %622 = phi ptr [ %24, %582 ], [ %23, %566 ]
  %623 = load i32, ptr %65, align 4
  store i32 %623, ptr %622, align 4
  %624 = add i32 %623, 1
  %625 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %624, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2609

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2609: ; preds = %.cont.cont.i2574, %621
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %._crit_edge.i1979

._crit_edge.i1979:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2609, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %626 = add nuw nsw i32 %.060.i1977, 1
  %627 = icmp slt i32 %626, %438
  br i1 %627, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i1979, %439, %436
  %628 = load ptr, ptr %result.i283, align 8
  %629 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %630 = load ptr, ptr %35, align 8
  %631 = load ptr, ptr %628, align 8
  %632 = getelementptr i8, ptr %631, i64 72
  %633 = load ptr, ptr %632, align 8
  %result.i.i.i = call { i64, i64 } %633(ptr nocapture nofree nonnull readonly %628) #5
  %634 = extractvalue { i64, i64 } %result.i.i.i, 0
  %635 = extractvalue { i64, i64 } %result.i.i.i, 1
  %636 = urem i64 20, %635
  %637 = icmp eq i64 %636, 0
  %638 = sub i64 %635, %636
  %639 = select i1 %637, i64 0, i64 %638
  %640 = add i64 %634, 20
  %641 = add i64 %640, %639
  %642 = load ptr, ptr %630, align 8
  %643 = getelementptr i8, ptr %642, i64 72
  %644 = load ptr, ptr %643, align 8
  %result.i1.i.i = call { i64, i64 } %644(ptr nocapture nofree nonnull readonly %630) #5
  %645 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %646 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %647 = call i64 @llvm.umax.i64(i64 %635, i64 %646)
  %648 = call i64 @llvm.umax.i64(i64 %647, i64 8)
  %649 = urem i64 %641, %646
  %650 = icmp eq i64 %649, 0
  %651 = sub i64 %646, %649
  %652 = select i1 %650, i64 0, i64 %651
  %653 = add i64 %645, %641
  %654 = add i64 %653, %652
  %655 = urem i64 %654, %648
  %656 = icmp eq i64 %655, 0
  %657 = sub i64 %648, %655
  %658 = select i1 %656, i64 0, i64 %657
  %659 = add i64 %658, %654
  %result.i90.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %659, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %628, ptr %result.i90.i, align 8
  %660 = getelementptr inbounds i8, ptr %result.i90.i, i64 8
  store ptr %630, ptr %660, align 8
  %661 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i)
  %662 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %663 = load ptr, ptr %628, align 8
  %664 = getelementptr i8, ptr %663, i64 72
  %665 = load ptr, ptr %664, align 8
  %result.i.i196.i = call { i64, i64 } %665(ptr nocapture nofree nonnull readonly %628) #5
  %666 = extractvalue { i64, i64 } %result.i.i196.i, 1
  %667 = urem i64 20, %666
  %668 = icmp eq i64 %667, 0
  %reass.sub3811 = sub i64 %666, %667
  %669 = add i64 %reass.sub3811, 20
  %670 = select i1 %668, i64 20, i64 %669
  %671 = getelementptr i8, ptr %result.i90.i, i64 %670
  %672 = getelementptr i8, ptr %663, i64 64
  %673 = load ptr, ptr %672, align 8
  call void %673({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %628, ptr nocapture nofree writeonly %671) #1
  %674 = load ptr, ptr %result.i90.i, align 8
  %675 = load ptr, ptr %674, align 8
  %676 = getelementptr i8, ptr %675, i64 72
  %677 = load ptr, ptr %676, align 8
  %result.i.i197.i = call { i64, i64 } %677(ptr nocapture nofree nonnull readonly %674) #5
  %678 = extractvalue { i64, i64 } %result.i.i197.i, 0
  %679 = extractvalue { i64, i64 } %result.i.i197.i, 1
  %680 = urem i64 20, %679
  %681 = icmp eq i64 %680, 0
  %682 = sub i64 %679, %680
  %683 = select i1 %681, i64 0, i64 %682
  %684 = add i64 %678, 20
  %685 = add i64 %684, %683
  %686 = load ptr, ptr %660, align 8
  %687 = load ptr, ptr %686, align 8
  %688 = getelementptr i8, ptr %687, i64 72
  %689 = load ptr, ptr %688, align 8
  %result.i1.i198.i = call { i64, i64 } %689(ptr nocapture nofree nonnull readonly %686) #5
  %690 = extractvalue { i64, i64 } %result.i1.i198.i, 1
  %691 = urem i64 %685, %690
  %692 = icmp eq i64 %691, 0
  %693 = sub i64 %690, %691
  %694 = select i1 %692, i64 0, i64 %693
  %695 = getelementptr i8, ptr %result.i90.i, i64 %685
  %696 = getelementptr i8, ptr %695, i64 %694
  %697 = getelementptr i8, ptr %687, i64 64
  %698 = load ptr, ptr %697, align 8
  call void %698({ ptr, i160 } %193, ptr nocapture nofree nonnull readonly %686, ptr nocapture nofree writeonly %696) #1
  %699 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %700 = getelementptr inbounds i8, ptr %result.i90.i, i64 16
  store i32 %195, ptr %700, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %34)
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %702 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %703 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %704

704:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %705, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %771, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i90.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i1167, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %705 = add nuw nsw i32 %.0566.i, 1
  %706 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %707 = insertvalue { ptr, ptr, ptr, i32 } %706, ptr %.sroa.6.0563.i, 1
  %708 = insertvalue { ptr, ptr, ptr, i32 } %707, ptr %.sroa.12.0562.i, 2
  %709 = insertvalue { ptr, ptr, ptr, i32 } %708, i32 %.sroa.17.0561.i, 3
  %710 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %711 = sext i32 %.sroa.17.0561.i to i64
  %712 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %711
  %713 = getelementptr i8, ptr %712, i64 64
  %714 = load ptr, ptr %713, align 8
  %result.i125.i1165 = call ptr %714({ ptr, ptr, ptr, i32 } %709, ptr nocapture nofree noundef nonnull readonly %2) #16
  %715 = call i32 %result.i125.i1165({ ptr, ptr, ptr, i32 } %709, { ptr, ptr, ptr, i32 } %709, ptr nonnull align 8 %2) #7
  %716 = ptrtoint ptr %.sroa.6.0563.i to i64
  %717 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %718, label %734

718:                                              ; preds = %704
  %719 = load i32, ptr %42, align 8
  %720 = add i32 %719, -1
  %721 = and i32 %720, %715
  %722 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %723 = load ptr, ptr %43, align 8
  %724 = sext i32 %721 to i64
  %725 = shl nsw i64 %724, 5
  %726 = getelementptr i8, ptr %723, i64 %725
  %727 = load ptr, ptr %726, align 8
  %728 = getelementptr i8, ptr %726, i64 8
  %729 = load i160, ptr %728, align 4
  store ptr %.sroa.0.0564.i, ptr %726, align 8
  store i64 %716, ptr %728, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %726, i64 16
  store i64 %717, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %726, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %730 = icmp ne ptr %727, @nil_typ
  %731 = icmp ne ptr %727, null
  %.not92.i = and i1 %730, %731
  %extract.i = lshr i160 %729, 64
  %732 = insertelement <2 x i160> poison, i160 %729, i64 0
  %733 = insertelement <2 x i160> %732, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

734:                                              ; preds = %704
  %735 = add i32 %715, 2127912214
  %736 = shl i32 %715, 12
  %737 = add i32 %735, %736
  %738 = ashr i32 %737, 19
  %739 = xor i32 %737, %738
  %740 = xor i32 %739, -949894596
  %741 = add i32 %740, 374761393
  %742 = shl i32 %740, 5
  %743 = add i32 %741, %742
  %744 = add i32 %743, -744332180
  %745 = shl i32 %743, 9
  %746 = xor i32 %744, %745
  %747 = add i32 %746, -42973499
  %748 = shl i32 %746, 3
  %749 = add i32 %747, %748
  %750 = ashr i32 %749, 16
  %751 = xor i32 %749, %750
  %752 = xor i32 %751, -1252372727
  %753 = load i32, ptr %42, align 8
  %754 = add i32 %753, -1
  %755 = and i32 %754, %752
  %756 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %757 = load ptr, ptr %44, align 8
  %758 = sext i32 %755 to i64
  %759 = shl nsw i64 %758, 5
  %760 = getelementptr i8, ptr %757, i64 %759
  %761 = load ptr, ptr %760, align 8
  %762 = getelementptr i8, ptr %760, i64 8
  %763 = load i160, ptr %762, align 4
  store ptr %.sroa.0.0564.i, ptr %760, align 8
  store i64 %716, ptr %762, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %760, i64 16
  store i64 %717, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %760, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %764 = icmp ne ptr %761, @nil_typ
  %765 = icmp ne ptr %761, null
  %.not90.i = and i1 %764, %765
  %extract607.i = lshr i160 %763, 64
  %766 = insertelement <2 x i160> poison, i160 %763, i64 0
  %767 = insertelement <2 x i160> %766, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %734, %718
  %vptr.i142.sroa.speculated.i = phi ptr [ %727, %718 ], [ %761, %734 ]
  %.in3817 = phi <2 x i160> [ %733, %718 ], [ %767, %734 ]
  %768 = trunc <2 x i160> %.in3817 to <2 x i64>
  %769 = extractelement <2 x i64> %768, i64 1
  %spec.select.i1167 = inttoptr i64 %769 to ptr
  %770 = extractelement <2 x i64> %768, i64 0
  %spec.select539.i = inttoptr i64 %770 to ptr
  %771 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %772 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %774 = icmp ult i32 %.0566.i, 99
  br i1 %774, label %704, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %718, %734
  %775 = phi ptr [ %34, %734 ], [ %33, %718 ]
  %776 = load i32, ptr %65, align 4
  store i32 %776, ptr %775, align 4
  %777 = add i32 %776, 1
  %778 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %777, ptr %65, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  %779 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %779, label %CuckooMap_insert_keyK_valueV.exit, label %780

780:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %781 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %782 = load ptr, ptr %43, align 8
  %783 = load ptr, ptr %44, align 8
  %784 = load i32, ptr %42, align 8
  %785 = shl i32 %784, 1
  %spec.select.i1184 = call i32 @llvm.smax.i32(i32 %785, i32 16)
  store i32 %spec.select.i1184, ptr %42, align 8
  %786 = zext nneg i32 %spec.select.i1184 to i64
  %787 = shl nuw nsw i64 %786, 5
  %result.i.i1185 = call noalias ptr @bump_malloc_inner(i64 noundef %787, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1185, ptr %43, align 8
  %result.i20.i1186 = call noalias ptr @bump_malloc_inner(i64 noundef %787, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1186, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %788 = icmp sgt i32 %784, 0
  br i1 %788, label %.lr.ph.i2026, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2059.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2059.thread: ; preds = %780
  %789 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095

.lr.ph.i2026:                                     ; preds = %780, %._crit_edge.i2041
  %.060.i2039 = phi i32 [ %878, %._crit_edge.i2041 ], [ 0, %780 ]
  %790 = zext nneg i32 %.060.i2039 to i64
  %791 = shl nuw nsw i64 %790, 5
  %792 = getelementptr i8, ptr %782, i64 %791
  %793 = load ptr, ptr %792, align 8
  %794 = icmp ne ptr %793, @nil_typ
  %795 = icmp ne ptr %793, null
  %.not16.i2040 = and i1 %794, %795
  br i1 %.not16.i2040, label %796, label %._crit_edge.i2041

796:                                              ; preds = %.lr.ph.i2026
  %797 = getelementptr i8, ptr %792, i64 8
  %798 = load <2 x i64>, ptr %797, align 4
  %hash_coef_ptr.i.i18.i2043 = getelementptr i8, ptr %793, i64 8
  %tbl_size_ptr.i.i19.i2044 = getelementptr i8, ptr %793, i64 16
  %offset_tbl_ptr.i.i20.i2045 = getelementptr i8, ptr %793, i64 40
  %799 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %hash_coef.i.i99.i2627 = load i64, ptr %hash_coef_ptr.i.i18.i2043, align 4, !noalias !22
  %tbl_size.i.i100.i2628 = load i64, ptr %tbl_size_ptr.i.i19.i2044, align 4, !noalias !22
  %offset_tbl.i.i101.i2629 = load ptr, ptr %offset_tbl_ptr.i.i20.i2045, align 8, !noalias !22
  %product.i.i.i102.i2630 = mul i64 %hash_coef.i.i99.i2627, 4015701072841558310
  %shifted.i.i.i103.i2631 = lshr i64 %product.i.i.i102.i2630, 32
  %xored.i.i.i104.i2632 = xor i64 %shifted.i.i.i103.i2631, %product.i.i.i102.i2630
  %hash.i.i.i105.i2633 = and i64 %xored.i.i.i104.i2632, %tbl_size.i.i100.i2628
  %offset_ptr.i.i106.i2634 = getelementptr i32, ptr %offset_tbl.i.i101.i2629, i64 %hash.i.i.i105.i2633
  %offset.i.i121.i2635 = load i32, ptr %offset_ptr.i.i106.i2634, align 4, !noalias !185
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %801 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %802 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %803

803:                                              ; preds = %.cont.cont.i2656, %796
  %.0566.i2636 = phi i32 [ 0, %796 ], [ %807, %.cont.cont.i2656 ]
  %.070565.i2637 = phi i1 [ true, %796 ], [ %869, %.cont.cont.i2656 ]
  %.sroa.0.0564.i2638 = phi ptr [ %793, %796 ], [ %vptr.i142.sroa.speculated.i2659, %.cont.cont.i2656 ]
  %.sroa.17.0561.i2641 = phi i32 [ %offset.i.i121.i2635, %796 ], [ %offset.i.i154.i2673, %.cont.cont.i2656 ]
  %804 = phi <2 x i64> [ %798, %796 ], [ %868, %.cont.cont.i2656 ]
  %805 = extractelement <2 x i64> %804, i64 1
  %.sroa.12.0562.i2640 = inttoptr i64 %805 to ptr
  %806 = extractelement <2 x i64> %804, i64 0
  %.sroa.6.0563.i2639 = inttoptr i64 %806 to ptr
  %807 = add nuw nsw i32 %.0566.i2636, 1
  %808 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2638, 0
  %809 = insertvalue { ptr, ptr, ptr, i32 } %808, ptr %.sroa.6.0563.i2639, 1
  %810 = insertvalue { ptr, ptr, ptr, i32 } %809, ptr %.sroa.12.0562.i2640, 2
  %811 = insertvalue { ptr, ptr, ptr, i32 } %810, i32 %.sroa.17.0561.i2641, 3
  %812 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2638)
  %813 = sext i32 %.sroa.17.0561.i2641 to i64
  %814 = getelementptr ptr, ptr %.sroa.0.0564.i2638, i64 %813
  %815 = getelementptr i8, ptr %814, i64 64
  %816 = load ptr, ptr %815, align 8
  %result.i125.i2642 = call ptr %816({ ptr, ptr, ptr, i32 } %811, ptr nocapture nofree noundef nonnull readonly %2) #16
  %817 = call i32 %result.i125.i2642({ ptr, ptr, ptr, i32 } %811, { ptr, ptr, ptr, i32 } %811, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2637, label %818, label %834

818:                                              ; preds = %803
  %819 = load i32, ptr %42, align 8
  %820 = add i32 %819, -1
  %821 = and i32 %820, %817
  %822 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %823 = load ptr, ptr %43, align 8
  %824 = sext i32 %821 to i64
  %825 = shl nsw i64 %824, 5
  %826 = getelementptr i8, ptr %823, i64 %825
  %827 = load ptr, ptr %826, align 8
  %828 = getelementptr i8, ptr %826, i64 8
  %829 = load i160, ptr %828, align 4
  store ptr %.sroa.0.0564.i2638, ptr %826, align 8
  store i64 %806, ptr %828, align 4
  %.sroa_idx157.i2685 = getelementptr i8, ptr %826, i64 16
  store i64 %805, ptr %.sroa_idx157.i2685, align 4
  %.sroa_idx158.i2686 = getelementptr i8, ptr %826, i64 24
  store i32 %.sroa.17.0561.i2641, ptr %.sroa_idx158.i2686, align 4
  %830 = icmp ne ptr %827, @nil_typ
  %831 = icmp ne ptr %827, null
  %.not92.i2687 = and i1 %830, %831
  %extract.i2689 = lshr i160 %829, 64
  %832 = insertelement <2 x i160> poison, i160 %829, i64 0
  %833 = insertelement <2 x i160> %832, i160 %extract.i2689, i64 1
  br i1 %.not92.i2687, label %.cont.cont.i2656, label %873

834:                                              ; preds = %803
  %835 = add i32 %817, 2127912214
  %836 = shl i32 %817, 12
  %837 = add i32 %835, %836
  %838 = ashr i32 %837, 19
  %839 = xor i32 %837, %838
  %840 = xor i32 %839, -949894596
  %841 = add i32 %840, 374761393
  %842 = shl i32 %840, 5
  %843 = add i32 %841, %842
  %844 = add i32 %843, -744332180
  %845 = shl i32 %843, 9
  %846 = xor i32 %844, %845
  %847 = add i32 %846, -42973499
  %848 = shl i32 %846, 3
  %849 = add i32 %847, %848
  %850 = ashr i32 %849, 16
  %851 = xor i32 %849, %850
  %852 = xor i32 %851, -1252372727
  %853 = load i32, ptr %42, align 8
  %854 = add i32 %853, -1
  %855 = and i32 %854, %852
  %856 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %857 = load ptr, ptr %44, align 8
  %858 = sext i32 %855 to i64
  %859 = shl nsw i64 %858, 5
  %860 = getelementptr i8, ptr %857, i64 %859
  %861 = load ptr, ptr %860, align 8
  %862 = getelementptr i8, ptr %860, i64 8
  %863 = load i160, ptr %862, align 4
  store ptr %.sroa.0.0564.i2638, ptr %860, align 8
  store i64 %806, ptr %862, align 4
  %.sroa_idx161.i2646 = getelementptr i8, ptr %860, i64 16
  store i64 %805, ptr %.sroa_idx161.i2646, align 4
  %.sroa_idx162.i2647 = getelementptr i8, ptr %860, i64 24
  store i32 %.sroa.17.0561.i2641, ptr %.sroa_idx162.i2647, align 4
  %864 = icmp ne ptr %861, @nil_typ
  %865 = icmp ne ptr %861, null
  %.not90.i2648 = and i1 %864, %865
  %extract607.i2650 = lshr i160 %863, 64
  %866 = insertelement <2 x i160> poison, i160 %863, i64 0
  %867 = insertelement <2 x i160> %866, i160 %extract607.i2650, i64 1
  br i1 %.not90.i2648, label %.cont.cont.i2656, label %873

.cont.cont.i2656:                                 ; preds = %834, %818
  %vptr.i142.sroa.speculated.i2659 = phi ptr [ %827, %818 ], [ %861, %834 ]
  %.in3818 = phi <2 x i160> [ %833, %818 ], [ %867, %834 ]
  %868 = trunc <2 x i160> %.in3818 to <2 x i64>
  %869 = xor i1 %.070565.i2637, true
  %hash_coef_ptr.i.i143.i2662 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2659, i64 8
  %tbl_size_ptr.i.i144.i2663 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2659, i64 16
  %offset_tbl_ptr.i.i145.i2664 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2659, i64 40
  %hash_coef.i.i146.i2665 = load i64, ptr %hash_coef_ptr.i.i143.i2662, align 4
  %tbl_size.i.i147.i2666 = load i64, ptr %tbl_size_ptr.i.i144.i2663, align 4
  %offset_tbl.i.i148.i2667 = load ptr, ptr %offset_tbl_ptr.i.i145.i2664, align 8
  %product.i.i.i149.i2668 = mul i64 %hash_coef.i.i146.i2665, 4015701072841558310
  %shifted.i.i.i150.i2669 = lshr i64 %product.i.i.i149.i2668, 32
  %xored.i.i.i151.i2670 = xor i64 %shifted.i.i.i150.i2669, %product.i.i.i149.i2668
  %hash.i.i.i152.i2671 = and i64 %xored.i.i.i151.i2670, %tbl_size.i.i147.i2666
  %offset_ptr.i.i153.i2672 = getelementptr i32, ptr %offset_tbl.i.i148.i2667, i64 %hash.i.i.i152.i2671
  %offset.i.i154.i2673 = load i32, ptr %offset_ptr.i.i153.i2672, align 4
  %870 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %871 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %872 = icmp ult i32 %.0566.i2636, 99
  br i1 %872, label %803, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2691

873:                                              ; preds = %834, %818
  %874 = phi ptr [ %22, %834 ], [ %21, %818 ]
  %875 = load i32, ptr %65, align 4
  store i32 %875, ptr %874, align 4
  %876 = add i32 %875, 1
  %877 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %876, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2691

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2691: ; preds = %.cont.cont.i2656, %873
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %._crit_edge.i2041

._crit_edge.i2041:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2691, %.lr.ph.i2026
  %878 = add nuw nsw i32 %.060.i2039, 1
  %879 = icmp slt i32 %878, %784
  br i1 %879, label %.lr.ph.i2026, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2059

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2059: ; preds = %._crit_edge.i2041
  %880 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %881

881:                                              ; preds = %._crit_edge.i2077, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2059
  %.060.i2075 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2059 ], [ %970, %._crit_edge.i2077 ]
  %882 = zext nneg i32 %.060.i2075 to i64
  %883 = shl nuw nsw i64 %882, 5
  %884 = getelementptr i8, ptr %783, i64 %883
  %885 = load ptr, ptr %884, align 8
  %886 = icmp ne ptr %885, @nil_typ
  %887 = icmp ne ptr %885, null
  %.not16.i2076 = and i1 %886, %887
  br i1 %.not16.i2076, label %888, label %._crit_edge.i2077

888:                                              ; preds = %881
  %889 = getelementptr i8, ptr %884, i64 8
  %890 = load <2 x i64>, ptr %889, align 4
  %hash_coef_ptr.i.i18.i2079 = getelementptr i8, ptr %885, i64 8
  %tbl_size_ptr.i.i19.i2080 = getelementptr i8, ptr %885, i64 16
  %offset_tbl_ptr.i.i20.i2081 = getelementptr i8, ptr %885, i64 40
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i2709 = load i64, ptr %hash_coef_ptr.i.i18.i2079, align 4, !noalias !22
  %tbl_size.i.i100.i2710 = load i64, ptr %tbl_size_ptr.i.i19.i2080, align 4, !noalias !22
  %offset_tbl.i.i101.i2711 = load ptr, ptr %offset_tbl_ptr.i.i20.i2081, align 8, !noalias !22
  %product.i.i.i102.i2712 = mul i64 %hash_coef.i.i99.i2709, 4015701072841558310
  %shifted.i.i.i103.i2713 = lshr i64 %product.i.i.i102.i2712, 32
  %xored.i.i.i104.i2714 = xor i64 %shifted.i.i.i103.i2713, %product.i.i.i102.i2712
  %hash.i.i.i105.i2715 = and i64 %xored.i.i.i104.i2714, %tbl_size.i.i100.i2710
  %offset_ptr.i.i106.i2716 = getelementptr i32, ptr %offset_tbl.i.i101.i2711, i64 %hash.i.i.i105.i2715
  %offset.i.i121.i2717 = load i32, ptr %offset_ptr.i.i106.i2716, align 4, !noalias !188
  %892 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %893 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %894 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %895

895:                                              ; preds = %.cont.cont.i2738, %888
  %.0566.i2718 = phi i32 [ 0, %888 ], [ %899, %.cont.cont.i2738 ]
  %.070565.i2719 = phi i1 [ true, %888 ], [ %961, %.cont.cont.i2738 ]
  %.sroa.0.0564.i2720 = phi ptr [ %885, %888 ], [ %vptr.i142.sroa.speculated.i2741, %.cont.cont.i2738 ]
  %.sroa.17.0561.i2723 = phi i32 [ %offset.i.i121.i2717, %888 ], [ %offset.i.i154.i2755, %.cont.cont.i2738 ]
  %896 = phi <2 x i64> [ %890, %888 ], [ %960, %.cont.cont.i2738 ]
  %897 = extractelement <2 x i64> %896, i64 1
  %.sroa.12.0562.i2722 = inttoptr i64 %897 to ptr
  %898 = extractelement <2 x i64> %896, i64 0
  %.sroa.6.0563.i2721 = inttoptr i64 %898 to ptr
  %899 = add nuw nsw i32 %.0566.i2718, 1
  %900 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2720, 0
  %901 = insertvalue { ptr, ptr, ptr, i32 } %900, ptr %.sroa.6.0563.i2721, 1
  %902 = insertvalue { ptr, ptr, ptr, i32 } %901, ptr %.sroa.12.0562.i2722, 2
  %903 = insertvalue { ptr, ptr, ptr, i32 } %902, i32 %.sroa.17.0561.i2723, 3
  %904 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2720)
  %905 = sext i32 %.sroa.17.0561.i2723 to i64
  %906 = getelementptr ptr, ptr %.sroa.0.0564.i2720, i64 %905
  %907 = getelementptr i8, ptr %906, i64 64
  %908 = load ptr, ptr %907, align 8
  %result.i125.i2724 = call ptr %908({ ptr, ptr, ptr, i32 } %903, ptr nocapture nofree noundef nonnull readonly %2) #16
  %909 = call i32 %result.i125.i2724({ ptr, ptr, ptr, i32 } %903, { ptr, ptr, ptr, i32 } %903, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2719, label %910, label %926

910:                                              ; preds = %895
  %911 = load i32, ptr %42, align 8
  %912 = add i32 %911, -1
  %913 = and i32 %912, %909
  %914 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %915 = load ptr, ptr %43, align 8
  %916 = sext i32 %913 to i64
  %917 = shl nsw i64 %916, 5
  %918 = getelementptr i8, ptr %915, i64 %917
  %919 = load ptr, ptr %918, align 8
  %920 = getelementptr i8, ptr %918, i64 8
  %921 = load i160, ptr %920, align 4
  store ptr %.sroa.0.0564.i2720, ptr %918, align 8
  store i64 %898, ptr %920, align 4
  %.sroa_idx157.i2767 = getelementptr i8, ptr %918, i64 16
  store i64 %897, ptr %.sroa_idx157.i2767, align 4
  %.sroa_idx158.i2768 = getelementptr i8, ptr %918, i64 24
  store i32 %.sroa.17.0561.i2723, ptr %.sroa_idx158.i2768, align 4
  %922 = icmp ne ptr %919, @nil_typ
  %923 = icmp ne ptr %919, null
  %.not92.i2769 = and i1 %922, %923
  %extract.i2771 = lshr i160 %921, 64
  %924 = insertelement <2 x i160> poison, i160 %921, i64 0
  %925 = insertelement <2 x i160> %924, i160 %extract.i2771, i64 1
  br i1 %.not92.i2769, label %.cont.cont.i2738, label %965

926:                                              ; preds = %895
  %927 = add i32 %909, 2127912214
  %928 = shl i32 %909, 12
  %929 = add i32 %927, %928
  %930 = ashr i32 %929, 19
  %931 = xor i32 %929, %930
  %932 = xor i32 %931, -949894596
  %933 = add i32 %932, 374761393
  %934 = shl i32 %932, 5
  %935 = add i32 %933, %934
  %936 = add i32 %935, -744332180
  %937 = shl i32 %935, 9
  %938 = xor i32 %936, %937
  %939 = add i32 %938, -42973499
  %940 = shl i32 %938, 3
  %941 = add i32 %939, %940
  %942 = ashr i32 %941, 16
  %943 = xor i32 %941, %942
  %944 = xor i32 %943, -1252372727
  %945 = load i32, ptr %42, align 8
  %946 = add i32 %945, -1
  %947 = and i32 %946, %944
  %948 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %949 = load ptr, ptr %44, align 8
  %950 = sext i32 %947 to i64
  %951 = shl nsw i64 %950, 5
  %952 = getelementptr i8, ptr %949, i64 %951
  %953 = load ptr, ptr %952, align 8
  %954 = getelementptr i8, ptr %952, i64 8
  %955 = load i160, ptr %954, align 4
  store ptr %.sroa.0.0564.i2720, ptr %952, align 8
  store i64 %898, ptr %954, align 4
  %.sroa_idx161.i2728 = getelementptr i8, ptr %952, i64 16
  store i64 %897, ptr %.sroa_idx161.i2728, align 4
  %.sroa_idx162.i2729 = getelementptr i8, ptr %952, i64 24
  store i32 %.sroa.17.0561.i2723, ptr %.sroa_idx162.i2729, align 4
  %956 = icmp ne ptr %953, @nil_typ
  %957 = icmp ne ptr %953, null
  %.not90.i2730 = and i1 %956, %957
  %extract607.i2732 = lshr i160 %955, 64
  %958 = insertelement <2 x i160> poison, i160 %955, i64 0
  %959 = insertelement <2 x i160> %958, i160 %extract607.i2732, i64 1
  br i1 %.not90.i2730, label %.cont.cont.i2738, label %965

.cont.cont.i2738:                                 ; preds = %926, %910
  %vptr.i142.sroa.speculated.i2741 = phi ptr [ %919, %910 ], [ %953, %926 ]
  %.in3819 = phi <2 x i160> [ %925, %910 ], [ %959, %926 ]
  %960 = trunc <2 x i160> %.in3819 to <2 x i64>
  %961 = xor i1 %.070565.i2719, true
  %hash_coef_ptr.i.i143.i2744 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2741, i64 8
  %tbl_size_ptr.i.i144.i2745 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2741, i64 16
  %offset_tbl_ptr.i.i145.i2746 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2741, i64 40
  %hash_coef.i.i146.i2747 = load i64, ptr %hash_coef_ptr.i.i143.i2744, align 4
  %tbl_size.i.i147.i2748 = load i64, ptr %tbl_size_ptr.i.i144.i2745, align 4
  %offset_tbl.i.i148.i2749 = load ptr, ptr %offset_tbl_ptr.i.i145.i2746, align 8
  %product.i.i.i149.i2750 = mul i64 %hash_coef.i.i146.i2747, 4015701072841558310
  %shifted.i.i.i150.i2751 = lshr i64 %product.i.i.i149.i2750, 32
  %xored.i.i.i151.i2752 = xor i64 %shifted.i.i.i150.i2751, %product.i.i.i149.i2750
  %hash.i.i.i152.i2753 = and i64 %xored.i.i.i151.i2752, %tbl_size.i.i147.i2748
  %offset_ptr.i.i153.i2754 = getelementptr i32, ptr %offset_tbl.i.i148.i2749, i64 %hash.i.i.i152.i2753
  %offset.i.i154.i2755 = load i32, ptr %offset_ptr.i.i153.i2754, align 4
  %962 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %963 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %964 = icmp ult i32 %.0566.i2718, 99
  br i1 %964, label %895, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2773

965:                                              ; preds = %926, %910
  %966 = phi ptr [ %20, %926 ], [ %19, %910 ]
  %967 = load i32, ptr %65, align 4
  store i32 %967, ptr %966, align 4
  %968 = add i32 %967, 1
  %969 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %968, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2773

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2773: ; preds = %.cont.cont.i2738, %965
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %._crit_edge.i2077

._crit_edge.i2077:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2773, %881
  %970 = add nuw nsw i32 %.060.i2075, 1
  %971 = icmp slt i32 %970, %784
  br i1 %971, label %881, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095: ; preds = %._crit_edge.i2077, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2059.thread
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %32)
  %hash_coef.i.i99.i1209 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i1210 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1211 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i1212 = mul i64 %hash_coef.i.i99.i1209, 4015701072841558310
  %shifted.i.i.i103.i1213 = lshr i64 %product.i.i.i102.i1212, 32
  %xored.i.i.i104.i1214 = xor i64 %shifted.i.i.i103.i1213, %product.i.i.i102.i1212
  %hash.i.i.i105.i1215 = and i64 %xored.i.i.i104.i1214, %tbl_size.i.i100.i1210
  %offset_ptr.i.i106.i1216 = getelementptr i32, ptr %offset_tbl.i.i101.i1211, i64 %hash.i.i.i105.i1215
  %offset.i.i121.i1217 = load i32, ptr %offset_ptr.i.i106.i1216, align 4, !noalias !191
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %973 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %974 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %975

975:                                              ; preds = %.cont.cont.i1239, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095
  %.0566.i1219 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095 ], [ %979, %.cont.cont.i1239 ]
  %.070565.i1220 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095 ], [ %1041, %.cont.cont.i1239 ]
  %.sroa.0.0564.i1221 = phi ptr [ %vptr.i142.sroa.speculated.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095 ], [ %vptr.i142.sroa.speculated.i1242, %.cont.cont.i1239 ]
  %.sroa.17.0561.i1224 = phi i32 [ %offset.i.i121.i1217, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095 ], [ %offset.i.i154.i1256, %.cont.cont.i1239 ]
  %976 = phi <2 x i64> [ %768, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2095 ], [ %1040, %.cont.cont.i1239 ]
  %977 = extractelement <2 x i64> %976, i64 1
  %.sroa.12.0562.i1223 = inttoptr i64 %977 to ptr
  %978 = extractelement <2 x i64> %976, i64 0
  %.sroa.6.0563.i1222 = inttoptr i64 %978 to ptr
  %979 = add nuw nsw i32 %.0566.i1219, 1
  %980 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1221, 0
  %981 = insertvalue { ptr, ptr, ptr, i32 } %980, ptr %.sroa.6.0563.i1222, 1
  %982 = insertvalue { ptr, ptr, ptr, i32 } %981, ptr %.sroa.12.0562.i1223, 2
  %983 = insertvalue { ptr, ptr, ptr, i32 } %982, i32 %.sroa.17.0561.i1224, 3
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1221)
  %985 = sext i32 %.sroa.17.0561.i1224 to i64
  %986 = getelementptr ptr, ptr %.sroa.0.0564.i1221, i64 %985
  %987 = getelementptr i8, ptr %986, i64 64
  %988 = load ptr, ptr %987, align 8
  %result.i125.i1225 = call ptr %988({ ptr, ptr, ptr, i32 } %983, ptr nocapture nofree noundef nonnull readonly %2) #16
  %989 = call i32 %result.i125.i1225({ ptr, ptr, ptr, i32 } %983, { ptr, ptr, ptr, i32 } %983, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1220, label %990, label %1006

990:                                              ; preds = %975
  %991 = load i32, ptr %42, align 8
  %992 = add i32 %991, -1
  %993 = and i32 %992, %989
  %994 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %995 = load ptr, ptr %43, align 8
  %996 = sext i32 %993 to i64
  %997 = shl nsw i64 %996, 5
  %998 = getelementptr i8, ptr %995, i64 %997
  %999 = load ptr, ptr %998, align 8
  %1000 = getelementptr i8, ptr %998, i64 8
  %1001 = load i160, ptr %1000, align 4
  store ptr %.sroa.0.0564.i1221, ptr %998, align 8
  store i64 %978, ptr %1000, align 4
  %.sroa_idx157.i1268 = getelementptr i8, ptr %998, i64 16
  store i64 %977, ptr %.sroa_idx157.i1268, align 4
  %.sroa_idx158.i1269 = getelementptr i8, ptr %998, i64 24
  store i32 %.sroa.17.0561.i1224, ptr %.sroa_idx158.i1269, align 4
  %1002 = icmp ne ptr %999, @nil_typ
  %1003 = icmp ne ptr %999, null
  %.not92.i1270 = and i1 %1002, %1003
  %extract.i1272 = lshr i160 %1001, 64
  %1004 = insertelement <2 x i160> poison, i160 %1001, i64 0
  %1005 = insertelement <2 x i160> %1004, i160 %extract.i1272, i64 1
  br i1 %.not92.i1270, label %.cont.cont.i1239, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1274.thread

1006:                                             ; preds = %975
  %1007 = add i32 %989, 2127912214
  %1008 = shl i32 %989, 12
  %1009 = add i32 %1007, %1008
  %1010 = ashr i32 %1009, 19
  %1011 = xor i32 %1009, %1010
  %1012 = xor i32 %1011, -949894596
  %1013 = add i32 %1012, 374761393
  %1014 = shl i32 %1012, 5
  %1015 = add i32 %1013, %1014
  %1016 = add i32 %1015, -744332180
  %1017 = shl i32 %1015, 9
  %1018 = xor i32 %1016, %1017
  %1019 = add i32 %1018, -42973499
  %1020 = shl i32 %1018, 3
  %1021 = add i32 %1019, %1020
  %1022 = ashr i32 %1021, 16
  %1023 = xor i32 %1021, %1022
  %1024 = xor i32 %1023, -1252372727
  %1025 = load i32, ptr %42, align 8
  %1026 = add i32 %1025, -1
  %1027 = and i32 %1026, %1024
  %1028 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1029 = load ptr, ptr %44, align 8
  %1030 = sext i32 %1027 to i64
  %1031 = shl nsw i64 %1030, 5
  %1032 = getelementptr i8, ptr %1029, i64 %1031
  %1033 = load ptr, ptr %1032, align 8
  %1034 = getelementptr i8, ptr %1032, i64 8
  %1035 = load i160, ptr %1034, align 4
  store ptr %.sroa.0.0564.i1221, ptr %1032, align 8
  store i64 %978, ptr %1034, align 4
  %.sroa_idx161.i1229 = getelementptr i8, ptr %1032, i64 16
  store i64 %977, ptr %.sroa_idx161.i1229, align 4
  %.sroa_idx162.i1230 = getelementptr i8, ptr %1032, i64 24
  store i32 %.sroa.17.0561.i1224, ptr %.sroa_idx162.i1230, align 4
  %1036 = icmp ne ptr %1033, @nil_typ
  %1037 = icmp ne ptr %1033, null
  %.not90.i1231 = and i1 %1036, %1037
  %extract607.i1233 = lshr i160 %1035, 64
  %1038 = insertelement <2 x i160> poison, i160 %1035, i64 0
  %1039 = insertelement <2 x i160> %1038, i160 %extract607.i1233, i64 1
  br i1 %.not90.i1231, label %.cont.cont.i1239, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1274.thread

.cont.cont.i1239:                                 ; preds = %1006, %990
  %vptr.i142.sroa.speculated.i1242 = phi ptr [ %999, %990 ], [ %1033, %1006 ]
  %.in3820 = phi <2 x i160> [ %1005, %990 ], [ %1039, %1006 ]
  %1040 = trunc <2 x i160> %.in3820 to <2 x i64>
  %1041 = xor i1 %.070565.i1220, true
  %hash_coef_ptr.i.i143.i1245 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1242, i64 8
  %tbl_size_ptr.i.i144.i1246 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1242, i64 16
  %offset_tbl_ptr.i.i145.i1247 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1242, i64 40
  %hash_coef.i.i146.i1248 = load i64, ptr %hash_coef_ptr.i.i143.i1245, align 4
  %tbl_size.i.i147.i1249 = load i64, ptr %tbl_size_ptr.i.i144.i1246, align 4
  %offset_tbl.i.i148.i1250 = load ptr, ptr %offset_tbl_ptr.i.i145.i1247, align 8
  %product.i.i.i149.i1251 = mul i64 %hash_coef.i.i146.i1248, 4015701072841558310
  %shifted.i.i.i150.i1252 = lshr i64 %product.i.i.i149.i1251, 32
  %xored.i.i.i151.i1253 = xor i64 %shifted.i.i.i150.i1252, %product.i.i.i149.i1251
  %hash.i.i.i152.i1254 = and i64 %xored.i.i.i151.i1253, %tbl_size.i.i147.i1249
  %offset_ptr.i.i153.i1255 = getelementptr i32, ptr %offset_tbl.i.i148.i1250, i64 %hash.i.i.i152.i1254
  %offset.i.i154.i1256 = load i32, ptr %offset_ptr.i.i153.i1255, align 4
  %1042 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1043 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1044 = icmp ult i32 %.0566.i1219, 99
  br i1 %1044, label %975, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1274

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1274.thread: ; preds = %990, %1006
  %1045 = phi ptr [ %32, %1006 ], [ %31, %990 ]
  %1046 = load i32, ptr %65, align 4
  store i32 %1046, ptr %1045, align 4
  %1047 = add i32 %1046, 1
  %1048 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1047, ptr %65, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1274: ; preds = %.cont.cont.i1239
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  %1049 = icmp eq ptr %vptr.i142.sroa.speculated.i1242, null
  br i1 %1049, label %CuckooMap_insert_keyK_valueV.exit, label %1050

1050:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1274
  %1051 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1052 = load ptr, ptr %43, align 8
  %1053 = load ptr, ptr %44, align 8
  %1054 = load i32, ptr %42, align 8
  %1055 = shl i32 %1054, 1
  %spec.select.i1290 = call i32 @llvm.smax.i32(i32 %1055, i32 16)
  store i32 %spec.select.i1290, ptr %42, align 8
  %1056 = zext nneg i32 %spec.select.i1290 to i64
  %1057 = shl nuw nsw i64 %1056, 5
  %result.i.i1291 = call noalias ptr @bump_malloc_inner(i64 noundef %1057, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1291, ptr %43, align 8
  %result.i20.i1292 = call noalias ptr @bump_malloc_inner(i64 noundef %1057, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1292, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %1058 = icmp sgt i32 %1054, 0
  br i1 %1058, label %.lr.ph.i2125, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2158.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2158.thread: ; preds = %1050
  %1059 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i2125:                                     ; preds = %1050, %._crit_edge.i2140
  %.060.i2138 = phi i32 [ %1148, %._crit_edge.i2140 ], [ 0, %1050 ]
  %1060 = zext nneg i32 %.060.i2138 to i64
  %1061 = shl nuw nsw i64 %1060, 5
  %1062 = getelementptr i8, ptr %1052, i64 %1061
  %1063 = load ptr, ptr %1062, align 8
  %1064 = icmp ne ptr %1063, @nil_typ
  %1065 = icmp ne ptr %1063, null
  %.not16.i2139 = and i1 %1064, %1065
  br i1 %.not16.i2139, label %1066, label %._crit_edge.i2140

1066:                                             ; preds = %.lr.ph.i2125
  %1067 = getelementptr i8, ptr %1062, i64 8
  %1068 = load <2 x i64>, ptr %1067, align 4
  %hash_coef_ptr.i.i18.i2142 = getelementptr i8, ptr %1063, i64 8
  %tbl_size_ptr.i.i19.i2143 = getelementptr i8, ptr %1063, i64 16
  %offset_tbl_ptr.i.i20.i2144 = getelementptr i8, ptr %1063, i64 40
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i2791 = load i64, ptr %hash_coef_ptr.i.i18.i2142, align 4, !noalias !22
  %tbl_size.i.i100.i2792 = load i64, ptr %tbl_size_ptr.i.i19.i2143, align 4, !noalias !22
  %offset_tbl.i.i101.i2793 = load ptr, ptr %offset_tbl_ptr.i.i20.i2144, align 8, !noalias !22
  %product.i.i.i102.i2794 = mul i64 %hash_coef.i.i99.i2791, 4015701072841558310
  %shifted.i.i.i103.i2795 = lshr i64 %product.i.i.i102.i2794, 32
  %xored.i.i.i104.i2796 = xor i64 %shifted.i.i.i103.i2795, %product.i.i.i102.i2794
  %hash.i.i.i105.i2797 = and i64 %xored.i.i.i104.i2796, %tbl_size.i.i100.i2792
  %offset_ptr.i.i106.i2798 = getelementptr i32, ptr %offset_tbl.i.i101.i2793, i64 %hash.i.i.i105.i2797
  %offset.i.i121.i2799 = load i32, ptr %offset_ptr.i.i106.i2798, align 4, !noalias !194
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1071 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1072 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1073

1073:                                             ; preds = %.cont.cont.i2820, %1066
  %.0566.i2800 = phi i32 [ 0, %1066 ], [ %1077, %.cont.cont.i2820 ]
  %.070565.i2801 = phi i1 [ true, %1066 ], [ %1139, %.cont.cont.i2820 ]
  %.sroa.0.0564.i2802 = phi ptr [ %1063, %1066 ], [ %vptr.i142.sroa.speculated.i2823, %.cont.cont.i2820 ]
  %.sroa.17.0561.i2805 = phi i32 [ %offset.i.i121.i2799, %1066 ], [ %offset.i.i154.i2837, %.cont.cont.i2820 ]
  %1074 = phi <2 x i64> [ %1068, %1066 ], [ %1138, %.cont.cont.i2820 ]
  %1075 = extractelement <2 x i64> %1074, i64 1
  %.sroa.12.0562.i2804 = inttoptr i64 %1075 to ptr
  %1076 = extractelement <2 x i64> %1074, i64 0
  %.sroa.6.0563.i2803 = inttoptr i64 %1076 to ptr
  %1077 = add nuw nsw i32 %.0566.i2800, 1
  %1078 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2802, 0
  %1079 = insertvalue { ptr, ptr, ptr, i32 } %1078, ptr %.sroa.6.0563.i2803, 1
  %1080 = insertvalue { ptr, ptr, ptr, i32 } %1079, ptr %.sroa.12.0562.i2804, 2
  %1081 = insertvalue { ptr, ptr, ptr, i32 } %1080, i32 %.sroa.17.0561.i2805, 3
  %1082 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2802)
  %1083 = sext i32 %.sroa.17.0561.i2805 to i64
  %1084 = getelementptr ptr, ptr %.sroa.0.0564.i2802, i64 %1083
  %1085 = getelementptr i8, ptr %1084, i64 64
  %1086 = load ptr, ptr %1085, align 8
  %result.i125.i2806 = call ptr %1086({ ptr, ptr, ptr, i32 } %1081, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1087 = call i32 %result.i125.i2806({ ptr, ptr, ptr, i32 } %1081, { ptr, ptr, ptr, i32 } %1081, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2801, label %1088, label %1104

1088:                                             ; preds = %1073
  %1089 = load i32, ptr %42, align 8
  %1090 = add i32 %1089, -1
  %1091 = and i32 %1090, %1087
  %1092 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1093 = load ptr, ptr %43, align 8
  %1094 = sext i32 %1091 to i64
  %1095 = shl nsw i64 %1094, 5
  %1096 = getelementptr i8, ptr %1093, i64 %1095
  %1097 = load ptr, ptr %1096, align 8
  %1098 = getelementptr i8, ptr %1096, i64 8
  %1099 = load i160, ptr %1098, align 4
  store ptr %.sroa.0.0564.i2802, ptr %1096, align 8
  store i64 %1076, ptr %1098, align 4
  %.sroa_idx157.i2849 = getelementptr i8, ptr %1096, i64 16
  store i64 %1075, ptr %.sroa_idx157.i2849, align 4
  %.sroa_idx158.i2850 = getelementptr i8, ptr %1096, i64 24
  store i32 %.sroa.17.0561.i2805, ptr %.sroa_idx158.i2850, align 4
  %1100 = icmp ne ptr %1097, @nil_typ
  %1101 = icmp ne ptr %1097, null
  %.not92.i2851 = and i1 %1100, %1101
  %extract.i2853 = lshr i160 %1099, 64
  %1102 = insertelement <2 x i160> poison, i160 %1099, i64 0
  %1103 = insertelement <2 x i160> %1102, i160 %extract.i2853, i64 1
  br i1 %.not92.i2851, label %.cont.cont.i2820, label %1143

1104:                                             ; preds = %1073
  %1105 = add i32 %1087, 2127912214
  %1106 = shl i32 %1087, 12
  %1107 = add i32 %1105, %1106
  %1108 = ashr i32 %1107, 19
  %1109 = xor i32 %1107, %1108
  %1110 = xor i32 %1109, -949894596
  %1111 = add i32 %1110, 374761393
  %1112 = shl i32 %1110, 5
  %1113 = add i32 %1111, %1112
  %1114 = add i32 %1113, -744332180
  %1115 = shl i32 %1113, 9
  %1116 = xor i32 %1114, %1115
  %1117 = add i32 %1116, -42973499
  %1118 = shl i32 %1116, 3
  %1119 = add i32 %1117, %1118
  %1120 = ashr i32 %1119, 16
  %1121 = xor i32 %1119, %1120
  %1122 = xor i32 %1121, -1252372727
  %1123 = load i32, ptr %42, align 8
  %1124 = add i32 %1123, -1
  %1125 = and i32 %1124, %1122
  %1126 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1127 = load ptr, ptr %44, align 8
  %1128 = sext i32 %1125 to i64
  %1129 = shl nsw i64 %1128, 5
  %1130 = getelementptr i8, ptr %1127, i64 %1129
  %1131 = load ptr, ptr %1130, align 8
  %1132 = getelementptr i8, ptr %1130, i64 8
  %1133 = load i160, ptr %1132, align 4
  store ptr %.sroa.0.0564.i2802, ptr %1130, align 8
  store i64 %1076, ptr %1132, align 4
  %.sroa_idx161.i2810 = getelementptr i8, ptr %1130, i64 16
  store i64 %1075, ptr %.sroa_idx161.i2810, align 4
  %.sroa_idx162.i2811 = getelementptr i8, ptr %1130, i64 24
  store i32 %.sroa.17.0561.i2805, ptr %.sroa_idx162.i2811, align 4
  %1134 = icmp ne ptr %1131, @nil_typ
  %1135 = icmp ne ptr %1131, null
  %.not90.i2812 = and i1 %1134, %1135
  %extract607.i2814 = lshr i160 %1133, 64
  %1136 = insertelement <2 x i160> poison, i160 %1133, i64 0
  %1137 = insertelement <2 x i160> %1136, i160 %extract607.i2814, i64 1
  br i1 %.not90.i2812, label %.cont.cont.i2820, label %1143

.cont.cont.i2820:                                 ; preds = %1104, %1088
  %vptr.i142.sroa.speculated.i2823 = phi ptr [ %1097, %1088 ], [ %1131, %1104 ]
  %.in3821 = phi <2 x i160> [ %1103, %1088 ], [ %1137, %1104 ]
  %1138 = trunc <2 x i160> %.in3821 to <2 x i64>
  %1139 = xor i1 %.070565.i2801, true
  %hash_coef_ptr.i.i143.i2826 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2823, i64 8
  %tbl_size_ptr.i.i144.i2827 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2823, i64 16
  %offset_tbl_ptr.i.i145.i2828 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2823, i64 40
  %hash_coef.i.i146.i2829 = load i64, ptr %hash_coef_ptr.i.i143.i2826, align 4
  %tbl_size.i.i147.i2830 = load i64, ptr %tbl_size_ptr.i.i144.i2827, align 4
  %offset_tbl.i.i148.i2831 = load ptr, ptr %offset_tbl_ptr.i.i145.i2828, align 8
  %product.i.i.i149.i2832 = mul i64 %hash_coef.i.i146.i2829, 4015701072841558310
  %shifted.i.i.i150.i2833 = lshr i64 %product.i.i.i149.i2832, 32
  %xored.i.i.i151.i2834 = xor i64 %shifted.i.i.i150.i2833, %product.i.i.i149.i2832
  %hash.i.i.i152.i2835 = and i64 %xored.i.i.i151.i2834, %tbl_size.i.i147.i2830
  %offset_ptr.i.i153.i2836 = getelementptr i32, ptr %offset_tbl.i.i148.i2831, i64 %hash.i.i.i152.i2835
  %offset.i.i154.i2837 = load i32, ptr %offset_ptr.i.i153.i2836, align 4
  %1140 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1141 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1142 = icmp ult i32 %.0566.i2800, 99
  br i1 %1142, label %1073, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2855

1143:                                             ; preds = %1104, %1088
  %1144 = phi ptr [ %18, %1104 ], [ %17, %1088 ]
  %1145 = load i32, ptr %65, align 4
  store i32 %1145, ptr %1144, align 4
  %1146 = add i32 %1145, 1
  %1147 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1146, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2855

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2855: ; preds = %.cont.cont.i2820, %1143
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i2140

._crit_edge.i2140:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2855, %.lr.ph.i2125
  %1148 = add nuw nsw i32 %.060.i2138, 1
  %1149 = icmp slt i32 %1148, %1054
  br i1 %1149, label %.lr.ph.i2125, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2158

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2158: ; preds = %._crit_edge.i2140
  %1150 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %1151

1151:                                             ; preds = %._crit_edge.i2176, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2158
  %.060.i2174 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2158 ], [ %1240, %._crit_edge.i2176 ]
  %1152 = zext nneg i32 %.060.i2174 to i64
  %1153 = shl nuw nsw i64 %1152, 5
  %1154 = getelementptr i8, ptr %1053, i64 %1153
  %1155 = load ptr, ptr %1154, align 8
  %1156 = icmp ne ptr %1155, @nil_typ
  %1157 = icmp ne ptr %1155, null
  %.not16.i2175 = and i1 %1156, %1157
  br i1 %.not16.i2175, label %1158, label %._crit_edge.i2176

1158:                                             ; preds = %1151
  %1159 = getelementptr i8, ptr %1154, i64 8
  %1160 = load <2 x i64>, ptr %1159, align 4
  %hash_coef_ptr.i.i18.i2178 = getelementptr i8, ptr %1155, i64 8
  %tbl_size_ptr.i.i19.i2179 = getelementptr i8, ptr %1155, i64 16
  %offset_tbl_ptr.i.i20.i2180 = getelementptr i8, ptr %1155, i64 40
  %1161 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i2873 = load i64, ptr %hash_coef_ptr.i.i18.i2178, align 4, !noalias !22
  %tbl_size.i.i100.i2874 = load i64, ptr %tbl_size_ptr.i.i19.i2179, align 4, !noalias !22
  %offset_tbl.i.i101.i2875 = load ptr, ptr %offset_tbl_ptr.i.i20.i2180, align 8, !noalias !22
  %product.i.i.i102.i2876 = mul i64 %hash_coef.i.i99.i2873, 4015701072841558310
  %shifted.i.i.i103.i2877 = lshr i64 %product.i.i.i102.i2876, 32
  %xored.i.i.i104.i2878 = xor i64 %shifted.i.i.i103.i2877, %product.i.i.i102.i2876
  %hash.i.i.i105.i2879 = and i64 %xored.i.i.i104.i2878, %tbl_size.i.i100.i2874
  %offset_ptr.i.i106.i2880 = getelementptr i32, ptr %offset_tbl.i.i101.i2875, i64 %hash.i.i.i105.i2879
  %offset.i.i121.i2881 = load i32, ptr %offset_ptr.i.i106.i2880, align 4, !noalias !197
  %1162 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1163 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1164 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1165

1165:                                             ; preds = %.cont.cont.i2902, %1158
  %.0566.i2882 = phi i32 [ 0, %1158 ], [ %1169, %.cont.cont.i2902 ]
  %.070565.i2883 = phi i1 [ true, %1158 ], [ %1231, %.cont.cont.i2902 ]
  %.sroa.0.0564.i2884 = phi ptr [ %1155, %1158 ], [ %vptr.i142.sroa.speculated.i2905, %.cont.cont.i2902 ]
  %.sroa.17.0561.i2887 = phi i32 [ %offset.i.i121.i2881, %1158 ], [ %offset.i.i154.i2919, %.cont.cont.i2902 ]
  %1166 = phi <2 x i64> [ %1160, %1158 ], [ %1230, %.cont.cont.i2902 ]
  %1167 = extractelement <2 x i64> %1166, i64 1
  %.sroa.12.0562.i2886 = inttoptr i64 %1167 to ptr
  %1168 = extractelement <2 x i64> %1166, i64 0
  %.sroa.6.0563.i2885 = inttoptr i64 %1168 to ptr
  %1169 = add nuw nsw i32 %.0566.i2882, 1
  %1170 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2884, 0
  %1171 = insertvalue { ptr, ptr, ptr, i32 } %1170, ptr %.sroa.6.0563.i2885, 1
  %1172 = insertvalue { ptr, ptr, ptr, i32 } %1171, ptr %.sroa.12.0562.i2886, 2
  %1173 = insertvalue { ptr, ptr, ptr, i32 } %1172, i32 %.sroa.17.0561.i2887, 3
  %1174 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2884)
  %1175 = sext i32 %.sroa.17.0561.i2887 to i64
  %1176 = getelementptr ptr, ptr %.sroa.0.0564.i2884, i64 %1175
  %1177 = getelementptr i8, ptr %1176, i64 64
  %1178 = load ptr, ptr %1177, align 8
  %result.i125.i2888 = call ptr %1178({ ptr, ptr, ptr, i32 } %1173, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1179 = call i32 %result.i125.i2888({ ptr, ptr, ptr, i32 } %1173, { ptr, ptr, ptr, i32 } %1173, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2883, label %1180, label %1196

1180:                                             ; preds = %1165
  %1181 = load i32, ptr %42, align 8
  %1182 = add i32 %1181, -1
  %1183 = and i32 %1182, %1179
  %1184 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1185 = load ptr, ptr %43, align 8
  %1186 = sext i32 %1183 to i64
  %1187 = shl nsw i64 %1186, 5
  %1188 = getelementptr i8, ptr %1185, i64 %1187
  %1189 = load ptr, ptr %1188, align 8
  %1190 = getelementptr i8, ptr %1188, i64 8
  %1191 = load i160, ptr %1190, align 4
  store ptr %.sroa.0.0564.i2884, ptr %1188, align 8
  store i64 %1168, ptr %1190, align 4
  %.sroa_idx157.i2931 = getelementptr i8, ptr %1188, i64 16
  store i64 %1167, ptr %.sroa_idx157.i2931, align 4
  %.sroa_idx158.i2932 = getelementptr i8, ptr %1188, i64 24
  store i32 %.sroa.17.0561.i2887, ptr %.sroa_idx158.i2932, align 4
  %1192 = icmp ne ptr %1189, @nil_typ
  %1193 = icmp ne ptr %1189, null
  %.not92.i2933 = and i1 %1192, %1193
  %extract.i2935 = lshr i160 %1191, 64
  %1194 = insertelement <2 x i160> poison, i160 %1191, i64 0
  %1195 = insertelement <2 x i160> %1194, i160 %extract.i2935, i64 1
  br i1 %.not92.i2933, label %.cont.cont.i2902, label %1235

1196:                                             ; preds = %1165
  %1197 = add i32 %1179, 2127912214
  %1198 = shl i32 %1179, 12
  %1199 = add i32 %1197, %1198
  %1200 = ashr i32 %1199, 19
  %1201 = xor i32 %1199, %1200
  %1202 = xor i32 %1201, -949894596
  %1203 = add i32 %1202, 374761393
  %1204 = shl i32 %1202, 5
  %1205 = add i32 %1203, %1204
  %1206 = add i32 %1205, -744332180
  %1207 = shl i32 %1205, 9
  %1208 = xor i32 %1206, %1207
  %1209 = add i32 %1208, -42973499
  %1210 = shl i32 %1208, 3
  %1211 = add i32 %1209, %1210
  %1212 = ashr i32 %1211, 16
  %1213 = xor i32 %1211, %1212
  %1214 = xor i32 %1213, -1252372727
  %1215 = load i32, ptr %42, align 8
  %1216 = add i32 %1215, -1
  %1217 = and i32 %1216, %1214
  %1218 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1219 = load ptr, ptr %44, align 8
  %1220 = sext i32 %1217 to i64
  %1221 = shl nsw i64 %1220, 5
  %1222 = getelementptr i8, ptr %1219, i64 %1221
  %1223 = load ptr, ptr %1222, align 8
  %1224 = getelementptr i8, ptr %1222, i64 8
  %1225 = load i160, ptr %1224, align 4
  store ptr %.sroa.0.0564.i2884, ptr %1222, align 8
  store i64 %1168, ptr %1224, align 4
  %.sroa_idx161.i2892 = getelementptr i8, ptr %1222, i64 16
  store i64 %1167, ptr %.sroa_idx161.i2892, align 4
  %.sroa_idx162.i2893 = getelementptr i8, ptr %1222, i64 24
  store i32 %.sroa.17.0561.i2887, ptr %.sroa_idx162.i2893, align 4
  %1226 = icmp ne ptr %1223, @nil_typ
  %1227 = icmp ne ptr %1223, null
  %.not90.i2894 = and i1 %1226, %1227
  %extract607.i2896 = lshr i160 %1225, 64
  %1228 = insertelement <2 x i160> poison, i160 %1225, i64 0
  %1229 = insertelement <2 x i160> %1228, i160 %extract607.i2896, i64 1
  br i1 %.not90.i2894, label %.cont.cont.i2902, label %1235

.cont.cont.i2902:                                 ; preds = %1196, %1180
  %vptr.i142.sroa.speculated.i2905 = phi ptr [ %1189, %1180 ], [ %1223, %1196 ]
  %.in3822 = phi <2 x i160> [ %1195, %1180 ], [ %1229, %1196 ]
  %1230 = trunc <2 x i160> %.in3822 to <2 x i64>
  %1231 = xor i1 %.070565.i2883, true
  %hash_coef_ptr.i.i143.i2908 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2905, i64 8
  %tbl_size_ptr.i.i144.i2909 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2905, i64 16
  %offset_tbl_ptr.i.i145.i2910 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2905, i64 40
  %hash_coef.i.i146.i2911 = load i64, ptr %hash_coef_ptr.i.i143.i2908, align 4
  %tbl_size.i.i147.i2912 = load i64, ptr %tbl_size_ptr.i.i144.i2909, align 4
  %offset_tbl.i.i148.i2913 = load ptr, ptr %offset_tbl_ptr.i.i145.i2910, align 8
  %product.i.i.i149.i2914 = mul i64 %hash_coef.i.i146.i2911, 4015701072841558310
  %shifted.i.i.i150.i2915 = lshr i64 %product.i.i.i149.i2914, 32
  %xored.i.i.i151.i2916 = xor i64 %shifted.i.i.i150.i2915, %product.i.i.i149.i2914
  %hash.i.i.i152.i2917 = and i64 %xored.i.i.i151.i2916, %tbl_size.i.i147.i2912
  %offset_ptr.i.i153.i2918 = getelementptr i32, ptr %offset_tbl.i.i148.i2913, i64 %hash.i.i.i152.i2917
  %offset.i.i154.i2919 = load i32, ptr %offset_ptr.i.i153.i2918, align 4
  %1232 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1233 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1234 = icmp ult i32 %.0566.i2882, 99
  br i1 %1234, label %1165, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2937

1235:                                             ; preds = %1196, %1180
  %1236 = phi ptr [ %16, %1196 ], [ %15, %1180 ]
  %1237 = load i32, ptr %65, align 4
  store i32 %1237, ptr %1236, align 4
  %1238 = add i32 %1237, 1
  %1239 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1238, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2937

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2937: ; preds = %.cont.cont.i2902, %1235
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i2176

._crit_edge.i2176:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit2937, %1151
  %1240 = add nuw nsw i32 %.060.i2174, 1
  %1241 = icmp slt i32 %1240, %1054
  br i1 %1241, label %1151, label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i2176, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2158.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1274.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1134, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1274
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1242 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %1243 = sext i32 %.0266514 to i64
  %1244 = shl nsw i64 %1243, 2
  %1245 = getelementptr i8, ptr %result.i4.i, i64 %1244
  store i32 %72, ptr %1245, align 1
  store i1 true, ptr %.sroa.0224.sroa.0, align 8
  %.sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.0. = load i8, ptr %.sroa.0224.sroa.0, align 8
  %.sroa.0224.0.insert.ext = zext i8 %.sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.0. to i160
  %1246 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0224.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1247 = load ptr, ptr %54, align 8
  %1248 = call i32 %1247({ ptr, i160 } %73) #7
  %1249 = load i32, ptr %56, align 8
  %1250 = add i32 %1249, -1
  %1251 = and i32 %1250, %1248
  %1252 = load ptr, ptr %57, align 8
  %1253 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1254 = sext i32 %1251 to i64
  %1255 = shl nsw i64 %1254, 5
  %1256 = getelementptr i8, ptr %1252, i64 %1255
  %1257 = load ptr, ptr %1256, align 8
  %1258 = getelementptr i8, ptr %1256, i64 8
  %1259 = icmp ne ptr %1257, @nil_typ
  %1260 = icmp ne ptr %1257, null
  %.not64.i1339 = and i1 %1259, %1260
  br i1 %.not64.i1339, label %1261, label %1359

1261:                                             ; preds = %CuckooMap_insert_keyK_valueV.exit
  %1262 = load i64, ptr %1258, align 4
  %.sroa_idx.i1341 = getelementptr i8, ptr %1256, i64 16
  %1263 = load i64, ptr %.sroa_idx.i1341, align 4
  %1264 = inttoptr i64 %1262 to ptr
  %1265 = inttoptr i64 %1263 to ptr
  %hash_coef_ptr.i.i66.i1342 = getelementptr i8, ptr %1257, i64 8
  %tbl_size_ptr.i.i67.i1343 = getelementptr i8, ptr %1257, i64 16
  %offset_tbl_ptr.i.i68.i1344 = getelementptr i8, ptr %1257, i64 40
  %hash_coef.i.i69.i1345 = load i64, ptr %hash_coef_ptr.i.i66.i1342, align 4, !noalias !200
  %tbl_size.i.i70.i1346 = load i64, ptr %tbl_size_ptr.i.i67.i1343, align 4, !noalias !200
  %offset_tbl.i.i71.i1347 = load ptr, ptr %offset_tbl_ptr.i.i68.i1344, align 8, !noalias !200
  %product.i.i.i72.i1348 = mul i64 %hash_coef.i.i69.i1345, 4015701072841558310
  %shifted.i.i.i73.i1349 = lshr i64 %product.i.i.i72.i1348, 32
  %xored.i.i.i74.i1350 = xor i64 %shifted.i.i.i73.i1349, %product.i.i.i72.i1348
  %hash.i.i.i75.i1351 = and i64 %xored.i.i.i74.i1350, %tbl_size.i.i70.i1346
  %offset_ptr.i.i76.i1352 = getelementptr i32, ptr %offset_tbl.i.i71.i1347, i64 %hash.i.i.i75.i1351
  %offset.i.i77.i1353 = load i32, ptr %offset_ptr.i.i76.i1352, align 4, !noalias !200
  %1266 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1257, 0
  %1267 = insertvalue { ptr, ptr, ptr, i32 } %1266, ptr %1264, 1
  %1268 = insertvalue { ptr, ptr, ptr, i32 } %1267, ptr %1265, 2
  %1269 = insertvalue { ptr, ptr, ptr, i32 } %1268, i32 %offset.i.i77.i1353, 3
  %1270 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1257) #35
  %1272 = sext i32 %offset.i.i77.i1353 to i64
  %1273 = getelementptr ptr, ptr %1257, i64 %1272
  %1274 = getelementptr i8, ptr %1273, i64 64
  %1275 = load ptr, ptr %1274, align 8
  %result.i.i1354 = call ptr %1275({ ptr, ptr, ptr, i32 } %1269, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1276 = call i32 %result.i.i1354({ ptr, ptr, ptr, i32 } %1269, { ptr, ptr, ptr, i32 } %1269, ptr nonnull align 8 %2) #7
  %1277 = icmp eq i32 %1276, %1248
  br i1 %1277, label %._crit_edge.i1355, label %1359

._crit_edge.i1355:                                ; preds = %1261
  %1278 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1279 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1257)
  %1280 = getelementptr i8, ptr %1273, i64 48
  %1281 = load ptr, ptr %1280, align 8
  %result.i79.i1356 = call ptr %1281({ ptr, ptr, ptr, i32 } %1269, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1282 = call { ptr, i160 } %result.i79.i1356({ ptr, ptr, ptr, i32 } %1269, { ptr, ptr, ptr, i32 } %1269, ptr nonnull align 8 %2) #7
  %1283 = load ptr, ptr %55, align 8
  %1284 = call i1 %1283({ ptr, i160 } %1282, { ptr, i160 } %73) #7
  br i1 %1284, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1368, label %1359

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1368: ; preds = %._crit_edge.i1355
  %1285 = load ptr, ptr %result.i326, align 8
  %1286 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1287 = load ptr, ptr %49, align 8
  %1288 = load ptr, ptr %1285, align 8, !alias.scope !203
  %1289 = getelementptr i8, ptr %1288, i64 72
  %1290 = load ptr, ptr %1289, align 8, !alias.scope !203
  %result.i.i.i1360 = call { i64, i64 } %1290(ptr nocapture nofree nonnull readonly %1285) #5, !alias.scope !203
  %1291 = extractvalue { i64, i64 } %result.i.i.i1360, 0
  %1292 = extractvalue { i64, i64 } %result.i.i.i1360, 1
  %1293 = urem i64 20, %1292
  %1294 = icmp eq i64 %1293, 0
  %1295 = sub i64 %1292, %1293
  %1296 = select i1 %1294, i64 0, i64 %1295
  %1297 = add i64 %1291, 20
  %1298 = add i64 %1297, %1296
  %1299 = load ptr, ptr %1287, align 8, !alias.scope !203
  %1300 = getelementptr i8, ptr %1299, i64 72
  %1301 = load ptr, ptr %1300, align 8, !alias.scope !203
  %result.i1.i.i1361 = call { i64, i64 } %1301(ptr nocapture nofree nonnull readonly %1287) #5, !alias.scope !203
  %1302 = extractvalue { i64, i64 } %result.i1.i.i1361, 0
  %1303 = extractvalue { i64, i64 } %result.i1.i.i1361, 1
  %1304 = call i64 @llvm.umax.i64(i64 %1292, i64 %1303)
  %1305 = call i64 @llvm.umax.i64(i64 %1304, i64 8)
  %1306 = urem i64 %1298, %1303
  %1307 = icmp eq i64 %1306, 0
  %1308 = sub i64 %1303, %1306
  %1309 = select i1 %1307, i64 0, i64 %1308
  %1310 = add i64 %1302, %1298
  %1311 = add i64 %1310, %1309
  %1312 = urem i64 %1311, %1305
  %1313 = icmp eq i64 %1312, 0
  %1314 = sub i64 %1305, %1312
  %1315 = select i1 %1313, i64 0, i64 %1314
  %1316 = add i64 %1315, %1311
  %result.i83.i1362 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1316, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1285, ptr %result.i83.i1362, align 8
  %1317 = getelementptr inbounds i8, ptr %result.i83.i1362, i64 8
  store ptr %1287, ptr %1317, align 8
  %1318 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1362)
  %1319 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1320 = load ptr, ptr %1285, align 8
  %1321 = getelementptr i8, ptr %1320, i64 72
  %1322 = load ptr, ptr %1321, align 8
  %result.i.i118.i1363 = call { i64, i64 } %1322(ptr nocapture nofree nonnull readonly %1285) #5
  %1323 = extractvalue { i64, i64 } %result.i.i118.i1363, 1
  %1324 = urem i64 20, %1323
  %1325 = icmp eq i64 %1324, 0
  %reass.sub = sub i64 %1323, %1324
  %1326 = add i64 %reass.sub, 20
  %1327 = select i1 %1325, i64 20, i64 %1326
  %1328 = getelementptr i8, ptr %result.i83.i1362, i64 %1327
  %1329 = getelementptr i8, ptr %1320, i64 64
  %1330 = load ptr, ptr %1329, align 8
  call void %1330({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1285, ptr nocapture nofree writeonly %1328) #1
  %1331 = load ptr, ptr %result.i83.i1362, align 8
  %1332 = load ptr, ptr %1331, align 8
  %1333 = getelementptr i8, ptr %1332, i64 72
  %1334 = load ptr, ptr %1333, align 8
  %result.i.i119.i1365 = call { i64, i64 } %1334(ptr nocapture nofree nonnull readonly %1331) #5
  %1335 = extractvalue { i64, i64 } %result.i.i119.i1365, 0
  %1336 = extractvalue { i64, i64 } %result.i.i119.i1365, 1
  %1337 = urem i64 20, %1336
  %1338 = icmp eq i64 %1337, 0
  %1339 = sub i64 %1336, %1337
  %1340 = select i1 %1338, i64 0, i64 %1339
  %1341 = add i64 %1335, 20
  %1342 = add i64 %1341, %1340
  %1343 = load ptr, ptr %1317, align 8
  %1344 = load ptr, ptr %1343, align 8
  %1345 = getelementptr i8, ptr %1344, i64 72
  %1346 = load ptr, ptr %1345, align 8
  %result.i1.i120.i1366 = call { i64, i64 } %1346(ptr nocapture nofree nonnull readonly %1343) #5
  %1347 = extractvalue { i64, i64 } %result.i1.i120.i1366, 1
  %1348 = urem i64 %1342, %1347
  %1349 = icmp eq i64 %1348, 0
  %1350 = sub i64 %1347, %1348
  %1351 = select i1 %1349, i64 0, i64 %1350
  %1352 = getelementptr i8, ptr %result.i83.i1362, i64 %1342
  %1353 = getelementptr i8, ptr %1352, i64 %1351
  %1354 = getelementptr i8, ptr %1344, i64 64
  %1355 = load ptr, ptr %1354, align 8
  call void %1355({ ptr, i160 } %1246, ptr nocapture nofree nonnull readonly %1343, ptr nocapture nofree writeonly %1353) #1
  %1356 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1357 = getelementptr inbounds i8, ptr %result.i83.i1362, i64 16
  store i32 %1248, ptr %1357, align 8
  store ptr @Entry, ptr %1256, align 8
  %1358 = ptrtoint ptr %result.i83.i1362 to i64
  store i64 %1358, ptr %1258, align 4
  %.sroa_idx28.i1367 = getelementptr i8, ptr %1256, i64 24
  store i32 10, ptr %.sroa_idx28.i1367, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit780

1359:                                             ; preds = %._crit_edge.i1355, %CuckooMap_insert_keyK_valueV.exit, %1261
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1360 = add i32 %1248, 2127912214
  %1361 = shl i32 %1248, 12
  %1362 = add i32 %1360, %1361
  %1363 = ashr i32 %1362, 19
  %1364 = xor i32 %1362, %1363
  %1365 = xor i32 %1364, -949894596
  %1366 = add i32 %1365, 374761393
  %1367 = shl i32 %1365, 5
  %1368 = add i32 %1366, %1367
  %1369 = add i32 %1368, -744332180
  %1370 = shl i32 %1368, 9
  %1371 = xor i32 %1369, %1370
  %1372 = add i32 %1371, -42973499
  %1373 = shl i32 %1371, 3
  %1374 = add i32 %1372, %1373
  %1375 = ashr i32 %1374, 16
  %1376 = xor i32 %1374, %1375
  %1377 = xor i32 %1376, -1252372727
  %1378 = load i32, ptr %56, align 8
  %1379 = add i32 %1378, -1
  %1380 = and i32 %1379, %1377
  %1381 = load ptr, ptr %58, align 8
  %1382 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1383 = sext i32 %1380 to i64
  %1384 = shl nsw i64 %1383, 5
  %1385 = getelementptr i8, ptr %1381, i64 %1384
  %1386 = load ptr, ptr %1385, align 8
  %1387 = getelementptr i8, ptr %1385, i64 8
  %1388 = icmp ne ptr %1386, @nil_typ
  %1389 = icmp ne ptr %1386, null
  %.not64.i1398 = and i1 %1388, %1389
  br i1 %.not64.i1398, label %1390, label %1489

1390:                                             ; preds = %1359
  %1391 = load i64, ptr %1387, align 4
  %.sroa_idx.i1400 = getelementptr i8, ptr %1385, i64 16
  %1392 = load i64, ptr %.sroa_idx.i1400, align 4
  %1393 = inttoptr i64 %1391 to ptr
  %1394 = inttoptr i64 %1392 to ptr
  %hash_coef_ptr.i.i66.i1401 = getelementptr i8, ptr %1386, i64 8
  %tbl_size_ptr.i.i67.i1402 = getelementptr i8, ptr %1386, i64 16
  %offset_tbl_ptr.i.i68.i1403 = getelementptr i8, ptr %1386, i64 40
  %hash_coef.i.i69.i1404 = load i64, ptr %hash_coef_ptr.i.i66.i1401, align 4, !noalias !206
  %tbl_size.i.i70.i1405 = load i64, ptr %tbl_size_ptr.i.i67.i1402, align 4, !noalias !206
  %offset_tbl.i.i71.i1406 = load ptr, ptr %offset_tbl_ptr.i.i68.i1403, align 8, !noalias !206
  %product.i.i.i72.i1407 = mul i64 %hash_coef.i.i69.i1404, 4015701072841558310
  %shifted.i.i.i73.i1408 = lshr i64 %product.i.i.i72.i1407, 32
  %xored.i.i.i74.i1409 = xor i64 %shifted.i.i.i73.i1408, %product.i.i.i72.i1407
  %hash.i.i.i75.i1410 = and i64 %xored.i.i.i74.i1409, %tbl_size.i.i70.i1405
  %offset_ptr.i.i76.i1411 = getelementptr i32, ptr %offset_tbl.i.i71.i1406, i64 %hash.i.i.i75.i1410
  %offset.i.i77.i1412 = load i32, ptr %offset_ptr.i.i76.i1411, align 4, !noalias !206
  %1395 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1386, 0
  %1396 = insertvalue { ptr, ptr, ptr, i32 } %1395, ptr %1393, 1
  %1397 = insertvalue { ptr, ptr, ptr, i32 } %1396, ptr %1394, 2
  %1398 = insertvalue { ptr, ptr, ptr, i32 } %1397, i32 %offset.i.i77.i1412, 3
  %1399 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1400 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1386) #35
  %1401 = sext i32 %offset.i.i77.i1412 to i64
  %1402 = getelementptr ptr, ptr %1386, i64 %1401
  %1403 = getelementptr i8, ptr %1402, i64 64
  %1404 = load ptr, ptr %1403, align 8
  %result.i.i1413 = call ptr %1404({ ptr, ptr, ptr, i32 } %1398, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1405 = call i32 %result.i.i1413({ ptr, ptr, ptr, i32 } %1398, { ptr, ptr, ptr, i32 } %1398, ptr nonnull align 8 %2) #7
  %1406 = icmp eq i32 %1405, %1248
  br i1 %1406, label %._crit_edge.i1414, label %1489

._crit_edge.i1414:                                ; preds = %1390
  %1407 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1408 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1386)
  %1409 = getelementptr i8, ptr %1402, i64 48
  %1410 = load ptr, ptr %1409, align 8
  %result.i79.i1415 = call ptr %1410({ ptr, ptr, ptr, i32 } %1398, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1411 = call { ptr, i160 } %result.i79.i1415({ ptr, ptr, ptr, i32 } %1398, { ptr, ptr, ptr, i32 } %1398, ptr nonnull align 8 %2) #7
  %1412 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1413 = load ptr, ptr %55, align 8
  %1414 = call i1 %1413({ ptr, i160 } %1411, { ptr, i160 } %73) #7
  br i1 %1414, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1427, label %1489

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1427: ; preds = %._crit_edge.i1414
  %1415 = load ptr, ptr %result.i326, align 8
  %1416 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1417 = load ptr, ptr %49, align 8
  %1418 = load ptr, ptr %1415, align 8, !alias.scope !209
  %1419 = getelementptr i8, ptr %1418, i64 72
  %1420 = load ptr, ptr %1419, align 8, !alias.scope !209
  %result.i.i.i1419 = call { i64, i64 } %1420(ptr nocapture nofree nonnull readonly %1415) #5, !alias.scope !209
  %1421 = extractvalue { i64, i64 } %result.i.i.i1419, 0
  %1422 = extractvalue { i64, i64 } %result.i.i.i1419, 1
  %1423 = urem i64 20, %1422
  %1424 = icmp eq i64 %1423, 0
  %1425 = sub i64 %1422, %1423
  %1426 = select i1 %1424, i64 0, i64 %1425
  %1427 = add i64 %1421, 20
  %1428 = add i64 %1427, %1426
  %1429 = load ptr, ptr %1417, align 8, !alias.scope !209
  %1430 = getelementptr i8, ptr %1429, i64 72
  %1431 = load ptr, ptr %1430, align 8, !alias.scope !209
  %result.i1.i.i1420 = call { i64, i64 } %1431(ptr nocapture nofree nonnull readonly %1417) #5, !alias.scope !209
  %1432 = extractvalue { i64, i64 } %result.i1.i.i1420, 0
  %1433 = extractvalue { i64, i64 } %result.i1.i.i1420, 1
  %1434 = call i64 @llvm.umax.i64(i64 %1422, i64 %1433)
  %1435 = call i64 @llvm.umax.i64(i64 %1434, i64 8)
  %1436 = urem i64 %1428, %1433
  %1437 = icmp eq i64 %1436, 0
  %1438 = sub i64 %1433, %1436
  %1439 = select i1 %1437, i64 0, i64 %1438
  %1440 = add i64 %1432, %1428
  %1441 = add i64 %1440, %1439
  %1442 = urem i64 %1441, %1435
  %1443 = icmp eq i64 %1442, 0
  %1444 = sub i64 %1435, %1442
  %1445 = select i1 %1443, i64 0, i64 %1444
  %1446 = add i64 %1445, %1441
  %result.i83.i1421 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1446, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1415, ptr %result.i83.i1421, align 8
  %1447 = getelementptr inbounds i8, ptr %result.i83.i1421, i64 8
  store ptr %1417, ptr %1447, align 8
  %1448 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1421)
  %1449 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1450 = load ptr, ptr %1415, align 8
  %1451 = getelementptr i8, ptr %1450, i64 72
  %1452 = load ptr, ptr %1451, align 8
  %result.i.i118.i1422 = call { i64, i64 } %1452(ptr nocapture nofree nonnull readonly %1415) #5
  %1453 = extractvalue { i64, i64 } %result.i.i118.i1422, 1
  %1454 = urem i64 20, %1453
  %1455 = icmp eq i64 %1454, 0
  %reass.sub3815 = sub i64 %1453, %1454
  %1456 = add i64 %reass.sub3815, 20
  %1457 = select i1 %1455, i64 20, i64 %1456
  %1458 = getelementptr i8, ptr %result.i83.i1421, i64 %1457
  %1459 = getelementptr i8, ptr %1450, i64 64
  %1460 = load ptr, ptr %1459, align 8
  call void %1460({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1415, ptr nocapture nofree writeonly %1458) #1
  %1461 = load ptr, ptr %result.i83.i1421, align 8
  %1462 = load ptr, ptr %1461, align 8
  %1463 = getelementptr i8, ptr %1462, i64 72
  %1464 = load ptr, ptr %1463, align 8
  %result.i.i119.i1424 = call { i64, i64 } %1464(ptr nocapture nofree nonnull readonly %1461) #5
  %1465 = extractvalue { i64, i64 } %result.i.i119.i1424, 0
  %1466 = extractvalue { i64, i64 } %result.i.i119.i1424, 1
  %1467 = urem i64 20, %1466
  %1468 = icmp eq i64 %1467, 0
  %1469 = sub i64 %1466, %1467
  %1470 = select i1 %1468, i64 0, i64 %1469
  %1471 = add i64 %1465, 20
  %1472 = add i64 %1471, %1470
  %1473 = load ptr, ptr %1447, align 8
  %1474 = load ptr, ptr %1473, align 8
  %1475 = getelementptr i8, ptr %1474, i64 72
  %1476 = load ptr, ptr %1475, align 8
  %result.i1.i120.i1425 = call { i64, i64 } %1476(ptr nocapture nofree nonnull readonly %1473) #5
  %1477 = extractvalue { i64, i64 } %result.i1.i120.i1425, 1
  %1478 = urem i64 %1472, %1477
  %1479 = icmp eq i64 %1478, 0
  %1480 = sub i64 %1477, %1478
  %1481 = select i1 %1479, i64 0, i64 %1480
  %1482 = getelementptr i8, ptr %result.i83.i1421, i64 %1472
  %1483 = getelementptr i8, ptr %1482, i64 %1481
  %1484 = getelementptr i8, ptr %1474, i64 64
  %1485 = load ptr, ptr %1484, align 8
  call void %1485({ ptr, i160 } %1246, ptr nocapture nofree nonnull readonly %1473, ptr nocapture nofree writeonly %1483) #1
  %1486 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1487 = getelementptr inbounds i8, ptr %result.i83.i1421, i64 16
  store i32 %1248, ptr %1487, align 8
  store ptr @Entry, ptr %1385, align 8
  %1488 = ptrtoint ptr %result.i83.i1421 to i64
  store i64 %1488, ptr %1387, align 4
  %.sroa_idx28.i1426 = getelementptr i8, ptr %1385, i64 24
  store i32 10, ptr %.sroa_idx28.i1426, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit780

1489:                                             ; preds = %._crit_edge.i1414, %1359, %1390
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1490 = load i32, ptr %66, align 4
  %1491 = load i32, ptr %56, align 8
  %.not.i738 = icmp slt i32 %1490, %1491
  br i1 %.not.i738, label %._crit_edge.i740, label %1492

1492:                                             ; preds = %1489
  %1493 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1494 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1495 = load ptr, ptr %57, align 8
  %1496 = load ptr, ptr %58, align 8
  %1497 = shl i32 %1491, 1
  %spec.select.i1443 = call i32 @llvm.smax.i32(i32 %1497, i32 16)
  store i32 %spec.select.i1443, ptr %56, align 8
  %1498 = zext nneg i32 %spec.select.i1443 to i64
  %1499 = shl nuw nsw i64 %1498, 5
  %result.i.i1444 = call noalias ptr @bump_malloc_inner(i64 noundef %1499, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1444, ptr %57, align 8
  %result.i20.i1445 = call noalias ptr @bump_malloc_inner(i64 noundef %1499, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1445, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %1500 = icmp sgt i32 %1491, 0
  br i1 %1500, label %.lr.ph.i2197, label %._crit_edge.i740

.lr.ph.i2197:                                     ; preds = %1492, %._crit_edge.i2212
  %.060.i2210 = phi i32 [ %1589, %._crit_edge.i2212 ], [ 0, %1492 ]
  %1501 = zext nneg i32 %.060.i2210 to i64
  %1502 = shl nuw nsw i64 %1501, 5
  %1503 = getelementptr i8, ptr %1495, i64 %1502
  %1504 = load ptr, ptr %1503, align 8
  %1505 = icmp ne ptr %1504, @nil_typ
  %1506 = icmp ne ptr %1504, null
  %.not16.i2211 = and i1 %1505, %1506
  br i1 %.not16.i2211, label %1507, label %._crit_edge.i2212

1507:                                             ; preds = %.lr.ph.i2197
  %1508 = getelementptr i8, ptr %1503, i64 8
  %1509 = load <2 x i64>, ptr %1508, align 4
  %hash_coef_ptr.i.i18.i2214 = getelementptr i8, ptr %1504, i64 8
  %tbl_size_ptr.i.i19.i2215 = getelementptr i8, ptr %1504, i64 16
  %offset_tbl_ptr.i.i20.i2216 = getelementptr i8, ptr %1504, i64 40
  %1510 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i2955 = load i64, ptr %hash_coef_ptr.i.i18.i2214, align 4, !noalias !22
  %tbl_size.i.i100.i2956 = load i64, ptr %tbl_size_ptr.i.i19.i2215, align 4, !noalias !22
  %offset_tbl.i.i101.i2957 = load ptr, ptr %offset_tbl_ptr.i.i20.i2216, align 8, !noalias !22
  %product.i.i.i102.i2958 = mul i64 %hash_coef.i.i99.i2955, 4015701072841558310
  %shifted.i.i.i103.i2959 = lshr i64 %product.i.i.i102.i2958, 32
  %xored.i.i.i104.i2960 = xor i64 %shifted.i.i.i103.i2959, %product.i.i.i102.i2958
  %hash.i.i.i105.i2961 = and i64 %xored.i.i.i104.i2960, %tbl_size.i.i100.i2956
  %offset_ptr.i.i106.i2962 = getelementptr i32, ptr %offset_tbl.i.i101.i2957, i64 %hash.i.i.i105.i2961
  %offset.i.i121.i2963 = load i32, ptr %offset_ptr.i.i106.i2962, align 4, !noalias !212
  %1511 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1512 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1513 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1514

1514:                                             ; preds = %.cont.cont.i2984, %1507
  %.0566.i2964 = phi i32 [ 0, %1507 ], [ %1518, %.cont.cont.i2984 ]
  %.070565.i2965 = phi i1 [ true, %1507 ], [ %1580, %.cont.cont.i2984 ]
  %.sroa.0.0564.i2966 = phi ptr [ %1504, %1507 ], [ %vptr.i142.sroa.speculated.i2987, %.cont.cont.i2984 ]
  %.sroa.17.0561.i2969 = phi i32 [ %offset.i.i121.i2963, %1507 ], [ %offset.i.i154.i3001, %.cont.cont.i2984 ]
  %1515 = phi <2 x i64> [ %1509, %1507 ], [ %1579, %.cont.cont.i2984 ]
  %1516 = extractelement <2 x i64> %1515, i64 1
  %.sroa.12.0562.i2968 = inttoptr i64 %1516 to ptr
  %1517 = extractelement <2 x i64> %1515, i64 0
  %.sroa.6.0563.i2967 = inttoptr i64 %1517 to ptr
  %1518 = add nuw nsw i32 %.0566.i2964, 1
  %1519 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2966, 0
  %1520 = insertvalue { ptr, ptr, ptr, i32 } %1519, ptr %.sroa.6.0563.i2967, 1
  %1521 = insertvalue { ptr, ptr, ptr, i32 } %1520, ptr %.sroa.12.0562.i2968, 2
  %1522 = insertvalue { ptr, ptr, ptr, i32 } %1521, i32 %.sroa.17.0561.i2969, 3
  %1523 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2966)
  %1524 = sext i32 %.sroa.17.0561.i2969 to i64
  %1525 = getelementptr ptr, ptr %.sroa.0.0564.i2966, i64 %1524
  %1526 = getelementptr i8, ptr %1525, i64 64
  %1527 = load ptr, ptr %1526, align 8
  %result.i125.i2970 = call ptr %1527({ ptr, ptr, ptr, i32 } %1522, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1528 = call i32 %result.i125.i2970({ ptr, ptr, ptr, i32 } %1522, { ptr, ptr, ptr, i32 } %1522, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2965, label %1529, label %1545

1529:                                             ; preds = %1514
  %1530 = load i32, ptr %56, align 8
  %1531 = add i32 %1530, -1
  %1532 = and i32 %1531, %1528
  %1533 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1534 = load ptr, ptr %57, align 8
  %1535 = sext i32 %1532 to i64
  %1536 = shl nsw i64 %1535, 5
  %1537 = getelementptr i8, ptr %1534, i64 %1536
  %1538 = load ptr, ptr %1537, align 8
  %1539 = getelementptr i8, ptr %1537, i64 8
  %1540 = load i160, ptr %1539, align 4
  store ptr %.sroa.0.0564.i2966, ptr %1537, align 8
  store i64 %1517, ptr %1539, align 4
  %.sroa_idx157.i3013 = getelementptr i8, ptr %1537, i64 16
  store i64 %1516, ptr %.sroa_idx157.i3013, align 4
  %.sroa_idx158.i3014 = getelementptr i8, ptr %1537, i64 24
  store i32 %.sroa.17.0561.i2969, ptr %.sroa_idx158.i3014, align 4
  %1541 = icmp ne ptr %1538, @nil_typ
  %1542 = icmp ne ptr %1538, null
  %.not92.i3015 = and i1 %1541, %1542
  %extract.i3017 = lshr i160 %1540, 64
  %1543 = insertelement <2 x i160> poison, i160 %1540, i64 0
  %1544 = insertelement <2 x i160> %1543, i160 %extract.i3017, i64 1
  br i1 %.not92.i3015, label %.cont.cont.i2984, label %1584

1545:                                             ; preds = %1514
  %1546 = add i32 %1528, 2127912214
  %1547 = shl i32 %1528, 12
  %1548 = add i32 %1546, %1547
  %1549 = ashr i32 %1548, 19
  %1550 = xor i32 %1548, %1549
  %1551 = xor i32 %1550, -949894596
  %1552 = add i32 %1551, 374761393
  %1553 = shl i32 %1551, 5
  %1554 = add i32 %1552, %1553
  %1555 = add i32 %1554, -744332180
  %1556 = shl i32 %1554, 9
  %1557 = xor i32 %1555, %1556
  %1558 = add i32 %1557, -42973499
  %1559 = shl i32 %1557, 3
  %1560 = add i32 %1558, %1559
  %1561 = ashr i32 %1560, 16
  %1562 = xor i32 %1560, %1561
  %1563 = xor i32 %1562, -1252372727
  %1564 = load i32, ptr %56, align 8
  %1565 = add i32 %1564, -1
  %1566 = and i32 %1565, %1563
  %1567 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1568 = load ptr, ptr %58, align 8
  %1569 = sext i32 %1566 to i64
  %1570 = shl nsw i64 %1569, 5
  %1571 = getelementptr i8, ptr %1568, i64 %1570
  %1572 = load ptr, ptr %1571, align 8
  %1573 = getelementptr i8, ptr %1571, i64 8
  %1574 = load i160, ptr %1573, align 4
  store ptr %.sroa.0.0564.i2966, ptr %1571, align 8
  store i64 %1517, ptr %1573, align 4
  %.sroa_idx161.i2974 = getelementptr i8, ptr %1571, i64 16
  store i64 %1516, ptr %.sroa_idx161.i2974, align 4
  %.sroa_idx162.i2975 = getelementptr i8, ptr %1571, i64 24
  store i32 %.sroa.17.0561.i2969, ptr %.sroa_idx162.i2975, align 4
  %1575 = icmp ne ptr %1572, @nil_typ
  %1576 = icmp ne ptr %1572, null
  %.not90.i2976 = and i1 %1575, %1576
  %extract607.i2978 = lshr i160 %1574, 64
  %1577 = insertelement <2 x i160> poison, i160 %1574, i64 0
  %1578 = insertelement <2 x i160> %1577, i160 %extract607.i2978, i64 1
  br i1 %.not90.i2976, label %.cont.cont.i2984, label %1584

.cont.cont.i2984:                                 ; preds = %1545, %1529
  %vptr.i142.sroa.speculated.i2987 = phi ptr [ %1538, %1529 ], [ %1572, %1545 ]
  %.in3823 = phi <2 x i160> [ %1544, %1529 ], [ %1578, %1545 ]
  %1579 = trunc <2 x i160> %.in3823 to <2 x i64>
  %1580 = xor i1 %.070565.i2965, true
  %hash_coef_ptr.i.i143.i2990 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2987, i64 8
  %tbl_size_ptr.i.i144.i2991 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2987, i64 16
  %offset_tbl_ptr.i.i145.i2992 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2987, i64 40
  %hash_coef.i.i146.i2993 = load i64, ptr %hash_coef_ptr.i.i143.i2990, align 4
  %tbl_size.i.i147.i2994 = load i64, ptr %tbl_size_ptr.i.i144.i2991, align 4
  %offset_tbl.i.i148.i2995 = load ptr, ptr %offset_tbl_ptr.i.i145.i2992, align 8
  %product.i.i.i149.i2996 = mul i64 %hash_coef.i.i146.i2993, 4015701072841558310
  %shifted.i.i.i150.i2997 = lshr i64 %product.i.i.i149.i2996, 32
  %xored.i.i.i151.i2998 = xor i64 %shifted.i.i.i150.i2997, %product.i.i.i149.i2996
  %hash.i.i.i152.i2999 = and i64 %xored.i.i.i151.i2998, %tbl_size.i.i147.i2994
  %offset_ptr.i.i153.i3000 = getelementptr i32, ptr %offset_tbl.i.i148.i2995, i64 %hash.i.i.i152.i2999
  %offset.i.i154.i3001 = load i32, ptr %offset_ptr.i.i153.i3000, align 4
  %1581 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1582 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1583 = icmp ult i32 %.0566.i2964, 99
  br i1 %1583, label %1514, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3019

1584:                                             ; preds = %1545, %1529
  %1585 = phi ptr [ %14, %1545 ], [ %13, %1529 ]
  %1586 = load i32, ptr %66, align 4
  store i32 %1586, ptr %1585, align 4
  %1587 = add i32 %1586, 1
  %1588 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1587, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3019

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3019: ; preds = %.cont.cont.i2984, %1584
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i2212

._crit_edge.i2212:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3019, %.lr.ph.i2197
  %1589 = add nuw nsw i32 %.060.i2210, 1
  %1590 = icmp slt i32 %1589, %1491
  br i1 %1590, label %.lr.ph.i2197, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2230

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2230: ; preds = %._crit_edge.i2212, %._crit_edge.i2248
  %.060.i2246 = phi i32 [ %1679, %._crit_edge.i2248 ], [ 0, %._crit_edge.i2212 ]
  %1591 = zext nneg i32 %.060.i2246 to i64
  %1592 = shl nuw nsw i64 %1591, 5
  %1593 = getelementptr i8, ptr %1496, i64 %1592
  %1594 = load ptr, ptr %1593, align 8
  %1595 = icmp ne ptr %1594, @nil_typ
  %1596 = icmp ne ptr %1594, null
  %.not16.i2247 = and i1 %1595, %1596
  br i1 %.not16.i2247, label %1597, label %._crit_edge.i2248

1597:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2230
  %1598 = getelementptr i8, ptr %1593, i64 8
  %1599 = load <2 x i64>, ptr %1598, align 4
  %hash_coef_ptr.i.i18.i2250 = getelementptr i8, ptr %1594, i64 8
  %tbl_size_ptr.i.i19.i2251 = getelementptr i8, ptr %1594, i64 16
  %offset_tbl_ptr.i.i20.i2252 = getelementptr i8, ptr %1594, i64 40
  %1600 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i3037 = load i64, ptr %hash_coef_ptr.i.i18.i2250, align 4, !noalias !22
  %tbl_size.i.i100.i3038 = load i64, ptr %tbl_size_ptr.i.i19.i2251, align 4, !noalias !22
  %offset_tbl.i.i101.i3039 = load ptr, ptr %offset_tbl_ptr.i.i20.i2252, align 8, !noalias !22
  %product.i.i.i102.i3040 = mul i64 %hash_coef.i.i99.i3037, 4015701072841558310
  %shifted.i.i.i103.i3041 = lshr i64 %product.i.i.i102.i3040, 32
  %xored.i.i.i104.i3042 = xor i64 %shifted.i.i.i103.i3041, %product.i.i.i102.i3040
  %hash.i.i.i105.i3043 = and i64 %xored.i.i.i104.i3042, %tbl_size.i.i100.i3038
  %offset_ptr.i.i106.i3044 = getelementptr i32, ptr %offset_tbl.i.i101.i3039, i64 %hash.i.i.i105.i3043
  %offset.i.i121.i3045 = load i32, ptr %offset_ptr.i.i106.i3044, align 4, !noalias !215
  %1601 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1602 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1603 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1604

1604:                                             ; preds = %.cont.cont.i3066, %1597
  %.0566.i3046 = phi i32 [ 0, %1597 ], [ %1608, %.cont.cont.i3066 ]
  %.070565.i3047 = phi i1 [ true, %1597 ], [ %1670, %.cont.cont.i3066 ]
  %.sroa.0.0564.i3048 = phi ptr [ %1594, %1597 ], [ %vptr.i142.sroa.speculated.i3069, %.cont.cont.i3066 ]
  %.sroa.17.0561.i3051 = phi i32 [ %offset.i.i121.i3045, %1597 ], [ %offset.i.i154.i3083, %.cont.cont.i3066 ]
  %1605 = phi <2 x i64> [ %1599, %1597 ], [ %1669, %.cont.cont.i3066 ]
  %1606 = extractelement <2 x i64> %1605, i64 1
  %.sroa.12.0562.i3050 = inttoptr i64 %1606 to ptr
  %1607 = extractelement <2 x i64> %1605, i64 0
  %.sroa.6.0563.i3049 = inttoptr i64 %1607 to ptr
  %1608 = add nuw nsw i32 %.0566.i3046, 1
  %1609 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3048, 0
  %1610 = insertvalue { ptr, ptr, ptr, i32 } %1609, ptr %.sroa.6.0563.i3049, 1
  %1611 = insertvalue { ptr, ptr, ptr, i32 } %1610, ptr %.sroa.12.0562.i3050, 2
  %1612 = insertvalue { ptr, ptr, ptr, i32 } %1611, i32 %.sroa.17.0561.i3051, 3
  %1613 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3048)
  %1614 = sext i32 %.sroa.17.0561.i3051 to i64
  %1615 = getelementptr ptr, ptr %.sroa.0.0564.i3048, i64 %1614
  %1616 = getelementptr i8, ptr %1615, i64 64
  %1617 = load ptr, ptr %1616, align 8
  %result.i125.i3052 = call ptr %1617({ ptr, ptr, ptr, i32 } %1612, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1618 = call i32 %result.i125.i3052({ ptr, ptr, ptr, i32 } %1612, { ptr, ptr, ptr, i32 } %1612, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3047, label %1619, label %1635

1619:                                             ; preds = %1604
  %1620 = load i32, ptr %56, align 8
  %1621 = add i32 %1620, -1
  %1622 = and i32 %1621, %1618
  %1623 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1624 = load ptr, ptr %57, align 8
  %1625 = sext i32 %1622 to i64
  %1626 = shl nsw i64 %1625, 5
  %1627 = getelementptr i8, ptr %1624, i64 %1626
  %1628 = load ptr, ptr %1627, align 8
  %1629 = getelementptr i8, ptr %1627, i64 8
  %1630 = load i160, ptr %1629, align 4
  store ptr %.sroa.0.0564.i3048, ptr %1627, align 8
  store i64 %1607, ptr %1629, align 4
  %.sroa_idx157.i3095 = getelementptr i8, ptr %1627, i64 16
  store i64 %1606, ptr %.sroa_idx157.i3095, align 4
  %.sroa_idx158.i3096 = getelementptr i8, ptr %1627, i64 24
  store i32 %.sroa.17.0561.i3051, ptr %.sroa_idx158.i3096, align 4
  %1631 = icmp ne ptr %1628, @nil_typ
  %1632 = icmp ne ptr %1628, null
  %.not92.i3097 = and i1 %1631, %1632
  %extract.i3099 = lshr i160 %1630, 64
  %1633 = insertelement <2 x i160> poison, i160 %1630, i64 0
  %1634 = insertelement <2 x i160> %1633, i160 %extract.i3099, i64 1
  br i1 %.not92.i3097, label %.cont.cont.i3066, label %1674

1635:                                             ; preds = %1604
  %1636 = add i32 %1618, 2127912214
  %1637 = shl i32 %1618, 12
  %1638 = add i32 %1636, %1637
  %1639 = ashr i32 %1638, 19
  %1640 = xor i32 %1638, %1639
  %1641 = xor i32 %1640, -949894596
  %1642 = add i32 %1641, 374761393
  %1643 = shl i32 %1641, 5
  %1644 = add i32 %1642, %1643
  %1645 = add i32 %1644, -744332180
  %1646 = shl i32 %1644, 9
  %1647 = xor i32 %1645, %1646
  %1648 = add i32 %1647, -42973499
  %1649 = shl i32 %1647, 3
  %1650 = add i32 %1648, %1649
  %1651 = ashr i32 %1650, 16
  %1652 = xor i32 %1650, %1651
  %1653 = xor i32 %1652, -1252372727
  %1654 = load i32, ptr %56, align 8
  %1655 = add i32 %1654, -1
  %1656 = and i32 %1655, %1653
  %1657 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1658 = load ptr, ptr %58, align 8
  %1659 = sext i32 %1656 to i64
  %1660 = shl nsw i64 %1659, 5
  %1661 = getelementptr i8, ptr %1658, i64 %1660
  %1662 = load ptr, ptr %1661, align 8
  %1663 = getelementptr i8, ptr %1661, i64 8
  %1664 = load i160, ptr %1663, align 4
  store ptr %.sroa.0.0564.i3048, ptr %1661, align 8
  store i64 %1607, ptr %1663, align 4
  %.sroa_idx161.i3056 = getelementptr i8, ptr %1661, i64 16
  store i64 %1606, ptr %.sroa_idx161.i3056, align 4
  %.sroa_idx162.i3057 = getelementptr i8, ptr %1661, i64 24
  store i32 %.sroa.17.0561.i3051, ptr %.sroa_idx162.i3057, align 4
  %1665 = icmp ne ptr %1662, @nil_typ
  %1666 = icmp ne ptr %1662, null
  %.not90.i3058 = and i1 %1665, %1666
  %extract607.i3060 = lshr i160 %1664, 64
  %1667 = insertelement <2 x i160> poison, i160 %1664, i64 0
  %1668 = insertelement <2 x i160> %1667, i160 %extract607.i3060, i64 1
  br i1 %.not90.i3058, label %.cont.cont.i3066, label %1674

.cont.cont.i3066:                                 ; preds = %1635, %1619
  %vptr.i142.sroa.speculated.i3069 = phi ptr [ %1628, %1619 ], [ %1662, %1635 ]
  %.in3824 = phi <2 x i160> [ %1634, %1619 ], [ %1668, %1635 ]
  %1669 = trunc <2 x i160> %.in3824 to <2 x i64>
  %1670 = xor i1 %.070565.i3047, true
  %hash_coef_ptr.i.i143.i3072 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3069, i64 8
  %tbl_size_ptr.i.i144.i3073 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3069, i64 16
  %offset_tbl_ptr.i.i145.i3074 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3069, i64 40
  %hash_coef.i.i146.i3075 = load i64, ptr %hash_coef_ptr.i.i143.i3072, align 4
  %tbl_size.i.i147.i3076 = load i64, ptr %tbl_size_ptr.i.i144.i3073, align 4
  %offset_tbl.i.i148.i3077 = load ptr, ptr %offset_tbl_ptr.i.i145.i3074, align 8
  %product.i.i.i149.i3078 = mul i64 %hash_coef.i.i146.i3075, 4015701072841558310
  %shifted.i.i.i150.i3079 = lshr i64 %product.i.i.i149.i3078, 32
  %xored.i.i.i151.i3080 = xor i64 %shifted.i.i.i150.i3079, %product.i.i.i149.i3078
  %hash.i.i.i152.i3081 = and i64 %xored.i.i.i151.i3080, %tbl_size.i.i147.i3076
  %offset_ptr.i.i153.i3082 = getelementptr i32, ptr %offset_tbl.i.i148.i3077, i64 %hash.i.i.i152.i3081
  %offset.i.i154.i3083 = load i32, ptr %offset_ptr.i.i153.i3082, align 4
  %1671 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1673 = icmp ult i32 %.0566.i3046, 99
  br i1 %1673, label %1604, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3101

1674:                                             ; preds = %1635, %1619
  %1675 = phi ptr [ %12, %1635 ], [ %11, %1619 ]
  %1676 = load i32, ptr %66, align 4
  store i32 %1676, ptr %1675, align 4
  %1677 = add i32 %1676, 1
  %1678 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1677, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3101

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3101: ; preds = %.cont.cont.i3066, %1674
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %._crit_edge.i2248

._crit_edge.i2248:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3101, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2230
  %1679 = add nuw nsw i32 %.060.i2246, 1
  %1680 = icmp slt i32 %1679, %1491
  br i1 %1680, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2230, label %._crit_edge.i740

._crit_edge.i740:                                 ; preds = %._crit_edge.i2248, %1492, %1489
  %1681 = load ptr, ptr %result.i326, align 8
  %1682 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1683 = load ptr, ptr %49, align 8
  %1684 = load ptr, ptr %1681, align 8
  %1685 = getelementptr i8, ptr %1684, i64 72
  %1686 = load ptr, ptr %1685, align 8
  %result.i.i.i743 = call { i64, i64 } %1686(ptr nocapture nofree nonnull readonly %1681) #5
  %1687 = extractvalue { i64, i64 } %result.i.i.i743, 0
  %1688 = extractvalue { i64, i64 } %result.i.i.i743, 1
  %1689 = urem i64 20, %1688
  %1690 = icmp eq i64 %1689, 0
  %1691 = sub i64 %1688, %1689
  %1692 = select i1 %1690, i64 0, i64 %1691
  %1693 = add i64 %1687, 20
  %1694 = add i64 %1693, %1692
  %1695 = load ptr, ptr %1683, align 8
  %1696 = getelementptr i8, ptr %1695, i64 72
  %1697 = load ptr, ptr %1696, align 8
  %result.i1.i.i744 = call { i64, i64 } %1697(ptr nocapture nofree nonnull readonly %1683) #5
  %1698 = extractvalue { i64, i64 } %result.i1.i.i744, 0
  %1699 = extractvalue { i64, i64 } %result.i1.i.i744, 1
  %1700 = call i64 @llvm.umax.i64(i64 %1688, i64 %1699)
  %1701 = call i64 @llvm.umax.i64(i64 %1700, i64 8)
  %1702 = urem i64 %1694, %1699
  %1703 = icmp eq i64 %1702, 0
  %1704 = sub i64 %1699, %1702
  %1705 = select i1 %1703, i64 0, i64 %1704
  %1706 = add i64 %1698, %1694
  %1707 = add i64 %1706, %1705
  %1708 = urem i64 %1707, %1701
  %1709 = icmp eq i64 %1708, 0
  %1710 = sub i64 %1701, %1708
  %1711 = select i1 %1709, i64 0, i64 %1710
  %1712 = add i64 %1711, %1707
  %result.i90.i745 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1712, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1681, ptr %result.i90.i745, align 8
  %1713 = getelementptr inbounds i8, ptr %result.i90.i745, i64 8
  store ptr %1683, ptr %1713, align 8
  %1714 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i745)
  %1715 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1716 = load ptr, ptr %1681, align 8
  %1717 = getelementptr i8, ptr %1716, i64 72
  %1718 = load ptr, ptr %1717, align 8
  %result.i.i196.i746 = call { i64, i64 } %1718(ptr nocapture nofree nonnull readonly %1681) #5
  %1719 = extractvalue { i64, i64 } %result.i.i196.i746, 1
  %1720 = urem i64 20, %1719
  %1721 = icmp eq i64 %1720, 0
  %reass.sub3814 = sub i64 %1719, %1720
  %1722 = add i64 %reass.sub3814, 20
  %1723 = select i1 %1721, i64 20, i64 %1722
  %1724 = getelementptr i8, ptr %result.i90.i745, i64 %1723
  %1725 = getelementptr i8, ptr %1716, i64 64
  %1726 = load ptr, ptr %1725, align 8
  call void %1726({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1681, ptr nocapture nofree writeonly %1724) #1
  %1727 = load ptr, ptr %result.i90.i745, align 8
  %1728 = load ptr, ptr %1727, align 8
  %1729 = getelementptr i8, ptr %1728, i64 72
  %1730 = load ptr, ptr %1729, align 8
  %result.i.i197.i748 = call { i64, i64 } %1730(ptr nocapture nofree nonnull readonly %1727) #5
  %1731 = extractvalue { i64, i64 } %result.i.i197.i748, 0
  %1732 = extractvalue { i64, i64 } %result.i.i197.i748, 1
  %1733 = urem i64 20, %1732
  %1734 = icmp eq i64 %1733, 0
  %1735 = sub i64 %1732, %1733
  %1736 = select i1 %1734, i64 0, i64 %1735
  %1737 = add i64 %1731, 20
  %1738 = add i64 %1737, %1736
  %1739 = load ptr, ptr %1713, align 8
  %1740 = load ptr, ptr %1739, align 8
  %1741 = getelementptr i8, ptr %1740, i64 72
  %1742 = load ptr, ptr %1741, align 8
  %result.i1.i198.i749 = call { i64, i64 } %1742(ptr nocapture nofree nonnull readonly %1739) #5
  %1743 = extractvalue { i64, i64 } %result.i1.i198.i749, 1
  %1744 = urem i64 %1738, %1743
  %1745 = icmp eq i64 %1744, 0
  %1746 = sub i64 %1743, %1744
  %1747 = select i1 %1745, i64 0, i64 %1746
  %1748 = getelementptr i8, ptr %result.i90.i745, i64 %1738
  %1749 = getelementptr i8, ptr %1748, i64 %1747
  %1750 = getelementptr i8, ptr %1740, i64 64
  %1751 = load ptr, ptr %1750, align 8
  call void %1751({ ptr, i160 } %1246, ptr nocapture nofree nonnull readonly %1739, ptr nocapture nofree writeonly %1749) #1
  %1752 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1753 = getelementptr inbounds i8, ptr %result.i90.i745, i64 16
  store i32 %1248, ptr %1753, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %30)
  %1754 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1755 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1756 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1757

1757:                                             ; preds = %.cont.cont.i1498, %._crit_edge.i740
  %.0566.i1478 = phi i32 [ 0, %._crit_edge.i740 ], [ %1758, %.cont.cont.i1498 ]
  %.070565.i1479 = phi i1 [ true, %._crit_edge.i740 ], [ %1824, %.cont.cont.i1498 ]
  %.sroa.0.0564.i1480 = phi ptr [ @Entry, %._crit_edge.i740 ], [ %vptr.i142.sroa.speculated.i1501, %.cont.cont.i1498 ]
  %.sroa.6.0563.i1481 = phi ptr [ %result.i90.i745, %._crit_edge.i740 ], [ %spec.select539.i1503, %.cont.cont.i1498 ]
  %.sroa.12.0562.i1482 = phi ptr [ undef, %._crit_edge.i740 ], [ %spec.select.i1502, %.cont.cont.i1498 ]
  %.sroa.17.0561.i1483 = phi i32 [ 10, %._crit_edge.i740 ], [ %offset.i.i154.i1515, %.cont.cont.i1498 ]
  %1758 = add nuw nsw i32 %.0566.i1478, 1
  %1759 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1480, 0
  %1760 = insertvalue { ptr, ptr, ptr, i32 } %1759, ptr %.sroa.6.0563.i1481, 1
  %1761 = insertvalue { ptr, ptr, ptr, i32 } %1760, ptr %.sroa.12.0562.i1482, 2
  %1762 = insertvalue { ptr, ptr, ptr, i32 } %1761, i32 %.sroa.17.0561.i1483, 3
  %1763 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1480)
  %1764 = sext i32 %.sroa.17.0561.i1483 to i64
  %1765 = getelementptr ptr, ptr %.sroa.0.0564.i1480, i64 %1764
  %1766 = getelementptr i8, ptr %1765, i64 64
  %1767 = load ptr, ptr %1766, align 8
  %result.i125.i1484 = call ptr %1767({ ptr, ptr, ptr, i32 } %1762, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1768 = call i32 %result.i125.i1484({ ptr, ptr, ptr, i32 } %1762, { ptr, ptr, ptr, i32 } %1762, ptr nonnull align 8 %2) #7
  %1769 = ptrtoint ptr %.sroa.6.0563.i1481 to i64
  %1770 = ptrtoint ptr %.sroa.12.0562.i1482 to i64
  br i1 %.070565.i1479, label %1771, label %1787

1771:                                             ; preds = %1757
  %1772 = load i32, ptr %56, align 8
  %1773 = add i32 %1772, -1
  %1774 = and i32 %1773, %1768
  %1775 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1776 = load ptr, ptr %57, align 8
  %1777 = sext i32 %1774 to i64
  %1778 = shl nsw i64 %1777, 5
  %1779 = getelementptr i8, ptr %1776, i64 %1778
  %1780 = load ptr, ptr %1779, align 8
  %1781 = getelementptr i8, ptr %1779, i64 8
  %1782 = load i160, ptr %1781, align 4
  store ptr %.sroa.0.0564.i1480, ptr %1779, align 8
  store i64 %1769, ptr %1781, align 4
  %.sroa_idx157.i1527 = getelementptr i8, ptr %1779, i64 16
  store i64 %1770, ptr %.sroa_idx157.i1527, align 4
  %.sroa_idx158.i1528 = getelementptr i8, ptr %1779, i64 24
  store i32 %.sroa.17.0561.i1483, ptr %.sroa_idx158.i1528, align 4
  %1783 = icmp ne ptr %1780, @nil_typ
  %1784 = icmp ne ptr %1780, null
  %.not92.i1529 = and i1 %1783, %1784
  %extract.i1531 = lshr i160 %1782, 64
  %1785 = insertelement <2 x i160> poison, i160 %1782, i64 0
  %1786 = insertelement <2 x i160> %1785, i160 %extract.i1531, i64 1
  br i1 %.not92.i1529, label %.cont.cont.i1498, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1533.thread

1787:                                             ; preds = %1757
  %1788 = add i32 %1768, 2127912214
  %1789 = shl i32 %1768, 12
  %1790 = add i32 %1788, %1789
  %1791 = ashr i32 %1790, 19
  %1792 = xor i32 %1790, %1791
  %1793 = xor i32 %1792, -949894596
  %1794 = add i32 %1793, 374761393
  %1795 = shl i32 %1793, 5
  %1796 = add i32 %1794, %1795
  %1797 = add i32 %1796, -744332180
  %1798 = shl i32 %1796, 9
  %1799 = xor i32 %1797, %1798
  %1800 = add i32 %1799, -42973499
  %1801 = shl i32 %1799, 3
  %1802 = add i32 %1800, %1801
  %1803 = ashr i32 %1802, 16
  %1804 = xor i32 %1802, %1803
  %1805 = xor i32 %1804, -1252372727
  %1806 = load i32, ptr %56, align 8
  %1807 = add i32 %1806, -1
  %1808 = and i32 %1807, %1805
  %1809 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1810 = load ptr, ptr %58, align 8
  %1811 = sext i32 %1808 to i64
  %1812 = shl nsw i64 %1811, 5
  %1813 = getelementptr i8, ptr %1810, i64 %1812
  %1814 = load ptr, ptr %1813, align 8
  %1815 = getelementptr i8, ptr %1813, i64 8
  %1816 = load i160, ptr %1815, align 4
  store ptr %.sroa.0.0564.i1480, ptr %1813, align 8
  store i64 %1769, ptr %1815, align 4
  %.sroa_idx161.i1488 = getelementptr i8, ptr %1813, i64 16
  store i64 %1770, ptr %.sroa_idx161.i1488, align 4
  %.sroa_idx162.i1489 = getelementptr i8, ptr %1813, i64 24
  store i32 %.sroa.17.0561.i1483, ptr %.sroa_idx162.i1489, align 4
  %1817 = icmp ne ptr %1814, @nil_typ
  %1818 = icmp ne ptr %1814, null
  %.not90.i1490 = and i1 %1817, %1818
  %extract607.i1492 = lshr i160 %1816, 64
  %1819 = insertelement <2 x i160> poison, i160 %1816, i64 0
  %1820 = insertelement <2 x i160> %1819, i160 %extract607.i1492, i64 1
  br i1 %.not90.i1490, label %.cont.cont.i1498, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1533.thread

.cont.cont.i1498:                                 ; preds = %1787, %1771
  %vptr.i142.sroa.speculated.i1501 = phi ptr [ %1780, %1771 ], [ %1814, %1787 ]
  %.in3825 = phi <2 x i160> [ %1786, %1771 ], [ %1820, %1787 ]
  %1821 = trunc <2 x i160> %.in3825 to <2 x i64>
  %1822 = extractelement <2 x i64> %1821, i64 1
  %spec.select.i1502 = inttoptr i64 %1822 to ptr
  %1823 = extractelement <2 x i64> %1821, i64 0
  %spec.select539.i1503 = inttoptr i64 %1823 to ptr
  %1824 = xor i1 %.070565.i1479, true
  %hash_coef_ptr.i.i143.i1504 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1501, i64 8
  %tbl_size_ptr.i.i144.i1505 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1501, i64 16
  %offset_tbl_ptr.i.i145.i1506 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1501, i64 40
  %hash_coef.i.i146.i1507 = load i64, ptr %hash_coef_ptr.i.i143.i1504, align 4
  %tbl_size.i.i147.i1508 = load i64, ptr %tbl_size_ptr.i.i144.i1505, align 4
  %offset_tbl.i.i148.i1509 = load ptr, ptr %offset_tbl_ptr.i.i145.i1506, align 8
  %product.i.i.i149.i1510 = mul i64 %hash_coef.i.i146.i1507, 4015701072841558310
  %shifted.i.i.i150.i1511 = lshr i64 %product.i.i.i149.i1510, 32
  %xored.i.i.i151.i1512 = xor i64 %shifted.i.i.i150.i1511, %product.i.i.i149.i1510
  %hash.i.i.i152.i1513 = and i64 %xored.i.i.i151.i1512, %tbl_size.i.i147.i1508
  %offset_ptr.i.i153.i1514 = getelementptr i32, ptr %offset_tbl.i.i148.i1509, i64 %hash.i.i.i152.i1513
  %offset.i.i154.i1515 = load i32, ptr %offset_ptr.i.i153.i1514, align 4
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1826 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1827 = icmp ult i32 %.0566.i1478, 99
  br i1 %1827, label %1757, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1533

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1533.thread: ; preds = %1771, %1787
  %1828 = phi ptr [ %30, %1787 ], [ %29, %1771 ]
  %1829 = load i32, ptr %66, align 4
  store i32 %1829, ptr %1828, align 4
  %1830 = add i32 %1829, 1
  %1831 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1830, ptr %66, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  br label %CuckooMap_insert_keyK_valueV.exit780

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1533: ; preds = %.cont.cont.i1498
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  %1832 = icmp eq ptr %vptr.i142.sroa.speculated.i1501, null
  br i1 %1832, label %CuckooMap_insert_keyK_valueV.exit780, label %1833

1833:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1533
  %1834 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1835 = load ptr, ptr %57, align 8
  %1836 = load ptr, ptr %58, align 8
  %1837 = load i32, ptr %56, align 8
  %1838 = shl i32 %1837, 1
  %spec.select.i1549 = call i32 @llvm.smax.i32(i32 %1838, i32 16)
  store i32 %spec.select.i1549, ptr %56, align 8
  %1839 = zext nneg i32 %spec.select.i1549 to i64
  %1840 = shl nuw nsw i64 %1839, 5
  %result.i.i1550 = call noalias ptr @bump_malloc_inner(i64 noundef %1840, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1550, ptr %57, align 8
  %result.i20.i1551 = call noalias ptr @bump_malloc_inner(i64 noundef %1840, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1551, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %1841 = icmp sgt i32 %1837, 0
  br i1 %1841, label %.lr.ph.i2296, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365

.lr.ph.i2296:                                     ; preds = %1833, %._crit_edge.i2311
  %.060.i2309 = phi i32 [ %1930, %._crit_edge.i2311 ], [ 0, %1833 ]
  %1842 = zext nneg i32 %.060.i2309 to i64
  %1843 = shl nuw nsw i64 %1842, 5
  %1844 = getelementptr i8, ptr %1835, i64 %1843
  %1845 = load ptr, ptr %1844, align 8
  %1846 = icmp ne ptr %1845, @nil_typ
  %1847 = icmp ne ptr %1845, null
  %.not16.i2310 = and i1 %1846, %1847
  br i1 %.not16.i2310, label %1848, label %._crit_edge.i2311

1848:                                             ; preds = %.lr.ph.i2296
  %1849 = getelementptr i8, ptr %1844, i64 8
  %1850 = load <2 x i64>, ptr %1849, align 4
  %hash_coef_ptr.i.i18.i2313 = getelementptr i8, ptr %1845, i64 8
  %tbl_size_ptr.i.i19.i2314 = getelementptr i8, ptr %1845, i64 16
  %offset_tbl_ptr.i.i20.i2315 = getelementptr i8, ptr %1845, i64 40
  %1851 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i3119 = load i64, ptr %hash_coef_ptr.i.i18.i2313, align 4, !noalias !22
  %tbl_size.i.i100.i3120 = load i64, ptr %tbl_size_ptr.i.i19.i2314, align 4, !noalias !22
  %offset_tbl.i.i101.i3121 = load ptr, ptr %offset_tbl_ptr.i.i20.i2315, align 8, !noalias !22
  %product.i.i.i102.i3122 = mul i64 %hash_coef.i.i99.i3119, 4015701072841558310
  %shifted.i.i.i103.i3123 = lshr i64 %product.i.i.i102.i3122, 32
  %xored.i.i.i104.i3124 = xor i64 %shifted.i.i.i103.i3123, %product.i.i.i102.i3122
  %hash.i.i.i105.i3125 = and i64 %xored.i.i.i104.i3124, %tbl_size.i.i100.i3120
  %offset_ptr.i.i106.i3126 = getelementptr i32, ptr %offset_tbl.i.i101.i3121, i64 %hash.i.i.i105.i3125
  %offset.i.i121.i3127 = load i32, ptr %offset_ptr.i.i106.i3126, align 4, !noalias !218
  %1852 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1853 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1854 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1855

1855:                                             ; preds = %.cont.cont.i3148, %1848
  %.0566.i3128 = phi i32 [ 0, %1848 ], [ %1859, %.cont.cont.i3148 ]
  %.070565.i3129 = phi i1 [ true, %1848 ], [ %1921, %.cont.cont.i3148 ]
  %.sroa.0.0564.i3130 = phi ptr [ %1845, %1848 ], [ %vptr.i142.sroa.speculated.i3151, %.cont.cont.i3148 ]
  %.sroa.17.0561.i3133 = phi i32 [ %offset.i.i121.i3127, %1848 ], [ %offset.i.i154.i3165, %.cont.cont.i3148 ]
  %1856 = phi <2 x i64> [ %1850, %1848 ], [ %1920, %.cont.cont.i3148 ]
  %1857 = extractelement <2 x i64> %1856, i64 1
  %.sroa.12.0562.i3132 = inttoptr i64 %1857 to ptr
  %1858 = extractelement <2 x i64> %1856, i64 0
  %.sroa.6.0563.i3131 = inttoptr i64 %1858 to ptr
  %1859 = add nuw nsw i32 %.0566.i3128, 1
  %1860 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3130, 0
  %1861 = insertvalue { ptr, ptr, ptr, i32 } %1860, ptr %.sroa.6.0563.i3131, 1
  %1862 = insertvalue { ptr, ptr, ptr, i32 } %1861, ptr %.sroa.12.0562.i3132, 2
  %1863 = insertvalue { ptr, ptr, ptr, i32 } %1862, i32 %.sroa.17.0561.i3133, 3
  %1864 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3130)
  %1865 = sext i32 %.sroa.17.0561.i3133 to i64
  %1866 = getelementptr ptr, ptr %.sroa.0.0564.i3130, i64 %1865
  %1867 = getelementptr i8, ptr %1866, i64 64
  %1868 = load ptr, ptr %1867, align 8
  %result.i125.i3134 = call ptr %1868({ ptr, ptr, ptr, i32 } %1863, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1869 = call i32 %result.i125.i3134({ ptr, ptr, ptr, i32 } %1863, { ptr, ptr, ptr, i32 } %1863, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3129, label %1870, label %1886

1870:                                             ; preds = %1855
  %1871 = load i32, ptr %56, align 8
  %1872 = add i32 %1871, -1
  %1873 = and i32 %1872, %1869
  %1874 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1875 = load ptr, ptr %57, align 8
  %1876 = sext i32 %1873 to i64
  %1877 = shl nsw i64 %1876, 5
  %1878 = getelementptr i8, ptr %1875, i64 %1877
  %1879 = load ptr, ptr %1878, align 8
  %1880 = getelementptr i8, ptr %1878, i64 8
  %1881 = load i160, ptr %1880, align 4
  store ptr %.sroa.0.0564.i3130, ptr %1878, align 8
  store i64 %1858, ptr %1880, align 4
  %.sroa_idx157.i3177 = getelementptr i8, ptr %1878, i64 16
  store i64 %1857, ptr %.sroa_idx157.i3177, align 4
  %.sroa_idx158.i3178 = getelementptr i8, ptr %1878, i64 24
  store i32 %.sroa.17.0561.i3133, ptr %.sroa_idx158.i3178, align 4
  %1882 = icmp ne ptr %1879, @nil_typ
  %1883 = icmp ne ptr %1879, null
  %.not92.i3179 = and i1 %1882, %1883
  %extract.i3181 = lshr i160 %1881, 64
  %1884 = insertelement <2 x i160> poison, i160 %1881, i64 0
  %1885 = insertelement <2 x i160> %1884, i160 %extract.i3181, i64 1
  br i1 %.not92.i3179, label %.cont.cont.i3148, label %1925

1886:                                             ; preds = %1855
  %1887 = add i32 %1869, 2127912214
  %1888 = shl i32 %1869, 12
  %1889 = add i32 %1887, %1888
  %1890 = ashr i32 %1889, 19
  %1891 = xor i32 %1889, %1890
  %1892 = xor i32 %1891, -949894596
  %1893 = add i32 %1892, 374761393
  %1894 = shl i32 %1892, 5
  %1895 = add i32 %1893, %1894
  %1896 = add i32 %1895, -744332180
  %1897 = shl i32 %1895, 9
  %1898 = xor i32 %1896, %1897
  %1899 = add i32 %1898, -42973499
  %1900 = shl i32 %1898, 3
  %1901 = add i32 %1899, %1900
  %1902 = ashr i32 %1901, 16
  %1903 = xor i32 %1901, %1902
  %1904 = xor i32 %1903, -1252372727
  %1905 = load i32, ptr %56, align 8
  %1906 = add i32 %1905, -1
  %1907 = and i32 %1906, %1904
  %1908 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1909 = load ptr, ptr %58, align 8
  %1910 = sext i32 %1907 to i64
  %1911 = shl nsw i64 %1910, 5
  %1912 = getelementptr i8, ptr %1909, i64 %1911
  %1913 = load ptr, ptr %1912, align 8
  %1914 = getelementptr i8, ptr %1912, i64 8
  %1915 = load i160, ptr %1914, align 4
  store ptr %.sroa.0.0564.i3130, ptr %1912, align 8
  store i64 %1858, ptr %1914, align 4
  %.sroa_idx161.i3138 = getelementptr i8, ptr %1912, i64 16
  store i64 %1857, ptr %.sroa_idx161.i3138, align 4
  %.sroa_idx162.i3139 = getelementptr i8, ptr %1912, i64 24
  store i32 %.sroa.17.0561.i3133, ptr %.sroa_idx162.i3139, align 4
  %1916 = icmp ne ptr %1913, @nil_typ
  %1917 = icmp ne ptr %1913, null
  %.not90.i3140 = and i1 %1916, %1917
  %extract607.i3142 = lshr i160 %1915, 64
  %1918 = insertelement <2 x i160> poison, i160 %1915, i64 0
  %1919 = insertelement <2 x i160> %1918, i160 %extract607.i3142, i64 1
  br i1 %.not90.i3140, label %.cont.cont.i3148, label %1925

.cont.cont.i3148:                                 ; preds = %1886, %1870
  %vptr.i142.sroa.speculated.i3151 = phi ptr [ %1879, %1870 ], [ %1913, %1886 ]
  %.in3826 = phi <2 x i160> [ %1885, %1870 ], [ %1919, %1886 ]
  %1920 = trunc <2 x i160> %.in3826 to <2 x i64>
  %1921 = xor i1 %.070565.i3129, true
  %hash_coef_ptr.i.i143.i3154 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3151, i64 8
  %tbl_size_ptr.i.i144.i3155 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3151, i64 16
  %offset_tbl_ptr.i.i145.i3156 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3151, i64 40
  %hash_coef.i.i146.i3157 = load i64, ptr %hash_coef_ptr.i.i143.i3154, align 4
  %tbl_size.i.i147.i3158 = load i64, ptr %tbl_size_ptr.i.i144.i3155, align 4
  %offset_tbl.i.i148.i3159 = load ptr, ptr %offset_tbl_ptr.i.i145.i3156, align 8
  %product.i.i.i149.i3160 = mul i64 %hash_coef.i.i146.i3157, 4015701072841558310
  %shifted.i.i.i150.i3161 = lshr i64 %product.i.i.i149.i3160, 32
  %xored.i.i.i151.i3162 = xor i64 %shifted.i.i.i150.i3161, %product.i.i.i149.i3160
  %hash.i.i.i152.i3163 = and i64 %xored.i.i.i151.i3162, %tbl_size.i.i147.i3158
  %offset_ptr.i.i153.i3164 = getelementptr i32, ptr %offset_tbl.i.i148.i3159, i64 %hash.i.i.i152.i3163
  %offset.i.i154.i3165 = load i32, ptr %offset_ptr.i.i153.i3164, align 4
  %1922 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1923 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1924 = icmp ult i32 %.0566.i3128, 99
  br i1 %1924, label %1855, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3183

1925:                                             ; preds = %1886, %1870
  %1926 = phi ptr [ %10, %1886 ], [ %9, %1870 ]
  %1927 = load i32, ptr %66, align 4
  store i32 %1927, ptr %1926, align 4
  %1928 = add i32 %1927, 1
  %1929 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1928, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3183

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3183: ; preds = %.cont.cont.i3148, %1925
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i2311

._crit_edge.i2311:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3183, %.lr.ph.i2296
  %1930 = add nuw nsw i32 %.060.i2309, 1
  %1931 = icmp slt i32 %1930, %1837
  br i1 %1931, label %.lr.ph.i2296, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2329

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2329: ; preds = %._crit_edge.i2311, %._crit_edge.i2347
  %.060.i2345 = phi i32 [ %2020, %._crit_edge.i2347 ], [ 0, %._crit_edge.i2311 ]
  %1932 = zext nneg i32 %.060.i2345 to i64
  %1933 = shl nuw nsw i64 %1932, 5
  %1934 = getelementptr i8, ptr %1836, i64 %1933
  %1935 = load ptr, ptr %1934, align 8
  %1936 = icmp ne ptr %1935, @nil_typ
  %1937 = icmp ne ptr %1935, null
  %.not16.i2346 = and i1 %1936, %1937
  br i1 %.not16.i2346, label %1938, label %._crit_edge.i2347

1938:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2329
  %1939 = getelementptr i8, ptr %1934, i64 8
  %1940 = load <2 x i64>, ptr %1939, align 4
  %hash_coef_ptr.i.i18.i2349 = getelementptr i8, ptr %1935, i64 8
  %tbl_size_ptr.i.i19.i2350 = getelementptr i8, ptr %1935, i64 16
  %offset_tbl_ptr.i.i20.i2351 = getelementptr i8, ptr %1935, i64 40
  %1941 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i3201 = load i64, ptr %hash_coef_ptr.i.i18.i2349, align 4, !noalias !22
  %tbl_size.i.i100.i3202 = load i64, ptr %tbl_size_ptr.i.i19.i2350, align 4, !noalias !22
  %offset_tbl.i.i101.i3203 = load ptr, ptr %offset_tbl_ptr.i.i20.i2351, align 8, !noalias !22
  %product.i.i.i102.i3204 = mul i64 %hash_coef.i.i99.i3201, 4015701072841558310
  %shifted.i.i.i103.i3205 = lshr i64 %product.i.i.i102.i3204, 32
  %xored.i.i.i104.i3206 = xor i64 %shifted.i.i.i103.i3205, %product.i.i.i102.i3204
  %hash.i.i.i105.i3207 = and i64 %xored.i.i.i104.i3206, %tbl_size.i.i100.i3202
  %offset_ptr.i.i106.i3208 = getelementptr i32, ptr %offset_tbl.i.i101.i3203, i64 %hash.i.i.i105.i3207
  %offset.i.i121.i3209 = load i32, ptr %offset_ptr.i.i106.i3208, align 4, !noalias !221
  %1942 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1943 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1944 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1945

1945:                                             ; preds = %.cont.cont.i3230, %1938
  %.0566.i3210 = phi i32 [ 0, %1938 ], [ %1949, %.cont.cont.i3230 ]
  %.070565.i3211 = phi i1 [ true, %1938 ], [ %2011, %.cont.cont.i3230 ]
  %.sroa.0.0564.i3212 = phi ptr [ %1935, %1938 ], [ %vptr.i142.sroa.speculated.i3233, %.cont.cont.i3230 ]
  %.sroa.17.0561.i3215 = phi i32 [ %offset.i.i121.i3209, %1938 ], [ %offset.i.i154.i3247, %.cont.cont.i3230 ]
  %1946 = phi <2 x i64> [ %1940, %1938 ], [ %2010, %.cont.cont.i3230 ]
  %1947 = extractelement <2 x i64> %1946, i64 1
  %.sroa.12.0562.i3214 = inttoptr i64 %1947 to ptr
  %1948 = extractelement <2 x i64> %1946, i64 0
  %.sroa.6.0563.i3213 = inttoptr i64 %1948 to ptr
  %1949 = add nuw nsw i32 %.0566.i3210, 1
  %1950 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3212, 0
  %1951 = insertvalue { ptr, ptr, ptr, i32 } %1950, ptr %.sroa.6.0563.i3213, 1
  %1952 = insertvalue { ptr, ptr, ptr, i32 } %1951, ptr %.sroa.12.0562.i3214, 2
  %1953 = insertvalue { ptr, ptr, ptr, i32 } %1952, i32 %.sroa.17.0561.i3215, 3
  %1954 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3212)
  %1955 = sext i32 %.sroa.17.0561.i3215 to i64
  %1956 = getelementptr ptr, ptr %.sroa.0.0564.i3212, i64 %1955
  %1957 = getelementptr i8, ptr %1956, i64 64
  %1958 = load ptr, ptr %1957, align 8
  %result.i125.i3216 = call ptr %1958({ ptr, ptr, ptr, i32 } %1953, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1959 = call i32 %result.i125.i3216({ ptr, ptr, ptr, i32 } %1953, { ptr, ptr, ptr, i32 } %1953, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3211, label %1960, label %1976

1960:                                             ; preds = %1945
  %1961 = load i32, ptr %56, align 8
  %1962 = add i32 %1961, -1
  %1963 = and i32 %1962, %1959
  %1964 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1965 = load ptr, ptr %57, align 8
  %1966 = sext i32 %1963 to i64
  %1967 = shl nsw i64 %1966, 5
  %1968 = getelementptr i8, ptr %1965, i64 %1967
  %1969 = load ptr, ptr %1968, align 8
  %1970 = getelementptr i8, ptr %1968, i64 8
  %1971 = load i160, ptr %1970, align 4
  store ptr %.sroa.0.0564.i3212, ptr %1968, align 8
  store i64 %1948, ptr %1970, align 4
  %.sroa_idx157.i3259 = getelementptr i8, ptr %1968, i64 16
  store i64 %1947, ptr %.sroa_idx157.i3259, align 4
  %.sroa_idx158.i3260 = getelementptr i8, ptr %1968, i64 24
  store i32 %.sroa.17.0561.i3215, ptr %.sroa_idx158.i3260, align 4
  %1972 = icmp ne ptr %1969, @nil_typ
  %1973 = icmp ne ptr %1969, null
  %.not92.i3261 = and i1 %1972, %1973
  %extract.i3263 = lshr i160 %1971, 64
  %1974 = insertelement <2 x i160> poison, i160 %1971, i64 0
  %1975 = insertelement <2 x i160> %1974, i160 %extract.i3263, i64 1
  br i1 %.not92.i3261, label %.cont.cont.i3230, label %2015

1976:                                             ; preds = %1945
  %1977 = add i32 %1959, 2127912214
  %1978 = shl i32 %1959, 12
  %1979 = add i32 %1977, %1978
  %1980 = ashr i32 %1979, 19
  %1981 = xor i32 %1979, %1980
  %1982 = xor i32 %1981, -949894596
  %1983 = add i32 %1982, 374761393
  %1984 = shl i32 %1982, 5
  %1985 = add i32 %1983, %1984
  %1986 = add i32 %1985, -744332180
  %1987 = shl i32 %1985, 9
  %1988 = xor i32 %1986, %1987
  %1989 = add i32 %1988, -42973499
  %1990 = shl i32 %1988, 3
  %1991 = add i32 %1989, %1990
  %1992 = ashr i32 %1991, 16
  %1993 = xor i32 %1991, %1992
  %1994 = xor i32 %1993, -1252372727
  %1995 = load i32, ptr %56, align 8
  %1996 = add i32 %1995, -1
  %1997 = and i32 %1996, %1994
  %1998 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1999 = load ptr, ptr %58, align 8
  %2000 = sext i32 %1997 to i64
  %2001 = shl nsw i64 %2000, 5
  %2002 = getelementptr i8, ptr %1999, i64 %2001
  %2003 = load ptr, ptr %2002, align 8
  %2004 = getelementptr i8, ptr %2002, i64 8
  %2005 = load i160, ptr %2004, align 4
  store ptr %.sroa.0.0564.i3212, ptr %2002, align 8
  store i64 %1948, ptr %2004, align 4
  %.sroa_idx161.i3220 = getelementptr i8, ptr %2002, i64 16
  store i64 %1947, ptr %.sroa_idx161.i3220, align 4
  %.sroa_idx162.i3221 = getelementptr i8, ptr %2002, i64 24
  store i32 %.sroa.17.0561.i3215, ptr %.sroa_idx162.i3221, align 4
  %2006 = icmp ne ptr %2003, @nil_typ
  %2007 = icmp ne ptr %2003, null
  %.not90.i3222 = and i1 %2006, %2007
  %extract607.i3224 = lshr i160 %2005, 64
  %2008 = insertelement <2 x i160> poison, i160 %2005, i64 0
  %2009 = insertelement <2 x i160> %2008, i160 %extract607.i3224, i64 1
  br i1 %.not90.i3222, label %.cont.cont.i3230, label %2015

.cont.cont.i3230:                                 ; preds = %1976, %1960
  %vptr.i142.sroa.speculated.i3233 = phi ptr [ %1969, %1960 ], [ %2003, %1976 ]
  %.in3827 = phi <2 x i160> [ %1975, %1960 ], [ %2009, %1976 ]
  %2010 = trunc <2 x i160> %.in3827 to <2 x i64>
  %2011 = xor i1 %.070565.i3211, true
  %hash_coef_ptr.i.i143.i3236 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3233, i64 8
  %tbl_size_ptr.i.i144.i3237 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3233, i64 16
  %offset_tbl_ptr.i.i145.i3238 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3233, i64 40
  %hash_coef.i.i146.i3239 = load i64, ptr %hash_coef_ptr.i.i143.i3236, align 4
  %tbl_size.i.i147.i3240 = load i64, ptr %tbl_size_ptr.i.i144.i3237, align 4
  %offset_tbl.i.i148.i3241 = load ptr, ptr %offset_tbl_ptr.i.i145.i3238, align 8
  %product.i.i.i149.i3242 = mul i64 %hash_coef.i.i146.i3239, 4015701072841558310
  %shifted.i.i.i150.i3243 = lshr i64 %product.i.i.i149.i3242, 32
  %xored.i.i.i151.i3244 = xor i64 %shifted.i.i.i150.i3243, %product.i.i.i149.i3242
  %hash.i.i.i152.i3245 = and i64 %xored.i.i.i151.i3244, %tbl_size.i.i147.i3240
  %offset_ptr.i.i153.i3246 = getelementptr i32, ptr %offset_tbl.i.i148.i3241, i64 %hash.i.i.i152.i3245
  %offset.i.i154.i3247 = load i32, ptr %offset_ptr.i.i153.i3246, align 4
  %2012 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2013 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2014 = icmp ult i32 %.0566.i3210, 99
  br i1 %2014, label %1945, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3265

2015:                                             ; preds = %1976, %1960
  %2016 = phi ptr [ %8, %1976 ], [ %7, %1960 ]
  %2017 = load i32, ptr %66, align 4
  store i32 %2017, ptr %2016, align 4
  %2018 = add i32 %2017, 1
  %2019 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2018, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3265

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3265: ; preds = %.cont.cont.i3230, %2015
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i2347

._crit_edge.i2347:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3265, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2329
  %2020 = add nuw nsw i32 %.060.i2345, 1
  %2021 = icmp slt i32 %2020, %1837
  br i1 %2021, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2329, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365: ; preds = %._crit_edge.i2347, %1833
  %2022 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %28)
  %hash_coef.i.i99.i1574 = load i64, ptr %hash_coef_ptr.i.i143.i1504, align 4, !noalias !22
  %tbl_size.i.i100.i1575 = load i64, ptr %tbl_size_ptr.i.i144.i1505, align 4, !noalias !22
  %offset_tbl.i.i101.i1576 = load ptr, ptr %offset_tbl_ptr.i.i145.i1506, align 8, !noalias !22
  %product.i.i.i102.i1577 = mul i64 %hash_coef.i.i99.i1574, 4015701072841558310
  %shifted.i.i.i103.i1578 = lshr i64 %product.i.i.i102.i1577, 32
  %xored.i.i.i104.i1579 = xor i64 %shifted.i.i.i103.i1578, %product.i.i.i102.i1577
  %hash.i.i.i105.i1580 = and i64 %xored.i.i.i104.i1579, %tbl_size.i.i100.i1575
  %offset_ptr.i.i106.i1581 = getelementptr i32, ptr %offset_tbl.i.i101.i1576, i64 %hash.i.i.i105.i1580
  %offset.i.i121.i1582 = load i32, ptr %offset_ptr.i.i106.i1581, align 4, !noalias !224
  %2023 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2024 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2025 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2026

2026:                                             ; preds = %.cont.cont.i1604, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365
  %.0566.i1584 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365 ], [ %2030, %.cont.cont.i1604 ]
  %.070565.i1585 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365 ], [ %2092, %.cont.cont.i1604 ]
  %.sroa.0.0564.i1586 = phi ptr [ %vptr.i142.sroa.speculated.i1501, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365 ], [ %vptr.i142.sroa.speculated.i1607, %.cont.cont.i1604 ]
  %.sroa.17.0561.i1589 = phi i32 [ %offset.i.i121.i1582, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365 ], [ %offset.i.i154.i1621, %.cont.cont.i1604 ]
  %2027 = phi <2 x i64> [ %1821, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2365 ], [ %2091, %.cont.cont.i1604 ]
  %2028 = extractelement <2 x i64> %2027, i64 1
  %.sroa.12.0562.i1588 = inttoptr i64 %2028 to ptr
  %2029 = extractelement <2 x i64> %2027, i64 0
  %.sroa.6.0563.i1587 = inttoptr i64 %2029 to ptr
  %2030 = add nuw nsw i32 %.0566.i1584, 1
  %2031 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1586, 0
  %2032 = insertvalue { ptr, ptr, ptr, i32 } %2031, ptr %.sroa.6.0563.i1587, 1
  %2033 = insertvalue { ptr, ptr, ptr, i32 } %2032, ptr %.sroa.12.0562.i1588, 2
  %2034 = insertvalue { ptr, ptr, ptr, i32 } %2033, i32 %.sroa.17.0561.i1589, 3
  %2035 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1586)
  %2036 = sext i32 %.sroa.17.0561.i1589 to i64
  %2037 = getelementptr ptr, ptr %.sroa.0.0564.i1586, i64 %2036
  %2038 = getelementptr i8, ptr %2037, i64 64
  %2039 = load ptr, ptr %2038, align 8
  %result.i125.i1590 = call ptr %2039({ ptr, ptr, ptr, i32 } %2034, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2040 = call i32 %result.i125.i1590({ ptr, ptr, ptr, i32 } %2034, { ptr, ptr, ptr, i32 } %2034, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1585, label %2041, label %2057

2041:                                             ; preds = %2026
  %2042 = load i32, ptr %56, align 8
  %2043 = add i32 %2042, -1
  %2044 = and i32 %2043, %2040
  %2045 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2046 = load ptr, ptr %57, align 8
  %2047 = sext i32 %2044 to i64
  %2048 = shl nsw i64 %2047, 5
  %2049 = getelementptr i8, ptr %2046, i64 %2048
  %2050 = load ptr, ptr %2049, align 8
  %2051 = getelementptr i8, ptr %2049, i64 8
  %2052 = load i160, ptr %2051, align 4
  store ptr %.sroa.0.0564.i1586, ptr %2049, align 8
  store i64 %2029, ptr %2051, align 4
  %.sroa_idx157.i1633 = getelementptr i8, ptr %2049, i64 16
  store i64 %2028, ptr %.sroa_idx157.i1633, align 4
  %.sroa_idx158.i1634 = getelementptr i8, ptr %2049, i64 24
  store i32 %.sroa.17.0561.i1589, ptr %.sroa_idx158.i1634, align 4
  %2053 = icmp ne ptr %2050, @nil_typ
  %2054 = icmp ne ptr %2050, null
  %.not92.i1635 = and i1 %2053, %2054
  %extract.i1637 = lshr i160 %2052, 64
  %2055 = insertelement <2 x i160> poison, i160 %2052, i64 0
  %2056 = insertelement <2 x i160> %2055, i160 %extract.i1637, i64 1
  br i1 %.not92.i1635, label %.cont.cont.i1604, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1639.thread

2057:                                             ; preds = %2026
  %2058 = add i32 %2040, 2127912214
  %2059 = shl i32 %2040, 12
  %2060 = add i32 %2058, %2059
  %2061 = ashr i32 %2060, 19
  %2062 = xor i32 %2060, %2061
  %2063 = xor i32 %2062, -949894596
  %2064 = add i32 %2063, 374761393
  %2065 = shl i32 %2063, 5
  %2066 = add i32 %2064, %2065
  %2067 = add i32 %2066, -744332180
  %2068 = shl i32 %2066, 9
  %2069 = xor i32 %2067, %2068
  %2070 = add i32 %2069, -42973499
  %2071 = shl i32 %2069, 3
  %2072 = add i32 %2070, %2071
  %2073 = ashr i32 %2072, 16
  %2074 = xor i32 %2072, %2073
  %2075 = xor i32 %2074, -1252372727
  %2076 = load i32, ptr %56, align 8
  %2077 = add i32 %2076, -1
  %2078 = and i32 %2077, %2075
  %2079 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2080 = load ptr, ptr %58, align 8
  %2081 = sext i32 %2078 to i64
  %2082 = shl nsw i64 %2081, 5
  %2083 = getelementptr i8, ptr %2080, i64 %2082
  %2084 = load ptr, ptr %2083, align 8
  %2085 = getelementptr i8, ptr %2083, i64 8
  %2086 = load i160, ptr %2085, align 4
  store ptr %.sroa.0.0564.i1586, ptr %2083, align 8
  store i64 %2029, ptr %2085, align 4
  %.sroa_idx161.i1594 = getelementptr i8, ptr %2083, i64 16
  store i64 %2028, ptr %.sroa_idx161.i1594, align 4
  %.sroa_idx162.i1595 = getelementptr i8, ptr %2083, i64 24
  store i32 %.sroa.17.0561.i1589, ptr %.sroa_idx162.i1595, align 4
  %2087 = icmp ne ptr %2084, @nil_typ
  %2088 = icmp ne ptr %2084, null
  %.not90.i1596 = and i1 %2087, %2088
  %extract607.i1598 = lshr i160 %2086, 64
  %2089 = insertelement <2 x i160> poison, i160 %2086, i64 0
  %2090 = insertelement <2 x i160> %2089, i160 %extract607.i1598, i64 1
  br i1 %.not90.i1596, label %.cont.cont.i1604, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1639.thread

.cont.cont.i1604:                                 ; preds = %2057, %2041
  %vptr.i142.sroa.speculated.i1607 = phi ptr [ %2050, %2041 ], [ %2084, %2057 ]
  %.in3828 = phi <2 x i160> [ %2056, %2041 ], [ %2090, %2057 ]
  %2091 = trunc <2 x i160> %.in3828 to <2 x i64>
  %2092 = xor i1 %.070565.i1585, true
  %hash_coef_ptr.i.i143.i1610 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1607, i64 8
  %tbl_size_ptr.i.i144.i1611 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1607, i64 16
  %offset_tbl_ptr.i.i145.i1612 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1607, i64 40
  %hash_coef.i.i146.i1613 = load i64, ptr %hash_coef_ptr.i.i143.i1610, align 4
  %tbl_size.i.i147.i1614 = load i64, ptr %tbl_size_ptr.i.i144.i1611, align 4
  %offset_tbl.i.i148.i1615 = load ptr, ptr %offset_tbl_ptr.i.i145.i1612, align 8
  %product.i.i.i149.i1616 = mul i64 %hash_coef.i.i146.i1613, 4015701072841558310
  %shifted.i.i.i150.i1617 = lshr i64 %product.i.i.i149.i1616, 32
  %xored.i.i.i151.i1618 = xor i64 %shifted.i.i.i150.i1617, %product.i.i.i149.i1616
  %hash.i.i.i152.i1619 = and i64 %xored.i.i.i151.i1618, %tbl_size.i.i147.i1614
  %offset_ptr.i.i153.i1620 = getelementptr i32, ptr %offset_tbl.i.i148.i1615, i64 %hash.i.i.i152.i1619
  %offset.i.i154.i1621 = load i32, ptr %offset_ptr.i.i153.i1620, align 4
  %2093 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2094 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2095 = icmp ult i32 %.0566.i1584, 99
  br i1 %2095, label %2026, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1639

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1639.thread: ; preds = %2041, %2057
  %2096 = phi ptr [ %28, %2057 ], [ %27, %2041 ]
  %2097 = load i32, ptr %66, align 4
  store i32 %2097, ptr %2096, align 4
  %2098 = add i32 %2097, 1
  %2099 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2098, ptr %66, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  br label %CuckooMap_insert_keyK_valueV.exit780

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1639: ; preds = %.cont.cont.i1604
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  %2100 = icmp eq ptr %vptr.i142.sroa.speculated.i1607, null
  br i1 %2100, label %CuckooMap_insert_keyK_valueV.exit780, label %2101

2101:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1639
  %2102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2103 = load ptr, ptr %57, align 8
  %2104 = load ptr, ptr %58, align 8
  %2105 = load i32, ptr %56, align 8
  %2106 = shl i32 %2105, 1
  %spec.select.i1655 = call i32 @llvm.smax.i32(i32 %2106, i32 16)
  store i32 %spec.select.i1655, ptr %56, align 8
  %2107 = zext nneg i32 %spec.select.i1655 to i64
  %2108 = shl nuw nsw i64 %2107, 5
  %result.i.i1656 = call noalias ptr @bump_malloc_inner(i64 noundef %2108, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1656, ptr %57, align 8
  %result.i20.i1657 = call noalias ptr @bump_malloc_inner(i64 noundef %2108, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1657, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %2109 = icmp sgt i32 %2105, 0
  br i1 %2109, label %.lr.ph.i2395, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2428.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2428.thread: ; preds = %2101
  %2110 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit780

.lr.ph.i2395:                                     ; preds = %2101, %._crit_edge.i2410
  %.060.i2408 = phi i32 [ %2199, %._crit_edge.i2410 ], [ 0, %2101 ]
  %2111 = zext nneg i32 %.060.i2408 to i64
  %2112 = shl nuw nsw i64 %2111, 5
  %2113 = getelementptr i8, ptr %2103, i64 %2112
  %2114 = load ptr, ptr %2113, align 8
  %2115 = icmp ne ptr %2114, @nil_typ
  %2116 = icmp ne ptr %2114, null
  %.not16.i2409 = and i1 %2115, %2116
  br i1 %.not16.i2409, label %2117, label %._crit_edge.i2410

2117:                                             ; preds = %.lr.ph.i2395
  %2118 = getelementptr i8, ptr %2113, i64 8
  %2119 = load <2 x i64>, ptr %2118, align 4
  %hash_coef_ptr.i.i18.i2412 = getelementptr i8, ptr %2114, i64 8
  %tbl_size_ptr.i.i19.i2413 = getelementptr i8, ptr %2114, i64 16
  %offset_tbl_ptr.i.i20.i2414 = getelementptr i8, ptr %2114, i64 40
  %2120 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i3283 = load i64, ptr %hash_coef_ptr.i.i18.i2412, align 4, !noalias !22
  %tbl_size.i.i100.i3284 = load i64, ptr %tbl_size_ptr.i.i19.i2413, align 4, !noalias !22
  %offset_tbl.i.i101.i3285 = load ptr, ptr %offset_tbl_ptr.i.i20.i2414, align 8, !noalias !22
  %product.i.i.i102.i3286 = mul i64 %hash_coef.i.i99.i3283, 4015701072841558310
  %shifted.i.i.i103.i3287 = lshr i64 %product.i.i.i102.i3286, 32
  %xored.i.i.i104.i3288 = xor i64 %shifted.i.i.i103.i3287, %product.i.i.i102.i3286
  %hash.i.i.i105.i3289 = and i64 %xored.i.i.i104.i3288, %tbl_size.i.i100.i3284
  %offset_ptr.i.i106.i3290 = getelementptr i32, ptr %offset_tbl.i.i101.i3285, i64 %hash.i.i.i105.i3289
  %offset.i.i121.i3291 = load i32, ptr %offset_ptr.i.i106.i3290, align 4, !noalias !227
  %2121 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2122 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2124

2124:                                             ; preds = %.cont.cont.i3312, %2117
  %.0566.i3292 = phi i32 [ 0, %2117 ], [ %2128, %.cont.cont.i3312 ]
  %.070565.i3293 = phi i1 [ true, %2117 ], [ %2190, %.cont.cont.i3312 ]
  %.sroa.0.0564.i3294 = phi ptr [ %2114, %2117 ], [ %vptr.i142.sroa.speculated.i3315, %.cont.cont.i3312 ]
  %.sroa.17.0561.i3297 = phi i32 [ %offset.i.i121.i3291, %2117 ], [ %offset.i.i154.i3329, %.cont.cont.i3312 ]
  %2125 = phi <2 x i64> [ %2119, %2117 ], [ %2189, %.cont.cont.i3312 ]
  %2126 = extractelement <2 x i64> %2125, i64 1
  %.sroa.12.0562.i3296 = inttoptr i64 %2126 to ptr
  %2127 = extractelement <2 x i64> %2125, i64 0
  %.sroa.6.0563.i3295 = inttoptr i64 %2127 to ptr
  %2128 = add nuw nsw i32 %.0566.i3292, 1
  %2129 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3294, 0
  %2130 = insertvalue { ptr, ptr, ptr, i32 } %2129, ptr %.sroa.6.0563.i3295, 1
  %2131 = insertvalue { ptr, ptr, ptr, i32 } %2130, ptr %.sroa.12.0562.i3296, 2
  %2132 = insertvalue { ptr, ptr, ptr, i32 } %2131, i32 %.sroa.17.0561.i3297, 3
  %2133 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3294)
  %2134 = sext i32 %.sroa.17.0561.i3297 to i64
  %2135 = getelementptr ptr, ptr %.sroa.0.0564.i3294, i64 %2134
  %2136 = getelementptr i8, ptr %2135, i64 64
  %2137 = load ptr, ptr %2136, align 8
  %result.i125.i3298 = call ptr %2137({ ptr, ptr, ptr, i32 } %2132, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2138 = call i32 %result.i125.i3298({ ptr, ptr, ptr, i32 } %2132, { ptr, ptr, ptr, i32 } %2132, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3293, label %2139, label %2155

2139:                                             ; preds = %2124
  %2140 = load i32, ptr %56, align 8
  %2141 = add i32 %2140, -1
  %2142 = and i32 %2141, %2138
  %2143 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2144 = load ptr, ptr %57, align 8
  %2145 = sext i32 %2142 to i64
  %2146 = shl nsw i64 %2145, 5
  %2147 = getelementptr i8, ptr %2144, i64 %2146
  %2148 = load ptr, ptr %2147, align 8
  %2149 = getelementptr i8, ptr %2147, i64 8
  %2150 = load i160, ptr %2149, align 4
  store ptr %.sroa.0.0564.i3294, ptr %2147, align 8
  store i64 %2127, ptr %2149, align 4
  %.sroa_idx157.i3341 = getelementptr i8, ptr %2147, i64 16
  store i64 %2126, ptr %.sroa_idx157.i3341, align 4
  %.sroa_idx158.i3342 = getelementptr i8, ptr %2147, i64 24
  store i32 %.sroa.17.0561.i3297, ptr %.sroa_idx158.i3342, align 4
  %2151 = icmp ne ptr %2148, @nil_typ
  %2152 = icmp ne ptr %2148, null
  %.not92.i3343 = and i1 %2151, %2152
  %extract.i3345 = lshr i160 %2150, 64
  %2153 = insertelement <2 x i160> poison, i160 %2150, i64 0
  %2154 = insertelement <2 x i160> %2153, i160 %extract.i3345, i64 1
  br i1 %.not92.i3343, label %.cont.cont.i3312, label %2194

2155:                                             ; preds = %2124
  %2156 = add i32 %2138, 2127912214
  %2157 = shl i32 %2138, 12
  %2158 = add i32 %2156, %2157
  %2159 = ashr i32 %2158, 19
  %2160 = xor i32 %2158, %2159
  %2161 = xor i32 %2160, -949894596
  %2162 = add i32 %2161, 374761393
  %2163 = shl i32 %2161, 5
  %2164 = add i32 %2162, %2163
  %2165 = add i32 %2164, -744332180
  %2166 = shl i32 %2164, 9
  %2167 = xor i32 %2165, %2166
  %2168 = add i32 %2167, -42973499
  %2169 = shl i32 %2167, 3
  %2170 = add i32 %2168, %2169
  %2171 = ashr i32 %2170, 16
  %2172 = xor i32 %2170, %2171
  %2173 = xor i32 %2172, -1252372727
  %2174 = load i32, ptr %56, align 8
  %2175 = add i32 %2174, -1
  %2176 = and i32 %2175, %2173
  %2177 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2178 = load ptr, ptr %58, align 8
  %2179 = sext i32 %2176 to i64
  %2180 = shl nsw i64 %2179, 5
  %2181 = getelementptr i8, ptr %2178, i64 %2180
  %2182 = load ptr, ptr %2181, align 8
  %2183 = getelementptr i8, ptr %2181, i64 8
  %2184 = load i160, ptr %2183, align 4
  store ptr %.sroa.0.0564.i3294, ptr %2181, align 8
  store i64 %2127, ptr %2183, align 4
  %.sroa_idx161.i3302 = getelementptr i8, ptr %2181, i64 16
  store i64 %2126, ptr %.sroa_idx161.i3302, align 4
  %.sroa_idx162.i3303 = getelementptr i8, ptr %2181, i64 24
  store i32 %.sroa.17.0561.i3297, ptr %.sroa_idx162.i3303, align 4
  %2185 = icmp ne ptr %2182, @nil_typ
  %2186 = icmp ne ptr %2182, null
  %.not90.i3304 = and i1 %2185, %2186
  %extract607.i3306 = lshr i160 %2184, 64
  %2187 = insertelement <2 x i160> poison, i160 %2184, i64 0
  %2188 = insertelement <2 x i160> %2187, i160 %extract607.i3306, i64 1
  br i1 %.not90.i3304, label %.cont.cont.i3312, label %2194

.cont.cont.i3312:                                 ; preds = %2155, %2139
  %vptr.i142.sroa.speculated.i3315 = phi ptr [ %2148, %2139 ], [ %2182, %2155 ]
  %.in3829 = phi <2 x i160> [ %2154, %2139 ], [ %2188, %2155 ]
  %2189 = trunc <2 x i160> %.in3829 to <2 x i64>
  %2190 = xor i1 %.070565.i3293, true
  %hash_coef_ptr.i.i143.i3318 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3315, i64 8
  %tbl_size_ptr.i.i144.i3319 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3315, i64 16
  %offset_tbl_ptr.i.i145.i3320 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3315, i64 40
  %hash_coef.i.i146.i3321 = load i64, ptr %hash_coef_ptr.i.i143.i3318, align 4
  %tbl_size.i.i147.i3322 = load i64, ptr %tbl_size_ptr.i.i144.i3319, align 4
  %offset_tbl.i.i148.i3323 = load ptr, ptr %offset_tbl_ptr.i.i145.i3320, align 8
  %product.i.i.i149.i3324 = mul i64 %hash_coef.i.i146.i3321, 4015701072841558310
  %shifted.i.i.i150.i3325 = lshr i64 %product.i.i.i149.i3324, 32
  %xored.i.i.i151.i3326 = xor i64 %shifted.i.i.i150.i3325, %product.i.i.i149.i3324
  %hash.i.i.i152.i3327 = and i64 %xored.i.i.i151.i3326, %tbl_size.i.i147.i3322
  %offset_ptr.i.i153.i3328 = getelementptr i32, ptr %offset_tbl.i.i148.i3323, i64 %hash.i.i.i152.i3327
  %offset.i.i154.i3329 = load i32, ptr %offset_ptr.i.i153.i3328, align 4
  %2191 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2192 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2193 = icmp ult i32 %.0566.i3292, 99
  br i1 %2193, label %2124, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3347

2194:                                             ; preds = %2155, %2139
  %2195 = phi ptr [ %6, %2155 ], [ %5, %2139 ]
  %2196 = load i32, ptr %66, align 4
  store i32 %2196, ptr %2195, align 4
  %2197 = add i32 %2196, 1
  %2198 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2197, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3347

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3347: ; preds = %.cont.cont.i3312, %2194
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i2410

._crit_edge.i2410:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3347, %.lr.ph.i2395
  %2199 = add nuw nsw i32 %.060.i2408, 1
  %2200 = icmp slt i32 %2199, %2105
  br i1 %2200, label %.lr.ph.i2395, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2428

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2428: ; preds = %._crit_edge.i2410
  %2201 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %2202

2202:                                             ; preds = %._crit_edge.i2446, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2428
  %.060.i2444 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2428 ], [ %2291, %._crit_edge.i2446 ]
  %2203 = zext nneg i32 %.060.i2444 to i64
  %2204 = shl nuw nsw i64 %2203, 5
  %2205 = getelementptr i8, ptr %2104, i64 %2204
  %2206 = load ptr, ptr %2205, align 8
  %2207 = icmp ne ptr %2206, @nil_typ
  %2208 = icmp ne ptr %2206, null
  %.not16.i2445 = and i1 %2207, %2208
  br i1 %.not16.i2445, label %2209, label %._crit_edge.i2446

2209:                                             ; preds = %2202
  %2210 = getelementptr i8, ptr %2205, i64 8
  %2211 = load <2 x i64>, ptr %2210, align 4
  %hash_coef_ptr.i.i18.i2448 = getelementptr i8, ptr %2206, i64 8
  %tbl_size_ptr.i.i19.i2449 = getelementptr i8, ptr %2206, i64 16
  %offset_tbl_ptr.i.i20.i2450 = getelementptr i8, ptr %2206, i64 40
  %2212 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i3365 = load i64, ptr %hash_coef_ptr.i.i18.i2448, align 4, !noalias !22
  %tbl_size.i.i100.i3366 = load i64, ptr %tbl_size_ptr.i.i19.i2449, align 4, !noalias !22
  %offset_tbl.i.i101.i3367 = load ptr, ptr %offset_tbl_ptr.i.i20.i2450, align 8, !noalias !22
  %product.i.i.i102.i3368 = mul i64 %hash_coef.i.i99.i3365, 4015701072841558310
  %shifted.i.i.i103.i3369 = lshr i64 %product.i.i.i102.i3368, 32
  %xored.i.i.i104.i3370 = xor i64 %shifted.i.i.i103.i3369, %product.i.i.i102.i3368
  %hash.i.i.i105.i3371 = and i64 %xored.i.i.i104.i3370, %tbl_size.i.i100.i3366
  %offset_ptr.i.i106.i3372 = getelementptr i32, ptr %offset_tbl.i.i101.i3367, i64 %hash.i.i.i105.i3371
  %offset.i.i121.i3373 = load i32, ptr %offset_ptr.i.i106.i3372, align 4, !noalias !230
  %2213 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2214 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2215 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2216

2216:                                             ; preds = %.cont.cont.i3394, %2209
  %.0566.i3374 = phi i32 [ 0, %2209 ], [ %2220, %.cont.cont.i3394 ]
  %.070565.i3375 = phi i1 [ true, %2209 ], [ %2282, %.cont.cont.i3394 ]
  %.sroa.0.0564.i3376 = phi ptr [ %2206, %2209 ], [ %vptr.i142.sroa.speculated.i3397, %.cont.cont.i3394 ]
  %.sroa.17.0561.i3379 = phi i32 [ %offset.i.i121.i3373, %2209 ], [ %offset.i.i154.i3411, %.cont.cont.i3394 ]
  %2217 = phi <2 x i64> [ %2211, %2209 ], [ %2281, %.cont.cont.i3394 ]
  %2218 = extractelement <2 x i64> %2217, i64 1
  %.sroa.12.0562.i3378 = inttoptr i64 %2218 to ptr
  %2219 = extractelement <2 x i64> %2217, i64 0
  %.sroa.6.0563.i3377 = inttoptr i64 %2219 to ptr
  %2220 = add nuw nsw i32 %.0566.i3374, 1
  %2221 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3376, 0
  %2222 = insertvalue { ptr, ptr, ptr, i32 } %2221, ptr %.sroa.6.0563.i3377, 1
  %2223 = insertvalue { ptr, ptr, ptr, i32 } %2222, ptr %.sroa.12.0562.i3378, 2
  %2224 = insertvalue { ptr, ptr, ptr, i32 } %2223, i32 %.sroa.17.0561.i3379, 3
  %2225 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3376)
  %2226 = sext i32 %.sroa.17.0561.i3379 to i64
  %2227 = getelementptr ptr, ptr %.sroa.0.0564.i3376, i64 %2226
  %2228 = getelementptr i8, ptr %2227, i64 64
  %2229 = load ptr, ptr %2228, align 8
  %result.i125.i3380 = call ptr %2229({ ptr, ptr, ptr, i32 } %2224, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2230 = call i32 %result.i125.i3380({ ptr, ptr, ptr, i32 } %2224, { ptr, ptr, ptr, i32 } %2224, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3375, label %2231, label %2247

2231:                                             ; preds = %2216
  %2232 = load i32, ptr %56, align 8
  %2233 = add i32 %2232, -1
  %2234 = and i32 %2233, %2230
  %2235 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2236 = load ptr, ptr %57, align 8
  %2237 = sext i32 %2234 to i64
  %2238 = shl nsw i64 %2237, 5
  %2239 = getelementptr i8, ptr %2236, i64 %2238
  %2240 = load ptr, ptr %2239, align 8
  %2241 = getelementptr i8, ptr %2239, i64 8
  %2242 = load i160, ptr %2241, align 4
  store ptr %.sroa.0.0564.i3376, ptr %2239, align 8
  store i64 %2219, ptr %2241, align 4
  %.sroa_idx157.i3423 = getelementptr i8, ptr %2239, i64 16
  store i64 %2218, ptr %.sroa_idx157.i3423, align 4
  %.sroa_idx158.i3424 = getelementptr i8, ptr %2239, i64 24
  store i32 %.sroa.17.0561.i3379, ptr %.sroa_idx158.i3424, align 4
  %2243 = icmp ne ptr %2240, @nil_typ
  %2244 = icmp ne ptr %2240, null
  %.not92.i3425 = and i1 %2243, %2244
  %extract.i3427 = lshr i160 %2242, 64
  %2245 = insertelement <2 x i160> poison, i160 %2242, i64 0
  %2246 = insertelement <2 x i160> %2245, i160 %extract.i3427, i64 1
  br i1 %.not92.i3425, label %.cont.cont.i3394, label %2286

2247:                                             ; preds = %2216
  %2248 = add i32 %2230, 2127912214
  %2249 = shl i32 %2230, 12
  %2250 = add i32 %2248, %2249
  %2251 = ashr i32 %2250, 19
  %2252 = xor i32 %2250, %2251
  %2253 = xor i32 %2252, -949894596
  %2254 = add i32 %2253, 374761393
  %2255 = shl i32 %2253, 5
  %2256 = add i32 %2254, %2255
  %2257 = add i32 %2256, -744332180
  %2258 = shl i32 %2256, 9
  %2259 = xor i32 %2257, %2258
  %2260 = add i32 %2259, -42973499
  %2261 = shl i32 %2259, 3
  %2262 = add i32 %2260, %2261
  %2263 = ashr i32 %2262, 16
  %2264 = xor i32 %2262, %2263
  %2265 = xor i32 %2264, -1252372727
  %2266 = load i32, ptr %56, align 8
  %2267 = add i32 %2266, -1
  %2268 = and i32 %2267, %2265
  %2269 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2270 = load ptr, ptr %58, align 8
  %2271 = sext i32 %2268 to i64
  %2272 = shl nsw i64 %2271, 5
  %2273 = getelementptr i8, ptr %2270, i64 %2272
  %2274 = load ptr, ptr %2273, align 8
  %2275 = getelementptr i8, ptr %2273, i64 8
  %2276 = load i160, ptr %2275, align 4
  store ptr %.sroa.0.0564.i3376, ptr %2273, align 8
  store i64 %2219, ptr %2275, align 4
  %.sroa_idx161.i3384 = getelementptr i8, ptr %2273, i64 16
  store i64 %2218, ptr %.sroa_idx161.i3384, align 4
  %.sroa_idx162.i3385 = getelementptr i8, ptr %2273, i64 24
  store i32 %.sroa.17.0561.i3379, ptr %.sroa_idx162.i3385, align 4
  %2277 = icmp ne ptr %2274, @nil_typ
  %2278 = icmp ne ptr %2274, null
  %.not90.i3386 = and i1 %2277, %2278
  %extract607.i3388 = lshr i160 %2276, 64
  %2279 = insertelement <2 x i160> poison, i160 %2276, i64 0
  %2280 = insertelement <2 x i160> %2279, i160 %extract607.i3388, i64 1
  br i1 %.not90.i3386, label %.cont.cont.i3394, label %2286

.cont.cont.i3394:                                 ; preds = %2247, %2231
  %vptr.i142.sroa.speculated.i3397 = phi ptr [ %2240, %2231 ], [ %2274, %2247 ]
  %.in3830 = phi <2 x i160> [ %2246, %2231 ], [ %2280, %2247 ]
  %2281 = trunc <2 x i160> %.in3830 to <2 x i64>
  %2282 = xor i1 %.070565.i3375, true
  %hash_coef_ptr.i.i143.i3400 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3397, i64 8
  %tbl_size_ptr.i.i144.i3401 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3397, i64 16
  %offset_tbl_ptr.i.i145.i3402 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3397, i64 40
  %hash_coef.i.i146.i3403 = load i64, ptr %hash_coef_ptr.i.i143.i3400, align 4
  %tbl_size.i.i147.i3404 = load i64, ptr %tbl_size_ptr.i.i144.i3401, align 4
  %offset_tbl.i.i148.i3405 = load ptr, ptr %offset_tbl_ptr.i.i145.i3402, align 8
  %product.i.i.i149.i3406 = mul i64 %hash_coef.i.i146.i3403, 4015701072841558310
  %shifted.i.i.i150.i3407 = lshr i64 %product.i.i.i149.i3406, 32
  %xored.i.i.i151.i3408 = xor i64 %shifted.i.i.i150.i3407, %product.i.i.i149.i3406
  %hash.i.i.i152.i3409 = and i64 %xored.i.i.i151.i3408, %tbl_size.i.i147.i3404
  %offset_ptr.i.i153.i3410 = getelementptr i32, ptr %offset_tbl.i.i148.i3405, i64 %hash.i.i.i152.i3409
  %offset.i.i154.i3411 = load i32, ptr %offset_ptr.i.i153.i3410, align 4
  %2283 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2284 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2285 = icmp ult i32 %.0566.i3374, 99
  br i1 %2285, label %2216, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3429

2286:                                             ; preds = %2247, %2231
  %2287 = phi ptr [ %4, %2247 ], [ %3, %2231 ]
  %2288 = load i32, ptr %66, align 4
  store i32 %2288, ptr %2287, align 4
  %2289 = add i32 %2288, 1
  %2290 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2289, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3429

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3429: ; preds = %.cont.cont.i3394, %2286
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i2446

._crit_edge.i2446:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3429, %2202
  %2291 = add nuw nsw i32 %.060.i2444, 1
  %2292 = icmp slt i32 %2291, %2105
  br i1 %2292, label %2202, label %CuckooMap_insert_keyK_valueV.exit780

CuckooMap_insert_keyK_valueV.exit780:             ; preds = %._crit_edge.i2446, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2428.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1639.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1533.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1427, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1368, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1533, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1639
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2293 = sext i32 %192 to i64
  %2294 = add i64 %.0275513, %2293
  %2295 = add nsw i32 %.0266514, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit780, %CuckooMap_get_keyK.exit
  %.2277 = phi i64 [ %2294, %CuckooMap_insert_keyK_valueV.exit780 ], [ %.0275513, %CuckooMap_get_keyK.exit ]
  %.2268 = phi i32 [ %2295, %CuckooMap_insert_keyK_valueV.exit780 ], [ %.0266514, %CuckooMap_get_keyK.exit ]
  %2296 = add nuw nsw i32 %.0264515, 1
  %2297 = icmp slt i32 %.2268, %0
  %2298 = icmp slt i32 %2296, %60
  %spec.select = select i1 %2297, i1 %2298, i1 false
  br i1 %spec.select, label %68, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %.0275.lcssa = phi i64 [ 0, %1 ], [ %.2277, %._crit_edge1 ]
  %.0266.lcssa = phi i32 [ 0, %1 ], [ %.2268, %._crit_edge1 ]
  %2299 = icmp slt i32 %.0266.lcssa, %0
  br i1 %2299, label %._crit_edge.lr.ph.i, label %._crit_edge4

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge3._crit_edge
  %result.i355 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i355, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2300 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2301 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1675 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i1675, ptr noundef nonnull align 32 dereferenceable(29) %result.i355, i64 29, i1 false)
  %2302 = getelementptr i8, ptr %result.i.i1675, i64 29
  store i8 0, ptr %2302, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1675)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2303 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0266.lcssa) #17
  %result.i361 = call noalias align 64 dereferenceable_or_null(34) ptr @bump_malloc_inner(i64 noundef 34, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %2304 = load <33 x i8>, ptr @fhtqp__unique_keys_for_random_hit_test, align 64
  store <33 x i8> %2304, ptr %result.i361, align 64
  %2305 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2306 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2307 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1690 = call noalias dereferenceable_or_null(34) ptr @bump_malloc_inner(i64 noundef 34, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(33) %result.i.i1690, ptr noundef nonnull align 64 dereferenceable(33) %result.i361, i64 33, i1 false)
  %2308 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2309 = getelementptr i8, ptr %result.i.i1690, i64 33
  store i8 0, ptr %2309, align 1
  %puts.i815 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1690)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3._crit_edge, %._crit_edge.lr.ph.i
  %.0274 = phi i32 [ %.0266.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge3._crit_edge ]
  %2310 = call i64 @clock()
  %2311 = icmp sgt i32 %.0274, 0
  br i1 %2311, label %.lr.ph520.preheader, label %._crit_edge.lr.ph.i1849

.lr.ph520.preheader:                              ; preds = %._crit_edge4
  %2312 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  br label %.lr.ph520

.lr.ph520:                                        ; preds = %.lr.ph520.preheader, %._crit_edge5
  %.0263519 = phi i64 [ %.2, %._crit_edge5 ], [ 0, %.lr.ph520.preheader ]
  %.0269518 = phi i1 [ %.2271, %._crit_edge5 ], [ true, %.lr.ph520.preheader ]
  %.0272517 = phi i32 [ %2444, %._crit_edge5 ], [ 0, %.lr.ph520.preheader ]
  %2313 = zext nneg i32 %.0272517 to i64
  %2314 = shl nuw nsw i64 %2313, 2
  %2315 = getelementptr i8, ptr %result.i4.i, i64 %2314
  %2316 = load i32, ptr %2315, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %2316 to i160
  %2317 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %2318 = load ptr, ptr %40, align 8
  %2319 = call i32 %2318({ ptr, i160 } %2317) #7
  %2320 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %2321 = load i32, ptr %42, align 8
  %2322 = add i32 %2321, -1
  %2323 = and i32 %2322, %2319
  %2324 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2325 = sext i32 %2323 to i64
  %2326 = shl nsw i64 %2325, 5
  %2327 = getelementptr i8, ptr %2324, i64 %2326
  %2328 = load ptr, ptr %2327, align 8
  %2329 = icmp ne ptr %2328, @nil_typ
  %2330 = icmp ne ptr %2328, null
  %.not44.i1737 = and i1 %2329, %2330
  br i1 %.not44.i1737, label %2331, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761.thread

2331:                                             ; preds = %.lr.ph520
  %2332 = getelementptr i8, ptr %2327, i64 8
  %2333 = load i64, ptr %2332, align 4
  %.sroa_idx.i1741 = getelementptr i8, ptr %2327, i64 16
  %2334 = load i64, ptr %.sroa_idx.i1741, align 4
  %2335 = inttoptr i64 %2333 to ptr
  %2336 = inttoptr i64 %2334 to ptr
  %hash_coef_ptr.i.i46.i1742 = getelementptr i8, ptr %2328, i64 8
  %tbl_size_ptr.i.i47.i1743 = getelementptr i8, ptr %2328, i64 16
  %offset_tbl_ptr.i.i48.i1744 = getelementptr i8, ptr %2328, i64 40
  %hash_coef.i.i49.i1745 = load i64, ptr %hash_coef_ptr.i.i46.i1742, align 4, !noalias !233
  %tbl_size.i.i50.i1746 = load i64, ptr %tbl_size_ptr.i.i47.i1743, align 4, !noalias !233
  %offset_tbl.i.i51.i1747 = load ptr, ptr %offset_tbl_ptr.i.i48.i1744, align 8, !noalias !233
  %product.i.i.i52.i1748 = mul i64 %hash_coef.i.i49.i1745, 4015701072841558310
  %shifted.i.i.i53.i1749 = lshr i64 %product.i.i.i52.i1748, 32
  %xored.i.i.i54.i1750 = xor i64 %shifted.i.i.i53.i1749, %product.i.i.i52.i1748
  %hash.i.i.i55.i1751 = and i64 %xored.i.i.i54.i1750, %tbl_size.i.i50.i1746
  %offset_ptr.i.i56.i1752 = getelementptr i32, ptr %offset_tbl.i.i51.i1747, i64 %hash.i.i.i55.i1751
  %offset.i.i57.i1753 = load i32, ptr %offset_ptr.i.i56.i1752, align 4, !noalias !233
  %2337 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2328, 0
  %2338 = insertvalue { ptr, ptr, ptr, i32 } %2337, ptr %2335, 1
  %2339 = insertvalue { ptr, ptr, ptr, i32 } %2338, ptr %2336, 2
  %2340 = insertvalue { ptr, ptr, ptr, i32 } %2339, i32 %offset.i.i57.i1753, 3
  %2341 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2342 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2328) #35
  %2343 = sext i32 %offset.i.i57.i1753 to i64
  %2344 = getelementptr ptr, ptr %2328, i64 %2343
  %2345 = getelementptr i8, ptr %2344, i64 64
  %2346 = load ptr, ptr %2345, align 8
  %result.i.i1754 = call ptr %2346({ ptr, ptr, ptr, i32 } %2340, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2347 = call i32 %result.i.i1754({ ptr, ptr, ptr, i32 } %2340, { ptr, ptr, ptr, i32 } %2340, ptr nonnull align 8 %2) #7
  %2348 = icmp eq i32 %2347, %2319
  br i1 %2348, label %._crit_edge.i1755, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761.thread

._crit_edge.i1755:                                ; preds = %2331
  %2349 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2350 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2328)
  %2351 = getelementptr i8, ptr %2344, i64 48
  %2352 = load ptr, ptr %2351, align 8
  %result.i59.i1756 = call ptr %2352({ ptr, ptr, ptr, i32 } %2340, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2353 = call { ptr, i160 } %result.i59.i1756({ ptr, ptr, ptr, i32 } %2340, { ptr, ptr, ptr, i32 } %2340, ptr nonnull align 8 %2) #7
  %2354 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2355 = load ptr, ptr %41, align 8
  %2356 = call i1 %2355({ ptr, i160 } %2353, { ptr, i160 } %2317) #7
  br i1 %2356, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761.thread: ; preds = %._crit_edge.i1755, %.lr.ph520, %2331
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2365

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761: ; preds = %._crit_edge.i1755
  %2357 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2358 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2328)
  %2359 = getelementptr i8, ptr %2344, i64 56
  %2360 = load ptr, ptr %2359, align 8
  %result.i60.i1758 = call ptr %2360({ ptr, ptr, ptr, i32 } %2340, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2361 = call { ptr, i160 } %result.i60.i1758({ ptr, ptr, ptr, i32 } %2340, { ptr, ptr, ptr, i32 } %2340, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1759 = extractvalue { ptr, i160 } %2361, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2362 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2363 = icmp ne ptr %.fca.0.extract21.i1759, @nil_typ
  %2364 = icmp ne ptr %.fca.0.extract21.i1759, null
  %.not63.i852 = and i1 %2363, %2364
  br i1 %.not63.i852, label %CuckooMap_get_keyK.exit865, label %2365

2365:                                             ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761
  %2366 = add i32 %2319, 2127912214
  %2367 = shl i32 %2319, 12
  %2368 = add i32 %2366, %2367
  %2369 = ashr i32 %2368, 19
  %2370 = xor i32 %2368, %2369
  %2371 = xor i32 %2370, -949894596
  %2372 = add i32 %2371, 374761393
  %2373 = shl i32 %2371, 5
  %2374 = add i32 %2372, %2373
  %2375 = add i32 %2374, -744332180
  %2376 = shl i32 %2374, 9
  %2377 = xor i32 %2375, %2376
  %2378 = add i32 %2377, -42973499
  %2379 = shl i32 %2377, 3
  %2380 = add i32 %2378, %2379
  %2381 = ashr i32 %2380, 16
  %2382 = xor i32 %2380, %2381
  %2383 = xor i32 %2382, -1252372727
  %2384 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2385 = load i32, ptr %42, align 8
  %2386 = add i32 %2385, -1
  %2387 = and i32 %2386, %2383
  %2388 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2389 = sext i32 %2387 to i64
  %2390 = shl nsw i64 %2389, 5
  %2391 = getelementptr i8, ptr %2388, i64 %2390
  %2392 = load ptr, ptr %2391, align 8
  %2393 = icmp ne ptr %2392, @nil_typ
  %2394 = icmp ne ptr %2392, null
  %.not44.i1791 = and i1 %2393, %2394
  br i1 %.not44.i1791, label %2395, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1815

2395:                                             ; preds = %2365
  %2396 = getelementptr i8, ptr %2391, i64 8
  %2397 = load i64, ptr %2396, align 4
  %.sroa_idx.i1795 = getelementptr i8, ptr %2391, i64 16
  %2398 = load i64, ptr %.sroa_idx.i1795, align 4
  %2399 = inttoptr i64 %2397 to ptr
  %2400 = inttoptr i64 %2398 to ptr
  %hash_coef_ptr.i.i46.i1796 = getelementptr i8, ptr %2392, i64 8
  %tbl_size_ptr.i.i47.i1797 = getelementptr i8, ptr %2392, i64 16
  %offset_tbl_ptr.i.i48.i1798 = getelementptr i8, ptr %2392, i64 40
  %hash_coef.i.i49.i1799 = load i64, ptr %hash_coef_ptr.i.i46.i1796, align 4, !noalias !236
  %tbl_size.i.i50.i1800 = load i64, ptr %tbl_size_ptr.i.i47.i1797, align 4, !noalias !236
  %offset_tbl.i.i51.i1801 = load ptr, ptr %offset_tbl_ptr.i.i48.i1798, align 8, !noalias !236
  %product.i.i.i52.i1802 = mul i64 %hash_coef.i.i49.i1799, 4015701072841558310
  %shifted.i.i.i53.i1803 = lshr i64 %product.i.i.i52.i1802, 32
  %xored.i.i.i54.i1804 = xor i64 %shifted.i.i.i53.i1803, %product.i.i.i52.i1802
  %hash.i.i.i55.i1805 = and i64 %xored.i.i.i54.i1804, %tbl_size.i.i50.i1800
  %offset_ptr.i.i56.i1806 = getelementptr i32, ptr %offset_tbl.i.i51.i1801, i64 %hash.i.i.i55.i1805
  %offset.i.i57.i1807 = load i32, ptr %offset_ptr.i.i56.i1806, align 4, !noalias !236
  %2401 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2392, 0
  %2402 = insertvalue { ptr, ptr, ptr, i32 } %2401, ptr %2399, 1
  %2403 = insertvalue { ptr, ptr, ptr, i32 } %2402, ptr %2400, 2
  %2404 = insertvalue { ptr, ptr, ptr, i32 } %2403, i32 %offset.i.i57.i1807, 3
  %2405 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2406 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2392) #35
  %2407 = sext i32 %offset.i.i57.i1807 to i64
  %2408 = getelementptr ptr, ptr %2392, i64 %2407
  %2409 = getelementptr i8, ptr %2408, i64 64
  %2410 = load ptr, ptr %2409, align 8
  %result.i.i1808 = call ptr %2410({ ptr, ptr, ptr, i32 } %2404, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2411 = call i32 %result.i.i1808({ ptr, ptr, ptr, i32 } %2404, { ptr, ptr, ptr, i32 } %2404, ptr nonnull align 8 %2) #7
  %2412 = icmp eq i32 %2411, %2319
  br i1 %2412, label %._crit_edge.i1809, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1815

._crit_edge.i1809:                                ; preds = %2395
  %2413 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2414 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2392)
  %2415 = getelementptr i8, ptr %2408, i64 48
  %2416 = load ptr, ptr %2415, align 8
  %result.i59.i1810 = call ptr %2416({ ptr, ptr, ptr, i32 } %2404, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2417 = call { ptr, i160 } %result.i59.i1810({ ptr, ptr, ptr, i32 } %2404, { ptr, ptr, ptr, i32 } %2404, ptr nonnull align 8 %2) #7
  %2418 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2419 = load ptr, ptr %41, align 8
  %2420 = call i1 %2419({ ptr, i160 } %2417, { ptr, i160 } %2317) #7
  br i1 %2420, label %2421, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1815

2421:                                             ; preds = %._crit_edge.i1809
  %2422 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2423 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2392)
  %2424 = getelementptr i8, ptr %2408, i64 56
  %2425 = load ptr, ptr %2424, align 8
  %result.i60.i1812 = call ptr %2425({ ptr, ptr, ptr, i32 } %2404, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2426 = call { ptr, i160 } %result.i60.i1812({ ptr, ptr, ptr, i32 } %2404, { ptr, ptr, ptr, i32 } %2404, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1813 = extractvalue { ptr, i160 } %2426, 0
  %.fca.1.extract22.i1814 = extractvalue { ptr, i160 } %2426, 1
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1815

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1815: ; preds = %2365, %2395, %._crit_edge.i1809, %2421
  %.reg2mem43.sroa.3.077.i1792 = phi i160 [ %.fca.1.extract22.i1814, %2421 ], [ poison, %._crit_edge.i1809 ], [ poison, %2365 ], [ poison, %2395 ]
  %2427 = phi ptr [ %.fca.0.extract21.i1813, %2421 ], [ @nil_typ, %._crit_edge.i1809 ], [ @nil_typ, %2365 ], [ @nil_typ, %2395 ]
  %.reload40.fca.0.insert.i1793 = insertvalue { ptr, i160 } poison, ptr %2427, 0
  %.reload40.fca.1.insert.i1794 = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i1793, i160 %.reg2mem43.sroa.3.077.i1792, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2428 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2429 = icmp ne ptr %2427, @nil_typ
  %2430 = icmp ne ptr %2427, null
  %.not65.not.not.i858 = and i1 %2429, %2430
  %cond.fr.i859 = freeze i1 %.not65.not.not.i858
  %spec.select.i860 = select i1 %cond.fr.i859, ptr %2427, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit865

CuckooMap_get_keyK.exit865:                       ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1815
  %.pn.i861 = phi { ptr, i160 } [ %2361, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761 ], [ %.reload40.fca.1.insert.i1794, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1815 ]
  %2431 = phi ptr [ %.fca.0.extract21.i1759, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1761 ], [ %spec.select.i860, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1815 ]
  %2432 = icmp ne ptr %2431, @nil_typ
  %2433 = icmp ne ptr %2431, null
  %.not281 = and i1 %2432, %2433
  br i1 %.not281, label %2434, label %._crit_edge.lr.ph.i1830

2434:                                             ; preds = %CuckooMap_get_keyK.exit865
  %.fca.1.extract..sroa.354.0106.i862 = extractvalue { ptr, i160 } %.pn.i861, 1
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0106.i862 to i32
  %2435 = sext i32 %.sroa.2.8.extract.trunc to i64
  %2436 = add i64 %.0263519, %2435
  br label %._crit_edge5

._crit_edge.lr.ph.i1830:                          ; preds = %CuckooMap_get_keyK.exit865
  %result.i368 = call noalias align 64 dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %2437 = load <51 x i8>, ptr @swkjg_Error_Nil_returned_during_random_hit_test_for_key_, align 64
  store <51 x i8> %2437, ptr %result.i368, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2438 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2439 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1829 = call noalias dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(51) %result.i.i1829, ptr noundef nonnull align 64 dereferenceable(51) %result.i368, i64 51, i1 false)
  %2440 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2441 = getelementptr i8, ptr %result.i.i1829, i64 51
  store i8 0, ptr %2441, align 1
  %puts.i885 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1829)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2442 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2443 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %2316) #17
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %2434, %._crit_edge.lr.ph.i1830
  %.2271 = phi i1 [ %.0269518, %2434 ], [ false, %._crit_edge.lr.ph.i1830 ]
  %.2 = phi i64 [ %2436, %2434 ], [ %.0263519, %._crit_edge.lr.ph.i1830 ]
  %2444 = add nuw nsw i32 %.0272517, 1
  %2445 = icmp slt i32 %2444, %.0274
  br i1 %2445, label %.lr.ph520, label %._crit_edge.lr.ph.i1849

._crit_edge.lr.ph.i1849:                          ; preds = %._crit_edge5, %._crit_edge4
  %.0269.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.2271, %._crit_edge5 ]
  %.0263.lcssa = phi i64 [ 0, %._crit_edge4 ], [ %.2, %._crit_edge5 ]
  %2446 = call i64 @clock()
  %result.i374 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %result.i374, align 16
  %2447 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2448 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2449 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1848 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i1848, ptr noundef nonnull align 16 dereferenceable(14) %result.i374, i64 14, i1 false)
  %2450 = sub i64 %2446, %2310
  %2451 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2452 = getelementptr i8, ptr %result.i.i1848, i64 14
  store i8 0, ptr %2452, align 1
  %puts.i905 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1848)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i98.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98.i, align 16
  %result.i.i356.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i98.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356.i)
  %2453 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0274) #17
  %result.i104.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104.i, align 16
  %result.i.i370.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i104.i, i64 14, i1 false)
  %puts.i294.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370.i)
  %2454 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2450) #17
  %result.i110.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110.i, align 4
  %result.i.i389.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i110.i, i64 3, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  br i1 %2311, label %._crit_edge1.i, label %._crit_edge.lr.ph.i1868

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i1849
  %2455 = icmp sgt i64 %2450, 0
  br i1 %2455, label %2456, label %._crit_edge.lr.ph.i409.i

2456:                                             ; preds = %._crit_edge1.i
  %2457 = mul i64 %2450, 1000000
  %2458 = zext nneg i32 %.0274 to i64
  %2459 = sdiv i64 %2457, %2458
  br label %._crit_edge.lr.ph.i409.i

._crit_edge.lr.ph.i409.i:                         ; preds = %2456, %._crit_edge1.i
  %.0.i = phi i64 [ %2459, %2456 ], [ 0, %._crit_edge1.i ]
  %result.i115.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115.i, align 16
  %result.i.i408.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i115.i, i64 15, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  %2460 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i121.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121.i, align 4
  %2461 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i427.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i121.i, i64 3, i1 false)
  %2462 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  br label %._crit_edge.lr.ph.i1868

._crit_edge.lr.ph.i1868:                          ; preds = %._crit_edge.lr.ph.i1849, %._crit_edge.lr.ph.i409.i
  %.not = icmp eq i64 %.0263.lcssa, %.0275.lcssa
  %result.i378 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i378, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2463 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2464 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1867 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i1867, ptr noundef nonnull align 32 dereferenceable(18) %result.i378, i64 18, i1 false)
  %spec.select282 = select i1 %.not, i1 %.0269.lcssa, i1 false
  %2465 = getelementptr i8, ptr %result.i.i1867, i64 18
  store i8 0, ptr %2465, align 1
  %puts.i925 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1867)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %spec.select282, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %2466 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2467 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2468 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i1886 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <4 x i8> %., ptr %result.i.i1886, align 1
  %2469 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2470 = getelementptr i8, ptr %result.i.i1886, i64 4
  store i8 0, ptr %2470, align 1
  %puts.i945 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1886)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca i32, align 4
  %28 = alloca i32, align 4
  %29 = alloca i32, align 4
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i32, align 4
  %34 = alloca i32, align 4
  %oldProtect.i434 = alloca i32, align 4
  %oldProtect.i430 = alloca i32, align 4
  %oldProtect.i389 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0323.sroa.0 = alloca i8, align 8
  %result.i385 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i385, align 8
  %35 = getelementptr inbounds i8, ptr %result.i385, i64 8
  store ptr @_parameterization_Ptri32, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i385, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %36, align 8
  %37 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i385) #39
  %result.i386 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i387 = call i32 @VirtualProtect(ptr nofree %result.i386, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i386, ptr noalias nofree noundef nonnull readnone @lystgjlake, ptr noalias nofree noundef nonnull readnone @i32_hasher) #39
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i386) #40
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i386) #39
  %result.i388 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i389)
  %result.i390 = call i32 @VirtualProtect(ptr nofree %result.i388, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i389) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i389)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i388, ptr noalias nofree noundef nonnull readnone @vwrhczetrx, ptr noalias nofree noundef nonnull readnone @i32_eq) #39
  %ret.i391 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i388) #40
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i388) #39
  %40 = getelementptr inbounds i8, ptr %result.i385, i64 48
  store ptr %ret.i, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %result.i385, i64 56
  store ptr %ret.i391, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i385, i64 40
  store i32 8, ptr %42, align 8
  %result.i.i703 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %43 = getelementptr inbounds i8, ptr %result.i385, i64 24
  store ptr %result.i.i703, ptr %43, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %44 = getelementptr inbounds i8, ptr %result.i385, i64 32
  store ptr %result.i9.i, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  %result.i428 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i428, align 8
  %46 = getelementptr inbounds i8, ptr %result.i428, i64 8
  store ptr @_parameterization_Ptri1, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i428, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i428)
  %result.i429 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i430)
  %result.i431 = call i32 @VirtualProtect(ptr nofree %result.i429, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i430) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i430)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i429, ptr noalias nofree noundef nonnull readnone @mfvrojumog, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i432 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i429) #40
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i429)
  %result.i433 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i434)
  %result.i435 = call i32 @VirtualProtect(ptr nofree %result.i433, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i434) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i434)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i433, ptr noalias nofree noundef nonnull readnone @thuccbiyie, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i436 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i433) #40
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i433)
  %51 = getelementptr inbounds i8, ptr %result.i428, i64 48
  store ptr %ret.i432, ptr %51, align 8
  %52 = getelementptr inbounds i8, ptr %result.i428, i64 56
  store ptr %ret.i436, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i428, i64 40
  store i32 8, ptr %53, align 8
  %result.i.i742 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %54 = getelementptr inbounds i8, ptr %result.i428, i64 24
  store ptr %result.i.i742, ptr %54, align 8
  %result.i9.i743 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %55 = getelementptr inbounds i8, ptr %result.i428, i64 32
  store ptr %result.i9.i743, ptr %55, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %57 = mul i32 %0, 10
  %58 = icmp sgt i32 %0, 0
  %59 = icmp sgt i32 %57, 0
  %spec.select685 = and i1 %58, %59
  br i1 %spec.select685, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %62 = getelementptr inbounds i8, ptr %result.i385, i64 44
  %63 = getelementptr inbounds i8, ptr %result.i428, i64 44
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  br label %65

65:                                               ; preds = %.lr.ph, %._crit_edge1
  %66 = phi i32 [ 789, %.lr.ph ], [ %69, %._crit_edge1 ]
  %.0358687 = phi i32 [ 0, %.lr.ph ], [ %2287, %._crit_edge1 ]
  %.0361686 = phi i32 [ 0, %.lr.ph ], [ %.2363, %._crit_edge1 ]
  %67 = mul i32 %66, 1103515245
  %68 = add i32 %67, 12345
  %69 = and i32 %68, 2147483647
  %.sroa.0347.0.insert.ext = zext nneg i32 %69 to i160
  %70 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0347.0.insert.ext, 1
  %71 = load ptr, ptr %51, align 8
  %72 = call i32 %71({ ptr, i160 } %70) #7
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %74 = load i32, ptr %53, align 8
  %75 = add i32 %74, -1
  %76 = and i32 %75, %72
  %77 = load ptr, ptr %54, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %78 = sext i32 %76 to i64
  %79 = shl nsw i64 %78, 5
  %80 = getelementptr i8, ptr %77, i64 %79
  %81 = load ptr, ptr %80, align 8
  %82 = icmp ne ptr %81, @nil_typ
  %83 = icmp ne ptr %81, null
  %.not44.i = and i1 %82, %83
  br i1 %.not44.i, label %84, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

84:                                               ; preds = %65
  %85 = getelementptr i8, ptr %80, i64 8
  %86 = load i64, ptr %85, align 4
  %.sroa_idx.i = getelementptr i8, ptr %80, i64 16
  %87 = load i64, ptr %.sroa_idx.i, align 4
  %88 = inttoptr i64 %86 to ptr
  %89 = inttoptr i64 %87 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %81, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %81, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %81, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !239
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !239
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !239
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !239
  %90 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %81, 0
  %91 = insertvalue { ptr, ptr, ptr, i32 } %90, ptr %88, 1
  %92 = insertvalue { ptr, ptr, ptr, i32 } %91, ptr %89, 2
  %93 = insertvalue { ptr, ptr, ptr, i32 } %92, i32 %offset.i.i57.i, 3
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %81) #35
  %96 = sext i32 %offset.i.i57.i to i64
  %97 = getelementptr ptr, ptr %81, i64 %96
  %98 = getelementptr i8, ptr %97, i64 64
  %99 = load ptr, ptr %98, align 8
  %result.i.i = call ptr %99({ ptr, ptr, ptr, i32 } %93, ptr nocapture nofree noundef nonnull readonly %2) #16
  %100 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %93, { ptr, ptr, ptr, i32 } %93, ptr nonnull align 8 %2) #7
  %101 = icmp eq i32 %100, %72
  br i1 %101, label %._crit_edge.i1281, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i1281:                                ; preds = %84
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %81)
  %104 = getelementptr i8, ptr %97, i64 48
  %105 = load ptr, ptr %104, align 8
  %result.i59.i = call ptr %105({ ptr, ptr, ptr, i32 } %93, ptr nocapture nofree noundef nonnull readonly %2) #16
  %106 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %93, { ptr, ptr, ptr, i32 } %93, ptr nonnull align 8 %2) #7
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %108 = load ptr, ptr %52, align 8
  %109 = call i1 %108({ ptr, i160 } %106, { ptr, i160 } %70) #7
  br i1 %109, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i1281, %65, %84
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %118

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1281
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %111 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %81)
  %112 = getelementptr i8, ptr %97, i64 56
  %113 = load ptr, ptr %112, align 8
  %result.i60.i = call ptr %113({ ptr, ptr, ptr, i32 } %93, ptr nocapture nofree noundef nonnull readonly %2) #16
  %114 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %93, { ptr, ptr, ptr, i32 } %93, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %114, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %116 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %117 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %116, %117
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %118

118:                                              ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %119 = add i32 %72, 2127912214
  %120 = shl i32 %72, 12
  %121 = add i32 %119, %120
  %122 = ashr i32 %121, 19
  %123 = xor i32 %121, %122
  %124 = xor i32 %123, -949894596
  %125 = add i32 %124, 374761393
  %126 = shl i32 %124, 5
  %127 = add i32 %125, %126
  %128 = add i32 %127, -744332180
  %129 = shl i32 %127, 9
  %130 = xor i32 %128, %129
  %131 = add i32 %130, -42973499
  %132 = shl i32 %130, 3
  %133 = add i32 %131, %132
  %134 = ashr i32 %133, 16
  %135 = xor i32 %133, %134
  %136 = xor i32 %135, -1252372727
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %138 = load i32, ptr %53, align 8
  %139 = add i32 %138, -1
  %140 = and i32 %139, %136
  %141 = load ptr, ptr %55, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %142 = sext i32 %140 to i64
  %143 = shl nsw i64 %142, 5
  %144 = getelementptr i8, ptr %141, i64 %143
  %145 = load ptr, ptr %144, align 8
  %146 = icmp ne ptr %145, @nil_typ
  %147 = icmp ne ptr %145, null
  %.not44.i1310 = and i1 %146, %147
  br i1 %.not44.i1310, label %148, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1334

148:                                              ; preds = %118
  %149 = getelementptr i8, ptr %144, i64 8
  %150 = load i64, ptr %149, align 4
  %.sroa_idx.i1314 = getelementptr i8, ptr %144, i64 16
  %151 = load i64, ptr %.sroa_idx.i1314, align 4
  %152 = inttoptr i64 %150 to ptr
  %153 = inttoptr i64 %151 to ptr
  %hash_coef_ptr.i.i46.i1315 = getelementptr i8, ptr %145, i64 8
  %tbl_size_ptr.i.i47.i1316 = getelementptr i8, ptr %145, i64 16
  %offset_tbl_ptr.i.i48.i1317 = getelementptr i8, ptr %145, i64 40
  %hash_coef.i.i49.i1318 = load i64, ptr %hash_coef_ptr.i.i46.i1315, align 4, !noalias !242
  %tbl_size.i.i50.i1319 = load i64, ptr %tbl_size_ptr.i.i47.i1316, align 4, !noalias !242
  %offset_tbl.i.i51.i1320 = load ptr, ptr %offset_tbl_ptr.i.i48.i1317, align 8, !noalias !242
  %product.i.i.i52.i1321 = mul i64 %hash_coef.i.i49.i1318, 4015701072841558310
  %shifted.i.i.i53.i1322 = lshr i64 %product.i.i.i52.i1321, 32
  %xored.i.i.i54.i1323 = xor i64 %shifted.i.i.i53.i1322, %product.i.i.i52.i1321
  %hash.i.i.i55.i1324 = and i64 %xored.i.i.i54.i1323, %tbl_size.i.i50.i1319
  %offset_ptr.i.i56.i1325 = getelementptr i32, ptr %offset_tbl.i.i51.i1320, i64 %hash.i.i.i55.i1324
  %offset.i.i57.i1326 = load i32, ptr %offset_ptr.i.i56.i1325, align 4, !noalias !242
  %154 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %145, 0
  %155 = insertvalue { ptr, ptr, ptr, i32 } %154, ptr %152, 1
  %156 = insertvalue { ptr, ptr, ptr, i32 } %155, ptr %153, 2
  %157 = insertvalue { ptr, ptr, ptr, i32 } %156, i32 %offset.i.i57.i1326, 3
  %158 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %159 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %145) #35
  %160 = sext i32 %offset.i.i57.i1326 to i64
  %161 = getelementptr ptr, ptr %145, i64 %160
  %162 = getelementptr i8, ptr %161, i64 64
  %163 = load ptr, ptr %162, align 8
  %result.i.i1327 = call ptr %163({ ptr, ptr, ptr, i32 } %157, ptr nocapture nofree noundef nonnull readonly %2) #16
  %164 = call i32 %result.i.i1327({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr nonnull align 8 %2) #7
  %165 = icmp eq i32 %164, %72
  br i1 %165, label %._crit_edge.i1328, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1334

._crit_edge.i1328:                                ; preds = %148
  %166 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %145)
  %168 = getelementptr i8, ptr %161, i64 48
  %169 = load ptr, ptr %168, align 8
  %result.i59.i1329 = call ptr %169({ ptr, ptr, ptr, i32 } %157, ptr nocapture nofree noundef nonnull readonly %2) #16
  %170 = call { ptr, i160 } %result.i59.i1329({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr nonnull align 8 %2) #7
  %171 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %172 = load ptr, ptr %52, align 8
  %173 = call i1 %172({ ptr, i160 } %170, { ptr, i160 } %70) #7
  br i1 %173, label %174, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1334

174:                                              ; preds = %._crit_edge.i1328
  %175 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %176 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %145)
  %177 = getelementptr i8, ptr %161, i64 56
  %178 = load ptr, ptr %177, align 8
  %result.i60.i1331 = call ptr %178({ ptr, ptr, ptr, i32 } %157, ptr nocapture nofree noundef nonnull readonly %2) #16
  %179 = call { ptr, i160 } %result.i60.i1331({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1332 = extractvalue { ptr, i160 } %179, 0
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1334

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1334: ; preds = %118, %148, %._crit_edge.i1328, %174
  %180 = phi ptr [ %.fca.0.extract21.i1332, %174 ], [ @nil_typ, %._crit_edge.i1328 ], [ @nil_typ, %118 ], [ @nil_typ, %148 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %182 = icmp ne ptr %180, @nil_typ
  %183 = icmp ne ptr %180, null
  %.not65.not.not.i = and i1 %182, %183
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %180, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1334
  %184 = phi ptr [ %.fca.0.extract21.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1334 ]
  %185 = icmp eq ptr %184, @nil_typ
  %186 = icmp eq ptr %184, null
  %187 = or i1 %185, %186
  br i1 %187, label %188, label %._crit_edge1

188:                                              ; preds = %CuckooMap_get_keyK.exit
  %189 = add nuw i32 %69, 1
  %.sroa.0330.0.insert.ext = zext i32 %189 to i160
  %190 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0330.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %191 = load ptr, ptr %40, align 8
  %192 = call i32 %191({ ptr, i160 } %70) #7
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %194 = load i32, ptr %42, align 8
  %195 = add i32 %194, -1
  %196 = and i32 %195, %192
  %197 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %198 = sext i32 %196 to i64
  %199 = shl nsw i64 %198, 5
  %200 = getelementptr i8, ptr %197, i64 %199
  %201 = load ptr, ptr %200, align 8
  %202 = getelementptr i8, ptr %200, i64 8
  %203 = icmp ne ptr %201, @nil_typ
  %204 = icmp ne ptr %201, null
  %.not64.i = and i1 %203, %204
  br i1 %.not64.i, label %205, label %303

205:                                              ; preds = %188
  %206 = load i64, ptr %202, align 4
  %.sroa_idx.i1375 = getelementptr i8, ptr %200, i64 16
  %207 = load i64, ptr %.sroa_idx.i1375, align 4
  %208 = inttoptr i64 %206 to ptr
  %209 = inttoptr i64 %207 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %201, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %201, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %201, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !245
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !245
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !245
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !245
  %210 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %201, 0
  %211 = insertvalue { ptr, ptr, ptr, i32 } %210, ptr %208, 1
  %212 = insertvalue { ptr, ptr, ptr, i32 } %211, ptr %209, 2
  %213 = insertvalue { ptr, ptr, ptr, i32 } %212, i32 %offset.i.i77.i, 3
  %214 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %201) #35
  %216 = sext i32 %offset.i.i77.i to i64
  %217 = getelementptr ptr, ptr %201, i64 %216
  %218 = getelementptr i8, ptr %217, i64 64
  %219 = load ptr, ptr %218, align 8
  %result.i.i1376 = call ptr %219({ ptr, ptr, ptr, i32 } %213, ptr nocapture nofree noundef nonnull readonly %2) #16
  %220 = call i32 %result.i.i1376({ ptr, ptr, ptr, i32 } %213, { ptr, ptr, ptr, i32 } %213, ptr nonnull align 8 %2) #7
  %221 = icmp eq i32 %220, %192
  br i1 %221, label %._crit_edge.i1377, label %303

._crit_edge.i1377:                                ; preds = %205
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %201)
  %224 = getelementptr i8, ptr %217, i64 48
  %225 = load ptr, ptr %224, align 8
  %result.i79.i1378 = call ptr %225({ ptr, ptr, ptr, i32 } %213, ptr nocapture nofree noundef nonnull readonly %2) #16
  %226 = call { ptr, i160 } %result.i79.i1378({ ptr, ptr, ptr, i32 } %213, { ptr, ptr, ptr, i32 } %213, ptr nonnull align 8 %2) #7
  %227 = load ptr, ptr %41, align 8
  %228 = call i1 %227({ ptr, i160 } %226, { ptr, i160 } %70) #7
  br i1 %228, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %303

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1377
  %229 = load ptr, ptr %result.i385, align 8
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %231 = load ptr, ptr %35, align 8
  %232 = load ptr, ptr %229, align 8, !alias.scope !248
  %233 = getelementptr i8, ptr %232, i64 72
  %234 = load ptr, ptr %233, align 8, !alias.scope !248
  %result.i.i.i1379 = call { i64, i64 } %234(ptr nocapture nofree nonnull readonly %229) #5, !alias.scope !248
  %235 = extractvalue { i64, i64 } %result.i.i.i1379, 0
  %236 = extractvalue { i64, i64 } %result.i.i.i1379, 1
  %237 = urem i64 20, %236
  %238 = icmp eq i64 %237, 0
  %239 = sub i64 %236, %237
  %240 = select i1 %238, i64 0, i64 %239
  %241 = add i64 %235, 20
  %242 = add i64 %241, %240
  %243 = load ptr, ptr %231, align 8, !alias.scope !248
  %244 = getelementptr i8, ptr %243, i64 72
  %245 = load ptr, ptr %244, align 8, !alias.scope !248
  %result.i1.i.i1380 = call { i64, i64 } %245(ptr nocapture nofree nonnull readonly %231) #5, !alias.scope !248
  %246 = extractvalue { i64, i64 } %result.i1.i.i1380, 0
  %247 = extractvalue { i64, i64 } %result.i1.i.i1380, 1
  %248 = call i64 @llvm.umax.i64(i64 %236, i64 %247)
  %249 = call i64 @llvm.umax.i64(i64 %248, i64 8)
  %250 = urem i64 %242, %247
  %251 = icmp eq i64 %250, 0
  %252 = sub i64 %247, %250
  %253 = select i1 %251, i64 0, i64 %252
  %254 = add i64 %246, %242
  %255 = add i64 %254, %253
  %256 = urem i64 %255, %249
  %257 = icmp eq i64 %256, 0
  %258 = sub i64 %249, %256
  %259 = select i1 %257, i64 0, i64 %258
  %260 = add i64 %259, %255
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %260, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %229, ptr %result.i83.i, align 8
  %261 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %231, ptr %261, align 8
  %262 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %263 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %264 = load ptr, ptr %229, align 8
  %265 = getelementptr i8, ptr %264, i64 72
  %266 = load ptr, ptr %265, align 8
  %result.i.i118.i = call { i64, i64 } %266(ptr nocapture nofree nonnull readonly %229) #5
  %267 = extractvalue { i64, i64 } %result.i.i118.i, 1
  %268 = urem i64 20, %267
  %269 = icmp eq i64 %268, 0
  %reass.sub4286 = sub i64 %267, %268
  %270 = add i64 %reass.sub4286, 20
  %271 = select i1 %269, i64 20, i64 %270
  %272 = getelementptr i8, ptr %result.i83.i, i64 %271
  %273 = getelementptr i8, ptr %264, i64 64
  %274 = load ptr, ptr %273, align 8
  call void %274({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %229, ptr nocapture nofree writeonly %272) #1
  %275 = load ptr, ptr %result.i83.i, align 8
  %276 = load ptr, ptr %275, align 8
  %277 = getelementptr i8, ptr %276, i64 72
  %278 = load ptr, ptr %277, align 8
  %result.i.i119.i = call { i64, i64 } %278(ptr nocapture nofree nonnull readonly %275) #5
  %279 = extractvalue { i64, i64 } %result.i.i119.i, 0
  %280 = extractvalue { i64, i64 } %result.i.i119.i, 1
  %281 = urem i64 20, %280
  %282 = icmp eq i64 %281, 0
  %283 = sub i64 %280, %281
  %284 = select i1 %282, i64 0, i64 %283
  %285 = add i64 %279, 20
  %286 = add i64 %285, %284
  %287 = load ptr, ptr %261, align 8
  %288 = load ptr, ptr %287, align 8
  %289 = getelementptr i8, ptr %288, i64 72
  %290 = load ptr, ptr %289, align 8
  %result.i1.i120.i = call { i64, i64 } %290(ptr nocapture nofree nonnull readonly %287) #5
  %291 = extractvalue { i64, i64 } %result.i1.i120.i, 1
  %292 = urem i64 %286, %291
  %293 = icmp eq i64 %292, 0
  %294 = sub i64 %291, %292
  %295 = select i1 %293, i64 0, i64 %294
  %296 = getelementptr i8, ptr %result.i83.i, i64 %286
  %297 = getelementptr i8, ptr %296, i64 %295
  %298 = getelementptr i8, ptr %288, i64 64
  %299 = load ptr, ptr %298, align 8
  call void %299({ ptr, i160 } %190, ptr nocapture nofree nonnull readonly %287, ptr nocapture nofree writeonly %297) #1
  %300 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %301 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %192, ptr %301, align 8
  store ptr @Entry, ptr %200, align 8
  %302 = ptrtoint ptr %result.i83.i to i64
  store i64 %302, ptr %202, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %200, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

303:                                              ; preds = %._crit_edge.i1377, %188, %205
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %304 = add i32 %192, 2127912214
  %305 = shl i32 %192, 12
  %306 = add i32 %304, %305
  %307 = ashr i32 %306, 19
  %308 = xor i32 %306, %307
  %309 = xor i32 %308, -949894596
  %310 = add i32 %309, 374761393
  %311 = shl i32 %309, 5
  %312 = add i32 %310, %311
  %313 = add i32 %312, -744332180
  %314 = shl i32 %312, 9
  %315 = xor i32 %313, %314
  %316 = add i32 %315, -42973499
  %317 = shl i32 %315, 3
  %318 = add i32 %316, %317
  %319 = ashr i32 %318, 16
  %320 = xor i32 %318, %319
  %321 = xor i32 %320, -1252372727
  %322 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %323 = load i32, ptr %42, align 8
  %324 = add i32 %323, -1
  %325 = and i32 %324, %321
  %326 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %327 = sext i32 %325 to i64
  %328 = shl nsw i64 %327, 5
  %329 = getelementptr i8, ptr %326, i64 %328
  %330 = load ptr, ptr %329, align 8
  %331 = getelementptr i8, ptr %329, i64 8
  %332 = icmp ne ptr %330, @nil_typ
  %333 = icmp ne ptr %330, null
  %.not64.i1410 = and i1 %332, %333
  br i1 %.not64.i1410, label %334, label %433

334:                                              ; preds = %303
  %335 = load i64, ptr %331, align 4
  %.sroa_idx.i1412 = getelementptr i8, ptr %329, i64 16
  %336 = load i64, ptr %.sroa_idx.i1412, align 4
  %337 = inttoptr i64 %335 to ptr
  %338 = inttoptr i64 %336 to ptr
  %hash_coef_ptr.i.i66.i1413 = getelementptr i8, ptr %330, i64 8
  %tbl_size_ptr.i.i67.i1414 = getelementptr i8, ptr %330, i64 16
  %offset_tbl_ptr.i.i68.i1415 = getelementptr i8, ptr %330, i64 40
  %hash_coef.i.i69.i1416 = load i64, ptr %hash_coef_ptr.i.i66.i1413, align 4, !noalias !251
  %tbl_size.i.i70.i1417 = load i64, ptr %tbl_size_ptr.i.i67.i1414, align 4, !noalias !251
  %offset_tbl.i.i71.i1418 = load ptr, ptr %offset_tbl_ptr.i.i68.i1415, align 8, !noalias !251
  %product.i.i.i72.i1419 = mul i64 %hash_coef.i.i69.i1416, 4015701072841558310
  %shifted.i.i.i73.i1420 = lshr i64 %product.i.i.i72.i1419, 32
  %xored.i.i.i74.i1421 = xor i64 %shifted.i.i.i73.i1420, %product.i.i.i72.i1419
  %hash.i.i.i75.i1422 = and i64 %xored.i.i.i74.i1421, %tbl_size.i.i70.i1417
  %offset_ptr.i.i76.i1423 = getelementptr i32, ptr %offset_tbl.i.i71.i1418, i64 %hash.i.i.i75.i1422
  %offset.i.i77.i1424 = load i32, ptr %offset_ptr.i.i76.i1423, align 4, !noalias !251
  %339 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %330, 0
  %340 = insertvalue { ptr, ptr, ptr, i32 } %339, ptr %337, 1
  %341 = insertvalue { ptr, ptr, ptr, i32 } %340, ptr %338, 2
  %342 = insertvalue { ptr, ptr, ptr, i32 } %341, i32 %offset.i.i77.i1424, 3
  %343 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %344 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %330) #35
  %345 = sext i32 %offset.i.i77.i1424 to i64
  %346 = getelementptr ptr, ptr %330, i64 %345
  %347 = getelementptr i8, ptr %346, i64 64
  %348 = load ptr, ptr %347, align 8
  %result.i.i1425 = call ptr %348({ ptr, ptr, ptr, i32 } %342, ptr nocapture nofree noundef nonnull readonly %2) #16
  %349 = call i32 %result.i.i1425({ ptr, ptr, ptr, i32 } %342, { ptr, ptr, ptr, i32 } %342, ptr nonnull align 8 %2) #7
  %350 = icmp eq i32 %349, %192
  br i1 %350, label %._crit_edge.i1426, label %433

._crit_edge.i1426:                                ; preds = %334
  %351 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %352 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %330)
  %353 = getelementptr i8, ptr %346, i64 48
  %354 = load ptr, ptr %353, align 8
  %result.i79.i1427 = call ptr %354({ ptr, ptr, ptr, i32 } %342, ptr nocapture nofree noundef nonnull readonly %2) #16
  %355 = call { ptr, i160 } %result.i79.i1427({ ptr, ptr, ptr, i32 } %342, { ptr, ptr, ptr, i32 } %342, ptr nonnull align 8 %2) #7
  %356 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %357 = load ptr, ptr %41, align 8
  %358 = call i1 %357({ ptr, i160 } %355, { ptr, i160 } %70) #7
  br i1 %358, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1439, label %433

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1439: ; preds = %._crit_edge.i1426
  %359 = load ptr, ptr %result.i385, align 8
  %360 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %361 = load ptr, ptr %35, align 8
  %362 = load ptr, ptr %359, align 8, !alias.scope !254
  %363 = getelementptr i8, ptr %362, i64 72
  %364 = load ptr, ptr %363, align 8, !alias.scope !254
  %result.i.i.i1431 = call { i64, i64 } %364(ptr nocapture nofree nonnull readonly %359) #5, !alias.scope !254
  %365 = extractvalue { i64, i64 } %result.i.i.i1431, 0
  %366 = extractvalue { i64, i64 } %result.i.i.i1431, 1
  %367 = urem i64 20, %366
  %368 = icmp eq i64 %367, 0
  %369 = sub i64 %366, %367
  %370 = select i1 %368, i64 0, i64 %369
  %371 = add i64 %365, 20
  %372 = add i64 %371, %370
  %373 = load ptr, ptr %361, align 8, !alias.scope !254
  %374 = getelementptr i8, ptr %373, i64 72
  %375 = load ptr, ptr %374, align 8, !alias.scope !254
  %result.i1.i.i1432 = call { i64, i64 } %375(ptr nocapture nofree nonnull readonly %361) #5, !alias.scope !254
  %376 = extractvalue { i64, i64 } %result.i1.i.i1432, 0
  %377 = extractvalue { i64, i64 } %result.i1.i.i1432, 1
  %378 = call i64 @llvm.umax.i64(i64 %366, i64 %377)
  %379 = call i64 @llvm.umax.i64(i64 %378, i64 8)
  %380 = urem i64 %372, %377
  %381 = icmp eq i64 %380, 0
  %382 = sub i64 %377, %380
  %383 = select i1 %381, i64 0, i64 %382
  %384 = add i64 %376, %372
  %385 = add i64 %384, %383
  %386 = urem i64 %385, %379
  %387 = icmp eq i64 %386, 0
  %388 = sub i64 %379, %386
  %389 = select i1 %387, i64 0, i64 %388
  %390 = add i64 %389, %385
  %result.i83.i1433 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %390, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %359, ptr %result.i83.i1433, align 8
  %391 = getelementptr inbounds i8, ptr %result.i83.i1433, i64 8
  store ptr %361, ptr %391, align 8
  %392 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1433)
  %393 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %394 = load ptr, ptr %359, align 8
  %395 = getelementptr i8, ptr %394, i64 72
  %396 = load ptr, ptr %395, align 8
  %result.i.i118.i1434 = call { i64, i64 } %396(ptr nocapture nofree nonnull readonly %359) #5
  %397 = extractvalue { i64, i64 } %result.i.i118.i1434, 1
  %398 = urem i64 20, %397
  %399 = icmp eq i64 %398, 0
  %reass.sub4285 = sub i64 %397, %398
  %400 = add i64 %reass.sub4285, 20
  %401 = select i1 %399, i64 20, i64 %400
  %402 = getelementptr i8, ptr %result.i83.i1433, i64 %401
  %403 = getelementptr i8, ptr %394, i64 64
  %404 = load ptr, ptr %403, align 8
  call void %404({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %359, ptr nocapture nofree writeonly %402) #1
  %405 = load ptr, ptr %result.i83.i1433, align 8
  %406 = load ptr, ptr %405, align 8
  %407 = getelementptr i8, ptr %406, i64 72
  %408 = load ptr, ptr %407, align 8
  %result.i.i119.i1436 = call { i64, i64 } %408(ptr nocapture nofree nonnull readonly %405) #5
  %409 = extractvalue { i64, i64 } %result.i.i119.i1436, 0
  %410 = extractvalue { i64, i64 } %result.i.i119.i1436, 1
  %411 = urem i64 20, %410
  %412 = icmp eq i64 %411, 0
  %413 = sub i64 %410, %411
  %414 = select i1 %412, i64 0, i64 %413
  %415 = add i64 %409, 20
  %416 = add i64 %415, %414
  %417 = load ptr, ptr %391, align 8
  %418 = load ptr, ptr %417, align 8
  %419 = getelementptr i8, ptr %418, i64 72
  %420 = load ptr, ptr %419, align 8
  %result.i1.i120.i1437 = call { i64, i64 } %420(ptr nocapture nofree nonnull readonly %417) #5
  %421 = extractvalue { i64, i64 } %result.i1.i120.i1437, 1
  %422 = urem i64 %416, %421
  %423 = icmp eq i64 %422, 0
  %424 = sub i64 %421, %422
  %425 = select i1 %423, i64 0, i64 %424
  %426 = getelementptr i8, ptr %result.i83.i1433, i64 %416
  %427 = getelementptr i8, ptr %426, i64 %425
  %428 = getelementptr i8, ptr %418, i64 64
  %429 = load ptr, ptr %428, align 8
  call void %429({ ptr, i160 } %190, ptr nocapture nofree nonnull readonly %417, ptr nocapture nofree writeonly %427) #1
  %430 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %431 = getelementptr inbounds i8, ptr %result.i83.i1433, i64 16
  store i32 %192, ptr %431, align 8
  store ptr @Entry, ptr %329, align 8
  %432 = ptrtoint ptr %result.i83.i1433 to i64
  store i64 %432, ptr %331, align 4
  %.sroa_idx28.i1438 = getelementptr i8, ptr %329, i64 24
  store i32 10, ptr %.sroa_idx28.i1438, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

433:                                              ; preds = %._crit_edge.i1426, %303, %334
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %434 = load i32, ptr %62, align 4
  %435 = load i32, ptr %42, align 8
  %.not.i = icmp slt i32 %434, %435
  br i1 %.not.i, label %._crit_edge.i, label %436

436:                                              ; preds = %433
  %437 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %438 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %439 = load ptr, ptr %43, align 8
  %440 = load ptr, ptr %44, align 8
  %441 = shl i32 %435, 1
  %spec.select.i1454 = call i32 @llvm.smax.i32(i32 %441, i32 16)
  store i32 %spec.select.i1454, ptr %42, align 8
  %442 = zext nneg i32 %spec.select.i1454 to i64
  %443 = shl nuw nsw i64 %442, 5
  %result.i.i1455 = call noalias ptr @bump_malloc_inner(i64 noundef %443, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1455, ptr %43, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %443, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i, ptr %44, align 8
  store i32 0, ptr %62, align 4
  %444 = icmp sgt i32 %435, 0
  br i1 %444, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %436, %._crit_edge.i2432
  %.060.i = phi i32 [ %533, %._crit_edge.i2432 ], [ 0, %436 ]
  %445 = zext nneg i32 %.060.i to i64
  %446 = shl nuw nsw i64 %445, 5
  %447 = getelementptr i8, ptr %439, i64 %446
  %448 = load ptr, ptr %447, align 8
  %449 = icmp ne ptr %448, @nil_typ
  %450 = icmp ne ptr %448, null
  %.not16.i = and i1 %449, %450
  br i1 %.not16.i, label %451, label %._crit_edge.i2432

451:                                              ; preds = %.lr.ph.i
  %452 = getelementptr i8, ptr %447, i64 8
  %453 = load <2 x i64>, ptr %452, align 4
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %448, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %448, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %448, i64 40
  %454 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %26)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !257
  %455 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %456 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %458

458:                                              ; preds = %.cont.cont.i2975, %451
  %.0566.i2963 = phi i32 [ 0, %451 ], [ %462, %.cont.cont.i2975 ]
  %.070565.i2964 = phi i1 [ true, %451 ], [ %524, %.cont.cont.i2975 ]
  %.sroa.0.0564.i2965 = phi ptr [ %448, %451 ], [ %vptr.i142.sroa.speculated.i2978, %.cont.cont.i2975 ]
  %.sroa.17.0561.i2968 = phi i32 [ %offset.i.i121.i, %451 ], [ %offset.i.i154.i2992, %.cont.cont.i2975 ]
  %459 = phi <2 x i64> [ %453, %451 ], [ %523, %.cont.cont.i2975 ]
  %460 = extractelement <2 x i64> %459, i64 1
  %.sroa.12.0562.i2967 = inttoptr i64 %460 to ptr
  %461 = extractelement <2 x i64> %459, i64 0
  %.sroa.6.0563.i2966 = inttoptr i64 %461 to ptr
  %462 = add nuw nsw i32 %.0566.i2963, 1
  %463 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i2965, 0
  %464 = insertvalue { ptr, ptr, ptr, i32 } %463, ptr %.sroa.6.0563.i2966, 1
  %465 = insertvalue { ptr, ptr, ptr, i32 } %464, ptr %.sroa.12.0562.i2967, 2
  %466 = insertvalue { ptr, ptr, ptr, i32 } %465, i32 %.sroa.17.0561.i2968, 3
  %467 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i2965)
  %468 = sext i32 %.sroa.17.0561.i2968 to i64
  %469 = getelementptr ptr, ptr %.sroa.0.0564.i2965, i64 %468
  %470 = getelementptr i8, ptr %469, i64 64
  %471 = load ptr, ptr %470, align 8
  %result.i125.i = call ptr %471({ ptr, ptr, ptr, i32 } %466, ptr nocapture nofree noundef nonnull readonly %2) #16
  %472 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %466, { ptr, ptr, ptr, i32 } %466, ptr nonnull align 8 %2) #7
  br i1 %.070565.i2964, label %473, label %489

473:                                              ; preds = %458
  %474 = load i32, ptr %42, align 8
  %475 = add i32 %474, -1
  %476 = and i32 %475, %472
  %477 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %478 = load ptr, ptr %43, align 8
  %479 = sext i32 %476 to i64
  %480 = shl nsw i64 %479, 5
  %481 = getelementptr i8, ptr %478, i64 %480
  %482 = load ptr, ptr %481, align 8
  %483 = getelementptr i8, ptr %481, i64 8
  %484 = load i160, ptr %483, align 4
  store ptr %.sroa.0.0564.i2965, ptr %481, align 8
  store i64 %461, ptr %483, align 4
  %.sroa_idx157.i2994 = getelementptr i8, ptr %481, i64 16
  store i64 %460, ptr %.sroa_idx157.i2994, align 4
  %.sroa_idx158.i2995 = getelementptr i8, ptr %481, i64 24
  store i32 %.sroa.17.0561.i2968, ptr %.sroa_idx158.i2995, align 4
  %485 = icmp ne ptr %482, @nil_typ
  %486 = icmp ne ptr %482, null
  %.not92.i2996 = and i1 %485, %486
  %extract.i2998 = lshr i160 %484, 64
  %487 = insertelement <2 x i160> poison, i160 %484, i64 0
  %488 = insertelement <2 x i160> %487, i160 %extract.i2998, i64 1
  br i1 %.not92.i2996, label %.cont.cont.i2975, label %528

489:                                              ; preds = %458
  %490 = add i32 %472, 2127912214
  %491 = shl i32 %472, 12
  %492 = add i32 %490, %491
  %493 = ashr i32 %492, 19
  %494 = xor i32 %492, %493
  %495 = xor i32 %494, -949894596
  %496 = add i32 %495, 374761393
  %497 = shl i32 %495, 5
  %498 = add i32 %496, %497
  %499 = add i32 %498, -744332180
  %500 = shl i32 %498, 9
  %501 = xor i32 %499, %500
  %502 = add i32 %501, -42973499
  %503 = shl i32 %501, 3
  %504 = add i32 %502, %503
  %505 = ashr i32 %504, 16
  %506 = xor i32 %504, %505
  %507 = xor i32 %506, -1252372727
  %508 = load i32, ptr %42, align 8
  %509 = add i32 %508, -1
  %510 = and i32 %509, %507
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %512 = load ptr, ptr %44, align 8
  %513 = sext i32 %510 to i64
  %514 = shl nsw i64 %513, 5
  %515 = getelementptr i8, ptr %512, i64 %514
  %516 = load ptr, ptr %515, align 8
  %517 = getelementptr i8, ptr %515, i64 8
  %518 = load i160, ptr %517, align 4
  store ptr %.sroa.0.0564.i2965, ptr %515, align 8
  store i64 %461, ptr %517, align 4
  %.sroa_idx161.i2969 = getelementptr i8, ptr %515, i64 16
  store i64 %460, ptr %.sroa_idx161.i2969, align 4
  %.sroa_idx162.i2970 = getelementptr i8, ptr %515, i64 24
  store i32 %.sroa.17.0561.i2968, ptr %.sroa_idx162.i2970, align 4
  %519 = icmp ne ptr %516, @nil_typ
  %520 = icmp ne ptr %516, null
  %.not90.i2971 = and i1 %519, %520
  %extract607.i2973 = lshr i160 %518, 64
  %521 = insertelement <2 x i160> poison, i160 %518, i64 0
  %522 = insertelement <2 x i160> %521, i160 %extract607.i2973, i64 1
  br i1 %.not90.i2971, label %.cont.cont.i2975, label %528

.cont.cont.i2975:                                 ; preds = %489, %473
  %vptr.i142.sroa.speculated.i2978 = phi ptr [ %482, %473 ], [ %516, %489 ]
  %.in = phi <2 x i160> [ %488, %473 ], [ %522, %489 ]
  %523 = trunc <2 x i160> %.in to <2 x i64>
  %524 = xor i1 %.070565.i2964, true
  %hash_coef_ptr.i.i143.i2981 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2978, i64 8
  %tbl_size_ptr.i.i144.i2982 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2978, i64 16
  %offset_tbl_ptr.i.i145.i2983 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i2978, i64 40
  %hash_coef.i.i146.i2984 = load i64, ptr %hash_coef_ptr.i.i143.i2981, align 4
  %tbl_size.i.i147.i2985 = load i64, ptr %tbl_size_ptr.i.i144.i2982, align 4
  %offset_tbl.i.i148.i2986 = load ptr, ptr %offset_tbl_ptr.i.i145.i2983, align 8
  %product.i.i.i149.i2987 = mul i64 %hash_coef.i.i146.i2984, 4015701072841558310
  %shifted.i.i.i150.i2988 = lshr i64 %product.i.i.i149.i2987, 32
  %xored.i.i.i151.i2989 = xor i64 %shifted.i.i.i150.i2988, %product.i.i.i149.i2987
  %hash.i.i.i152.i2990 = and i64 %xored.i.i.i151.i2989, %tbl_size.i.i147.i2985
  %offset_ptr.i.i153.i2991 = getelementptr i32, ptr %offset_tbl.i.i148.i2986, i64 %hash.i.i.i152.i2990
  %offset.i.i154.i2992 = load i32, ptr %offset_ptr.i.i153.i2991, align 4
  %525 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %526 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %527 = icmp ult i32 %.0566.i2963, 99
  br i1 %527, label %458, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3000

528:                                              ; preds = %489, %473
  %529 = phi ptr [ %26, %489 ], [ %25, %473 ]
  %530 = load i32, ptr %62, align 4
  store i32 %530, ptr %529, align 4
  %531 = add i32 %530, 1
  %532 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %531, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3000

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3000: ; preds = %.cont.cont.i2975, %528
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  br label %._crit_edge.i2432

._crit_edge.i2432:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3000, %.lr.ph.i
  %533 = add nuw nsw i32 %.060.i, 1
  %534 = icmp slt i32 %533, %435
  br i1 %534, label %.lr.ph.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i2432, %._crit_edge.i2451
  %.060.i2449 = phi i32 [ %623, %._crit_edge.i2451 ], [ 0, %._crit_edge.i2432 ]
  %535 = zext nneg i32 %.060.i2449 to i64
  %536 = shl nuw nsw i64 %535, 5
  %537 = getelementptr i8, ptr %440, i64 %536
  %538 = load ptr, ptr %537, align 8
  %539 = icmp ne ptr %538, @nil_typ
  %540 = icmp ne ptr %538, null
  %.not16.i2450 = and i1 %539, %540
  br i1 %.not16.i2450, label %541, label %._crit_edge.i2451

541:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %542 = getelementptr i8, ptr %537, i64 8
  %543 = load <2 x i64>, ptr %542, align 4
  %hash_coef_ptr.i.i18.i2453 = getelementptr i8, ptr %538, i64 8
  %tbl_size_ptr.i.i19.i2454 = getelementptr i8, ptr %538, i64 16
  %offset_tbl_ptr.i.i20.i2455 = getelementptr i8, ptr %538, i64 40
  %544 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %hash_coef.i.i99.i3018 = load i64, ptr %hash_coef_ptr.i.i18.i2453, align 4, !noalias !22
  %tbl_size.i.i100.i3019 = load i64, ptr %tbl_size_ptr.i.i19.i2454, align 4, !noalias !22
  %offset_tbl.i.i101.i3020 = load ptr, ptr %offset_tbl_ptr.i.i20.i2455, align 8, !noalias !22
  %product.i.i.i102.i3021 = mul i64 %hash_coef.i.i99.i3018, 4015701072841558310
  %shifted.i.i.i103.i3022 = lshr i64 %product.i.i.i102.i3021, 32
  %xored.i.i.i104.i3023 = xor i64 %shifted.i.i.i103.i3022, %product.i.i.i102.i3021
  %hash.i.i.i105.i3024 = and i64 %xored.i.i.i104.i3023, %tbl_size.i.i100.i3019
  %offset_ptr.i.i106.i3025 = getelementptr i32, ptr %offset_tbl.i.i101.i3020, i64 %hash.i.i.i105.i3024
  %offset.i.i121.i3026 = load i32, ptr %offset_ptr.i.i106.i3025, align 4, !noalias !260
  %545 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %546 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %548

548:                                              ; preds = %.cont.cont.i3047, %541
  %.0566.i3027 = phi i32 [ 0, %541 ], [ %552, %.cont.cont.i3047 ]
  %.070565.i3028 = phi i1 [ true, %541 ], [ %614, %.cont.cont.i3047 ]
  %.sroa.0.0564.i3029 = phi ptr [ %538, %541 ], [ %vptr.i142.sroa.speculated.i3050, %.cont.cont.i3047 ]
  %.sroa.17.0561.i3032 = phi i32 [ %offset.i.i121.i3026, %541 ], [ %offset.i.i154.i3064, %.cont.cont.i3047 ]
  %549 = phi <2 x i64> [ %543, %541 ], [ %613, %.cont.cont.i3047 ]
  %550 = extractelement <2 x i64> %549, i64 1
  %.sroa.12.0562.i3031 = inttoptr i64 %550 to ptr
  %551 = extractelement <2 x i64> %549, i64 0
  %.sroa.6.0563.i3030 = inttoptr i64 %551 to ptr
  %552 = add nuw nsw i32 %.0566.i3027, 1
  %553 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3029, 0
  %554 = insertvalue { ptr, ptr, ptr, i32 } %553, ptr %.sroa.6.0563.i3030, 1
  %555 = insertvalue { ptr, ptr, ptr, i32 } %554, ptr %.sroa.12.0562.i3031, 2
  %556 = insertvalue { ptr, ptr, ptr, i32 } %555, i32 %.sroa.17.0561.i3032, 3
  %557 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3029)
  %558 = sext i32 %.sroa.17.0561.i3032 to i64
  %559 = getelementptr ptr, ptr %.sroa.0.0564.i3029, i64 %558
  %560 = getelementptr i8, ptr %559, i64 64
  %561 = load ptr, ptr %560, align 8
  %result.i125.i3033 = call ptr %561({ ptr, ptr, ptr, i32 } %556, ptr nocapture nofree noundef nonnull readonly %2) #16
  %562 = call i32 %result.i125.i3033({ ptr, ptr, ptr, i32 } %556, { ptr, ptr, ptr, i32 } %556, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3028, label %563, label %579

563:                                              ; preds = %548
  %564 = load i32, ptr %42, align 8
  %565 = add i32 %564, -1
  %566 = and i32 %565, %562
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %568 = load ptr, ptr %43, align 8
  %569 = sext i32 %566 to i64
  %570 = shl nsw i64 %569, 5
  %571 = getelementptr i8, ptr %568, i64 %570
  %572 = load ptr, ptr %571, align 8
  %573 = getelementptr i8, ptr %571, i64 8
  %574 = load i160, ptr %573, align 4
  store ptr %.sroa.0.0564.i3029, ptr %571, align 8
  store i64 %551, ptr %573, align 4
  %.sroa_idx157.i3076 = getelementptr i8, ptr %571, i64 16
  store i64 %550, ptr %.sroa_idx157.i3076, align 4
  %.sroa_idx158.i3077 = getelementptr i8, ptr %571, i64 24
  store i32 %.sroa.17.0561.i3032, ptr %.sroa_idx158.i3077, align 4
  %575 = icmp ne ptr %572, @nil_typ
  %576 = icmp ne ptr %572, null
  %.not92.i3078 = and i1 %575, %576
  %extract.i3080 = lshr i160 %574, 64
  %577 = insertelement <2 x i160> poison, i160 %574, i64 0
  %578 = insertelement <2 x i160> %577, i160 %extract.i3080, i64 1
  br i1 %.not92.i3078, label %.cont.cont.i3047, label %618

579:                                              ; preds = %548
  %580 = add i32 %562, 2127912214
  %581 = shl i32 %562, 12
  %582 = add i32 %580, %581
  %583 = ashr i32 %582, 19
  %584 = xor i32 %582, %583
  %585 = xor i32 %584, -949894596
  %586 = add i32 %585, 374761393
  %587 = shl i32 %585, 5
  %588 = add i32 %586, %587
  %589 = add i32 %588, -744332180
  %590 = shl i32 %588, 9
  %591 = xor i32 %589, %590
  %592 = add i32 %591, -42973499
  %593 = shl i32 %591, 3
  %594 = add i32 %592, %593
  %595 = ashr i32 %594, 16
  %596 = xor i32 %594, %595
  %597 = xor i32 %596, -1252372727
  %598 = load i32, ptr %42, align 8
  %599 = add i32 %598, -1
  %600 = and i32 %599, %597
  %601 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %602 = load ptr, ptr %44, align 8
  %603 = sext i32 %600 to i64
  %604 = shl nsw i64 %603, 5
  %605 = getelementptr i8, ptr %602, i64 %604
  %606 = load ptr, ptr %605, align 8
  %607 = getelementptr i8, ptr %605, i64 8
  %608 = load i160, ptr %607, align 4
  store ptr %.sroa.0.0564.i3029, ptr %605, align 8
  store i64 %551, ptr %607, align 4
  %.sroa_idx161.i3037 = getelementptr i8, ptr %605, i64 16
  store i64 %550, ptr %.sroa_idx161.i3037, align 4
  %.sroa_idx162.i3038 = getelementptr i8, ptr %605, i64 24
  store i32 %.sroa.17.0561.i3032, ptr %.sroa_idx162.i3038, align 4
  %609 = icmp ne ptr %606, @nil_typ
  %610 = icmp ne ptr %606, null
  %.not90.i3039 = and i1 %609, %610
  %extract607.i3041 = lshr i160 %608, 64
  %611 = insertelement <2 x i160> poison, i160 %608, i64 0
  %612 = insertelement <2 x i160> %611, i160 %extract607.i3041, i64 1
  br i1 %.not90.i3039, label %.cont.cont.i3047, label %618

.cont.cont.i3047:                                 ; preds = %579, %563
  %vptr.i142.sroa.speculated.i3050 = phi ptr [ %572, %563 ], [ %606, %579 ]
  %.in4289 = phi <2 x i160> [ %578, %563 ], [ %612, %579 ]
  %613 = trunc <2 x i160> %.in4289 to <2 x i64>
  %614 = xor i1 %.070565.i3028, true
  %hash_coef_ptr.i.i143.i3053 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3050, i64 8
  %tbl_size_ptr.i.i144.i3054 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3050, i64 16
  %offset_tbl_ptr.i.i145.i3055 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3050, i64 40
  %hash_coef.i.i146.i3056 = load i64, ptr %hash_coef_ptr.i.i143.i3053, align 4
  %tbl_size.i.i147.i3057 = load i64, ptr %tbl_size_ptr.i.i144.i3054, align 4
  %offset_tbl.i.i148.i3058 = load ptr, ptr %offset_tbl_ptr.i.i145.i3055, align 8
  %product.i.i.i149.i3059 = mul i64 %hash_coef.i.i146.i3056, 4015701072841558310
  %shifted.i.i.i150.i3060 = lshr i64 %product.i.i.i149.i3059, 32
  %xored.i.i.i151.i3061 = xor i64 %shifted.i.i.i150.i3060, %product.i.i.i149.i3059
  %hash.i.i.i152.i3062 = and i64 %xored.i.i.i151.i3061, %tbl_size.i.i147.i3057
  %offset_ptr.i.i153.i3063 = getelementptr i32, ptr %offset_tbl.i.i148.i3058, i64 %hash.i.i.i152.i3062
  %offset.i.i154.i3064 = load i32, ptr %offset_ptr.i.i153.i3063, align 4
  %615 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %616 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %617 = icmp ult i32 %.0566.i3027, 99
  br i1 %617, label %548, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3082

618:                                              ; preds = %579, %563
  %619 = phi ptr [ %24, %579 ], [ %23, %563 ]
  %620 = load i32, ptr %62, align 4
  store i32 %620, ptr %619, align 4
  %621 = add i32 %620, 1
  %622 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %621, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3082

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3082: ; preds = %.cont.cont.i3047, %618
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %._crit_edge.i2451

._crit_edge.i2451:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3082, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %623 = add nuw nsw i32 %.060.i2449, 1
  %624 = icmp slt i32 %623, %435
  br i1 %624, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i2451, %436, %433
  %625 = load ptr, ptr %result.i385, align 8
  %626 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %627 = load ptr, ptr %35, align 8
  %628 = load ptr, ptr %625, align 8
  %629 = getelementptr i8, ptr %628, i64 72
  %630 = load ptr, ptr %629, align 8
  %result.i.i.i = call { i64, i64 } %630(ptr nocapture nofree nonnull readonly %625) #5
  %631 = extractvalue { i64, i64 } %result.i.i.i, 0
  %632 = extractvalue { i64, i64 } %result.i.i.i, 1
  %633 = urem i64 20, %632
  %634 = icmp eq i64 %633, 0
  %635 = sub i64 %632, %633
  %636 = select i1 %634, i64 0, i64 %635
  %637 = add i64 %631, 20
  %638 = add i64 %637, %636
  %639 = load ptr, ptr %627, align 8
  %640 = getelementptr i8, ptr %639, i64 72
  %641 = load ptr, ptr %640, align 8
  %result.i1.i.i = call { i64, i64 } %641(ptr nocapture nofree nonnull readonly %627) #5
  %642 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %643 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %644 = call i64 @llvm.umax.i64(i64 %632, i64 %643)
  %645 = call i64 @llvm.umax.i64(i64 %644, i64 8)
  %646 = urem i64 %638, %643
  %647 = icmp eq i64 %646, 0
  %648 = sub i64 %643, %646
  %649 = select i1 %647, i64 0, i64 %648
  %650 = add i64 %642, %638
  %651 = add i64 %650, %649
  %652 = urem i64 %651, %645
  %653 = icmp eq i64 %652, 0
  %654 = sub i64 %645, %652
  %655 = select i1 %653, i64 0, i64 %654
  %656 = add i64 %655, %651
  %result.i90.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %656, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %625, ptr %result.i90.i, align 8
  %657 = getelementptr inbounds i8, ptr %result.i90.i, i64 8
  store ptr %627, ptr %657, align 8
  %658 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i)
  %659 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %660 = load ptr, ptr %625, align 8
  %661 = getelementptr i8, ptr %660, i64 72
  %662 = load ptr, ptr %661, align 8
  %result.i.i196.i = call { i64, i64 } %662(ptr nocapture nofree nonnull readonly %625) #5
  %663 = extractvalue { i64, i64 } %result.i.i196.i, 1
  %664 = urem i64 20, %663
  %665 = icmp eq i64 %664, 0
  %reass.sub4284 = sub i64 %663, %664
  %666 = add i64 %reass.sub4284, 20
  %667 = select i1 %665, i64 20, i64 %666
  %668 = getelementptr i8, ptr %result.i90.i, i64 %667
  %669 = getelementptr i8, ptr %660, i64 64
  %670 = load ptr, ptr %669, align 8
  call void %670({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %625, ptr nocapture nofree writeonly %668) #1
  %671 = load ptr, ptr %result.i90.i, align 8
  %672 = load ptr, ptr %671, align 8
  %673 = getelementptr i8, ptr %672, i64 72
  %674 = load ptr, ptr %673, align 8
  %result.i.i197.i = call { i64, i64 } %674(ptr nocapture nofree nonnull readonly %671) #5
  %675 = extractvalue { i64, i64 } %result.i.i197.i, 0
  %676 = extractvalue { i64, i64 } %result.i.i197.i, 1
  %677 = urem i64 20, %676
  %678 = icmp eq i64 %677, 0
  %679 = sub i64 %676, %677
  %680 = select i1 %678, i64 0, i64 %679
  %681 = add i64 %675, 20
  %682 = add i64 %681, %680
  %683 = load ptr, ptr %657, align 8
  %684 = load ptr, ptr %683, align 8
  %685 = getelementptr i8, ptr %684, i64 72
  %686 = load ptr, ptr %685, align 8
  %result.i1.i198.i = call { i64, i64 } %686(ptr nocapture nofree nonnull readonly %683) #5
  %687 = extractvalue { i64, i64 } %result.i1.i198.i, 1
  %688 = urem i64 %682, %687
  %689 = icmp eq i64 %688, 0
  %690 = sub i64 %687, %688
  %691 = select i1 %689, i64 0, i64 %690
  %692 = getelementptr i8, ptr %result.i90.i, i64 %682
  %693 = getelementptr i8, ptr %692, i64 %691
  %694 = getelementptr i8, ptr %684, i64 64
  %695 = load ptr, ptr %694, align 8
  call void %695({ ptr, i160 } %190, ptr nocapture nofree nonnull readonly %683, ptr nocapture nofree writeonly %693) #1
  %696 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %697 = getelementptr inbounds i8, ptr %result.i90.i, i64 16
  store i32 %192, ptr %697, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %34)
  %698 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %699 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %701

701:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %702, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %768, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i90.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i1472, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %702 = add nuw nsw i32 %.0566.i, 1
  %703 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %704 = insertvalue { ptr, ptr, ptr, i32 } %703, ptr %.sroa.6.0563.i, 1
  %705 = insertvalue { ptr, ptr, ptr, i32 } %704, ptr %.sroa.12.0562.i, 2
  %706 = insertvalue { ptr, ptr, ptr, i32 } %705, i32 %.sroa.17.0561.i, 3
  %707 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %708 = sext i32 %.sroa.17.0561.i to i64
  %709 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %708
  %710 = getelementptr i8, ptr %709, i64 64
  %711 = load ptr, ptr %710, align 8
  %result.i125.i1470 = call ptr %711({ ptr, ptr, ptr, i32 } %706, ptr nocapture nofree noundef nonnull readonly %2) #16
  %712 = call i32 %result.i125.i1470({ ptr, ptr, ptr, i32 } %706, { ptr, ptr, ptr, i32 } %706, ptr nonnull align 8 %2) #7
  %713 = ptrtoint ptr %.sroa.6.0563.i to i64
  %714 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %715, label %731

715:                                              ; preds = %701
  %716 = load i32, ptr %42, align 8
  %717 = add i32 %716, -1
  %718 = and i32 %717, %712
  %719 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %720 = load ptr, ptr %43, align 8
  %721 = sext i32 %718 to i64
  %722 = shl nsw i64 %721, 5
  %723 = getelementptr i8, ptr %720, i64 %722
  %724 = load ptr, ptr %723, align 8
  %725 = getelementptr i8, ptr %723, i64 8
  %726 = load i160, ptr %725, align 4
  store ptr %.sroa.0.0564.i, ptr %723, align 8
  store i64 %713, ptr %725, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %723, i64 16
  store i64 %714, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %723, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %727 = icmp ne ptr %724, @nil_typ
  %728 = icmp ne ptr %724, null
  %.not92.i = and i1 %727, %728
  %extract.i = lshr i160 %726, 64
  %729 = insertelement <2 x i160> poison, i160 %726, i64 0
  %730 = insertelement <2 x i160> %729, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

731:                                              ; preds = %701
  %732 = add i32 %712, 2127912214
  %733 = shl i32 %712, 12
  %734 = add i32 %732, %733
  %735 = ashr i32 %734, 19
  %736 = xor i32 %734, %735
  %737 = xor i32 %736, -949894596
  %738 = add i32 %737, 374761393
  %739 = shl i32 %737, 5
  %740 = add i32 %738, %739
  %741 = add i32 %740, -744332180
  %742 = shl i32 %740, 9
  %743 = xor i32 %741, %742
  %744 = add i32 %743, -42973499
  %745 = shl i32 %743, 3
  %746 = add i32 %744, %745
  %747 = ashr i32 %746, 16
  %748 = xor i32 %746, %747
  %749 = xor i32 %748, -1252372727
  %750 = load i32, ptr %42, align 8
  %751 = add i32 %750, -1
  %752 = and i32 %751, %749
  %753 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %754 = load ptr, ptr %44, align 8
  %755 = sext i32 %752 to i64
  %756 = shl nsw i64 %755, 5
  %757 = getelementptr i8, ptr %754, i64 %756
  %758 = load ptr, ptr %757, align 8
  %759 = getelementptr i8, ptr %757, i64 8
  %760 = load i160, ptr %759, align 4
  store ptr %.sroa.0.0564.i, ptr %757, align 8
  store i64 %713, ptr %759, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %757, i64 16
  store i64 %714, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %757, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %761 = icmp ne ptr %758, @nil_typ
  %762 = icmp ne ptr %758, null
  %.not90.i = and i1 %761, %762
  %extract607.i = lshr i160 %760, 64
  %763 = insertelement <2 x i160> poison, i160 %760, i64 0
  %764 = insertelement <2 x i160> %763, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %731, %715
  %vptr.i142.sroa.speculated.i = phi ptr [ %724, %715 ], [ %758, %731 ]
  %.in4290 = phi <2 x i160> [ %730, %715 ], [ %764, %731 ]
  %765 = trunc <2 x i160> %.in4290 to <2 x i64>
  %766 = extractelement <2 x i64> %765, i64 1
  %spec.select.i1472 = inttoptr i64 %766 to ptr
  %767 = extractelement <2 x i64> %765, i64 0
  %spec.select539.i = inttoptr i64 %767 to ptr
  %768 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %770 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %771 = icmp ult i32 %.0566.i, 99
  br i1 %771, label %701, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %715, %731
  %772 = phi ptr [ %34, %731 ], [ %33, %715 ]
  %773 = load i32, ptr %62, align 4
  store i32 %773, ptr %772, align 4
  %774 = add i32 %773, 1
  %775 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %774, ptr %62, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  %776 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %776, label %CuckooMap_insert_keyK_valueV.exit, label %777

777:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %778 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %779 = load ptr, ptr %43, align 8
  %780 = load ptr, ptr %44, align 8
  %781 = load i32, ptr %42, align 8
  %782 = shl i32 %781, 1
  %spec.select.i1489 = call i32 @llvm.smax.i32(i32 %782, i32 16)
  store i32 %spec.select.i1489, ptr %42, align 8
  %783 = zext nneg i32 %spec.select.i1489 to i64
  %784 = shl nuw nsw i64 %783, 5
  %result.i.i1490 = call noalias ptr @bump_malloc_inner(i64 noundef %784, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1490, ptr %43, align 8
  %result.i20.i1491 = call noalias ptr @bump_malloc_inner(i64 noundef %784, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1491, ptr %44, align 8
  store i32 0, ptr %62, align 4
  %785 = icmp sgt i32 %781, 0
  br i1 %785, label %.lr.ph.i2498, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2531.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2531.thread: ; preds = %777
  %786 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567

.lr.ph.i2498:                                     ; preds = %777, %._crit_edge.i2513
  %.060.i2511 = phi i32 [ %875, %._crit_edge.i2513 ], [ 0, %777 ]
  %787 = zext nneg i32 %.060.i2511 to i64
  %788 = shl nuw nsw i64 %787, 5
  %789 = getelementptr i8, ptr %779, i64 %788
  %790 = load ptr, ptr %789, align 8
  %791 = icmp ne ptr %790, @nil_typ
  %792 = icmp ne ptr %790, null
  %.not16.i2512 = and i1 %791, %792
  br i1 %.not16.i2512, label %793, label %._crit_edge.i2513

793:                                              ; preds = %.lr.ph.i2498
  %794 = getelementptr i8, ptr %789, i64 8
  %795 = load <2 x i64>, ptr %794, align 4
  %hash_coef_ptr.i.i18.i2515 = getelementptr i8, ptr %790, i64 8
  %tbl_size_ptr.i.i19.i2516 = getelementptr i8, ptr %790, i64 16
  %offset_tbl_ptr.i.i20.i2517 = getelementptr i8, ptr %790, i64 40
  %796 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %hash_coef.i.i99.i3100 = load i64, ptr %hash_coef_ptr.i.i18.i2515, align 4, !noalias !22
  %tbl_size.i.i100.i3101 = load i64, ptr %tbl_size_ptr.i.i19.i2516, align 4, !noalias !22
  %offset_tbl.i.i101.i3102 = load ptr, ptr %offset_tbl_ptr.i.i20.i2517, align 8, !noalias !22
  %product.i.i.i102.i3103 = mul i64 %hash_coef.i.i99.i3100, 4015701072841558310
  %shifted.i.i.i103.i3104 = lshr i64 %product.i.i.i102.i3103, 32
  %xored.i.i.i104.i3105 = xor i64 %shifted.i.i.i103.i3104, %product.i.i.i102.i3103
  %hash.i.i.i105.i3106 = and i64 %xored.i.i.i104.i3105, %tbl_size.i.i100.i3101
  %offset_ptr.i.i106.i3107 = getelementptr i32, ptr %offset_tbl.i.i101.i3102, i64 %hash.i.i.i105.i3106
  %offset.i.i121.i3108 = load i32, ptr %offset_ptr.i.i106.i3107, align 4, !noalias !263
  %797 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %798 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %799 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %800

800:                                              ; preds = %.cont.cont.i3129, %793
  %.0566.i3109 = phi i32 [ 0, %793 ], [ %804, %.cont.cont.i3129 ]
  %.070565.i3110 = phi i1 [ true, %793 ], [ %866, %.cont.cont.i3129 ]
  %.sroa.0.0564.i3111 = phi ptr [ %790, %793 ], [ %vptr.i142.sroa.speculated.i3132, %.cont.cont.i3129 ]
  %.sroa.17.0561.i3114 = phi i32 [ %offset.i.i121.i3108, %793 ], [ %offset.i.i154.i3146, %.cont.cont.i3129 ]
  %801 = phi <2 x i64> [ %795, %793 ], [ %865, %.cont.cont.i3129 ]
  %802 = extractelement <2 x i64> %801, i64 1
  %.sroa.12.0562.i3113 = inttoptr i64 %802 to ptr
  %803 = extractelement <2 x i64> %801, i64 0
  %.sroa.6.0563.i3112 = inttoptr i64 %803 to ptr
  %804 = add nuw nsw i32 %.0566.i3109, 1
  %805 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3111, 0
  %806 = insertvalue { ptr, ptr, ptr, i32 } %805, ptr %.sroa.6.0563.i3112, 1
  %807 = insertvalue { ptr, ptr, ptr, i32 } %806, ptr %.sroa.12.0562.i3113, 2
  %808 = insertvalue { ptr, ptr, ptr, i32 } %807, i32 %.sroa.17.0561.i3114, 3
  %809 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3111)
  %810 = sext i32 %.sroa.17.0561.i3114 to i64
  %811 = getelementptr ptr, ptr %.sroa.0.0564.i3111, i64 %810
  %812 = getelementptr i8, ptr %811, i64 64
  %813 = load ptr, ptr %812, align 8
  %result.i125.i3115 = call ptr %813({ ptr, ptr, ptr, i32 } %808, ptr nocapture nofree noundef nonnull readonly %2) #16
  %814 = call i32 %result.i125.i3115({ ptr, ptr, ptr, i32 } %808, { ptr, ptr, ptr, i32 } %808, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3110, label %815, label %831

815:                                              ; preds = %800
  %816 = load i32, ptr %42, align 8
  %817 = add i32 %816, -1
  %818 = and i32 %817, %814
  %819 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %820 = load ptr, ptr %43, align 8
  %821 = sext i32 %818 to i64
  %822 = shl nsw i64 %821, 5
  %823 = getelementptr i8, ptr %820, i64 %822
  %824 = load ptr, ptr %823, align 8
  %825 = getelementptr i8, ptr %823, i64 8
  %826 = load i160, ptr %825, align 4
  store ptr %.sroa.0.0564.i3111, ptr %823, align 8
  store i64 %803, ptr %825, align 4
  %.sroa_idx157.i3158 = getelementptr i8, ptr %823, i64 16
  store i64 %802, ptr %.sroa_idx157.i3158, align 4
  %.sroa_idx158.i3159 = getelementptr i8, ptr %823, i64 24
  store i32 %.sroa.17.0561.i3114, ptr %.sroa_idx158.i3159, align 4
  %827 = icmp ne ptr %824, @nil_typ
  %828 = icmp ne ptr %824, null
  %.not92.i3160 = and i1 %827, %828
  %extract.i3162 = lshr i160 %826, 64
  %829 = insertelement <2 x i160> poison, i160 %826, i64 0
  %830 = insertelement <2 x i160> %829, i160 %extract.i3162, i64 1
  br i1 %.not92.i3160, label %.cont.cont.i3129, label %870

831:                                              ; preds = %800
  %832 = add i32 %814, 2127912214
  %833 = shl i32 %814, 12
  %834 = add i32 %832, %833
  %835 = ashr i32 %834, 19
  %836 = xor i32 %834, %835
  %837 = xor i32 %836, -949894596
  %838 = add i32 %837, 374761393
  %839 = shl i32 %837, 5
  %840 = add i32 %838, %839
  %841 = add i32 %840, -744332180
  %842 = shl i32 %840, 9
  %843 = xor i32 %841, %842
  %844 = add i32 %843, -42973499
  %845 = shl i32 %843, 3
  %846 = add i32 %844, %845
  %847 = ashr i32 %846, 16
  %848 = xor i32 %846, %847
  %849 = xor i32 %848, -1252372727
  %850 = load i32, ptr %42, align 8
  %851 = add i32 %850, -1
  %852 = and i32 %851, %849
  %853 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %854 = load ptr, ptr %44, align 8
  %855 = sext i32 %852 to i64
  %856 = shl nsw i64 %855, 5
  %857 = getelementptr i8, ptr %854, i64 %856
  %858 = load ptr, ptr %857, align 8
  %859 = getelementptr i8, ptr %857, i64 8
  %860 = load i160, ptr %859, align 4
  store ptr %.sroa.0.0564.i3111, ptr %857, align 8
  store i64 %803, ptr %859, align 4
  %.sroa_idx161.i3119 = getelementptr i8, ptr %857, i64 16
  store i64 %802, ptr %.sroa_idx161.i3119, align 4
  %.sroa_idx162.i3120 = getelementptr i8, ptr %857, i64 24
  store i32 %.sroa.17.0561.i3114, ptr %.sroa_idx162.i3120, align 4
  %861 = icmp ne ptr %858, @nil_typ
  %862 = icmp ne ptr %858, null
  %.not90.i3121 = and i1 %861, %862
  %extract607.i3123 = lshr i160 %860, 64
  %863 = insertelement <2 x i160> poison, i160 %860, i64 0
  %864 = insertelement <2 x i160> %863, i160 %extract607.i3123, i64 1
  br i1 %.not90.i3121, label %.cont.cont.i3129, label %870

.cont.cont.i3129:                                 ; preds = %831, %815
  %vptr.i142.sroa.speculated.i3132 = phi ptr [ %824, %815 ], [ %858, %831 ]
  %.in4291 = phi <2 x i160> [ %830, %815 ], [ %864, %831 ]
  %865 = trunc <2 x i160> %.in4291 to <2 x i64>
  %866 = xor i1 %.070565.i3110, true
  %hash_coef_ptr.i.i143.i3135 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3132, i64 8
  %tbl_size_ptr.i.i144.i3136 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3132, i64 16
  %offset_tbl_ptr.i.i145.i3137 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3132, i64 40
  %hash_coef.i.i146.i3138 = load i64, ptr %hash_coef_ptr.i.i143.i3135, align 4
  %tbl_size.i.i147.i3139 = load i64, ptr %tbl_size_ptr.i.i144.i3136, align 4
  %offset_tbl.i.i148.i3140 = load ptr, ptr %offset_tbl_ptr.i.i145.i3137, align 8
  %product.i.i.i149.i3141 = mul i64 %hash_coef.i.i146.i3138, 4015701072841558310
  %shifted.i.i.i150.i3142 = lshr i64 %product.i.i.i149.i3141, 32
  %xored.i.i.i151.i3143 = xor i64 %shifted.i.i.i150.i3142, %product.i.i.i149.i3141
  %hash.i.i.i152.i3144 = and i64 %xored.i.i.i151.i3143, %tbl_size.i.i147.i3139
  %offset_ptr.i.i153.i3145 = getelementptr i32, ptr %offset_tbl.i.i148.i3140, i64 %hash.i.i.i152.i3144
  %offset.i.i154.i3146 = load i32, ptr %offset_ptr.i.i153.i3145, align 4
  %867 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %868 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %869 = icmp ult i32 %.0566.i3109, 99
  br i1 %869, label %800, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3164

870:                                              ; preds = %831, %815
  %871 = phi ptr [ %22, %831 ], [ %21, %815 ]
  %872 = load i32, ptr %62, align 4
  store i32 %872, ptr %871, align 4
  %873 = add i32 %872, 1
  %874 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %873, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3164

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3164: ; preds = %.cont.cont.i3129, %870
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %._crit_edge.i2513

._crit_edge.i2513:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3164, %.lr.ph.i2498
  %875 = add nuw nsw i32 %.060.i2511, 1
  %876 = icmp slt i32 %875, %781
  br i1 %876, label %.lr.ph.i2498, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2531

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2531: ; preds = %._crit_edge.i2513
  %877 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %878

878:                                              ; preds = %._crit_edge.i2549, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2531
  %.060.i2547 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2531 ], [ %967, %._crit_edge.i2549 ]
  %879 = zext nneg i32 %.060.i2547 to i64
  %880 = shl nuw nsw i64 %879, 5
  %881 = getelementptr i8, ptr %780, i64 %880
  %882 = load ptr, ptr %881, align 8
  %883 = icmp ne ptr %882, @nil_typ
  %884 = icmp ne ptr %882, null
  %.not16.i2548 = and i1 %883, %884
  br i1 %.not16.i2548, label %885, label %._crit_edge.i2549

885:                                              ; preds = %878
  %886 = getelementptr i8, ptr %881, i64 8
  %887 = load <2 x i64>, ptr %886, align 4
  %hash_coef_ptr.i.i18.i2551 = getelementptr i8, ptr %882, i64 8
  %tbl_size_ptr.i.i19.i2552 = getelementptr i8, ptr %882, i64 16
  %offset_tbl_ptr.i.i20.i2553 = getelementptr i8, ptr %882, i64 40
  %888 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i3182 = load i64, ptr %hash_coef_ptr.i.i18.i2551, align 4, !noalias !22
  %tbl_size.i.i100.i3183 = load i64, ptr %tbl_size_ptr.i.i19.i2552, align 4, !noalias !22
  %offset_tbl.i.i101.i3184 = load ptr, ptr %offset_tbl_ptr.i.i20.i2553, align 8, !noalias !22
  %product.i.i.i102.i3185 = mul i64 %hash_coef.i.i99.i3182, 4015701072841558310
  %shifted.i.i.i103.i3186 = lshr i64 %product.i.i.i102.i3185, 32
  %xored.i.i.i104.i3187 = xor i64 %shifted.i.i.i103.i3186, %product.i.i.i102.i3185
  %hash.i.i.i105.i3188 = and i64 %xored.i.i.i104.i3187, %tbl_size.i.i100.i3183
  %offset_ptr.i.i106.i3189 = getelementptr i32, ptr %offset_tbl.i.i101.i3184, i64 %hash.i.i.i105.i3188
  %offset.i.i121.i3190 = load i32, ptr %offset_ptr.i.i106.i3189, align 4, !noalias !266
  %889 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %890 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %892

892:                                              ; preds = %.cont.cont.i3211, %885
  %.0566.i3191 = phi i32 [ 0, %885 ], [ %896, %.cont.cont.i3211 ]
  %.070565.i3192 = phi i1 [ true, %885 ], [ %958, %.cont.cont.i3211 ]
  %.sroa.0.0564.i3193 = phi ptr [ %882, %885 ], [ %vptr.i142.sroa.speculated.i3214, %.cont.cont.i3211 ]
  %.sroa.17.0561.i3196 = phi i32 [ %offset.i.i121.i3190, %885 ], [ %offset.i.i154.i3228, %.cont.cont.i3211 ]
  %893 = phi <2 x i64> [ %887, %885 ], [ %957, %.cont.cont.i3211 ]
  %894 = extractelement <2 x i64> %893, i64 1
  %.sroa.12.0562.i3195 = inttoptr i64 %894 to ptr
  %895 = extractelement <2 x i64> %893, i64 0
  %.sroa.6.0563.i3194 = inttoptr i64 %895 to ptr
  %896 = add nuw nsw i32 %.0566.i3191, 1
  %897 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3193, 0
  %898 = insertvalue { ptr, ptr, ptr, i32 } %897, ptr %.sroa.6.0563.i3194, 1
  %899 = insertvalue { ptr, ptr, ptr, i32 } %898, ptr %.sroa.12.0562.i3195, 2
  %900 = insertvalue { ptr, ptr, ptr, i32 } %899, i32 %.sroa.17.0561.i3196, 3
  %901 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3193)
  %902 = sext i32 %.sroa.17.0561.i3196 to i64
  %903 = getelementptr ptr, ptr %.sroa.0.0564.i3193, i64 %902
  %904 = getelementptr i8, ptr %903, i64 64
  %905 = load ptr, ptr %904, align 8
  %result.i125.i3197 = call ptr %905({ ptr, ptr, ptr, i32 } %900, ptr nocapture nofree noundef nonnull readonly %2) #16
  %906 = call i32 %result.i125.i3197({ ptr, ptr, ptr, i32 } %900, { ptr, ptr, ptr, i32 } %900, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3192, label %907, label %923

907:                                              ; preds = %892
  %908 = load i32, ptr %42, align 8
  %909 = add i32 %908, -1
  %910 = and i32 %909, %906
  %911 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %912 = load ptr, ptr %43, align 8
  %913 = sext i32 %910 to i64
  %914 = shl nsw i64 %913, 5
  %915 = getelementptr i8, ptr %912, i64 %914
  %916 = load ptr, ptr %915, align 8
  %917 = getelementptr i8, ptr %915, i64 8
  %918 = load i160, ptr %917, align 4
  store ptr %.sroa.0.0564.i3193, ptr %915, align 8
  store i64 %895, ptr %917, align 4
  %.sroa_idx157.i3240 = getelementptr i8, ptr %915, i64 16
  store i64 %894, ptr %.sroa_idx157.i3240, align 4
  %.sroa_idx158.i3241 = getelementptr i8, ptr %915, i64 24
  store i32 %.sroa.17.0561.i3196, ptr %.sroa_idx158.i3241, align 4
  %919 = icmp ne ptr %916, @nil_typ
  %920 = icmp ne ptr %916, null
  %.not92.i3242 = and i1 %919, %920
  %extract.i3244 = lshr i160 %918, 64
  %921 = insertelement <2 x i160> poison, i160 %918, i64 0
  %922 = insertelement <2 x i160> %921, i160 %extract.i3244, i64 1
  br i1 %.not92.i3242, label %.cont.cont.i3211, label %962

923:                                              ; preds = %892
  %924 = add i32 %906, 2127912214
  %925 = shl i32 %906, 12
  %926 = add i32 %924, %925
  %927 = ashr i32 %926, 19
  %928 = xor i32 %926, %927
  %929 = xor i32 %928, -949894596
  %930 = add i32 %929, 374761393
  %931 = shl i32 %929, 5
  %932 = add i32 %930, %931
  %933 = add i32 %932, -744332180
  %934 = shl i32 %932, 9
  %935 = xor i32 %933, %934
  %936 = add i32 %935, -42973499
  %937 = shl i32 %935, 3
  %938 = add i32 %936, %937
  %939 = ashr i32 %938, 16
  %940 = xor i32 %938, %939
  %941 = xor i32 %940, -1252372727
  %942 = load i32, ptr %42, align 8
  %943 = add i32 %942, -1
  %944 = and i32 %943, %941
  %945 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %946 = load ptr, ptr %44, align 8
  %947 = sext i32 %944 to i64
  %948 = shl nsw i64 %947, 5
  %949 = getelementptr i8, ptr %946, i64 %948
  %950 = load ptr, ptr %949, align 8
  %951 = getelementptr i8, ptr %949, i64 8
  %952 = load i160, ptr %951, align 4
  store ptr %.sroa.0.0564.i3193, ptr %949, align 8
  store i64 %895, ptr %951, align 4
  %.sroa_idx161.i3201 = getelementptr i8, ptr %949, i64 16
  store i64 %894, ptr %.sroa_idx161.i3201, align 4
  %.sroa_idx162.i3202 = getelementptr i8, ptr %949, i64 24
  store i32 %.sroa.17.0561.i3196, ptr %.sroa_idx162.i3202, align 4
  %953 = icmp ne ptr %950, @nil_typ
  %954 = icmp ne ptr %950, null
  %.not90.i3203 = and i1 %953, %954
  %extract607.i3205 = lshr i160 %952, 64
  %955 = insertelement <2 x i160> poison, i160 %952, i64 0
  %956 = insertelement <2 x i160> %955, i160 %extract607.i3205, i64 1
  br i1 %.not90.i3203, label %.cont.cont.i3211, label %962

.cont.cont.i3211:                                 ; preds = %923, %907
  %vptr.i142.sroa.speculated.i3214 = phi ptr [ %916, %907 ], [ %950, %923 ]
  %.in4292 = phi <2 x i160> [ %922, %907 ], [ %956, %923 ]
  %957 = trunc <2 x i160> %.in4292 to <2 x i64>
  %958 = xor i1 %.070565.i3192, true
  %hash_coef_ptr.i.i143.i3217 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3214, i64 8
  %tbl_size_ptr.i.i144.i3218 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3214, i64 16
  %offset_tbl_ptr.i.i145.i3219 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3214, i64 40
  %hash_coef.i.i146.i3220 = load i64, ptr %hash_coef_ptr.i.i143.i3217, align 4
  %tbl_size.i.i147.i3221 = load i64, ptr %tbl_size_ptr.i.i144.i3218, align 4
  %offset_tbl.i.i148.i3222 = load ptr, ptr %offset_tbl_ptr.i.i145.i3219, align 8
  %product.i.i.i149.i3223 = mul i64 %hash_coef.i.i146.i3220, 4015701072841558310
  %shifted.i.i.i150.i3224 = lshr i64 %product.i.i.i149.i3223, 32
  %xored.i.i.i151.i3225 = xor i64 %shifted.i.i.i150.i3224, %product.i.i.i149.i3223
  %hash.i.i.i152.i3226 = and i64 %xored.i.i.i151.i3225, %tbl_size.i.i147.i3221
  %offset_ptr.i.i153.i3227 = getelementptr i32, ptr %offset_tbl.i.i148.i3222, i64 %hash.i.i.i152.i3226
  %offset.i.i154.i3228 = load i32, ptr %offset_ptr.i.i153.i3227, align 4
  %959 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %960 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %961 = icmp ult i32 %.0566.i3191, 99
  br i1 %961, label %892, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3246

962:                                              ; preds = %923, %907
  %963 = phi ptr [ %20, %923 ], [ %19, %907 ]
  %964 = load i32, ptr %62, align 4
  store i32 %964, ptr %963, align 4
  %965 = add i32 %964, 1
  %966 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %965, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3246

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3246: ; preds = %.cont.cont.i3211, %962
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %._crit_edge.i2549

._crit_edge.i2549:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3246, %878
  %967 = add nuw nsw i32 %.060.i2547, 1
  %968 = icmp slt i32 %967, %781
  br i1 %968, label %878, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567: ; preds = %._crit_edge.i2549, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2531.thread
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %32)
  %hash_coef.i.i99.i1514 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i1515 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1516 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i1517 = mul i64 %hash_coef.i.i99.i1514, 4015701072841558310
  %shifted.i.i.i103.i1518 = lshr i64 %product.i.i.i102.i1517, 32
  %xored.i.i.i104.i1519 = xor i64 %shifted.i.i.i103.i1518, %product.i.i.i102.i1517
  %hash.i.i.i105.i1520 = and i64 %xored.i.i.i104.i1519, %tbl_size.i.i100.i1515
  %offset_ptr.i.i106.i1521 = getelementptr i32, ptr %offset_tbl.i.i101.i1516, i64 %hash.i.i.i105.i1520
  %offset.i.i121.i1522 = load i32, ptr %offset_ptr.i.i106.i1521, align 4, !noalias !269
  %969 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %970 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %971 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %972

972:                                              ; preds = %.cont.cont.i1544, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567
  %.0566.i1524 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567 ], [ %976, %.cont.cont.i1544 ]
  %.070565.i1525 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567 ], [ %1038, %.cont.cont.i1544 ]
  %.sroa.0.0564.i1526 = phi ptr [ %vptr.i142.sroa.speculated.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567 ], [ %vptr.i142.sroa.speculated.i1547, %.cont.cont.i1544 ]
  %.sroa.17.0561.i1529 = phi i32 [ %offset.i.i121.i1522, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567 ], [ %offset.i.i154.i1561, %.cont.cont.i1544 ]
  %973 = phi <2 x i64> [ %765, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2567 ], [ %1037, %.cont.cont.i1544 ]
  %974 = extractelement <2 x i64> %973, i64 1
  %.sroa.12.0562.i1528 = inttoptr i64 %974 to ptr
  %975 = extractelement <2 x i64> %973, i64 0
  %.sroa.6.0563.i1527 = inttoptr i64 %975 to ptr
  %976 = add nuw nsw i32 %.0566.i1524, 1
  %977 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1526, 0
  %978 = insertvalue { ptr, ptr, ptr, i32 } %977, ptr %.sroa.6.0563.i1527, 1
  %979 = insertvalue { ptr, ptr, ptr, i32 } %978, ptr %.sroa.12.0562.i1528, 2
  %980 = insertvalue { ptr, ptr, ptr, i32 } %979, i32 %.sroa.17.0561.i1529, 3
  %981 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1526)
  %982 = sext i32 %.sroa.17.0561.i1529 to i64
  %983 = getelementptr ptr, ptr %.sroa.0.0564.i1526, i64 %982
  %984 = getelementptr i8, ptr %983, i64 64
  %985 = load ptr, ptr %984, align 8
  %result.i125.i1530 = call ptr %985({ ptr, ptr, ptr, i32 } %980, ptr nocapture nofree noundef nonnull readonly %2) #16
  %986 = call i32 %result.i125.i1530({ ptr, ptr, ptr, i32 } %980, { ptr, ptr, ptr, i32 } %980, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1525, label %987, label %1003

987:                                              ; preds = %972
  %988 = load i32, ptr %42, align 8
  %989 = add i32 %988, -1
  %990 = and i32 %989, %986
  %991 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %992 = load ptr, ptr %43, align 8
  %993 = sext i32 %990 to i64
  %994 = shl nsw i64 %993, 5
  %995 = getelementptr i8, ptr %992, i64 %994
  %996 = load ptr, ptr %995, align 8
  %997 = getelementptr i8, ptr %995, i64 8
  %998 = load i160, ptr %997, align 4
  store ptr %.sroa.0.0564.i1526, ptr %995, align 8
  store i64 %975, ptr %997, align 4
  %.sroa_idx157.i1573 = getelementptr i8, ptr %995, i64 16
  store i64 %974, ptr %.sroa_idx157.i1573, align 4
  %.sroa_idx158.i1574 = getelementptr i8, ptr %995, i64 24
  store i32 %.sroa.17.0561.i1529, ptr %.sroa_idx158.i1574, align 4
  %999 = icmp ne ptr %996, @nil_typ
  %1000 = icmp ne ptr %996, null
  %.not92.i1575 = and i1 %999, %1000
  %extract.i1577 = lshr i160 %998, 64
  %1001 = insertelement <2 x i160> poison, i160 %998, i64 0
  %1002 = insertelement <2 x i160> %1001, i160 %extract.i1577, i64 1
  br i1 %.not92.i1575, label %.cont.cont.i1544, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1579.thread

1003:                                             ; preds = %972
  %1004 = add i32 %986, 2127912214
  %1005 = shl i32 %986, 12
  %1006 = add i32 %1004, %1005
  %1007 = ashr i32 %1006, 19
  %1008 = xor i32 %1006, %1007
  %1009 = xor i32 %1008, -949894596
  %1010 = add i32 %1009, 374761393
  %1011 = shl i32 %1009, 5
  %1012 = add i32 %1010, %1011
  %1013 = add i32 %1012, -744332180
  %1014 = shl i32 %1012, 9
  %1015 = xor i32 %1013, %1014
  %1016 = add i32 %1015, -42973499
  %1017 = shl i32 %1015, 3
  %1018 = add i32 %1016, %1017
  %1019 = ashr i32 %1018, 16
  %1020 = xor i32 %1018, %1019
  %1021 = xor i32 %1020, -1252372727
  %1022 = load i32, ptr %42, align 8
  %1023 = add i32 %1022, -1
  %1024 = and i32 %1023, %1021
  %1025 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1026 = load ptr, ptr %44, align 8
  %1027 = sext i32 %1024 to i64
  %1028 = shl nsw i64 %1027, 5
  %1029 = getelementptr i8, ptr %1026, i64 %1028
  %1030 = load ptr, ptr %1029, align 8
  %1031 = getelementptr i8, ptr %1029, i64 8
  %1032 = load i160, ptr %1031, align 4
  store ptr %.sroa.0.0564.i1526, ptr %1029, align 8
  store i64 %975, ptr %1031, align 4
  %.sroa_idx161.i1534 = getelementptr i8, ptr %1029, i64 16
  store i64 %974, ptr %.sroa_idx161.i1534, align 4
  %.sroa_idx162.i1535 = getelementptr i8, ptr %1029, i64 24
  store i32 %.sroa.17.0561.i1529, ptr %.sroa_idx162.i1535, align 4
  %1033 = icmp ne ptr %1030, @nil_typ
  %1034 = icmp ne ptr %1030, null
  %.not90.i1536 = and i1 %1033, %1034
  %extract607.i1538 = lshr i160 %1032, 64
  %1035 = insertelement <2 x i160> poison, i160 %1032, i64 0
  %1036 = insertelement <2 x i160> %1035, i160 %extract607.i1538, i64 1
  br i1 %.not90.i1536, label %.cont.cont.i1544, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1579.thread

.cont.cont.i1544:                                 ; preds = %1003, %987
  %vptr.i142.sroa.speculated.i1547 = phi ptr [ %996, %987 ], [ %1030, %1003 ]
  %.in4293 = phi <2 x i160> [ %1002, %987 ], [ %1036, %1003 ]
  %1037 = trunc <2 x i160> %.in4293 to <2 x i64>
  %1038 = xor i1 %.070565.i1525, true
  %hash_coef_ptr.i.i143.i1550 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1547, i64 8
  %tbl_size_ptr.i.i144.i1551 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1547, i64 16
  %offset_tbl_ptr.i.i145.i1552 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1547, i64 40
  %hash_coef.i.i146.i1553 = load i64, ptr %hash_coef_ptr.i.i143.i1550, align 4
  %tbl_size.i.i147.i1554 = load i64, ptr %tbl_size_ptr.i.i144.i1551, align 4
  %offset_tbl.i.i148.i1555 = load ptr, ptr %offset_tbl_ptr.i.i145.i1552, align 8
  %product.i.i.i149.i1556 = mul i64 %hash_coef.i.i146.i1553, 4015701072841558310
  %shifted.i.i.i150.i1557 = lshr i64 %product.i.i.i149.i1556, 32
  %xored.i.i.i151.i1558 = xor i64 %shifted.i.i.i150.i1557, %product.i.i.i149.i1556
  %hash.i.i.i152.i1559 = and i64 %xored.i.i.i151.i1558, %tbl_size.i.i147.i1554
  %offset_ptr.i.i153.i1560 = getelementptr i32, ptr %offset_tbl.i.i148.i1555, i64 %hash.i.i.i152.i1559
  %offset.i.i154.i1561 = load i32, ptr %offset_ptr.i.i153.i1560, align 4
  %1039 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1040 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1041 = icmp ult i32 %.0566.i1524, 99
  br i1 %1041, label %972, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1579

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1579.thread: ; preds = %987, %1003
  %1042 = phi ptr [ %32, %1003 ], [ %31, %987 ]
  %1043 = load i32, ptr %62, align 4
  store i32 %1043, ptr %1042, align 4
  %1044 = add i32 %1043, 1
  %1045 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1044, ptr %62, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1579: ; preds = %.cont.cont.i1544
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  %1046 = icmp eq ptr %vptr.i142.sroa.speculated.i1547, null
  br i1 %1046, label %CuckooMap_insert_keyK_valueV.exit, label %1047

1047:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1579
  %1048 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1049 = load ptr, ptr %43, align 8
  %1050 = load ptr, ptr %44, align 8
  %1051 = load i32, ptr %42, align 8
  %1052 = shl i32 %1051, 1
  %spec.select.i1595 = call i32 @llvm.smax.i32(i32 %1052, i32 16)
  store i32 %spec.select.i1595, ptr %42, align 8
  %1053 = zext nneg i32 %spec.select.i1595 to i64
  %1054 = shl nuw nsw i64 %1053, 5
  %result.i.i1596 = call noalias ptr @bump_malloc_inner(i64 noundef %1054, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1596, ptr %43, align 8
  %result.i20.i1597 = call noalias ptr @bump_malloc_inner(i64 noundef %1054, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1597, ptr %44, align 8
  store i32 0, ptr %62, align 4
  %1055 = icmp sgt i32 %1051, 0
  br i1 %1055, label %.lr.ph.i2597, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2630.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2630.thread: ; preds = %1047
  %1056 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i2597:                                     ; preds = %1047, %._crit_edge.i2612
  %.060.i2610 = phi i32 [ %1145, %._crit_edge.i2612 ], [ 0, %1047 ]
  %1057 = zext nneg i32 %.060.i2610 to i64
  %1058 = shl nuw nsw i64 %1057, 5
  %1059 = getelementptr i8, ptr %1049, i64 %1058
  %1060 = load ptr, ptr %1059, align 8
  %1061 = icmp ne ptr %1060, @nil_typ
  %1062 = icmp ne ptr %1060, null
  %.not16.i2611 = and i1 %1061, %1062
  br i1 %.not16.i2611, label %1063, label %._crit_edge.i2612

1063:                                             ; preds = %.lr.ph.i2597
  %1064 = getelementptr i8, ptr %1059, i64 8
  %1065 = load <2 x i64>, ptr %1064, align 4
  %hash_coef_ptr.i.i18.i2614 = getelementptr i8, ptr %1060, i64 8
  %tbl_size_ptr.i.i19.i2615 = getelementptr i8, ptr %1060, i64 16
  %offset_tbl_ptr.i.i20.i2616 = getelementptr i8, ptr %1060, i64 40
  %1066 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i3264 = load i64, ptr %hash_coef_ptr.i.i18.i2614, align 4, !noalias !22
  %tbl_size.i.i100.i3265 = load i64, ptr %tbl_size_ptr.i.i19.i2615, align 4, !noalias !22
  %offset_tbl.i.i101.i3266 = load ptr, ptr %offset_tbl_ptr.i.i20.i2616, align 8, !noalias !22
  %product.i.i.i102.i3267 = mul i64 %hash_coef.i.i99.i3264, 4015701072841558310
  %shifted.i.i.i103.i3268 = lshr i64 %product.i.i.i102.i3267, 32
  %xored.i.i.i104.i3269 = xor i64 %shifted.i.i.i103.i3268, %product.i.i.i102.i3267
  %hash.i.i.i105.i3270 = and i64 %xored.i.i.i104.i3269, %tbl_size.i.i100.i3265
  %offset_ptr.i.i106.i3271 = getelementptr i32, ptr %offset_tbl.i.i101.i3266, i64 %hash.i.i.i105.i3270
  %offset.i.i121.i3272 = load i32, ptr %offset_ptr.i.i106.i3271, align 4, !noalias !272
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1068 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1070

1070:                                             ; preds = %.cont.cont.i3293, %1063
  %.0566.i3273 = phi i32 [ 0, %1063 ], [ %1074, %.cont.cont.i3293 ]
  %.070565.i3274 = phi i1 [ true, %1063 ], [ %1136, %.cont.cont.i3293 ]
  %.sroa.0.0564.i3275 = phi ptr [ %1060, %1063 ], [ %vptr.i142.sroa.speculated.i3296, %.cont.cont.i3293 ]
  %.sroa.17.0561.i3278 = phi i32 [ %offset.i.i121.i3272, %1063 ], [ %offset.i.i154.i3310, %.cont.cont.i3293 ]
  %1071 = phi <2 x i64> [ %1065, %1063 ], [ %1135, %.cont.cont.i3293 ]
  %1072 = extractelement <2 x i64> %1071, i64 1
  %.sroa.12.0562.i3277 = inttoptr i64 %1072 to ptr
  %1073 = extractelement <2 x i64> %1071, i64 0
  %.sroa.6.0563.i3276 = inttoptr i64 %1073 to ptr
  %1074 = add nuw nsw i32 %.0566.i3273, 1
  %1075 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3275, 0
  %1076 = insertvalue { ptr, ptr, ptr, i32 } %1075, ptr %.sroa.6.0563.i3276, 1
  %1077 = insertvalue { ptr, ptr, ptr, i32 } %1076, ptr %.sroa.12.0562.i3277, 2
  %1078 = insertvalue { ptr, ptr, ptr, i32 } %1077, i32 %.sroa.17.0561.i3278, 3
  %1079 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3275)
  %1080 = sext i32 %.sroa.17.0561.i3278 to i64
  %1081 = getelementptr ptr, ptr %.sroa.0.0564.i3275, i64 %1080
  %1082 = getelementptr i8, ptr %1081, i64 64
  %1083 = load ptr, ptr %1082, align 8
  %result.i125.i3279 = call ptr %1083({ ptr, ptr, ptr, i32 } %1078, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1084 = call i32 %result.i125.i3279({ ptr, ptr, ptr, i32 } %1078, { ptr, ptr, ptr, i32 } %1078, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3274, label %1085, label %1101

1085:                                             ; preds = %1070
  %1086 = load i32, ptr %42, align 8
  %1087 = add i32 %1086, -1
  %1088 = and i32 %1087, %1084
  %1089 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1090 = load ptr, ptr %43, align 8
  %1091 = sext i32 %1088 to i64
  %1092 = shl nsw i64 %1091, 5
  %1093 = getelementptr i8, ptr %1090, i64 %1092
  %1094 = load ptr, ptr %1093, align 8
  %1095 = getelementptr i8, ptr %1093, i64 8
  %1096 = load i160, ptr %1095, align 4
  store ptr %.sroa.0.0564.i3275, ptr %1093, align 8
  store i64 %1073, ptr %1095, align 4
  %.sroa_idx157.i3322 = getelementptr i8, ptr %1093, i64 16
  store i64 %1072, ptr %.sroa_idx157.i3322, align 4
  %.sroa_idx158.i3323 = getelementptr i8, ptr %1093, i64 24
  store i32 %.sroa.17.0561.i3278, ptr %.sroa_idx158.i3323, align 4
  %1097 = icmp ne ptr %1094, @nil_typ
  %1098 = icmp ne ptr %1094, null
  %.not92.i3324 = and i1 %1097, %1098
  %extract.i3326 = lshr i160 %1096, 64
  %1099 = insertelement <2 x i160> poison, i160 %1096, i64 0
  %1100 = insertelement <2 x i160> %1099, i160 %extract.i3326, i64 1
  br i1 %.not92.i3324, label %.cont.cont.i3293, label %1140

1101:                                             ; preds = %1070
  %1102 = add i32 %1084, 2127912214
  %1103 = shl i32 %1084, 12
  %1104 = add i32 %1102, %1103
  %1105 = ashr i32 %1104, 19
  %1106 = xor i32 %1104, %1105
  %1107 = xor i32 %1106, -949894596
  %1108 = add i32 %1107, 374761393
  %1109 = shl i32 %1107, 5
  %1110 = add i32 %1108, %1109
  %1111 = add i32 %1110, -744332180
  %1112 = shl i32 %1110, 9
  %1113 = xor i32 %1111, %1112
  %1114 = add i32 %1113, -42973499
  %1115 = shl i32 %1113, 3
  %1116 = add i32 %1114, %1115
  %1117 = ashr i32 %1116, 16
  %1118 = xor i32 %1116, %1117
  %1119 = xor i32 %1118, -1252372727
  %1120 = load i32, ptr %42, align 8
  %1121 = add i32 %1120, -1
  %1122 = and i32 %1121, %1119
  %1123 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1124 = load ptr, ptr %44, align 8
  %1125 = sext i32 %1122 to i64
  %1126 = shl nsw i64 %1125, 5
  %1127 = getelementptr i8, ptr %1124, i64 %1126
  %1128 = load ptr, ptr %1127, align 8
  %1129 = getelementptr i8, ptr %1127, i64 8
  %1130 = load i160, ptr %1129, align 4
  store ptr %.sroa.0.0564.i3275, ptr %1127, align 8
  store i64 %1073, ptr %1129, align 4
  %.sroa_idx161.i3283 = getelementptr i8, ptr %1127, i64 16
  store i64 %1072, ptr %.sroa_idx161.i3283, align 4
  %.sroa_idx162.i3284 = getelementptr i8, ptr %1127, i64 24
  store i32 %.sroa.17.0561.i3278, ptr %.sroa_idx162.i3284, align 4
  %1131 = icmp ne ptr %1128, @nil_typ
  %1132 = icmp ne ptr %1128, null
  %.not90.i3285 = and i1 %1131, %1132
  %extract607.i3287 = lshr i160 %1130, 64
  %1133 = insertelement <2 x i160> poison, i160 %1130, i64 0
  %1134 = insertelement <2 x i160> %1133, i160 %extract607.i3287, i64 1
  br i1 %.not90.i3285, label %.cont.cont.i3293, label %1140

.cont.cont.i3293:                                 ; preds = %1101, %1085
  %vptr.i142.sroa.speculated.i3296 = phi ptr [ %1094, %1085 ], [ %1128, %1101 ]
  %.in4294 = phi <2 x i160> [ %1100, %1085 ], [ %1134, %1101 ]
  %1135 = trunc <2 x i160> %.in4294 to <2 x i64>
  %1136 = xor i1 %.070565.i3274, true
  %hash_coef_ptr.i.i143.i3299 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3296, i64 8
  %tbl_size_ptr.i.i144.i3300 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3296, i64 16
  %offset_tbl_ptr.i.i145.i3301 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3296, i64 40
  %hash_coef.i.i146.i3302 = load i64, ptr %hash_coef_ptr.i.i143.i3299, align 4
  %tbl_size.i.i147.i3303 = load i64, ptr %tbl_size_ptr.i.i144.i3300, align 4
  %offset_tbl.i.i148.i3304 = load ptr, ptr %offset_tbl_ptr.i.i145.i3301, align 8
  %product.i.i.i149.i3305 = mul i64 %hash_coef.i.i146.i3302, 4015701072841558310
  %shifted.i.i.i150.i3306 = lshr i64 %product.i.i.i149.i3305, 32
  %xored.i.i.i151.i3307 = xor i64 %shifted.i.i.i150.i3306, %product.i.i.i149.i3305
  %hash.i.i.i152.i3308 = and i64 %xored.i.i.i151.i3307, %tbl_size.i.i147.i3303
  %offset_ptr.i.i153.i3309 = getelementptr i32, ptr %offset_tbl.i.i148.i3304, i64 %hash.i.i.i152.i3308
  %offset.i.i154.i3310 = load i32, ptr %offset_ptr.i.i153.i3309, align 4
  %1137 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1138 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1139 = icmp ult i32 %.0566.i3273, 99
  br i1 %1139, label %1070, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3328

1140:                                             ; preds = %1101, %1085
  %1141 = phi ptr [ %18, %1101 ], [ %17, %1085 ]
  %1142 = load i32, ptr %62, align 4
  store i32 %1142, ptr %1141, align 4
  %1143 = add i32 %1142, 1
  %1144 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1143, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3328

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3328: ; preds = %.cont.cont.i3293, %1140
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i2612

._crit_edge.i2612:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3328, %.lr.ph.i2597
  %1145 = add nuw nsw i32 %.060.i2610, 1
  %1146 = icmp slt i32 %1145, %1051
  br i1 %1146, label %.lr.ph.i2597, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2630

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2630: ; preds = %._crit_edge.i2612
  %1147 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %1148

1148:                                             ; preds = %._crit_edge.i2648, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2630
  %.060.i2646 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2630 ], [ %1237, %._crit_edge.i2648 ]
  %1149 = zext nneg i32 %.060.i2646 to i64
  %1150 = shl nuw nsw i64 %1149, 5
  %1151 = getelementptr i8, ptr %1050, i64 %1150
  %1152 = load ptr, ptr %1151, align 8
  %1153 = icmp ne ptr %1152, @nil_typ
  %1154 = icmp ne ptr %1152, null
  %.not16.i2647 = and i1 %1153, %1154
  br i1 %.not16.i2647, label %1155, label %._crit_edge.i2648

1155:                                             ; preds = %1148
  %1156 = getelementptr i8, ptr %1151, i64 8
  %1157 = load <2 x i64>, ptr %1156, align 4
  %hash_coef_ptr.i.i18.i2650 = getelementptr i8, ptr %1152, i64 8
  %tbl_size_ptr.i.i19.i2651 = getelementptr i8, ptr %1152, i64 16
  %offset_tbl_ptr.i.i20.i2652 = getelementptr i8, ptr %1152, i64 40
  %1158 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i3346 = load i64, ptr %hash_coef_ptr.i.i18.i2650, align 4, !noalias !22
  %tbl_size.i.i100.i3347 = load i64, ptr %tbl_size_ptr.i.i19.i2651, align 4, !noalias !22
  %offset_tbl.i.i101.i3348 = load ptr, ptr %offset_tbl_ptr.i.i20.i2652, align 8, !noalias !22
  %product.i.i.i102.i3349 = mul i64 %hash_coef.i.i99.i3346, 4015701072841558310
  %shifted.i.i.i103.i3350 = lshr i64 %product.i.i.i102.i3349, 32
  %xored.i.i.i104.i3351 = xor i64 %shifted.i.i.i103.i3350, %product.i.i.i102.i3349
  %hash.i.i.i105.i3352 = and i64 %xored.i.i.i104.i3351, %tbl_size.i.i100.i3347
  %offset_ptr.i.i106.i3353 = getelementptr i32, ptr %offset_tbl.i.i101.i3348, i64 %hash.i.i.i105.i3352
  %offset.i.i121.i3354 = load i32, ptr %offset_ptr.i.i106.i3353, align 4, !noalias !275
  %1159 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1160 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1162

1162:                                             ; preds = %.cont.cont.i3375, %1155
  %.0566.i3355 = phi i32 [ 0, %1155 ], [ %1166, %.cont.cont.i3375 ]
  %.070565.i3356 = phi i1 [ true, %1155 ], [ %1228, %.cont.cont.i3375 ]
  %.sroa.0.0564.i3357 = phi ptr [ %1152, %1155 ], [ %vptr.i142.sroa.speculated.i3378, %.cont.cont.i3375 ]
  %.sroa.17.0561.i3360 = phi i32 [ %offset.i.i121.i3354, %1155 ], [ %offset.i.i154.i3392, %.cont.cont.i3375 ]
  %1163 = phi <2 x i64> [ %1157, %1155 ], [ %1227, %.cont.cont.i3375 ]
  %1164 = extractelement <2 x i64> %1163, i64 1
  %.sroa.12.0562.i3359 = inttoptr i64 %1164 to ptr
  %1165 = extractelement <2 x i64> %1163, i64 0
  %.sroa.6.0563.i3358 = inttoptr i64 %1165 to ptr
  %1166 = add nuw nsw i32 %.0566.i3355, 1
  %1167 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3357, 0
  %1168 = insertvalue { ptr, ptr, ptr, i32 } %1167, ptr %.sroa.6.0563.i3358, 1
  %1169 = insertvalue { ptr, ptr, ptr, i32 } %1168, ptr %.sroa.12.0562.i3359, 2
  %1170 = insertvalue { ptr, ptr, ptr, i32 } %1169, i32 %.sroa.17.0561.i3360, 3
  %1171 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3357)
  %1172 = sext i32 %.sroa.17.0561.i3360 to i64
  %1173 = getelementptr ptr, ptr %.sroa.0.0564.i3357, i64 %1172
  %1174 = getelementptr i8, ptr %1173, i64 64
  %1175 = load ptr, ptr %1174, align 8
  %result.i125.i3361 = call ptr %1175({ ptr, ptr, ptr, i32 } %1170, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1176 = call i32 %result.i125.i3361({ ptr, ptr, ptr, i32 } %1170, { ptr, ptr, ptr, i32 } %1170, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3356, label %1177, label %1193

1177:                                             ; preds = %1162
  %1178 = load i32, ptr %42, align 8
  %1179 = add i32 %1178, -1
  %1180 = and i32 %1179, %1176
  %1181 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1182 = load ptr, ptr %43, align 8
  %1183 = sext i32 %1180 to i64
  %1184 = shl nsw i64 %1183, 5
  %1185 = getelementptr i8, ptr %1182, i64 %1184
  %1186 = load ptr, ptr %1185, align 8
  %1187 = getelementptr i8, ptr %1185, i64 8
  %1188 = load i160, ptr %1187, align 4
  store ptr %.sroa.0.0564.i3357, ptr %1185, align 8
  store i64 %1165, ptr %1187, align 4
  %.sroa_idx157.i3404 = getelementptr i8, ptr %1185, i64 16
  store i64 %1164, ptr %.sroa_idx157.i3404, align 4
  %.sroa_idx158.i3405 = getelementptr i8, ptr %1185, i64 24
  store i32 %.sroa.17.0561.i3360, ptr %.sroa_idx158.i3405, align 4
  %1189 = icmp ne ptr %1186, @nil_typ
  %1190 = icmp ne ptr %1186, null
  %.not92.i3406 = and i1 %1189, %1190
  %extract.i3408 = lshr i160 %1188, 64
  %1191 = insertelement <2 x i160> poison, i160 %1188, i64 0
  %1192 = insertelement <2 x i160> %1191, i160 %extract.i3408, i64 1
  br i1 %.not92.i3406, label %.cont.cont.i3375, label %1232

1193:                                             ; preds = %1162
  %1194 = add i32 %1176, 2127912214
  %1195 = shl i32 %1176, 12
  %1196 = add i32 %1194, %1195
  %1197 = ashr i32 %1196, 19
  %1198 = xor i32 %1196, %1197
  %1199 = xor i32 %1198, -949894596
  %1200 = add i32 %1199, 374761393
  %1201 = shl i32 %1199, 5
  %1202 = add i32 %1200, %1201
  %1203 = add i32 %1202, -744332180
  %1204 = shl i32 %1202, 9
  %1205 = xor i32 %1203, %1204
  %1206 = add i32 %1205, -42973499
  %1207 = shl i32 %1205, 3
  %1208 = add i32 %1206, %1207
  %1209 = ashr i32 %1208, 16
  %1210 = xor i32 %1208, %1209
  %1211 = xor i32 %1210, -1252372727
  %1212 = load i32, ptr %42, align 8
  %1213 = add i32 %1212, -1
  %1214 = and i32 %1213, %1211
  %1215 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1216 = load ptr, ptr %44, align 8
  %1217 = sext i32 %1214 to i64
  %1218 = shl nsw i64 %1217, 5
  %1219 = getelementptr i8, ptr %1216, i64 %1218
  %1220 = load ptr, ptr %1219, align 8
  %1221 = getelementptr i8, ptr %1219, i64 8
  %1222 = load i160, ptr %1221, align 4
  store ptr %.sroa.0.0564.i3357, ptr %1219, align 8
  store i64 %1165, ptr %1221, align 4
  %.sroa_idx161.i3365 = getelementptr i8, ptr %1219, i64 16
  store i64 %1164, ptr %.sroa_idx161.i3365, align 4
  %.sroa_idx162.i3366 = getelementptr i8, ptr %1219, i64 24
  store i32 %.sroa.17.0561.i3360, ptr %.sroa_idx162.i3366, align 4
  %1223 = icmp ne ptr %1220, @nil_typ
  %1224 = icmp ne ptr %1220, null
  %.not90.i3367 = and i1 %1223, %1224
  %extract607.i3369 = lshr i160 %1222, 64
  %1225 = insertelement <2 x i160> poison, i160 %1222, i64 0
  %1226 = insertelement <2 x i160> %1225, i160 %extract607.i3369, i64 1
  br i1 %.not90.i3367, label %.cont.cont.i3375, label %1232

.cont.cont.i3375:                                 ; preds = %1193, %1177
  %vptr.i142.sroa.speculated.i3378 = phi ptr [ %1186, %1177 ], [ %1220, %1193 ]
  %.in4295 = phi <2 x i160> [ %1192, %1177 ], [ %1226, %1193 ]
  %1227 = trunc <2 x i160> %.in4295 to <2 x i64>
  %1228 = xor i1 %.070565.i3356, true
  %hash_coef_ptr.i.i143.i3381 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3378, i64 8
  %tbl_size_ptr.i.i144.i3382 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3378, i64 16
  %offset_tbl_ptr.i.i145.i3383 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3378, i64 40
  %hash_coef.i.i146.i3384 = load i64, ptr %hash_coef_ptr.i.i143.i3381, align 4
  %tbl_size.i.i147.i3385 = load i64, ptr %tbl_size_ptr.i.i144.i3382, align 4
  %offset_tbl.i.i148.i3386 = load ptr, ptr %offset_tbl_ptr.i.i145.i3383, align 8
  %product.i.i.i149.i3387 = mul i64 %hash_coef.i.i146.i3384, 4015701072841558310
  %shifted.i.i.i150.i3388 = lshr i64 %product.i.i.i149.i3387, 32
  %xored.i.i.i151.i3389 = xor i64 %shifted.i.i.i150.i3388, %product.i.i.i149.i3387
  %hash.i.i.i152.i3390 = and i64 %xored.i.i.i151.i3389, %tbl_size.i.i147.i3385
  %offset_ptr.i.i153.i3391 = getelementptr i32, ptr %offset_tbl.i.i148.i3386, i64 %hash.i.i.i152.i3390
  %offset.i.i154.i3392 = load i32, ptr %offset_ptr.i.i153.i3391, align 4
  %1229 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1230 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1231 = icmp ult i32 %.0566.i3355, 99
  br i1 %1231, label %1162, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3410

1232:                                             ; preds = %1193, %1177
  %1233 = phi ptr [ %16, %1193 ], [ %15, %1177 ]
  %1234 = load i32, ptr %62, align 4
  store i32 %1234, ptr %1233, align 4
  %1235 = add i32 %1234, 1
  %1236 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1235, ptr %62, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3410

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3410: ; preds = %.cont.cont.i3375, %1232
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i2648

._crit_edge.i2648:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3410, %1148
  %1237 = add nuw nsw i32 %.060.i2646, 1
  %1238 = icmp slt i32 %1237, %1051
  br i1 %1238, label %1148, label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i2648, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2630.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1579.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1439, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1579
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i1 true, ptr %.sroa.0323.sroa.0, align 8
  %.sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.0. = load i8, ptr %.sroa.0323.sroa.0, align 8
  %.sroa.0323.0.insert.ext = zext i8 %.sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.0. to i160
  %1239 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0323.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1240 = load ptr, ptr %51, align 8
  %1241 = call i32 %1240({ ptr, i160 } %70) #7
  %1242 = load i32, ptr %53, align 8
  %1243 = add i32 %1242, -1
  %1244 = and i32 %1243, %1241
  %1245 = load ptr, ptr %54, align 8
  %1246 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1247 = sext i32 %1244 to i64
  %1248 = shl nsw i64 %1247, 5
  %1249 = getelementptr i8, ptr %1245, i64 %1248
  %1250 = load ptr, ptr %1249, align 8
  %1251 = getelementptr i8, ptr %1249, i64 8
  %1252 = icmp ne ptr %1250, @nil_typ
  %1253 = icmp ne ptr %1250, null
  %.not64.i1643 = and i1 %1252, %1253
  br i1 %.not64.i1643, label %1254, label %1352

1254:                                             ; preds = %CuckooMap_insert_keyK_valueV.exit
  %1255 = load i64, ptr %1251, align 4
  %.sroa_idx.i1645 = getelementptr i8, ptr %1249, i64 16
  %1256 = load i64, ptr %.sroa_idx.i1645, align 4
  %1257 = inttoptr i64 %1255 to ptr
  %1258 = inttoptr i64 %1256 to ptr
  %hash_coef_ptr.i.i66.i1646 = getelementptr i8, ptr %1250, i64 8
  %tbl_size_ptr.i.i67.i1647 = getelementptr i8, ptr %1250, i64 16
  %offset_tbl_ptr.i.i68.i1648 = getelementptr i8, ptr %1250, i64 40
  %hash_coef.i.i69.i1649 = load i64, ptr %hash_coef_ptr.i.i66.i1646, align 4, !noalias !278
  %tbl_size.i.i70.i1650 = load i64, ptr %tbl_size_ptr.i.i67.i1647, align 4, !noalias !278
  %offset_tbl.i.i71.i1651 = load ptr, ptr %offset_tbl_ptr.i.i68.i1648, align 8, !noalias !278
  %product.i.i.i72.i1652 = mul i64 %hash_coef.i.i69.i1649, 4015701072841558310
  %shifted.i.i.i73.i1653 = lshr i64 %product.i.i.i72.i1652, 32
  %xored.i.i.i74.i1654 = xor i64 %shifted.i.i.i73.i1653, %product.i.i.i72.i1652
  %hash.i.i.i75.i1655 = and i64 %xored.i.i.i74.i1654, %tbl_size.i.i70.i1650
  %offset_ptr.i.i76.i1656 = getelementptr i32, ptr %offset_tbl.i.i71.i1651, i64 %hash.i.i.i75.i1655
  %offset.i.i77.i1657 = load i32, ptr %offset_ptr.i.i76.i1656, align 4, !noalias !278
  %1259 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1250, 0
  %1260 = insertvalue { ptr, ptr, ptr, i32 } %1259, ptr %1257, 1
  %1261 = insertvalue { ptr, ptr, ptr, i32 } %1260, ptr %1258, 2
  %1262 = insertvalue { ptr, ptr, ptr, i32 } %1261, i32 %offset.i.i77.i1657, 3
  %1263 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1264 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1250) #35
  %1265 = sext i32 %offset.i.i77.i1657 to i64
  %1266 = getelementptr ptr, ptr %1250, i64 %1265
  %1267 = getelementptr i8, ptr %1266, i64 64
  %1268 = load ptr, ptr %1267, align 8
  %result.i.i1658 = call ptr %1268({ ptr, ptr, ptr, i32 } %1262, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1269 = call i32 %result.i.i1658({ ptr, ptr, ptr, i32 } %1262, { ptr, ptr, ptr, i32 } %1262, ptr nonnull align 8 %2) #7
  %1270 = icmp eq i32 %1269, %1241
  br i1 %1270, label %._crit_edge.i1659, label %1352

._crit_edge.i1659:                                ; preds = %1254
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1272 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1250)
  %1273 = getelementptr i8, ptr %1266, i64 48
  %1274 = load ptr, ptr %1273, align 8
  %result.i79.i1660 = call ptr %1274({ ptr, ptr, ptr, i32 } %1262, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1275 = call { ptr, i160 } %result.i79.i1660({ ptr, ptr, ptr, i32 } %1262, { ptr, ptr, ptr, i32 } %1262, ptr nonnull align 8 %2) #7
  %1276 = load ptr, ptr %52, align 8
  %1277 = call i1 %1276({ ptr, i160 } %1275, { ptr, i160 } %70) #7
  br i1 %1277, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1672, label %1352

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1672: ; preds = %._crit_edge.i1659
  %1278 = load ptr, ptr %result.i428, align 8
  %1279 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1280 = load ptr, ptr %46, align 8
  %1281 = load ptr, ptr %1278, align 8, !alias.scope !281
  %1282 = getelementptr i8, ptr %1281, i64 72
  %1283 = load ptr, ptr %1282, align 8, !alias.scope !281
  %result.i.i.i1664 = call { i64, i64 } %1283(ptr nocapture nofree nonnull readonly %1278) #5, !alias.scope !281
  %1284 = extractvalue { i64, i64 } %result.i.i.i1664, 0
  %1285 = extractvalue { i64, i64 } %result.i.i.i1664, 1
  %1286 = urem i64 20, %1285
  %1287 = icmp eq i64 %1286, 0
  %1288 = sub i64 %1285, %1286
  %1289 = select i1 %1287, i64 0, i64 %1288
  %1290 = add i64 %1284, 20
  %1291 = add i64 %1290, %1289
  %1292 = load ptr, ptr %1280, align 8, !alias.scope !281
  %1293 = getelementptr i8, ptr %1292, i64 72
  %1294 = load ptr, ptr %1293, align 8, !alias.scope !281
  %result.i1.i.i1665 = call { i64, i64 } %1294(ptr nocapture nofree nonnull readonly %1280) #5, !alias.scope !281
  %1295 = extractvalue { i64, i64 } %result.i1.i.i1665, 0
  %1296 = extractvalue { i64, i64 } %result.i1.i.i1665, 1
  %1297 = call i64 @llvm.umax.i64(i64 %1285, i64 %1296)
  %1298 = call i64 @llvm.umax.i64(i64 %1297, i64 8)
  %1299 = urem i64 %1291, %1296
  %1300 = icmp eq i64 %1299, 0
  %1301 = sub i64 %1296, %1299
  %1302 = select i1 %1300, i64 0, i64 %1301
  %1303 = add i64 %1295, %1291
  %1304 = add i64 %1303, %1302
  %1305 = urem i64 %1304, %1298
  %1306 = icmp eq i64 %1305, 0
  %1307 = sub i64 %1298, %1305
  %1308 = select i1 %1306, i64 0, i64 %1307
  %1309 = add i64 %1308, %1304
  %result.i83.i1666 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1309, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1278, ptr %result.i83.i1666, align 8
  %1310 = getelementptr inbounds i8, ptr %result.i83.i1666, i64 8
  store ptr %1280, ptr %1310, align 8
  %1311 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1666)
  %1312 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1313 = load ptr, ptr %1278, align 8
  %1314 = getelementptr i8, ptr %1313, i64 72
  %1315 = load ptr, ptr %1314, align 8
  %result.i.i118.i1667 = call { i64, i64 } %1315(ptr nocapture nofree nonnull readonly %1278) #5
  %1316 = extractvalue { i64, i64 } %result.i.i118.i1667, 1
  %1317 = urem i64 20, %1316
  %1318 = icmp eq i64 %1317, 0
  %reass.sub = sub i64 %1316, %1317
  %1319 = add i64 %reass.sub, 20
  %1320 = select i1 %1318, i64 20, i64 %1319
  %1321 = getelementptr i8, ptr %result.i83.i1666, i64 %1320
  %1322 = getelementptr i8, ptr %1313, i64 64
  %1323 = load ptr, ptr %1322, align 8
  call void %1323({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %1278, ptr nocapture nofree writeonly %1321) #1
  %1324 = load ptr, ptr %result.i83.i1666, align 8
  %1325 = load ptr, ptr %1324, align 8
  %1326 = getelementptr i8, ptr %1325, i64 72
  %1327 = load ptr, ptr %1326, align 8
  %result.i.i119.i1669 = call { i64, i64 } %1327(ptr nocapture nofree nonnull readonly %1324) #5
  %1328 = extractvalue { i64, i64 } %result.i.i119.i1669, 0
  %1329 = extractvalue { i64, i64 } %result.i.i119.i1669, 1
  %1330 = urem i64 20, %1329
  %1331 = icmp eq i64 %1330, 0
  %1332 = sub i64 %1329, %1330
  %1333 = select i1 %1331, i64 0, i64 %1332
  %1334 = add i64 %1328, 20
  %1335 = add i64 %1334, %1333
  %1336 = load ptr, ptr %1310, align 8
  %1337 = load ptr, ptr %1336, align 8
  %1338 = getelementptr i8, ptr %1337, i64 72
  %1339 = load ptr, ptr %1338, align 8
  %result.i1.i120.i1670 = call { i64, i64 } %1339(ptr nocapture nofree nonnull readonly %1336) #5
  %1340 = extractvalue { i64, i64 } %result.i1.i120.i1670, 1
  %1341 = urem i64 %1335, %1340
  %1342 = icmp eq i64 %1341, 0
  %1343 = sub i64 %1340, %1341
  %1344 = select i1 %1342, i64 0, i64 %1343
  %1345 = getelementptr i8, ptr %result.i83.i1666, i64 %1335
  %1346 = getelementptr i8, ptr %1345, i64 %1344
  %1347 = getelementptr i8, ptr %1337, i64 64
  %1348 = load ptr, ptr %1347, align 8
  call void %1348({ ptr, i160 } %1239, ptr nocapture nofree nonnull readonly %1336, ptr nocapture nofree writeonly %1346) #1
  %1349 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1350 = getelementptr inbounds i8, ptr %result.i83.i1666, i64 16
  store i32 %1241, ptr %1350, align 8
  store ptr @Entry, ptr %1249, align 8
  %1351 = ptrtoint ptr %result.i83.i1666 to i64
  store i64 %1351, ptr %1251, align 4
  %.sroa_idx28.i1671 = getelementptr i8, ptr %1249, i64 24
  store i32 10, ptr %.sroa_idx28.i1671, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit982

1352:                                             ; preds = %._crit_edge.i1659, %CuckooMap_insert_keyK_valueV.exit, %1254
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1353 = add i32 %1241, 2127912214
  %1354 = shl i32 %1241, 12
  %1355 = add i32 %1353, %1354
  %1356 = ashr i32 %1355, 19
  %1357 = xor i32 %1355, %1356
  %1358 = xor i32 %1357, -949894596
  %1359 = add i32 %1358, 374761393
  %1360 = shl i32 %1358, 5
  %1361 = add i32 %1359, %1360
  %1362 = add i32 %1361, -744332180
  %1363 = shl i32 %1361, 9
  %1364 = xor i32 %1362, %1363
  %1365 = add i32 %1364, -42973499
  %1366 = shl i32 %1364, 3
  %1367 = add i32 %1365, %1366
  %1368 = ashr i32 %1367, 16
  %1369 = xor i32 %1367, %1368
  %1370 = xor i32 %1369, -1252372727
  %1371 = load i32, ptr %53, align 8
  %1372 = add i32 %1371, -1
  %1373 = and i32 %1372, %1370
  %1374 = load ptr, ptr %55, align 8
  %1375 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1376 = sext i32 %1373 to i64
  %1377 = shl nsw i64 %1376, 5
  %1378 = getelementptr i8, ptr %1374, i64 %1377
  %1379 = load ptr, ptr %1378, align 8
  %1380 = getelementptr i8, ptr %1378, i64 8
  %1381 = icmp ne ptr %1379, @nil_typ
  %1382 = icmp ne ptr %1379, null
  %.not64.i1702 = and i1 %1381, %1382
  br i1 %.not64.i1702, label %1383, label %1482

1383:                                             ; preds = %1352
  %1384 = load i64, ptr %1380, align 4
  %.sroa_idx.i1704 = getelementptr i8, ptr %1378, i64 16
  %1385 = load i64, ptr %.sroa_idx.i1704, align 4
  %1386 = inttoptr i64 %1384 to ptr
  %1387 = inttoptr i64 %1385 to ptr
  %hash_coef_ptr.i.i66.i1705 = getelementptr i8, ptr %1379, i64 8
  %tbl_size_ptr.i.i67.i1706 = getelementptr i8, ptr %1379, i64 16
  %offset_tbl_ptr.i.i68.i1707 = getelementptr i8, ptr %1379, i64 40
  %hash_coef.i.i69.i1708 = load i64, ptr %hash_coef_ptr.i.i66.i1705, align 4, !noalias !284
  %tbl_size.i.i70.i1709 = load i64, ptr %tbl_size_ptr.i.i67.i1706, align 4, !noalias !284
  %offset_tbl.i.i71.i1710 = load ptr, ptr %offset_tbl_ptr.i.i68.i1707, align 8, !noalias !284
  %product.i.i.i72.i1711 = mul i64 %hash_coef.i.i69.i1708, 4015701072841558310
  %shifted.i.i.i73.i1712 = lshr i64 %product.i.i.i72.i1711, 32
  %xored.i.i.i74.i1713 = xor i64 %shifted.i.i.i73.i1712, %product.i.i.i72.i1711
  %hash.i.i.i75.i1714 = and i64 %xored.i.i.i74.i1713, %tbl_size.i.i70.i1709
  %offset_ptr.i.i76.i1715 = getelementptr i32, ptr %offset_tbl.i.i71.i1710, i64 %hash.i.i.i75.i1714
  %offset.i.i77.i1716 = load i32, ptr %offset_ptr.i.i76.i1715, align 4, !noalias !284
  %1388 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1379, 0
  %1389 = insertvalue { ptr, ptr, ptr, i32 } %1388, ptr %1386, 1
  %1390 = insertvalue { ptr, ptr, ptr, i32 } %1389, ptr %1387, 2
  %1391 = insertvalue { ptr, ptr, ptr, i32 } %1390, i32 %offset.i.i77.i1716, 3
  %1392 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1393 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1379) #35
  %1394 = sext i32 %offset.i.i77.i1716 to i64
  %1395 = getelementptr ptr, ptr %1379, i64 %1394
  %1396 = getelementptr i8, ptr %1395, i64 64
  %1397 = load ptr, ptr %1396, align 8
  %result.i.i1717 = call ptr %1397({ ptr, ptr, ptr, i32 } %1391, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1398 = call i32 %result.i.i1717({ ptr, ptr, ptr, i32 } %1391, { ptr, ptr, ptr, i32 } %1391, ptr nonnull align 8 %2) #7
  %1399 = icmp eq i32 %1398, %1241
  br i1 %1399, label %._crit_edge.i1718, label %1482

._crit_edge.i1718:                                ; preds = %1383
  %1400 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1401 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1379)
  %1402 = getelementptr i8, ptr %1395, i64 48
  %1403 = load ptr, ptr %1402, align 8
  %result.i79.i1719 = call ptr %1403({ ptr, ptr, ptr, i32 } %1391, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1404 = call { ptr, i160 } %result.i79.i1719({ ptr, ptr, ptr, i32 } %1391, { ptr, ptr, ptr, i32 } %1391, ptr nonnull align 8 %2) #7
  %1405 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1406 = load ptr, ptr %52, align 8
  %1407 = call i1 %1406({ ptr, i160 } %1404, { ptr, i160 } %70) #7
  br i1 %1407, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1731, label %1482

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1731: ; preds = %._crit_edge.i1718
  %1408 = load ptr, ptr %result.i428, align 8
  %1409 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1410 = load ptr, ptr %46, align 8
  %1411 = load ptr, ptr %1408, align 8, !alias.scope !287
  %1412 = getelementptr i8, ptr %1411, i64 72
  %1413 = load ptr, ptr %1412, align 8, !alias.scope !287
  %result.i.i.i1723 = call { i64, i64 } %1413(ptr nocapture nofree nonnull readonly %1408) #5, !alias.scope !287
  %1414 = extractvalue { i64, i64 } %result.i.i.i1723, 0
  %1415 = extractvalue { i64, i64 } %result.i.i.i1723, 1
  %1416 = urem i64 20, %1415
  %1417 = icmp eq i64 %1416, 0
  %1418 = sub i64 %1415, %1416
  %1419 = select i1 %1417, i64 0, i64 %1418
  %1420 = add i64 %1414, 20
  %1421 = add i64 %1420, %1419
  %1422 = load ptr, ptr %1410, align 8, !alias.scope !287
  %1423 = getelementptr i8, ptr %1422, i64 72
  %1424 = load ptr, ptr %1423, align 8, !alias.scope !287
  %result.i1.i.i1724 = call { i64, i64 } %1424(ptr nocapture nofree nonnull readonly %1410) #5, !alias.scope !287
  %1425 = extractvalue { i64, i64 } %result.i1.i.i1724, 0
  %1426 = extractvalue { i64, i64 } %result.i1.i.i1724, 1
  %1427 = call i64 @llvm.umax.i64(i64 %1415, i64 %1426)
  %1428 = call i64 @llvm.umax.i64(i64 %1427, i64 8)
  %1429 = urem i64 %1421, %1426
  %1430 = icmp eq i64 %1429, 0
  %1431 = sub i64 %1426, %1429
  %1432 = select i1 %1430, i64 0, i64 %1431
  %1433 = add i64 %1425, %1421
  %1434 = add i64 %1433, %1432
  %1435 = urem i64 %1434, %1428
  %1436 = icmp eq i64 %1435, 0
  %1437 = sub i64 %1428, %1435
  %1438 = select i1 %1436, i64 0, i64 %1437
  %1439 = add i64 %1438, %1434
  %result.i83.i1725 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1439, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1408, ptr %result.i83.i1725, align 8
  %1440 = getelementptr inbounds i8, ptr %result.i83.i1725, i64 8
  store ptr %1410, ptr %1440, align 8
  %1441 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1725)
  %1442 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1443 = load ptr, ptr %1408, align 8
  %1444 = getelementptr i8, ptr %1443, i64 72
  %1445 = load ptr, ptr %1444, align 8
  %result.i.i118.i1726 = call { i64, i64 } %1445(ptr nocapture nofree nonnull readonly %1408) #5
  %1446 = extractvalue { i64, i64 } %result.i.i118.i1726, 1
  %1447 = urem i64 20, %1446
  %1448 = icmp eq i64 %1447, 0
  %reass.sub4288 = sub i64 %1446, %1447
  %1449 = add i64 %reass.sub4288, 20
  %1450 = select i1 %1448, i64 20, i64 %1449
  %1451 = getelementptr i8, ptr %result.i83.i1725, i64 %1450
  %1452 = getelementptr i8, ptr %1443, i64 64
  %1453 = load ptr, ptr %1452, align 8
  call void %1453({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %1408, ptr nocapture nofree writeonly %1451) #1
  %1454 = load ptr, ptr %result.i83.i1725, align 8
  %1455 = load ptr, ptr %1454, align 8
  %1456 = getelementptr i8, ptr %1455, i64 72
  %1457 = load ptr, ptr %1456, align 8
  %result.i.i119.i1728 = call { i64, i64 } %1457(ptr nocapture nofree nonnull readonly %1454) #5
  %1458 = extractvalue { i64, i64 } %result.i.i119.i1728, 0
  %1459 = extractvalue { i64, i64 } %result.i.i119.i1728, 1
  %1460 = urem i64 20, %1459
  %1461 = icmp eq i64 %1460, 0
  %1462 = sub i64 %1459, %1460
  %1463 = select i1 %1461, i64 0, i64 %1462
  %1464 = add i64 %1458, 20
  %1465 = add i64 %1464, %1463
  %1466 = load ptr, ptr %1440, align 8
  %1467 = load ptr, ptr %1466, align 8
  %1468 = getelementptr i8, ptr %1467, i64 72
  %1469 = load ptr, ptr %1468, align 8
  %result.i1.i120.i1729 = call { i64, i64 } %1469(ptr nocapture nofree nonnull readonly %1466) #5
  %1470 = extractvalue { i64, i64 } %result.i1.i120.i1729, 1
  %1471 = urem i64 %1465, %1470
  %1472 = icmp eq i64 %1471, 0
  %1473 = sub i64 %1470, %1471
  %1474 = select i1 %1472, i64 0, i64 %1473
  %1475 = getelementptr i8, ptr %result.i83.i1725, i64 %1465
  %1476 = getelementptr i8, ptr %1475, i64 %1474
  %1477 = getelementptr i8, ptr %1467, i64 64
  %1478 = load ptr, ptr %1477, align 8
  call void %1478({ ptr, i160 } %1239, ptr nocapture nofree nonnull readonly %1466, ptr nocapture nofree writeonly %1476) #1
  %1479 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1480 = getelementptr inbounds i8, ptr %result.i83.i1725, i64 16
  store i32 %1241, ptr %1480, align 8
  store ptr @Entry, ptr %1378, align 8
  %1481 = ptrtoint ptr %result.i83.i1725 to i64
  store i64 %1481, ptr %1380, align 4
  %.sroa_idx28.i1730 = getelementptr i8, ptr %1378, i64 24
  store i32 10, ptr %.sroa_idx28.i1730, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit982

1482:                                             ; preds = %._crit_edge.i1718, %1352, %1383
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1483 = load i32, ptr %63, align 4
  %1484 = load i32, ptr %53, align 8
  %.not.i940 = icmp slt i32 %1483, %1484
  br i1 %.not.i940, label %._crit_edge.i942, label %1485

1485:                                             ; preds = %1482
  %1486 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1487 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1488 = load ptr, ptr %54, align 8
  %1489 = load ptr, ptr %55, align 8
  %1490 = shl i32 %1484, 1
  %spec.select.i1747 = call i32 @llvm.smax.i32(i32 %1490, i32 16)
  store i32 %spec.select.i1747, ptr %53, align 8
  %1491 = zext nneg i32 %spec.select.i1747 to i64
  %1492 = shl nuw nsw i64 %1491, 5
  %result.i.i1748 = call noalias ptr @bump_malloc_inner(i64 noundef %1492, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1748, ptr %54, align 8
  %result.i20.i1749 = call noalias ptr @bump_malloc_inner(i64 noundef %1492, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1749, ptr %55, align 8
  store i32 0, ptr %63, align 4
  %1493 = icmp sgt i32 %1484, 0
  br i1 %1493, label %.lr.ph.i2669, label %._crit_edge.i942

.lr.ph.i2669:                                     ; preds = %1485, %._crit_edge.i2684
  %.060.i2682 = phi i32 [ %1582, %._crit_edge.i2684 ], [ 0, %1485 ]
  %1494 = zext nneg i32 %.060.i2682 to i64
  %1495 = shl nuw nsw i64 %1494, 5
  %1496 = getelementptr i8, ptr %1488, i64 %1495
  %1497 = load ptr, ptr %1496, align 8
  %1498 = icmp ne ptr %1497, @nil_typ
  %1499 = icmp ne ptr %1497, null
  %.not16.i2683 = and i1 %1498, %1499
  br i1 %.not16.i2683, label %1500, label %._crit_edge.i2684

1500:                                             ; preds = %.lr.ph.i2669
  %1501 = getelementptr i8, ptr %1496, i64 8
  %1502 = load <2 x i64>, ptr %1501, align 4
  %hash_coef_ptr.i.i18.i2686 = getelementptr i8, ptr %1497, i64 8
  %tbl_size_ptr.i.i19.i2687 = getelementptr i8, ptr %1497, i64 16
  %offset_tbl_ptr.i.i20.i2688 = getelementptr i8, ptr %1497, i64 40
  %1503 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i3428 = load i64, ptr %hash_coef_ptr.i.i18.i2686, align 4, !noalias !22
  %tbl_size.i.i100.i3429 = load i64, ptr %tbl_size_ptr.i.i19.i2687, align 4, !noalias !22
  %offset_tbl.i.i101.i3430 = load ptr, ptr %offset_tbl_ptr.i.i20.i2688, align 8, !noalias !22
  %product.i.i.i102.i3431 = mul i64 %hash_coef.i.i99.i3428, 4015701072841558310
  %shifted.i.i.i103.i3432 = lshr i64 %product.i.i.i102.i3431, 32
  %xored.i.i.i104.i3433 = xor i64 %shifted.i.i.i103.i3432, %product.i.i.i102.i3431
  %hash.i.i.i105.i3434 = and i64 %xored.i.i.i104.i3433, %tbl_size.i.i100.i3429
  %offset_ptr.i.i106.i3435 = getelementptr i32, ptr %offset_tbl.i.i101.i3430, i64 %hash.i.i.i105.i3434
  %offset.i.i121.i3436 = load i32, ptr %offset_ptr.i.i106.i3435, align 4, !noalias !290
  %1504 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1505 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1506 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1507

1507:                                             ; preds = %.cont.cont.i3457, %1500
  %.0566.i3437 = phi i32 [ 0, %1500 ], [ %1511, %.cont.cont.i3457 ]
  %.070565.i3438 = phi i1 [ true, %1500 ], [ %1573, %.cont.cont.i3457 ]
  %.sroa.0.0564.i3439 = phi ptr [ %1497, %1500 ], [ %vptr.i142.sroa.speculated.i3460, %.cont.cont.i3457 ]
  %.sroa.17.0561.i3442 = phi i32 [ %offset.i.i121.i3436, %1500 ], [ %offset.i.i154.i3474, %.cont.cont.i3457 ]
  %1508 = phi <2 x i64> [ %1502, %1500 ], [ %1572, %.cont.cont.i3457 ]
  %1509 = extractelement <2 x i64> %1508, i64 1
  %.sroa.12.0562.i3441 = inttoptr i64 %1509 to ptr
  %1510 = extractelement <2 x i64> %1508, i64 0
  %.sroa.6.0563.i3440 = inttoptr i64 %1510 to ptr
  %1511 = add nuw nsw i32 %.0566.i3437, 1
  %1512 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3439, 0
  %1513 = insertvalue { ptr, ptr, ptr, i32 } %1512, ptr %.sroa.6.0563.i3440, 1
  %1514 = insertvalue { ptr, ptr, ptr, i32 } %1513, ptr %.sroa.12.0562.i3441, 2
  %1515 = insertvalue { ptr, ptr, ptr, i32 } %1514, i32 %.sroa.17.0561.i3442, 3
  %1516 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3439)
  %1517 = sext i32 %.sroa.17.0561.i3442 to i64
  %1518 = getelementptr ptr, ptr %.sroa.0.0564.i3439, i64 %1517
  %1519 = getelementptr i8, ptr %1518, i64 64
  %1520 = load ptr, ptr %1519, align 8
  %result.i125.i3443 = call ptr %1520({ ptr, ptr, ptr, i32 } %1515, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1521 = call i32 %result.i125.i3443({ ptr, ptr, ptr, i32 } %1515, { ptr, ptr, ptr, i32 } %1515, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3438, label %1522, label %1538

1522:                                             ; preds = %1507
  %1523 = load i32, ptr %53, align 8
  %1524 = add i32 %1523, -1
  %1525 = and i32 %1524, %1521
  %1526 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1527 = load ptr, ptr %54, align 8
  %1528 = sext i32 %1525 to i64
  %1529 = shl nsw i64 %1528, 5
  %1530 = getelementptr i8, ptr %1527, i64 %1529
  %1531 = load ptr, ptr %1530, align 8
  %1532 = getelementptr i8, ptr %1530, i64 8
  %1533 = load i160, ptr %1532, align 4
  store ptr %.sroa.0.0564.i3439, ptr %1530, align 8
  store i64 %1510, ptr %1532, align 4
  %.sroa_idx157.i3486 = getelementptr i8, ptr %1530, i64 16
  store i64 %1509, ptr %.sroa_idx157.i3486, align 4
  %.sroa_idx158.i3487 = getelementptr i8, ptr %1530, i64 24
  store i32 %.sroa.17.0561.i3442, ptr %.sroa_idx158.i3487, align 4
  %1534 = icmp ne ptr %1531, @nil_typ
  %1535 = icmp ne ptr %1531, null
  %.not92.i3488 = and i1 %1534, %1535
  %extract.i3490 = lshr i160 %1533, 64
  %1536 = insertelement <2 x i160> poison, i160 %1533, i64 0
  %1537 = insertelement <2 x i160> %1536, i160 %extract.i3490, i64 1
  br i1 %.not92.i3488, label %.cont.cont.i3457, label %1577

1538:                                             ; preds = %1507
  %1539 = add i32 %1521, 2127912214
  %1540 = shl i32 %1521, 12
  %1541 = add i32 %1539, %1540
  %1542 = ashr i32 %1541, 19
  %1543 = xor i32 %1541, %1542
  %1544 = xor i32 %1543, -949894596
  %1545 = add i32 %1544, 374761393
  %1546 = shl i32 %1544, 5
  %1547 = add i32 %1545, %1546
  %1548 = add i32 %1547, -744332180
  %1549 = shl i32 %1547, 9
  %1550 = xor i32 %1548, %1549
  %1551 = add i32 %1550, -42973499
  %1552 = shl i32 %1550, 3
  %1553 = add i32 %1551, %1552
  %1554 = ashr i32 %1553, 16
  %1555 = xor i32 %1553, %1554
  %1556 = xor i32 %1555, -1252372727
  %1557 = load i32, ptr %53, align 8
  %1558 = add i32 %1557, -1
  %1559 = and i32 %1558, %1556
  %1560 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1561 = load ptr, ptr %55, align 8
  %1562 = sext i32 %1559 to i64
  %1563 = shl nsw i64 %1562, 5
  %1564 = getelementptr i8, ptr %1561, i64 %1563
  %1565 = load ptr, ptr %1564, align 8
  %1566 = getelementptr i8, ptr %1564, i64 8
  %1567 = load i160, ptr %1566, align 4
  store ptr %.sroa.0.0564.i3439, ptr %1564, align 8
  store i64 %1510, ptr %1566, align 4
  %.sroa_idx161.i3447 = getelementptr i8, ptr %1564, i64 16
  store i64 %1509, ptr %.sroa_idx161.i3447, align 4
  %.sroa_idx162.i3448 = getelementptr i8, ptr %1564, i64 24
  store i32 %.sroa.17.0561.i3442, ptr %.sroa_idx162.i3448, align 4
  %1568 = icmp ne ptr %1565, @nil_typ
  %1569 = icmp ne ptr %1565, null
  %.not90.i3449 = and i1 %1568, %1569
  %extract607.i3451 = lshr i160 %1567, 64
  %1570 = insertelement <2 x i160> poison, i160 %1567, i64 0
  %1571 = insertelement <2 x i160> %1570, i160 %extract607.i3451, i64 1
  br i1 %.not90.i3449, label %.cont.cont.i3457, label %1577

.cont.cont.i3457:                                 ; preds = %1538, %1522
  %vptr.i142.sroa.speculated.i3460 = phi ptr [ %1531, %1522 ], [ %1565, %1538 ]
  %.in4296 = phi <2 x i160> [ %1537, %1522 ], [ %1571, %1538 ]
  %1572 = trunc <2 x i160> %.in4296 to <2 x i64>
  %1573 = xor i1 %.070565.i3438, true
  %hash_coef_ptr.i.i143.i3463 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3460, i64 8
  %tbl_size_ptr.i.i144.i3464 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3460, i64 16
  %offset_tbl_ptr.i.i145.i3465 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3460, i64 40
  %hash_coef.i.i146.i3466 = load i64, ptr %hash_coef_ptr.i.i143.i3463, align 4
  %tbl_size.i.i147.i3467 = load i64, ptr %tbl_size_ptr.i.i144.i3464, align 4
  %offset_tbl.i.i148.i3468 = load ptr, ptr %offset_tbl_ptr.i.i145.i3465, align 8
  %product.i.i.i149.i3469 = mul i64 %hash_coef.i.i146.i3466, 4015701072841558310
  %shifted.i.i.i150.i3470 = lshr i64 %product.i.i.i149.i3469, 32
  %xored.i.i.i151.i3471 = xor i64 %shifted.i.i.i150.i3470, %product.i.i.i149.i3469
  %hash.i.i.i152.i3472 = and i64 %xored.i.i.i151.i3471, %tbl_size.i.i147.i3467
  %offset_ptr.i.i153.i3473 = getelementptr i32, ptr %offset_tbl.i.i148.i3468, i64 %hash.i.i.i152.i3472
  %offset.i.i154.i3474 = load i32, ptr %offset_ptr.i.i153.i3473, align 4
  %1574 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1575 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1576 = icmp ult i32 %.0566.i3437, 99
  br i1 %1576, label %1507, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3492

1577:                                             ; preds = %1538, %1522
  %1578 = phi ptr [ %14, %1538 ], [ %13, %1522 ]
  %1579 = load i32, ptr %63, align 4
  store i32 %1579, ptr %1578, align 4
  %1580 = add i32 %1579, 1
  %1581 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1580, ptr %63, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3492

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3492: ; preds = %.cont.cont.i3457, %1577
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i2684

._crit_edge.i2684:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3492, %.lr.ph.i2669
  %1582 = add nuw nsw i32 %.060.i2682, 1
  %1583 = icmp slt i32 %1582, %1484
  br i1 %1583, label %.lr.ph.i2669, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2702

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2702: ; preds = %._crit_edge.i2684, %._crit_edge.i2720
  %.060.i2718 = phi i32 [ %1672, %._crit_edge.i2720 ], [ 0, %._crit_edge.i2684 ]
  %1584 = zext nneg i32 %.060.i2718 to i64
  %1585 = shl nuw nsw i64 %1584, 5
  %1586 = getelementptr i8, ptr %1489, i64 %1585
  %1587 = load ptr, ptr %1586, align 8
  %1588 = icmp ne ptr %1587, @nil_typ
  %1589 = icmp ne ptr %1587, null
  %.not16.i2719 = and i1 %1588, %1589
  br i1 %.not16.i2719, label %1590, label %._crit_edge.i2720

1590:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2702
  %1591 = getelementptr i8, ptr %1586, i64 8
  %1592 = load <2 x i64>, ptr %1591, align 4
  %hash_coef_ptr.i.i18.i2722 = getelementptr i8, ptr %1587, i64 8
  %tbl_size_ptr.i.i19.i2723 = getelementptr i8, ptr %1587, i64 16
  %offset_tbl_ptr.i.i20.i2724 = getelementptr i8, ptr %1587, i64 40
  %1593 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i3510 = load i64, ptr %hash_coef_ptr.i.i18.i2722, align 4, !noalias !22
  %tbl_size.i.i100.i3511 = load i64, ptr %tbl_size_ptr.i.i19.i2723, align 4, !noalias !22
  %offset_tbl.i.i101.i3512 = load ptr, ptr %offset_tbl_ptr.i.i20.i2724, align 8, !noalias !22
  %product.i.i.i102.i3513 = mul i64 %hash_coef.i.i99.i3510, 4015701072841558310
  %shifted.i.i.i103.i3514 = lshr i64 %product.i.i.i102.i3513, 32
  %xored.i.i.i104.i3515 = xor i64 %shifted.i.i.i103.i3514, %product.i.i.i102.i3513
  %hash.i.i.i105.i3516 = and i64 %xored.i.i.i104.i3515, %tbl_size.i.i100.i3511
  %offset_ptr.i.i106.i3517 = getelementptr i32, ptr %offset_tbl.i.i101.i3512, i64 %hash.i.i.i105.i3516
  %offset.i.i121.i3518 = load i32, ptr %offset_ptr.i.i106.i3517, align 4, !noalias !293
  %1594 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1595 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1596 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1597

1597:                                             ; preds = %.cont.cont.i3539, %1590
  %.0566.i3519 = phi i32 [ 0, %1590 ], [ %1601, %.cont.cont.i3539 ]
  %.070565.i3520 = phi i1 [ true, %1590 ], [ %1663, %.cont.cont.i3539 ]
  %.sroa.0.0564.i3521 = phi ptr [ %1587, %1590 ], [ %vptr.i142.sroa.speculated.i3542, %.cont.cont.i3539 ]
  %.sroa.17.0561.i3524 = phi i32 [ %offset.i.i121.i3518, %1590 ], [ %offset.i.i154.i3556, %.cont.cont.i3539 ]
  %1598 = phi <2 x i64> [ %1592, %1590 ], [ %1662, %.cont.cont.i3539 ]
  %1599 = extractelement <2 x i64> %1598, i64 1
  %.sroa.12.0562.i3523 = inttoptr i64 %1599 to ptr
  %1600 = extractelement <2 x i64> %1598, i64 0
  %.sroa.6.0563.i3522 = inttoptr i64 %1600 to ptr
  %1601 = add nuw nsw i32 %.0566.i3519, 1
  %1602 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3521, 0
  %1603 = insertvalue { ptr, ptr, ptr, i32 } %1602, ptr %.sroa.6.0563.i3522, 1
  %1604 = insertvalue { ptr, ptr, ptr, i32 } %1603, ptr %.sroa.12.0562.i3523, 2
  %1605 = insertvalue { ptr, ptr, ptr, i32 } %1604, i32 %.sroa.17.0561.i3524, 3
  %1606 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3521)
  %1607 = sext i32 %.sroa.17.0561.i3524 to i64
  %1608 = getelementptr ptr, ptr %.sroa.0.0564.i3521, i64 %1607
  %1609 = getelementptr i8, ptr %1608, i64 64
  %1610 = load ptr, ptr %1609, align 8
  %result.i125.i3525 = call ptr %1610({ ptr, ptr, ptr, i32 } %1605, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1611 = call i32 %result.i125.i3525({ ptr, ptr, ptr, i32 } %1605, { ptr, ptr, ptr, i32 } %1605, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3520, label %1612, label %1628

1612:                                             ; preds = %1597
  %1613 = load i32, ptr %53, align 8
  %1614 = add i32 %1613, -1
  %1615 = and i32 %1614, %1611
  %1616 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1617 = load ptr, ptr %54, align 8
  %1618 = sext i32 %1615 to i64
  %1619 = shl nsw i64 %1618, 5
  %1620 = getelementptr i8, ptr %1617, i64 %1619
  %1621 = load ptr, ptr %1620, align 8
  %1622 = getelementptr i8, ptr %1620, i64 8
  %1623 = load i160, ptr %1622, align 4
  store ptr %.sroa.0.0564.i3521, ptr %1620, align 8
  store i64 %1600, ptr %1622, align 4
  %.sroa_idx157.i3568 = getelementptr i8, ptr %1620, i64 16
  store i64 %1599, ptr %.sroa_idx157.i3568, align 4
  %.sroa_idx158.i3569 = getelementptr i8, ptr %1620, i64 24
  store i32 %.sroa.17.0561.i3524, ptr %.sroa_idx158.i3569, align 4
  %1624 = icmp ne ptr %1621, @nil_typ
  %1625 = icmp ne ptr %1621, null
  %.not92.i3570 = and i1 %1624, %1625
  %extract.i3572 = lshr i160 %1623, 64
  %1626 = insertelement <2 x i160> poison, i160 %1623, i64 0
  %1627 = insertelement <2 x i160> %1626, i160 %extract.i3572, i64 1
  br i1 %.not92.i3570, label %.cont.cont.i3539, label %1667

1628:                                             ; preds = %1597
  %1629 = add i32 %1611, 2127912214
  %1630 = shl i32 %1611, 12
  %1631 = add i32 %1629, %1630
  %1632 = ashr i32 %1631, 19
  %1633 = xor i32 %1631, %1632
  %1634 = xor i32 %1633, -949894596
  %1635 = add i32 %1634, 374761393
  %1636 = shl i32 %1634, 5
  %1637 = add i32 %1635, %1636
  %1638 = add i32 %1637, -744332180
  %1639 = shl i32 %1637, 9
  %1640 = xor i32 %1638, %1639
  %1641 = add i32 %1640, -42973499
  %1642 = shl i32 %1640, 3
  %1643 = add i32 %1641, %1642
  %1644 = ashr i32 %1643, 16
  %1645 = xor i32 %1643, %1644
  %1646 = xor i32 %1645, -1252372727
  %1647 = load i32, ptr %53, align 8
  %1648 = add i32 %1647, -1
  %1649 = and i32 %1648, %1646
  %1650 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1651 = load ptr, ptr %55, align 8
  %1652 = sext i32 %1649 to i64
  %1653 = shl nsw i64 %1652, 5
  %1654 = getelementptr i8, ptr %1651, i64 %1653
  %1655 = load ptr, ptr %1654, align 8
  %1656 = getelementptr i8, ptr %1654, i64 8
  %1657 = load i160, ptr %1656, align 4
  store ptr %.sroa.0.0564.i3521, ptr %1654, align 8
  store i64 %1600, ptr %1656, align 4
  %.sroa_idx161.i3529 = getelementptr i8, ptr %1654, i64 16
  store i64 %1599, ptr %.sroa_idx161.i3529, align 4
  %.sroa_idx162.i3530 = getelementptr i8, ptr %1654, i64 24
  store i32 %.sroa.17.0561.i3524, ptr %.sroa_idx162.i3530, align 4
  %1658 = icmp ne ptr %1655, @nil_typ
  %1659 = icmp ne ptr %1655, null
  %.not90.i3531 = and i1 %1658, %1659
  %extract607.i3533 = lshr i160 %1657, 64
  %1660 = insertelement <2 x i160> poison, i160 %1657, i64 0
  %1661 = insertelement <2 x i160> %1660, i160 %extract607.i3533, i64 1
  br i1 %.not90.i3531, label %.cont.cont.i3539, label %1667

.cont.cont.i3539:                                 ; preds = %1628, %1612
  %vptr.i142.sroa.speculated.i3542 = phi ptr [ %1621, %1612 ], [ %1655, %1628 ]
  %.in4297 = phi <2 x i160> [ %1627, %1612 ], [ %1661, %1628 ]
  %1662 = trunc <2 x i160> %.in4297 to <2 x i64>
  %1663 = xor i1 %.070565.i3520, true
  %hash_coef_ptr.i.i143.i3545 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3542, i64 8
  %tbl_size_ptr.i.i144.i3546 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3542, i64 16
  %offset_tbl_ptr.i.i145.i3547 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3542, i64 40
  %hash_coef.i.i146.i3548 = load i64, ptr %hash_coef_ptr.i.i143.i3545, align 4
  %tbl_size.i.i147.i3549 = load i64, ptr %tbl_size_ptr.i.i144.i3546, align 4
  %offset_tbl.i.i148.i3550 = load ptr, ptr %offset_tbl_ptr.i.i145.i3547, align 8
  %product.i.i.i149.i3551 = mul i64 %hash_coef.i.i146.i3548, 4015701072841558310
  %shifted.i.i.i150.i3552 = lshr i64 %product.i.i.i149.i3551, 32
  %xored.i.i.i151.i3553 = xor i64 %shifted.i.i.i150.i3552, %product.i.i.i149.i3551
  %hash.i.i.i152.i3554 = and i64 %xored.i.i.i151.i3553, %tbl_size.i.i147.i3549
  %offset_ptr.i.i153.i3555 = getelementptr i32, ptr %offset_tbl.i.i148.i3550, i64 %hash.i.i.i152.i3554
  %offset.i.i154.i3556 = load i32, ptr %offset_ptr.i.i153.i3555, align 4
  %1664 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1665 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1666 = icmp ult i32 %.0566.i3519, 99
  br i1 %1666, label %1597, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3574

1667:                                             ; preds = %1628, %1612
  %1668 = phi ptr [ %12, %1628 ], [ %11, %1612 ]
  %1669 = load i32, ptr %63, align 4
  store i32 %1669, ptr %1668, align 4
  %1670 = add i32 %1669, 1
  %1671 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1670, ptr %63, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3574

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3574: ; preds = %.cont.cont.i3539, %1667
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %._crit_edge.i2720

._crit_edge.i2720:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3574, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2702
  %1672 = add nuw nsw i32 %.060.i2718, 1
  %1673 = icmp slt i32 %1672, %1484
  br i1 %1673, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2702, label %._crit_edge.i942

._crit_edge.i942:                                 ; preds = %._crit_edge.i2720, %1485, %1482
  %1674 = load ptr, ptr %result.i428, align 8
  %1675 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1676 = load ptr, ptr %46, align 8
  %1677 = load ptr, ptr %1674, align 8
  %1678 = getelementptr i8, ptr %1677, i64 72
  %1679 = load ptr, ptr %1678, align 8
  %result.i.i.i945 = call { i64, i64 } %1679(ptr nocapture nofree nonnull readonly %1674) #5
  %1680 = extractvalue { i64, i64 } %result.i.i.i945, 0
  %1681 = extractvalue { i64, i64 } %result.i.i.i945, 1
  %1682 = urem i64 20, %1681
  %1683 = icmp eq i64 %1682, 0
  %1684 = sub i64 %1681, %1682
  %1685 = select i1 %1683, i64 0, i64 %1684
  %1686 = add i64 %1680, 20
  %1687 = add i64 %1686, %1685
  %1688 = load ptr, ptr %1676, align 8
  %1689 = getelementptr i8, ptr %1688, i64 72
  %1690 = load ptr, ptr %1689, align 8
  %result.i1.i.i946 = call { i64, i64 } %1690(ptr nocapture nofree nonnull readonly %1676) #5
  %1691 = extractvalue { i64, i64 } %result.i1.i.i946, 0
  %1692 = extractvalue { i64, i64 } %result.i1.i.i946, 1
  %1693 = call i64 @llvm.umax.i64(i64 %1681, i64 %1692)
  %1694 = call i64 @llvm.umax.i64(i64 %1693, i64 8)
  %1695 = urem i64 %1687, %1692
  %1696 = icmp eq i64 %1695, 0
  %1697 = sub i64 %1692, %1695
  %1698 = select i1 %1696, i64 0, i64 %1697
  %1699 = add i64 %1691, %1687
  %1700 = add i64 %1699, %1698
  %1701 = urem i64 %1700, %1694
  %1702 = icmp eq i64 %1701, 0
  %1703 = sub i64 %1694, %1701
  %1704 = select i1 %1702, i64 0, i64 %1703
  %1705 = add i64 %1704, %1700
  %result.i90.i947 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1705, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1674, ptr %result.i90.i947, align 8
  %1706 = getelementptr inbounds i8, ptr %result.i90.i947, i64 8
  store ptr %1676, ptr %1706, align 8
  %1707 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i947)
  %1708 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1709 = load ptr, ptr %1674, align 8
  %1710 = getelementptr i8, ptr %1709, i64 72
  %1711 = load ptr, ptr %1710, align 8
  %result.i.i196.i948 = call { i64, i64 } %1711(ptr nocapture nofree nonnull readonly %1674) #5
  %1712 = extractvalue { i64, i64 } %result.i.i196.i948, 1
  %1713 = urem i64 20, %1712
  %1714 = icmp eq i64 %1713, 0
  %reass.sub4287 = sub i64 %1712, %1713
  %1715 = add i64 %reass.sub4287, 20
  %1716 = select i1 %1714, i64 20, i64 %1715
  %1717 = getelementptr i8, ptr %result.i90.i947, i64 %1716
  %1718 = getelementptr i8, ptr %1709, i64 64
  %1719 = load ptr, ptr %1718, align 8
  call void %1719({ ptr, i160 } %70, ptr nocapture nofree nonnull readonly %1674, ptr nocapture nofree writeonly %1717) #1
  %1720 = load ptr, ptr %result.i90.i947, align 8
  %1721 = load ptr, ptr %1720, align 8
  %1722 = getelementptr i8, ptr %1721, i64 72
  %1723 = load ptr, ptr %1722, align 8
  %result.i.i197.i950 = call { i64, i64 } %1723(ptr nocapture nofree nonnull readonly %1720) #5
  %1724 = extractvalue { i64, i64 } %result.i.i197.i950, 0
  %1725 = extractvalue { i64, i64 } %result.i.i197.i950, 1
  %1726 = urem i64 20, %1725
  %1727 = icmp eq i64 %1726, 0
  %1728 = sub i64 %1725, %1726
  %1729 = select i1 %1727, i64 0, i64 %1728
  %1730 = add i64 %1724, 20
  %1731 = add i64 %1730, %1729
  %1732 = load ptr, ptr %1706, align 8
  %1733 = load ptr, ptr %1732, align 8
  %1734 = getelementptr i8, ptr %1733, i64 72
  %1735 = load ptr, ptr %1734, align 8
  %result.i1.i198.i951 = call { i64, i64 } %1735(ptr nocapture nofree nonnull readonly %1732) #5
  %1736 = extractvalue { i64, i64 } %result.i1.i198.i951, 1
  %1737 = urem i64 %1731, %1736
  %1738 = icmp eq i64 %1737, 0
  %1739 = sub i64 %1736, %1737
  %1740 = select i1 %1738, i64 0, i64 %1739
  %1741 = getelementptr i8, ptr %result.i90.i947, i64 %1731
  %1742 = getelementptr i8, ptr %1741, i64 %1740
  %1743 = getelementptr i8, ptr %1733, i64 64
  %1744 = load ptr, ptr %1743, align 8
  call void %1744({ ptr, i160 } %1239, ptr nocapture nofree nonnull readonly %1732, ptr nocapture nofree writeonly %1742) #1
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1746 = getelementptr inbounds i8, ptr %result.i90.i947, i64 16
  store i32 %1241, ptr %1746, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %30)
  %1747 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1748 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1749 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1750

1750:                                             ; preds = %.cont.cont.i1802, %._crit_edge.i942
  %.0566.i1782 = phi i32 [ 0, %._crit_edge.i942 ], [ %1751, %.cont.cont.i1802 ]
  %.070565.i1783 = phi i1 [ true, %._crit_edge.i942 ], [ %1817, %.cont.cont.i1802 ]
  %.sroa.0.0564.i1784 = phi ptr [ @Entry, %._crit_edge.i942 ], [ %vptr.i142.sroa.speculated.i1805, %.cont.cont.i1802 ]
  %.sroa.6.0563.i1785 = phi ptr [ %result.i90.i947, %._crit_edge.i942 ], [ %spec.select539.i1807, %.cont.cont.i1802 ]
  %.sroa.12.0562.i1786 = phi ptr [ undef, %._crit_edge.i942 ], [ %spec.select.i1806, %.cont.cont.i1802 ]
  %.sroa.17.0561.i1787 = phi i32 [ 10, %._crit_edge.i942 ], [ %offset.i.i154.i1819, %.cont.cont.i1802 ]
  %1751 = add nuw nsw i32 %.0566.i1782, 1
  %1752 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1784, 0
  %1753 = insertvalue { ptr, ptr, ptr, i32 } %1752, ptr %.sroa.6.0563.i1785, 1
  %1754 = insertvalue { ptr, ptr, ptr, i32 } %1753, ptr %.sroa.12.0562.i1786, 2
  %1755 = insertvalue { ptr, ptr, ptr, i32 } %1754, i32 %.sroa.17.0561.i1787, 3
  %1756 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1784)
  %1757 = sext i32 %.sroa.17.0561.i1787 to i64
  %1758 = getelementptr ptr, ptr %.sroa.0.0564.i1784, i64 %1757
  %1759 = getelementptr i8, ptr %1758, i64 64
  %1760 = load ptr, ptr %1759, align 8
  %result.i125.i1788 = call ptr %1760({ ptr, ptr, ptr, i32 } %1755, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1761 = call i32 %result.i125.i1788({ ptr, ptr, ptr, i32 } %1755, { ptr, ptr, ptr, i32 } %1755, ptr nonnull align 8 %2) #7
  %1762 = ptrtoint ptr %.sroa.6.0563.i1785 to i64
  %1763 = ptrtoint ptr %.sroa.12.0562.i1786 to i64
  br i1 %.070565.i1783, label %1764, label %1780

1764:                                             ; preds = %1750
  %1765 = load i32, ptr %53, align 8
  %1766 = add i32 %1765, -1
  %1767 = and i32 %1766, %1761
  %1768 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1769 = load ptr, ptr %54, align 8
  %1770 = sext i32 %1767 to i64
  %1771 = shl nsw i64 %1770, 5
  %1772 = getelementptr i8, ptr %1769, i64 %1771
  %1773 = load ptr, ptr %1772, align 8
  %1774 = getelementptr i8, ptr %1772, i64 8
  %1775 = load i160, ptr %1774, align 4
  store ptr %.sroa.0.0564.i1784, ptr %1772, align 8
  store i64 %1762, ptr %1774, align 4
  %.sroa_idx157.i1831 = getelementptr i8, ptr %1772, i64 16
  store i64 %1763, ptr %.sroa_idx157.i1831, align 4
  %.sroa_idx158.i1832 = getelementptr i8, ptr %1772, i64 24
  store i32 %.sroa.17.0561.i1787, ptr %.sroa_idx158.i1832, align 4
  %1776 = icmp ne ptr %1773, @nil_typ
  %1777 = icmp ne ptr %1773, null
  %.not92.i1833 = and i1 %1776, %1777
  %extract.i1835 = lshr i160 %1775, 64
  %1778 = insertelement <2 x i160> poison, i160 %1775, i64 0
  %1779 = insertelement <2 x i160> %1778, i160 %extract.i1835, i64 1
  br i1 %.not92.i1833, label %.cont.cont.i1802, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1837.thread

1780:                                             ; preds = %1750
  %1781 = add i32 %1761, 2127912214
  %1782 = shl i32 %1761, 12
  %1783 = add i32 %1781, %1782
  %1784 = ashr i32 %1783, 19
  %1785 = xor i32 %1783, %1784
  %1786 = xor i32 %1785, -949894596
  %1787 = add i32 %1786, 374761393
  %1788 = shl i32 %1786, 5
  %1789 = add i32 %1787, %1788
  %1790 = add i32 %1789, -744332180
  %1791 = shl i32 %1789, 9
  %1792 = xor i32 %1790, %1791
  %1793 = add i32 %1792, -42973499
  %1794 = shl i32 %1792, 3
  %1795 = add i32 %1793, %1794
  %1796 = ashr i32 %1795, 16
  %1797 = xor i32 %1795, %1796
  %1798 = xor i32 %1797, -1252372727
  %1799 = load i32, ptr %53, align 8
  %1800 = add i32 %1799, -1
  %1801 = and i32 %1800, %1798
  %1802 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1803 = load ptr, ptr %55, align 8
  %1804 = sext i32 %1801 to i64
  %1805 = shl nsw i64 %1804, 5
  %1806 = getelementptr i8, ptr %1803, i64 %1805
  %1807 = load ptr, ptr %1806, align 8
  %1808 = getelementptr i8, ptr %1806, i64 8
  %1809 = load i160, ptr %1808, align 4
  store ptr %.sroa.0.0564.i1784, ptr %1806, align 8
  store i64 %1762, ptr %1808, align 4
  %.sroa_idx161.i1792 = getelementptr i8, ptr %1806, i64 16
  store i64 %1763, ptr %.sroa_idx161.i1792, align 4
  %.sroa_idx162.i1793 = getelementptr i8, ptr %1806, i64 24
  store i32 %.sroa.17.0561.i1787, ptr %.sroa_idx162.i1793, align 4
  %1810 = icmp ne ptr %1807, @nil_typ
  %1811 = icmp ne ptr %1807, null
  %.not90.i1794 = and i1 %1810, %1811
  %extract607.i1796 = lshr i160 %1809, 64
  %1812 = insertelement <2 x i160> poison, i160 %1809, i64 0
  %1813 = insertelement <2 x i160> %1812, i160 %extract607.i1796, i64 1
  br i1 %.not90.i1794, label %.cont.cont.i1802, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1837.thread

.cont.cont.i1802:                                 ; preds = %1780, %1764
  %vptr.i142.sroa.speculated.i1805 = phi ptr [ %1773, %1764 ], [ %1807, %1780 ]
  %.in4298 = phi <2 x i160> [ %1779, %1764 ], [ %1813, %1780 ]
  %1814 = trunc <2 x i160> %.in4298 to <2 x i64>
  %1815 = extractelement <2 x i64> %1814, i64 1
  %spec.select.i1806 = inttoptr i64 %1815 to ptr
  %1816 = extractelement <2 x i64> %1814, i64 0
  %spec.select539.i1807 = inttoptr i64 %1816 to ptr
  %1817 = xor i1 %.070565.i1783, true
  %hash_coef_ptr.i.i143.i1808 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1805, i64 8
  %tbl_size_ptr.i.i144.i1809 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1805, i64 16
  %offset_tbl_ptr.i.i145.i1810 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1805, i64 40
  %hash_coef.i.i146.i1811 = load i64, ptr %hash_coef_ptr.i.i143.i1808, align 4
  %tbl_size.i.i147.i1812 = load i64, ptr %tbl_size_ptr.i.i144.i1809, align 4
  %offset_tbl.i.i148.i1813 = load ptr, ptr %offset_tbl_ptr.i.i145.i1810, align 8
  %product.i.i.i149.i1814 = mul i64 %hash_coef.i.i146.i1811, 4015701072841558310
  %shifted.i.i.i150.i1815 = lshr i64 %product.i.i.i149.i1814, 32
  %xored.i.i.i151.i1816 = xor i64 %shifted.i.i.i150.i1815, %product.i.i.i149.i1814
  %hash.i.i.i152.i1817 = and i64 %xored.i.i.i151.i1816, %tbl_size.i.i147.i1812
  %offset_ptr.i.i153.i1818 = getelementptr i32, ptr %offset_tbl.i.i148.i1813, i64 %hash.i.i.i152.i1817
  %offset.i.i154.i1819 = load i32, ptr %offset_ptr.i.i153.i1818, align 4
  %1818 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1819 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1820 = icmp ult i32 %.0566.i1782, 99
  br i1 %1820, label %1750, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1837

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1837.thread: ; preds = %1764, %1780
  %1821 = phi ptr [ %30, %1780 ], [ %29, %1764 ]
  %1822 = load i32, ptr %63, align 4
  store i32 %1822, ptr %1821, align 4
  %1823 = add i32 %1822, 1
  %1824 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1823, ptr %63, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  br label %CuckooMap_insert_keyK_valueV.exit982

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1837: ; preds = %.cont.cont.i1802
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  %1825 = icmp eq ptr %vptr.i142.sroa.speculated.i1805, null
  br i1 %1825, label %CuckooMap_insert_keyK_valueV.exit982, label %1826

1826:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1837
  %1827 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1828 = load ptr, ptr %54, align 8
  %1829 = load ptr, ptr %55, align 8
  %1830 = load i32, ptr %53, align 8
  %1831 = shl i32 %1830, 1
  %spec.select.i1853 = call i32 @llvm.smax.i32(i32 %1831, i32 16)
  store i32 %spec.select.i1853, ptr %53, align 8
  %1832 = zext nneg i32 %spec.select.i1853 to i64
  %1833 = shl nuw nsw i64 %1832, 5
  %result.i.i1854 = call noalias ptr @bump_malloc_inner(i64 noundef %1833, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1854, ptr %54, align 8
  %result.i20.i1855 = call noalias ptr @bump_malloc_inner(i64 noundef %1833, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1855, ptr %55, align 8
  store i32 0, ptr %63, align 4
  %1834 = icmp sgt i32 %1830, 0
  br i1 %1834, label %.lr.ph.i2768, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837

.lr.ph.i2768:                                     ; preds = %1826, %._crit_edge.i2783
  %.060.i2781 = phi i32 [ %1923, %._crit_edge.i2783 ], [ 0, %1826 ]
  %1835 = zext nneg i32 %.060.i2781 to i64
  %1836 = shl nuw nsw i64 %1835, 5
  %1837 = getelementptr i8, ptr %1828, i64 %1836
  %1838 = load ptr, ptr %1837, align 8
  %1839 = icmp ne ptr %1838, @nil_typ
  %1840 = icmp ne ptr %1838, null
  %.not16.i2782 = and i1 %1839, %1840
  br i1 %.not16.i2782, label %1841, label %._crit_edge.i2783

1841:                                             ; preds = %.lr.ph.i2768
  %1842 = getelementptr i8, ptr %1837, i64 8
  %1843 = load <2 x i64>, ptr %1842, align 4
  %hash_coef_ptr.i.i18.i2785 = getelementptr i8, ptr %1838, i64 8
  %tbl_size_ptr.i.i19.i2786 = getelementptr i8, ptr %1838, i64 16
  %offset_tbl_ptr.i.i20.i2787 = getelementptr i8, ptr %1838, i64 40
  %1844 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i3592 = load i64, ptr %hash_coef_ptr.i.i18.i2785, align 4, !noalias !22
  %tbl_size.i.i100.i3593 = load i64, ptr %tbl_size_ptr.i.i19.i2786, align 4, !noalias !22
  %offset_tbl.i.i101.i3594 = load ptr, ptr %offset_tbl_ptr.i.i20.i2787, align 8, !noalias !22
  %product.i.i.i102.i3595 = mul i64 %hash_coef.i.i99.i3592, 4015701072841558310
  %shifted.i.i.i103.i3596 = lshr i64 %product.i.i.i102.i3595, 32
  %xored.i.i.i104.i3597 = xor i64 %shifted.i.i.i103.i3596, %product.i.i.i102.i3595
  %hash.i.i.i105.i3598 = and i64 %xored.i.i.i104.i3597, %tbl_size.i.i100.i3593
  %offset_ptr.i.i106.i3599 = getelementptr i32, ptr %offset_tbl.i.i101.i3594, i64 %hash.i.i.i105.i3598
  %offset.i.i121.i3600 = load i32, ptr %offset_ptr.i.i106.i3599, align 4, !noalias !296
  %1845 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1846 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1847 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1848

1848:                                             ; preds = %.cont.cont.i3621, %1841
  %.0566.i3601 = phi i32 [ 0, %1841 ], [ %1852, %.cont.cont.i3621 ]
  %.070565.i3602 = phi i1 [ true, %1841 ], [ %1914, %.cont.cont.i3621 ]
  %.sroa.0.0564.i3603 = phi ptr [ %1838, %1841 ], [ %vptr.i142.sroa.speculated.i3624, %.cont.cont.i3621 ]
  %.sroa.17.0561.i3606 = phi i32 [ %offset.i.i121.i3600, %1841 ], [ %offset.i.i154.i3638, %.cont.cont.i3621 ]
  %1849 = phi <2 x i64> [ %1843, %1841 ], [ %1913, %.cont.cont.i3621 ]
  %1850 = extractelement <2 x i64> %1849, i64 1
  %.sroa.12.0562.i3605 = inttoptr i64 %1850 to ptr
  %1851 = extractelement <2 x i64> %1849, i64 0
  %.sroa.6.0563.i3604 = inttoptr i64 %1851 to ptr
  %1852 = add nuw nsw i32 %.0566.i3601, 1
  %1853 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3603, 0
  %1854 = insertvalue { ptr, ptr, ptr, i32 } %1853, ptr %.sroa.6.0563.i3604, 1
  %1855 = insertvalue { ptr, ptr, ptr, i32 } %1854, ptr %.sroa.12.0562.i3605, 2
  %1856 = insertvalue { ptr, ptr, ptr, i32 } %1855, i32 %.sroa.17.0561.i3606, 3
  %1857 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3603)
  %1858 = sext i32 %.sroa.17.0561.i3606 to i64
  %1859 = getelementptr ptr, ptr %.sroa.0.0564.i3603, i64 %1858
  %1860 = getelementptr i8, ptr %1859, i64 64
  %1861 = load ptr, ptr %1860, align 8
  %result.i125.i3607 = call ptr %1861({ ptr, ptr, ptr, i32 } %1856, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1862 = call i32 %result.i125.i3607({ ptr, ptr, ptr, i32 } %1856, { ptr, ptr, ptr, i32 } %1856, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3602, label %1863, label %1879

1863:                                             ; preds = %1848
  %1864 = load i32, ptr %53, align 8
  %1865 = add i32 %1864, -1
  %1866 = and i32 %1865, %1862
  %1867 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1868 = load ptr, ptr %54, align 8
  %1869 = sext i32 %1866 to i64
  %1870 = shl nsw i64 %1869, 5
  %1871 = getelementptr i8, ptr %1868, i64 %1870
  %1872 = load ptr, ptr %1871, align 8
  %1873 = getelementptr i8, ptr %1871, i64 8
  %1874 = load i160, ptr %1873, align 4
  store ptr %.sroa.0.0564.i3603, ptr %1871, align 8
  store i64 %1851, ptr %1873, align 4
  %.sroa_idx157.i3650 = getelementptr i8, ptr %1871, i64 16
  store i64 %1850, ptr %.sroa_idx157.i3650, align 4
  %.sroa_idx158.i3651 = getelementptr i8, ptr %1871, i64 24
  store i32 %.sroa.17.0561.i3606, ptr %.sroa_idx158.i3651, align 4
  %1875 = icmp ne ptr %1872, @nil_typ
  %1876 = icmp ne ptr %1872, null
  %.not92.i3652 = and i1 %1875, %1876
  %extract.i3654 = lshr i160 %1874, 64
  %1877 = insertelement <2 x i160> poison, i160 %1874, i64 0
  %1878 = insertelement <2 x i160> %1877, i160 %extract.i3654, i64 1
  br i1 %.not92.i3652, label %.cont.cont.i3621, label %1918

1879:                                             ; preds = %1848
  %1880 = add i32 %1862, 2127912214
  %1881 = shl i32 %1862, 12
  %1882 = add i32 %1880, %1881
  %1883 = ashr i32 %1882, 19
  %1884 = xor i32 %1882, %1883
  %1885 = xor i32 %1884, -949894596
  %1886 = add i32 %1885, 374761393
  %1887 = shl i32 %1885, 5
  %1888 = add i32 %1886, %1887
  %1889 = add i32 %1888, -744332180
  %1890 = shl i32 %1888, 9
  %1891 = xor i32 %1889, %1890
  %1892 = add i32 %1891, -42973499
  %1893 = shl i32 %1891, 3
  %1894 = add i32 %1892, %1893
  %1895 = ashr i32 %1894, 16
  %1896 = xor i32 %1894, %1895
  %1897 = xor i32 %1896, -1252372727
  %1898 = load i32, ptr %53, align 8
  %1899 = add i32 %1898, -1
  %1900 = and i32 %1899, %1897
  %1901 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1902 = load ptr, ptr %55, align 8
  %1903 = sext i32 %1900 to i64
  %1904 = shl nsw i64 %1903, 5
  %1905 = getelementptr i8, ptr %1902, i64 %1904
  %1906 = load ptr, ptr %1905, align 8
  %1907 = getelementptr i8, ptr %1905, i64 8
  %1908 = load i160, ptr %1907, align 4
  store ptr %.sroa.0.0564.i3603, ptr %1905, align 8
  store i64 %1851, ptr %1907, align 4
  %.sroa_idx161.i3611 = getelementptr i8, ptr %1905, i64 16
  store i64 %1850, ptr %.sroa_idx161.i3611, align 4
  %.sroa_idx162.i3612 = getelementptr i8, ptr %1905, i64 24
  store i32 %.sroa.17.0561.i3606, ptr %.sroa_idx162.i3612, align 4
  %1909 = icmp ne ptr %1906, @nil_typ
  %1910 = icmp ne ptr %1906, null
  %.not90.i3613 = and i1 %1909, %1910
  %extract607.i3615 = lshr i160 %1908, 64
  %1911 = insertelement <2 x i160> poison, i160 %1908, i64 0
  %1912 = insertelement <2 x i160> %1911, i160 %extract607.i3615, i64 1
  br i1 %.not90.i3613, label %.cont.cont.i3621, label %1918

.cont.cont.i3621:                                 ; preds = %1879, %1863
  %vptr.i142.sroa.speculated.i3624 = phi ptr [ %1872, %1863 ], [ %1906, %1879 ]
  %.in4299 = phi <2 x i160> [ %1878, %1863 ], [ %1912, %1879 ]
  %1913 = trunc <2 x i160> %.in4299 to <2 x i64>
  %1914 = xor i1 %.070565.i3602, true
  %hash_coef_ptr.i.i143.i3627 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3624, i64 8
  %tbl_size_ptr.i.i144.i3628 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3624, i64 16
  %offset_tbl_ptr.i.i145.i3629 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3624, i64 40
  %hash_coef.i.i146.i3630 = load i64, ptr %hash_coef_ptr.i.i143.i3627, align 4
  %tbl_size.i.i147.i3631 = load i64, ptr %tbl_size_ptr.i.i144.i3628, align 4
  %offset_tbl.i.i148.i3632 = load ptr, ptr %offset_tbl_ptr.i.i145.i3629, align 8
  %product.i.i.i149.i3633 = mul i64 %hash_coef.i.i146.i3630, 4015701072841558310
  %shifted.i.i.i150.i3634 = lshr i64 %product.i.i.i149.i3633, 32
  %xored.i.i.i151.i3635 = xor i64 %shifted.i.i.i150.i3634, %product.i.i.i149.i3633
  %hash.i.i.i152.i3636 = and i64 %xored.i.i.i151.i3635, %tbl_size.i.i147.i3631
  %offset_ptr.i.i153.i3637 = getelementptr i32, ptr %offset_tbl.i.i148.i3632, i64 %hash.i.i.i152.i3636
  %offset.i.i154.i3638 = load i32, ptr %offset_ptr.i.i153.i3637, align 4
  %1915 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1916 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1917 = icmp ult i32 %.0566.i3601, 99
  br i1 %1917, label %1848, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3656

1918:                                             ; preds = %1879, %1863
  %1919 = phi ptr [ %10, %1879 ], [ %9, %1863 ]
  %1920 = load i32, ptr %63, align 4
  store i32 %1920, ptr %1919, align 4
  %1921 = add i32 %1920, 1
  %1922 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1921, ptr %63, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3656

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3656: ; preds = %.cont.cont.i3621, %1918
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i2783

._crit_edge.i2783:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3656, %.lr.ph.i2768
  %1923 = add nuw nsw i32 %.060.i2781, 1
  %1924 = icmp slt i32 %1923, %1830
  br i1 %1924, label %.lr.ph.i2768, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2801

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2801: ; preds = %._crit_edge.i2783, %._crit_edge.i2819
  %.060.i2817 = phi i32 [ %2013, %._crit_edge.i2819 ], [ 0, %._crit_edge.i2783 ]
  %1925 = zext nneg i32 %.060.i2817 to i64
  %1926 = shl nuw nsw i64 %1925, 5
  %1927 = getelementptr i8, ptr %1829, i64 %1926
  %1928 = load ptr, ptr %1927, align 8
  %1929 = icmp ne ptr %1928, @nil_typ
  %1930 = icmp ne ptr %1928, null
  %.not16.i2818 = and i1 %1929, %1930
  br i1 %.not16.i2818, label %1931, label %._crit_edge.i2819

1931:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2801
  %1932 = getelementptr i8, ptr %1927, i64 8
  %1933 = load <2 x i64>, ptr %1932, align 4
  %hash_coef_ptr.i.i18.i2821 = getelementptr i8, ptr %1928, i64 8
  %tbl_size_ptr.i.i19.i2822 = getelementptr i8, ptr %1928, i64 16
  %offset_tbl_ptr.i.i20.i2823 = getelementptr i8, ptr %1928, i64 40
  %1934 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i3674 = load i64, ptr %hash_coef_ptr.i.i18.i2821, align 4, !noalias !22
  %tbl_size.i.i100.i3675 = load i64, ptr %tbl_size_ptr.i.i19.i2822, align 4, !noalias !22
  %offset_tbl.i.i101.i3676 = load ptr, ptr %offset_tbl_ptr.i.i20.i2823, align 8, !noalias !22
  %product.i.i.i102.i3677 = mul i64 %hash_coef.i.i99.i3674, 4015701072841558310
  %shifted.i.i.i103.i3678 = lshr i64 %product.i.i.i102.i3677, 32
  %xored.i.i.i104.i3679 = xor i64 %shifted.i.i.i103.i3678, %product.i.i.i102.i3677
  %hash.i.i.i105.i3680 = and i64 %xored.i.i.i104.i3679, %tbl_size.i.i100.i3675
  %offset_ptr.i.i106.i3681 = getelementptr i32, ptr %offset_tbl.i.i101.i3676, i64 %hash.i.i.i105.i3680
  %offset.i.i121.i3682 = load i32, ptr %offset_ptr.i.i106.i3681, align 4, !noalias !299
  %1935 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1936 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1937 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1938

1938:                                             ; preds = %.cont.cont.i3703, %1931
  %.0566.i3683 = phi i32 [ 0, %1931 ], [ %1942, %.cont.cont.i3703 ]
  %.070565.i3684 = phi i1 [ true, %1931 ], [ %2004, %.cont.cont.i3703 ]
  %.sroa.0.0564.i3685 = phi ptr [ %1928, %1931 ], [ %vptr.i142.sroa.speculated.i3706, %.cont.cont.i3703 ]
  %.sroa.17.0561.i3688 = phi i32 [ %offset.i.i121.i3682, %1931 ], [ %offset.i.i154.i3720, %.cont.cont.i3703 ]
  %1939 = phi <2 x i64> [ %1933, %1931 ], [ %2003, %.cont.cont.i3703 ]
  %1940 = extractelement <2 x i64> %1939, i64 1
  %.sroa.12.0562.i3687 = inttoptr i64 %1940 to ptr
  %1941 = extractelement <2 x i64> %1939, i64 0
  %.sroa.6.0563.i3686 = inttoptr i64 %1941 to ptr
  %1942 = add nuw nsw i32 %.0566.i3683, 1
  %1943 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3685, 0
  %1944 = insertvalue { ptr, ptr, ptr, i32 } %1943, ptr %.sroa.6.0563.i3686, 1
  %1945 = insertvalue { ptr, ptr, ptr, i32 } %1944, ptr %.sroa.12.0562.i3687, 2
  %1946 = insertvalue { ptr, ptr, ptr, i32 } %1945, i32 %.sroa.17.0561.i3688, 3
  %1947 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3685)
  %1948 = sext i32 %.sroa.17.0561.i3688 to i64
  %1949 = getelementptr ptr, ptr %.sroa.0.0564.i3685, i64 %1948
  %1950 = getelementptr i8, ptr %1949, i64 64
  %1951 = load ptr, ptr %1950, align 8
  %result.i125.i3689 = call ptr %1951({ ptr, ptr, ptr, i32 } %1946, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1952 = call i32 %result.i125.i3689({ ptr, ptr, ptr, i32 } %1946, { ptr, ptr, ptr, i32 } %1946, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3684, label %1953, label %1969

1953:                                             ; preds = %1938
  %1954 = load i32, ptr %53, align 8
  %1955 = add i32 %1954, -1
  %1956 = and i32 %1955, %1952
  %1957 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1958 = load ptr, ptr %54, align 8
  %1959 = sext i32 %1956 to i64
  %1960 = shl nsw i64 %1959, 5
  %1961 = getelementptr i8, ptr %1958, i64 %1960
  %1962 = load ptr, ptr %1961, align 8
  %1963 = getelementptr i8, ptr %1961, i64 8
  %1964 = load i160, ptr %1963, align 4
  store ptr %.sroa.0.0564.i3685, ptr %1961, align 8
  store i64 %1941, ptr %1963, align 4
  %.sroa_idx157.i3732 = getelementptr i8, ptr %1961, i64 16
  store i64 %1940, ptr %.sroa_idx157.i3732, align 4
  %.sroa_idx158.i3733 = getelementptr i8, ptr %1961, i64 24
  store i32 %.sroa.17.0561.i3688, ptr %.sroa_idx158.i3733, align 4
  %1965 = icmp ne ptr %1962, @nil_typ
  %1966 = icmp ne ptr %1962, null
  %.not92.i3734 = and i1 %1965, %1966
  %extract.i3736 = lshr i160 %1964, 64
  %1967 = insertelement <2 x i160> poison, i160 %1964, i64 0
  %1968 = insertelement <2 x i160> %1967, i160 %extract.i3736, i64 1
  br i1 %.not92.i3734, label %.cont.cont.i3703, label %2008

1969:                                             ; preds = %1938
  %1970 = add i32 %1952, 2127912214
  %1971 = shl i32 %1952, 12
  %1972 = add i32 %1970, %1971
  %1973 = ashr i32 %1972, 19
  %1974 = xor i32 %1972, %1973
  %1975 = xor i32 %1974, -949894596
  %1976 = add i32 %1975, 374761393
  %1977 = shl i32 %1975, 5
  %1978 = add i32 %1976, %1977
  %1979 = add i32 %1978, -744332180
  %1980 = shl i32 %1978, 9
  %1981 = xor i32 %1979, %1980
  %1982 = add i32 %1981, -42973499
  %1983 = shl i32 %1981, 3
  %1984 = add i32 %1982, %1983
  %1985 = ashr i32 %1984, 16
  %1986 = xor i32 %1984, %1985
  %1987 = xor i32 %1986, -1252372727
  %1988 = load i32, ptr %53, align 8
  %1989 = add i32 %1988, -1
  %1990 = and i32 %1989, %1987
  %1991 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1992 = load ptr, ptr %55, align 8
  %1993 = sext i32 %1990 to i64
  %1994 = shl nsw i64 %1993, 5
  %1995 = getelementptr i8, ptr %1992, i64 %1994
  %1996 = load ptr, ptr %1995, align 8
  %1997 = getelementptr i8, ptr %1995, i64 8
  %1998 = load i160, ptr %1997, align 4
  store ptr %.sroa.0.0564.i3685, ptr %1995, align 8
  store i64 %1941, ptr %1997, align 4
  %.sroa_idx161.i3693 = getelementptr i8, ptr %1995, i64 16
  store i64 %1940, ptr %.sroa_idx161.i3693, align 4
  %.sroa_idx162.i3694 = getelementptr i8, ptr %1995, i64 24
  store i32 %.sroa.17.0561.i3688, ptr %.sroa_idx162.i3694, align 4
  %1999 = icmp ne ptr %1996, @nil_typ
  %2000 = icmp ne ptr %1996, null
  %.not90.i3695 = and i1 %1999, %2000
  %extract607.i3697 = lshr i160 %1998, 64
  %2001 = insertelement <2 x i160> poison, i160 %1998, i64 0
  %2002 = insertelement <2 x i160> %2001, i160 %extract607.i3697, i64 1
  br i1 %.not90.i3695, label %.cont.cont.i3703, label %2008

.cont.cont.i3703:                                 ; preds = %1969, %1953
  %vptr.i142.sroa.speculated.i3706 = phi ptr [ %1962, %1953 ], [ %1996, %1969 ]
  %.in4300 = phi <2 x i160> [ %1968, %1953 ], [ %2002, %1969 ]
  %2003 = trunc <2 x i160> %.in4300 to <2 x i64>
  %2004 = xor i1 %.070565.i3684, true
  %hash_coef_ptr.i.i143.i3709 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3706, i64 8
  %tbl_size_ptr.i.i144.i3710 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3706, i64 16
  %offset_tbl_ptr.i.i145.i3711 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3706, i64 40
  %hash_coef.i.i146.i3712 = load i64, ptr %hash_coef_ptr.i.i143.i3709, align 4
  %tbl_size.i.i147.i3713 = load i64, ptr %tbl_size_ptr.i.i144.i3710, align 4
  %offset_tbl.i.i148.i3714 = load ptr, ptr %offset_tbl_ptr.i.i145.i3711, align 8
  %product.i.i.i149.i3715 = mul i64 %hash_coef.i.i146.i3712, 4015701072841558310
  %shifted.i.i.i150.i3716 = lshr i64 %product.i.i.i149.i3715, 32
  %xored.i.i.i151.i3717 = xor i64 %shifted.i.i.i150.i3716, %product.i.i.i149.i3715
  %hash.i.i.i152.i3718 = and i64 %xored.i.i.i151.i3717, %tbl_size.i.i147.i3713
  %offset_ptr.i.i153.i3719 = getelementptr i32, ptr %offset_tbl.i.i148.i3714, i64 %hash.i.i.i152.i3718
  %offset.i.i154.i3720 = load i32, ptr %offset_ptr.i.i153.i3719, align 4
  %2005 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2006 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2007 = icmp ult i32 %.0566.i3683, 99
  br i1 %2007, label %1938, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3738

2008:                                             ; preds = %1969, %1953
  %2009 = phi ptr [ %8, %1969 ], [ %7, %1953 ]
  %2010 = load i32, ptr %63, align 4
  store i32 %2010, ptr %2009, align 4
  %2011 = add i32 %2010, 1
  %2012 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2011, ptr %63, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3738

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3738: ; preds = %.cont.cont.i3703, %2008
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i2819

._crit_edge.i2819:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3738, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2801
  %2013 = add nuw nsw i32 %.060.i2817, 1
  %2014 = icmp slt i32 %2013, %1830
  br i1 %2014, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2801, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837: ; preds = %._crit_edge.i2819, %1826
  %2015 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %28)
  %hash_coef.i.i99.i1878 = load i64, ptr %hash_coef_ptr.i.i143.i1808, align 4, !noalias !22
  %tbl_size.i.i100.i1879 = load i64, ptr %tbl_size_ptr.i.i144.i1809, align 4, !noalias !22
  %offset_tbl.i.i101.i1880 = load ptr, ptr %offset_tbl_ptr.i.i145.i1810, align 8, !noalias !22
  %product.i.i.i102.i1881 = mul i64 %hash_coef.i.i99.i1878, 4015701072841558310
  %shifted.i.i.i103.i1882 = lshr i64 %product.i.i.i102.i1881, 32
  %xored.i.i.i104.i1883 = xor i64 %shifted.i.i.i103.i1882, %product.i.i.i102.i1881
  %hash.i.i.i105.i1884 = and i64 %xored.i.i.i104.i1883, %tbl_size.i.i100.i1879
  %offset_ptr.i.i106.i1885 = getelementptr i32, ptr %offset_tbl.i.i101.i1880, i64 %hash.i.i.i105.i1884
  %offset.i.i121.i1886 = load i32, ptr %offset_ptr.i.i106.i1885, align 4, !noalias !302
  %2016 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2017 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2018 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2019

2019:                                             ; preds = %.cont.cont.i1908, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837
  %.0566.i1888 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837 ], [ %2023, %.cont.cont.i1908 ]
  %.070565.i1889 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837 ], [ %2085, %.cont.cont.i1908 ]
  %.sroa.0.0564.i1890 = phi ptr [ %vptr.i142.sroa.speculated.i1805, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837 ], [ %vptr.i142.sroa.speculated.i1911, %.cont.cont.i1908 ]
  %.sroa.17.0561.i1893 = phi i32 [ %offset.i.i121.i1886, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837 ], [ %offset.i.i154.i1925, %.cont.cont.i1908 ]
  %2020 = phi <2 x i64> [ %1814, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2837 ], [ %2084, %.cont.cont.i1908 ]
  %2021 = extractelement <2 x i64> %2020, i64 1
  %.sroa.12.0562.i1892 = inttoptr i64 %2021 to ptr
  %2022 = extractelement <2 x i64> %2020, i64 0
  %.sroa.6.0563.i1891 = inttoptr i64 %2022 to ptr
  %2023 = add nuw nsw i32 %.0566.i1888, 1
  %2024 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1890, 0
  %2025 = insertvalue { ptr, ptr, ptr, i32 } %2024, ptr %.sroa.6.0563.i1891, 1
  %2026 = insertvalue { ptr, ptr, ptr, i32 } %2025, ptr %.sroa.12.0562.i1892, 2
  %2027 = insertvalue { ptr, ptr, ptr, i32 } %2026, i32 %.sroa.17.0561.i1893, 3
  %2028 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1890)
  %2029 = sext i32 %.sroa.17.0561.i1893 to i64
  %2030 = getelementptr ptr, ptr %.sroa.0.0564.i1890, i64 %2029
  %2031 = getelementptr i8, ptr %2030, i64 64
  %2032 = load ptr, ptr %2031, align 8
  %result.i125.i1894 = call ptr %2032({ ptr, ptr, ptr, i32 } %2027, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2033 = call i32 %result.i125.i1894({ ptr, ptr, ptr, i32 } %2027, { ptr, ptr, ptr, i32 } %2027, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1889, label %2034, label %2050

2034:                                             ; preds = %2019
  %2035 = load i32, ptr %53, align 8
  %2036 = add i32 %2035, -1
  %2037 = and i32 %2036, %2033
  %2038 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2039 = load ptr, ptr %54, align 8
  %2040 = sext i32 %2037 to i64
  %2041 = shl nsw i64 %2040, 5
  %2042 = getelementptr i8, ptr %2039, i64 %2041
  %2043 = load ptr, ptr %2042, align 8
  %2044 = getelementptr i8, ptr %2042, i64 8
  %2045 = load i160, ptr %2044, align 4
  store ptr %.sroa.0.0564.i1890, ptr %2042, align 8
  store i64 %2022, ptr %2044, align 4
  %.sroa_idx157.i1937 = getelementptr i8, ptr %2042, i64 16
  store i64 %2021, ptr %.sroa_idx157.i1937, align 4
  %.sroa_idx158.i1938 = getelementptr i8, ptr %2042, i64 24
  store i32 %.sroa.17.0561.i1893, ptr %.sroa_idx158.i1938, align 4
  %2046 = icmp ne ptr %2043, @nil_typ
  %2047 = icmp ne ptr %2043, null
  %.not92.i1939 = and i1 %2046, %2047
  %extract.i1941 = lshr i160 %2045, 64
  %2048 = insertelement <2 x i160> poison, i160 %2045, i64 0
  %2049 = insertelement <2 x i160> %2048, i160 %extract.i1941, i64 1
  br i1 %.not92.i1939, label %.cont.cont.i1908, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1943.thread

2050:                                             ; preds = %2019
  %2051 = add i32 %2033, 2127912214
  %2052 = shl i32 %2033, 12
  %2053 = add i32 %2051, %2052
  %2054 = ashr i32 %2053, 19
  %2055 = xor i32 %2053, %2054
  %2056 = xor i32 %2055, -949894596
  %2057 = add i32 %2056, 374761393
  %2058 = shl i32 %2056, 5
  %2059 = add i32 %2057, %2058
  %2060 = add i32 %2059, -744332180
  %2061 = shl i32 %2059, 9
  %2062 = xor i32 %2060, %2061
  %2063 = add i32 %2062, -42973499
  %2064 = shl i32 %2062, 3
  %2065 = add i32 %2063, %2064
  %2066 = ashr i32 %2065, 16
  %2067 = xor i32 %2065, %2066
  %2068 = xor i32 %2067, -1252372727
  %2069 = load i32, ptr %53, align 8
  %2070 = add i32 %2069, -1
  %2071 = and i32 %2070, %2068
  %2072 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2073 = load ptr, ptr %55, align 8
  %2074 = sext i32 %2071 to i64
  %2075 = shl nsw i64 %2074, 5
  %2076 = getelementptr i8, ptr %2073, i64 %2075
  %2077 = load ptr, ptr %2076, align 8
  %2078 = getelementptr i8, ptr %2076, i64 8
  %2079 = load i160, ptr %2078, align 4
  store ptr %.sroa.0.0564.i1890, ptr %2076, align 8
  store i64 %2022, ptr %2078, align 4
  %.sroa_idx161.i1898 = getelementptr i8, ptr %2076, i64 16
  store i64 %2021, ptr %.sroa_idx161.i1898, align 4
  %.sroa_idx162.i1899 = getelementptr i8, ptr %2076, i64 24
  store i32 %.sroa.17.0561.i1893, ptr %.sroa_idx162.i1899, align 4
  %2080 = icmp ne ptr %2077, @nil_typ
  %2081 = icmp ne ptr %2077, null
  %.not90.i1900 = and i1 %2080, %2081
  %extract607.i1902 = lshr i160 %2079, 64
  %2082 = insertelement <2 x i160> poison, i160 %2079, i64 0
  %2083 = insertelement <2 x i160> %2082, i160 %extract607.i1902, i64 1
  br i1 %.not90.i1900, label %.cont.cont.i1908, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1943.thread

.cont.cont.i1908:                                 ; preds = %2050, %2034
  %vptr.i142.sroa.speculated.i1911 = phi ptr [ %2043, %2034 ], [ %2077, %2050 ]
  %.in4301 = phi <2 x i160> [ %2049, %2034 ], [ %2083, %2050 ]
  %2084 = trunc <2 x i160> %.in4301 to <2 x i64>
  %2085 = xor i1 %.070565.i1889, true
  %hash_coef_ptr.i.i143.i1914 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1911, i64 8
  %tbl_size_ptr.i.i144.i1915 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1911, i64 16
  %offset_tbl_ptr.i.i145.i1916 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1911, i64 40
  %hash_coef.i.i146.i1917 = load i64, ptr %hash_coef_ptr.i.i143.i1914, align 4
  %tbl_size.i.i147.i1918 = load i64, ptr %tbl_size_ptr.i.i144.i1915, align 4
  %offset_tbl.i.i148.i1919 = load ptr, ptr %offset_tbl_ptr.i.i145.i1916, align 8
  %product.i.i.i149.i1920 = mul i64 %hash_coef.i.i146.i1917, 4015701072841558310
  %shifted.i.i.i150.i1921 = lshr i64 %product.i.i.i149.i1920, 32
  %xored.i.i.i151.i1922 = xor i64 %shifted.i.i.i150.i1921, %product.i.i.i149.i1920
  %hash.i.i.i152.i1923 = and i64 %xored.i.i.i151.i1922, %tbl_size.i.i147.i1918
  %offset_ptr.i.i153.i1924 = getelementptr i32, ptr %offset_tbl.i.i148.i1919, i64 %hash.i.i.i152.i1923
  %offset.i.i154.i1925 = load i32, ptr %offset_ptr.i.i153.i1924, align 4
  %2086 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2087 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2088 = icmp ult i32 %.0566.i1888, 99
  br i1 %2088, label %2019, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1943

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1943.thread: ; preds = %2034, %2050
  %2089 = phi ptr [ %28, %2050 ], [ %27, %2034 ]
  %2090 = load i32, ptr %63, align 4
  store i32 %2090, ptr %2089, align 4
  %2091 = add i32 %2090, 1
  %2092 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2091, ptr %63, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  br label %CuckooMap_insert_keyK_valueV.exit982

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1943: ; preds = %.cont.cont.i1908
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  %2093 = icmp eq ptr %vptr.i142.sroa.speculated.i1911, null
  br i1 %2093, label %CuckooMap_insert_keyK_valueV.exit982, label %2094

2094:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1943
  %2095 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2096 = load ptr, ptr %54, align 8
  %2097 = load ptr, ptr %55, align 8
  %2098 = load i32, ptr %53, align 8
  %2099 = shl i32 %2098, 1
  %spec.select.i1959 = call i32 @llvm.smax.i32(i32 %2099, i32 16)
  store i32 %spec.select.i1959, ptr %53, align 8
  %2100 = zext nneg i32 %spec.select.i1959 to i64
  %2101 = shl nuw nsw i64 %2100, 5
  %result.i.i1960 = call noalias ptr @bump_malloc_inner(i64 noundef %2101, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1960, ptr %54, align 8
  %result.i20.i1961 = call noalias ptr @bump_malloc_inner(i64 noundef %2101, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1961, ptr %55, align 8
  store i32 0, ptr %63, align 4
  %2102 = icmp sgt i32 %2098, 0
  br i1 %2102, label %.lr.ph.i2867, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2900.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2900.thread: ; preds = %2094
  %2103 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit982

.lr.ph.i2867:                                     ; preds = %2094, %._crit_edge.i2882
  %.060.i2880 = phi i32 [ %2192, %._crit_edge.i2882 ], [ 0, %2094 ]
  %2104 = zext nneg i32 %.060.i2880 to i64
  %2105 = shl nuw nsw i64 %2104, 5
  %2106 = getelementptr i8, ptr %2096, i64 %2105
  %2107 = load ptr, ptr %2106, align 8
  %2108 = icmp ne ptr %2107, @nil_typ
  %2109 = icmp ne ptr %2107, null
  %.not16.i2881 = and i1 %2108, %2109
  br i1 %.not16.i2881, label %2110, label %._crit_edge.i2882

2110:                                             ; preds = %.lr.ph.i2867
  %2111 = getelementptr i8, ptr %2106, i64 8
  %2112 = load <2 x i64>, ptr %2111, align 4
  %hash_coef_ptr.i.i18.i2884 = getelementptr i8, ptr %2107, i64 8
  %tbl_size_ptr.i.i19.i2885 = getelementptr i8, ptr %2107, i64 16
  %offset_tbl_ptr.i.i20.i2886 = getelementptr i8, ptr %2107, i64 40
  %2113 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i3756 = load i64, ptr %hash_coef_ptr.i.i18.i2884, align 4, !noalias !22
  %tbl_size.i.i100.i3757 = load i64, ptr %tbl_size_ptr.i.i19.i2885, align 4, !noalias !22
  %offset_tbl.i.i101.i3758 = load ptr, ptr %offset_tbl_ptr.i.i20.i2886, align 8, !noalias !22
  %product.i.i.i102.i3759 = mul i64 %hash_coef.i.i99.i3756, 4015701072841558310
  %shifted.i.i.i103.i3760 = lshr i64 %product.i.i.i102.i3759, 32
  %xored.i.i.i104.i3761 = xor i64 %shifted.i.i.i103.i3760, %product.i.i.i102.i3759
  %hash.i.i.i105.i3762 = and i64 %xored.i.i.i104.i3761, %tbl_size.i.i100.i3757
  %offset_ptr.i.i106.i3763 = getelementptr i32, ptr %offset_tbl.i.i101.i3758, i64 %hash.i.i.i105.i3762
  %offset.i.i121.i3764 = load i32, ptr %offset_ptr.i.i106.i3763, align 4, !noalias !305
  %2114 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2115 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2116 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2117

2117:                                             ; preds = %.cont.cont.i3785, %2110
  %.0566.i3765 = phi i32 [ 0, %2110 ], [ %2121, %.cont.cont.i3785 ]
  %.070565.i3766 = phi i1 [ true, %2110 ], [ %2183, %.cont.cont.i3785 ]
  %.sroa.0.0564.i3767 = phi ptr [ %2107, %2110 ], [ %vptr.i142.sroa.speculated.i3788, %.cont.cont.i3785 ]
  %.sroa.17.0561.i3770 = phi i32 [ %offset.i.i121.i3764, %2110 ], [ %offset.i.i154.i3802, %.cont.cont.i3785 ]
  %2118 = phi <2 x i64> [ %2112, %2110 ], [ %2182, %.cont.cont.i3785 ]
  %2119 = extractelement <2 x i64> %2118, i64 1
  %.sroa.12.0562.i3769 = inttoptr i64 %2119 to ptr
  %2120 = extractelement <2 x i64> %2118, i64 0
  %.sroa.6.0563.i3768 = inttoptr i64 %2120 to ptr
  %2121 = add nuw nsw i32 %.0566.i3765, 1
  %2122 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3767, 0
  %2123 = insertvalue { ptr, ptr, ptr, i32 } %2122, ptr %.sroa.6.0563.i3768, 1
  %2124 = insertvalue { ptr, ptr, ptr, i32 } %2123, ptr %.sroa.12.0562.i3769, 2
  %2125 = insertvalue { ptr, ptr, ptr, i32 } %2124, i32 %.sroa.17.0561.i3770, 3
  %2126 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3767)
  %2127 = sext i32 %.sroa.17.0561.i3770 to i64
  %2128 = getelementptr ptr, ptr %.sroa.0.0564.i3767, i64 %2127
  %2129 = getelementptr i8, ptr %2128, i64 64
  %2130 = load ptr, ptr %2129, align 8
  %result.i125.i3771 = call ptr %2130({ ptr, ptr, ptr, i32 } %2125, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2131 = call i32 %result.i125.i3771({ ptr, ptr, ptr, i32 } %2125, { ptr, ptr, ptr, i32 } %2125, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3766, label %2132, label %2148

2132:                                             ; preds = %2117
  %2133 = load i32, ptr %53, align 8
  %2134 = add i32 %2133, -1
  %2135 = and i32 %2134, %2131
  %2136 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2137 = load ptr, ptr %54, align 8
  %2138 = sext i32 %2135 to i64
  %2139 = shl nsw i64 %2138, 5
  %2140 = getelementptr i8, ptr %2137, i64 %2139
  %2141 = load ptr, ptr %2140, align 8
  %2142 = getelementptr i8, ptr %2140, i64 8
  %2143 = load i160, ptr %2142, align 4
  store ptr %.sroa.0.0564.i3767, ptr %2140, align 8
  store i64 %2120, ptr %2142, align 4
  %.sroa_idx157.i3814 = getelementptr i8, ptr %2140, i64 16
  store i64 %2119, ptr %.sroa_idx157.i3814, align 4
  %.sroa_idx158.i3815 = getelementptr i8, ptr %2140, i64 24
  store i32 %.sroa.17.0561.i3770, ptr %.sroa_idx158.i3815, align 4
  %2144 = icmp ne ptr %2141, @nil_typ
  %2145 = icmp ne ptr %2141, null
  %.not92.i3816 = and i1 %2144, %2145
  %extract.i3818 = lshr i160 %2143, 64
  %2146 = insertelement <2 x i160> poison, i160 %2143, i64 0
  %2147 = insertelement <2 x i160> %2146, i160 %extract.i3818, i64 1
  br i1 %.not92.i3816, label %.cont.cont.i3785, label %2187

2148:                                             ; preds = %2117
  %2149 = add i32 %2131, 2127912214
  %2150 = shl i32 %2131, 12
  %2151 = add i32 %2149, %2150
  %2152 = ashr i32 %2151, 19
  %2153 = xor i32 %2151, %2152
  %2154 = xor i32 %2153, -949894596
  %2155 = add i32 %2154, 374761393
  %2156 = shl i32 %2154, 5
  %2157 = add i32 %2155, %2156
  %2158 = add i32 %2157, -744332180
  %2159 = shl i32 %2157, 9
  %2160 = xor i32 %2158, %2159
  %2161 = add i32 %2160, -42973499
  %2162 = shl i32 %2160, 3
  %2163 = add i32 %2161, %2162
  %2164 = ashr i32 %2163, 16
  %2165 = xor i32 %2163, %2164
  %2166 = xor i32 %2165, -1252372727
  %2167 = load i32, ptr %53, align 8
  %2168 = add i32 %2167, -1
  %2169 = and i32 %2168, %2166
  %2170 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2171 = load ptr, ptr %55, align 8
  %2172 = sext i32 %2169 to i64
  %2173 = shl nsw i64 %2172, 5
  %2174 = getelementptr i8, ptr %2171, i64 %2173
  %2175 = load ptr, ptr %2174, align 8
  %2176 = getelementptr i8, ptr %2174, i64 8
  %2177 = load i160, ptr %2176, align 4
  store ptr %.sroa.0.0564.i3767, ptr %2174, align 8
  store i64 %2120, ptr %2176, align 4
  %.sroa_idx161.i3775 = getelementptr i8, ptr %2174, i64 16
  store i64 %2119, ptr %.sroa_idx161.i3775, align 4
  %.sroa_idx162.i3776 = getelementptr i8, ptr %2174, i64 24
  store i32 %.sroa.17.0561.i3770, ptr %.sroa_idx162.i3776, align 4
  %2178 = icmp ne ptr %2175, @nil_typ
  %2179 = icmp ne ptr %2175, null
  %.not90.i3777 = and i1 %2178, %2179
  %extract607.i3779 = lshr i160 %2177, 64
  %2180 = insertelement <2 x i160> poison, i160 %2177, i64 0
  %2181 = insertelement <2 x i160> %2180, i160 %extract607.i3779, i64 1
  br i1 %.not90.i3777, label %.cont.cont.i3785, label %2187

.cont.cont.i3785:                                 ; preds = %2148, %2132
  %vptr.i142.sroa.speculated.i3788 = phi ptr [ %2141, %2132 ], [ %2175, %2148 ]
  %.in4302 = phi <2 x i160> [ %2147, %2132 ], [ %2181, %2148 ]
  %2182 = trunc <2 x i160> %.in4302 to <2 x i64>
  %2183 = xor i1 %.070565.i3766, true
  %hash_coef_ptr.i.i143.i3791 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3788, i64 8
  %tbl_size_ptr.i.i144.i3792 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3788, i64 16
  %offset_tbl_ptr.i.i145.i3793 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3788, i64 40
  %hash_coef.i.i146.i3794 = load i64, ptr %hash_coef_ptr.i.i143.i3791, align 4
  %tbl_size.i.i147.i3795 = load i64, ptr %tbl_size_ptr.i.i144.i3792, align 4
  %offset_tbl.i.i148.i3796 = load ptr, ptr %offset_tbl_ptr.i.i145.i3793, align 8
  %product.i.i.i149.i3797 = mul i64 %hash_coef.i.i146.i3794, 4015701072841558310
  %shifted.i.i.i150.i3798 = lshr i64 %product.i.i.i149.i3797, 32
  %xored.i.i.i151.i3799 = xor i64 %shifted.i.i.i150.i3798, %product.i.i.i149.i3797
  %hash.i.i.i152.i3800 = and i64 %xored.i.i.i151.i3799, %tbl_size.i.i147.i3795
  %offset_ptr.i.i153.i3801 = getelementptr i32, ptr %offset_tbl.i.i148.i3796, i64 %hash.i.i.i152.i3800
  %offset.i.i154.i3802 = load i32, ptr %offset_ptr.i.i153.i3801, align 4
  %2184 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2185 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2186 = icmp ult i32 %.0566.i3765, 99
  br i1 %2186, label %2117, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3820

2187:                                             ; preds = %2148, %2132
  %2188 = phi ptr [ %6, %2148 ], [ %5, %2132 ]
  %2189 = load i32, ptr %63, align 4
  store i32 %2189, ptr %2188, align 4
  %2190 = add i32 %2189, 1
  %2191 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2190, ptr %63, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3820

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3820: ; preds = %.cont.cont.i3785, %2187
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i2882

._crit_edge.i2882:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3820, %.lr.ph.i2867
  %2192 = add nuw nsw i32 %.060.i2880, 1
  %2193 = icmp slt i32 %2192, %2098
  br i1 %2193, label %.lr.ph.i2867, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2900

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2900: ; preds = %._crit_edge.i2882
  %2194 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %2195

2195:                                             ; preds = %._crit_edge.i2918, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2900
  %.060.i2916 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2900 ], [ %2284, %._crit_edge.i2918 ]
  %2196 = zext nneg i32 %.060.i2916 to i64
  %2197 = shl nuw nsw i64 %2196, 5
  %2198 = getelementptr i8, ptr %2097, i64 %2197
  %2199 = load ptr, ptr %2198, align 8
  %2200 = icmp ne ptr %2199, @nil_typ
  %2201 = icmp ne ptr %2199, null
  %.not16.i2917 = and i1 %2200, %2201
  br i1 %.not16.i2917, label %2202, label %._crit_edge.i2918

2202:                                             ; preds = %2195
  %2203 = getelementptr i8, ptr %2198, i64 8
  %2204 = load <2 x i64>, ptr %2203, align 4
  %hash_coef_ptr.i.i18.i2920 = getelementptr i8, ptr %2199, i64 8
  %tbl_size_ptr.i.i19.i2921 = getelementptr i8, ptr %2199, i64 16
  %offset_tbl_ptr.i.i20.i2922 = getelementptr i8, ptr %2199, i64 40
  %2205 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i3838 = load i64, ptr %hash_coef_ptr.i.i18.i2920, align 4, !noalias !22
  %tbl_size.i.i100.i3839 = load i64, ptr %tbl_size_ptr.i.i19.i2921, align 4, !noalias !22
  %offset_tbl.i.i101.i3840 = load ptr, ptr %offset_tbl_ptr.i.i20.i2922, align 8, !noalias !22
  %product.i.i.i102.i3841 = mul i64 %hash_coef.i.i99.i3838, 4015701072841558310
  %shifted.i.i.i103.i3842 = lshr i64 %product.i.i.i102.i3841, 32
  %xored.i.i.i104.i3843 = xor i64 %shifted.i.i.i103.i3842, %product.i.i.i102.i3841
  %hash.i.i.i105.i3844 = and i64 %xored.i.i.i104.i3843, %tbl_size.i.i100.i3839
  %offset_ptr.i.i106.i3845 = getelementptr i32, ptr %offset_tbl.i.i101.i3840, i64 %hash.i.i.i105.i3844
  %offset.i.i121.i3846 = load i32, ptr %offset_ptr.i.i106.i3845, align 4, !noalias !308
  %2206 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2207 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2208 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2209

2209:                                             ; preds = %.cont.cont.i3867, %2202
  %.0566.i3847 = phi i32 [ 0, %2202 ], [ %2213, %.cont.cont.i3867 ]
  %.070565.i3848 = phi i1 [ true, %2202 ], [ %2275, %.cont.cont.i3867 ]
  %.sroa.0.0564.i3849 = phi ptr [ %2199, %2202 ], [ %vptr.i142.sroa.speculated.i3870, %.cont.cont.i3867 ]
  %.sroa.17.0561.i3852 = phi i32 [ %offset.i.i121.i3846, %2202 ], [ %offset.i.i154.i3884, %.cont.cont.i3867 ]
  %2210 = phi <2 x i64> [ %2204, %2202 ], [ %2274, %.cont.cont.i3867 ]
  %2211 = extractelement <2 x i64> %2210, i64 1
  %.sroa.12.0562.i3851 = inttoptr i64 %2211 to ptr
  %2212 = extractelement <2 x i64> %2210, i64 0
  %.sroa.6.0563.i3850 = inttoptr i64 %2212 to ptr
  %2213 = add nuw nsw i32 %.0566.i3847, 1
  %2214 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3849, 0
  %2215 = insertvalue { ptr, ptr, ptr, i32 } %2214, ptr %.sroa.6.0563.i3850, 1
  %2216 = insertvalue { ptr, ptr, ptr, i32 } %2215, ptr %.sroa.12.0562.i3851, 2
  %2217 = insertvalue { ptr, ptr, ptr, i32 } %2216, i32 %.sroa.17.0561.i3852, 3
  %2218 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3849)
  %2219 = sext i32 %.sroa.17.0561.i3852 to i64
  %2220 = getelementptr ptr, ptr %.sroa.0.0564.i3849, i64 %2219
  %2221 = getelementptr i8, ptr %2220, i64 64
  %2222 = load ptr, ptr %2221, align 8
  %result.i125.i3853 = call ptr %2222({ ptr, ptr, ptr, i32 } %2217, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2223 = call i32 %result.i125.i3853({ ptr, ptr, ptr, i32 } %2217, { ptr, ptr, ptr, i32 } %2217, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3848, label %2224, label %2240

2224:                                             ; preds = %2209
  %2225 = load i32, ptr %53, align 8
  %2226 = add i32 %2225, -1
  %2227 = and i32 %2226, %2223
  %2228 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2229 = load ptr, ptr %54, align 8
  %2230 = sext i32 %2227 to i64
  %2231 = shl nsw i64 %2230, 5
  %2232 = getelementptr i8, ptr %2229, i64 %2231
  %2233 = load ptr, ptr %2232, align 8
  %2234 = getelementptr i8, ptr %2232, i64 8
  %2235 = load i160, ptr %2234, align 4
  store ptr %.sroa.0.0564.i3849, ptr %2232, align 8
  store i64 %2212, ptr %2234, align 4
  %.sroa_idx157.i3896 = getelementptr i8, ptr %2232, i64 16
  store i64 %2211, ptr %.sroa_idx157.i3896, align 4
  %.sroa_idx158.i3897 = getelementptr i8, ptr %2232, i64 24
  store i32 %.sroa.17.0561.i3852, ptr %.sroa_idx158.i3897, align 4
  %2236 = icmp ne ptr %2233, @nil_typ
  %2237 = icmp ne ptr %2233, null
  %.not92.i3898 = and i1 %2236, %2237
  %extract.i3900 = lshr i160 %2235, 64
  %2238 = insertelement <2 x i160> poison, i160 %2235, i64 0
  %2239 = insertelement <2 x i160> %2238, i160 %extract.i3900, i64 1
  br i1 %.not92.i3898, label %.cont.cont.i3867, label %2279

2240:                                             ; preds = %2209
  %2241 = add i32 %2223, 2127912214
  %2242 = shl i32 %2223, 12
  %2243 = add i32 %2241, %2242
  %2244 = ashr i32 %2243, 19
  %2245 = xor i32 %2243, %2244
  %2246 = xor i32 %2245, -949894596
  %2247 = add i32 %2246, 374761393
  %2248 = shl i32 %2246, 5
  %2249 = add i32 %2247, %2248
  %2250 = add i32 %2249, -744332180
  %2251 = shl i32 %2249, 9
  %2252 = xor i32 %2250, %2251
  %2253 = add i32 %2252, -42973499
  %2254 = shl i32 %2252, 3
  %2255 = add i32 %2253, %2254
  %2256 = ashr i32 %2255, 16
  %2257 = xor i32 %2255, %2256
  %2258 = xor i32 %2257, -1252372727
  %2259 = load i32, ptr %53, align 8
  %2260 = add i32 %2259, -1
  %2261 = and i32 %2260, %2258
  %2262 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2263 = load ptr, ptr %55, align 8
  %2264 = sext i32 %2261 to i64
  %2265 = shl nsw i64 %2264, 5
  %2266 = getelementptr i8, ptr %2263, i64 %2265
  %2267 = load ptr, ptr %2266, align 8
  %2268 = getelementptr i8, ptr %2266, i64 8
  %2269 = load i160, ptr %2268, align 4
  store ptr %.sroa.0.0564.i3849, ptr %2266, align 8
  store i64 %2212, ptr %2268, align 4
  %.sroa_idx161.i3857 = getelementptr i8, ptr %2266, i64 16
  store i64 %2211, ptr %.sroa_idx161.i3857, align 4
  %.sroa_idx162.i3858 = getelementptr i8, ptr %2266, i64 24
  store i32 %.sroa.17.0561.i3852, ptr %.sroa_idx162.i3858, align 4
  %2270 = icmp ne ptr %2267, @nil_typ
  %2271 = icmp ne ptr %2267, null
  %.not90.i3859 = and i1 %2270, %2271
  %extract607.i3861 = lshr i160 %2269, 64
  %2272 = insertelement <2 x i160> poison, i160 %2269, i64 0
  %2273 = insertelement <2 x i160> %2272, i160 %extract607.i3861, i64 1
  br i1 %.not90.i3859, label %.cont.cont.i3867, label %2279

.cont.cont.i3867:                                 ; preds = %2240, %2224
  %vptr.i142.sroa.speculated.i3870 = phi ptr [ %2233, %2224 ], [ %2267, %2240 ]
  %.in4303 = phi <2 x i160> [ %2239, %2224 ], [ %2273, %2240 ]
  %2274 = trunc <2 x i160> %.in4303 to <2 x i64>
  %2275 = xor i1 %.070565.i3848, true
  %hash_coef_ptr.i.i143.i3873 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3870, i64 8
  %tbl_size_ptr.i.i144.i3874 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3870, i64 16
  %offset_tbl_ptr.i.i145.i3875 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3870, i64 40
  %hash_coef.i.i146.i3876 = load i64, ptr %hash_coef_ptr.i.i143.i3873, align 4
  %tbl_size.i.i147.i3877 = load i64, ptr %tbl_size_ptr.i.i144.i3874, align 4
  %offset_tbl.i.i148.i3878 = load ptr, ptr %offset_tbl_ptr.i.i145.i3875, align 8
  %product.i.i.i149.i3879 = mul i64 %hash_coef.i.i146.i3876, 4015701072841558310
  %shifted.i.i.i150.i3880 = lshr i64 %product.i.i.i149.i3879, 32
  %xored.i.i.i151.i3881 = xor i64 %shifted.i.i.i150.i3880, %product.i.i.i149.i3879
  %hash.i.i.i152.i3882 = and i64 %xored.i.i.i151.i3881, %tbl_size.i.i147.i3877
  %offset_ptr.i.i153.i3883 = getelementptr i32, ptr %offset_tbl.i.i148.i3878, i64 %hash.i.i.i152.i3882
  %offset.i.i154.i3884 = load i32, ptr %offset_ptr.i.i153.i3883, align 4
  %2276 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2277 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2278 = icmp ult i32 %.0566.i3847, 99
  br i1 %2278, label %2209, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3902

2279:                                             ; preds = %2240, %2224
  %2280 = phi ptr [ %4, %2240 ], [ %3, %2224 ]
  %2281 = load i32, ptr %63, align 4
  store i32 %2281, ptr %2280, align 4
  %2282 = add i32 %2281, 1
  %2283 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2282, ptr %63, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3902

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3902: ; preds = %.cont.cont.i3867, %2279
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i2918

._crit_edge.i2918:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3902, %2195
  %2284 = add nuw nsw i32 %.060.i2916, 1
  %2285 = icmp slt i32 %2284, %2098
  br i1 %2285, label %2195, label %CuckooMap_insert_keyK_valueV.exit982

CuckooMap_insert_keyK_valueV.exit982:             ; preds = %._crit_edge.i2918, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2900.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1943.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1837.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1731, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1672, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1837, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1943
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2286 = add nsw i32 %.0361686, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit982, %CuckooMap_get_keyK.exit
  %.2363 = phi i32 [ %2286, %CuckooMap_insert_keyK_valueV.exit982 ], [ %.0361686, %CuckooMap_get_keyK.exit ]
  %2287 = add nuw nsw i32 %.0358687, 1
  %2288 = icmp slt i32 %.2363, %0
  %2289 = icmp slt i32 %2287, %57
  %spec.select = select i1 %2288, i1 %2289, i1 false
  br i1 %spec.select, label %65, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %2290 = sext i32 %0 to i64
  %2291 = shl nsw i64 %2290, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %2291, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %2292 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #35
  %2293 = mul i32 %0, 20
  %2294 = icmp sgt i32 %2293, 0
  %spec.select384688 = and i1 %58, %2294
  br i1 %spec.select384688, label %.lr.ph691, label %._crit_edge7._crit_edge

.lr.ph691:                                        ; preds = %._crit_edge3._crit_edge
  %2295 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2296 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2297 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  br label %2298

2298:                                             ; preds = %.lr.ph691, %._crit_edge5
  %2299 = phi i32 [ 987, %.lr.ph691 ], [ %2302, %._crit_edge5 ]
  %.0357690 = phi i32 [ 0, %.lr.ph691 ], [ %.2, %._crit_edge5 ]
  %.2360689 = phi i32 [ 0, %.lr.ph691 ], [ %2427, %._crit_edge5 ]
  %2300 = mul i32 %2299, 1103515245
  %2301 = add i32 %2300, 12345
  %2302 = and i32 %2301, 2147483647
  %.sroa.0285.0.insert.ext = zext nneg i32 %2302 to i160
  %2303 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0285.0.insert.ext, 1
  %2304 = load ptr, ptr %51, align 8
  %2305 = call i32 %2304({ ptr, i160 } %2303) #7
  %2306 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %2307 = load i32, ptr %53, align 8
  %2308 = add i32 %2307, -1
  %2309 = and i32 %2308, %2305
  %2310 = load ptr, ptr %54, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2311 = sext i32 %2309 to i64
  %2312 = shl nsw i64 %2311, 5
  %2313 = getelementptr i8, ptr %2310, i64 %2312
  %2314 = load ptr, ptr %2313, align 8
  %2315 = icmp ne ptr %2314, @nil_typ
  %2316 = icmp ne ptr %2314, null
  %.not44.i2007 = and i1 %2315, %2316
  br i1 %.not44.i2007, label %2317, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031.thread

2317:                                             ; preds = %2298
  %2318 = getelementptr i8, ptr %2313, i64 8
  %2319 = load i64, ptr %2318, align 4
  %.sroa_idx.i2011 = getelementptr i8, ptr %2313, i64 16
  %2320 = load i64, ptr %.sroa_idx.i2011, align 4
  %2321 = inttoptr i64 %2319 to ptr
  %2322 = inttoptr i64 %2320 to ptr
  %hash_coef_ptr.i.i46.i2012 = getelementptr i8, ptr %2314, i64 8
  %tbl_size_ptr.i.i47.i2013 = getelementptr i8, ptr %2314, i64 16
  %offset_tbl_ptr.i.i48.i2014 = getelementptr i8, ptr %2314, i64 40
  %hash_coef.i.i49.i2015 = load i64, ptr %hash_coef_ptr.i.i46.i2012, align 4, !noalias !311
  %tbl_size.i.i50.i2016 = load i64, ptr %tbl_size_ptr.i.i47.i2013, align 4, !noalias !311
  %offset_tbl.i.i51.i2017 = load ptr, ptr %offset_tbl_ptr.i.i48.i2014, align 8, !noalias !311
  %product.i.i.i52.i2018 = mul i64 %hash_coef.i.i49.i2015, 4015701072841558310
  %shifted.i.i.i53.i2019 = lshr i64 %product.i.i.i52.i2018, 32
  %xored.i.i.i54.i2020 = xor i64 %shifted.i.i.i53.i2019, %product.i.i.i52.i2018
  %hash.i.i.i55.i2021 = and i64 %xored.i.i.i54.i2020, %tbl_size.i.i50.i2016
  %offset_ptr.i.i56.i2022 = getelementptr i32, ptr %offset_tbl.i.i51.i2017, i64 %hash.i.i.i55.i2021
  %offset.i.i57.i2023 = load i32, ptr %offset_ptr.i.i56.i2022, align 4, !noalias !311
  %2323 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2314, 0
  %2324 = insertvalue { ptr, ptr, ptr, i32 } %2323, ptr %2321, 1
  %2325 = insertvalue { ptr, ptr, ptr, i32 } %2324, ptr %2322, 2
  %2326 = insertvalue { ptr, ptr, ptr, i32 } %2325, i32 %offset.i.i57.i2023, 3
  %2327 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2328 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2314) #35
  %2329 = sext i32 %offset.i.i57.i2023 to i64
  %2330 = getelementptr ptr, ptr %2314, i64 %2329
  %2331 = getelementptr i8, ptr %2330, i64 64
  %2332 = load ptr, ptr %2331, align 8
  %result.i.i2024 = call ptr %2332({ ptr, ptr, ptr, i32 } %2326, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2333 = call i32 %result.i.i2024({ ptr, ptr, ptr, i32 } %2326, { ptr, ptr, ptr, i32 } %2326, ptr nonnull align 8 %2) #7
  %2334 = icmp eq i32 %2333, %2305
  br i1 %2334, label %._crit_edge.i2025, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031.thread

._crit_edge.i2025:                                ; preds = %2317
  %2335 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2336 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2314)
  %2337 = getelementptr i8, ptr %2330, i64 48
  %2338 = load ptr, ptr %2337, align 8
  %result.i59.i2026 = call ptr %2338({ ptr, ptr, ptr, i32 } %2326, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2339 = call { ptr, i160 } %result.i59.i2026({ ptr, ptr, ptr, i32 } %2326, { ptr, ptr, ptr, i32 } %2326, ptr nonnull align 8 %2) #7
  %2340 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2341 = load ptr, ptr %52, align 8
  %2342 = call i1 %2341({ ptr, i160 } %2339, { ptr, i160 } %2303) #7
  br i1 %2342, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031.thread: ; preds = %._crit_edge.i2025, %2298, %2317
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2351

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031: ; preds = %._crit_edge.i2025
  %2343 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2344 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2314)
  %2345 = getelementptr i8, ptr %2330, i64 56
  %2346 = load ptr, ptr %2345, align 8
  %result.i60.i2028 = call ptr %2346({ ptr, ptr, ptr, i32 } %2326, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2347 = call { ptr, i160 } %result.i60.i2028({ ptr, ptr, ptr, i32 } %2326, { ptr, ptr, ptr, i32 } %2326, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2029 = extractvalue { ptr, i160 } %2347, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2348 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2349 = icmp ne ptr %.fca.0.extract21.i2029, @nil_typ
  %2350 = icmp ne ptr %.fca.0.extract21.i2029, null
  %.not63.i1018 = and i1 %2349, %2350
  br i1 %.not63.i1018, label %CuckooMap_get_keyK.exit1031, label %2351

2351:                                             ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031
  %2352 = add i32 %2305, 2127912214
  %2353 = shl i32 %2305, 12
  %2354 = add i32 %2352, %2353
  %2355 = ashr i32 %2354, 19
  %2356 = xor i32 %2354, %2355
  %2357 = xor i32 %2356, -949894596
  %2358 = add i32 %2357, 374761393
  %2359 = shl i32 %2357, 5
  %2360 = add i32 %2358, %2359
  %2361 = add i32 %2360, -744332180
  %2362 = shl i32 %2360, 9
  %2363 = xor i32 %2361, %2362
  %2364 = add i32 %2363, -42973499
  %2365 = shl i32 %2363, 3
  %2366 = add i32 %2364, %2365
  %2367 = ashr i32 %2366, 16
  %2368 = xor i32 %2366, %2367
  %2369 = xor i32 %2368, -1252372727
  %2370 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2371 = load i32, ptr %53, align 8
  %2372 = add i32 %2371, -1
  %2373 = and i32 %2372, %2369
  %2374 = load ptr, ptr %55, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2375 = sext i32 %2373 to i64
  %2376 = shl nsw i64 %2375, 5
  %2377 = getelementptr i8, ptr %2374, i64 %2376
  %2378 = load ptr, ptr %2377, align 8
  %2379 = icmp ne ptr %2378, @nil_typ
  %2380 = icmp ne ptr %2378, null
  %.not44.i2061 = and i1 %2379, %2380
  br i1 %.not44.i2061, label %2381, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2085

2381:                                             ; preds = %2351
  %2382 = getelementptr i8, ptr %2377, i64 8
  %2383 = load i64, ptr %2382, align 4
  %.sroa_idx.i2065 = getelementptr i8, ptr %2377, i64 16
  %2384 = load i64, ptr %.sroa_idx.i2065, align 4
  %2385 = inttoptr i64 %2383 to ptr
  %2386 = inttoptr i64 %2384 to ptr
  %hash_coef_ptr.i.i46.i2066 = getelementptr i8, ptr %2378, i64 8
  %tbl_size_ptr.i.i47.i2067 = getelementptr i8, ptr %2378, i64 16
  %offset_tbl_ptr.i.i48.i2068 = getelementptr i8, ptr %2378, i64 40
  %hash_coef.i.i49.i2069 = load i64, ptr %hash_coef_ptr.i.i46.i2066, align 4, !noalias !314
  %tbl_size.i.i50.i2070 = load i64, ptr %tbl_size_ptr.i.i47.i2067, align 4, !noalias !314
  %offset_tbl.i.i51.i2071 = load ptr, ptr %offset_tbl_ptr.i.i48.i2068, align 8, !noalias !314
  %product.i.i.i52.i2072 = mul i64 %hash_coef.i.i49.i2069, 4015701072841558310
  %shifted.i.i.i53.i2073 = lshr i64 %product.i.i.i52.i2072, 32
  %xored.i.i.i54.i2074 = xor i64 %shifted.i.i.i53.i2073, %product.i.i.i52.i2072
  %hash.i.i.i55.i2075 = and i64 %xored.i.i.i54.i2074, %tbl_size.i.i50.i2070
  %offset_ptr.i.i56.i2076 = getelementptr i32, ptr %offset_tbl.i.i51.i2071, i64 %hash.i.i.i55.i2075
  %offset.i.i57.i2077 = load i32, ptr %offset_ptr.i.i56.i2076, align 4, !noalias !314
  %2387 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2378, 0
  %2388 = insertvalue { ptr, ptr, ptr, i32 } %2387, ptr %2385, 1
  %2389 = insertvalue { ptr, ptr, ptr, i32 } %2388, ptr %2386, 2
  %2390 = insertvalue { ptr, ptr, ptr, i32 } %2389, i32 %offset.i.i57.i2077, 3
  %2391 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2392 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2378) #35
  %2393 = sext i32 %offset.i.i57.i2077 to i64
  %2394 = getelementptr ptr, ptr %2378, i64 %2393
  %2395 = getelementptr i8, ptr %2394, i64 64
  %2396 = load ptr, ptr %2395, align 8
  %result.i.i2078 = call ptr %2396({ ptr, ptr, ptr, i32 } %2390, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2397 = call i32 %result.i.i2078({ ptr, ptr, ptr, i32 } %2390, { ptr, ptr, ptr, i32 } %2390, ptr nonnull align 8 %2) #7
  %2398 = icmp eq i32 %2397, %2305
  br i1 %2398, label %._crit_edge.i2079, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2085

._crit_edge.i2079:                                ; preds = %2381
  %2399 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2400 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2378)
  %2401 = getelementptr i8, ptr %2394, i64 48
  %2402 = load ptr, ptr %2401, align 8
  %result.i59.i2080 = call ptr %2402({ ptr, ptr, ptr, i32 } %2390, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2403 = call { ptr, i160 } %result.i59.i2080({ ptr, ptr, ptr, i32 } %2390, { ptr, ptr, ptr, i32 } %2390, ptr nonnull align 8 %2) #7
  %2404 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2405 = load ptr, ptr %52, align 8
  %2406 = call i1 %2405({ ptr, i160 } %2403, { ptr, i160 } %2303) #7
  br i1 %2406, label %2407, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2085

2407:                                             ; preds = %._crit_edge.i2079
  %2408 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2409 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2378)
  %2410 = getelementptr i8, ptr %2394, i64 56
  %2411 = load ptr, ptr %2410, align 8
  %result.i60.i2082 = call ptr %2411({ ptr, ptr, ptr, i32 } %2390, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2412 = call { ptr, i160 } %result.i60.i2082({ ptr, ptr, ptr, i32 } %2390, { ptr, ptr, ptr, i32 } %2390, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2083 = extractvalue { ptr, i160 } %2412, 0
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2085

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2085: ; preds = %2351, %2381, %._crit_edge.i2079, %2407
  %2413 = phi ptr [ %.fca.0.extract21.i2083, %2407 ], [ @nil_typ, %._crit_edge.i2079 ], [ @nil_typ, %2351 ], [ @nil_typ, %2381 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2414 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2415 = icmp ne ptr %2413, @nil_typ
  %2416 = icmp ne ptr %2413, null
  %.not65.not.not.i1024 = and i1 %2415, %2416
  %cond.fr.i1025 = freeze i1 %.not65.not.not.i1024
  %spec.select.i1026 = select i1 %cond.fr.i1025, ptr %2413, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit1031

CuckooMap_get_keyK.exit1031:                      ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2085
  %2417 = phi ptr [ %.fca.0.extract21.i2029, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2031 ], [ %spec.select.i1026, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2085 ]
  %2418 = icmp eq ptr %2417, @nil_typ
  %2419 = icmp eq ptr %2417, null
  %2420 = or i1 %2418, %2419
  br i1 %2420, label %2421, label %._crit_edge5

2421:                                             ; preds = %CuckooMap_get_keyK.exit1031
  %2422 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %2423 = sext i32 %.0357690 to i64
  %2424 = shl nsw i64 %2423, 2
  %2425 = getelementptr i8, ptr %result.i4.i, i64 %2424
  store i32 %2302, ptr %2425, align 1
  %2426 = add nsw i32 %.0357690, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %2421, %CuckooMap_get_keyK.exit1031
  %.2 = phi i32 [ %2426, %2421 ], [ %.0357690, %CuckooMap_get_keyK.exit1031 ]
  %2427 = add nuw nsw i32 %.2360689, 1
  %2428 = icmp slt i32 %.2, %0
  %2429 = icmp slt i32 %2427, %2293
  %spec.select384 = select i1 %2428, i1 %2429, i1 false
  br i1 %spec.select384, label %2298, label %._crit_edge7._crit_edge

._crit_edge7._crit_edge:                          ; preds = %._crit_edge5, %._crit_edge3._crit_edge
  %.0357.lcssa = phi i32 [ 0, %._crit_edge3._crit_edge ], [ %.2, %._crit_edge5 ]
  %2430 = icmp slt i32 %.0357.lcssa, %0
  br i1 %2430, label %._crit_edge.lr.ph.i, label %._crit_edge8

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge7._crit_edge
  %result.i476 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i476, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2431 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2432 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2099 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i2099, ptr noundef nonnull align 32 dereferenceable(29) %result.i476, i64 29, i1 false)
  %2433 = getelementptr i8, ptr %result.i.i2099, i64 29
  store i8 0, ptr %2433, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2099)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2434 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0357.lcssa) #17
  %result.i482 = call noalias align 32 dereferenceable_or_null(23) ptr @bump_malloc_inner(i64 noundef 23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <22 x i8> <i8 32, i8 103, i8 117, i8 97, i8 114, i8 97, i8 110, i8 116, i8 101, i8 101, i8 100, i8 32, i8 109, i8 105, i8 115, i8 115, i8 32, i8 107, i8 101, i8 121, i8 115, i8 46>, ptr %result.i482, align 32
  %2435 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2436 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2437 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2114 = call noalias dereferenceable_or_null(23) ptr @bump_malloc_inner(i64 noundef 23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(22) %result.i.i2114, ptr noundef nonnull align 32 dereferenceable(22) %result.i482, i64 22, i1 false)
  %2438 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2439 = getelementptr i8, ptr %result.i.i2114, i64 22
  store i8 0, ptr %2439, align 1
  %puts.i1080 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2114)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge7._crit_edge, %._crit_edge.lr.ph.i
  %.0380 = phi i32 [ %.0357.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge7._crit_edge ]
  %2440 = call i64 @clock()
  %2441 = icmp sgt i32 %.0380, 0
  br i1 %2441, label %._crit_edge9.preheader, label %2574

._crit_edge9.preheader:                           ; preds = %._crit_edge8
  %2442 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  br label %._crit_edge9

._crit_edge9:                                     ; preds = %._crit_edge9.preheader, %CuckooMap_get_keyK.exit1130
  %.0365694 = phi i32 [ %.2367, %CuckooMap_get_keyK.exit1130 ], [ 0, %._crit_edge9.preheader ]
  %.0368693 = phi i32 [ %.2370, %CuckooMap_get_keyK.exit1130 ], [ 0, %._crit_edge9.preheader ]
  %.0371692 = phi i32 [ %2566, %CuckooMap_get_keyK.exit1130 ], [ 0, %._crit_edge9.preheader ]
  %2443 = zext nneg i32 %.0371692 to i64
  %2444 = shl nuw nsw i64 %2443, 2
  %2445 = getelementptr i8, ptr %result.i4.i, i64 %2444
  %2446 = load i32, ptr %2445, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %2446 to i160
  %2447 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %2448 = load ptr, ptr %40, align 8
  %2449 = call i32 %2448({ ptr, i160 } %2447) #7
  %2450 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %2451 = load i32, ptr %42, align 8
  %2452 = add i32 %2451, -1
  %2453 = and i32 %2452, %2449
  %2454 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2455 = sext i32 %2453 to i64
  %2456 = shl nsw i64 %2455, 5
  %2457 = getelementptr i8, ptr %2454, i64 %2456
  %2458 = load ptr, ptr %2457, align 8
  %2459 = icmp ne ptr %2458, @nil_typ
  %2460 = icmp ne ptr %2458, null
  %.not44.i2161 = and i1 %2459, %2460
  br i1 %.not44.i2161, label %2461, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185.thread

2461:                                             ; preds = %._crit_edge9
  %2462 = getelementptr i8, ptr %2457, i64 8
  %2463 = load i64, ptr %2462, align 4
  %.sroa_idx.i2165 = getelementptr i8, ptr %2457, i64 16
  %2464 = load i64, ptr %.sroa_idx.i2165, align 4
  %2465 = inttoptr i64 %2463 to ptr
  %2466 = inttoptr i64 %2464 to ptr
  %hash_coef_ptr.i.i46.i2166 = getelementptr i8, ptr %2458, i64 8
  %tbl_size_ptr.i.i47.i2167 = getelementptr i8, ptr %2458, i64 16
  %offset_tbl_ptr.i.i48.i2168 = getelementptr i8, ptr %2458, i64 40
  %hash_coef.i.i49.i2169 = load i64, ptr %hash_coef_ptr.i.i46.i2166, align 4, !noalias !317
  %tbl_size.i.i50.i2170 = load i64, ptr %tbl_size_ptr.i.i47.i2167, align 4, !noalias !317
  %offset_tbl.i.i51.i2171 = load ptr, ptr %offset_tbl_ptr.i.i48.i2168, align 8, !noalias !317
  %product.i.i.i52.i2172 = mul i64 %hash_coef.i.i49.i2169, 4015701072841558310
  %shifted.i.i.i53.i2173 = lshr i64 %product.i.i.i52.i2172, 32
  %xored.i.i.i54.i2174 = xor i64 %shifted.i.i.i53.i2173, %product.i.i.i52.i2172
  %hash.i.i.i55.i2175 = and i64 %xored.i.i.i54.i2174, %tbl_size.i.i50.i2170
  %offset_ptr.i.i56.i2176 = getelementptr i32, ptr %offset_tbl.i.i51.i2171, i64 %hash.i.i.i55.i2175
  %offset.i.i57.i2177 = load i32, ptr %offset_ptr.i.i56.i2176, align 4, !noalias !317
  %2467 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2458, 0
  %2468 = insertvalue { ptr, ptr, ptr, i32 } %2467, ptr %2465, 1
  %2469 = insertvalue { ptr, ptr, ptr, i32 } %2468, ptr %2466, 2
  %2470 = insertvalue { ptr, ptr, ptr, i32 } %2469, i32 %offset.i.i57.i2177, 3
  %2471 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2472 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2458) #35
  %2473 = sext i32 %offset.i.i57.i2177 to i64
  %2474 = getelementptr ptr, ptr %2458, i64 %2473
  %2475 = getelementptr i8, ptr %2474, i64 64
  %2476 = load ptr, ptr %2475, align 8
  %result.i.i2178 = call ptr %2476({ ptr, ptr, ptr, i32 } %2470, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2477 = call i32 %result.i.i2178({ ptr, ptr, ptr, i32 } %2470, { ptr, ptr, ptr, i32 } %2470, ptr nonnull align 8 %2) #7
  %2478 = icmp eq i32 %2477, %2449
  br i1 %2478, label %._crit_edge.i2179, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185.thread

._crit_edge.i2179:                                ; preds = %2461
  %2479 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2480 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2458)
  %2481 = getelementptr i8, ptr %2474, i64 48
  %2482 = load ptr, ptr %2481, align 8
  %result.i59.i2180 = call ptr %2482({ ptr, ptr, ptr, i32 } %2470, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2483 = call { ptr, i160 } %result.i59.i2180({ ptr, ptr, ptr, i32 } %2470, { ptr, ptr, ptr, i32 } %2470, ptr nonnull align 8 %2) #7
  %2484 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2485 = load ptr, ptr %41, align 8
  %2486 = call i1 %2485({ ptr, i160 } %2483, { ptr, i160 } %2447) #7
  br i1 %2486, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185.thread: ; preds = %._crit_edge.i2179, %._crit_edge9, %2461
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2495

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185: ; preds = %._crit_edge.i2179
  %2487 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2488 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2458)
  %2489 = getelementptr i8, ptr %2474, i64 56
  %2490 = load ptr, ptr %2489, align 8
  %result.i60.i2182 = call ptr %2490({ ptr, ptr, ptr, i32 } %2470, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2491 = call { ptr, i160 } %result.i60.i2182({ ptr, ptr, ptr, i32 } %2470, { ptr, ptr, ptr, i32 } %2470, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2183 = extractvalue { ptr, i160 } %2491, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2492 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2493 = icmp ne ptr %.fca.0.extract21.i2183, @nil_typ
  %2494 = icmp ne ptr %.fca.0.extract21.i2183, null
  %.not63.i1117 = and i1 %2493, %2494
  br i1 %.not63.i1117, label %CuckooMap_get_keyK.exit1130, label %2495

2495:                                             ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185
  %2496 = add i32 %2449, 2127912214
  %2497 = shl i32 %2449, 12
  %2498 = add i32 %2496, %2497
  %2499 = ashr i32 %2498, 19
  %2500 = xor i32 %2498, %2499
  %2501 = xor i32 %2500, -949894596
  %2502 = add i32 %2501, 374761393
  %2503 = shl i32 %2501, 5
  %2504 = add i32 %2502, %2503
  %2505 = add i32 %2504, -744332180
  %2506 = shl i32 %2504, 9
  %2507 = xor i32 %2505, %2506
  %2508 = add i32 %2507, -42973499
  %2509 = shl i32 %2507, 3
  %2510 = add i32 %2508, %2509
  %2511 = ashr i32 %2510, 16
  %2512 = xor i32 %2510, %2511
  %2513 = xor i32 %2512, -1252372727
  %2514 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2515 = load i32, ptr %42, align 8
  %2516 = add i32 %2515, -1
  %2517 = and i32 %2516, %2513
  %2518 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2519 = sext i32 %2517 to i64
  %2520 = shl nsw i64 %2519, 5
  %2521 = getelementptr i8, ptr %2518, i64 %2520
  %2522 = load ptr, ptr %2521, align 8
  %2523 = icmp ne ptr %2522, @nil_typ
  %2524 = icmp ne ptr %2522, null
  %.not44.i2215 = and i1 %2523, %2524
  br i1 %.not44.i2215, label %2525, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2239

2525:                                             ; preds = %2495
  %2526 = getelementptr i8, ptr %2521, i64 8
  %2527 = load i64, ptr %2526, align 4
  %.sroa_idx.i2219 = getelementptr i8, ptr %2521, i64 16
  %2528 = load i64, ptr %.sroa_idx.i2219, align 4
  %2529 = inttoptr i64 %2527 to ptr
  %2530 = inttoptr i64 %2528 to ptr
  %hash_coef_ptr.i.i46.i2220 = getelementptr i8, ptr %2522, i64 8
  %tbl_size_ptr.i.i47.i2221 = getelementptr i8, ptr %2522, i64 16
  %offset_tbl_ptr.i.i48.i2222 = getelementptr i8, ptr %2522, i64 40
  %hash_coef.i.i49.i2223 = load i64, ptr %hash_coef_ptr.i.i46.i2220, align 4, !noalias !320
  %tbl_size.i.i50.i2224 = load i64, ptr %tbl_size_ptr.i.i47.i2221, align 4, !noalias !320
  %offset_tbl.i.i51.i2225 = load ptr, ptr %offset_tbl_ptr.i.i48.i2222, align 8, !noalias !320
  %product.i.i.i52.i2226 = mul i64 %hash_coef.i.i49.i2223, 4015701072841558310
  %shifted.i.i.i53.i2227 = lshr i64 %product.i.i.i52.i2226, 32
  %xored.i.i.i54.i2228 = xor i64 %shifted.i.i.i53.i2227, %product.i.i.i52.i2226
  %hash.i.i.i55.i2229 = and i64 %xored.i.i.i54.i2228, %tbl_size.i.i50.i2224
  %offset_ptr.i.i56.i2230 = getelementptr i32, ptr %offset_tbl.i.i51.i2225, i64 %hash.i.i.i55.i2229
  %offset.i.i57.i2231 = load i32, ptr %offset_ptr.i.i56.i2230, align 4, !noalias !320
  %2531 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2522, 0
  %2532 = insertvalue { ptr, ptr, ptr, i32 } %2531, ptr %2529, 1
  %2533 = insertvalue { ptr, ptr, ptr, i32 } %2532, ptr %2530, 2
  %2534 = insertvalue { ptr, ptr, ptr, i32 } %2533, i32 %offset.i.i57.i2231, 3
  %2535 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2536 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2522) #35
  %2537 = sext i32 %offset.i.i57.i2231 to i64
  %2538 = getelementptr ptr, ptr %2522, i64 %2537
  %2539 = getelementptr i8, ptr %2538, i64 64
  %2540 = load ptr, ptr %2539, align 8
  %result.i.i2232 = call ptr %2540({ ptr, ptr, ptr, i32 } %2534, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2541 = call i32 %result.i.i2232({ ptr, ptr, ptr, i32 } %2534, { ptr, ptr, ptr, i32 } %2534, ptr nonnull align 8 %2) #7
  %2542 = icmp eq i32 %2541, %2449
  br i1 %2542, label %._crit_edge.i2233, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2239

._crit_edge.i2233:                                ; preds = %2525
  %2543 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2544 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2522)
  %2545 = getelementptr i8, ptr %2538, i64 48
  %2546 = load ptr, ptr %2545, align 8
  %result.i59.i2234 = call ptr %2546({ ptr, ptr, ptr, i32 } %2534, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2547 = call { ptr, i160 } %result.i59.i2234({ ptr, ptr, ptr, i32 } %2534, { ptr, ptr, ptr, i32 } %2534, ptr nonnull align 8 %2) #7
  %2548 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2549 = load ptr, ptr %41, align 8
  %2550 = call i1 %2549({ ptr, i160 } %2547, { ptr, i160 } %2447) #7
  br i1 %2550, label %2551, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2239

2551:                                             ; preds = %._crit_edge.i2233
  %2552 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2553 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2522)
  %2554 = getelementptr i8, ptr %2538, i64 56
  %2555 = load ptr, ptr %2554, align 8
  %result.i60.i2236 = call ptr %2555({ ptr, ptr, ptr, i32 } %2534, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2556 = call { ptr, i160 } %result.i60.i2236({ ptr, ptr, ptr, i32 } %2534, { ptr, ptr, ptr, i32 } %2534, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2237 = extractvalue { ptr, i160 } %2556, 0
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2239

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2239: ; preds = %2495, %2525, %._crit_edge.i2233, %2551
  %2557 = phi ptr [ %.fca.0.extract21.i2237, %2551 ], [ @nil_typ, %._crit_edge.i2233 ], [ @nil_typ, %2495 ], [ @nil_typ, %2525 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2558 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2559 = icmp ne ptr %2557, @nil_typ
  %2560 = icmp ne ptr %2557, null
  %.not65.not.not.i1123 = and i1 %2559, %2560
  %cond.fr.i1124 = freeze i1 %.not65.not.not.i1123
  %spec.select.i1125 = select i1 %cond.fr.i1124, ptr %2557, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit1130

CuckooMap_get_keyK.exit1130:                      ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2239
  %2561 = phi ptr [ %.fca.0.extract21.i2183, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2185 ], [ %spec.select.i1125, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2239 ]
  %2562 = icmp eq ptr %2561, @nil_typ
  %2563 = icmp eq ptr %2561, null
  %2564 = or i1 %2562, %2563
  %.0365..0368 = select i1 %2564, i32 %.0365694, i32 %.0368693
  %2565 = add i32 %.0365..0368, 1
  %.2370 = select i1 %2564, i32 %.0368693, i32 %2565
  %.2367 = select i1 %2564, i32 %2565, i32 %.0365694
  %2566 = add nuw nsw i32 %.0371692, 1
  %2567 = icmp slt i32 %2566, %.0380
  br i1 %2567, label %._crit_edge9, label %2568

2568:                                             ; preds = %CuckooMap_get_keyK.exit1130
  %2569 = call i64 @clock()
  %2570 = mul i32 %.2370, 100
  %2571 = sdiv i32 %2570, %.0380
  %2572 = icmp slt i32 %2571, 5
  %2573 = select i1 %2572, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  br label %._crit_edge.lr.ph.i2254

2574:                                             ; preds = %._crit_edge8
  %2575 = call i64 @clock()
  br label %._crit_edge.lr.ph.i2254

._crit_edge.lr.ph.i2254:                          ; preds = %2574, %2568
  %2576 = phi i64 [ %2569, %2568 ], [ %2575, %2574 ]
  %.0365.lcssa701 = phi i32 [ %.2367, %2568 ], [ 0, %2574 ]
  %.0368.lcssa699 = phi i32 [ %.2370, %2568 ], [ 0, %2574 ]
  %.reg2mem27.0.in = phi <4 x i8> [ %2573, %2568 ], [ <i8 80, i8 65, i8 83, i8 83>, %2574 ]
  %result.i489 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %result.i489, align 16
  %2577 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2578 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2579 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2253 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i2253, ptr noundef nonnull align 16 dereferenceable(15) %result.i489, i64 15, i1 false)
  %2580 = sub i64 %2576, %2440
  %2581 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2582 = getelementptr i8, ptr %result.i.i2253, i64 15
  store i8 0, ptr %2582, align 1
  %puts.i1150 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2253)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i98.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98.i, align 16
  %result.i.i356.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i98.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356.i)
  %2583 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0380) #17
  %result.i104.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104.i, align 16
  %result.i.i370.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i104.i, i64 14, i1 false)
  %puts.i294.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370.i)
  %2584 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2580) #17
  %result.i110.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110.i, align 4
  %result.i.i389.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i110.i, i64 3, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  br i1 %2441, label %._crit_edge1.i, label %._crit_edge.lr.ph.i2273

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i2254
  %2585 = icmp sgt i64 %2580, 0
  br i1 %2585, label %2586, label %._crit_edge.lr.ph.i409.i

2586:                                             ; preds = %._crit_edge1.i
  %2587 = mul i64 %2580, 1000000
  %2588 = zext nneg i32 %.0380 to i64
  %2589 = sdiv i64 %2587, %2588
  br label %._crit_edge.lr.ph.i409.i

._crit_edge.lr.ph.i409.i:                         ; preds = %2586, %._crit_edge1.i
  %.0.i = phi i64 [ %2589, %2586 ], [ 0, %._crit_edge1.i ]
  %result.i115.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115.i, align 16
  %result.i.i408.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i115.i, i64 15, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  %2590 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i121.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121.i, align 4
  %result.i.i427.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i121.i, i64 3, i1 false)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  br label %._crit_edge.lr.ph.i2273

._crit_edge.lr.ph.i2273:                          ; preds = %._crit_edge.lr.ph.i2254, %._crit_edge.lr.ph.i409.i
  %result.i493 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i493, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2591 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2592 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2272 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i2272, ptr noundef nonnull align 32 dereferenceable(18) %result.i493, i64 18, i1 false)
  %2593 = getelementptr i8, ptr %result.i.i2272, i64 18
  store i8 0, ptr %2593, align 1
  %puts.i1170 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2272)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2594 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2595 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2291 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <4 x i8> %.reg2mem27.0.in, ptr %result.i.i2291, align 1
  %2596 = getelementptr i8, ptr %result.i.i2291, i64 4
  store i8 0, ptr %2596, align 1
  %puts.i1190 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2291)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i508 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <13 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %result.i508, align 16
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2597 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2598 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2310 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i2310, ptr noundef nonnull align 16 dereferenceable(13) %result.i508, i64 13, i1 false)
  %2599 = getelementptr i8, ptr %result.i.i2310, i64 13
  store i8 0, ptr %2599, align 1
  %puts.i1210 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2310)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2600 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0365.lcssa701) #17
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2601 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2602 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2329 = call noalias dereferenceable_or_null(9) ptr @bump_malloc_inner(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store i64 2322295501682647084, ptr %result.i.i2329, align 1
  %2603 = getelementptr i8, ptr %result.i.i2329, i64 8
  store i8 0, ptr %2603, align 1
  %puts.i1230 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2329)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2604 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0368.lcssa699) #17
  %2605 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2606 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2607 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2348 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store i8 41, ptr %result.i.i2348, align 1
  %2608 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2609 = getelementptr i8, ptr %result.i.i2348, i64 1
  store i8 0, ptr %2609, align 1
  %puts.i1250 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2348)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr {
  %2 = alloca {}, align 8
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca i32, align 4
  %28 = alloca i32, align 4
  %29 = alloca i32, align 4
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i32, align 4
  %34 = alloca i32, align 4
  %oldProtect.i427 = alloca i32, align 4
  %oldProtect.i423 = alloca i32, align 4
  %oldProtect.i382 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0316.sroa.0 = alloca i8, align 8
  %result.i378 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i378, align 8
  %35 = getelementptr inbounds i8, ptr %result.i378, i64 8
  store ptr @_parameterization_Ptri32, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i378, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %36, align 8
  %37 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i378) #39
  %result.i379 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i380 = call i32 @VirtualProtect(ptr nofree %result.i379, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i379, ptr noalias nofree noundef nonnull readnone @pycmovwgqt, ptr noalias nofree noundef nonnull readnone @i32_hasher) #39
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i379) #40
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i379) #39
  %result.i381 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i382)
  %result.i383 = call i32 @VirtualProtect(ptr nofree %result.i381, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i382) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i382)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i381, ptr noalias nofree noundef nonnull readnone @vzdjjwynyr, ptr noalias nofree noundef nonnull readnone @i32_eq) #39
  %ret.i384 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i381) #40
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i381) #39
  %40 = getelementptr inbounds i8, ptr %result.i378, i64 48
  store ptr %ret.i, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %result.i378, i64 56
  store ptr %ret.i384, ptr %41, align 8
  %42 = getelementptr inbounds i8, ptr %result.i378, i64 40
  store i32 8, ptr %42, align 8
  %result.i.i704 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %43 = getelementptr inbounds i8, ptr %result.i378, i64 24
  store ptr %result.i.i704, ptr %43, align 8
  %result.i9.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %44 = getelementptr inbounds i8, ptr %result.i378, i64 32
  store ptr %result.i9.i, ptr %44, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  %46 = sext i32 %0 to i64
  %47 = shl nsw i64 %46, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %47, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #35
  %result.i421 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i421, align 8
  %49 = getelementptr inbounds i8, ptr %result.i421, i64 8
  store ptr @_parameterization_Ptri1, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i421, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i421)
  %result.i422 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i423)
  %result.i424 = call i32 @VirtualProtect(ptr nofree %result.i422, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i423) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i423)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i422, ptr noalias nofree noundef nonnull readnone @jytlqghthm, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i425 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i422) #40
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i422)
  %result.i426 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i427)
  %result.i428 = call i32 @VirtualProtect(ptr nofree %result.i426, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i427) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i427)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i426, ptr noalias nofree noundef nonnull readnone @wgpehabsqq, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i429 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i426) #40
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i426)
  %54 = getelementptr inbounds i8, ptr %result.i421, i64 48
  store ptr %ret.i425, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i421, i64 56
  store ptr %ret.i429, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %result.i421, i64 40
  store i32 8, ptr %56, align 8
  %result.i.i744 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %57 = getelementptr inbounds i8, ptr %result.i421, i64 24
  store ptr %result.i.i744, ptr %57, align 8
  %result.i9.i745 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %58 = getelementptr inbounds i8, ptr %result.i421, i64 32
  store ptr %result.i9.i745, ptr %58, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %60 = mul i32 %0, 10
  %61 = icmp sgt i32 %0, 0
  %62 = icmp sgt i32 %60, 0
  %spec.select688 = and i1 %61, %62
  br i1 %spec.select688, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %65 = getelementptr inbounds i8, ptr %result.i378, i64 44
  %66 = getelementptr inbounds i8, ptr %result.i421, i64 44
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #35
  br label %68

68:                                               ; preds = %.lr.ph, %._crit_edge1
  %69 = phi i32 [ 101112, %.lr.ph ], [ %72, %._crit_edge1 ]
  %.0355690 = phi i32 [ 0, %.lr.ph ], [ %2294, %._crit_edge1 ]
  %.0357689 = phi i32 [ 0, %.lr.ph ], [ %.2359, %._crit_edge1 ]
  %70 = mul i32 %69, 1103515245
  %71 = add i32 %70, 12345
  %72 = and i32 %71, 2147483647
  %.sroa.0343.0.insert.ext = zext nneg i32 %72 to i160
  %73 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0343.0.insert.ext, 1
  %74 = load ptr, ptr %54, align 8
  %75 = call i32 %74({ ptr, i160 } %73) #7
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %77 = load i32, ptr %56, align 8
  %78 = add i32 %77, -1
  %79 = and i32 %78, %75
  %80 = load ptr, ptr %57, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %81 = sext i32 %79 to i64
  %82 = shl nsw i64 %81, 5
  %83 = getelementptr i8, ptr %80, i64 %82
  %84 = load ptr, ptr %83, align 8
  %85 = icmp ne ptr %84, @nil_typ
  %86 = icmp ne ptr %84, null
  %.not44.i = and i1 %85, %86
  br i1 %.not44.i, label %87, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

87:                                               ; preds = %68
  %88 = getelementptr i8, ptr %83, i64 8
  %89 = load i64, ptr %88, align 4
  %.sroa_idx.i = getelementptr i8, ptr %83, i64 16
  %90 = load i64, ptr %.sroa_idx.i, align 4
  %91 = inttoptr i64 %89 to ptr
  %92 = inttoptr i64 %90 to ptr
  %hash_coef_ptr.i.i46.i = getelementptr i8, ptr %84, i64 8
  %tbl_size_ptr.i.i47.i = getelementptr i8, ptr %84, i64 16
  %offset_tbl_ptr.i.i48.i = getelementptr i8, ptr %84, i64 40
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i46.i, align 4, !noalias !323
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i47.i, align 4, !noalias !323
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i48.i, align 8, !noalias !323
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4015701072841558310
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i57.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !323
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %84, 0
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %91, 1
  %95 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %92, 2
  %96 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %offset.i.i57.i, 3
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84) #35
  %99 = sext i32 %offset.i.i57.i to i64
  %100 = getelementptr ptr, ptr %84, i64 %99
  %101 = getelementptr i8, ptr %100, i64 64
  %102 = load ptr, ptr %101, align 8
  %result.i.i = call ptr %102({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #16
  %103 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %104 = icmp eq i32 %103, %75
  br i1 %104, label %._crit_edge.i1321, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i1321:                                ; preds = %87
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84)
  %107 = getelementptr i8, ptr %100, i64 48
  %108 = load ptr, ptr %107, align 8
  %result.i59.i = call ptr %108({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #16
  %109 = call { ptr, i160 } %result.i59.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %111 = load ptr, ptr %55, align 8
  %112 = call i1 %111({ ptr, i160 } %109, { ptr, i160 } %73) #7
  br i1 %112, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i1321, %68, %87
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %121

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1321
  %113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %84)
  %115 = getelementptr i8, ptr %100, i64 56
  %116 = load ptr, ptr %115, align 8
  %result.i60.i = call ptr %116({ ptr, ptr, ptr, i32 } %96, ptr nocapture nofree noundef nonnull readonly %2) #16
  %117 = call { ptr, i160 } %result.i60.i({ ptr, ptr, ptr, i32 } %96, { ptr, ptr, ptr, i32 } %96, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i = extractvalue { ptr, i160 } %117, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %119 = icmp ne ptr %.fca.0.extract21.i, @nil_typ
  %120 = icmp ne ptr %.fca.0.extract21.i, null
  %.not63.i = and i1 %119, %120
  br i1 %.not63.i, label %CuckooMap_get_keyK.exit, label %121

121:                                              ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %122 = add i32 %75, 2127912214
  %123 = shl i32 %75, 12
  %124 = add i32 %122, %123
  %125 = ashr i32 %124, 19
  %126 = xor i32 %124, %125
  %127 = xor i32 %126, -949894596
  %128 = add i32 %127, 374761393
  %129 = shl i32 %127, 5
  %130 = add i32 %128, %129
  %131 = add i32 %130, -744332180
  %132 = shl i32 %130, 9
  %133 = xor i32 %131, %132
  %134 = add i32 %133, -42973499
  %135 = shl i32 %133, 3
  %136 = add i32 %134, %135
  %137 = ashr i32 %136, 16
  %138 = xor i32 %136, %137
  %139 = xor i32 %138, -1252372727
  %140 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %141 = load i32, ptr %56, align 8
  %142 = add i32 %141, -1
  %143 = and i32 %142, %139
  %144 = load ptr, ptr %58, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %145 = sext i32 %143 to i64
  %146 = shl nsw i64 %145, 5
  %147 = getelementptr i8, ptr %144, i64 %146
  %148 = load ptr, ptr %147, align 8
  %149 = icmp ne ptr %148, @nil_typ
  %150 = icmp ne ptr %148, null
  %.not44.i1350 = and i1 %149, %150
  br i1 %.not44.i1350, label %151, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1374

151:                                              ; preds = %121
  %152 = getelementptr i8, ptr %147, i64 8
  %153 = load i64, ptr %152, align 4
  %.sroa_idx.i1354 = getelementptr i8, ptr %147, i64 16
  %154 = load i64, ptr %.sroa_idx.i1354, align 4
  %155 = inttoptr i64 %153 to ptr
  %156 = inttoptr i64 %154 to ptr
  %hash_coef_ptr.i.i46.i1355 = getelementptr i8, ptr %148, i64 8
  %tbl_size_ptr.i.i47.i1356 = getelementptr i8, ptr %148, i64 16
  %offset_tbl_ptr.i.i48.i1357 = getelementptr i8, ptr %148, i64 40
  %hash_coef.i.i49.i1358 = load i64, ptr %hash_coef_ptr.i.i46.i1355, align 4, !noalias !326
  %tbl_size.i.i50.i1359 = load i64, ptr %tbl_size_ptr.i.i47.i1356, align 4, !noalias !326
  %offset_tbl.i.i51.i1360 = load ptr, ptr %offset_tbl_ptr.i.i48.i1357, align 8, !noalias !326
  %product.i.i.i52.i1361 = mul i64 %hash_coef.i.i49.i1358, 4015701072841558310
  %shifted.i.i.i53.i1362 = lshr i64 %product.i.i.i52.i1361, 32
  %xored.i.i.i54.i1363 = xor i64 %shifted.i.i.i53.i1362, %product.i.i.i52.i1361
  %hash.i.i.i55.i1364 = and i64 %xored.i.i.i54.i1363, %tbl_size.i.i50.i1359
  %offset_ptr.i.i56.i1365 = getelementptr i32, ptr %offset_tbl.i.i51.i1360, i64 %hash.i.i.i55.i1364
  %offset.i.i57.i1366 = load i32, ptr %offset_ptr.i.i56.i1365, align 4, !noalias !326
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %148, 0
  %158 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %155, 1
  %159 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %156, 2
  %160 = insertvalue { ptr, ptr, ptr, i32 } %159, i32 %offset.i.i57.i1366, 3
  %161 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %162 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148) #35
  %163 = sext i32 %offset.i.i57.i1366 to i64
  %164 = getelementptr ptr, ptr %148, i64 %163
  %165 = getelementptr i8, ptr %164, i64 64
  %166 = load ptr, ptr %165, align 8
  %result.i.i1367 = call ptr %166({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #16
  %167 = call i32 %result.i.i1367({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %168 = icmp eq i32 %167, %75
  br i1 %168, label %._crit_edge.i1368, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1374

._crit_edge.i1368:                                ; preds = %151
  %169 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %170 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148)
  %171 = getelementptr i8, ptr %164, i64 48
  %172 = load ptr, ptr %171, align 8
  %result.i59.i1369 = call ptr %172({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #16
  %173 = call { ptr, i160 } %result.i59.i1369({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %175 = load ptr, ptr %55, align 8
  %176 = call i1 %175({ ptr, i160 } %173, { ptr, i160 } %73) #7
  br i1 %176, label %177, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1374

177:                                              ; preds = %._crit_edge.i1368
  %178 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %148)
  %180 = getelementptr i8, ptr %164, i64 56
  %181 = load ptr, ptr %180, align 8
  %result.i60.i1371 = call ptr %181({ ptr, ptr, ptr, i32 } %160, ptr nocapture nofree noundef nonnull readonly %2) #16
  %182 = call { ptr, i160 } %result.i60.i1371({ ptr, ptr, ptr, i32 } %160, { ptr, ptr, ptr, i32 } %160, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i1372 = extractvalue { ptr, i160 } %182, 0
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1374

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1374: ; preds = %121, %151, %._crit_edge.i1368, %177
  %183 = phi ptr [ %.fca.0.extract21.i1372, %177 ], [ @nil_typ, %._crit_edge.i1368 ], [ @nil_typ, %121 ], [ @nil_typ, %151 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %184 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %185 = icmp ne ptr %183, @nil_typ
  %186 = icmp ne ptr %183, null
  %.not65.not.not.i = and i1 %185, %186
  %cond.fr.i = freeze i1 %.not65.not.not.i
  %spec.select.i = select i1 %cond.fr.i, ptr %183, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit

CuckooMap_get_keyK.exit:                          ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1374
  %187 = phi ptr [ %.fca.0.extract21.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1374 ]
  %188 = icmp eq ptr %187, @nil_typ
  %189 = icmp eq ptr %187, null
  %190 = or i1 %188, %189
  br i1 %190, label %191, label %._crit_edge1

191:                                              ; preds = %CuckooMap_get_keyK.exit
  %192 = add nuw i32 %72, 1
  %.sroa.0326.0.insert.ext = zext i32 %192 to i160
  %193 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0326.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %194 = load ptr, ptr %40, align 8
  %195 = call i32 %194({ ptr, i160 } %73) #7
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %197 = load i32, ptr %42, align 8
  %198 = add i32 %197, -1
  %199 = and i32 %198, %195
  %200 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %201 = sext i32 %199 to i64
  %202 = shl nsw i64 %201, 5
  %203 = getelementptr i8, ptr %200, i64 %202
  %204 = load ptr, ptr %203, align 8
  %205 = getelementptr i8, ptr %203, i64 8
  %206 = icmp ne ptr %204, @nil_typ
  %207 = icmp ne ptr %204, null
  %.not64.i = and i1 %206, %207
  br i1 %.not64.i, label %208, label %306

208:                                              ; preds = %191
  %209 = load i64, ptr %205, align 4
  %.sroa_idx.i1415 = getelementptr i8, ptr %203, i64 16
  %210 = load i64, ptr %.sroa_idx.i1415, align 4
  %211 = inttoptr i64 %209 to ptr
  %212 = inttoptr i64 %210 to ptr
  %hash_coef_ptr.i.i66.i = getelementptr i8, ptr %204, i64 8
  %tbl_size_ptr.i.i67.i = getelementptr i8, ptr %204, i64 16
  %offset_tbl_ptr.i.i68.i = getelementptr i8, ptr %204, i64 40
  %hash_coef.i.i69.i = load i64, ptr %hash_coef_ptr.i.i66.i, align 4, !noalias !329
  %tbl_size.i.i70.i = load i64, ptr %tbl_size_ptr.i.i67.i, align 4, !noalias !329
  %offset_tbl.i.i71.i = load ptr, ptr %offset_tbl_ptr.i.i68.i, align 8, !noalias !329
  %product.i.i.i72.i = mul i64 %hash_coef.i.i69.i, 4015701072841558310
  %shifted.i.i.i73.i = lshr i64 %product.i.i.i72.i, 32
  %xored.i.i.i74.i = xor i64 %shifted.i.i.i73.i, %product.i.i.i72.i
  %hash.i.i.i75.i = and i64 %xored.i.i.i74.i, %tbl_size.i.i70.i
  %offset_ptr.i.i76.i = getelementptr i32, ptr %offset_tbl.i.i71.i, i64 %hash.i.i.i75.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i76.i, align 4, !noalias !329
  %213 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %204, 0
  %214 = insertvalue { ptr, ptr, ptr, i32 } %213, ptr %211, 1
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %212, 2
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, i32 %offset.i.i77.i, 3
  %217 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %218 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %204) #35
  %219 = sext i32 %offset.i.i77.i to i64
  %220 = getelementptr ptr, ptr %204, i64 %219
  %221 = getelementptr i8, ptr %220, i64 64
  %222 = load ptr, ptr %221, align 8
  %result.i.i1416 = call ptr %222({ ptr, ptr, ptr, i32 } %216, ptr nocapture nofree noundef nonnull readonly %2) #16
  %223 = call i32 %result.i.i1416({ ptr, ptr, ptr, i32 } %216, { ptr, ptr, ptr, i32 } %216, ptr nonnull align 8 %2) #7
  %224 = icmp eq i32 %223, %195
  br i1 %224, label %._crit_edge.i1417, label %306

._crit_edge.i1417:                                ; preds = %208
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %226 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %204)
  %227 = getelementptr i8, ptr %220, i64 48
  %228 = load ptr, ptr %227, align 8
  %result.i79.i1418 = call ptr %228({ ptr, ptr, ptr, i32 } %216, ptr nocapture nofree noundef nonnull readonly %2) #16
  %229 = call { ptr, i160 } %result.i79.i1418({ ptr, ptr, ptr, i32 } %216, { ptr, ptr, ptr, i32 } %216, ptr nonnull align 8 %2) #7
  %230 = load ptr, ptr %41, align 8
  %231 = call i1 %230({ ptr, i160 } %229, { ptr, i160 } %73) #7
  br i1 %231, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %306

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i1417
  %232 = load ptr, ptr %result.i378, align 8
  %233 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %234 = load ptr, ptr %35, align 8
  %235 = load ptr, ptr %232, align 8, !alias.scope !332
  %236 = getelementptr i8, ptr %235, i64 72
  %237 = load ptr, ptr %236, align 8, !alias.scope !332
  %result.i.i.i1419 = call { i64, i64 } %237(ptr nocapture nofree nonnull readonly %232) #5, !alias.scope !332
  %238 = extractvalue { i64, i64 } %result.i.i.i1419, 0
  %239 = extractvalue { i64, i64 } %result.i.i.i1419, 1
  %240 = urem i64 20, %239
  %241 = icmp eq i64 %240, 0
  %242 = sub i64 %239, %240
  %243 = select i1 %241, i64 0, i64 %242
  %244 = add i64 %238, 20
  %245 = add i64 %244, %243
  %246 = load ptr, ptr %234, align 8, !alias.scope !332
  %247 = getelementptr i8, ptr %246, i64 72
  %248 = load ptr, ptr %247, align 8, !alias.scope !332
  %result.i1.i.i1420 = call { i64, i64 } %248(ptr nocapture nofree nonnull readonly %234) #5, !alias.scope !332
  %249 = extractvalue { i64, i64 } %result.i1.i.i1420, 0
  %250 = extractvalue { i64, i64 } %result.i1.i.i1420, 1
  %251 = call i64 @llvm.umax.i64(i64 %239, i64 %250)
  %252 = call i64 @llvm.umax.i64(i64 %251, i64 8)
  %253 = urem i64 %245, %250
  %254 = icmp eq i64 %253, 0
  %255 = sub i64 %250, %253
  %256 = select i1 %254, i64 0, i64 %255
  %257 = add i64 %249, %245
  %258 = add i64 %257, %256
  %259 = urem i64 %258, %252
  %260 = icmp eq i64 %259, 0
  %261 = sub i64 %252, %259
  %262 = select i1 %260, i64 0, i64 %261
  %263 = add i64 %262, %258
  %result.i83.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %263, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %232, ptr %result.i83.i, align 8
  %264 = getelementptr inbounds i8, ptr %result.i83.i, i64 8
  store ptr %234, ptr %264, align 8
  %265 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i)
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %267 = load ptr, ptr %232, align 8
  %268 = getelementptr i8, ptr %267, i64 72
  %269 = load ptr, ptr %268, align 8
  %result.i.i118.i = call { i64, i64 } %269(ptr nocapture nofree nonnull readonly %232) #5
  %270 = extractvalue { i64, i64 } %result.i.i118.i, 1
  %271 = urem i64 20, %270
  %272 = icmp eq i64 %271, 0
  %reass.sub4324 = sub i64 %270, %271
  %273 = add i64 %reass.sub4324, 20
  %274 = select i1 %272, i64 20, i64 %273
  %275 = getelementptr i8, ptr %result.i83.i, i64 %274
  %276 = getelementptr i8, ptr %267, i64 64
  %277 = load ptr, ptr %276, align 8
  call void %277({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %232, ptr nocapture nofree writeonly %275) #1
  %278 = load ptr, ptr %result.i83.i, align 8
  %279 = load ptr, ptr %278, align 8
  %280 = getelementptr i8, ptr %279, i64 72
  %281 = load ptr, ptr %280, align 8
  %result.i.i119.i = call { i64, i64 } %281(ptr nocapture nofree nonnull readonly %278) #5
  %282 = extractvalue { i64, i64 } %result.i.i119.i, 0
  %283 = extractvalue { i64, i64 } %result.i.i119.i, 1
  %284 = urem i64 20, %283
  %285 = icmp eq i64 %284, 0
  %286 = sub i64 %283, %284
  %287 = select i1 %285, i64 0, i64 %286
  %288 = add i64 %282, 20
  %289 = add i64 %288, %287
  %290 = load ptr, ptr %264, align 8
  %291 = load ptr, ptr %290, align 8
  %292 = getelementptr i8, ptr %291, i64 72
  %293 = load ptr, ptr %292, align 8
  %result.i1.i120.i = call { i64, i64 } %293(ptr nocapture nofree nonnull readonly %290) #5
  %294 = extractvalue { i64, i64 } %result.i1.i120.i, 1
  %295 = urem i64 %289, %294
  %296 = icmp eq i64 %295, 0
  %297 = sub i64 %294, %295
  %298 = select i1 %296, i64 0, i64 %297
  %299 = getelementptr i8, ptr %result.i83.i, i64 %289
  %300 = getelementptr i8, ptr %299, i64 %298
  %301 = getelementptr i8, ptr %291, i64 64
  %302 = load ptr, ptr %301, align 8
  call void %302({ ptr, i160 } %193, ptr nocapture nofree nonnull readonly %290, ptr nocapture nofree writeonly %300) #1
  %303 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %304 = getelementptr inbounds i8, ptr %result.i83.i, i64 16
  store i32 %195, ptr %304, align 8
  store ptr @Entry, ptr %203, align 8
  %305 = ptrtoint ptr %result.i83.i to i64
  store i64 %305, ptr %205, align 4
  %.sroa_idx28.i = getelementptr i8, ptr %203, i64 24
  store i32 10, ptr %.sroa_idx28.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

306:                                              ; preds = %._crit_edge.i1417, %191, %208
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %307 = add i32 %195, 2127912214
  %308 = shl i32 %195, 12
  %309 = add i32 %307, %308
  %310 = ashr i32 %309, 19
  %311 = xor i32 %309, %310
  %312 = xor i32 %311, -949894596
  %313 = add i32 %312, 374761393
  %314 = shl i32 %312, 5
  %315 = add i32 %313, %314
  %316 = add i32 %315, -744332180
  %317 = shl i32 %315, 9
  %318 = xor i32 %316, %317
  %319 = add i32 %318, -42973499
  %320 = shl i32 %318, 3
  %321 = add i32 %319, %320
  %322 = ashr i32 %321, 16
  %323 = xor i32 %321, %322
  %324 = xor i32 %323, -1252372727
  %325 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %326 = load i32, ptr %42, align 8
  %327 = add i32 %326, -1
  %328 = and i32 %327, %324
  %329 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %330 = sext i32 %328 to i64
  %331 = shl nsw i64 %330, 5
  %332 = getelementptr i8, ptr %329, i64 %331
  %333 = load ptr, ptr %332, align 8
  %334 = getelementptr i8, ptr %332, i64 8
  %335 = icmp ne ptr %333, @nil_typ
  %336 = icmp ne ptr %333, null
  %.not64.i1450 = and i1 %335, %336
  br i1 %.not64.i1450, label %337, label %436

337:                                              ; preds = %306
  %338 = load i64, ptr %334, align 4
  %.sroa_idx.i1452 = getelementptr i8, ptr %332, i64 16
  %339 = load i64, ptr %.sroa_idx.i1452, align 4
  %340 = inttoptr i64 %338 to ptr
  %341 = inttoptr i64 %339 to ptr
  %hash_coef_ptr.i.i66.i1453 = getelementptr i8, ptr %333, i64 8
  %tbl_size_ptr.i.i67.i1454 = getelementptr i8, ptr %333, i64 16
  %offset_tbl_ptr.i.i68.i1455 = getelementptr i8, ptr %333, i64 40
  %hash_coef.i.i69.i1456 = load i64, ptr %hash_coef_ptr.i.i66.i1453, align 4, !noalias !335
  %tbl_size.i.i70.i1457 = load i64, ptr %tbl_size_ptr.i.i67.i1454, align 4, !noalias !335
  %offset_tbl.i.i71.i1458 = load ptr, ptr %offset_tbl_ptr.i.i68.i1455, align 8, !noalias !335
  %product.i.i.i72.i1459 = mul i64 %hash_coef.i.i69.i1456, 4015701072841558310
  %shifted.i.i.i73.i1460 = lshr i64 %product.i.i.i72.i1459, 32
  %xored.i.i.i74.i1461 = xor i64 %shifted.i.i.i73.i1460, %product.i.i.i72.i1459
  %hash.i.i.i75.i1462 = and i64 %xored.i.i.i74.i1461, %tbl_size.i.i70.i1457
  %offset_ptr.i.i76.i1463 = getelementptr i32, ptr %offset_tbl.i.i71.i1458, i64 %hash.i.i.i75.i1462
  %offset.i.i77.i1464 = load i32, ptr %offset_ptr.i.i76.i1463, align 4, !noalias !335
  %342 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %333, 0
  %343 = insertvalue { ptr, ptr, ptr, i32 } %342, ptr %340, 1
  %344 = insertvalue { ptr, ptr, ptr, i32 } %343, ptr %341, 2
  %345 = insertvalue { ptr, ptr, ptr, i32 } %344, i32 %offset.i.i77.i1464, 3
  %346 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %333) #35
  %348 = sext i32 %offset.i.i77.i1464 to i64
  %349 = getelementptr ptr, ptr %333, i64 %348
  %350 = getelementptr i8, ptr %349, i64 64
  %351 = load ptr, ptr %350, align 8
  %result.i.i1465 = call ptr %351({ ptr, ptr, ptr, i32 } %345, ptr nocapture nofree noundef nonnull readonly %2) #16
  %352 = call i32 %result.i.i1465({ ptr, ptr, ptr, i32 } %345, { ptr, ptr, ptr, i32 } %345, ptr nonnull align 8 %2) #7
  %353 = icmp eq i32 %352, %195
  br i1 %353, label %._crit_edge.i1466, label %436

._crit_edge.i1466:                                ; preds = %337
  %354 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %355 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %333)
  %356 = getelementptr i8, ptr %349, i64 48
  %357 = load ptr, ptr %356, align 8
  %result.i79.i1467 = call ptr %357({ ptr, ptr, ptr, i32 } %345, ptr nocapture nofree noundef nonnull readonly %2) #16
  %358 = call { ptr, i160 } %result.i79.i1467({ ptr, ptr, ptr, i32 } %345, { ptr, ptr, ptr, i32 } %345, ptr nonnull align 8 %2) #7
  %359 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %360 = load ptr, ptr %41, align 8
  %361 = call i1 %360({ ptr, i160 } %358, { ptr, i160 } %73) #7
  br i1 %361, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1479, label %436

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1479: ; preds = %._crit_edge.i1466
  %362 = load ptr, ptr %result.i378, align 8
  %363 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %364 = load ptr, ptr %35, align 8
  %365 = load ptr, ptr %362, align 8, !alias.scope !338
  %366 = getelementptr i8, ptr %365, i64 72
  %367 = load ptr, ptr %366, align 8, !alias.scope !338
  %result.i.i.i1471 = call { i64, i64 } %367(ptr nocapture nofree nonnull readonly %362) #5, !alias.scope !338
  %368 = extractvalue { i64, i64 } %result.i.i.i1471, 0
  %369 = extractvalue { i64, i64 } %result.i.i.i1471, 1
  %370 = urem i64 20, %369
  %371 = icmp eq i64 %370, 0
  %372 = sub i64 %369, %370
  %373 = select i1 %371, i64 0, i64 %372
  %374 = add i64 %368, 20
  %375 = add i64 %374, %373
  %376 = load ptr, ptr %364, align 8, !alias.scope !338
  %377 = getelementptr i8, ptr %376, i64 72
  %378 = load ptr, ptr %377, align 8, !alias.scope !338
  %result.i1.i.i1472 = call { i64, i64 } %378(ptr nocapture nofree nonnull readonly %364) #5, !alias.scope !338
  %379 = extractvalue { i64, i64 } %result.i1.i.i1472, 0
  %380 = extractvalue { i64, i64 } %result.i1.i.i1472, 1
  %381 = call i64 @llvm.umax.i64(i64 %369, i64 %380)
  %382 = call i64 @llvm.umax.i64(i64 %381, i64 8)
  %383 = urem i64 %375, %380
  %384 = icmp eq i64 %383, 0
  %385 = sub i64 %380, %383
  %386 = select i1 %384, i64 0, i64 %385
  %387 = add i64 %379, %375
  %388 = add i64 %387, %386
  %389 = urem i64 %388, %382
  %390 = icmp eq i64 %389, 0
  %391 = sub i64 %382, %389
  %392 = select i1 %390, i64 0, i64 %391
  %393 = add i64 %392, %388
  %result.i83.i1473 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %393, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %362, ptr %result.i83.i1473, align 8
  %394 = getelementptr inbounds i8, ptr %result.i83.i1473, i64 8
  store ptr %364, ptr %394, align 8
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1473)
  %396 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %397 = load ptr, ptr %362, align 8
  %398 = getelementptr i8, ptr %397, i64 72
  %399 = load ptr, ptr %398, align 8
  %result.i.i118.i1474 = call { i64, i64 } %399(ptr nocapture nofree nonnull readonly %362) #5
  %400 = extractvalue { i64, i64 } %result.i.i118.i1474, 1
  %401 = urem i64 20, %400
  %402 = icmp eq i64 %401, 0
  %reass.sub4323 = sub i64 %400, %401
  %403 = add i64 %reass.sub4323, 20
  %404 = select i1 %402, i64 20, i64 %403
  %405 = getelementptr i8, ptr %result.i83.i1473, i64 %404
  %406 = getelementptr i8, ptr %397, i64 64
  %407 = load ptr, ptr %406, align 8
  call void %407({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %362, ptr nocapture nofree writeonly %405) #1
  %408 = load ptr, ptr %result.i83.i1473, align 8
  %409 = load ptr, ptr %408, align 8
  %410 = getelementptr i8, ptr %409, i64 72
  %411 = load ptr, ptr %410, align 8
  %result.i.i119.i1476 = call { i64, i64 } %411(ptr nocapture nofree nonnull readonly %408) #5
  %412 = extractvalue { i64, i64 } %result.i.i119.i1476, 0
  %413 = extractvalue { i64, i64 } %result.i.i119.i1476, 1
  %414 = urem i64 20, %413
  %415 = icmp eq i64 %414, 0
  %416 = sub i64 %413, %414
  %417 = select i1 %415, i64 0, i64 %416
  %418 = add i64 %412, 20
  %419 = add i64 %418, %417
  %420 = load ptr, ptr %394, align 8
  %421 = load ptr, ptr %420, align 8
  %422 = getelementptr i8, ptr %421, i64 72
  %423 = load ptr, ptr %422, align 8
  %result.i1.i120.i1477 = call { i64, i64 } %423(ptr nocapture nofree nonnull readonly %420) #5
  %424 = extractvalue { i64, i64 } %result.i1.i120.i1477, 1
  %425 = urem i64 %419, %424
  %426 = icmp eq i64 %425, 0
  %427 = sub i64 %424, %425
  %428 = select i1 %426, i64 0, i64 %427
  %429 = getelementptr i8, ptr %result.i83.i1473, i64 %419
  %430 = getelementptr i8, ptr %429, i64 %428
  %431 = getelementptr i8, ptr %421, i64 64
  %432 = load ptr, ptr %431, align 8
  call void %432({ ptr, i160 } %193, ptr nocapture nofree nonnull readonly %420, ptr nocapture nofree writeonly %430) #1
  %433 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %434 = getelementptr inbounds i8, ptr %result.i83.i1473, i64 16
  store i32 %195, ptr %434, align 8
  store ptr @Entry, ptr %332, align 8
  %435 = ptrtoint ptr %result.i83.i1473 to i64
  store i64 %435, ptr %334, align 4
  %.sroa_idx28.i1478 = getelementptr i8, ptr %332, i64 24
  store i32 10, ptr %.sroa_idx28.i1478, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit

436:                                              ; preds = %._crit_edge.i1466, %306, %337
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %437 = load i32, ptr %65, align 4
  %438 = load i32, ptr %42, align 8
  %.not.i = icmp slt i32 %437, %438
  br i1 %.not.i, label %._crit_edge.i, label %439

439:                                              ; preds = %436
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %441 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %442 = load ptr, ptr %43, align 8
  %443 = load ptr, ptr %44, align 8
  %444 = shl i32 %438, 1
  %spec.select.i1494 = call i32 @llvm.smax.i32(i32 %444, i32 16)
  store i32 %spec.select.i1494, ptr %42, align 8
  %445 = zext nneg i32 %spec.select.i1494 to i64
  %446 = shl nuw nsw i64 %445, 5
  %result.i.i1495 = call noalias ptr @bump_malloc_inner(i64 noundef %446, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1495, ptr %43, align 8
  %result.i20.i = call noalias ptr @bump_malloc_inner(i64 noundef %446, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %447 = icmp sgt i32 %438, 0
  br i1 %447, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %439, %._crit_edge.i2470
  %.060.i = phi i32 [ %536, %._crit_edge.i2470 ], [ 0, %439 ]
  %448 = zext nneg i32 %.060.i to i64
  %449 = shl nuw nsw i64 %448, 5
  %450 = getelementptr i8, ptr %442, i64 %449
  %451 = load ptr, ptr %450, align 8
  %452 = icmp ne ptr %451, @nil_typ
  %453 = icmp ne ptr %451, null
  %.not16.i = and i1 %452, %453
  br i1 %.not16.i, label %454, label %._crit_edge.i2470

454:                                              ; preds = %.lr.ph.i
  %455 = getelementptr i8, ptr %450, i64 8
  %456 = load <2 x i64>, ptr %455, align 4
  %hash_coef_ptr.i.i18.i = getelementptr i8, ptr %451, i64 8
  %tbl_size_ptr.i.i19.i = getelementptr i8, ptr %451, i64 16
  %offset_tbl_ptr.i.i20.i = getelementptr i8, ptr %451, i64 40
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %26)
  %hash_coef.i.i99.i = load i64, ptr %hash_coef_ptr.i.i18.i, align 4, !noalias !22
  %tbl_size.i.i100.i = load i64, ptr %tbl_size_ptr.i.i19.i, align 4, !noalias !22
  %offset_tbl.i.i101.i = load ptr, ptr %offset_tbl_ptr.i.i20.i, align 8, !noalias !22
  %product.i.i.i102.i = mul i64 %hash_coef.i.i99.i, 4015701072841558310
  %shifted.i.i.i103.i = lshr i64 %product.i.i.i102.i, 32
  %xored.i.i.i104.i = xor i64 %shifted.i.i.i103.i, %product.i.i.i102.i
  %hash.i.i.i105.i = and i64 %xored.i.i.i104.i, %tbl_size.i.i100.i
  %offset_ptr.i.i106.i = getelementptr i32, ptr %offset_tbl.i.i101.i, i64 %hash.i.i.i105.i
  %offset.i.i121.i = load i32, ptr %offset_ptr.i.i106.i, align 4, !noalias !341
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %459 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %461

461:                                              ; preds = %.cont.cont.i3013, %454
  %.0566.i3001 = phi i32 [ 0, %454 ], [ %465, %.cont.cont.i3013 ]
  %.070565.i3002 = phi i1 [ true, %454 ], [ %527, %.cont.cont.i3013 ]
  %.sroa.0.0564.i3003 = phi ptr [ %451, %454 ], [ %vptr.i142.sroa.speculated.i3016, %.cont.cont.i3013 ]
  %.sroa.17.0561.i3006 = phi i32 [ %offset.i.i121.i, %454 ], [ %offset.i.i154.i3030, %.cont.cont.i3013 ]
  %462 = phi <2 x i64> [ %456, %454 ], [ %526, %.cont.cont.i3013 ]
  %463 = extractelement <2 x i64> %462, i64 1
  %.sroa.12.0562.i3005 = inttoptr i64 %463 to ptr
  %464 = extractelement <2 x i64> %462, i64 0
  %.sroa.6.0563.i3004 = inttoptr i64 %464 to ptr
  %465 = add nuw nsw i32 %.0566.i3001, 1
  %466 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3003, 0
  %467 = insertvalue { ptr, ptr, ptr, i32 } %466, ptr %.sroa.6.0563.i3004, 1
  %468 = insertvalue { ptr, ptr, ptr, i32 } %467, ptr %.sroa.12.0562.i3005, 2
  %469 = insertvalue { ptr, ptr, ptr, i32 } %468, i32 %.sroa.17.0561.i3006, 3
  %470 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3003)
  %471 = sext i32 %.sroa.17.0561.i3006 to i64
  %472 = getelementptr ptr, ptr %.sroa.0.0564.i3003, i64 %471
  %473 = getelementptr i8, ptr %472, i64 64
  %474 = load ptr, ptr %473, align 8
  %result.i125.i = call ptr %474({ ptr, ptr, ptr, i32 } %469, ptr nocapture nofree noundef nonnull readonly %2) #16
  %475 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %469, { ptr, ptr, ptr, i32 } %469, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3002, label %476, label %492

476:                                              ; preds = %461
  %477 = load i32, ptr %42, align 8
  %478 = add i32 %477, -1
  %479 = and i32 %478, %475
  %480 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %481 = load ptr, ptr %43, align 8
  %482 = sext i32 %479 to i64
  %483 = shl nsw i64 %482, 5
  %484 = getelementptr i8, ptr %481, i64 %483
  %485 = load ptr, ptr %484, align 8
  %486 = getelementptr i8, ptr %484, i64 8
  %487 = load i160, ptr %486, align 4
  store ptr %.sroa.0.0564.i3003, ptr %484, align 8
  store i64 %464, ptr %486, align 4
  %.sroa_idx157.i3032 = getelementptr i8, ptr %484, i64 16
  store i64 %463, ptr %.sroa_idx157.i3032, align 4
  %.sroa_idx158.i3033 = getelementptr i8, ptr %484, i64 24
  store i32 %.sroa.17.0561.i3006, ptr %.sroa_idx158.i3033, align 4
  %488 = icmp ne ptr %485, @nil_typ
  %489 = icmp ne ptr %485, null
  %.not92.i3034 = and i1 %488, %489
  %extract.i3036 = lshr i160 %487, 64
  %490 = insertelement <2 x i160> poison, i160 %487, i64 0
  %491 = insertelement <2 x i160> %490, i160 %extract.i3036, i64 1
  br i1 %.not92.i3034, label %.cont.cont.i3013, label %531

492:                                              ; preds = %461
  %493 = add i32 %475, 2127912214
  %494 = shl i32 %475, 12
  %495 = add i32 %493, %494
  %496 = ashr i32 %495, 19
  %497 = xor i32 %495, %496
  %498 = xor i32 %497, -949894596
  %499 = add i32 %498, 374761393
  %500 = shl i32 %498, 5
  %501 = add i32 %499, %500
  %502 = add i32 %501, -744332180
  %503 = shl i32 %501, 9
  %504 = xor i32 %502, %503
  %505 = add i32 %504, -42973499
  %506 = shl i32 %504, 3
  %507 = add i32 %505, %506
  %508 = ashr i32 %507, 16
  %509 = xor i32 %507, %508
  %510 = xor i32 %509, -1252372727
  %511 = load i32, ptr %42, align 8
  %512 = add i32 %511, -1
  %513 = and i32 %512, %510
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %515 = load ptr, ptr %44, align 8
  %516 = sext i32 %513 to i64
  %517 = shl nsw i64 %516, 5
  %518 = getelementptr i8, ptr %515, i64 %517
  %519 = load ptr, ptr %518, align 8
  %520 = getelementptr i8, ptr %518, i64 8
  %521 = load i160, ptr %520, align 4
  store ptr %.sroa.0.0564.i3003, ptr %518, align 8
  store i64 %464, ptr %520, align 4
  %.sroa_idx161.i3007 = getelementptr i8, ptr %518, i64 16
  store i64 %463, ptr %.sroa_idx161.i3007, align 4
  %.sroa_idx162.i3008 = getelementptr i8, ptr %518, i64 24
  store i32 %.sroa.17.0561.i3006, ptr %.sroa_idx162.i3008, align 4
  %522 = icmp ne ptr %519, @nil_typ
  %523 = icmp ne ptr %519, null
  %.not90.i3009 = and i1 %522, %523
  %extract607.i3011 = lshr i160 %521, 64
  %524 = insertelement <2 x i160> poison, i160 %521, i64 0
  %525 = insertelement <2 x i160> %524, i160 %extract607.i3011, i64 1
  br i1 %.not90.i3009, label %.cont.cont.i3013, label %531

.cont.cont.i3013:                                 ; preds = %492, %476
  %vptr.i142.sroa.speculated.i3016 = phi ptr [ %485, %476 ], [ %519, %492 ]
  %.in = phi <2 x i160> [ %491, %476 ], [ %525, %492 ]
  %526 = trunc <2 x i160> %.in to <2 x i64>
  %527 = xor i1 %.070565.i3002, true
  %hash_coef_ptr.i.i143.i3019 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3016, i64 8
  %tbl_size_ptr.i.i144.i3020 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3016, i64 16
  %offset_tbl_ptr.i.i145.i3021 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3016, i64 40
  %hash_coef.i.i146.i3022 = load i64, ptr %hash_coef_ptr.i.i143.i3019, align 4
  %tbl_size.i.i147.i3023 = load i64, ptr %tbl_size_ptr.i.i144.i3020, align 4
  %offset_tbl.i.i148.i3024 = load ptr, ptr %offset_tbl_ptr.i.i145.i3021, align 8
  %product.i.i.i149.i3025 = mul i64 %hash_coef.i.i146.i3022, 4015701072841558310
  %shifted.i.i.i150.i3026 = lshr i64 %product.i.i.i149.i3025, 32
  %xored.i.i.i151.i3027 = xor i64 %shifted.i.i.i150.i3026, %product.i.i.i149.i3025
  %hash.i.i.i152.i3028 = and i64 %xored.i.i.i151.i3027, %tbl_size.i.i147.i3023
  %offset_ptr.i.i153.i3029 = getelementptr i32, ptr %offset_tbl.i.i148.i3024, i64 %hash.i.i.i152.i3028
  %offset.i.i154.i3030 = load i32, ptr %offset_ptr.i.i153.i3029, align 4
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %529 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %530 = icmp ult i32 %.0566.i3001, 99
  br i1 %530, label %461, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3038

531:                                              ; preds = %492, %476
  %532 = phi ptr [ %26, %492 ], [ %25, %476 ]
  %533 = load i32, ptr %65, align 4
  store i32 %533, ptr %532, align 4
  %534 = add i32 %533, 1
  %535 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %534, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3038

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3038: ; preds = %.cont.cont.i3013, %531
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %25)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %26)
  br label %._crit_edge.i2470

._crit_edge.i2470:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3038, %.lr.ph.i
  %536 = add nuw nsw i32 %.060.i, 1
  %537 = icmp slt i32 %536, %438
  br i1 %537, label %.lr.ph.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit: ; preds = %._crit_edge.i2470, %._crit_edge.i2489
  %.060.i2487 = phi i32 [ %626, %._crit_edge.i2489 ], [ 0, %._crit_edge.i2470 ]
  %538 = zext nneg i32 %.060.i2487 to i64
  %539 = shl nuw nsw i64 %538, 5
  %540 = getelementptr i8, ptr %443, i64 %539
  %541 = load ptr, ptr %540, align 8
  %542 = icmp ne ptr %541, @nil_typ
  %543 = icmp ne ptr %541, null
  %.not16.i2488 = and i1 %542, %543
  br i1 %.not16.i2488, label %544, label %._crit_edge.i2489

544:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %545 = getelementptr i8, ptr %540, i64 8
  %546 = load <2 x i64>, ptr %545, align 4
  %hash_coef_ptr.i.i18.i2491 = getelementptr i8, ptr %541, i64 8
  %tbl_size_ptr.i.i19.i2492 = getelementptr i8, ptr %541, i64 16
  %offset_tbl_ptr.i.i20.i2493 = getelementptr i8, ptr %541, i64 40
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %hash_coef.i.i99.i3056 = load i64, ptr %hash_coef_ptr.i.i18.i2491, align 4, !noalias !22
  %tbl_size.i.i100.i3057 = load i64, ptr %tbl_size_ptr.i.i19.i2492, align 4, !noalias !22
  %offset_tbl.i.i101.i3058 = load ptr, ptr %offset_tbl_ptr.i.i20.i2493, align 8, !noalias !22
  %product.i.i.i102.i3059 = mul i64 %hash_coef.i.i99.i3056, 4015701072841558310
  %shifted.i.i.i103.i3060 = lshr i64 %product.i.i.i102.i3059, 32
  %xored.i.i.i104.i3061 = xor i64 %shifted.i.i.i103.i3060, %product.i.i.i102.i3059
  %hash.i.i.i105.i3062 = and i64 %xored.i.i.i104.i3061, %tbl_size.i.i100.i3057
  %offset_ptr.i.i106.i3063 = getelementptr i32, ptr %offset_tbl.i.i101.i3058, i64 %hash.i.i.i105.i3062
  %offset.i.i121.i3064 = load i32, ptr %offset_ptr.i.i106.i3063, align 4, !noalias !344
  %548 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %550 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %551

551:                                              ; preds = %.cont.cont.i3085, %544
  %.0566.i3065 = phi i32 [ 0, %544 ], [ %555, %.cont.cont.i3085 ]
  %.070565.i3066 = phi i1 [ true, %544 ], [ %617, %.cont.cont.i3085 ]
  %.sroa.0.0564.i3067 = phi ptr [ %541, %544 ], [ %vptr.i142.sroa.speculated.i3088, %.cont.cont.i3085 ]
  %.sroa.17.0561.i3070 = phi i32 [ %offset.i.i121.i3064, %544 ], [ %offset.i.i154.i3102, %.cont.cont.i3085 ]
  %552 = phi <2 x i64> [ %546, %544 ], [ %616, %.cont.cont.i3085 ]
  %553 = extractelement <2 x i64> %552, i64 1
  %.sroa.12.0562.i3069 = inttoptr i64 %553 to ptr
  %554 = extractelement <2 x i64> %552, i64 0
  %.sroa.6.0563.i3068 = inttoptr i64 %554 to ptr
  %555 = add nuw nsw i32 %.0566.i3065, 1
  %556 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3067, 0
  %557 = insertvalue { ptr, ptr, ptr, i32 } %556, ptr %.sroa.6.0563.i3068, 1
  %558 = insertvalue { ptr, ptr, ptr, i32 } %557, ptr %.sroa.12.0562.i3069, 2
  %559 = insertvalue { ptr, ptr, ptr, i32 } %558, i32 %.sroa.17.0561.i3070, 3
  %560 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3067)
  %561 = sext i32 %.sroa.17.0561.i3070 to i64
  %562 = getelementptr ptr, ptr %.sroa.0.0564.i3067, i64 %561
  %563 = getelementptr i8, ptr %562, i64 64
  %564 = load ptr, ptr %563, align 8
  %result.i125.i3071 = call ptr %564({ ptr, ptr, ptr, i32 } %559, ptr nocapture nofree noundef nonnull readonly %2) #16
  %565 = call i32 %result.i125.i3071({ ptr, ptr, ptr, i32 } %559, { ptr, ptr, ptr, i32 } %559, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3066, label %566, label %582

566:                                              ; preds = %551
  %567 = load i32, ptr %42, align 8
  %568 = add i32 %567, -1
  %569 = and i32 %568, %565
  %570 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %571 = load ptr, ptr %43, align 8
  %572 = sext i32 %569 to i64
  %573 = shl nsw i64 %572, 5
  %574 = getelementptr i8, ptr %571, i64 %573
  %575 = load ptr, ptr %574, align 8
  %576 = getelementptr i8, ptr %574, i64 8
  %577 = load i160, ptr %576, align 4
  store ptr %.sroa.0.0564.i3067, ptr %574, align 8
  store i64 %554, ptr %576, align 4
  %.sroa_idx157.i3114 = getelementptr i8, ptr %574, i64 16
  store i64 %553, ptr %.sroa_idx157.i3114, align 4
  %.sroa_idx158.i3115 = getelementptr i8, ptr %574, i64 24
  store i32 %.sroa.17.0561.i3070, ptr %.sroa_idx158.i3115, align 4
  %578 = icmp ne ptr %575, @nil_typ
  %579 = icmp ne ptr %575, null
  %.not92.i3116 = and i1 %578, %579
  %extract.i3118 = lshr i160 %577, 64
  %580 = insertelement <2 x i160> poison, i160 %577, i64 0
  %581 = insertelement <2 x i160> %580, i160 %extract.i3118, i64 1
  br i1 %.not92.i3116, label %.cont.cont.i3085, label %621

582:                                              ; preds = %551
  %583 = add i32 %565, 2127912214
  %584 = shl i32 %565, 12
  %585 = add i32 %583, %584
  %586 = ashr i32 %585, 19
  %587 = xor i32 %585, %586
  %588 = xor i32 %587, -949894596
  %589 = add i32 %588, 374761393
  %590 = shl i32 %588, 5
  %591 = add i32 %589, %590
  %592 = add i32 %591, -744332180
  %593 = shl i32 %591, 9
  %594 = xor i32 %592, %593
  %595 = add i32 %594, -42973499
  %596 = shl i32 %594, 3
  %597 = add i32 %595, %596
  %598 = ashr i32 %597, 16
  %599 = xor i32 %597, %598
  %600 = xor i32 %599, -1252372727
  %601 = load i32, ptr %42, align 8
  %602 = add i32 %601, -1
  %603 = and i32 %602, %600
  %604 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %605 = load ptr, ptr %44, align 8
  %606 = sext i32 %603 to i64
  %607 = shl nsw i64 %606, 5
  %608 = getelementptr i8, ptr %605, i64 %607
  %609 = load ptr, ptr %608, align 8
  %610 = getelementptr i8, ptr %608, i64 8
  %611 = load i160, ptr %610, align 4
  store ptr %.sroa.0.0564.i3067, ptr %608, align 8
  store i64 %554, ptr %610, align 4
  %.sroa_idx161.i3075 = getelementptr i8, ptr %608, i64 16
  store i64 %553, ptr %.sroa_idx161.i3075, align 4
  %.sroa_idx162.i3076 = getelementptr i8, ptr %608, i64 24
  store i32 %.sroa.17.0561.i3070, ptr %.sroa_idx162.i3076, align 4
  %612 = icmp ne ptr %609, @nil_typ
  %613 = icmp ne ptr %609, null
  %.not90.i3077 = and i1 %612, %613
  %extract607.i3079 = lshr i160 %611, 64
  %614 = insertelement <2 x i160> poison, i160 %611, i64 0
  %615 = insertelement <2 x i160> %614, i160 %extract607.i3079, i64 1
  br i1 %.not90.i3077, label %.cont.cont.i3085, label %621

.cont.cont.i3085:                                 ; preds = %582, %566
  %vptr.i142.sroa.speculated.i3088 = phi ptr [ %575, %566 ], [ %609, %582 ]
  %.in4327 = phi <2 x i160> [ %581, %566 ], [ %615, %582 ]
  %616 = trunc <2 x i160> %.in4327 to <2 x i64>
  %617 = xor i1 %.070565.i3066, true
  %hash_coef_ptr.i.i143.i3091 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3088, i64 8
  %tbl_size_ptr.i.i144.i3092 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3088, i64 16
  %offset_tbl_ptr.i.i145.i3093 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3088, i64 40
  %hash_coef.i.i146.i3094 = load i64, ptr %hash_coef_ptr.i.i143.i3091, align 4
  %tbl_size.i.i147.i3095 = load i64, ptr %tbl_size_ptr.i.i144.i3092, align 4
  %offset_tbl.i.i148.i3096 = load ptr, ptr %offset_tbl_ptr.i.i145.i3093, align 8
  %product.i.i.i149.i3097 = mul i64 %hash_coef.i.i146.i3094, 4015701072841558310
  %shifted.i.i.i150.i3098 = lshr i64 %product.i.i.i149.i3097, 32
  %xored.i.i.i151.i3099 = xor i64 %shifted.i.i.i150.i3098, %product.i.i.i149.i3097
  %hash.i.i.i152.i3100 = and i64 %xored.i.i.i151.i3099, %tbl_size.i.i147.i3095
  %offset_ptr.i.i153.i3101 = getelementptr i32, ptr %offset_tbl.i.i148.i3096, i64 %hash.i.i.i152.i3100
  %offset.i.i154.i3102 = load i32, ptr %offset_ptr.i.i153.i3101, align 4
  %618 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %619 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %620 = icmp ult i32 %.0566.i3065, 99
  br i1 %620, label %551, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3120

621:                                              ; preds = %582, %566
  %622 = phi ptr [ %24, %582 ], [ %23, %566 ]
  %623 = load i32, ptr %65, align 4
  store i32 %623, ptr %622, align 4
  %624 = add i32 %623, 1
  %625 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %624, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3120

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3120: ; preds = %.cont.cont.i3085, %621
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %._crit_edge.i2489

._crit_edge.i2489:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3120, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit
  %626 = add nuw nsw i32 %.060.i2487, 1
  %627 = icmp slt i32 %626, %438
  br i1 %627, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit, label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i2489, %439, %436
  %628 = load ptr, ptr %result.i378, align 8
  %629 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %630 = load ptr, ptr %35, align 8
  %631 = load ptr, ptr %628, align 8
  %632 = getelementptr i8, ptr %631, i64 72
  %633 = load ptr, ptr %632, align 8
  %result.i.i.i = call { i64, i64 } %633(ptr nocapture nofree nonnull readonly %628) #5
  %634 = extractvalue { i64, i64 } %result.i.i.i, 0
  %635 = extractvalue { i64, i64 } %result.i.i.i, 1
  %636 = urem i64 20, %635
  %637 = icmp eq i64 %636, 0
  %638 = sub i64 %635, %636
  %639 = select i1 %637, i64 0, i64 %638
  %640 = add i64 %634, 20
  %641 = add i64 %640, %639
  %642 = load ptr, ptr %630, align 8
  %643 = getelementptr i8, ptr %642, i64 72
  %644 = load ptr, ptr %643, align 8
  %result.i1.i.i = call { i64, i64 } %644(ptr nocapture nofree nonnull readonly %630) #5
  %645 = extractvalue { i64, i64 } %result.i1.i.i, 0
  %646 = extractvalue { i64, i64 } %result.i1.i.i, 1
  %647 = call i64 @llvm.umax.i64(i64 %635, i64 %646)
  %648 = call i64 @llvm.umax.i64(i64 %647, i64 8)
  %649 = urem i64 %641, %646
  %650 = icmp eq i64 %649, 0
  %651 = sub i64 %646, %649
  %652 = select i1 %650, i64 0, i64 %651
  %653 = add i64 %645, %641
  %654 = add i64 %653, %652
  %655 = urem i64 %654, %648
  %656 = icmp eq i64 %655, 0
  %657 = sub i64 %648, %655
  %658 = select i1 %656, i64 0, i64 %657
  %659 = add i64 %658, %654
  %result.i90.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %659, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %628, ptr %result.i90.i, align 8
  %660 = getelementptr inbounds i8, ptr %result.i90.i, i64 8
  store ptr %630, ptr %660, align 8
  %661 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i)
  %662 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %663 = load ptr, ptr %628, align 8
  %664 = getelementptr i8, ptr %663, i64 72
  %665 = load ptr, ptr %664, align 8
  %result.i.i196.i = call { i64, i64 } %665(ptr nocapture nofree nonnull readonly %628) #5
  %666 = extractvalue { i64, i64 } %result.i.i196.i, 1
  %667 = urem i64 20, %666
  %668 = icmp eq i64 %667, 0
  %reass.sub4322 = sub i64 %666, %667
  %669 = add i64 %reass.sub4322, 20
  %670 = select i1 %668, i64 20, i64 %669
  %671 = getelementptr i8, ptr %result.i90.i, i64 %670
  %672 = getelementptr i8, ptr %663, i64 64
  %673 = load ptr, ptr %672, align 8
  call void %673({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %628, ptr nocapture nofree writeonly %671) #1
  %674 = load ptr, ptr %result.i90.i, align 8
  %675 = load ptr, ptr %674, align 8
  %676 = getelementptr i8, ptr %675, i64 72
  %677 = load ptr, ptr %676, align 8
  %result.i.i197.i = call { i64, i64 } %677(ptr nocapture nofree nonnull readonly %674) #5
  %678 = extractvalue { i64, i64 } %result.i.i197.i, 0
  %679 = extractvalue { i64, i64 } %result.i.i197.i, 1
  %680 = urem i64 20, %679
  %681 = icmp eq i64 %680, 0
  %682 = sub i64 %679, %680
  %683 = select i1 %681, i64 0, i64 %682
  %684 = add i64 %678, 20
  %685 = add i64 %684, %683
  %686 = load ptr, ptr %660, align 8
  %687 = load ptr, ptr %686, align 8
  %688 = getelementptr i8, ptr %687, i64 72
  %689 = load ptr, ptr %688, align 8
  %result.i1.i198.i = call { i64, i64 } %689(ptr nocapture nofree nonnull readonly %686) #5
  %690 = extractvalue { i64, i64 } %result.i1.i198.i, 1
  %691 = urem i64 %685, %690
  %692 = icmp eq i64 %691, 0
  %693 = sub i64 %690, %691
  %694 = select i1 %692, i64 0, i64 %693
  %695 = getelementptr i8, ptr %result.i90.i, i64 %685
  %696 = getelementptr i8, ptr %695, i64 %694
  %697 = getelementptr i8, ptr %687, i64 64
  %698 = load ptr, ptr %697, align 8
  call void %698({ ptr, i160 } %193, ptr nocapture nofree nonnull readonly %686, ptr nocapture nofree writeonly %696) #1
  %699 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %700 = getelementptr inbounds i8, ptr %result.i90.i, i64 16
  store i32 %195, ptr %700, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %34)
  %701 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %702 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %703 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %704

704:                                              ; preds = %.cont.cont.i, %._crit_edge.i
  %.0566.i = phi i32 [ 0, %._crit_edge.i ], [ %705, %.cont.cont.i ]
  %.070565.i = phi i1 [ true, %._crit_edge.i ], [ %771, %.cont.cont.i ]
  %.sroa.0.0564.i = phi ptr [ @Entry, %._crit_edge.i ], [ %vptr.i142.sroa.speculated.i, %.cont.cont.i ]
  %.sroa.6.0563.i = phi ptr [ %result.i90.i, %._crit_edge.i ], [ %spec.select539.i, %.cont.cont.i ]
  %.sroa.12.0562.i = phi ptr [ undef, %._crit_edge.i ], [ %spec.select.i1512, %.cont.cont.i ]
  %.sroa.17.0561.i = phi i32 [ 10, %._crit_edge.i ], [ %offset.i.i154.i, %.cont.cont.i ]
  %705 = add nuw nsw i32 %.0566.i, 1
  %706 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i, 0
  %707 = insertvalue { ptr, ptr, ptr, i32 } %706, ptr %.sroa.6.0563.i, 1
  %708 = insertvalue { ptr, ptr, ptr, i32 } %707, ptr %.sroa.12.0562.i, 2
  %709 = insertvalue { ptr, ptr, ptr, i32 } %708, i32 %.sroa.17.0561.i, 3
  %710 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i)
  %711 = sext i32 %.sroa.17.0561.i to i64
  %712 = getelementptr ptr, ptr %.sroa.0.0564.i, i64 %711
  %713 = getelementptr i8, ptr %712, i64 64
  %714 = load ptr, ptr %713, align 8
  %result.i125.i1510 = call ptr %714({ ptr, ptr, ptr, i32 } %709, ptr nocapture nofree noundef nonnull readonly %2) #16
  %715 = call i32 %result.i125.i1510({ ptr, ptr, ptr, i32 } %709, { ptr, ptr, ptr, i32 } %709, ptr nonnull align 8 %2) #7
  %716 = ptrtoint ptr %.sroa.6.0563.i to i64
  %717 = ptrtoint ptr %.sroa.12.0562.i to i64
  br i1 %.070565.i, label %718, label %734

718:                                              ; preds = %704
  %719 = load i32, ptr %42, align 8
  %720 = add i32 %719, -1
  %721 = and i32 %720, %715
  %722 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %723 = load ptr, ptr %43, align 8
  %724 = sext i32 %721 to i64
  %725 = shl nsw i64 %724, 5
  %726 = getelementptr i8, ptr %723, i64 %725
  %727 = load ptr, ptr %726, align 8
  %728 = getelementptr i8, ptr %726, i64 8
  %729 = load i160, ptr %728, align 4
  store ptr %.sroa.0.0564.i, ptr %726, align 8
  store i64 %716, ptr %728, align 4
  %.sroa_idx157.i = getelementptr i8, ptr %726, i64 16
  store i64 %717, ptr %.sroa_idx157.i, align 4
  %.sroa_idx158.i = getelementptr i8, ptr %726, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx158.i, align 4
  %730 = icmp ne ptr %727, @nil_typ
  %731 = icmp ne ptr %727, null
  %.not92.i = and i1 %730, %731
  %extract.i = lshr i160 %729, 64
  %732 = insertelement <2 x i160> poison, i160 %729, i64 0
  %733 = insertelement <2 x i160> %732, i160 %extract.i, i64 1
  br i1 %.not92.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

734:                                              ; preds = %704
  %735 = add i32 %715, 2127912214
  %736 = shl i32 %715, 12
  %737 = add i32 %735, %736
  %738 = ashr i32 %737, 19
  %739 = xor i32 %737, %738
  %740 = xor i32 %739, -949894596
  %741 = add i32 %740, 374761393
  %742 = shl i32 %740, 5
  %743 = add i32 %741, %742
  %744 = add i32 %743, -744332180
  %745 = shl i32 %743, 9
  %746 = xor i32 %744, %745
  %747 = add i32 %746, -42973499
  %748 = shl i32 %746, 3
  %749 = add i32 %747, %748
  %750 = ashr i32 %749, 16
  %751 = xor i32 %749, %750
  %752 = xor i32 %751, -1252372727
  %753 = load i32, ptr %42, align 8
  %754 = add i32 %753, -1
  %755 = and i32 %754, %752
  %756 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %757 = load ptr, ptr %44, align 8
  %758 = sext i32 %755 to i64
  %759 = shl nsw i64 %758, 5
  %760 = getelementptr i8, ptr %757, i64 %759
  %761 = load ptr, ptr %760, align 8
  %762 = getelementptr i8, ptr %760, i64 8
  %763 = load i160, ptr %762, align 4
  store ptr %.sroa.0.0564.i, ptr %760, align 8
  store i64 %716, ptr %762, align 4
  %.sroa_idx161.i = getelementptr i8, ptr %760, i64 16
  store i64 %717, ptr %.sroa_idx161.i, align 4
  %.sroa_idx162.i = getelementptr i8, ptr %760, i64 24
  store i32 %.sroa.17.0561.i, ptr %.sroa_idx162.i, align 4
  %764 = icmp ne ptr %761, @nil_typ
  %765 = icmp ne ptr %761, null
  %.not90.i = and i1 %764, %765
  %extract607.i = lshr i160 %763, 64
  %766 = insertelement <2 x i160> poison, i160 %763, i64 0
  %767 = insertelement <2 x i160> %766, i160 %extract607.i, i64 1
  br i1 %.not90.i, label %.cont.cont.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread

.cont.cont.i:                                     ; preds = %734, %718
  %vptr.i142.sroa.speculated.i = phi ptr [ %727, %718 ], [ %761, %734 ]
  %.in4328 = phi <2 x i160> [ %733, %718 ], [ %767, %734 ]
  %768 = trunc <2 x i160> %.in4328 to <2 x i64>
  %769 = extractelement <2 x i64> %768, i64 1
  %spec.select.i1512 = inttoptr i64 %769 to ptr
  %770 = extractelement <2 x i64> %768, i64 0
  %spec.select539.i = inttoptr i64 %770 to ptr
  %771 = xor i1 %.070565.i, true
  %hash_coef_ptr.i.i143.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 8
  %tbl_size_ptr.i.i144.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 16
  %offset_tbl_ptr.i.i145.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i, i64 40
  %hash_coef.i.i146.i = load i64, ptr %hash_coef_ptr.i.i143.i, align 4
  %tbl_size.i.i147.i = load i64, ptr %tbl_size_ptr.i.i144.i, align 4
  %offset_tbl.i.i148.i = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8
  %product.i.i.i149.i = mul i64 %hash_coef.i.i146.i, 4015701072841558310
  %shifted.i.i.i150.i = lshr i64 %product.i.i.i149.i, 32
  %xored.i.i.i151.i = xor i64 %shifted.i.i.i150.i, %product.i.i.i149.i
  %hash.i.i.i152.i = and i64 %xored.i.i.i151.i, %tbl_size.i.i147.i
  %offset_ptr.i.i153.i = getelementptr i32, ptr %offset_tbl.i.i148.i, i64 %hash.i.i.i152.i
  %offset.i.i154.i = load i32, ptr %offset_ptr.i.i153.i, align 4
  %772 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %774 = icmp ult i32 %.0566.i, 99
  br i1 %774, label %704, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread: ; preds = %718, %734
  %775 = phi ptr [ %34, %734 ], [ %33, %718 ]
  %776 = load i32, ptr %65, align 4
  store i32 %776, ptr %775, align 4
  %777 = add i32 %776, 1
  %778 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %777, ptr %65, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit: ; preds = %.cont.cont.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %34)
  %779 = icmp eq ptr %vptr.i142.sroa.speculated.i, null
  br i1 %779, label %CuckooMap_insert_keyK_valueV.exit, label %780

780:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit
  %781 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %782 = load ptr, ptr %43, align 8
  %783 = load ptr, ptr %44, align 8
  %784 = load i32, ptr %42, align 8
  %785 = shl i32 %784, 1
  %spec.select.i1529 = call i32 @llvm.smax.i32(i32 %785, i32 16)
  store i32 %spec.select.i1529, ptr %42, align 8
  %786 = zext nneg i32 %spec.select.i1529 to i64
  %787 = shl nuw nsw i64 %786, 5
  %result.i.i1530 = call noalias ptr @bump_malloc_inner(i64 noundef %787, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1530, ptr %43, align 8
  %result.i20.i1531 = call noalias ptr @bump_malloc_inner(i64 noundef %787, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1531, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %788 = icmp sgt i32 %784, 0
  br i1 %788, label %.lr.ph.i2536, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569.thread: ; preds = %780
  %789 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605

.lr.ph.i2536:                                     ; preds = %780, %._crit_edge.i2551
  %.060.i2549 = phi i32 [ %878, %._crit_edge.i2551 ], [ 0, %780 ]
  %790 = zext nneg i32 %.060.i2549 to i64
  %791 = shl nuw nsw i64 %790, 5
  %792 = getelementptr i8, ptr %782, i64 %791
  %793 = load ptr, ptr %792, align 8
  %794 = icmp ne ptr %793, @nil_typ
  %795 = icmp ne ptr %793, null
  %.not16.i2550 = and i1 %794, %795
  br i1 %.not16.i2550, label %796, label %._crit_edge.i2551

796:                                              ; preds = %.lr.ph.i2536
  %797 = getelementptr i8, ptr %792, i64 8
  %798 = load <2 x i64>, ptr %797, align 4
  %hash_coef_ptr.i.i18.i2553 = getelementptr i8, ptr %793, i64 8
  %tbl_size_ptr.i.i19.i2554 = getelementptr i8, ptr %793, i64 16
  %offset_tbl_ptr.i.i20.i2555 = getelementptr i8, ptr %793, i64 40
  %799 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %hash_coef.i.i99.i3138 = load i64, ptr %hash_coef_ptr.i.i18.i2553, align 4, !noalias !22
  %tbl_size.i.i100.i3139 = load i64, ptr %tbl_size_ptr.i.i19.i2554, align 4, !noalias !22
  %offset_tbl.i.i101.i3140 = load ptr, ptr %offset_tbl_ptr.i.i20.i2555, align 8, !noalias !22
  %product.i.i.i102.i3141 = mul i64 %hash_coef.i.i99.i3138, 4015701072841558310
  %shifted.i.i.i103.i3142 = lshr i64 %product.i.i.i102.i3141, 32
  %xored.i.i.i104.i3143 = xor i64 %shifted.i.i.i103.i3142, %product.i.i.i102.i3141
  %hash.i.i.i105.i3144 = and i64 %xored.i.i.i104.i3143, %tbl_size.i.i100.i3139
  %offset_ptr.i.i106.i3145 = getelementptr i32, ptr %offset_tbl.i.i101.i3140, i64 %hash.i.i.i105.i3144
  %offset.i.i121.i3146 = load i32, ptr %offset_ptr.i.i106.i3145, align 4, !noalias !347
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %801 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %802 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %803

803:                                              ; preds = %.cont.cont.i3167, %796
  %.0566.i3147 = phi i32 [ 0, %796 ], [ %807, %.cont.cont.i3167 ]
  %.070565.i3148 = phi i1 [ true, %796 ], [ %869, %.cont.cont.i3167 ]
  %.sroa.0.0564.i3149 = phi ptr [ %793, %796 ], [ %vptr.i142.sroa.speculated.i3170, %.cont.cont.i3167 ]
  %.sroa.17.0561.i3152 = phi i32 [ %offset.i.i121.i3146, %796 ], [ %offset.i.i154.i3184, %.cont.cont.i3167 ]
  %804 = phi <2 x i64> [ %798, %796 ], [ %868, %.cont.cont.i3167 ]
  %805 = extractelement <2 x i64> %804, i64 1
  %.sroa.12.0562.i3151 = inttoptr i64 %805 to ptr
  %806 = extractelement <2 x i64> %804, i64 0
  %.sroa.6.0563.i3150 = inttoptr i64 %806 to ptr
  %807 = add nuw nsw i32 %.0566.i3147, 1
  %808 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3149, 0
  %809 = insertvalue { ptr, ptr, ptr, i32 } %808, ptr %.sroa.6.0563.i3150, 1
  %810 = insertvalue { ptr, ptr, ptr, i32 } %809, ptr %.sroa.12.0562.i3151, 2
  %811 = insertvalue { ptr, ptr, ptr, i32 } %810, i32 %.sroa.17.0561.i3152, 3
  %812 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3149)
  %813 = sext i32 %.sroa.17.0561.i3152 to i64
  %814 = getelementptr ptr, ptr %.sroa.0.0564.i3149, i64 %813
  %815 = getelementptr i8, ptr %814, i64 64
  %816 = load ptr, ptr %815, align 8
  %result.i125.i3153 = call ptr %816({ ptr, ptr, ptr, i32 } %811, ptr nocapture nofree noundef nonnull readonly %2) #16
  %817 = call i32 %result.i125.i3153({ ptr, ptr, ptr, i32 } %811, { ptr, ptr, ptr, i32 } %811, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3148, label %818, label %834

818:                                              ; preds = %803
  %819 = load i32, ptr %42, align 8
  %820 = add i32 %819, -1
  %821 = and i32 %820, %817
  %822 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %823 = load ptr, ptr %43, align 8
  %824 = sext i32 %821 to i64
  %825 = shl nsw i64 %824, 5
  %826 = getelementptr i8, ptr %823, i64 %825
  %827 = load ptr, ptr %826, align 8
  %828 = getelementptr i8, ptr %826, i64 8
  %829 = load i160, ptr %828, align 4
  store ptr %.sroa.0.0564.i3149, ptr %826, align 8
  store i64 %806, ptr %828, align 4
  %.sroa_idx157.i3196 = getelementptr i8, ptr %826, i64 16
  store i64 %805, ptr %.sroa_idx157.i3196, align 4
  %.sroa_idx158.i3197 = getelementptr i8, ptr %826, i64 24
  store i32 %.sroa.17.0561.i3152, ptr %.sroa_idx158.i3197, align 4
  %830 = icmp ne ptr %827, @nil_typ
  %831 = icmp ne ptr %827, null
  %.not92.i3198 = and i1 %830, %831
  %extract.i3200 = lshr i160 %829, 64
  %832 = insertelement <2 x i160> poison, i160 %829, i64 0
  %833 = insertelement <2 x i160> %832, i160 %extract.i3200, i64 1
  br i1 %.not92.i3198, label %.cont.cont.i3167, label %873

834:                                              ; preds = %803
  %835 = add i32 %817, 2127912214
  %836 = shl i32 %817, 12
  %837 = add i32 %835, %836
  %838 = ashr i32 %837, 19
  %839 = xor i32 %837, %838
  %840 = xor i32 %839, -949894596
  %841 = add i32 %840, 374761393
  %842 = shl i32 %840, 5
  %843 = add i32 %841, %842
  %844 = add i32 %843, -744332180
  %845 = shl i32 %843, 9
  %846 = xor i32 %844, %845
  %847 = add i32 %846, -42973499
  %848 = shl i32 %846, 3
  %849 = add i32 %847, %848
  %850 = ashr i32 %849, 16
  %851 = xor i32 %849, %850
  %852 = xor i32 %851, -1252372727
  %853 = load i32, ptr %42, align 8
  %854 = add i32 %853, -1
  %855 = and i32 %854, %852
  %856 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %857 = load ptr, ptr %44, align 8
  %858 = sext i32 %855 to i64
  %859 = shl nsw i64 %858, 5
  %860 = getelementptr i8, ptr %857, i64 %859
  %861 = load ptr, ptr %860, align 8
  %862 = getelementptr i8, ptr %860, i64 8
  %863 = load i160, ptr %862, align 4
  store ptr %.sroa.0.0564.i3149, ptr %860, align 8
  store i64 %806, ptr %862, align 4
  %.sroa_idx161.i3157 = getelementptr i8, ptr %860, i64 16
  store i64 %805, ptr %.sroa_idx161.i3157, align 4
  %.sroa_idx162.i3158 = getelementptr i8, ptr %860, i64 24
  store i32 %.sroa.17.0561.i3152, ptr %.sroa_idx162.i3158, align 4
  %864 = icmp ne ptr %861, @nil_typ
  %865 = icmp ne ptr %861, null
  %.not90.i3159 = and i1 %864, %865
  %extract607.i3161 = lshr i160 %863, 64
  %866 = insertelement <2 x i160> poison, i160 %863, i64 0
  %867 = insertelement <2 x i160> %866, i160 %extract607.i3161, i64 1
  br i1 %.not90.i3159, label %.cont.cont.i3167, label %873

.cont.cont.i3167:                                 ; preds = %834, %818
  %vptr.i142.sroa.speculated.i3170 = phi ptr [ %827, %818 ], [ %861, %834 ]
  %.in4329 = phi <2 x i160> [ %833, %818 ], [ %867, %834 ]
  %868 = trunc <2 x i160> %.in4329 to <2 x i64>
  %869 = xor i1 %.070565.i3148, true
  %hash_coef_ptr.i.i143.i3173 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3170, i64 8
  %tbl_size_ptr.i.i144.i3174 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3170, i64 16
  %offset_tbl_ptr.i.i145.i3175 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3170, i64 40
  %hash_coef.i.i146.i3176 = load i64, ptr %hash_coef_ptr.i.i143.i3173, align 4
  %tbl_size.i.i147.i3177 = load i64, ptr %tbl_size_ptr.i.i144.i3174, align 4
  %offset_tbl.i.i148.i3178 = load ptr, ptr %offset_tbl_ptr.i.i145.i3175, align 8
  %product.i.i.i149.i3179 = mul i64 %hash_coef.i.i146.i3176, 4015701072841558310
  %shifted.i.i.i150.i3180 = lshr i64 %product.i.i.i149.i3179, 32
  %xored.i.i.i151.i3181 = xor i64 %shifted.i.i.i150.i3180, %product.i.i.i149.i3179
  %hash.i.i.i152.i3182 = and i64 %xored.i.i.i151.i3181, %tbl_size.i.i147.i3177
  %offset_ptr.i.i153.i3183 = getelementptr i32, ptr %offset_tbl.i.i148.i3178, i64 %hash.i.i.i152.i3182
  %offset.i.i154.i3184 = load i32, ptr %offset_ptr.i.i153.i3183, align 4
  %870 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %871 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %872 = icmp ult i32 %.0566.i3147, 99
  br i1 %872, label %803, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202

873:                                              ; preds = %834, %818
  %874 = phi ptr [ %22, %834 ], [ %21, %818 ]
  %875 = load i32, ptr %65, align 4
  store i32 %875, ptr %874, align 4
  %876 = add i32 %875, 1
  %877 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %876, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202: ; preds = %.cont.cont.i3167, %873
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %._crit_edge.i2551

._crit_edge.i2551:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3202, %.lr.ph.i2536
  %878 = add nuw nsw i32 %.060.i2549, 1
  %879 = icmp slt i32 %878, %784
  br i1 %879, label %.lr.ph.i2536, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569: ; preds = %._crit_edge.i2551
  %880 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %881

881:                                              ; preds = %._crit_edge.i2587, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569
  %.060.i2585 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569 ], [ %970, %._crit_edge.i2587 ]
  %882 = zext nneg i32 %.060.i2585 to i64
  %883 = shl nuw nsw i64 %882, 5
  %884 = getelementptr i8, ptr %783, i64 %883
  %885 = load ptr, ptr %884, align 8
  %886 = icmp ne ptr %885, @nil_typ
  %887 = icmp ne ptr %885, null
  %.not16.i2586 = and i1 %886, %887
  br i1 %.not16.i2586, label %888, label %._crit_edge.i2587

888:                                              ; preds = %881
  %889 = getelementptr i8, ptr %884, i64 8
  %890 = load <2 x i64>, ptr %889, align 4
  %hash_coef_ptr.i.i18.i2589 = getelementptr i8, ptr %885, i64 8
  %tbl_size_ptr.i.i19.i2590 = getelementptr i8, ptr %885, i64 16
  %offset_tbl_ptr.i.i20.i2591 = getelementptr i8, ptr %885, i64 40
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i3220 = load i64, ptr %hash_coef_ptr.i.i18.i2589, align 4, !noalias !22
  %tbl_size.i.i100.i3221 = load i64, ptr %tbl_size_ptr.i.i19.i2590, align 4, !noalias !22
  %offset_tbl.i.i101.i3222 = load ptr, ptr %offset_tbl_ptr.i.i20.i2591, align 8, !noalias !22
  %product.i.i.i102.i3223 = mul i64 %hash_coef.i.i99.i3220, 4015701072841558310
  %shifted.i.i.i103.i3224 = lshr i64 %product.i.i.i102.i3223, 32
  %xored.i.i.i104.i3225 = xor i64 %shifted.i.i.i103.i3224, %product.i.i.i102.i3223
  %hash.i.i.i105.i3226 = and i64 %xored.i.i.i104.i3225, %tbl_size.i.i100.i3221
  %offset_ptr.i.i106.i3227 = getelementptr i32, ptr %offset_tbl.i.i101.i3222, i64 %hash.i.i.i105.i3226
  %offset.i.i121.i3228 = load i32, ptr %offset_ptr.i.i106.i3227, align 4, !noalias !350
  %892 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %893 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %894 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %895

895:                                              ; preds = %.cont.cont.i3249, %888
  %.0566.i3229 = phi i32 [ 0, %888 ], [ %899, %.cont.cont.i3249 ]
  %.070565.i3230 = phi i1 [ true, %888 ], [ %961, %.cont.cont.i3249 ]
  %.sroa.0.0564.i3231 = phi ptr [ %885, %888 ], [ %vptr.i142.sroa.speculated.i3252, %.cont.cont.i3249 ]
  %.sroa.17.0561.i3234 = phi i32 [ %offset.i.i121.i3228, %888 ], [ %offset.i.i154.i3266, %.cont.cont.i3249 ]
  %896 = phi <2 x i64> [ %890, %888 ], [ %960, %.cont.cont.i3249 ]
  %897 = extractelement <2 x i64> %896, i64 1
  %.sroa.12.0562.i3233 = inttoptr i64 %897 to ptr
  %898 = extractelement <2 x i64> %896, i64 0
  %.sroa.6.0563.i3232 = inttoptr i64 %898 to ptr
  %899 = add nuw nsw i32 %.0566.i3229, 1
  %900 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3231, 0
  %901 = insertvalue { ptr, ptr, ptr, i32 } %900, ptr %.sroa.6.0563.i3232, 1
  %902 = insertvalue { ptr, ptr, ptr, i32 } %901, ptr %.sroa.12.0562.i3233, 2
  %903 = insertvalue { ptr, ptr, ptr, i32 } %902, i32 %.sroa.17.0561.i3234, 3
  %904 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3231)
  %905 = sext i32 %.sroa.17.0561.i3234 to i64
  %906 = getelementptr ptr, ptr %.sroa.0.0564.i3231, i64 %905
  %907 = getelementptr i8, ptr %906, i64 64
  %908 = load ptr, ptr %907, align 8
  %result.i125.i3235 = call ptr %908({ ptr, ptr, ptr, i32 } %903, ptr nocapture nofree noundef nonnull readonly %2) #16
  %909 = call i32 %result.i125.i3235({ ptr, ptr, ptr, i32 } %903, { ptr, ptr, ptr, i32 } %903, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3230, label %910, label %926

910:                                              ; preds = %895
  %911 = load i32, ptr %42, align 8
  %912 = add i32 %911, -1
  %913 = and i32 %912, %909
  %914 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %915 = load ptr, ptr %43, align 8
  %916 = sext i32 %913 to i64
  %917 = shl nsw i64 %916, 5
  %918 = getelementptr i8, ptr %915, i64 %917
  %919 = load ptr, ptr %918, align 8
  %920 = getelementptr i8, ptr %918, i64 8
  %921 = load i160, ptr %920, align 4
  store ptr %.sroa.0.0564.i3231, ptr %918, align 8
  store i64 %898, ptr %920, align 4
  %.sroa_idx157.i3278 = getelementptr i8, ptr %918, i64 16
  store i64 %897, ptr %.sroa_idx157.i3278, align 4
  %.sroa_idx158.i3279 = getelementptr i8, ptr %918, i64 24
  store i32 %.sroa.17.0561.i3234, ptr %.sroa_idx158.i3279, align 4
  %922 = icmp ne ptr %919, @nil_typ
  %923 = icmp ne ptr %919, null
  %.not92.i3280 = and i1 %922, %923
  %extract.i3282 = lshr i160 %921, 64
  %924 = insertelement <2 x i160> poison, i160 %921, i64 0
  %925 = insertelement <2 x i160> %924, i160 %extract.i3282, i64 1
  br i1 %.not92.i3280, label %.cont.cont.i3249, label %965

926:                                              ; preds = %895
  %927 = add i32 %909, 2127912214
  %928 = shl i32 %909, 12
  %929 = add i32 %927, %928
  %930 = ashr i32 %929, 19
  %931 = xor i32 %929, %930
  %932 = xor i32 %931, -949894596
  %933 = add i32 %932, 374761393
  %934 = shl i32 %932, 5
  %935 = add i32 %933, %934
  %936 = add i32 %935, -744332180
  %937 = shl i32 %935, 9
  %938 = xor i32 %936, %937
  %939 = add i32 %938, -42973499
  %940 = shl i32 %938, 3
  %941 = add i32 %939, %940
  %942 = ashr i32 %941, 16
  %943 = xor i32 %941, %942
  %944 = xor i32 %943, -1252372727
  %945 = load i32, ptr %42, align 8
  %946 = add i32 %945, -1
  %947 = and i32 %946, %944
  %948 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %949 = load ptr, ptr %44, align 8
  %950 = sext i32 %947 to i64
  %951 = shl nsw i64 %950, 5
  %952 = getelementptr i8, ptr %949, i64 %951
  %953 = load ptr, ptr %952, align 8
  %954 = getelementptr i8, ptr %952, i64 8
  %955 = load i160, ptr %954, align 4
  store ptr %.sroa.0.0564.i3231, ptr %952, align 8
  store i64 %898, ptr %954, align 4
  %.sroa_idx161.i3239 = getelementptr i8, ptr %952, i64 16
  store i64 %897, ptr %.sroa_idx161.i3239, align 4
  %.sroa_idx162.i3240 = getelementptr i8, ptr %952, i64 24
  store i32 %.sroa.17.0561.i3234, ptr %.sroa_idx162.i3240, align 4
  %956 = icmp ne ptr %953, @nil_typ
  %957 = icmp ne ptr %953, null
  %.not90.i3241 = and i1 %956, %957
  %extract607.i3243 = lshr i160 %955, 64
  %958 = insertelement <2 x i160> poison, i160 %955, i64 0
  %959 = insertelement <2 x i160> %958, i160 %extract607.i3243, i64 1
  br i1 %.not90.i3241, label %.cont.cont.i3249, label %965

.cont.cont.i3249:                                 ; preds = %926, %910
  %vptr.i142.sroa.speculated.i3252 = phi ptr [ %919, %910 ], [ %953, %926 ]
  %.in4330 = phi <2 x i160> [ %925, %910 ], [ %959, %926 ]
  %960 = trunc <2 x i160> %.in4330 to <2 x i64>
  %961 = xor i1 %.070565.i3230, true
  %hash_coef_ptr.i.i143.i3255 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3252, i64 8
  %tbl_size_ptr.i.i144.i3256 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3252, i64 16
  %offset_tbl_ptr.i.i145.i3257 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3252, i64 40
  %hash_coef.i.i146.i3258 = load i64, ptr %hash_coef_ptr.i.i143.i3255, align 4
  %tbl_size.i.i147.i3259 = load i64, ptr %tbl_size_ptr.i.i144.i3256, align 4
  %offset_tbl.i.i148.i3260 = load ptr, ptr %offset_tbl_ptr.i.i145.i3257, align 8
  %product.i.i.i149.i3261 = mul i64 %hash_coef.i.i146.i3258, 4015701072841558310
  %shifted.i.i.i150.i3262 = lshr i64 %product.i.i.i149.i3261, 32
  %xored.i.i.i151.i3263 = xor i64 %shifted.i.i.i150.i3262, %product.i.i.i149.i3261
  %hash.i.i.i152.i3264 = and i64 %xored.i.i.i151.i3263, %tbl_size.i.i147.i3259
  %offset_ptr.i.i153.i3265 = getelementptr i32, ptr %offset_tbl.i.i148.i3260, i64 %hash.i.i.i152.i3264
  %offset.i.i154.i3266 = load i32, ptr %offset_ptr.i.i153.i3265, align 4
  %962 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %963 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %964 = icmp ult i32 %.0566.i3229, 99
  br i1 %964, label %895, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3284

965:                                              ; preds = %926, %910
  %966 = phi ptr [ %20, %926 ], [ %19, %910 ]
  %967 = load i32, ptr %65, align 4
  store i32 %967, ptr %966, align 4
  %968 = add i32 %967, 1
  %969 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %968, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3284

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3284: ; preds = %.cont.cont.i3249, %965
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %._crit_edge.i2587

._crit_edge.i2587:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3284, %881
  %970 = add nuw nsw i32 %.060.i2585, 1
  %971 = icmp slt i32 %970, %784
  br i1 %971, label %881, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605: ; preds = %._crit_edge.i2587, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2569.thread
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %32)
  %hash_coef.i.i99.i1554 = load i64, ptr %hash_coef_ptr.i.i143.i, align 4, !noalias !22
  %tbl_size.i.i100.i1555 = load i64, ptr %tbl_size_ptr.i.i144.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1556 = load ptr, ptr %offset_tbl_ptr.i.i145.i, align 8, !noalias !22
  %product.i.i.i102.i1557 = mul i64 %hash_coef.i.i99.i1554, 4015701072841558310
  %shifted.i.i.i103.i1558 = lshr i64 %product.i.i.i102.i1557, 32
  %xored.i.i.i104.i1559 = xor i64 %shifted.i.i.i103.i1558, %product.i.i.i102.i1557
  %hash.i.i.i105.i1560 = and i64 %xored.i.i.i104.i1559, %tbl_size.i.i100.i1555
  %offset_ptr.i.i106.i1561 = getelementptr i32, ptr %offset_tbl.i.i101.i1556, i64 %hash.i.i.i105.i1560
  %offset.i.i121.i1562 = load i32, ptr %offset_ptr.i.i106.i1561, align 4, !noalias !353
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %973 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %974 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %975

975:                                              ; preds = %.cont.cont.i1584, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605
  %.0566.i1564 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %979, %.cont.cont.i1584 ]
  %.070565.i1565 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %1041, %.cont.cont.i1584 ]
  %.sroa.0.0564.i1566 = phi ptr [ %vptr.i142.sroa.speculated.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %vptr.i142.sroa.speculated.i1587, %.cont.cont.i1584 ]
  %.sroa.17.0561.i1569 = phi i32 [ %offset.i.i121.i1562, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %offset.i.i154.i1601, %.cont.cont.i1584 ]
  %976 = phi <2 x i64> [ %768, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2605 ], [ %1040, %.cont.cont.i1584 ]
  %977 = extractelement <2 x i64> %976, i64 1
  %.sroa.12.0562.i1568 = inttoptr i64 %977 to ptr
  %978 = extractelement <2 x i64> %976, i64 0
  %.sroa.6.0563.i1567 = inttoptr i64 %978 to ptr
  %979 = add nuw nsw i32 %.0566.i1564, 1
  %980 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1566, 0
  %981 = insertvalue { ptr, ptr, ptr, i32 } %980, ptr %.sroa.6.0563.i1567, 1
  %982 = insertvalue { ptr, ptr, ptr, i32 } %981, ptr %.sroa.12.0562.i1568, 2
  %983 = insertvalue { ptr, ptr, ptr, i32 } %982, i32 %.sroa.17.0561.i1569, 3
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1566)
  %985 = sext i32 %.sroa.17.0561.i1569 to i64
  %986 = getelementptr ptr, ptr %.sroa.0.0564.i1566, i64 %985
  %987 = getelementptr i8, ptr %986, i64 64
  %988 = load ptr, ptr %987, align 8
  %result.i125.i1570 = call ptr %988({ ptr, ptr, ptr, i32 } %983, ptr nocapture nofree noundef nonnull readonly %2) #16
  %989 = call i32 %result.i125.i1570({ ptr, ptr, ptr, i32 } %983, { ptr, ptr, ptr, i32 } %983, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1565, label %990, label %1006

990:                                              ; preds = %975
  %991 = load i32, ptr %42, align 8
  %992 = add i32 %991, -1
  %993 = and i32 %992, %989
  %994 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %995 = load ptr, ptr %43, align 8
  %996 = sext i32 %993 to i64
  %997 = shl nsw i64 %996, 5
  %998 = getelementptr i8, ptr %995, i64 %997
  %999 = load ptr, ptr %998, align 8
  %1000 = getelementptr i8, ptr %998, i64 8
  %1001 = load i160, ptr %1000, align 4
  store ptr %.sroa.0.0564.i1566, ptr %998, align 8
  store i64 %978, ptr %1000, align 4
  %.sroa_idx157.i1613 = getelementptr i8, ptr %998, i64 16
  store i64 %977, ptr %.sroa_idx157.i1613, align 4
  %.sroa_idx158.i1614 = getelementptr i8, ptr %998, i64 24
  store i32 %.sroa.17.0561.i1569, ptr %.sroa_idx158.i1614, align 4
  %1002 = icmp ne ptr %999, @nil_typ
  %1003 = icmp ne ptr %999, null
  %.not92.i1615 = and i1 %1002, %1003
  %extract.i1617 = lshr i160 %1001, 64
  %1004 = insertelement <2 x i160> poison, i160 %1001, i64 0
  %1005 = insertelement <2 x i160> %1004, i160 %extract.i1617, i64 1
  br i1 %.not92.i1615, label %.cont.cont.i1584, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1619.thread

1006:                                             ; preds = %975
  %1007 = add i32 %989, 2127912214
  %1008 = shl i32 %989, 12
  %1009 = add i32 %1007, %1008
  %1010 = ashr i32 %1009, 19
  %1011 = xor i32 %1009, %1010
  %1012 = xor i32 %1011, -949894596
  %1013 = add i32 %1012, 374761393
  %1014 = shl i32 %1012, 5
  %1015 = add i32 %1013, %1014
  %1016 = add i32 %1015, -744332180
  %1017 = shl i32 %1015, 9
  %1018 = xor i32 %1016, %1017
  %1019 = add i32 %1018, -42973499
  %1020 = shl i32 %1018, 3
  %1021 = add i32 %1019, %1020
  %1022 = ashr i32 %1021, 16
  %1023 = xor i32 %1021, %1022
  %1024 = xor i32 %1023, -1252372727
  %1025 = load i32, ptr %42, align 8
  %1026 = add i32 %1025, -1
  %1027 = and i32 %1026, %1024
  %1028 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1029 = load ptr, ptr %44, align 8
  %1030 = sext i32 %1027 to i64
  %1031 = shl nsw i64 %1030, 5
  %1032 = getelementptr i8, ptr %1029, i64 %1031
  %1033 = load ptr, ptr %1032, align 8
  %1034 = getelementptr i8, ptr %1032, i64 8
  %1035 = load i160, ptr %1034, align 4
  store ptr %.sroa.0.0564.i1566, ptr %1032, align 8
  store i64 %978, ptr %1034, align 4
  %.sroa_idx161.i1574 = getelementptr i8, ptr %1032, i64 16
  store i64 %977, ptr %.sroa_idx161.i1574, align 4
  %.sroa_idx162.i1575 = getelementptr i8, ptr %1032, i64 24
  store i32 %.sroa.17.0561.i1569, ptr %.sroa_idx162.i1575, align 4
  %1036 = icmp ne ptr %1033, @nil_typ
  %1037 = icmp ne ptr %1033, null
  %.not90.i1576 = and i1 %1036, %1037
  %extract607.i1578 = lshr i160 %1035, 64
  %1038 = insertelement <2 x i160> poison, i160 %1035, i64 0
  %1039 = insertelement <2 x i160> %1038, i160 %extract607.i1578, i64 1
  br i1 %.not90.i1576, label %.cont.cont.i1584, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1619.thread

.cont.cont.i1584:                                 ; preds = %1006, %990
  %vptr.i142.sroa.speculated.i1587 = phi ptr [ %999, %990 ], [ %1033, %1006 ]
  %.in4331 = phi <2 x i160> [ %1005, %990 ], [ %1039, %1006 ]
  %1040 = trunc <2 x i160> %.in4331 to <2 x i64>
  %1041 = xor i1 %.070565.i1565, true
  %hash_coef_ptr.i.i143.i1590 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1587, i64 8
  %tbl_size_ptr.i.i144.i1591 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1587, i64 16
  %offset_tbl_ptr.i.i145.i1592 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1587, i64 40
  %hash_coef.i.i146.i1593 = load i64, ptr %hash_coef_ptr.i.i143.i1590, align 4
  %tbl_size.i.i147.i1594 = load i64, ptr %tbl_size_ptr.i.i144.i1591, align 4
  %offset_tbl.i.i148.i1595 = load ptr, ptr %offset_tbl_ptr.i.i145.i1592, align 8
  %product.i.i.i149.i1596 = mul i64 %hash_coef.i.i146.i1593, 4015701072841558310
  %shifted.i.i.i150.i1597 = lshr i64 %product.i.i.i149.i1596, 32
  %xored.i.i.i151.i1598 = xor i64 %shifted.i.i.i150.i1597, %product.i.i.i149.i1596
  %hash.i.i.i152.i1599 = and i64 %xored.i.i.i151.i1598, %tbl_size.i.i147.i1594
  %offset_ptr.i.i153.i1600 = getelementptr i32, ptr %offset_tbl.i.i148.i1595, i64 %hash.i.i.i152.i1599
  %offset.i.i154.i1601 = load i32, ptr %offset_ptr.i.i153.i1600, align 4
  %1042 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1043 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1044 = icmp ult i32 %.0566.i1564, 99
  br i1 %1044, label %975, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1619

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1619.thread: ; preds = %990, %1006
  %1045 = phi ptr [ %32, %1006 ], [ %31, %990 ]
  %1046 = load i32, ptr %65, align 4
  store i32 %1046, ptr %1045, align 4
  %1047 = add i32 %1046, 1
  %1048 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1047, ptr %65, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  br label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1619: ; preds = %.cont.cont.i1584
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %31)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %32)
  %1049 = icmp eq ptr %vptr.i142.sroa.speculated.i1587, null
  br i1 %1049, label %CuckooMap_insert_keyK_valueV.exit, label %1050

1050:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1619
  %1051 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1052 = load ptr, ptr %43, align 8
  %1053 = load ptr, ptr %44, align 8
  %1054 = load i32, ptr %42, align 8
  %1055 = shl i32 %1054, 1
  %spec.select.i1635 = call i32 @llvm.smax.i32(i32 %1055, i32 16)
  store i32 %spec.select.i1635, ptr %42, align 8
  %1056 = zext nneg i32 %spec.select.i1635 to i64
  %1057 = shl nuw nsw i64 %1056, 5
  %result.i.i1636 = call noalias ptr @bump_malloc_inner(i64 noundef %1057, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1636, ptr %43, align 8
  %result.i20.i1637 = call noalias ptr @bump_malloc_inner(i64 noundef %1057, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1637, ptr %44, align 8
  store i32 0, ptr %65, align 4
  %1058 = icmp sgt i32 %1054, 0
  br i1 %1058, label %.lr.ph.i2635, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668.thread: ; preds = %1050
  %1059 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit

.lr.ph.i2635:                                     ; preds = %1050, %._crit_edge.i2650
  %.060.i2648 = phi i32 [ %1148, %._crit_edge.i2650 ], [ 0, %1050 ]
  %1060 = zext nneg i32 %.060.i2648 to i64
  %1061 = shl nuw nsw i64 %1060, 5
  %1062 = getelementptr i8, ptr %1052, i64 %1061
  %1063 = load ptr, ptr %1062, align 8
  %1064 = icmp ne ptr %1063, @nil_typ
  %1065 = icmp ne ptr %1063, null
  %.not16.i2649 = and i1 %1064, %1065
  br i1 %.not16.i2649, label %1066, label %._crit_edge.i2650

1066:                                             ; preds = %.lr.ph.i2635
  %1067 = getelementptr i8, ptr %1062, i64 8
  %1068 = load <2 x i64>, ptr %1067, align 4
  %hash_coef_ptr.i.i18.i2652 = getelementptr i8, ptr %1063, i64 8
  %tbl_size_ptr.i.i19.i2653 = getelementptr i8, ptr %1063, i64 16
  %offset_tbl_ptr.i.i20.i2654 = getelementptr i8, ptr %1063, i64 40
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i3302 = load i64, ptr %hash_coef_ptr.i.i18.i2652, align 4, !noalias !22
  %tbl_size.i.i100.i3303 = load i64, ptr %tbl_size_ptr.i.i19.i2653, align 4, !noalias !22
  %offset_tbl.i.i101.i3304 = load ptr, ptr %offset_tbl_ptr.i.i20.i2654, align 8, !noalias !22
  %product.i.i.i102.i3305 = mul i64 %hash_coef.i.i99.i3302, 4015701072841558310
  %shifted.i.i.i103.i3306 = lshr i64 %product.i.i.i102.i3305, 32
  %xored.i.i.i104.i3307 = xor i64 %shifted.i.i.i103.i3306, %product.i.i.i102.i3305
  %hash.i.i.i105.i3308 = and i64 %xored.i.i.i104.i3307, %tbl_size.i.i100.i3303
  %offset_ptr.i.i106.i3309 = getelementptr i32, ptr %offset_tbl.i.i101.i3304, i64 %hash.i.i.i105.i3308
  %offset.i.i121.i3310 = load i32, ptr %offset_ptr.i.i106.i3309, align 4, !noalias !356
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1071 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1072 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1073

1073:                                             ; preds = %.cont.cont.i3331, %1066
  %.0566.i3311 = phi i32 [ 0, %1066 ], [ %1077, %.cont.cont.i3331 ]
  %.070565.i3312 = phi i1 [ true, %1066 ], [ %1139, %.cont.cont.i3331 ]
  %.sroa.0.0564.i3313 = phi ptr [ %1063, %1066 ], [ %vptr.i142.sroa.speculated.i3334, %.cont.cont.i3331 ]
  %.sroa.17.0561.i3316 = phi i32 [ %offset.i.i121.i3310, %1066 ], [ %offset.i.i154.i3348, %.cont.cont.i3331 ]
  %1074 = phi <2 x i64> [ %1068, %1066 ], [ %1138, %.cont.cont.i3331 ]
  %1075 = extractelement <2 x i64> %1074, i64 1
  %.sroa.12.0562.i3315 = inttoptr i64 %1075 to ptr
  %1076 = extractelement <2 x i64> %1074, i64 0
  %.sroa.6.0563.i3314 = inttoptr i64 %1076 to ptr
  %1077 = add nuw nsw i32 %.0566.i3311, 1
  %1078 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3313, 0
  %1079 = insertvalue { ptr, ptr, ptr, i32 } %1078, ptr %.sroa.6.0563.i3314, 1
  %1080 = insertvalue { ptr, ptr, ptr, i32 } %1079, ptr %.sroa.12.0562.i3315, 2
  %1081 = insertvalue { ptr, ptr, ptr, i32 } %1080, i32 %.sroa.17.0561.i3316, 3
  %1082 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3313)
  %1083 = sext i32 %.sroa.17.0561.i3316 to i64
  %1084 = getelementptr ptr, ptr %.sroa.0.0564.i3313, i64 %1083
  %1085 = getelementptr i8, ptr %1084, i64 64
  %1086 = load ptr, ptr %1085, align 8
  %result.i125.i3317 = call ptr %1086({ ptr, ptr, ptr, i32 } %1081, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1087 = call i32 %result.i125.i3317({ ptr, ptr, ptr, i32 } %1081, { ptr, ptr, ptr, i32 } %1081, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3312, label %1088, label %1104

1088:                                             ; preds = %1073
  %1089 = load i32, ptr %42, align 8
  %1090 = add i32 %1089, -1
  %1091 = and i32 %1090, %1087
  %1092 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1093 = load ptr, ptr %43, align 8
  %1094 = sext i32 %1091 to i64
  %1095 = shl nsw i64 %1094, 5
  %1096 = getelementptr i8, ptr %1093, i64 %1095
  %1097 = load ptr, ptr %1096, align 8
  %1098 = getelementptr i8, ptr %1096, i64 8
  %1099 = load i160, ptr %1098, align 4
  store ptr %.sroa.0.0564.i3313, ptr %1096, align 8
  store i64 %1076, ptr %1098, align 4
  %.sroa_idx157.i3360 = getelementptr i8, ptr %1096, i64 16
  store i64 %1075, ptr %.sroa_idx157.i3360, align 4
  %.sroa_idx158.i3361 = getelementptr i8, ptr %1096, i64 24
  store i32 %.sroa.17.0561.i3316, ptr %.sroa_idx158.i3361, align 4
  %1100 = icmp ne ptr %1097, @nil_typ
  %1101 = icmp ne ptr %1097, null
  %.not92.i3362 = and i1 %1100, %1101
  %extract.i3364 = lshr i160 %1099, 64
  %1102 = insertelement <2 x i160> poison, i160 %1099, i64 0
  %1103 = insertelement <2 x i160> %1102, i160 %extract.i3364, i64 1
  br i1 %.not92.i3362, label %.cont.cont.i3331, label %1143

1104:                                             ; preds = %1073
  %1105 = add i32 %1087, 2127912214
  %1106 = shl i32 %1087, 12
  %1107 = add i32 %1105, %1106
  %1108 = ashr i32 %1107, 19
  %1109 = xor i32 %1107, %1108
  %1110 = xor i32 %1109, -949894596
  %1111 = add i32 %1110, 374761393
  %1112 = shl i32 %1110, 5
  %1113 = add i32 %1111, %1112
  %1114 = add i32 %1113, -744332180
  %1115 = shl i32 %1113, 9
  %1116 = xor i32 %1114, %1115
  %1117 = add i32 %1116, -42973499
  %1118 = shl i32 %1116, 3
  %1119 = add i32 %1117, %1118
  %1120 = ashr i32 %1119, 16
  %1121 = xor i32 %1119, %1120
  %1122 = xor i32 %1121, -1252372727
  %1123 = load i32, ptr %42, align 8
  %1124 = add i32 %1123, -1
  %1125 = and i32 %1124, %1122
  %1126 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1127 = load ptr, ptr %44, align 8
  %1128 = sext i32 %1125 to i64
  %1129 = shl nsw i64 %1128, 5
  %1130 = getelementptr i8, ptr %1127, i64 %1129
  %1131 = load ptr, ptr %1130, align 8
  %1132 = getelementptr i8, ptr %1130, i64 8
  %1133 = load i160, ptr %1132, align 4
  store ptr %.sroa.0.0564.i3313, ptr %1130, align 8
  store i64 %1076, ptr %1132, align 4
  %.sroa_idx161.i3321 = getelementptr i8, ptr %1130, i64 16
  store i64 %1075, ptr %.sroa_idx161.i3321, align 4
  %.sroa_idx162.i3322 = getelementptr i8, ptr %1130, i64 24
  store i32 %.sroa.17.0561.i3316, ptr %.sroa_idx162.i3322, align 4
  %1134 = icmp ne ptr %1131, @nil_typ
  %1135 = icmp ne ptr %1131, null
  %.not90.i3323 = and i1 %1134, %1135
  %extract607.i3325 = lshr i160 %1133, 64
  %1136 = insertelement <2 x i160> poison, i160 %1133, i64 0
  %1137 = insertelement <2 x i160> %1136, i160 %extract607.i3325, i64 1
  br i1 %.not90.i3323, label %.cont.cont.i3331, label %1143

.cont.cont.i3331:                                 ; preds = %1104, %1088
  %vptr.i142.sroa.speculated.i3334 = phi ptr [ %1097, %1088 ], [ %1131, %1104 ]
  %.in4332 = phi <2 x i160> [ %1103, %1088 ], [ %1137, %1104 ]
  %1138 = trunc <2 x i160> %.in4332 to <2 x i64>
  %1139 = xor i1 %.070565.i3312, true
  %hash_coef_ptr.i.i143.i3337 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3334, i64 8
  %tbl_size_ptr.i.i144.i3338 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3334, i64 16
  %offset_tbl_ptr.i.i145.i3339 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3334, i64 40
  %hash_coef.i.i146.i3340 = load i64, ptr %hash_coef_ptr.i.i143.i3337, align 4
  %tbl_size.i.i147.i3341 = load i64, ptr %tbl_size_ptr.i.i144.i3338, align 4
  %offset_tbl.i.i148.i3342 = load ptr, ptr %offset_tbl_ptr.i.i145.i3339, align 8
  %product.i.i.i149.i3343 = mul i64 %hash_coef.i.i146.i3340, 4015701072841558310
  %shifted.i.i.i150.i3344 = lshr i64 %product.i.i.i149.i3343, 32
  %xored.i.i.i151.i3345 = xor i64 %shifted.i.i.i150.i3344, %product.i.i.i149.i3343
  %hash.i.i.i152.i3346 = and i64 %xored.i.i.i151.i3345, %tbl_size.i.i147.i3341
  %offset_ptr.i.i153.i3347 = getelementptr i32, ptr %offset_tbl.i.i148.i3342, i64 %hash.i.i.i152.i3346
  %offset.i.i154.i3348 = load i32, ptr %offset_ptr.i.i153.i3347, align 4
  %1140 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1141 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1142 = icmp ult i32 %.0566.i3311, 99
  br i1 %1142, label %1073, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3366

1143:                                             ; preds = %1104, %1088
  %1144 = phi ptr [ %18, %1104 ], [ %17, %1088 ]
  %1145 = load i32, ptr %65, align 4
  store i32 %1145, ptr %1144, align 4
  %1146 = add i32 %1145, 1
  %1147 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1146, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3366

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3366: ; preds = %.cont.cont.i3331, %1143
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i2650

._crit_edge.i2650:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3366, %.lr.ph.i2635
  %1148 = add nuw nsw i32 %.060.i2648, 1
  %1149 = icmp slt i32 %1148, %1054
  br i1 %1149, label %.lr.ph.i2635, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668: ; preds = %._crit_edge.i2650
  %1150 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %1151

1151:                                             ; preds = %._crit_edge.i2686, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668
  %.060.i2684 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668 ], [ %1240, %._crit_edge.i2686 ]
  %1152 = zext nneg i32 %.060.i2684 to i64
  %1153 = shl nuw nsw i64 %1152, 5
  %1154 = getelementptr i8, ptr %1053, i64 %1153
  %1155 = load ptr, ptr %1154, align 8
  %1156 = icmp ne ptr %1155, @nil_typ
  %1157 = icmp ne ptr %1155, null
  %.not16.i2685 = and i1 %1156, %1157
  br i1 %.not16.i2685, label %1158, label %._crit_edge.i2686

1158:                                             ; preds = %1151
  %1159 = getelementptr i8, ptr %1154, i64 8
  %1160 = load <2 x i64>, ptr %1159, align 4
  %hash_coef_ptr.i.i18.i2688 = getelementptr i8, ptr %1155, i64 8
  %tbl_size_ptr.i.i19.i2689 = getelementptr i8, ptr %1155, i64 16
  %offset_tbl_ptr.i.i20.i2690 = getelementptr i8, ptr %1155, i64 40
  %1161 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i3384 = load i64, ptr %hash_coef_ptr.i.i18.i2688, align 4, !noalias !22
  %tbl_size.i.i100.i3385 = load i64, ptr %tbl_size_ptr.i.i19.i2689, align 4, !noalias !22
  %offset_tbl.i.i101.i3386 = load ptr, ptr %offset_tbl_ptr.i.i20.i2690, align 8, !noalias !22
  %product.i.i.i102.i3387 = mul i64 %hash_coef.i.i99.i3384, 4015701072841558310
  %shifted.i.i.i103.i3388 = lshr i64 %product.i.i.i102.i3387, 32
  %xored.i.i.i104.i3389 = xor i64 %shifted.i.i.i103.i3388, %product.i.i.i102.i3387
  %hash.i.i.i105.i3390 = and i64 %xored.i.i.i104.i3389, %tbl_size.i.i100.i3385
  %offset_ptr.i.i106.i3391 = getelementptr i32, ptr %offset_tbl.i.i101.i3386, i64 %hash.i.i.i105.i3390
  %offset.i.i121.i3392 = load i32, ptr %offset_ptr.i.i106.i3391, align 4, !noalias !359
  %1162 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1163 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1164 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1165

1165:                                             ; preds = %.cont.cont.i3413, %1158
  %.0566.i3393 = phi i32 [ 0, %1158 ], [ %1169, %.cont.cont.i3413 ]
  %.070565.i3394 = phi i1 [ true, %1158 ], [ %1231, %.cont.cont.i3413 ]
  %.sroa.0.0564.i3395 = phi ptr [ %1155, %1158 ], [ %vptr.i142.sroa.speculated.i3416, %.cont.cont.i3413 ]
  %.sroa.17.0561.i3398 = phi i32 [ %offset.i.i121.i3392, %1158 ], [ %offset.i.i154.i3430, %.cont.cont.i3413 ]
  %1166 = phi <2 x i64> [ %1160, %1158 ], [ %1230, %.cont.cont.i3413 ]
  %1167 = extractelement <2 x i64> %1166, i64 1
  %.sroa.12.0562.i3397 = inttoptr i64 %1167 to ptr
  %1168 = extractelement <2 x i64> %1166, i64 0
  %.sroa.6.0563.i3396 = inttoptr i64 %1168 to ptr
  %1169 = add nuw nsw i32 %.0566.i3393, 1
  %1170 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3395, 0
  %1171 = insertvalue { ptr, ptr, ptr, i32 } %1170, ptr %.sroa.6.0563.i3396, 1
  %1172 = insertvalue { ptr, ptr, ptr, i32 } %1171, ptr %.sroa.12.0562.i3397, 2
  %1173 = insertvalue { ptr, ptr, ptr, i32 } %1172, i32 %.sroa.17.0561.i3398, 3
  %1174 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3395)
  %1175 = sext i32 %.sroa.17.0561.i3398 to i64
  %1176 = getelementptr ptr, ptr %.sroa.0.0564.i3395, i64 %1175
  %1177 = getelementptr i8, ptr %1176, i64 64
  %1178 = load ptr, ptr %1177, align 8
  %result.i125.i3399 = call ptr %1178({ ptr, ptr, ptr, i32 } %1173, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1179 = call i32 %result.i125.i3399({ ptr, ptr, ptr, i32 } %1173, { ptr, ptr, ptr, i32 } %1173, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3394, label %1180, label %1196

1180:                                             ; preds = %1165
  %1181 = load i32, ptr %42, align 8
  %1182 = add i32 %1181, -1
  %1183 = and i32 %1182, %1179
  %1184 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1185 = load ptr, ptr %43, align 8
  %1186 = sext i32 %1183 to i64
  %1187 = shl nsw i64 %1186, 5
  %1188 = getelementptr i8, ptr %1185, i64 %1187
  %1189 = load ptr, ptr %1188, align 8
  %1190 = getelementptr i8, ptr %1188, i64 8
  %1191 = load i160, ptr %1190, align 4
  store ptr %.sroa.0.0564.i3395, ptr %1188, align 8
  store i64 %1168, ptr %1190, align 4
  %.sroa_idx157.i3442 = getelementptr i8, ptr %1188, i64 16
  store i64 %1167, ptr %.sroa_idx157.i3442, align 4
  %.sroa_idx158.i3443 = getelementptr i8, ptr %1188, i64 24
  store i32 %.sroa.17.0561.i3398, ptr %.sroa_idx158.i3443, align 4
  %1192 = icmp ne ptr %1189, @nil_typ
  %1193 = icmp ne ptr %1189, null
  %.not92.i3444 = and i1 %1192, %1193
  %extract.i3446 = lshr i160 %1191, 64
  %1194 = insertelement <2 x i160> poison, i160 %1191, i64 0
  %1195 = insertelement <2 x i160> %1194, i160 %extract.i3446, i64 1
  br i1 %.not92.i3444, label %.cont.cont.i3413, label %1235

1196:                                             ; preds = %1165
  %1197 = add i32 %1179, 2127912214
  %1198 = shl i32 %1179, 12
  %1199 = add i32 %1197, %1198
  %1200 = ashr i32 %1199, 19
  %1201 = xor i32 %1199, %1200
  %1202 = xor i32 %1201, -949894596
  %1203 = add i32 %1202, 374761393
  %1204 = shl i32 %1202, 5
  %1205 = add i32 %1203, %1204
  %1206 = add i32 %1205, -744332180
  %1207 = shl i32 %1205, 9
  %1208 = xor i32 %1206, %1207
  %1209 = add i32 %1208, -42973499
  %1210 = shl i32 %1208, 3
  %1211 = add i32 %1209, %1210
  %1212 = ashr i32 %1211, 16
  %1213 = xor i32 %1211, %1212
  %1214 = xor i32 %1213, -1252372727
  %1215 = load i32, ptr %42, align 8
  %1216 = add i32 %1215, -1
  %1217 = and i32 %1216, %1214
  %1218 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1219 = load ptr, ptr %44, align 8
  %1220 = sext i32 %1217 to i64
  %1221 = shl nsw i64 %1220, 5
  %1222 = getelementptr i8, ptr %1219, i64 %1221
  %1223 = load ptr, ptr %1222, align 8
  %1224 = getelementptr i8, ptr %1222, i64 8
  %1225 = load i160, ptr %1224, align 4
  store ptr %.sroa.0.0564.i3395, ptr %1222, align 8
  store i64 %1168, ptr %1224, align 4
  %.sroa_idx161.i3403 = getelementptr i8, ptr %1222, i64 16
  store i64 %1167, ptr %.sroa_idx161.i3403, align 4
  %.sroa_idx162.i3404 = getelementptr i8, ptr %1222, i64 24
  store i32 %.sroa.17.0561.i3398, ptr %.sroa_idx162.i3404, align 4
  %1226 = icmp ne ptr %1223, @nil_typ
  %1227 = icmp ne ptr %1223, null
  %.not90.i3405 = and i1 %1226, %1227
  %extract607.i3407 = lshr i160 %1225, 64
  %1228 = insertelement <2 x i160> poison, i160 %1225, i64 0
  %1229 = insertelement <2 x i160> %1228, i160 %extract607.i3407, i64 1
  br i1 %.not90.i3405, label %.cont.cont.i3413, label %1235

.cont.cont.i3413:                                 ; preds = %1196, %1180
  %vptr.i142.sroa.speculated.i3416 = phi ptr [ %1189, %1180 ], [ %1223, %1196 ]
  %.in4333 = phi <2 x i160> [ %1195, %1180 ], [ %1229, %1196 ]
  %1230 = trunc <2 x i160> %.in4333 to <2 x i64>
  %1231 = xor i1 %.070565.i3394, true
  %hash_coef_ptr.i.i143.i3419 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3416, i64 8
  %tbl_size_ptr.i.i144.i3420 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3416, i64 16
  %offset_tbl_ptr.i.i145.i3421 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3416, i64 40
  %hash_coef.i.i146.i3422 = load i64, ptr %hash_coef_ptr.i.i143.i3419, align 4
  %tbl_size.i.i147.i3423 = load i64, ptr %tbl_size_ptr.i.i144.i3420, align 4
  %offset_tbl.i.i148.i3424 = load ptr, ptr %offset_tbl_ptr.i.i145.i3421, align 8
  %product.i.i.i149.i3425 = mul i64 %hash_coef.i.i146.i3422, 4015701072841558310
  %shifted.i.i.i150.i3426 = lshr i64 %product.i.i.i149.i3425, 32
  %xored.i.i.i151.i3427 = xor i64 %shifted.i.i.i150.i3426, %product.i.i.i149.i3425
  %hash.i.i.i152.i3428 = and i64 %xored.i.i.i151.i3427, %tbl_size.i.i147.i3423
  %offset_ptr.i.i153.i3429 = getelementptr i32, ptr %offset_tbl.i.i148.i3424, i64 %hash.i.i.i152.i3428
  %offset.i.i154.i3430 = load i32, ptr %offset_ptr.i.i153.i3429, align 4
  %1232 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1233 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1234 = icmp ult i32 %.0566.i3393, 99
  br i1 %1234, label %1165, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3448

1235:                                             ; preds = %1196, %1180
  %1236 = phi ptr [ %16, %1196 ], [ %15, %1180 ]
  %1237 = load i32, ptr %65, align 4
  store i32 %1237, ptr %1236, align 4
  %1238 = add i32 %1237, 1
  %1239 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1238, ptr %65, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3448

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3448: ; preds = %.cont.cont.i3413, %1235
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i2686

._crit_edge.i2686:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3448, %1151
  %1240 = add nuw nsw i32 %.060.i2684, 1
  %1241 = icmp slt i32 %1240, %1054
  br i1 %1241, label %1151, label %CuckooMap_insert_keyK_valueV.exit

CuckooMap_insert_keyK_valueV.exit:                ; preds = %._crit_edge.i2686, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2668.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1619.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1479, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1619
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1242 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %1243 = sext i32 %.0357689 to i64
  %1244 = shl nsw i64 %1243, 2
  %1245 = getelementptr i8, ptr %result.i4.i, i64 %1244
  store i32 %72, ptr %1245, align 1
  store i1 true, ptr %.sroa.0316.sroa.0, align 8
  %.sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.0. = load i8, ptr %.sroa.0316.sroa.0, align 8
  %.sroa.0316.0.insert.ext = zext i8 %.sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.0. to i160
  %1246 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.0316.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1247 = load ptr, ptr %54, align 8
  %1248 = call i32 %1247({ ptr, i160 } %73) #7
  %1249 = load i32, ptr %56, align 8
  %1250 = add i32 %1249, -1
  %1251 = and i32 %1250, %1248
  %1252 = load ptr, ptr %57, align 8
  %1253 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1254 = sext i32 %1251 to i64
  %1255 = shl nsw i64 %1254, 5
  %1256 = getelementptr i8, ptr %1252, i64 %1255
  %1257 = load ptr, ptr %1256, align 8
  %1258 = getelementptr i8, ptr %1256, i64 8
  %1259 = icmp ne ptr %1257, @nil_typ
  %1260 = icmp ne ptr %1257, null
  %.not64.i1683 = and i1 %1259, %1260
  br i1 %.not64.i1683, label %1261, label %1359

1261:                                             ; preds = %CuckooMap_insert_keyK_valueV.exit
  %1262 = load i64, ptr %1258, align 4
  %.sroa_idx.i1685 = getelementptr i8, ptr %1256, i64 16
  %1263 = load i64, ptr %.sroa_idx.i1685, align 4
  %1264 = inttoptr i64 %1262 to ptr
  %1265 = inttoptr i64 %1263 to ptr
  %hash_coef_ptr.i.i66.i1686 = getelementptr i8, ptr %1257, i64 8
  %tbl_size_ptr.i.i67.i1687 = getelementptr i8, ptr %1257, i64 16
  %offset_tbl_ptr.i.i68.i1688 = getelementptr i8, ptr %1257, i64 40
  %hash_coef.i.i69.i1689 = load i64, ptr %hash_coef_ptr.i.i66.i1686, align 4, !noalias !362
  %tbl_size.i.i70.i1690 = load i64, ptr %tbl_size_ptr.i.i67.i1687, align 4, !noalias !362
  %offset_tbl.i.i71.i1691 = load ptr, ptr %offset_tbl_ptr.i.i68.i1688, align 8, !noalias !362
  %product.i.i.i72.i1692 = mul i64 %hash_coef.i.i69.i1689, 4015701072841558310
  %shifted.i.i.i73.i1693 = lshr i64 %product.i.i.i72.i1692, 32
  %xored.i.i.i74.i1694 = xor i64 %shifted.i.i.i73.i1693, %product.i.i.i72.i1692
  %hash.i.i.i75.i1695 = and i64 %xored.i.i.i74.i1694, %tbl_size.i.i70.i1690
  %offset_ptr.i.i76.i1696 = getelementptr i32, ptr %offset_tbl.i.i71.i1691, i64 %hash.i.i.i75.i1695
  %offset.i.i77.i1697 = load i32, ptr %offset_ptr.i.i76.i1696, align 4, !noalias !362
  %1266 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1257, 0
  %1267 = insertvalue { ptr, ptr, ptr, i32 } %1266, ptr %1264, 1
  %1268 = insertvalue { ptr, ptr, ptr, i32 } %1267, ptr %1265, 2
  %1269 = insertvalue { ptr, ptr, ptr, i32 } %1268, i32 %offset.i.i77.i1697, 3
  %1270 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1257) #35
  %1272 = sext i32 %offset.i.i77.i1697 to i64
  %1273 = getelementptr ptr, ptr %1257, i64 %1272
  %1274 = getelementptr i8, ptr %1273, i64 64
  %1275 = load ptr, ptr %1274, align 8
  %result.i.i1698 = call ptr %1275({ ptr, ptr, ptr, i32 } %1269, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1276 = call i32 %result.i.i1698({ ptr, ptr, ptr, i32 } %1269, { ptr, ptr, ptr, i32 } %1269, ptr nonnull align 8 %2) #7
  %1277 = icmp eq i32 %1276, %1248
  br i1 %1277, label %._crit_edge.i1699, label %1359

._crit_edge.i1699:                                ; preds = %1261
  %1278 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1279 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1257)
  %1280 = getelementptr i8, ptr %1273, i64 48
  %1281 = load ptr, ptr %1280, align 8
  %result.i79.i1700 = call ptr %1281({ ptr, ptr, ptr, i32 } %1269, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1282 = call { ptr, i160 } %result.i79.i1700({ ptr, ptr, ptr, i32 } %1269, { ptr, ptr, ptr, i32 } %1269, ptr nonnull align 8 %2) #7
  %1283 = load ptr, ptr %55, align 8
  %1284 = call i1 %1283({ ptr, i160 } %1282, { ptr, i160 } %73) #7
  br i1 %1284, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1712, label %1359

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1712: ; preds = %._crit_edge.i1699
  %1285 = load ptr, ptr %result.i421, align 8
  %1286 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1287 = load ptr, ptr %49, align 8
  %1288 = load ptr, ptr %1285, align 8, !alias.scope !365
  %1289 = getelementptr i8, ptr %1288, i64 72
  %1290 = load ptr, ptr %1289, align 8, !alias.scope !365
  %result.i.i.i1704 = call { i64, i64 } %1290(ptr nocapture nofree nonnull readonly %1285) #5, !alias.scope !365
  %1291 = extractvalue { i64, i64 } %result.i.i.i1704, 0
  %1292 = extractvalue { i64, i64 } %result.i.i.i1704, 1
  %1293 = urem i64 20, %1292
  %1294 = icmp eq i64 %1293, 0
  %1295 = sub i64 %1292, %1293
  %1296 = select i1 %1294, i64 0, i64 %1295
  %1297 = add i64 %1291, 20
  %1298 = add i64 %1297, %1296
  %1299 = load ptr, ptr %1287, align 8, !alias.scope !365
  %1300 = getelementptr i8, ptr %1299, i64 72
  %1301 = load ptr, ptr %1300, align 8, !alias.scope !365
  %result.i1.i.i1705 = call { i64, i64 } %1301(ptr nocapture nofree nonnull readonly %1287) #5, !alias.scope !365
  %1302 = extractvalue { i64, i64 } %result.i1.i.i1705, 0
  %1303 = extractvalue { i64, i64 } %result.i1.i.i1705, 1
  %1304 = call i64 @llvm.umax.i64(i64 %1292, i64 %1303)
  %1305 = call i64 @llvm.umax.i64(i64 %1304, i64 8)
  %1306 = urem i64 %1298, %1303
  %1307 = icmp eq i64 %1306, 0
  %1308 = sub i64 %1303, %1306
  %1309 = select i1 %1307, i64 0, i64 %1308
  %1310 = add i64 %1302, %1298
  %1311 = add i64 %1310, %1309
  %1312 = urem i64 %1311, %1305
  %1313 = icmp eq i64 %1312, 0
  %1314 = sub i64 %1305, %1312
  %1315 = select i1 %1313, i64 0, i64 %1314
  %1316 = add i64 %1315, %1311
  %result.i83.i1706 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1316, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1285, ptr %result.i83.i1706, align 8
  %1317 = getelementptr inbounds i8, ptr %result.i83.i1706, i64 8
  store ptr %1287, ptr %1317, align 8
  %1318 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1706)
  %1319 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1320 = load ptr, ptr %1285, align 8
  %1321 = getelementptr i8, ptr %1320, i64 72
  %1322 = load ptr, ptr %1321, align 8
  %result.i.i118.i1707 = call { i64, i64 } %1322(ptr nocapture nofree nonnull readonly %1285) #5
  %1323 = extractvalue { i64, i64 } %result.i.i118.i1707, 1
  %1324 = urem i64 20, %1323
  %1325 = icmp eq i64 %1324, 0
  %reass.sub = sub i64 %1323, %1324
  %1326 = add i64 %reass.sub, 20
  %1327 = select i1 %1325, i64 20, i64 %1326
  %1328 = getelementptr i8, ptr %result.i83.i1706, i64 %1327
  %1329 = getelementptr i8, ptr %1320, i64 64
  %1330 = load ptr, ptr %1329, align 8
  call void %1330({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1285, ptr nocapture nofree writeonly %1328) #1
  %1331 = load ptr, ptr %result.i83.i1706, align 8
  %1332 = load ptr, ptr %1331, align 8
  %1333 = getelementptr i8, ptr %1332, i64 72
  %1334 = load ptr, ptr %1333, align 8
  %result.i.i119.i1709 = call { i64, i64 } %1334(ptr nocapture nofree nonnull readonly %1331) #5
  %1335 = extractvalue { i64, i64 } %result.i.i119.i1709, 0
  %1336 = extractvalue { i64, i64 } %result.i.i119.i1709, 1
  %1337 = urem i64 20, %1336
  %1338 = icmp eq i64 %1337, 0
  %1339 = sub i64 %1336, %1337
  %1340 = select i1 %1338, i64 0, i64 %1339
  %1341 = add i64 %1335, 20
  %1342 = add i64 %1341, %1340
  %1343 = load ptr, ptr %1317, align 8
  %1344 = load ptr, ptr %1343, align 8
  %1345 = getelementptr i8, ptr %1344, i64 72
  %1346 = load ptr, ptr %1345, align 8
  %result.i1.i120.i1710 = call { i64, i64 } %1346(ptr nocapture nofree nonnull readonly %1343) #5
  %1347 = extractvalue { i64, i64 } %result.i1.i120.i1710, 1
  %1348 = urem i64 %1342, %1347
  %1349 = icmp eq i64 %1348, 0
  %1350 = sub i64 %1347, %1348
  %1351 = select i1 %1349, i64 0, i64 %1350
  %1352 = getelementptr i8, ptr %result.i83.i1706, i64 %1342
  %1353 = getelementptr i8, ptr %1352, i64 %1351
  %1354 = getelementptr i8, ptr %1344, i64 64
  %1355 = load ptr, ptr %1354, align 8
  call void %1355({ ptr, i160 } %1246, ptr nocapture nofree nonnull readonly %1343, ptr nocapture nofree writeonly %1353) #1
  %1356 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1357 = getelementptr inbounds i8, ptr %result.i83.i1706, i64 16
  store i32 %1248, ptr %1357, align 8
  store ptr @Entry, ptr %1256, align 8
  %1358 = ptrtoint ptr %result.i83.i1706 to i64
  store i64 %1358, ptr %1258, align 4
  %.sroa_idx28.i1711 = getelementptr i8, ptr %1256, i64 24
  store i32 10, ptr %.sroa_idx28.i1711, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit1001

1359:                                             ; preds = %._crit_edge.i1699, %CuckooMap_insert_keyK_valueV.exit, %1261
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1360 = add i32 %1248, 2127912214
  %1361 = shl i32 %1248, 12
  %1362 = add i32 %1360, %1361
  %1363 = ashr i32 %1362, 19
  %1364 = xor i32 %1362, %1363
  %1365 = xor i32 %1364, -949894596
  %1366 = add i32 %1365, 374761393
  %1367 = shl i32 %1365, 5
  %1368 = add i32 %1366, %1367
  %1369 = add i32 %1368, -744332180
  %1370 = shl i32 %1368, 9
  %1371 = xor i32 %1369, %1370
  %1372 = add i32 %1371, -42973499
  %1373 = shl i32 %1371, 3
  %1374 = add i32 %1372, %1373
  %1375 = ashr i32 %1374, 16
  %1376 = xor i32 %1374, %1375
  %1377 = xor i32 %1376, -1252372727
  %1378 = load i32, ptr %56, align 8
  %1379 = add i32 %1378, -1
  %1380 = and i32 %1379, %1377
  %1381 = load ptr, ptr %58, align 8
  %1382 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1383 = sext i32 %1380 to i64
  %1384 = shl nsw i64 %1383, 5
  %1385 = getelementptr i8, ptr %1381, i64 %1384
  %1386 = load ptr, ptr %1385, align 8
  %1387 = getelementptr i8, ptr %1385, i64 8
  %1388 = icmp ne ptr %1386, @nil_typ
  %1389 = icmp ne ptr %1386, null
  %.not64.i1742 = and i1 %1388, %1389
  br i1 %.not64.i1742, label %1390, label %1489

1390:                                             ; preds = %1359
  %1391 = load i64, ptr %1387, align 4
  %.sroa_idx.i1744 = getelementptr i8, ptr %1385, i64 16
  %1392 = load i64, ptr %.sroa_idx.i1744, align 4
  %1393 = inttoptr i64 %1391 to ptr
  %1394 = inttoptr i64 %1392 to ptr
  %hash_coef_ptr.i.i66.i1745 = getelementptr i8, ptr %1386, i64 8
  %tbl_size_ptr.i.i67.i1746 = getelementptr i8, ptr %1386, i64 16
  %offset_tbl_ptr.i.i68.i1747 = getelementptr i8, ptr %1386, i64 40
  %hash_coef.i.i69.i1748 = load i64, ptr %hash_coef_ptr.i.i66.i1745, align 4, !noalias !368
  %tbl_size.i.i70.i1749 = load i64, ptr %tbl_size_ptr.i.i67.i1746, align 4, !noalias !368
  %offset_tbl.i.i71.i1750 = load ptr, ptr %offset_tbl_ptr.i.i68.i1747, align 8, !noalias !368
  %product.i.i.i72.i1751 = mul i64 %hash_coef.i.i69.i1748, 4015701072841558310
  %shifted.i.i.i73.i1752 = lshr i64 %product.i.i.i72.i1751, 32
  %xored.i.i.i74.i1753 = xor i64 %shifted.i.i.i73.i1752, %product.i.i.i72.i1751
  %hash.i.i.i75.i1754 = and i64 %xored.i.i.i74.i1753, %tbl_size.i.i70.i1749
  %offset_ptr.i.i76.i1755 = getelementptr i32, ptr %offset_tbl.i.i71.i1750, i64 %hash.i.i.i75.i1754
  %offset.i.i77.i1756 = load i32, ptr %offset_ptr.i.i76.i1755, align 4, !noalias !368
  %1395 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1386, 0
  %1396 = insertvalue { ptr, ptr, ptr, i32 } %1395, ptr %1393, 1
  %1397 = insertvalue { ptr, ptr, ptr, i32 } %1396, ptr %1394, 2
  %1398 = insertvalue { ptr, ptr, ptr, i32 } %1397, i32 %offset.i.i77.i1756, 3
  %1399 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %1400 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1386) #35
  %1401 = sext i32 %offset.i.i77.i1756 to i64
  %1402 = getelementptr ptr, ptr %1386, i64 %1401
  %1403 = getelementptr i8, ptr %1402, i64 64
  %1404 = load ptr, ptr %1403, align 8
  %result.i.i1757 = call ptr %1404({ ptr, ptr, ptr, i32 } %1398, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1405 = call i32 %result.i.i1757({ ptr, ptr, ptr, i32 } %1398, { ptr, ptr, ptr, i32 } %1398, ptr nonnull align 8 %2) #7
  %1406 = icmp eq i32 %1405, %1248
  br i1 %1406, label %._crit_edge.i1758, label %1489

._crit_edge.i1758:                                ; preds = %1390
  %1407 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1408 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1386)
  %1409 = getelementptr i8, ptr %1402, i64 48
  %1410 = load ptr, ptr %1409, align 8
  %result.i79.i1759 = call ptr %1410({ ptr, ptr, ptr, i32 } %1398, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1411 = call { ptr, i160 } %result.i79.i1759({ ptr, ptr, ptr, i32 } %1398, { ptr, ptr, ptr, i32 } %1398, ptr nonnull align 8 %2) #7
  %1412 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1413 = load ptr, ptr %55, align 8
  %1414 = call i1 %1413({ ptr, i160 } %1411, { ptr, i160 } %73) #7
  br i1 %1414, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1771, label %1489

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1771: ; preds = %._crit_edge.i1758
  %1415 = load ptr, ptr %result.i421, align 8
  %1416 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1417 = load ptr, ptr %49, align 8
  %1418 = load ptr, ptr %1415, align 8, !alias.scope !371
  %1419 = getelementptr i8, ptr %1418, i64 72
  %1420 = load ptr, ptr %1419, align 8, !alias.scope !371
  %result.i.i.i1763 = call { i64, i64 } %1420(ptr nocapture nofree nonnull readonly %1415) #5, !alias.scope !371
  %1421 = extractvalue { i64, i64 } %result.i.i.i1763, 0
  %1422 = extractvalue { i64, i64 } %result.i.i.i1763, 1
  %1423 = urem i64 20, %1422
  %1424 = icmp eq i64 %1423, 0
  %1425 = sub i64 %1422, %1423
  %1426 = select i1 %1424, i64 0, i64 %1425
  %1427 = add i64 %1421, 20
  %1428 = add i64 %1427, %1426
  %1429 = load ptr, ptr %1417, align 8, !alias.scope !371
  %1430 = getelementptr i8, ptr %1429, i64 72
  %1431 = load ptr, ptr %1430, align 8, !alias.scope !371
  %result.i1.i.i1764 = call { i64, i64 } %1431(ptr nocapture nofree nonnull readonly %1417) #5, !alias.scope !371
  %1432 = extractvalue { i64, i64 } %result.i1.i.i1764, 0
  %1433 = extractvalue { i64, i64 } %result.i1.i.i1764, 1
  %1434 = call i64 @llvm.umax.i64(i64 %1422, i64 %1433)
  %1435 = call i64 @llvm.umax.i64(i64 %1434, i64 8)
  %1436 = urem i64 %1428, %1433
  %1437 = icmp eq i64 %1436, 0
  %1438 = sub i64 %1433, %1436
  %1439 = select i1 %1437, i64 0, i64 %1438
  %1440 = add i64 %1432, %1428
  %1441 = add i64 %1440, %1439
  %1442 = urem i64 %1441, %1435
  %1443 = icmp eq i64 %1442, 0
  %1444 = sub i64 %1435, %1442
  %1445 = select i1 %1443, i64 0, i64 %1444
  %1446 = add i64 %1445, %1441
  %result.i83.i1765 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1446, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1415, ptr %result.i83.i1765, align 8
  %1447 = getelementptr inbounds i8, ptr %result.i83.i1765, i64 8
  store ptr %1417, ptr %1447, align 8
  %1448 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i1765)
  %1449 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1450 = load ptr, ptr %1415, align 8
  %1451 = getelementptr i8, ptr %1450, i64 72
  %1452 = load ptr, ptr %1451, align 8
  %result.i.i118.i1766 = call { i64, i64 } %1452(ptr nocapture nofree nonnull readonly %1415) #5
  %1453 = extractvalue { i64, i64 } %result.i.i118.i1766, 1
  %1454 = urem i64 20, %1453
  %1455 = icmp eq i64 %1454, 0
  %reass.sub4326 = sub i64 %1453, %1454
  %1456 = add i64 %reass.sub4326, 20
  %1457 = select i1 %1455, i64 20, i64 %1456
  %1458 = getelementptr i8, ptr %result.i83.i1765, i64 %1457
  %1459 = getelementptr i8, ptr %1450, i64 64
  %1460 = load ptr, ptr %1459, align 8
  call void %1460({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1415, ptr nocapture nofree writeonly %1458) #1
  %1461 = load ptr, ptr %result.i83.i1765, align 8
  %1462 = load ptr, ptr %1461, align 8
  %1463 = getelementptr i8, ptr %1462, i64 72
  %1464 = load ptr, ptr %1463, align 8
  %result.i.i119.i1768 = call { i64, i64 } %1464(ptr nocapture nofree nonnull readonly %1461) #5
  %1465 = extractvalue { i64, i64 } %result.i.i119.i1768, 0
  %1466 = extractvalue { i64, i64 } %result.i.i119.i1768, 1
  %1467 = urem i64 20, %1466
  %1468 = icmp eq i64 %1467, 0
  %1469 = sub i64 %1466, %1467
  %1470 = select i1 %1468, i64 0, i64 %1469
  %1471 = add i64 %1465, 20
  %1472 = add i64 %1471, %1470
  %1473 = load ptr, ptr %1447, align 8
  %1474 = load ptr, ptr %1473, align 8
  %1475 = getelementptr i8, ptr %1474, i64 72
  %1476 = load ptr, ptr %1475, align 8
  %result.i1.i120.i1769 = call { i64, i64 } %1476(ptr nocapture nofree nonnull readonly %1473) #5
  %1477 = extractvalue { i64, i64 } %result.i1.i120.i1769, 1
  %1478 = urem i64 %1472, %1477
  %1479 = icmp eq i64 %1478, 0
  %1480 = sub i64 %1477, %1478
  %1481 = select i1 %1479, i64 0, i64 %1480
  %1482 = getelementptr i8, ptr %result.i83.i1765, i64 %1472
  %1483 = getelementptr i8, ptr %1482, i64 %1481
  %1484 = getelementptr i8, ptr %1474, i64 64
  %1485 = load ptr, ptr %1484, align 8
  call void %1485({ ptr, i160 } %1246, ptr nocapture nofree nonnull readonly %1473, ptr nocapture nofree writeonly %1483) #1
  %1486 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1487 = getelementptr inbounds i8, ptr %result.i83.i1765, i64 16
  store i32 %1248, ptr %1487, align 8
  store ptr @Entry, ptr %1385, align 8
  %1488 = ptrtoint ptr %result.i83.i1765 to i64
  store i64 %1488, ptr %1387, align 4
  %.sroa_idx28.i1770 = getelementptr i8, ptr %1385, i64 24
  store i32 10, ptr %.sroa_idx28.i1770, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %CuckooMap_insert_keyK_valueV.exit1001

1489:                                             ; preds = %._crit_edge.i1758, %1359, %1390
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1490 = load i32, ptr %66, align 4
  %1491 = load i32, ptr %56, align 8
  %.not.i959 = icmp slt i32 %1490, %1491
  br i1 %.not.i959, label %._crit_edge.i961, label %1492

1492:                                             ; preds = %1489
  %1493 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1494 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1495 = load ptr, ptr %57, align 8
  %1496 = load ptr, ptr %58, align 8
  %1497 = shl i32 %1491, 1
  %spec.select.i1787 = call i32 @llvm.smax.i32(i32 %1497, i32 16)
  store i32 %spec.select.i1787, ptr %56, align 8
  %1498 = zext nneg i32 %spec.select.i1787 to i64
  %1499 = shl nuw nsw i64 %1498, 5
  %result.i.i1788 = call noalias ptr @bump_malloc_inner(i64 noundef %1499, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1788, ptr %57, align 8
  %result.i20.i1789 = call noalias ptr @bump_malloc_inner(i64 noundef %1499, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1789, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %1500 = icmp sgt i32 %1491, 0
  br i1 %1500, label %.lr.ph.i2707, label %._crit_edge.i961

.lr.ph.i2707:                                     ; preds = %1492, %._crit_edge.i2722
  %.060.i2720 = phi i32 [ %1589, %._crit_edge.i2722 ], [ 0, %1492 ]
  %1501 = zext nneg i32 %.060.i2720 to i64
  %1502 = shl nuw nsw i64 %1501, 5
  %1503 = getelementptr i8, ptr %1495, i64 %1502
  %1504 = load ptr, ptr %1503, align 8
  %1505 = icmp ne ptr %1504, @nil_typ
  %1506 = icmp ne ptr %1504, null
  %.not16.i2721 = and i1 %1505, %1506
  br i1 %.not16.i2721, label %1507, label %._crit_edge.i2722

1507:                                             ; preds = %.lr.ph.i2707
  %1508 = getelementptr i8, ptr %1503, i64 8
  %1509 = load <2 x i64>, ptr %1508, align 4
  %hash_coef_ptr.i.i18.i2724 = getelementptr i8, ptr %1504, i64 8
  %tbl_size_ptr.i.i19.i2725 = getelementptr i8, ptr %1504, i64 16
  %offset_tbl_ptr.i.i20.i2726 = getelementptr i8, ptr %1504, i64 40
  %1510 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i3466 = load i64, ptr %hash_coef_ptr.i.i18.i2724, align 4, !noalias !22
  %tbl_size.i.i100.i3467 = load i64, ptr %tbl_size_ptr.i.i19.i2725, align 4, !noalias !22
  %offset_tbl.i.i101.i3468 = load ptr, ptr %offset_tbl_ptr.i.i20.i2726, align 8, !noalias !22
  %product.i.i.i102.i3469 = mul i64 %hash_coef.i.i99.i3466, 4015701072841558310
  %shifted.i.i.i103.i3470 = lshr i64 %product.i.i.i102.i3469, 32
  %xored.i.i.i104.i3471 = xor i64 %shifted.i.i.i103.i3470, %product.i.i.i102.i3469
  %hash.i.i.i105.i3472 = and i64 %xored.i.i.i104.i3471, %tbl_size.i.i100.i3467
  %offset_ptr.i.i106.i3473 = getelementptr i32, ptr %offset_tbl.i.i101.i3468, i64 %hash.i.i.i105.i3472
  %offset.i.i121.i3474 = load i32, ptr %offset_ptr.i.i106.i3473, align 4, !noalias !374
  %1511 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1512 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1513 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1514

1514:                                             ; preds = %.cont.cont.i3495, %1507
  %.0566.i3475 = phi i32 [ 0, %1507 ], [ %1518, %.cont.cont.i3495 ]
  %.070565.i3476 = phi i1 [ true, %1507 ], [ %1580, %.cont.cont.i3495 ]
  %.sroa.0.0564.i3477 = phi ptr [ %1504, %1507 ], [ %vptr.i142.sroa.speculated.i3498, %.cont.cont.i3495 ]
  %.sroa.17.0561.i3480 = phi i32 [ %offset.i.i121.i3474, %1507 ], [ %offset.i.i154.i3512, %.cont.cont.i3495 ]
  %1515 = phi <2 x i64> [ %1509, %1507 ], [ %1579, %.cont.cont.i3495 ]
  %1516 = extractelement <2 x i64> %1515, i64 1
  %.sroa.12.0562.i3479 = inttoptr i64 %1516 to ptr
  %1517 = extractelement <2 x i64> %1515, i64 0
  %.sroa.6.0563.i3478 = inttoptr i64 %1517 to ptr
  %1518 = add nuw nsw i32 %.0566.i3475, 1
  %1519 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3477, 0
  %1520 = insertvalue { ptr, ptr, ptr, i32 } %1519, ptr %.sroa.6.0563.i3478, 1
  %1521 = insertvalue { ptr, ptr, ptr, i32 } %1520, ptr %.sroa.12.0562.i3479, 2
  %1522 = insertvalue { ptr, ptr, ptr, i32 } %1521, i32 %.sroa.17.0561.i3480, 3
  %1523 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3477)
  %1524 = sext i32 %.sroa.17.0561.i3480 to i64
  %1525 = getelementptr ptr, ptr %.sroa.0.0564.i3477, i64 %1524
  %1526 = getelementptr i8, ptr %1525, i64 64
  %1527 = load ptr, ptr %1526, align 8
  %result.i125.i3481 = call ptr %1527({ ptr, ptr, ptr, i32 } %1522, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1528 = call i32 %result.i125.i3481({ ptr, ptr, ptr, i32 } %1522, { ptr, ptr, ptr, i32 } %1522, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3476, label %1529, label %1545

1529:                                             ; preds = %1514
  %1530 = load i32, ptr %56, align 8
  %1531 = add i32 %1530, -1
  %1532 = and i32 %1531, %1528
  %1533 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1534 = load ptr, ptr %57, align 8
  %1535 = sext i32 %1532 to i64
  %1536 = shl nsw i64 %1535, 5
  %1537 = getelementptr i8, ptr %1534, i64 %1536
  %1538 = load ptr, ptr %1537, align 8
  %1539 = getelementptr i8, ptr %1537, i64 8
  %1540 = load i160, ptr %1539, align 4
  store ptr %.sroa.0.0564.i3477, ptr %1537, align 8
  store i64 %1517, ptr %1539, align 4
  %.sroa_idx157.i3524 = getelementptr i8, ptr %1537, i64 16
  store i64 %1516, ptr %.sroa_idx157.i3524, align 4
  %.sroa_idx158.i3525 = getelementptr i8, ptr %1537, i64 24
  store i32 %.sroa.17.0561.i3480, ptr %.sroa_idx158.i3525, align 4
  %1541 = icmp ne ptr %1538, @nil_typ
  %1542 = icmp ne ptr %1538, null
  %.not92.i3526 = and i1 %1541, %1542
  %extract.i3528 = lshr i160 %1540, 64
  %1543 = insertelement <2 x i160> poison, i160 %1540, i64 0
  %1544 = insertelement <2 x i160> %1543, i160 %extract.i3528, i64 1
  br i1 %.not92.i3526, label %.cont.cont.i3495, label %1584

1545:                                             ; preds = %1514
  %1546 = add i32 %1528, 2127912214
  %1547 = shl i32 %1528, 12
  %1548 = add i32 %1546, %1547
  %1549 = ashr i32 %1548, 19
  %1550 = xor i32 %1548, %1549
  %1551 = xor i32 %1550, -949894596
  %1552 = add i32 %1551, 374761393
  %1553 = shl i32 %1551, 5
  %1554 = add i32 %1552, %1553
  %1555 = add i32 %1554, -744332180
  %1556 = shl i32 %1554, 9
  %1557 = xor i32 %1555, %1556
  %1558 = add i32 %1557, -42973499
  %1559 = shl i32 %1557, 3
  %1560 = add i32 %1558, %1559
  %1561 = ashr i32 %1560, 16
  %1562 = xor i32 %1560, %1561
  %1563 = xor i32 %1562, -1252372727
  %1564 = load i32, ptr %56, align 8
  %1565 = add i32 %1564, -1
  %1566 = and i32 %1565, %1563
  %1567 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1568 = load ptr, ptr %58, align 8
  %1569 = sext i32 %1566 to i64
  %1570 = shl nsw i64 %1569, 5
  %1571 = getelementptr i8, ptr %1568, i64 %1570
  %1572 = load ptr, ptr %1571, align 8
  %1573 = getelementptr i8, ptr %1571, i64 8
  %1574 = load i160, ptr %1573, align 4
  store ptr %.sroa.0.0564.i3477, ptr %1571, align 8
  store i64 %1517, ptr %1573, align 4
  %.sroa_idx161.i3485 = getelementptr i8, ptr %1571, i64 16
  store i64 %1516, ptr %.sroa_idx161.i3485, align 4
  %.sroa_idx162.i3486 = getelementptr i8, ptr %1571, i64 24
  store i32 %.sroa.17.0561.i3480, ptr %.sroa_idx162.i3486, align 4
  %1575 = icmp ne ptr %1572, @nil_typ
  %1576 = icmp ne ptr %1572, null
  %.not90.i3487 = and i1 %1575, %1576
  %extract607.i3489 = lshr i160 %1574, 64
  %1577 = insertelement <2 x i160> poison, i160 %1574, i64 0
  %1578 = insertelement <2 x i160> %1577, i160 %extract607.i3489, i64 1
  br i1 %.not90.i3487, label %.cont.cont.i3495, label %1584

.cont.cont.i3495:                                 ; preds = %1545, %1529
  %vptr.i142.sroa.speculated.i3498 = phi ptr [ %1538, %1529 ], [ %1572, %1545 ]
  %.in4334 = phi <2 x i160> [ %1544, %1529 ], [ %1578, %1545 ]
  %1579 = trunc <2 x i160> %.in4334 to <2 x i64>
  %1580 = xor i1 %.070565.i3476, true
  %hash_coef_ptr.i.i143.i3501 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3498, i64 8
  %tbl_size_ptr.i.i144.i3502 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3498, i64 16
  %offset_tbl_ptr.i.i145.i3503 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3498, i64 40
  %hash_coef.i.i146.i3504 = load i64, ptr %hash_coef_ptr.i.i143.i3501, align 4
  %tbl_size.i.i147.i3505 = load i64, ptr %tbl_size_ptr.i.i144.i3502, align 4
  %offset_tbl.i.i148.i3506 = load ptr, ptr %offset_tbl_ptr.i.i145.i3503, align 8
  %product.i.i.i149.i3507 = mul i64 %hash_coef.i.i146.i3504, 4015701072841558310
  %shifted.i.i.i150.i3508 = lshr i64 %product.i.i.i149.i3507, 32
  %xored.i.i.i151.i3509 = xor i64 %shifted.i.i.i150.i3508, %product.i.i.i149.i3507
  %hash.i.i.i152.i3510 = and i64 %xored.i.i.i151.i3509, %tbl_size.i.i147.i3505
  %offset_ptr.i.i153.i3511 = getelementptr i32, ptr %offset_tbl.i.i148.i3506, i64 %hash.i.i.i152.i3510
  %offset.i.i154.i3512 = load i32, ptr %offset_ptr.i.i153.i3511, align 4
  %1581 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1582 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1583 = icmp ult i32 %.0566.i3475, 99
  br i1 %1583, label %1514, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3530

1584:                                             ; preds = %1545, %1529
  %1585 = phi ptr [ %14, %1545 ], [ %13, %1529 ]
  %1586 = load i32, ptr %66, align 4
  store i32 %1586, ptr %1585, align 4
  %1587 = add i32 %1586, 1
  %1588 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1587, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3530

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3530: ; preds = %.cont.cont.i3495, %1584
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i2722

._crit_edge.i2722:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3530, %.lr.ph.i2707
  %1589 = add nuw nsw i32 %.060.i2720, 1
  %1590 = icmp slt i32 %1589, %1491
  br i1 %1590, label %.lr.ph.i2707, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740: ; preds = %._crit_edge.i2722, %._crit_edge.i2758
  %.060.i2756 = phi i32 [ %1679, %._crit_edge.i2758 ], [ 0, %._crit_edge.i2722 ]
  %1591 = zext nneg i32 %.060.i2756 to i64
  %1592 = shl nuw nsw i64 %1591, 5
  %1593 = getelementptr i8, ptr %1496, i64 %1592
  %1594 = load ptr, ptr %1593, align 8
  %1595 = icmp ne ptr %1594, @nil_typ
  %1596 = icmp ne ptr %1594, null
  %.not16.i2757 = and i1 %1595, %1596
  br i1 %.not16.i2757, label %1597, label %._crit_edge.i2758

1597:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740
  %1598 = getelementptr i8, ptr %1593, i64 8
  %1599 = load <2 x i64>, ptr %1598, align 4
  %hash_coef_ptr.i.i18.i2760 = getelementptr i8, ptr %1594, i64 8
  %tbl_size_ptr.i.i19.i2761 = getelementptr i8, ptr %1594, i64 16
  %offset_tbl_ptr.i.i20.i2762 = getelementptr i8, ptr %1594, i64 40
  %1600 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %hash_coef.i.i99.i3548 = load i64, ptr %hash_coef_ptr.i.i18.i2760, align 4, !noalias !22
  %tbl_size.i.i100.i3549 = load i64, ptr %tbl_size_ptr.i.i19.i2761, align 4, !noalias !22
  %offset_tbl.i.i101.i3550 = load ptr, ptr %offset_tbl_ptr.i.i20.i2762, align 8, !noalias !22
  %product.i.i.i102.i3551 = mul i64 %hash_coef.i.i99.i3548, 4015701072841558310
  %shifted.i.i.i103.i3552 = lshr i64 %product.i.i.i102.i3551, 32
  %xored.i.i.i104.i3553 = xor i64 %shifted.i.i.i103.i3552, %product.i.i.i102.i3551
  %hash.i.i.i105.i3554 = and i64 %xored.i.i.i104.i3553, %tbl_size.i.i100.i3549
  %offset_ptr.i.i106.i3555 = getelementptr i32, ptr %offset_tbl.i.i101.i3550, i64 %hash.i.i.i105.i3554
  %offset.i.i121.i3556 = load i32, ptr %offset_ptr.i.i106.i3555, align 4, !noalias !377
  %1601 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1602 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1603 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1604

1604:                                             ; preds = %.cont.cont.i3577, %1597
  %.0566.i3557 = phi i32 [ 0, %1597 ], [ %1608, %.cont.cont.i3577 ]
  %.070565.i3558 = phi i1 [ true, %1597 ], [ %1670, %.cont.cont.i3577 ]
  %.sroa.0.0564.i3559 = phi ptr [ %1594, %1597 ], [ %vptr.i142.sroa.speculated.i3580, %.cont.cont.i3577 ]
  %.sroa.17.0561.i3562 = phi i32 [ %offset.i.i121.i3556, %1597 ], [ %offset.i.i154.i3594, %.cont.cont.i3577 ]
  %1605 = phi <2 x i64> [ %1599, %1597 ], [ %1669, %.cont.cont.i3577 ]
  %1606 = extractelement <2 x i64> %1605, i64 1
  %.sroa.12.0562.i3561 = inttoptr i64 %1606 to ptr
  %1607 = extractelement <2 x i64> %1605, i64 0
  %.sroa.6.0563.i3560 = inttoptr i64 %1607 to ptr
  %1608 = add nuw nsw i32 %.0566.i3557, 1
  %1609 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3559, 0
  %1610 = insertvalue { ptr, ptr, ptr, i32 } %1609, ptr %.sroa.6.0563.i3560, 1
  %1611 = insertvalue { ptr, ptr, ptr, i32 } %1610, ptr %.sroa.12.0562.i3561, 2
  %1612 = insertvalue { ptr, ptr, ptr, i32 } %1611, i32 %.sroa.17.0561.i3562, 3
  %1613 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3559)
  %1614 = sext i32 %.sroa.17.0561.i3562 to i64
  %1615 = getelementptr ptr, ptr %.sroa.0.0564.i3559, i64 %1614
  %1616 = getelementptr i8, ptr %1615, i64 64
  %1617 = load ptr, ptr %1616, align 8
  %result.i125.i3563 = call ptr %1617({ ptr, ptr, ptr, i32 } %1612, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1618 = call i32 %result.i125.i3563({ ptr, ptr, ptr, i32 } %1612, { ptr, ptr, ptr, i32 } %1612, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3558, label %1619, label %1635

1619:                                             ; preds = %1604
  %1620 = load i32, ptr %56, align 8
  %1621 = add i32 %1620, -1
  %1622 = and i32 %1621, %1618
  %1623 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1624 = load ptr, ptr %57, align 8
  %1625 = sext i32 %1622 to i64
  %1626 = shl nsw i64 %1625, 5
  %1627 = getelementptr i8, ptr %1624, i64 %1626
  %1628 = load ptr, ptr %1627, align 8
  %1629 = getelementptr i8, ptr %1627, i64 8
  %1630 = load i160, ptr %1629, align 4
  store ptr %.sroa.0.0564.i3559, ptr %1627, align 8
  store i64 %1607, ptr %1629, align 4
  %.sroa_idx157.i3606 = getelementptr i8, ptr %1627, i64 16
  store i64 %1606, ptr %.sroa_idx157.i3606, align 4
  %.sroa_idx158.i3607 = getelementptr i8, ptr %1627, i64 24
  store i32 %.sroa.17.0561.i3562, ptr %.sroa_idx158.i3607, align 4
  %1631 = icmp ne ptr %1628, @nil_typ
  %1632 = icmp ne ptr %1628, null
  %.not92.i3608 = and i1 %1631, %1632
  %extract.i3610 = lshr i160 %1630, 64
  %1633 = insertelement <2 x i160> poison, i160 %1630, i64 0
  %1634 = insertelement <2 x i160> %1633, i160 %extract.i3610, i64 1
  br i1 %.not92.i3608, label %.cont.cont.i3577, label %1674

1635:                                             ; preds = %1604
  %1636 = add i32 %1618, 2127912214
  %1637 = shl i32 %1618, 12
  %1638 = add i32 %1636, %1637
  %1639 = ashr i32 %1638, 19
  %1640 = xor i32 %1638, %1639
  %1641 = xor i32 %1640, -949894596
  %1642 = add i32 %1641, 374761393
  %1643 = shl i32 %1641, 5
  %1644 = add i32 %1642, %1643
  %1645 = add i32 %1644, -744332180
  %1646 = shl i32 %1644, 9
  %1647 = xor i32 %1645, %1646
  %1648 = add i32 %1647, -42973499
  %1649 = shl i32 %1647, 3
  %1650 = add i32 %1648, %1649
  %1651 = ashr i32 %1650, 16
  %1652 = xor i32 %1650, %1651
  %1653 = xor i32 %1652, -1252372727
  %1654 = load i32, ptr %56, align 8
  %1655 = add i32 %1654, -1
  %1656 = and i32 %1655, %1653
  %1657 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1658 = load ptr, ptr %58, align 8
  %1659 = sext i32 %1656 to i64
  %1660 = shl nsw i64 %1659, 5
  %1661 = getelementptr i8, ptr %1658, i64 %1660
  %1662 = load ptr, ptr %1661, align 8
  %1663 = getelementptr i8, ptr %1661, i64 8
  %1664 = load i160, ptr %1663, align 4
  store ptr %.sroa.0.0564.i3559, ptr %1661, align 8
  store i64 %1607, ptr %1663, align 4
  %.sroa_idx161.i3567 = getelementptr i8, ptr %1661, i64 16
  store i64 %1606, ptr %.sroa_idx161.i3567, align 4
  %.sroa_idx162.i3568 = getelementptr i8, ptr %1661, i64 24
  store i32 %.sroa.17.0561.i3562, ptr %.sroa_idx162.i3568, align 4
  %1665 = icmp ne ptr %1662, @nil_typ
  %1666 = icmp ne ptr %1662, null
  %.not90.i3569 = and i1 %1665, %1666
  %extract607.i3571 = lshr i160 %1664, 64
  %1667 = insertelement <2 x i160> poison, i160 %1664, i64 0
  %1668 = insertelement <2 x i160> %1667, i160 %extract607.i3571, i64 1
  br i1 %.not90.i3569, label %.cont.cont.i3577, label %1674

.cont.cont.i3577:                                 ; preds = %1635, %1619
  %vptr.i142.sroa.speculated.i3580 = phi ptr [ %1628, %1619 ], [ %1662, %1635 ]
  %.in4335 = phi <2 x i160> [ %1634, %1619 ], [ %1668, %1635 ]
  %1669 = trunc <2 x i160> %.in4335 to <2 x i64>
  %1670 = xor i1 %.070565.i3558, true
  %hash_coef_ptr.i.i143.i3583 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3580, i64 8
  %tbl_size_ptr.i.i144.i3584 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3580, i64 16
  %offset_tbl_ptr.i.i145.i3585 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3580, i64 40
  %hash_coef.i.i146.i3586 = load i64, ptr %hash_coef_ptr.i.i143.i3583, align 4
  %tbl_size.i.i147.i3587 = load i64, ptr %tbl_size_ptr.i.i144.i3584, align 4
  %offset_tbl.i.i148.i3588 = load ptr, ptr %offset_tbl_ptr.i.i145.i3585, align 8
  %product.i.i.i149.i3589 = mul i64 %hash_coef.i.i146.i3586, 4015701072841558310
  %shifted.i.i.i150.i3590 = lshr i64 %product.i.i.i149.i3589, 32
  %xored.i.i.i151.i3591 = xor i64 %shifted.i.i.i150.i3590, %product.i.i.i149.i3589
  %hash.i.i.i152.i3592 = and i64 %xored.i.i.i151.i3591, %tbl_size.i.i147.i3587
  %offset_ptr.i.i153.i3593 = getelementptr i32, ptr %offset_tbl.i.i148.i3588, i64 %hash.i.i.i152.i3592
  %offset.i.i154.i3594 = load i32, ptr %offset_ptr.i.i153.i3593, align 4
  %1671 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1673 = icmp ult i32 %.0566.i3557, 99
  br i1 %1673, label %1604, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3612

1674:                                             ; preds = %1635, %1619
  %1675 = phi ptr [ %12, %1635 ], [ %11, %1619 ]
  %1676 = load i32, ptr %66, align 4
  store i32 %1676, ptr %1675, align 4
  %1677 = add i32 %1676, 1
  %1678 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1677, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3612

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3612: ; preds = %.cont.cont.i3577, %1674
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %._crit_edge.i2758

._crit_edge.i2758:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3612, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740
  %1679 = add nuw nsw i32 %.060.i2756, 1
  %1680 = icmp slt i32 %1679, %1491
  br i1 %1680, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2740, label %._crit_edge.i961

._crit_edge.i961:                                 ; preds = %._crit_edge.i2758, %1492, %1489
  %1681 = load ptr, ptr %result.i421, align 8
  %1682 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1683 = load ptr, ptr %49, align 8
  %1684 = load ptr, ptr %1681, align 8
  %1685 = getelementptr i8, ptr %1684, i64 72
  %1686 = load ptr, ptr %1685, align 8
  %result.i.i.i964 = call { i64, i64 } %1686(ptr nocapture nofree nonnull readonly %1681) #5
  %1687 = extractvalue { i64, i64 } %result.i.i.i964, 0
  %1688 = extractvalue { i64, i64 } %result.i.i.i964, 1
  %1689 = urem i64 20, %1688
  %1690 = icmp eq i64 %1689, 0
  %1691 = sub i64 %1688, %1689
  %1692 = select i1 %1690, i64 0, i64 %1691
  %1693 = add i64 %1687, 20
  %1694 = add i64 %1693, %1692
  %1695 = load ptr, ptr %1683, align 8
  %1696 = getelementptr i8, ptr %1695, i64 72
  %1697 = load ptr, ptr %1696, align 8
  %result.i1.i.i965 = call { i64, i64 } %1697(ptr nocapture nofree nonnull readonly %1683) #5
  %1698 = extractvalue { i64, i64 } %result.i1.i.i965, 0
  %1699 = extractvalue { i64, i64 } %result.i1.i.i965, 1
  %1700 = call i64 @llvm.umax.i64(i64 %1688, i64 %1699)
  %1701 = call i64 @llvm.umax.i64(i64 %1700, i64 8)
  %1702 = urem i64 %1694, %1699
  %1703 = icmp eq i64 %1702, 0
  %1704 = sub i64 %1699, %1702
  %1705 = select i1 %1703, i64 0, i64 %1704
  %1706 = add i64 %1698, %1694
  %1707 = add i64 %1706, %1705
  %1708 = urem i64 %1707, %1701
  %1709 = icmp eq i64 %1708, 0
  %1710 = sub i64 %1701, %1708
  %1711 = select i1 %1709, i64 0, i64 %1710
  %1712 = add i64 %1711, %1707
  %result.i90.i966 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1712, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1681, ptr %result.i90.i966, align 8
  %1713 = getelementptr inbounds i8, ptr %result.i90.i966, i64 8
  store ptr %1683, ptr %1713, align 8
  %1714 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i966)
  %1715 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1716 = load ptr, ptr %1681, align 8
  %1717 = getelementptr i8, ptr %1716, i64 72
  %1718 = load ptr, ptr %1717, align 8
  %result.i.i196.i967 = call { i64, i64 } %1718(ptr nocapture nofree nonnull readonly %1681) #5
  %1719 = extractvalue { i64, i64 } %result.i.i196.i967, 1
  %1720 = urem i64 20, %1719
  %1721 = icmp eq i64 %1720, 0
  %reass.sub4325 = sub i64 %1719, %1720
  %1722 = add i64 %reass.sub4325, 20
  %1723 = select i1 %1721, i64 20, i64 %1722
  %1724 = getelementptr i8, ptr %result.i90.i966, i64 %1723
  %1725 = getelementptr i8, ptr %1716, i64 64
  %1726 = load ptr, ptr %1725, align 8
  call void %1726({ ptr, i160 } %73, ptr nocapture nofree nonnull readonly %1681, ptr nocapture nofree writeonly %1724) #1
  %1727 = load ptr, ptr %result.i90.i966, align 8
  %1728 = load ptr, ptr %1727, align 8
  %1729 = getelementptr i8, ptr %1728, i64 72
  %1730 = load ptr, ptr %1729, align 8
  %result.i.i197.i969 = call { i64, i64 } %1730(ptr nocapture nofree nonnull readonly %1727) #5
  %1731 = extractvalue { i64, i64 } %result.i.i197.i969, 0
  %1732 = extractvalue { i64, i64 } %result.i.i197.i969, 1
  %1733 = urem i64 20, %1732
  %1734 = icmp eq i64 %1733, 0
  %1735 = sub i64 %1732, %1733
  %1736 = select i1 %1734, i64 0, i64 %1735
  %1737 = add i64 %1731, 20
  %1738 = add i64 %1737, %1736
  %1739 = load ptr, ptr %1713, align 8
  %1740 = load ptr, ptr %1739, align 8
  %1741 = getelementptr i8, ptr %1740, i64 72
  %1742 = load ptr, ptr %1741, align 8
  %result.i1.i198.i970 = call { i64, i64 } %1742(ptr nocapture nofree nonnull readonly %1739) #5
  %1743 = extractvalue { i64, i64 } %result.i1.i198.i970, 1
  %1744 = urem i64 %1738, %1743
  %1745 = icmp eq i64 %1744, 0
  %1746 = sub i64 %1743, %1744
  %1747 = select i1 %1745, i64 0, i64 %1746
  %1748 = getelementptr i8, ptr %result.i90.i966, i64 %1738
  %1749 = getelementptr i8, ptr %1748, i64 %1747
  %1750 = getelementptr i8, ptr %1740, i64 64
  %1751 = load ptr, ptr %1750, align 8
  call void %1751({ ptr, i160 } %1246, ptr nocapture nofree nonnull readonly %1739, ptr nocapture nofree writeonly %1749) #1
  %1752 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1753 = getelementptr inbounds i8, ptr %result.i90.i966, i64 16
  store i32 %1248, ptr %1753, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %30)
  %1754 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1755 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1756 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1757

1757:                                             ; preds = %.cont.cont.i1842, %._crit_edge.i961
  %.0566.i1822 = phi i32 [ 0, %._crit_edge.i961 ], [ %1758, %.cont.cont.i1842 ]
  %.070565.i1823 = phi i1 [ true, %._crit_edge.i961 ], [ %1824, %.cont.cont.i1842 ]
  %.sroa.0.0564.i1824 = phi ptr [ @Entry, %._crit_edge.i961 ], [ %vptr.i142.sroa.speculated.i1845, %.cont.cont.i1842 ]
  %.sroa.6.0563.i1825 = phi ptr [ %result.i90.i966, %._crit_edge.i961 ], [ %spec.select539.i1847, %.cont.cont.i1842 ]
  %.sroa.12.0562.i1826 = phi ptr [ undef, %._crit_edge.i961 ], [ %spec.select.i1846, %.cont.cont.i1842 ]
  %.sroa.17.0561.i1827 = phi i32 [ 10, %._crit_edge.i961 ], [ %offset.i.i154.i1859, %.cont.cont.i1842 ]
  %1758 = add nuw nsw i32 %.0566.i1822, 1
  %1759 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1824, 0
  %1760 = insertvalue { ptr, ptr, ptr, i32 } %1759, ptr %.sroa.6.0563.i1825, 1
  %1761 = insertvalue { ptr, ptr, ptr, i32 } %1760, ptr %.sroa.12.0562.i1826, 2
  %1762 = insertvalue { ptr, ptr, ptr, i32 } %1761, i32 %.sroa.17.0561.i1827, 3
  %1763 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1824)
  %1764 = sext i32 %.sroa.17.0561.i1827 to i64
  %1765 = getelementptr ptr, ptr %.sroa.0.0564.i1824, i64 %1764
  %1766 = getelementptr i8, ptr %1765, i64 64
  %1767 = load ptr, ptr %1766, align 8
  %result.i125.i1828 = call ptr %1767({ ptr, ptr, ptr, i32 } %1762, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1768 = call i32 %result.i125.i1828({ ptr, ptr, ptr, i32 } %1762, { ptr, ptr, ptr, i32 } %1762, ptr nonnull align 8 %2) #7
  %1769 = ptrtoint ptr %.sroa.6.0563.i1825 to i64
  %1770 = ptrtoint ptr %.sroa.12.0562.i1826 to i64
  br i1 %.070565.i1823, label %1771, label %1787

1771:                                             ; preds = %1757
  %1772 = load i32, ptr %56, align 8
  %1773 = add i32 %1772, -1
  %1774 = and i32 %1773, %1768
  %1775 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1776 = load ptr, ptr %57, align 8
  %1777 = sext i32 %1774 to i64
  %1778 = shl nsw i64 %1777, 5
  %1779 = getelementptr i8, ptr %1776, i64 %1778
  %1780 = load ptr, ptr %1779, align 8
  %1781 = getelementptr i8, ptr %1779, i64 8
  %1782 = load i160, ptr %1781, align 4
  store ptr %.sroa.0.0564.i1824, ptr %1779, align 8
  store i64 %1769, ptr %1781, align 4
  %.sroa_idx157.i1871 = getelementptr i8, ptr %1779, i64 16
  store i64 %1770, ptr %.sroa_idx157.i1871, align 4
  %.sroa_idx158.i1872 = getelementptr i8, ptr %1779, i64 24
  store i32 %.sroa.17.0561.i1827, ptr %.sroa_idx158.i1872, align 4
  %1783 = icmp ne ptr %1780, @nil_typ
  %1784 = icmp ne ptr %1780, null
  %.not92.i1873 = and i1 %1783, %1784
  %extract.i1875 = lshr i160 %1782, 64
  %1785 = insertelement <2 x i160> poison, i160 %1782, i64 0
  %1786 = insertelement <2 x i160> %1785, i160 %extract.i1875, i64 1
  br i1 %.not92.i1873, label %.cont.cont.i1842, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1877.thread

1787:                                             ; preds = %1757
  %1788 = add i32 %1768, 2127912214
  %1789 = shl i32 %1768, 12
  %1790 = add i32 %1788, %1789
  %1791 = ashr i32 %1790, 19
  %1792 = xor i32 %1790, %1791
  %1793 = xor i32 %1792, -949894596
  %1794 = add i32 %1793, 374761393
  %1795 = shl i32 %1793, 5
  %1796 = add i32 %1794, %1795
  %1797 = add i32 %1796, -744332180
  %1798 = shl i32 %1796, 9
  %1799 = xor i32 %1797, %1798
  %1800 = add i32 %1799, -42973499
  %1801 = shl i32 %1799, 3
  %1802 = add i32 %1800, %1801
  %1803 = ashr i32 %1802, 16
  %1804 = xor i32 %1802, %1803
  %1805 = xor i32 %1804, -1252372727
  %1806 = load i32, ptr %56, align 8
  %1807 = add i32 %1806, -1
  %1808 = and i32 %1807, %1805
  %1809 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1810 = load ptr, ptr %58, align 8
  %1811 = sext i32 %1808 to i64
  %1812 = shl nsw i64 %1811, 5
  %1813 = getelementptr i8, ptr %1810, i64 %1812
  %1814 = load ptr, ptr %1813, align 8
  %1815 = getelementptr i8, ptr %1813, i64 8
  %1816 = load i160, ptr %1815, align 4
  store ptr %.sroa.0.0564.i1824, ptr %1813, align 8
  store i64 %1769, ptr %1815, align 4
  %.sroa_idx161.i1832 = getelementptr i8, ptr %1813, i64 16
  store i64 %1770, ptr %.sroa_idx161.i1832, align 4
  %.sroa_idx162.i1833 = getelementptr i8, ptr %1813, i64 24
  store i32 %.sroa.17.0561.i1827, ptr %.sroa_idx162.i1833, align 4
  %1817 = icmp ne ptr %1814, @nil_typ
  %1818 = icmp ne ptr %1814, null
  %.not90.i1834 = and i1 %1817, %1818
  %extract607.i1836 = lshr i160 %1816, 64
  %1819 = insertelement <2 x i160> poison, i160 %1816, i64 0
  %1820 = insertelement <2 x i160> %1819, i160 %extract607.i1836, i64 1
  br i1 %.not90.i1834, label %.cont.cont.i1842, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1877.thread

.cont.cont.i1842:                                 ; preds = %1787, %1771
  %vptr.i142.sroa.speculated.i1845 = phi ptr [ %1780, %1771 ], [ %1814, %1787 ]
  %.in4336 = phi <2 x i160> [ %1786, %1771 ], [ %1820, %1787 ]
  %1821 = trunc <2 x i160> %.in4336 to <2 x i64>
  %1822 = extractelement <2 x i64> %1821, i64 1
  %spec.select.i1846 = inttoptr i64 %1822 to ptr
  %1823 = extractelement <2 x i64> %1821, i64 0
  %spec.select539.i1847 = inttoptr i64 %1823 to ptr
  %1824 = xor i1 %.070565.i1823, true
  %hash_coef_ptr.i.i143.i1848 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1845, i64 8
  %tbl_size_ptr.i.i144.i1849 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1845, i64 16
  %offset_tbl_ptr.i.i145.i1850 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1845, i64 40
  %hash_coef.i.i146.i1851 = load i64, ptr %hash_coef_ptr.i.i143.i1848, align 4
  %tbl_size.i.i147.i1852 = load i64, ptr %tbl_size_ptr.i.i144.i1849, align 4
  %offset_tbl.i.i148.i1853 = load ptr, ptr %offset_tbl_ptr.i.i145.i1850, align 8
  %product.i.i.i149.i1854 = mul i64 %hash_coef.i.i146.i1851, 4015701072841558310
  %shifted.i.i.i150.i1855 = lshr i64 %product.i.i.i149.i1854, 32
  %xored.i.i.i151.i1856 = xor i64 %shifted.i.i.i150.i1855, %product.i.i.i149.i1854
  %hash.i.i.i152.i1857 = and i64 %xored.i.i.i151.i1856, %tbl_size.i.i147.i1852
  %offset_ptr.i.i153.i1858 = getelementptr i32, ptr %offset_tbl.i.i148.i1853, i64 %hash.i.i.i152.i1857
  %offset.i.i154.i1859 = load i32, ptr %offset_ptr.i.i153.i1858, align 4
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1826 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1827 = icmp ult i32 %.0566.i1822, 99
  br i1 %1827, label %1757, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1877

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1877.thread: ; preds = %1771, %1787
  %1828 = phi ptr [ %30, %1787 ], [ %29, %1771 ]
  %1829 = load i32, ptr %66, align 4
  store i32 %1829, ptr %1828, align 4
  %1830 = add i32 %1829, 1
  %1831 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1830, ptr %66, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  br label %CuckooMap_insert_keyK_valueV.exit1001

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1877: ; preds = %.cont.cont.i1842
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %29)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %30)
  %1832 = icmp eq ptr %vptr.i142.sroa.speculated.i1845, null
  br i1 %1832, label %CuckooMap_insert_keyK_valueV.exit1001, label %1833

1833:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1877
  %1834 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1835 = load ptr, ptr %57, align 8
  %1836 = load ptr, ptr %58, align 8
  %1837 = load i32, ptr %56, align 8
  %1838 = shl i32 %1837, 1
  %spec.select.i1893 = call i32 @llvm.smax.i32(i32 %1838, i32 16)
  store i32 %spec.select.i1893, ptr %56, align 8
  %1839 = zext nneg i32 %spec.select.i1893 to i64
  %1840 = shl nuw nsw i64 %1839, 5
  %result.i.i1894 = call noalias ptr @bump_malloc_inner(i64 noundef %1840, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i1894, ptr %57, align 8
  %result.i20.i1895 = call noalias ptr @bump_malloc_inner(i64 noundef %1840, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i1895, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %1841 = icmp sgt i32 %1837, 0
  br i1 %1841, label %.lr.ph.i2806, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875

.lr.ph.i2806:                                     ; preds = %1833, %._crit_edge.i2821
  %.060.i2819 = phi i32 [ %1930, %._crit_edge.i2821 ], [ 0, %1833 ]
  %1842 = zext nneg i32 %.060.i2819 to i64
  %1843 = shl nuw nsw i64 %1842, 5
  %1844 = getelementptr i8, ptr %1835, i64 %1843
  %1845 = load ptr, ptr %1844, align 8
  %1846 = icmp ne ptr %1845, @nil_typ
  %1847 = icmp ne ptr %1845, null
  %.not16.i2820 = and i1 %1846, %1847
  br i1 %.not16.i2820, label %1848, label %._crit_edge.i2821

1848:                                             ; preds = %.lr.ph.i2806
  %1849 = getelementptr i8, ptr %1844, i64 8
  %1850 = load <2 x i64>, ptr %1849, align 4
  %hash_coef_ptr.i.i18.i2823 = getelementptr i8, ptr %1845, i64 8
  %tbl_size_ptr.i.i19.i2824 = getelementptr i8, ptr %1845, i64 16
  %offset_tbl_ptr.i.i20.i2825 = getelementptr i8, ptr %1845, i64 40
  %1851 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i3630 = load i64, ptr %hash_coef_ptr.i.i18.i2823, align 4, !noalias !22
  %tbl_size.i.i100.i3631 = load i64, ptr %tbl_size_ptr.i.i19.i2824, align 4, !noalias !22
  %offset_tbl.i.i101.i3632 = load ptr, ptr %offset_tbl_ptr.i.i20.i2825, align 8, !noalias !22
  %product.i.i.i102.i3633 = mul i64 %hash_coef.i.i99.i3630, 4015701072841558310
  %shifted.i.i.i103.i3634 = lshr i64 %product.i.i.i102.i3633, 32
  %xored.i.i.i104.i3635 = xor i64 %shifted.i.i.i103.i3634, %product.i.i.i102.i3633
  %hash.i.i.i105.i3636 = and i64 %xored.i.i.i104.i3635, %tbl_size.i.i100.i3631
  %offset_ptr.i.i106.i3637 = getelementptr i32, ptr %offset_tbl.i.i101.i3632, i64 %hash.i.i.i105.i3636
  %offset.i.i121.i3638 = load i32, ptr %offset_ptr.i.i106.i3637, align 4, !noalias !380
  %1852 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1853 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1854 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1855

1855:                                             ; preds = %.cont.cont.i3659, %1848
  %.0566.i3639 = phi i32 [ 0, %1848 ], [ %1859, %.cont.cont.i3659 ]
  %.070565.i3640 = phi i1 [ true, %1848 ], [ %1921, %.cont.cont.i3659 ]
  %.sroa.0.0564.i3641 = phi ptr [ %1845, %1848 ], [ %vptr.i142.sroa.speculated.i3662, %.cont.cont.i3659 ]
  %.sroa.17.0561.i3644 = phi i32 [ %offset.i.i121.i3638, %1848 ], [ %offset.i.i154.i3676, %.cont.cont.i3659 ]
  %1856 = phi <2 x i64> [ %1850, %1848 ], [ %1920, %.cont.cont.i3659 ]
  %1857 = extractelement <2 x i64> %1856, i64 1
  %.sroa.12.0562.i3643 = inttoptr i64 %1857 to ptr
  %1858 = extractelement <2 x i64> %1856, i64 0
  %.sroa.6.0563.i3642 = inttoptr i64 %1858 to ptr
  %1859 = add nuw nsw i32 %.0566.i3639, 1
  %1860 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3641, 0
  %1861 = insertvalue { ptr, ptr, ptr, i32 } %1860, ptr %.sroa.6.0563.i3642, 1
  %1862 = insertvalue { ptr, ptr, ptr, i32 } %1861, ptr %.sroa.12.0562.i3643, 2
  %1863 = insertvalue { ptr, ptr, ptr, i32 } %1862, i32 %.sroa.17.0561.i3644, 3
  %1864 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3641)
  %1865 = sext i32 %.sroa.17.0561.i3644 to i64
  %1866 = getelementptr ptr, ptr %.sroa.0.0564.i3641, i64 %1865
  %1867 = getelementptr i8, ptr %1866, i64 64
  %1868 = load ptr, ptr %1867, align 8
  %result.i125.i3645 = call ptr %1868({ ptr, ptr, ptr, i32 } %1863, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1869 = call i32 %result.i125.i3645({ ptr, ptr, ptr, i32 } %1863, { ptr, ptr, ptr, i32 } %1863, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3640, label %1870, label %1886

1870:                                             ; preds = %1855
  %1871 = load i32, ptr %56, align 8
  %1872 = add i32 %1871, -1
  %1873 = and i32 %1872, %1869
  %1874 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1875 = load ptr, ptr %57, align 8
  %1876 = sext i32 %1873 to i64
  %1877 = shl nsw i64 %1876, 5
  %1878 = getelementptr i8, ptr %1875, i64 %1877
  %1879 = load ptr, ptr %1878, align 8
  %1880 = getelementptr i8, ptr %1878, i64 8
  %1881 = load i160, ptr %1880, align 4
  store ptr %.sroa.0.0564.i3641, ptr %1878, align 8
  store i64 %1858, ptr %1880, align 4
  %.sroa_idx157.i3688 = getelementptr i8, ptr %1878, i64 16
  store i64 %1857, ptr %.sroa_idx157.i3688, align 4
  %.sroa_idx158.i3689 = getelementptr i8, ptr %1878, i64 24
  store i32 %.sroa.17.0561.i3644, ptr %.sroa_idx158.i3689, align 4
  %1882 = icmp ne ptr %1879, @nil_typ
  %1883 = icmp ne ptr %1879, null
  %.not92.i3690 = and i1 %1882, %1883
  %extract.i3692 = lshr i160 %1881, 64
  %1884 = insertelement <2 x i160> poison, i160 %1881, i64 0
  %1885 = insertelement <2 x i160> %1884, i160 %extract.i3692, i64 1
  br i1 %.not92.i3690, label %.cont.cont.i3659, label %1925

1886:                                             ; preds = %1855
  %1887 = add i32 %1869, 2127912214
  %1888 = shl i32 %1869, 12
  %1889 = add i32 %1887, %1888
  %1890 = ashr i32 %1889, 19
  %1891 = xor i32 %1889, %1890
  %1892 = xor i32 %1891, -949894596
  %1893 = add i32 %1892, 374761393
  %1894 = shl i32 %1892, 5
  %1895 = add i32 %1893, %1894
  %1896 = add i32 %1895, -744332180
  %1897 = shl i32 %1895, 9
  %1898 = xor i32 %1896, %1897
  %1899 = add i32 %1898, -42973499
  %1900 = shl i32 %1898, 3
  %1901 = add i32 %1899, %1900
  %1902 = ashr i32 %1901, 16
  %1903 = xor i32 %1901, %1902
  %1904 = xor i32 %1903, -1252372727
  %1905 = load i32, ptr %56, align 8
  %1906 = add i32 %1905, -1
  %1907 = and i32 %1906, %1904
  %1908 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1909 = load ptr, ptr %58, align 8
  %1910 = sext i32 %1907 to i64
  %1911 = shl nsw i64 %1910, 5
  %1912 = getelementptr i8, ptr %1909, i64 %1911
  %1913 = load ptr, ptr %1912, align 8
  %1914 = getelementptr i8, ptr %1912, i64 8
  %1915 = load i160, ptr %1914, align 4
  store ptr %.sroa.0.0564.i3641, ptr %1912, align 8
  store i64 %1858, ptr %1914, align 4
  %.sroa_idx161.i3649 = getelementptr i8, ptr %1912, i64 16
  store i64 %1857, ptr %.sroa_idx161.i3649, align 4
  %.sroa_idx162.i3650 = getelementptr i8, ptr %1912, i64 24
  store i32 %.sroa.17.0561.i3644, ptr %.sroa_idx162.i3650, align 4
  %1916 = icmp ne ptr %1913, @nil_typ
  %1917 = icmp ne ptr %1913, null
  %.not90.i3651 = and i1 %1916, %1917
  %extract607.i3653 = lshr i160 %1915, 64
  %1918 = insertelement <2 x i160> poison, i160 %1915, i64 0
  %1919 = insertelement <2 x i160> %1918, i160 %extract607.i3653, i64 1
  br i1 %.not90.i3651, label %.cont.cont.i3659, label %1925

.cont.cont.i3659:                                 ; preds = %1886, %1870
  %vptr.i142.sroa.speculated.i3662 = phi ptr [ %1879, %1870 ], [ %1913, %1886 ]
  %.in4337 = phi <2 x i160> [ %1885, %1870 ], [ %1919, %1886 ]
  %1920 = trunc <2 x i160> %.in4337 to <2 x i64>
  %1921 = xor i1 %.070565.i3640, true
  %hash_coef_ptr.i.i143.i3665 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3662, i64 8
  %tbl_size_ptr.i.i144.i3666 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3662, i64 16
  %offset_tbl_ptr.i.i145.i3667 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3662, i64 40
  %hash_coef.i.i146.i3668 = load i64, ptr %hash_coef_ptr.i.i143.i3665, align 4
  %tbl_size.i.i147.i3669 = load i64, ptr %tbl_size_ptr.i.i144.i3666, align 4
  %offset_tbl.i.i148.i3670 = load ptr, ptr %offset_tbl_ptr.i.i145.i3667, align 8
  %product.i.i.i149.i3671 = mul i64 %hash_coef.i.i146.i3668, 4015701072841558310
  %shifted.i.i.i150.i3672 = lshr i64 %product.i.i.i149.i3671, 32
  %xored.i.i.i151.i3673 = xor i64 %shifted.i.i.i150.i3672, %product.i.i.i149.i3671
  %hash.i.i.i152.i3674 = and i64 %xored.i.i.i151.i3673, %tbl_size.i.i147.i3669
  %offset_ptr.i.i153.i3675 = getelementptr i32, ptr %offset_tbl.i.i148.i3670, i64 %hash.i.i.i152.i3674
  %offset.i.i154.i3676 = load i32, ptr %offset_ptr.i.i153.i3675, align 4
  %1922 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1923 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1924 = icmp ult i32 %.0566.i3639, 99
  br i1 %1924, label %1855, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3694

1925:                                             ; preds = %1886, %1870
  %1926 = phi ptr [ %10, %1886 ], [ %9, %1870 ]
  %1927 = load i32, ptr %66, align 4
  store i32 %1927, ptr %1926, align 4
  %1928 = add i32 %1927, 1
  %1929 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1928, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3694

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3694: ; preds = %.cont.cont.i3659, %1925
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %._crit_edge.i2821

._crit_edge.i2821:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3694, %.lr.ph.i2806
  %1930 = add nuw nsw i32 %.060.i2819, 1
  %1931 = icmp slt i32 %1930, %1837
  br i1 %1931, label %.lr.ph.i2806, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839: ; preds = %._crit_edge.i2821, %._crit_edge.i2857
  %.060.i2855 = phi i32 [ %2020, %._crit_edge.i2857 ], [ 0, %._crit_edge.i2821 ]
  %1932 = zext nneg i32 %.060.i2855 to i64
  %1933 = shl nuw nsw i64 %1932, 5
  %1934 = getelementptr i8, ptr %1836, i64 %1933
  %1935 = load ptr, ptr %1934, align 8
  %1936 = icmp ne ptr %1935, @nil_typ
  %1937 = icmp ne ptr %1935, null
  %.not16.i2856 = and i1 %1936, %1937
  br i1 %.not16.i2856, label %1938, label %._crit_edge.i2857

1938:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839
  %1939 = getelementptr i8, ptr %1934, i64 8
  %1940 = load <2 x i64>, ptr %1939, align 4
  %hash_coef_ptr.i.i18.i2859 = getelementptr i8, ptr %1935, i64 8
  %tbl_size_ptr.i.i19.i2860 = getelementptr i8, ptr %1935, i64 16
  %offset_tbl_ptr.i.i20.i2861 = getelementptr i8, ptr %1935, i64 40
  %1941 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i3712 = load i64, ptr %hash_coef_ptr.i.i18.i2859, align 4, !noalias !22
  %tbl_size.i.i100.i3713 = load i64, ptr %tbl_size_ptr.i.i19.i2860, align 4, !noalias !22
  %offset_tbl.i.i101.i3714 = load ptr, ptr %offset_tbl_ptr.i.i20.i2861, align 8, !noalias !22
  %product.i.i.i102.i3715 = mul i64 %hash_coef.i.i99.i3712, 4015701072841558310
  %shifted.i.i.i103.i3716 = lshr i64 %product.i.i.i102.i3715, 32
  %xored.i.i.i104.i3717 = xor i64 %shifted.i.i.i103.i3716, %product.i.i.i102.i3715
  %hash.i.i.i105.i3718 = and i64 %xored.i.i.i104.i3717, %tbl_size.i.i100.i3713
  %offset_ptr.i.i106.i3719 = getelementptr i32, ptr %offset_tbl.i.i101.i3714, i64 %hash.i.i.i105.i3718
  %offset.i.i121.i3720 = load i32, ptr %offset_ptr.i.i106.i3719, align 4, !noalias !383
  %1942 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1943 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %1944 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1945

1945:                                             ; preds = %.cont.cont.i3741, %1938
  %.0566.i3721 = phi i32 [ 0, %1938 ], [ %1949, %.cont.cont.i3741 ]
  %.070565.i3722 = phi i1 [ true, %1938 ], [ %2011, %.cont.cont.i3741 ]
  %.sroa.0.0564.i3723 = phi ptr [ %1935, %1938 ], [ %vptr.i142.sroa.speculated.i3744, %.cont.cont.i3741 ]
  %.sroa.17.0561.i3726 = phi i32 [ %offset.i.i121.i3720, %1938 ], [ %offset.i.i154.i3758, %.cont.cont.i3741 ]
  %1946 = phi <2 x i64> [ %1940, %1938 ], [ %2010, %.cont.cont.i3741 ]
  %1947 = extractelement <2 x i64> %1946, i64 1
  %.sroa.12.0562.i3725 = inttoptr i64 %1947 to ptr
  %1948 = extractelement <2 x i64> %1946, i64 0
  %.sroa.6.0563.i3724 = inttoptr i64 %1948 to ptr
  %1949 = add nuw nsw i32 %.0566.i3721, 1
  %1950 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3723, 0
  %1951 = insertvalue { ptr, ptr, ptr, i32 } %1950, ptr %.sroa.6.0563.i3724, 1
  %1952 = insertvalue { ptr, ptr, ptr, i32 } %1951, ptr %.sroa.12.0562.i3725, 2
  %1953 = insertvalue { ptr, ptr, ptr, i32 } %1952, i32 %.sroa.17.0561.i3726, 3
  %1954 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3723)
  %1955 = sext i32 %.sroa.17.0561.i3726 to i64
  %1956 = getelementptr ptr, ptr %.sroa.0.0564.i3723, i64 %1955
  %1957 = getelementptr i8, ptr %1956, i64 64
  %1958 = load ptr, ptr %1957, align 8
  %result.i125.i3727 = call ptr %1958({ ptr, ptr, ptr, i32 } %1953, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1959 = call i32 %result.i125.i3727({ ptr, ptr, ptr, i32 } %1953, { ptr, ptr, ptr, i32 } %1953, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3722, label %1960, label %1976

1960:                                             ; preds = %1945
  %1961 = load i32, ptr %56, align 8
  %1962 = add i32 %1961, -1
  %1963 = and i32 %1962, %1959
  %1964 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1965 = load ptr, ptr %57, align 8
  %1966 = sext i32 %1963 to i64
  %1967 = shl nsw i64 %1966, 5
  %1968 = getelementptr i8, ptr %1965, i64 %1967
  %1969 = load ptr, ptr %1968, align 8
  %1970 = getelementptr i8, ptr %1968, i64 8
  %1971 = load i160, ptr %1970, align 4
  store ptr %.sroa.0.0564.i3723, ptr %1968, align 8
  store i64 %1948, ptr %1970, align 4
  %.sroa_idx157.i3770 = getelementptr i8, ptr %1968, i64 16
  store i64 %1947, ptr %.sroa_idx157.i3770, align 4
  %.sroa_idx158.i3771 = getelementptr i8, ptr %1968, i64 24
  store i32 %.sroa.17.0561.i3726, ptr %.sroa_idx158.i3771, align 4
  %1972 = icmp ne ptr %1969, @nil_typ
  %1973 = icmp ne ptr %1969, null
  %.not92.i3772 = and i1 %1972, %1973
  %extract.i3774 = lshr i160 %1971, 64
  %1974 = insertelement <2 x i160> poison, i160 %1971, i64 0
  %1975 = insertelement <2 x i160> %1974, i160 %extract.i3774, i64 1
  br i1 %.not92.i3772, label %.cont.cont.i3741, label %2015

1976:                                             ; preds = %1945
  %1977 = add i32 %1959, 2127912214
  %1978 = shl i32 %1959, 12
  %1979 = add i32 %1977, %1978
  %1980 = ashr i32 %1979, 19
  %1981 = xor i32 %1979, %1980
  %1982 = xor i32 %1981, -949894596
  %1983 = add i32 %1982, 374761393
  %1984 = shl i32 %1982, 5
  %1985 = add i32 %1983, %1984
  %1986 = add i32 %1985, -744332180
  %1987 = shl i32 %1985, 9
  %1988 = xor i32 %1986, %1987
  %1989 = add i32 %1988, -42973499
  %1990 = shl i32 %1988, 3
  %1991 = add i32 %1989, %1990
  %1992 = ashr i32 %1991, 16
  %1993 = xor i32 %1991, %1992
  %1994 = xor i32 %1993, -1252372727
  %1995 = load i32, ptr %56, align 8
  %1996 = add i32 %1995, -1
  %1997 = and i32 %1996, %1994
  %1998 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1999 = load ptr, ptr %58, align 8
  %2000 = sext i32 %1997 to i64
  %2001 = shl nsw i64 %2000, 5
  %2002 = getelementptr i8, ptr %1999, i64 %2001
  %2003 = load ptr, ptr %2002, align 8
  %2004 = getelementptr i8, ptr %2002, i64 8
  %2005 = load i160, ptr %2004, align 4
  store ptr %.sroa.0.0564.i3723, ptr %2002, align 8
  store i64 %1948, ptr %2004, align 4
  %.sroa_idx161.i3731 = getelementptr i8, ptr %2002, i64 16
  store i64 %1947, ptr %.sroa_idx161.i3731, align 4
  %.sroa_idx162.i3732 = getelementptr i8, ptr %2002, i64 24
  store i32 %.sroa.17.0561.i3726, ptr %.sroa_idx162.i3732, align 4
  %2006 = icmp ne ptr %2003, @nil_typ
  %2007 = icmp ne ptr %2003, null
  %.not90.i3733 = and i1 %2006, %2007
  %extract607.i3735 = lshr i160 %2005, 64
  %2008 = insertelement <2 x i160> poison, i160 %2005, i64 0
  %2009 = insertelement <2 x i160> %2008, i160 %extract607.i3735, i64 1
  br i1 %.not90.i3733, label %.cont.cont.i3741, label %2015

.cont.cont.i3741:                                 ; preds = %1976, %1960
  %vptr.i142.sroa.speculated.i3744 = phi ptr [ %1969, %1960 ], [ %2003, %1976 ]
  %.in4338 = phi <2 x i160> [ %1975, %1960 ], [ %2009, %1976 ]
  %2010 = trunc <2 x i160> %.in4338 to <2 x i64>
  %2011 = xor i1 %.070565.i3722, true
  %hash_coef_ptr.i.i143.i3747 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3744, i64 8
  %tbl_size_ptr.i.i144.i3748 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3744, i64 16
  %offset_tbl_ptr.i.i145.i3749 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3744, i64 40
  %hash_coef.i.i146.i3750 = load i64, ptr %hash_coef_ptr.i.i143.i3747, align 4
  %tbl_size.i.i147.i3751 = load i64, ptr %tbl_size_ptr.i.i144.i3748, align 4
  %offset_tbl.i.i148.i3752 = load ptr, ptr %offset_tbl_ptr.i.i145.i3749, align 8
  %product.i.i.i149.i3753 = mul i64 %hash_coef.i.i146.i3750, 4015701072841558310
  %shifted.i.i.i150.i3754 = lshr i64 %product.i.i.i149.i3753, 32
  %xored.i.i.i151.i3755 = xor i64 %shifted.i.i.i150.i3754, %product.i.i.i149.i3753
  %hash.i.i.i152.i3756 = and i64 %xored.i.i.i151.i3755, %tbl_size.i.i147.i3751
  %offset_ptr.i.i153.i3757 = getelementptr i32, ptr %offset_tbl.i.i148.i3752, i64 %hash.i.i.i152.i3756
  %offset.i.i154.i3758 = load i32, ptr %offset_ptr.i.i153.i3757, align 4
  %2012 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2013 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2014 = icmp ult i32 %.0566.i3721, 99
  br i1 %2014, label %1945, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3776

2015:                                             ; preds = %1976, %1960
  %2016 = phi ptr [ %8, %1976 ], [ %7, %1960 ]
  %2017 = load i32, ptr %66, align 4
  store i32 %2017, ptr %2016, align 4
  %2018 = add i32 %2017, 1
  %2019 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2018, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3776

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3776: ; preds = %.cont.cont.i3741, %2015
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i2857

._crit_edge.i2857:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3776, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839
  %2020 = add nuw nsw i32 %.060.i2855, 1
  %2021 = icmp slt i32 %2020, %1837
  br i1 %2021, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2839, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875: ; preds = %._crit_edge.i2857, %1833
  %2022 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %28)
  %hash_coef.i.i99.i1918 = load i64, ptr %hash_coef_ptr.i.i143.i1848, align 4, !noalias !22
  %tbl_size.i.i100.i1919 = load i64, ptr %tbl_size_ptr.i.i144.i1849, align 4, !noalias !22
  %offset_tbl.i.i101.i1920 = load ptr, ptr %offset_tbl_ptr.i.i145.i1850, align 8, !noalias !22
  %product.i.i.i102.i1921 = mul i64 %hash_coef.i.i99.i1918, 4015701072841558310
  %shifted.i.i.i103.i1922 = lshr i64 %product.i.i.i102.i1921, 32
  %xored.i.i.i104.i1923 = xor i64 %shifted.i.i.i103.i1922, %product.i.i.i102.i1921
  %hash.i.i.i105.i1924 = and i64 %xored.i.i.i104.i1923, %tbl_size.i.i100.i1919
  %offset_ptr.i.i106.i1925 = getelementptr i32, ptr %offset_tbl.i.i101.i1920, i64 %hash.i.i.i105.i1924
  %offset.i.i121.i1926 = load i32, ptr %offset_ptr.i.i106.i1925, align 4, !noalias !386
  %2023 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2024 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2025 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2026

2026:                                             ; preds = %.cont.cont.i1948, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875
  %.0566.i1928 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %2030, %.cont.cont.i1948 ]
  %.070565.i1929 = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %2092, %.cont.cont.i1948 ]
  %.sroa.0.0564.i1930 = phi ptr [ %vptr.i142.sroa.speculated.i1845, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %vptr.i142.sroa.speculated.i1951, %.cont.cont.i1948 ]
  %.sroa.17.0561.i1933 = phi i32 [ %offset.i.i121.i1926, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %offset.i.i154.i1965, %.cont.cont.i1948 ]
  %2027 = phi <2 x i64> [ %1821, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2875 ], [ %2091, %.cont.cont.i1948 ]
  %2028 = extractelement <2 x i64> %2027, i64 1
  %.sroa.12.0562.i1932 = inttoptr i64 %2028 to ptr
  %2029 = extractelement <2 x i64> %2027, i64 0
  %.sroa.6.0563.i1931 = inttoptr i64 %2029 to ptr
  %2030 = add nuw nsw i32 %.0566.i1928, 1
  %2031 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1930, 0
  %2032 = insertvalue { ptr, ptr, ptr, i32 } %2031, ptr %.sroa.6.0563.i1931, 1
  %2033 = insertvalue { ptr, ptr, ptr, i32 } %2032, ptr %.sroa.12.0562.i1932, 2
  %2034 = insertvalue { ptr, ptr, ptr, i32 } %2033, i32 %.sroa.17.0561.i1933, 3
  %2035 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1930)
  %2036 = sext i32 %.sroa.17.0561.i1933 to i64
  %2037 = getelementptr ptr, ptr %.sroa.0.0564.i1930, i64 %2036
  %2038 = getelementptr i8, ptr %2037, i64 64
  %2039 = load ptr, ptr %2038, align 8
  %result.i125.i1934 = call ptr %2039({ ptr, ptr, ptr, i32 } %2034, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2040 = call i32 %result.i125.i1934({ ptr, ptr, ptr, i32 } %2034, { ptr, ptr, ptr, i32 } %2034, ptr nonnull align 8 %2) #7
  br i1 %.070565.i1929, label %2041, label %2057

2041:                                             ; preds = %2026
  %2042 = load i32, ptr %56, align 8
  %2043 = add i32 %2042, -1
  %2044 = and i32 %2043, %2040
  %2045 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2046 = load ptr, ptr %57, align 8
  %2047 = sext i32 %2044 to i64
  %2048 = shl nsw i64 %2047, 5
  %2049 = getelementptr i8, ptr %2046, i64 %2048
  %2050 = load ptr, ptr %2049, align 8
  %2051 = getelementptr i8, ptr %2049, i64 8
  %2052 = load i160, ptr %2051, align 4
  store ptr %.sroa.0.0564.i1930, ptr %2049, align 8
  store i64 %2029, ptr %2051, align 4
  %.sroa_idx157.i1977 = getelementptr i8, ptr %2049, i64 16
  store i64 %2028, ptr %.sroa_idx157.i1977, align 4
  %.sroa_idx158.i1978 = getelementptr i8, ptr %2049, i64 24
  store i32 %.sroa.17.0561.i1933, ptr %.sroa_idx158.i1978, align 4
  %2053 = icmp ne ptr %2050, @nil_typ
  %2054 = icmp ne ptr %2050, null
  %.not92.i1979 = and i1 %2053, %2054
  %extract.i1981 = lshr i160 %2052, 64
  %2055 = insertelement <2 x i160> poison, i160 %2052, i64 0
  %2056 = insertelement <2 x i160> %2055, i160 %extract.i1981, i64 1
  br i1 %.not92.i1979, label %.cont.cont.i1948, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1983.thread

2057:                                             ; preds = %2026
  %2058 = add i32 %2040, 2127912214
  %2059 = shl i32 %2040, 12
  %2060 = add i32 %2058, %2059
  %2061 = ashr i32 %2060, 19
  %2062 = xor i32 %2060, %2061
  %2063 = xor i32 %2062, -949894596
  %2064 = add i32 %2063, 374761393
  %2065 = shl i32 %2063, 5
  %2066 = add i32 %2064, %2065
  %2067 = add i32 %2066, -744332180
  %2068 = shl i32 %2066, 9
  %2069 = xor i32 %2067, %2068
  %2070 = add i32 %2069, -42973499
  %2071 = shl i32 %2069, 3
  %2072 = add i32 %2070, %2071
  %2073 = ashr i32 %2072, 16
  %2074 = xor i32 %2072, %2073
  %2075 = xor i32 %2074, -1252372727
  %2076 = load i32, ptr %56, align 8
  %2077 = add i32 %2076, -1
  %2078 = and i32 %2077, %2075
  %2079 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2080 = load ptr, ptr %58, align 8
  %2081 = sext i32 %2078 to i64
  %2082 = shl nsw i64 %2081, 5
  %2083 = getelementptr i8, ptr %2080, i64 %2082
  %2084 = load ptr, ptr %2083, align 8
  %2085 = getelementptr i8, ptr %2083, i64 8
  %2086 = load i160, ptr %2085, align 4
  store ptr %.sroa.0.0564.i1930, ptr %2083, align 8
  store i64 %2029, ptr %2085, align 4
  %.sroa_idx161.i1938 = getelementptr i8, ptr %2083, i64 16
  store i64 %2028, ptr %.sroa_idx161.i1938, align 4
  %.sroa_idx162.i1939 = getelementptr i8, ptr %2083, i64 24
  store i32 %.sroa.17.0561.i1933, ptr %.sroa_idx162.i1939, align 4
  %2087 = icmp ne ptr %2084, @nil_typ
  %2088 = icmp ne ptr %2084, null
  %.not90.i1940 = and i1 %2087, %2088
  %extract607.i1942 = lshr i160 %2086, 64
  %2089 = insertelement <2 x i160> poison, i160 %2086, i64 0
  %2090 = insertelement <2 x i160> %2089, i160 %extract607.i1942, i64 1
  br i1 %.not90.i1940, label %.cont.cont.i1948, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1983.thread

.cont.cont.i1948:                                 ; preds = %2057, %2041
  %vptr.i142.sroa.speculated.i1951 = phi ptr [ %2050, %2041 ], [ %2084, %2057 ]
  %.in4339 = phi <2 x i160> [ %2056, %2041 ], [ %2090, %2057 ]
  %2091 = trunc <2 x i160> %.in4339 to <2 x i64>
  %2092 = xor i1 %.070565.i1929, true
  %hash_coef_ptr.i.i143.i1954 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1951, i64 8
  %tbl_size_ptr.i.i144.i1955 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1951, i64 16
  %offset_tbl_ptr.i.i145.i1956 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1951, i64 40
  %hash_coef.i.i146.i1957 = load i64, ptr %hash_coef_ptr.i.i143.i1954, align 4
  %tbl_size.i.i147.i1958 = load i64, ptr %tbl_size_ptr.i.i144.i1955, align 4
  %offset_tbl.i.i148.i1959 = load ptr, ptr %offset_tbl_ptr.i.i145.i1956, align 8
  %product.i.i.i149.i1960 = mul i64 %hash_coef.i.i146.i1957, 4015701072841558310
  %shifted.i.i.i150.i1961 = lshr i64 %product.i.i.i149.i1960, 32
  %xored.i.i.i151.i1962 = xor i64 %shifted.i.i.i150.i1961, %product.i.i.i149.i1960
  %hash.i.i.i152.i1963 = and i64 %xored.i.i.i151.i1962, %tbl_size.i.i147.i1958
  %offset_ptr.i.i153.i1964 = getelementptr i32, ptr %offset_tbl.i.i148.i1959, i64 %hash.i.i.i152.i1963
  %offset.i.i154.i1965 = load i32, ptr %offset_ptr.i.i153.i1964, align 4
  %2093 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2094 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2095 = icmp ult i32 %.0566.i1928, 99
  br i1 %2095, label %2026, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1983

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1983.thread: ; preds = %2041, %2057
  %2096 = phi ptr [ %28, %2057 ], [ %27, %2041 ]
  %2097 = load i32, ptr %66, align 4
  store i32 %2097, ptr %2096, align 4
  %2098 = add i32 %2097, 1
  %2099 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2098, ptr %66, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  br label %CuckooMap_insert_keyK_valueV.exit1001

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1983: ; preds = %.cont.cont.i1948
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %28)
  %2100 = icmp eq ptr %vptr.i142.sroa.speculated.i1951, null
  br i1 %2100, label %CuckooMap_insert_keyK_valueV.exit1001, label %2101

2101:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1983
  %2102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2103 = load ptr, ptr %57, align 8
  %2104 = load ptr, ptr %58, align 8
  %2105 = load i32, ptr %56, align 8
  %2106 = shl i32 %2105, 1
  %spec.select.i1999 = call i32 @llvm.smax.i32(i32 %2106, i32 16)
  store i32 %spec.select.i1999, ptr %56, align 8
  %2107 = zext nneg i32 %spec.select.i1999 to i64
  %2108 = shl nuw nsw i64 %2107, 5
  %result.i.i2000 = call noalias ptr @bump_malloc_inner(i64 noundef %2108, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i2000, ptr %57, align 8
  %result.i20.i2001 = call noalias ptr @bump_malloc_inner(i64 noundef %2108, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i2001, ptr %58, align 8
  store i32 0, ptr %66, align 4
  %2109 = icmp sgt i32 %2105, 0
  br i1 %2109, label %.lr.ph.i2905, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938.thread

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938.thread: ; preds = %2101
  %2110 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit1001

.lr.ph.i2905:                                     ; preds = %2101, %._crit_edge.i2920
  %.060.i2918 = phi i32 [ %2199, %._crit_edge.i2920 ], [ 0, %2101 ]
  %2111 = zext nneg i32 %.060.i2918 to i64
  %2112 = shl nuw nsw i64 %2111, 5
  %2113 = getelementptr i8, ptr %2103, i64 %2112
  %2114 = load ptr, ptr %2113, align 8
  %2115 = icmp ne ptr %2114, @nil_typ
  %2116 = icmp ne ptr %2114, null
  %.not16.i2919 = and i1 %2115, %2116
  br i1 %.not16.i2919, label %2117, label %._crit_edge.i2920

2117:                                             ; preds = %.lr.ph.i2905
  %2118 = getelementptr i8, ptr %2113, i64 8
  %2119 = load <2 x i64>, ptr %2118, align 4
  %hash_coef_ptr.i.i18.i2922 = getelementptr i8, ptr %2114, i64 8
  %tbl_size_ptr.i.i19.i2923 = getelementptr i8, ptr %2114, i64 16
  %offset_tbl_ptr.i.i20.i2924 = getelementptr i8, ptr %2114, i64 40
  %2120 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i3794 = load i64, ptr %hash_coef_ptr.i.i18.i2922, align 4, !noalias !22
  %tbl_size.i.i100.i3795 = load i64, ptr %tbl_size_ptr.i.i19.i2923, align 4, !noalias !22
  %offset_tbl.i.i101.i3796 = load ptr, ptr %offset_tbl_ptr.i.i20.i2924, align 8, !noalias !22
  %product.i.i.i102.i3797 = mul i64 %hash_coef.i.i99.i3794, 4015701072841558310
  %shifted.i.i.i103.i3798 = lshr i64 %product.i.i.i102.i3797, 32
  %xored.i.i.i104.i3799 = xor i64 %shifted.i.i.i103.i3798, %product.i.i.i102.i3797
  %hash.i.i.i105.i3800 = and i64 %xored.i.i.i104.i3799, %tbl_size.i.i100.i3795
  %offset_ptr.i.i106.i3801 = getelementptr i32, ptr %offset_tbl.i.i101.i3796, i64 %hash.i.i.i105.i3800
  %offset.i.i121.i3802 = load i32, ptr %offset_ptr.i.i106.i3801, align 4, !noalias !389
  %2121 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2122 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2124

2124:                                             ; preds = %.cont.cont.i3823, %2117
  %.0566.i3803 = phi i32 [ 0, %2117 ], [ %2128, %.cont.cont.i3823 ]
  %.070565.i3804 = phi i1 [ true, %2117 ], [ %2190, %.cont.cont.i3823 ]
  %.sroa.0.0564.i3805 = phi ptr [ %2114, %2117 ], [ %vptr.i142.sroa.speculated.i3826, %.cont.cont.i3823 ]
  %.sroa.17.0561.i3808 = phi i32 [ %offset.i.i121.i3802, %2117 ], [ %offset.i.i154.i3840, %.cont.cont.i3823 ]
  %2125 = phi <2 x i64> [ %2119, %2117 ], [ %2189, %.cont.cont.i3823 ]
  %2126 = extractelement <2 x i64> %2125, i64 1
  %.sroa.12.0562.i3807 = inttoptr i64 %2126 to ptr
  %2127 = extractelement <2 x i64> %2125, i64 0
  %.sroa.6.0563.i3806 = inttoptr i64 %2127 to ptr
  %2128 = add nuw nsw i32 %.0566.i3803, 1
  %2129 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3805, 0
  %2130 = insertvalue { ptr, ptr, ptr, i32 } %2129, ptr %.sroa.6.0563.i3806, 1
  %2131 = insertvalue { ptr, ptr, ptr, i32 } %2130, ptr %.sroa.12.0562.i3807, 2
  %2132 = insertvalue { ptr, ptr, ptr, i32 } %2131, i32 %.sroa.17.0561.i3808, 3
  %2133 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3805)
  %2134 = sext i32 %.sroa.17.0561.i3808 to i64
  %2135 = getelementptr ptr, ptr %.sroa.0.0564.i3805, i64 %2134
  %2136 = getelementptr i8, ptr %2135, i64 64
  %2137 = load ptr, ptr %2136, align 8
  %result.i125.i3809 = call ptr %2137({ ptr, ptr, ptr, i32 } %2132, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2138 = call i32 %result.i125.i3809({ ptr, ptr, ptr, i32 } %2132, { ptr, ptr, ptr, i32 } %2132, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3804, label %2139, label %2155

2139:                                             ; preds = %2124
  %2140 = load i32, ptr %56, align 8
  %2141 = add i32 %2140, -1
  %2142 = and i32 %2141, %2138
  %2143 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2144 = load ptr, ptr %57, align 8
  %2145 = sext i32 %2142 to i64
  %2146 = shl nsw i64 %2145, 5
  %2147 = getelementptr i8, ptr %2144, i64 %2146
  %2148 = load ptr, ptr %2147, align 8
  %2149 = getelementptr i8, ptr %2147, i64 8
  %2150 = load i160, ptr %2149, align 4
  store ptr %.sroa.0.0564.i3805, ptr %2147, align 8
  store i64 %2127, ptr %2149, align 4
  %.sroa_idx157.i3852 = getelementptr i8, ptr %2147, i64 16
  store i64 %2126, ptr %.sroa_idx157.i3852, align 4
  %.sroa_idx158.i3853 = getelementptr i8, ptr %2147, i64 24
  store i32 %.sroa.17.0561.i3808, ptr %.sroa_idx158.i3853, align 4
  %2151 = icmp ne ptr %2148, @nil_typ
  %2152 = icmp ne ptr %2148, null
  %.not92.i3854 = and i1 %2151, %2152
  %extract.i3856 = lshr i160 %2150, 64
  %2153 = insertelement <2 x i160> poison, i160 %2150, i64 0
  %2154 = insertelement <2 x i160> %2153, i160 %extract.i3856, i64 1
  br i1 %.not92.i3854, label %.cont.cont.i3823, label %2194

2155:                                             ; preds = %2124
  %2156 = add i32 %2138, 2127912214
  %2157 = shl i32 %2138, 12
  %2158 = add i32 %2156, %2157
  %2159 = ashr i32 %2158, 19
  %2160 = xor i32 %2158, %2159
  %2161 = xor i32 %2160, -949894596
  %2162 = add i32 %2161, 374761393
  %2163 = shl i32 %2161, 5
  %2164 = add i32 %2162, %2163
  %2165 = add i32 %2164, -744332180
  %2166 = shl i32 %2164, 9
  %2167 = xor i32 %2165, %2166
  %2168 = add i32 %2167, -42973499
  %2169 = shl i32 %2167, 3
  %2170 = add i32 %2168, %2169
  %2171 = ashr i32 %2170, 16
  %2172 = xor i32 %2170, %2171
  %2173 = xor i32 %2172, -1252372727
  %2174 = load i32, ptr %56, align 8
  %2175 = add i32 %2174, -1
  %2176 = and i32 %2175, %2173
  %2177 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2178 = load ptr, ptr %58, align 8
  %2179 = sext i32 %2176 to i64
  %2180 = shl nsw i64 %2179, 5
  %2181 = getelementptr i8, ptr %2178, i64 %2180
  %2182 = load ptr, ptr %2181, align 8
  %2183 = getelementptr i8, ptr %2181, i64 8
  %2184 = load i160, ptr %2183, align 4
  store ptr %.sroa.0.0564.i3805, ptr %2181, align 8
  store i64 %2127, ptr %2183, align 4
  %.sroa_idx161.i3813 = getelementptr i8, ptr %2181, i64 16
  store i64 %2126, ptr %.sroa_idx161.i3813, align 4
  %.sroa_idx162.i3814 = getelementptr i8, ptr %2181, i64 24
  store i32 %.sroa.17.0561.i3808, ptr %.sroa_idx162.i3814, align 4
  %2185 = icmp ne ptr %2182, @nil_typ
  %2186 = icmp ne ptr %2182, null
  %.not90.i3815 = and i1 %2185, %2186
  %extract607.i3817 = lshr i160 %2184, 64
  %2187 = insertelement <2 x i160> poison, i160 %2184, i64 0
  %2188 = insertelement <2 x i160> %2187, i160 %extract607.i3817, i64 1
  br i1 %.not90.i3815, label %.cont.cont.i3823, label %2194

.cont.cont.i3823:                                 ; preds = %2155, %2139
  %vptr.i142.sroa.speculated.i3826 = phi ptr [ %2148, %2139 ], [ %2182, %2155 ]
  %.in4340 = phi <2 x i160> [ %2154, %2139 ], [ %2188, %2155 ]
  %2189 = trunc <2 x i160> %.in4340 to <2 x i64>
  %2190 = xor i1 %.070565.i3804, true
  %hash_coef_ptr.i.i143.i3829 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3826, i64 8
  %tbl_size_ptr.i.i144.i3830 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3826, i64 16
  %offset_tbl_ptr.i.i145.i3831 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3826, i64 40
  %hash_coef.i.i146.i3832 = load i64, ptr %hash_coef_ptr.i.i143.i3829, align 4
  %tbl_size.i.i147.i3833 = load i64, ptr %tbl_size_ptr.i.i144.i3830, align 4
  %offset_tbl.i.i148.i3834 = load ptr, ptr %offset_tbl_ptr.i.i145.i3831, align 8
  %product.i.i.i149.i3835 = mul i64 %hash_coef.i.i146.i3832, 4015701072841558310
  %shifted.i.i.i150.i3836 = lshr i64 %product.i.i.i149.i3835, 32
  %xored.i.i.i151.i3837 = xor i64 %shifted.i.i.i150.i3836, %product.i.i.i149.i3835
  %hash.i.i.i152.i3838 = and i64 %xored.i.i.i151.i3837, %tbl_size.i.i147.i3833
  %offset_ptr.i.i153.i3839 = getelementptr i32, ptr %offset_tbl.i.i148.i3834, i64 %hash.i.i.i152.i3838
  %offset.i.i154.i3840 = load i32, ptr %offset_ptr.i.i153.i3839, align 4
  %2191 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2192 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2193 = icmp ult i32 %.0566.i3803, 99
  br i1 %2193, label %2124, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3858

2194:                                             ; preds = %2155, %2139
  %2195 = phi ptr [ %6, %2155 ], [ %5, %2139 ]
  %2196 = load i32, ptr %66, align 4
  store i32 %2196, ptr %2195, align 4
  %2197 = add i32 %2196, 1
  %2198 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2197, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3858

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3858: ; preds = %.cont.cont.i3823, %2194
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i2920

._crit_edge.i2920:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3858, %.lr.ph.i2905
  %2199 = add nuw nsw i32 %.060.i2918, 1
  %2200 = icmp slt i32 %2199, %2105
  br i1 %2200, label %.lr.ph.i2905, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938: ; preds = %._crit_edge.i2920
  %2201 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %2202

2202:                                             ; preds = %._crit_edge.i2956, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938
  %.060.i2954 = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938 ], [ %2291, %._crit_edge.i2956 ]
  %2203 = zext nneg i32 %.060.i2954 to i64
  %2204 = shl nuw nsw i64 %2203, 5
  %2205 = getelementptr i8, ptr %2104, i64 %2204
  %2206 = load ptr, ptr %2205, align 8
  %2207 = icmp ne ptr %2206, @nil_typ
  %2208 = icmp ne ptr %2206, null
  %.not16.i2955 = and i1 %2207, %2208
  br i1 %.not16.i2955, label %2209, label %._crit_edge.i2956

2209:                                             ; preds = %2202
  %2210 = getelementptr i8, ptr %2205, i64 8
  %2211 = load <2 x i64>, ptr %2210, align 4
  %hash_coef_ptr.i.i18.i2958 = getelementptr i8, ptr %2206, i64 8
  %tbl_size_ptr.i.i19.i2959 = getelementptr i8, ptr %2206, i64 16
  %offset_tbl_ptr.i.i20.i2960 = getelementptr i8, ptr %2206, i64 40
  %2212 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i3876 = load i64, ptr %hash_coef_ptr.i.i18.i2958, align 4, !noalias !22
  %tbl_size.i.i100.i3877 = load i64, ptr %tbl_size_ptr.i.i19.i2959, align 4, !noalias !22
  %offset_tbl.i.i101.i3878 = load ptr, ptr %offset_tbl_ptr.i.i20.i2960, align 8, !noalias !22
  %product.i.i.i102.i3879 = mul i64 %hash_coef.i.i99.i3876, 4015701072841558310
  %shifted.i.i.i103.i3880 = lshr i64 %product.i.i.i102.i3879, 32
  %xored.i.i.i104.i3881 = xor i64 %shifted.i.i.i103.i3880, %product.i.i.i102.i3879
  %hash.i.i.i105.i3882 = and i64 %xored.i.i.i104.i3881, %tbl_size.i.i100.i3877
  %offset_ptr.i.i106.i3883 = getelementptr i32, ptr %offset_tbl.i.i101.i3878, i64 %hash.i.i.i105.i3882
  %offset.i.i121.i3884 = load i32, ptr %offset_ptr.i.i106.i3883, align 4, !noalias !392
  %2213 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2214 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2215 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %2216

2216:                                             ; preds = %.cont.cont.i3905, %2209
  %.0566.i3885 = phi i32 [ 0, %2209 ], [ %2220, %.cont.cont.i3905 ]
  %.070565.i3886 = phi i1 [ true, %2209 ], [ %2282, %.cont.cont.i3905 ]
  %.sroa.0.0564.i3887 = phi ptr [ %2206, %2209 ], [ %vptr.i142.sroa.speculated.i3908, %.cont.cont.i3905 ]
  %.sroa.17.0561.i3890 = phi i32 [ %offset.i.i121.i3884, %2209 ], [ %offset.i.i154.i3922, %.cont.cont.i3905 ]
  %2217 = phi <2 x i64> [ %2211, %2209 ], [ %2281, %.cont.cont.i3905 ]
  %2218 = extractelement <2 x i64> %2217, i64 1
  %.sroa.12.0562.i3889 = inttoptr i64 %2218 to ptr
  %2219 = extractelement <2 x i64> %2217, i64 0
  %.sroa.6.0563.i3888 = inttoptr i64 %2219 to ptr
  %2220 = add nuw nsw i32 %.0566.i3885, 1
  %2221 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i3887, 0
  %2222 = insertvalue { ptr, ptr, ptr, i32 } %2221, ptr %.sroa.6.0563.i3888, 1
  %2223 = insertvalue { ptr, ptr, ptr, i32 } %2222, ptr %.sroa.12.0562.i3889, 2
  %2224 = insertvalue { ptr, ptr, ptr, i32 } %2223, i32 %.sroa.17.0561.i3890, 3
  %2225 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i3887)
  %2226 = sext i32 %.sroa.17.0561.i3890 to i64
  %2227 = getelementptr ptr, ptr %.sroa.0.0564.i3887, i64 %2226
  %2228 = getelementptr i8, ptr %2227, i64 64
  %2229 = load ptr, ptr %2228, align 8
  %result.i125.i3891 = call ptr %2229({ ptr, ptr, ptr, i32 } %2224, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2230 = call i32 %result.i125.i3891({ ptr, ptr, ptr, i32 } %2224, { ptr, ptr, ptr, i32 } %2224, ptr nonnull align 8 %2) #7
  br i1 %.070565.i3886, label %2231, label %2247

2231:                                             ; preds = %2216
  %2232 = load i32, ptr %56, align 8
  %2233 = add i32 %2232, -1
  %2234 = and i32 %2233, %2230
  %2235 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2236 = load ptr, ptr %57, align 8
  %2237 = sext i32 %2234 to i64
  %2238 = shl nsw i64 %2237, 5
  %2239 = getelementptr i8, ptr %2236, i64 %2238
  %2240 = load ptr, ptr %2239, align 8
  %2241 = getelementptr i8, ptr %2239, i64 8
  %2242 = load i160, ptr %2241, align 4
  store ptr %.sroa.0.0564.i3887, ptr %2239, align 8
  store i64 %2219, ptr %2241, align 4
  %.sroa_idx157.i3934 = getelementptr i8, ptr %2239, i64 16
  store i64 %2218, ptr %.sroa_idx157.i3934, align 4
  %.sroa_idx158.i3935 = getelementptr i8, ptr %2239, i64 24
  store i32 %.sroa.17.0561.i3890, ptr %.sroa_idx158.i3935, align 4
  %2243 = icmp ne ptr %2240, @nil_typ
  %2244 = icmp ne ptr %2240, null
  %.not92.i3936 = and i1 %2243, %2244
  %extract.i3938 = lshr i160 %2242, 64
  %2245 = insertelement <2 x i160> poison, i160 %2242, i64 0
  %2246 = insertelement <2 x i160> %2245, i160 %extract.i3938, i64 1
  br i1 %.not92.i3936, label %.cont.cont.i3905, label %2286

2247:                                             ; preds = %2216
  %2248 = add i32 %2230, 2127912214
  %2249 = shl i32 %2230, 12
  %2250 = add i32 %2248, %2249
  %2251 = ashr i32 %2250, 19
  %2252 = xor i32 %2250, %2251
  %2253 = xor i32 %2252, -949894596
  %2254 = add i32 %2253, 374761393
  %2255 = shl i32 %2253, 5
  %2256 = add i32 %2254, %2255
  %2257 = add i32 %2256, -744332180
  %2258 = shl i32 %2256, 9
  %2259 = xor i32 %2257, %2258
  %2260 = add i32 %2259, -42973499
  %2261 = shl i32 %2259, 3
  %2262 = add i32 %2260, %2261
  %2263 = ashr i32 %2262, 16
  %2264 = xor i32 %2262, %2263
  %2265 = xor i32 %2264, -1252372727
  %2266 = load i32, ptr %56, align 8
  %2267 = add i32 %2266, -1
  %2268 = and i32 %2267, %2265
  %2269 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2270 = load ptr, ptr %58, align 8
  %2271 = sext i32 %2268 to i64
  %2272 = shl nsw i64 %2271, 5
  %2273 = getelementptr i8, ptr %2270, i64 %2272
  %2274 = load ptr, ptr %2273, align 8
  %2275 = getelementptr i8, ptr %2273, i64 8
  %2276 = load i160, ptr %2275, align 4
  store ptr %.sroa.0.0564.i3887, ptr %2273, align 8
  store i64 %2219, ptr %2275, align 4
  %.sroa_idx161.i3895 = getelementptr i8, ptr %2273, i64 16
  store i64 %2218, ptr %.sroa_idx161.i3895, align 4
  %.sroa_idx162.i3896 = getelementptr i8, ptr %2273, i64 24
  store i32 %.sroa.17.0561.i3890, ptr %.sroa_idx162.i3896, align 4
  %2277 = icmp ne ptr %2274, @nil_typ
  %2278 = icmp ne ptr %2274, null
  %.not90.i3897 = and i1 %2277, %2278
  %extract607.i3899 = lshr i160 %2276, 64
  %2279 = insertelement <2 x i160> poison, i160 %2276, i64 0
  %2280 = insertelement <2 x i160> %2279, i160 %extract607.i3899, i64 1
  br i1 %.not90.i3897, label %.cont.cont.i3905, label %2286

.cont.cont.i3905:                                 ; preds = %2247, %2231
  %vptr.i142.sroa.speculated.i3908 = phi ptr [ %2240, %2231 ], [ %2274, %2247 ]
  %.in4341 = phi <2 x i160> [ %2246, %2231 ], [ %2280, %2247 ]
  %2281 = trunc <2 x i160> %.in4341 to <2 x i64>
  %2282 = xor i1 %.070565.i3886, true
  %hash_coef_ptr.i.i143.i3911 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3908, i64 8
  %tbl_size_ptr.i.i144.i3912 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3908, i64 16
  %offset_tbl_ptr.i.i145.i3913 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i3908, i64 40
  %hash_coef.i.i146.i3914 = load i64, ptr %hash_coef_ptr.i.i143.i3911, align 4
  %tbl_size.i.i147.i3915 = load i64, ptr %tbl_size_ptr.i.i144.i3912, align 4
  %offset_tbl.i.i148.i3916 = load ptr, ptr %offset_tbl_ptr.i.i145.i3913, align 8
  %product.i.i.i149.i3917 = mul i64 %hash_coef.i.i146.i3914, 4015701072841558310
  %shifted.i.i.i150.i3918 = lshr i64 %product.i.i.i149.i3917, 32
  %xored.i.i.i151.i3919 = xor i64 %shifted.i.i.i150.i3918, %product.i.i.i149.i3917
  %hash.i.i.i152.i3920 = and i64 %xored.i.i.i151.i3919, %tbl_size.i.i147.i3915
  %offset_ptr.i.i153.i3921 = getelementptr i32, ptr %offset_tbl.i.i148.i3916, i64 %hash.i.i.i152.i3920
  %offset.i.i154.i3922 = load i32, ptr %offset_ptr.i.i153.i3921, align 4
  %2283 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2284 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2285 = icmp ult i32 %.0566.i3885, 99
  br i1 %2285, label %2216, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3940

2286:                                             ; preds = %2247, %2231
  %2287 = phi ptr [ %4, %2247 ], [ %3, %2231 ]
  %2288 = load i32, ptr %66, align 4
  store i32 %2288, ptr %2287, align 4
  %2289 = add i32 %2288, 1
  %2290 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2289, ptr %66, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3940

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3940: ; preds = %.cont.cont.i3905, %2286
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i2956

._crit_edge.i2956:                                ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit3940, %2202
  %2291 = add nuw nsw i32 %.060.i2954, 1
  %2292 = icmp slt i32 %2291, %2105
  br i1 %2292, label %2202, label %CuckooMap_insert_keyK_valueV.exit1001

CuckooMap_insert_keyK_valueV.exit1001:            ; preds = %._crit_edge.i2956, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit2938.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1983.thread, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1877.thread, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1771, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit1712, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1877, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1983
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2293 = add nsw i32 %.0357689, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %CuckooMap_insert_keyK_valueV.exit1001, %CuckooMap_get_keyK.exit
  %.2359 = phi i32 [ %2293, %CuckooMap_insert_keyK_valueV.exit1001 ], [ %.0357689, %CuckooMap_get_keyK.exit ]
  %2294 = add nuw nsw i32 %.0355690, 1
  %2295 = icmp slt i32 %.2359, %0
  %2296 = icmp slt i32 %2294, %60
  %spec.select = select i1 %2295, i1 %2296, i1 false
  br i1 %spec.select, label %68, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %.0357.lcssa = phi i32 [ 0, %1 ], [ %.2359, %._crit_edge1 ]
  %2297 = icmp slt i32 %.0357.lcssa, %0
  br i1 %2297, label %._crit_edge.lr.ph.i, label %._crit_edge4

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge3._crit_edge
  %result.i450 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i450, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2298 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2299 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2019 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i2019, ptr noundef nonnull align 32 dereferenceable(29) %result.i450, i64 29, i1 false)
  %2300 = getelementptr i8, ptr %result.i.i2019, i64 29
  store i8 0, ptr %2300, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2019)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2301 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0357.lcssa) #17
  %result.i456 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <29 x i8> <i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %result.i456, align 32
  %2302 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2303 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2304 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2034 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i2034, ptr noundef nonnull align 32 dereferenceable(29) %result.i456, i64 29, i1 false)
  %2305 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2306 = getelementptr i8, ptr %result.i.i2034, i64 29
  store i8 0, ptr %2306, align 1
  %puts.i1036 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2034)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3._crit_edge, %._crit_edge.lr.ph.i
  %.0365 = phi i32 [ %.0357.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge3._crit_edge ]
  %2307 = call i64 @clock()
  %2308 = icmp sgt i32 %.0365, 0
  br i1 %2308, label %.lr.ph695.preheader, label %._crit_edge8

.lr.ph695.preheader:                              ; preds = %._crit_edge4
  %2309 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %2310 = getelementptr inbounds i8, ptr %result.i378, i64 44
  br label %.lr.ph695

.lr.ph695:                                        ; preds = %.lr.ph695.preheader, %._crit_edge5
  %.0354694 = phi i32 [ %.2, %._crit_edge5 ], [ 0, %.lr.ph695.preheader ]
  %.0360693 = phi i1 [ %.3, %._crit_edge5 ], [ true, %.lr.ph695.preheader ]
  %.0363692 = phi i32 [ %2453, %._crit_edge5 ], [ 0, %.lr.ph695.preheader ]
  %2311 = zext nneg i32 %.0363692 to i64
  %2312 = shl nuw nsw i64 %2311, 2
  %2313 = getelementptr i8, ptr %result.i4.i, i64 %2312
  %2314 = load i32, ptr %2313, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %2314 to i160
  %2315 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %2316 = load ptr, ptr %40, align 8
  %2317 = call i32 %2316({ ptr, i160 } %2315) #7
  %2318 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %2319 = load i32, ptr %42, align 8
  %2320 = add i32 %2319, -1
  %2321 = and i32 %2320, %2317
  %2322 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2323 = sext i32 %2321 to i64
  %2324 = shl nsw i64 %2323, 5
  %2325 = getelementptr i8, ptr %2322, i64 %2324
  %2326 = load ptr, ptr %2325, align 8
  %2327 = icmp ne ptr %2326, @nil_typ
  %2328 = icmp ne ptr %2326, null
  %.not51.i = and i1 %2327, %2328
  br i1 %.not51.i, label %2329, label %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

2329:                                             ; preds = %.lr.ph695
  %2330 = getelementptr i8, ptr %2325, i64 8
  %2331 = load i64, ptr %2330, align 4
  %.sroa_idx.i2081 = getelementptr i8, ptr %2325, i64 16
  %2332 = load i64, ptr %.sroa_idx.i2081, align 4
  %2333 = inttoptr i64 %2331 to ptr
  %2334 = inttoptr i64 %2332 to ptr
  %hash_coef_ptr.i.i53.i = getelementptr i8, ptr %2326, i64 8
  %tbl_size_ptr.i.i54.i = getelementptr i8, ptr %2326, i64 16
  %offset_tbl_ptr.i.i55.i = getelementptr i8, ptr %2326, i64 40
  %hash_coef.i.i56.i = load i64, ptr %hash_coef_ptr.i.i53.i, align 4, !noalias !395
  %tbl_size.i.i57.i = load i64, ptr %tbl_size_ptr.i.i54.i, align 4, !noalias !395
  %offset_tbl.i.i58.i = load ptr, ptr %offset_tbl_ptr.i.i55.i, align 8, !noalias !395
  %product.i.i.i59.i = mul i64 %hash_coef.i.i56.i, 4015701072841558310
  %shifted.i.i.i60.i = lshr i64 %product.i.i.i59.i, 32
  %xored.i.i.i61.i = xor i64 %shifted.i.i.i60.i, %product.i.i.i59.i
  %hash.i.i.i62.i = and i64 %xored.i.i.i61.i, %tbl_size.i.i57.i
  %offset_ptr.i.i63.i = getelementptr i32, ptr %offset_tbl.i.i58.i, i64 %hash.i.i.i62.i
  %offset.i.i64.i = load i32, ptr %offset_ptr.i.i63.i, align 4, !noalias !395
  %2335 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2326, 0
  %2336 = insertvalue { ptr, ptr, ptr, i32 } %2335, ptr %2333, 1
  %2337 = insertvalue { ptr, ptr, ptr, i32 } %2336, ptr %2334, 2
  %2338 = insertvalue { ptr, ptr, ptr, i32 } %2337, i32 %offset.i.i64.i, 3
  %2339 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2340 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2326) #35
  %2341 = sext i32 %offset.i.i64.i to i64
  %2342 = getelementptr ptr, ptr %2326, i64 %2341
  %2343 = getelementptr i8, ptr %2342, i64 64
  %2344 = load ptr, ptr %2343, align 8
  %result.i.i2082 = call ptr %2344({ ptr, ptr, ptr, i32 } %2338, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2345 = call i32 %result.i.i2082({ ptr, ptr, ptr, i32 } %2338, { ptr, ptr, ptr, i32 } %2338, ptr nonnull align 8 %2) #7
  %2346 = icmp eq i32 %2345, %2317
  br i1 %2346, label %._crit_edge.i2083, label %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

._crit_edge.i2083:                                ; preds = %2329
  %2347 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2348 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2326)
  %2349 = getelementptr i8, ptr %2342, i64 48
  %2350 = load ptr, ptr %2349, align 8
  %result.i66.i = call ptr %2350({ ptr, ptr, ptr, i32 } %2338, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2351 = call { ptr, i160 } %result.i66.i({ ptr, ptr, ptr, i32 } %2338, { ptr, ptr, ptr, i32 } %2338, ptr nonnull align 8 %2) #7
  %2352 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2353 = load ptr, ptr %41, align 8
  %2354 = call i1 %2353({ ptr, i160 } %2351, { ptr, i160 } %2315) #7
  br i1 %2354, label %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, label %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread

CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread: ; preds = %._crit_edge.i2083, %.lr.ph695, %2329
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2365

CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit: ; preds = %._crit_edge.i2083
  %2355 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2356 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2326)
  %2357 = getelementptr i8, ptr %2342, i64 56
  %2358 = load ptr, ptr %2357, align 8
  %result.i67.i = call ptr %2358({ ptr, ptr, ptr, i32 } %2338, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2359 = call { ptr, i160 } %result.i67.i({ ptr, ptr, ptr, i32 } %2338, { ptr, ptr, ptr, i32 } %2338, ptr nonnull align 8 %2) #7
  %.fca.0.extract28.i = extractvalue { ptr, i160 } %2359, 0
  store ptr @nil_typ, ptr %2325, align 8
  %2360 = load i32, ptr %2310, align 4
  %2361 = add i32 %2360, -1
  store i32 %2361, ptr %2310, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2362 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2363 = icmp ne ptr %.fca.0.extract28.i, @nil_typ
  %2364 = icmp ne ptr %.fca.0.extract28.i, null
  %.not63.i1073 = and i1 %2363, %2364
  br i1 %.not63.i1073, label %CuckooMap_remove_keyK.exit, label %2365

2365:                                             ; preds = %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread, %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit
  %2366 = add i32 %2317, 2127912214
  %2367 = shl i32 %2317, 12
  %2368 = add i32 %2366, %2367
  %2369 = ashr i32 %2368, 19
  %2370 = xor i32 %2368, %2369
  %2371 = xor i32 %2370, -949894596
  %2372 = add i32 %2371, 374761393
  %2373 = shl i32 %2371, 5
  %2374 = add i32 %2372, %2373
  %2375 = add i32 %2374, -744332180
  %2376 = shl i32 %2374, 9
  %2377 = xor i32 %2375, %2376
  %2378 = add i32 %2377, -42973499
  %2379 = shl i32 %2377, 3
  %2380 = add i32 %2378, %2379
  %2381 = ashr i32 %2380, 16
  %2382 = xor i32 %2380, %2381
  %2383 = xor i32 %2382, -1252372727
  %2384 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2385 = load i32, ptr %42, align 8
  %2386 = add i32 %2385, -1
  %2387 = and i32 %2386, %2383
  %2388 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2389 = sext i32 %2387 to i64
  %2390 = shl nsw i64 %2389, 5
  %2391 = getelementptr i8, ptr %2388, i64 %2390
  %2392 = load ptr, ptr %2391, align 8
  %2393 = icmp ne ptr %2392, @nil_typ
  %2394 = icmp ne ptr %2392, null
  %.not51.i2113 = and i1 %2393, %2394
  br i1 %.not51.i2113, label %2395, label %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137

2395:                                             ; preds = %2365
  %2396 = getelementptr i8, ptr %2391, i64 8
  %2397 = load i64, ptr %2396, align 4
  %.sroa_idx.i2117 = getelementptr i8, ptr %2391, i64 16
  %2398 = load i64, ptr %.sroa_idx.i2117, align 4
  %2399 = inttoptr i64 %2397 to ptr
  %2400 = inttoptr i64 %2398 to ptr
  %hash_coef_ptr.i.i53.i2118 = getelementptr i8, ptr %2392, i64 8
  %tbl_size_ptr.i.i54.i2119 = getelementptr i8, ptr %2392, i64 16
  %offset_tbl_ptr.i.i55.i2120 = getelementptr i8, ptr %2392, i64 40
  %hash_coef.i.i56.i2121 = load i64, ptr %hash_coef_ptr.i.i53.i2118, align 4, !noalias !398
  %tbl_size.i.i57.i2122 = load i64, ptr %tbl_size_ptr.i.i54.i2119, align 4, !noalias !398
  %offset_tbl.i.i58.i2123 = load ptr, ptr %offset_tbl_ptr.i.i55.i2120, align 8, !noalias !398
  %product.i.i.i59.i2124 = mul i64 %hash_coef.i.i56.i2121, 4015701072841558310
  %shifted.i.i.i60.i2125 = lshr i64 %product.i.i.i59.i2124, 32
  %xored.i.i.i61.i2126 = xor i64 %shifted.i.i.i60.i2125, %product.i.i.i59.i2124
  %hash.i.i.i62.i2127 = and i64 %xored.i.i.i61.i2126, %tbl_size.i.i57.i2122
  %offset_ptr.i.i63.i2128 = getelementptr i32, ptr %offset_tbl.i.i58.i2123, i64 %hash.i.i.i62.i2127
  %offset.i.i64.i2129 = load i32, ptr %offset_ptr.i.i63.i2128, align 4, !noalias !398
  %2401 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2392, 0
  %2402 = insertvalue { ptr, ptr, ptr, i32 } %2401, ptr %2399, 1
  %2403 = insertvalue { ptr, ptr, ptr, i32 } %2402, ptr %2400, 2
  %2404 = insertvalue { ptr, ptr, ptr, i32 } %2403, i32 %offset.i.i64.i2129, 3
  %2405 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2406 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2392) #35
  %2407 = sext i32 %offset.i.i64.i2129 to i64
  %2408 = getelementptr ptr, ptr %2392, i64 %2407
  %2409 = getelementptr i8, ptr %2408, i64 64
  %2410 = load ptr, ptr %2409, align 8
  %result.i.i2130 = call ptr %2410({ ptr, ptr, ptr, i32 } %2404, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2411 = call i32 %result.i.i2130({ ptr, ptr, ptr, i32 } %2404, { ptr, ptr, ptr, i32 } %2404, ptr nonnull align 8 %2) #7
  %2412 = icmp eq i32 %2411, %2317
  br i1 %2412, label %._crit_edge.i2131, label %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137

._crit_edge.i2131:                                ; preds = %2395
  %2413 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2414 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2392)
  %2415 = getelementptr i8, ptr %2408, i64 48
  %2416 = load ptr, ptr %2415, align 8
  %result.i66.i2132 = call ptr %2416({ ptr, ptr, ptr, i32 } %2404, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2417 = call { ptr, i160 } %result.i66.i2132({ ptr, ptr, ptr, i32 } %2404, { ptr, ptr, ptr, i32 } %2404, ptr nonnull align 8 %2) #7
  %2418 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2419 = load ptr, ptr %41, align 8
  %2420 = call i1 %2419({ ptr, i160 } %2417, { ptr, i160 } %2315) #7
  br i1 %2420, label %2421, label %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137

2421:                                             ; preds = %._crit_edge.i2131
  %2422 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2423 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2392)
  %2424 = getelementptr i8, ptr %2408, i64 56
  %2425 = load ptr, ptr %2424, align 8
  %result.i67.i2134 = call ptr %2425({ ptr, ptr, ptr, i32 } %2404, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2426 = call { ptr, i160 } %result.i67.i2134({ ptr, ptr, ptr, i32 } %2404, { ptr, ptr, ptr, i32 } %2404, ptr nonnull align 8 %2) #7
  %.fca.0.extract28.i2135 = extractvalue { ptr, i160 } %2426, 0
  %.fca.1.extract29.i2136 = extractvalue { ptr, i160 } %2426, 1
  store ptr @nil_typ, ptr %2391, align 8
  %2427 = load i32, ptr %2310, align 4
  %2428 = add i32 %2427, -1
  store i32 %2428, ptr %2310, align 4
  br label %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137

CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137: ; preds = %2365, %2395, %._crit_edge.i2131, %2421
  %.reg2mem47.sroa.3.088.i2114 = phi i160 [ %.fca.1.extract29.i2136, %2421 ], [ poison, %._crit_edge.i2131 ], [ poison, %2365 ], [ poison, %2395 ]
  %2429 = phi ptr [ %.fca.0.extract28.i2135, %2421 ], [ @nil_typ, %._crit_edge.i2131 ], [ @nil_typ, %2365 ], [ @nil_typ, %2395 ]
  %.reload44.fca.0.insert.i2115 = insertvalue { ptr, i160 } poison, ptr %2429, 0
  %.reload44.fca.1.insert.i2116 = insertvalue { ptr, i160 } %.reload44.fca.0.insert.i2115, i160 %.reg2mem47.sroa.3.088.i2114, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2430 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2431 = icmp ne ptr %2429, @nil_typ
  %2432 = icmp ne ptr %2429, null
  %.not65.not.not.i1079 = and i1 %2431, %2432
  %cond.fr.i1080 = freeze i1 %.not65.not.not.i1079
  %spec.select.i1081 = select i1 %cond.fr.i1080, ptr %2429, ptr @nil_typ
  br label %CuckooMap_remove_keyK.exit

CuckooMap_remove_keyK.exit:                       ; preds = %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit, %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137
  %.pn.i1082 = phi { ptr, i160 } [ %2359, %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %.reload44.fca.1.insert.i2116, %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137 ]
  %2433 = phi ptr [ %.fca.0.extract28.i, %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit ], [ %spec.select.i1081, %CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2137 ]
  %2434 = icmp ne ptr %2433, @nil_typ
  %2435 = icmp ne ptr %2433, null
  %.not369 = and i1 %2434, %2435
  br i1 %.not369, label %2436, label %._crit_edge.lr.ph.i2171

2436:                                             ; preds = %CuckooMap_remove_keyK.exit
  %.fca.1.extract..sroa.354.0106.i1083 = extractvalue { ptr, i160 } %.pn.i1082, 1
  %.sroa.2256.8.extract.trunc = trunc i160 %.fca.1.extract..sroa.354.0106.i1083 to i32
  %2437 = add i32 %2314, 1
  %.not = icmp eq i32 %2437, %.sroa.2256.8.extract.trunc
  br i1 %.not, label %._crit_edge6, label %._crit_edge.lr.ph.i2152

._crit_edge.lr.ph.i2152:                          ; preds = %2436
  %result.i463 = call noalias align 64 dereferenceable_or_null(46) ptr @bump_malloc_inner(i64 noundef 46, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %2438 = load <45 x i8>, ptr @fcfel_Warning_Remove_returned_wrong_value_for_key_, align 64
  store <45 x i8> %2438, ptr %result.i463, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2439 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2440 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2151 = call noalias dereferenceable_or_null(46) ptr @bump_malloc_inner(i64 noundef 46, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(45) %result.i.i2151, ptr noundef nonnull align 64 dereferenceable(45) %result.i463, i64 45, i1 false)
  %2441 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2442 = getelementptr i8, ptr %result.i.i2151, i64 45
  store i8 0, ptr %2442, align 1
  %puts.i1105 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2151)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2443 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2444 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %2314) #17
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %2436, %._crit_edge.lr.ph.i2152
  %.2362 = phi i1 [ false, %._crit_edge.lr.ph.i2152 ], [ %.0360693, %2436 ]
  %2445 = add i32 %.0354694, 1
  br label %._crit_edge5

._crit_edge.lr.ph.i2171:                          ; preds = %CuckooMap_remove_keyK.exit
  %result.i469 = call noalias align 64 dereferenceable_or_null(38) ptr @bump_malloc_inner(i64 noundef 38, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %2446 = load <37 x i8>, ptr @lmasg_Warning_Remove_returned_Nil_for_key_, align 64
  store <37 x i8> %2446, ptr %result.i469, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2447 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2448 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2170 = call noalias dereferenceable_or_null(38) ptr @bump_malloc_inner(i64 noundef 38, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(37) %result.i.i2170, ptr noundef nonnull align 64 dereferenceable(37) %result.i469, i64 37, i1 false)
  %2449 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2450 = getelementptr i8, ptr %result.i.i2170, i64 37
  store i8 0, ptr %2450, align 1
  %puts.i1125 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2170)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2451 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2452 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %2314) #17
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge6, %._crit_edge.lr.ph.i2171
  %.3 = phi i1 [ %.2362, %._crit_edge6 ], [ false, %._crit_edge.lr.ph.i2171 ]
  %.2 = phi i32 [ %2445, %._crit_edge6 ], [ %.0354694, %._crit_edge.lr.ph.i2171 ]
  %2453 = add nuw nsw i32 %.0363692, 1
  %2454 = icmp slt i32 %2453, %.0365
  br i1 %2454, label %.lr.ph695, label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge5, %._crit_edge4
  %.0360.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.3, %._crit_edge5 ]
  %.0354.lcssa = phi i32 [ 0, %._crit_edge4 ], [ %.2, %._crit_edge5 ]
  %2455 = call i64 @clock()
  %.not370 = icmp eq i32 %.0354.lcssa, %.0365
  %2456 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %2457 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %2458 = getelementptr inbounds i8, ptr %result.i378, i64 44
  %2459 = load i32, ptr %2458, align 4
  %.not371 = icmp eq i32 %2459, 0
  %2460 = select i1 %.not371, i1 %.not370, i1 false
  %spec.select377 = select i1 %2460, i1 %.0360.lcssa, i1 false
  br i1 %2308, label %2461, label %._crit_edge.lr.ph.i2311

2461:                                             ; preds = %._crit_edge8
  %2462 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %2463 = load i32, ptr %result.i4.i, align 1
  %.sroa.2.sroa.0.0.insert.ext.i2176 = zext i32 %2463 to i160
  %2464 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i2176, 1
  %2465 = load ptr, ptr %40, align 8
  %2466 = call i32 %2465({ ptr, i160 } %2464) #7
  %2467 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %2468 = load i32, ptr %42, align 8
  %2469 = add i32 %2468, -1
  %2470 = and i32 %2469, %2466
  %2471 = load ptr, ptr %43, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2472 = sext i32 %2470 to i64
  %2473 = shl nsw i64 %2472, 5
  %2474 = getelementptr i8, ptr %2471, i64 %2473
  %2475 = load ptr, ptr %2474, align 8
  %2476 = icmp ne ptr %2475, @nil_typ
  %2477 = icmp ne ptr %2475, null
  %.not44.i2218 = and i1 %2476, %2477
  br i1 %.not44.i2218, label %2478, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread

2478:                                             ; preds = %2461
  %2479 = getelementptr i8, ptr %2474, i64 8
  %2480 = load i64, ptr %2479, align 4
  %.sroa_idx.i2222 = getelementptr i8, ptr %2474, i64 16
  %2481 = load i64, ptr %.sroa_idx.i2222, align 4
  %2482 = inttoptr i64 %2480 to ptr
  %2483 = inttoptr i64 %2481 to ptr
  %hash_coef_ptr.i.i46.i2223 = getelementptr i8, ptr %2475, i64 8
  %tbl_size_ptr.i.i47.i2224 = getelementptr i8, ptr %2475, i64 16
  %offset_tbl_ptr.i.i48.i2225 = getelementptr i8, ptr %2475, i64 40
  %hash_coef.i.i49.i2226 = load i64, ptr %hash_coef_ptr.i.i46.i2223, align 4, !noalias !401
  %tbl_size.i.i50.i2227 = load i64, ptr %tbl_size_ptr.i.i47.i2224, align 4, !noalias !401
  %offset_tbl.i.i51.i2228 = load ptr, ptr %offset_tbl_ptr.i.i48.i2225, align 8, !noalias !401
  %product.i.i.i52.i2229 = mul i64 %hash_coef.i.i49.i2226, 4015701072841558310
  %shifted.i.i.i53.i2230 = lshr i64 %product.i.i.i52.i2229, 32
  %xored.i.i.i54.i2231 = xor i64 %shifted.i.i.i53.i2230, %product.i.i.i52.i2229
  %hash.i.i.i55.i2232 = and i64 %xored.i.i.i54.i2231, %tbl_size.i.i50.i2227
  %offset_ptr.i.i56.i2233 = getelementptr i32, ptr %offset_tbl.i.i51.i2228, i64 %hash.i.i.i55.i2232
  %offset.i.i57.i2234 = load i32, ptr %offset_ptr.i.i56.i2233, align 4, !noalias !401
  %2484 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2475, 0
  %2485 = insertvalue { ptr, ptr, ptr, i32 } %2484, ptr %2482, 1
  %2486 = insertvalue { ptr, ptr, ptr, i32 } %2485, ptr %2483, 2
  %2487 = insertvalue { ptr, ptr, ptr, i32 } %2486, i32 %offset.i.i57.i2234, 3
  %2488 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2489 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2475) #35
  %2490 = sext i32 %offset.i.i57.i2234 to i64
  %2491 = getelementptr ptr, ptr %2475, i64 %2490
  %2492 = getelementptr i8, ptr %2491, i64 64
  %2493 = load ptr, ptr %2492, align 8
  %result.i.i2235 = call ptr %2493({ ptr, ptr, ptr, i32 } %2487, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2494 = call i32 %result.i.i2235({ ptr, ptr, ptr, i32 } %2487, { ptr, ptr, ptr, i32 } %2487, ptr nonnull align 8 %2) #7
  %2495 = icmp eq i32 %2494, %2466
  br i1 %2495, label %._crit_edge.i2236, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread

._crit_edge.i2236:                                ; preds = %2478
  %2496 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2497 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2475)
  %2498 = getelementptr i8, ptr %2491, i64 48
  %2499 = load ptr, ptr %2498, align 8
  %result.i59.i2237 = call ptr %2499({ ptr, ptr, ptr, i32 } %2487, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2500 = call { ptr, i160 } %result.i59.i2237({ ptr, ptr, ptr, i32 } %2487, { ptr, ptr, ptr, i32 } %2487, ptr nonnull align 8 %2) #7
  %2501 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2502 = load ptr, ptr %41, align 8
  %2503 = call i1 %2502({ ptr, i160 } %2500, { ptr, i160 } %2464) #7
  br i1 %2503, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread: ; preds = %._crit_edge.i2236, %2461, %2478
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %2512

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242: ; preds = %._crit_edge.i2236
  %2504 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2505 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2475)
  %2506 = getelementptr i8, ptr %2491, i64 56
  %2507 = load ptr, ptr %2506, align 8
  %result.i60.i2239 = call ptr %2507({ ptr, ptr, ptr, i32 } %2487, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2508 = call { ptr, i160 } %result.i60.i2239({ ptr, ptr, ptr, i32 } %2487, { ptr, ptr, ptr, i32 } %2487, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2240 = extractvalue { ptr, i160 } %2508, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2509 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2510 = icmp ne ptr %.fca.0.extract21.i2240, @nil_typ
  %2511 = icmp ne ptr %.fca.0.extract21.i2240, null
  %.not63.i1177 = and i1 %2510, %2511
  br i1 %.not63.i1177, label %CuckooMap_get_keyK.exit1190, label %2512

2512:                                             ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242.thread, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242
  %2513 = add i32 %2466, 2127912214
  %2514 = shl i32 %2466, 12
  %2515 = add i32 %2513, %2514
  %2516 = ashr i32 %2515, 19
  %2517 = xor i32 %2515, %2516
  %2518 = xor i32 %2517, -949894596
  %2519 = add i32 %2518, 374761393
  %2520 = shl i32 %2518, 5
  %2521 = add i32 %2519, %2520
  %2522 = add i32 %2521, -744332180
  %2523 = shl i32 %2521, 9
  %2524 = xor i32 %2522, %2523
  %2525 = add i32 %2524, -42973499
  %2526 = shl i32 %2524, 3
  %2527 = add i32 %2525, %2526
  %2528 = ashr i32 %2527, 16
  %2529 = xor i32 %2527, %2528
  %2530 = xor i32 %2529, -1252372727
  %2531 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2532 = load i32, ptr %42, align 8
  %2533 = add i32 %2532, -1
  %2534 = and i32 %2533, %2530
  %2535 = load ptr, ptr %44, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2536 = sext i32 %2534 to i64
  %2537 = shl nsw i64 %2536, 5
  %2538 = getelementptr i8, ptr %2535, i64 %2537
  %2539 = load ptr, ptr %2538, align 8
  %2540 = icmp ne ptr %2539, @nil_typ
  %2541 = icmp ne ptr %2539, null
  %.not44.i2272 = and i1 %2540, %2541
  br i1 %.not44.i2272, label %2542, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296

2542:                                             ; preds = %2512
  %2543 = getelementptr i8, ptr %2538, i64 8
  %2544 = load i64, ptr %2543, align 4
  %.sroa_idx.i2276 = getelementptr i8, ptr %2538, i64 16
  %2545 = load i64, ptr %.sroa_idx.i2276, align 4
  %2546 = inttoptr i64 %2544 to ptr
  %2547 = inttoptr i64 %2545 to ptr
  %hash_coef_ptr.i.i46.i2277 = getelementptr i8, ptr %2539, i64 8
  %tbl_size_ptr.i.i47.i2278 = getelementptr i8, ptr %2539, i64 16
  %offset_tbl_ptr.i.i48.i2279 = getelementptr i8, ptr %2539, i64 40
  %hash_coef.i.i49.i2280 = load i64, ptr %hash_coef_ptr.i.i46.i2277, align 4, !noalias !404
  %tbl_size.i.i50.i2281 = load i64, ptr %tbl_size_ptr.i.i47.i2278, align 4, !noalias !404
  %offset_tbl.i.i51.i2282 = load ptr, ptr %offset_tbl_ptr.i.i48.i2279, align 8, !noalias !404
  %product.i.i.i52.i2283 = mul i64 %hash_coef.i.i49.i2280, 4015701072841558310
  %shifted.i.i.i53.i2284 = lshr i64 %product.i.i.i52.i2283, 32
  %xored.i.i.i54.i2285 = xor i64 %shifted.i.i.i53.i2284, %product.i.i.i52.i2283
  %hash.i.i.i55.i2286 = and i64 %xored.i.i.i54.i2285, %tbl_size.i.i50.i2281
  %offset_ptr.i.i56.i2287 = getelementptr i32, ptr %offset_tbl.i.i51.i2282, i64 %hash.i.i.i55.i2286
  %offset.i.i57.i2288 = load i32, ptr %offset_ptr.i.i56.i2287, align 4, !noalias !404
  %2548 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2539, 0
  %2549 = insertvalue { ptr, ptr, ptr, i32 } %2548, ptr %2546, 1
  %2550 = insertvalue { ptr, ptr, ptr, i32 } %2549, ptr %2547, 2
  %2551 = insertvalue { ptr, ptr, ptr, i32 } %2550, i32 %offset.i.i57.i2288, 3
  %2552 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2553 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2539) #35
  %2554 = sext i32 %offset.i.i57.i2288 to i64
  %2555 = getelementptr ptr, ptr %2539, i64 %2554
  %2556 = getelementptr i8, ptr %2555, i64 64
  %2557 = load ptr, ptr %2556, align 8
  %result.i.i2289 = call ptr %2557({ ptr, ptr, ptr, i32 } %2551, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2558 = call i32 %result.i.i2289({ ptr, ptr, ptr, i32 } %2551, { ptr, ptr, ptr, i32 } %2551, ptr nonnull align 8 %2) #7
  %2559 = icmp eq i32 %2558, %2466
  br i1 %2559, label %._crit_edge.i2290, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296

._crit_edge.i2290:                                ; preds = %2542
  %2560 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2561 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2539)
  %2562 = getelementptr i8, ptr %2555, i64 48
  %2563 = load ptr, ptr %2562, align 8
  %result.i59.i2291 = call ptr %2563({ ptr, ptr, ptr, i32 } %2551, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2564 = call { ptr, i160 } %result.i59.i2291({ ptr, ptr, ptr, i32 } %2551, { ptr, ptr, ptr, i32 } %2551, ptr nonnull align 8 %2) #7
  %2565 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2566 = load ptr, ptr %41, align 8
  %2567 = call i1 %2566({ ptr, i160 } %2564, { ptr, i160 } %2464) #7
  br i1 %2567, label %2568, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296

2568:                                             ; preds = %._crit_edge.i2290
  %2569 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %2570 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2539)
  %2571 = getelementptr i8, ptr %2555, i64 56
  %2572 = load ptr, ptr %2571, align 8
  %result.i60.i2293 = call ptr %2572({ ptr, ptr, ptr, i32 } %2551, ptr nocapture nofree noundef nonnull readonly %2) #16
  %2573 = call { ptr, i160 } %result.i60.i2293({ ptr, ptr, ptr, i32 } %2551, { ptr, ptr, ptr, i32 } %2551, ptr nonnull align 8 %2) #7
  %.fca.0.extract21.i2294 = extractvalue { ptr, i160 } %2573, 0
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296: ; preds = %2512, %2542, %._crit_edge.i2290, %2568
  %2574 = phi ptr [ %.fca.0.extract21.i2294, %2568 ], [ @nil_typ, %._crit_edge.i2290 ], [ @nil_typ, %2512 ], [ @nil_typ, %2542 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2575 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2576 = icmp ne ptr %2574, @nil_typ
  %2577 = icmp ne ptr %2574, null
  %.not65.not.not.i1183 = and i1 %2576, %2577
  %cond.fr.i1184 = freeze i1 %.not65.not.not.i1183
  %spec.select.i1185 = select i1 %cond.fr.i1184, ptr %2574, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit1190

CuckooMap_get_keyK.exit1190:                      ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296
  %2578 = phi ptr [ %.fca.0.extract21.i2240, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2242 ], [ %spec.select.i1185, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit2296 ]
  %2579 = icmp eq ptr %2578, @nil_typ
  %2580 = icmp eq ptr %2578, null
  %.not374.not = or i1 %2579, %2580
  %spec.select376 = select i1 %.not374.not, i1 %spec.select377, i1 false
  br label %._crit_edge.lr.ph.i2311

._crit_edge.lr.ph.i2311:                          ; preds = %CuckooMap_get_keyK.exit1190, %._crit_edge8
  %.6 = phi i1 [ %spec.select377, %._crit_edge8 ], [ %spec.select376, %CuckooMap_get_keyK.exit1190 ]
  %result.i478 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i478, align 16
  %2581 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2582 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2583 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2310 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i2310, ptr noundef nonnull align 16 dereferenceable(13) %result.i478, i64 13, i1 false)
  %2584 = sub i64 %2455, %2307
  %2585 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2586 = getelementptr i8, ptr %result.i.i2310, i64 13
  store i8 0, ptr %2586, align 1
  %puts.i1210 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2310)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i98.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98.i, align 16
  %result.i.i356.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i98.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356.i)
  %2587 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0365) #17
  %result.i104.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104.i, align 16
  %result.i.i370.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i104.i, i64 14, i1 false)
  %puts.i294.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370.i)
  %2588 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2584) #17
  %result.i110.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110.i, align 4
  %result.i.i389.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i110.i, i64 3, i1 false)
  %puts.i314.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  br i1 %2308, label %._crit_edge1.i, label %._crit_edge.lr.ph.i2330

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i2311
  %2589 = icmp sgt i64 %2584, 0
  br i1 %2589, label %2590, label %._crit_edge.lr.ph.i409.i

2590:                                             ; preds = %._crit_edge1.i
  %2591 = mul i64 %2584, 1000000
  %2592 = zext nneg i32 %.0365 to i64
  %2593 = sdiv i64 %2591, %2592
  br label %._crit_edge.lr.ph.i409.i

._crit_edge.lr.ph.i409.i:                         ; preds = %2590, %._crit_edge1.i
  %.0.i = phi i64 [ %2593, %2590 ], [ 0, %._crit_edge1.i ]
  %result.i115.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115.i, align 16
  %result.i.i408.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i115.i, i64 15, i1 false)
  %puts.i334.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  %2594 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i121.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121.i, align 4
  %result.i.i427.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i121.i, i64 3, i1 false)
  %2595 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts.i354.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  br label %._crit_edge.lr.ph.i2330

._crit_edge.lr.ph.i2330:                          ; preds = %._crit_edge.lr.ph.i2311, %._crit_edge.lr.ph.i409.i
  %result.i482 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i482, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2596 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2597 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2329 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i2329, ptr noundef nonnull align 32 dereferenceable(18) %result.i482, i64 18, i1 false)
  %2598 = getelementptr i8, ptr %result.i.i2329, i64 18
  store i8 0, ptr %2598, align 1
  %puts.i1230 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2329)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %.6, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2599 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2600 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2348 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <4 x i8> %., ptr %result.i.i2348, align 1
  %2601 = getelementptr i8, ptr %result.i.i2348, i64 4
  store i8 0, ptr %2601, align 1
  %puts.i1250 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2348)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i497 = call noalias align 32 dereferenceable_or_null(21) ptr @bump_malloc_inner(i64 noundef 21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <20 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %result.i497, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2602 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2603 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2367 = call noalias dereferenceable_or_null(21) ptr @bump_malloc_inner(i64 noundef 21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(20) %result.i.i2367, ptr noundef nonnull align 32 dereferenceable(20) %result.i497, i64 20, i1 false)
  %2604 = getelementptr i8, ptr %result.i.i2367, i64 20
  store i8 0, ptr %2604, align 1
  %puts.i1270 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2367)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %2605 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0354.lcssa) #17
  %2606 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %2607 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %2608 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #35
  %result.i.i2386 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store i8 41, ptr %result.i.i2386, align 1
  %2609 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2610 = getelementptr i8, ptr %result.i.i2386, i64 1
  store i8 0, ptr %2610, align 1
  %puts.i1290 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i2386)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define noundef i32 @main() local_unnamed_addr {
._crit_edge.lr.ph.i:
  %0 = alloca [0 x ptr], align 8
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %oldProtect.i155.i = alloca i32, align 4
  %oldProtect.i.i31 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %oldProtect.i154.i = alloca i32, align 4
  %oldProtect.i.i = alloca i32, align 4
  tail call void @setup_landing_pad()
  %result.i = tail call noalias align 32 dereferenceable_or_null(23) ptr @bump_malloc_inner(i64 noundef 23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <22 x i8> <i8 45, i8 45, i8 45, i8 32, i8 77, i8 97, i8 112, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 45, i8 45, i8 45>, ptr %result.i, align 32
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i = tail call noalias dereferenceable_or_null(23) ptr @bump_malloc_inner(i64 noundef 23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(22) %result.i.i, ptr noundef nonnull align 32 dereferenceable(22) %result.i, i64 22, i1 false)
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts.i = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i150.i = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i150.i, align 8
  %28 = getelementptr inbounds i8, ptr %result.i150.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i150.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %29, align 8
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i150.i) #39
  %result.i151.i = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i.i)
  %result.i152.i = call i32 @VirtualProtect(ptr nofree %result.i151.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i151.i, ptr noalias nofree noundef nonnull readnone @rabbojnpqi, ptr noalias nofree noundef nonnull readnone @i32_hasher) #39
  %ret.i.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i151.i) #40
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i151.i) #39
  %result.i153.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i154.i)
  %result.i155.i = call i32 @VirtualProtect(ptr nofree %result.i153.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i154.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i154.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i153.i, ptr noalias nofree noundef nonnull readnone @bnwmaetavp, ptr noalias nofree noundef nonnull readnone @i32_eq) #39
  %ret.i156.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i153.i) #40
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i153.i) #39
  %33 = getelementptr inbounds i8, ptr %result.i150.i, i64 48
  store ptr %ret.i.i, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i150.i, i64 56
  store ptr %ret.i156.i, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i150.i, i64 40
  store i32 8, ptr %35, align 8
  %result.i.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %36 = getelementptr inbounds i8, ptr %result.i150.i, i64 24
  store ptr %result.i.i.i, ptr %36, align 8
  %result.i9.i.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %37 = getelementptr inbounds i8, ptr %result.i150.i, i64 32
  store ptr %result.i9.i.i, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %39 = call i64 @clock()
  %40 = getelementptr inbounds i8, ptr %result.i150.i, i64 44
  %41 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i150.i, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr undef, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 10, 3
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %CuckooMap_insert_keyK_valueV.exit.i, %._crit_edge.lr.ph.i
  %.0213.i = phi i32 [ %44, %CuckooMap_insert_keyK_valueV.exit.i ], [ 0, %._crit_edge.lr.ph.i ]
  %44 = add nuw nsw i32 %.0213.i, 1
  %.sroa.0131.0.insert.ext.i = zext nneg i32 %.0213.i to i160
  %45 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0131.0.insert.ext.i, 1
  %.sroa.0128.0.insert.ext.i = zext nneg i32 %44 to i160
  %46 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0128.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %47 = load ptr, ptr %33, align 8
  %48 = call i32 %47({ ptr, i160 } %45) #7
  %49 = load i32, ptr %35, align 8
  %50 = add i32 %49, -1
  %51 = and i32 %50, %48
  %52 = load ptr, ptr %36, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %54 = sext i32 %51 to i64
  %55 = shl nsw i64 %54, 5
  %56 = getelementptr i8, ptr %52, i64 %55
  %57 = load ptr, ptr %56, align 8
  %58 = getelementptr i8, ptr %56, i64 8
  %59 = icmp ne ptr %57, @nil_typ
  %60 = icmp ne ptr %57, null
  %.not64.i.i = and i1 %59, %60
  br i1 %.not64.i.i, label %61, label %159

61:                                               ; preds = %._crit_edge.i
  %62 = load i64, ptr %58, align 4
  %.sroa_idx.i.i = getelementptr i8, ptr %56, i64 16
  %63 = load i64, ptr %.sroa_idx.i.i, align 4
  %64 = inttoptr i64 %62 to ptr
  %65 = inttoptr i64 %63 to ptr
  %hash_coef_ptr.i.i66.i.i = getelementptr i8, ptr %57, i64 8
  %tbl_size_ptr.i.i67.i.i = getelementptr i8, ptr %57, i64 16
  %offset_tbl_ptr.i.i68.i.i = getelementptr i8, ptr %57, i64 40
  %hash_coef.i.i69.i.i = load i64, ptr %hash_coef_ptr.i.i66.i.i, align 4, !noalias !407
  %tbl_size.i.i70.i.i = load i64, ptr %tbl_size_ptr.i.i67.i.i, align 4, !noalias !407
  %offset_tbl.i.i71.i.i = load ptr, ptr %offset_tbl_ptr.i.i68.i.i, align 8, !noalias !407
  %product.i.i.i72.i.i = mul i64 %hash_coef.i.i69.i.i, 4015701072841558310
  %shifted.i.i.i73.i.i = lshr i64 %product.i.i.i72.i.i, 32
  %xored.i.i.i74.i.i = xor i64 %shifted.i.i.i73.i.i, %product.i.i.i72.i.i
  %hash.i.i.i75.i.i = and i64 %xored.i.i.i74.i.i, %tbl_size.i.i70.i.i
  %offset_ptr.i.i76.i.i = getelementptr i32, ptr %offset_tbl.i.i71.i.i, i64 %hash.i.i.i75.i.i
  %offset.i.i77.i.i = load i32, ptr %offset_ptr.i.i76.i.i, align 4, !noalias !407
  %66 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %57, 0
  %67 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %64, 1
  %68 = insertvalue { ptr, ptr, ptr, i32 } %67, ptr %65, 2
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 %offset.i.i77.i.i, 3
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %57) #35
  %72 = sext i32 %offset.i.i77.i.i to i64
  %73 = getelementptr ptr, ptr %57, i64 %72
  %74 = getelementptr i8, ptr %73, i64 64
  %75 = load ptr, ptr %74, align 8
  %result.i.i397.i = call ptr %75({ ptr, ptr, ptr, i32 } %69, ptr nocapture nofree noundef nonnull readonly %0) #16
  %76 = call i32 %result.i.i397.i({ ptr, ptr, ptr, i32 } %69, { ptr, ptr, ptr, i32 } %69, ptr nonnull align 8 %0) #7
  %77 = icmp eq i32 %76, %48
  br i1 %77, label %._crit_edge.i398.i, label %159

._crit_edge.i398.i:                               ; preds = %61
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %57)
  %80 = getelementptr i8, ptr %73, i64 48
  %81 = load ptr, ptr %80, align 8
  %result.i79.i399.i = call ptr %81({ ptr, ptr, ptr, i32 } %69, ptr nocapture nofree noundef nonnull readonly %0) #16
  %82 = call { ptr, i160 } %result.i79.i399.i({ ptr, ptr, ptr, i32 } %69, { ptr, ptr, ptr, i32 } %69, ptr nonnull align 8 %0) #7
  %83 = load ptr, ptr %34, align 8
  %84 = call i1 %83({ ptr, i160 } %82, { ptr, i160 } %45) #7
  br i1 %84, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i, label %159

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i: ; preds = %._crit_edge.i398.i
  %85 = load ptr, ptr %result.i150.i, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %87 = load ptr, ptr %28, align 8
  %88 = load ptr, ptr %85, align 8, !alias.scope !410
  %89 = getelementptr i8, ptr %88, i64 72
  %90 = load ptr, ptr %89, align 8, !alias.scope !410
  %result.i.i.i400.i = call { i64, i64 } %90(ptr nocapture nofree nonnull readonly %85) #5, !alias.scope !410
  %91 = extractvalue { i64, i64 } %result.i.i.i400.i, 0
  %92 = extractvalue { i64, i64 } %result.i.i.i400.i, 1
  %93 = urem i64 20, %92
  %94 = icmp eq i64 %93, 0
  %95 = sub i64 %92, %93
  %96 = select i1 %94, i64 0, i64 %95
  %97 = add i64 %91, 20
  %98 = add i64 %97, %96
  %99 = load ptr, ptr %87, align 8, !alias.scope !410
  %100 = getelementptr i8, ptr %99, i64 72
  %101 = load ptr, ptr %100, align 8, !alias.scope !410
  %result.i1.i.i401.i = call { i64, i64 } %101(ptr nocapture nofree nonnull readonly %87) #5, !alias.scope !410
  %102 = extractvalue { i64, i64 } %result.i1.i.i401.i, 0
  %103 = extractvalue { i64, i64 } %result.i1.i.i401.i, 1
  %104 = call i64 @llvm.umax.i64(i64 %92, i64 %103)
  %105 = call i64 @llvm.umax.i64(i64 %104, i64 8)
  %106 = urem i64 %98, %103
  %107 = icmp eq i64 %106, 0
  %108 = sub i64 %103, %106
  %109 = select i1 %107, i64 0, i64 %108
  %110 = add i64 %102, %98
  %111 = add i64 %110, %109
  %112 = urem i64 %111, %105
  %113 = icmp eq i64 %112, 0
  %114 = sub i64 %105, %112
  %115 = select i1 %113, i64 0, i64 %114
  %116 = add i64 %115, %111
  %result.i83.i.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %116, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %85, ptr %result.i83.i.i, align 8
  %117 = getelementptr inbounds i8, ptr %result.i83.i.i, i64 8
  store ptr %87, ptr %117, align 8
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i.i)
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %120 = load ptr, ptr %85, align 8
  %121 = getelementptr i8, ptr %120, i64 72
  %122 = load ptr, ptr %121, align 8
  %result.i.i118.i.i = call { i64, i64 } %122(ptr nocapture nofree nonnull readonly %85) #5
  %123 = extractvalue { i64, i64 } %result.i.i118.i.i, 1
  %124 = urem i64 20, %123
  %125 = icmp eq i64 %124, 0
  %reass.sub310 = sub i64 %123, %124
  %126 = add i64 %reass.sub310, 20
  %127 = select i1 %125, i64 20, i64 %126
  %128 = getelementptr i8, ptr %result.i83.i.i, i64 %127
  %129 = getelementptr i8, ptr %120, i64 64
  %130 = load ptr, ptr %129, align 8
  call void %130({ ptr, i160 } %45, ptr nocapture nofree nonnull readonly %85, ptr nocapture nofree writeonly %128) #1
  %131 = load ptr, ptr %result.i83.i.i, align 8
  %132 = load ptr, ptr %131, align 8
  %133 = getelementptr i8, ptr %132, i64 72
  %134 = load ptr, ptr %133, align 8
  %result.i.i119.i.i = call { i64, i64 } %134(ptr nocapture nofree nonnull readonly %131) #5
  %135 = extractvalue { i64, i64 } %result.i.i119.i.i, 0
  %136 = extractvalue { i64, i64 } %result.i.i119.i.i, 1
  %137 = urem i64 20, %136
  %138 = icmp eq i64 %137, 0
  %139 = sub i64 %136, %137
  %140 = select i1 %138, i64 0, i64 %139
  %141 = add i64 %135, 20
  %142 = add i64 %141, %140
  %143 = load ptr, ptr %117, align 8
  %144 = load ptr, ptr %143, align 8
  %145 = getelementptr i8, ptr %144, i64 72
  %146 = load ptr, ptr %145, align 8
  %result.i1.i120.i.i = call { i64, i64 } %146(ptr nocapture nofree nonnull readonly %143) #5
  %147 = extractvalue { i64, i64 } %result.i1.i120.i.i, 1
  %148 = urem i64 %142, %147
  %149 = icmp eq i64 %148, 0
  %150 = sub i64 %147, %148
  %151 = select i1 %149, i64 0, i64 %150
  %152 = getelementptr i8, ptr %result.i83.i.i, i64 %142
  %153 = getelementptr i8, ptr %152, i64 %151
  %154 = getelementptr i8, ptr %144, i64 64
  %155 = load ptr, ptr %154, align 8
  call void %155({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %143, ptr nocapture nofree writeonly %153) #1
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %157 = getelementptr inbounds i8, ptr %result.i83.i.i, i64 16
  store i32 %48, ptr %157, align 8
  store ptr @Entry, ptr %56, align 8
  %158 = ptrtoint ptr %result.i83.i.i to i64
  store i64 %158, ptr %58, align 4
  %.sroa_idx28.i.i = getelementptr i8, ptr %56, i64 24
  store i32 10, ptr %.sroa_idx28.i.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %CuckooMap_insert_keyK_valueV.exit.i

159:                                              ; preds = %._crit_edge.i398.i, %61, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %160 = add i32 %48, 2127912214
  %161 = shl i32 %48, 12
  %162 = add i32 %160, %161
  %163 = ashr i32 %162, 19
  %164 = xor i32 %162, %163
  %165 = xor i32 %164, -949894596
  %166 = add i32 %165, 374761393
  %167 = shl i32 %165, 5
  %168 = add i32 %166, %167
  %169 = add i32 %168, -744332180
  %170 = shl i32 %168, 9
  %171 = xor i32 %169, %170
  %172 = add i32 %171, -42973499
  %173 = shl i32 %171, 3
  %174 = add i32 %172, %173
  %175 = ashr i32 %174, 16
  %176 = xor i32 %174, %175
  %177 = xor i32 %176, -1252372727
  %178 = load i32, ptr %35, align 8
  %179 = add i32 %178, -1
  %180 = and i32 %179, %177
  %181 = load ptr, ptr %37, align 8
  %182 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %183 = sext i32 %180 to i64
  %184 = shl nsw i64 %183, 5
  %185 = getelementptr i8, ptr %181, i64 %184
  %186 = load ptr, ptr %185, align 8
  %187 = getelementptr i8, ptr %185, i64 8
  %188 = icmp ne ptr %186, @nil_typ
  %189 = icmp ne ptr %186, null
  %.not64.i430.i = and i1 %188, %189
  br i1 %.not64.i430.i, label %190, label %288

190:                                              ; preds = %159
  %191 = load i64, ptr %187, align 4
  %.sroa_idx.i432.i = getelementptr i8, ptr %185, i64 16
  %192 = load i64, ptr %.sroa_idx.i432.i, align 4
  %193 = inttoptr i64 %191 to ptr
  %194 = inttoptr i64 %192 to ptr
  %hash_coef_ptr.i.i66.i433.i = getelementptr i8, ptr %186, i64 8
  %tbl_size_ptr.i.i67.i434.i = getelementptr i8, ptr %186, i64 16
  %offset_tbl_ptr.i.i68.i435.i = getelementptr i8, ptr %186, i64 40
  %hash_coef.i.i69.i436.i = load i64, ptr %hash_coef_ptr.i.i66.i433.i, align 4, !noalias !413
  %tbl_size.i.i70.i437.i = load i64, ptr %tbl_size_ptr.i.i67.i434.i, align 4, !noalias !413
  %offset_tbl.i.i71.i438.i = load ptr, ptr %offset_tbl_ptr.i.i68.i435.i, align 8, !noalias !413
  %product.i.i.i72.i439.i = mul i64 %hash_coef.i.i69.i436.i, 4015701072841558310
  %shifted.i.i.i73.i440.i = lshr i64 %product.i.i.i72.i439.i, 32
  %xored.i.i.i74.i441.i = xor i64 %shifted.i.i.i73.i440.i, %product.i.i.i72.i439.i
  %hash.i.i.i75.i442.i = and i64 %xored.i.i.i74.i441.i, %tbl_size.i.i70.i437.i
  %offset_ptr.i.i76.i443.i = getelementptr i32, ptr %offset_tbl.i.i71.i438.i, i64 %hash.i.i.i75.i442.i
  %offset.i.i77.i444.i = load i32, ptr %offset_ptr.i.i76.i443.i, align 4, !noalias !413
  %195 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %186, 0
  %196 = insertvalue { ptr, ptr, ptr, i32 } %195, ptr %193, 1
  %197 = insertvalue { ptr, ptr, ptr, i32 } %196, ptr %194, 2
  %198 = insertvalue { ptr, ptr, ptr, i32 } %197, i32 %offset.i.i77.i444.i, 3
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %186) #35
  %201 = sext i32 %offset.i.i77.i444.i to i64
  %202 = getelementptr ptr, ptr %186, i64 %201
  %203 = getelementptr i8, ptr %202, i64 64
  %204 = load ptr, ptr %203, align 8
  %result.i.i445.i = call ptr %204({ ptr, ptr, ptr, i32 } %198, ptr nocapture nofree noundef nonnull readonly %0) #16
  %205 = call i32 %result.i.i445.i({ ptr, ptr, ptr, i32 } %198, { ptr, ptr, ptr, i32 } %198, ptr nonnull align 8 %0) #7
  %206 = icmp eq i32 %205, %48
  br i1 %206, label %._crit_edge.i446.i, label %288

._crit_edge.i446.i:                               ; preds = %190
  %207 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %186)
  %209 = getelementptr i8, ptr %202, i64 48
  %210 = load ptr, ptr %209, align 8
  %result.i79.i447.i = call ptr %210({ ptr, ptr, ptr, i32 } %198, ptr nocapture nofree noundef nonnull readonly %0) #16
  %211 = call { ptr, i160 } %result.i79.i447.i({ ptr, ptr, ptr, i32 } %198, { ptr, ptr, ptr, i32 } %198, ptr nonnull align 8 %0) #7
  %212 = load ptr, ptr %34, align 8
  %213 = call i1 %212({ ptr, i160 } %211, { ptr, i160 } %45) #7
  br i1 %213, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit459.i, label %288

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit459.i: ; preds = %._crit_edge.i446.i
  %214 = load ptr, ptr %result.i150.i, align 8
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %216 = load ptr, ptr %28, align 8
  %217 = load ptr, ptr %214, align 8, !alias.scope !416
  %218 = getelementptr i8, ptr %217, i64 72
  %219 = load ptr, ptr %218, align 8, !alias.scope !416
  %result.i.i.i451.i = call { i64, i64 } %219(ptr nocapture nofree nonnull readonly %214) #5, !alias.scope !416
  %220 = extractvalue { i64, i64 } %result.i.i.i451.i, 0
  %221 = extractvalue { i64, i64 } %result.i.i.i451.i, 1
  %222 = urem i64 20, %221
  %223 = icmp eq i64 %222, 0
  %224 = sub i64 %221, %222
  %225 = select i1 %223, i64 0, i64 %224
  %226 = add i64 %220, 20
  %227 = add i64 %226, %225
  %228 = load ptr, ptr %216, align 8, !alias.scope !416
  %229 = getelementptr i8, ptr %228, i64 72
  %230 = load ptr, ptr %229, align 8, !alias.scope !416
  %result.i1.i.i452.i = call { i64, i64 } %230(ptr nocapture nofree nonnull readonly %216) #5, !alias.scope !416
  %231 = extractvalue { i64, i64 } %result.i1.i.i452.i, 0
  %232 = extractvalue { i64, i64 } %result.i1.i.i452.i, 1
  %233 = call i64 @llvm.umax.i64(i64 %221, i64 %232)
  %234 = call i64 @llvm.umax.i64(i64 %233, i64 8)
  %235 = urem i64 %227, %232
  %236 = icmp eq i64 %235, 0
  %237 = sub i64 %232, %235
  %238 = select i1 %236, i64 0, i64 %237
  %239 = add i64 %231, %227
  %240 = add i64 %239, %238
  %241 = urem i64 %240, %234
  %242 = icmp eq i64 %241, 0
  %243 = sub i64 %234, %241
  %244 = select i1 %242, i64 0, i64 %243
  %245 = add i64 %244, %240
  %result.i83.i453.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %245, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %214, ptr %result.i83.i453.i, align 8
  %246 = getelementptr inbounds i8, ptr %result.i83.i453.i, i64 8
  store ptr %216, ptr %246, align 8
  %247 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i453.i)
  %248 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %249 = load ptr, ptr %214, align 8
  %250 = getelementptr i8, ptr %249, i64 72
  %251 = load ptr, ptr %250, align 8
  %result.i.i118.i454.i = call { i64, i64 } %251(ptr nocapture nofree nonnull readonly %214) #5
  %252 = extractvalue { i64, i64 } %result.i.i118.i454.i, 1
  %253 = urem i64 20, %252
  %254 = icmp eq i64 %253, 0
  %reass.sub309 = sub i64 %252, %253
  %255 = add i64 %reass.sub309, 20
  %256 = select i1 %254, i64 20, i64 %255
  %257 = getelementptr i8, ptr %result.i83.i453.i, i64 %256
  %258 = getelementptr i8, ptr %249, i64 64
  %259 = load ptr, ptr %258, align 8
  call void %259({ ptr, i160 } %45, ptr nocapture nofree nonnull readonly %214, ptr nocapture nofree writeonly %257) #1
  %260 = load ptr, ptr %result.i83.i453.i, align 8
  %261 = load ptr, ptr %260, align 8
  %262 = getelementptr i8, ptr %261, i64 72
  %263 = load ptr, ptr %262, align 8
  %result.i.i119.i456.i = call { i64, i64 } %263(ptr nocapture nofree nonnull readonly %260) #5
  %264 = extractvalue { i64, i64 } %result.i.i119.i456.i, 0
  %265 = extractvalue { i64, i64 } %result.i.i119.i456.i, 1
  %266 = urem i64 20, %265
  %267 = icmp eq i64 %266, 0
  %268 = sub i64 %265, %266
  %269 = select i1 %267, i64 0, i64 %268
  %270 = add i64 %264, 20
  %271 = add i64 %270, %269
  %272 = load ptr, ptr %246, align 8
  %273 = load ptr, ptr %272, align 8
  %274 = getelementptr i8, ptr %273, i64 72
  %275 = load ptr, ptr %274, align 8
  %result.i1.i120.i457.i = call { i64, i64 } %275(ptr nocapture nofree nonnull readonly %272) #5
  %276 = extractvalue { i64, i64 } %result.i1.i120.i457.i, 1
  %277 = urem i64 %271, %276
  %278 = icmp eq i64 %277, 0
  %279 = sub i64 %276, %277
  %280 = select i1 %278, i64 0, i64 %279
  %281 = getelementptr i8, ptr %result.i83.i453.i, i64 %271
  %282 = getelementptr i8, ptr %281, i64 %280
  %283 = getelementptr i8, ptr %273, i64 64
  %284 = load ptr, ptr %283, align 8
  call void %284({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %272, ptr nocapture nofree writeonly %282) #1
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %286 = getelementptr inbounds i8, ptr %result.i83.i453.i, i64 16
  store i32 %48, ptr %286, align 8
  store ptr @Entry, ptr %185, align 8
  %287 = ptrtoint ptr %result.i83.i453.i to i64
  store i64 %287, ptr %187, align 4
  %.sroa_idx28.i458.i = getelementptr i8, ptr %185, i64 24
  store i32 10, ptr %.sroa_idx28.i458.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %CuckooMap_insert_keyK_valueV.exit.i

288:                                              ; preds = %._crit_edge.i446.i, %190, %159
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %289 = load i32, ptr %40, align 4
  %290 = load i32, ptr %35, align 8
  %.not.i.i = icmp slt i32 %289, %290
  br i1 %.not.i.i, label %._crit_edge.i.i, label %291

291:                                              ; preds = %288
  %292 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %293 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %294 = load ptr, ptr %36, align 8
  %295 = load ptr, ptr %37, align 8
  %296 = shl i32 %290, 1
  %spec.select.i474.i = call i32 @llvm.smax.i32(i32 %296, i32 16)
  store i32 %spec.select.i474.i, ptr %35, align 8
  %297 = zext nneg i32 %spec.select.i474.i to i64
  %298 = shl nuw nsw i64 %297, 5
  %result.i.i475.i = call noalias ptr @bump_malloc_inner(i64 noundef %298, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i475.i, ptr %36, align 8
  %result.i20.i.i = call noalias ptr @bump_malloc_inner(i64 noundef %298, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i.i, ptr %37, align 8
  store i32 0, ptr %40, align 4
  %299 = icmp sgt i32 %290, 0
  br i1 %299, label %.lr.ph.i.i, label %._crit_edge.i.i

.lr.ph.i.i:                                       ; preds = %291, %._crit_edge.i796.i
  %.060.i.i = phi i32 [ %318, %._crit_edge.i796.i ], [ 0, %291 ]
  %300 = zext nneg i32 %.060.i.i to i64
  %301 = shl nuw nsw i64 %300, 5
  %302 = getelementptr i8, ptr %294, i64 %301
  %303 = load ptr, ptr %302, align 8
  %304 = icmp ne ptr %303, @nil_typ
  %305 = icmp ne ptr %303, null
  %.not16.i.i = and i1 %304, %305
  br i1 %.not16.i.i, label %306, label %._crit_edge.i796.i

306:                                              ; preds = %.lr.ph.i.i
  %307 = getelementptr i8, ptr %302, i64 8
  %308 = load i64, ptr %307, align 4
  %.sroa_idx.i797.i = getelementptr i8, ptr %302, i64 16
  %309 = load i64, ptr %.sroa_idx.i797.i, align 4
  %310 = inttoptr i64 %308 to ptr
  %311 = inttoptr i64 %309 to ptr
  %hash_coef_ptr.i.i18.i.i = getelementptr i8, ptr %303, i64 8
  %tbl_size_ptr.i.i19.i.i = getelementptr i8, ptr %303, i64 16
  %offset_tbl_ptr.i.i20.i.i = getelementptr i8, ptr %303, i64 40
  %hash_coef.i.i21.i.i = load i64, ptr %hash_coef_ptr.i.i18.i.i, align 4, !noalias !22
  %tbl_size.i.i22.i.i = load i64, ptr %tbl_size_ptr.i.i19.i.i, align 4, !noalias !22
  %offset_tbl.i.i23.i.i = load ptr, ptr %offset_tbl_ptr.i.i20.i.i, align 8, !noalias !22
  %product.i.i.i24.i.i = mul i64 %hash_coef.i.i21.i.i, 4015701072841558310
  %shifted.i.i.i25.i.i = lshr i64 %product.i.i.i24.i.i, 32
  %xored.i.i.i26.i.i = xor i64 %shifted.i.i.i25.i.i, %product.i.i.i24.i.i
  %hash.i.i.i27.i.i = and i64 %xored.i.i.i26.i.i, %tbl_size.i.i22.i.i
  %offset_ptr.i.i28.i.i = getelementptr i32, ptr %offset_tbl.i.i23.i.i, i64 %hash.i.i.i27.i.i
  %offset.i.i43.i.i = load i32, ptr %offset_ptr.i.i28.i.i, align 4, !noalias !419
  %312 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %303, 0
  %313 = insertvalue { ptr, ptr, ptr, i32 } %312, ptr %310, 1
  %314 = insertvalue { ptr, ptr, ptr, i32 } %313, ptr %311, 2
  %315 = insertvalue { ptr, ptr, ptr, i32 } %314, i32 %offset.i.i43.i.i, 3
  %316 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %317 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %315) #7
  br label %._crit_edge.i796.i

._crit_edge.i796.i:                               ; preds = %306, %.lr.ph.i.i
  %318 = add nuw nsw i32 %.060.i.i, 1
  %319 = icmp slt i32 %318, %290
  br i1 %319, label %.lr.ph.i.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i: ; preds = %._crit_edge.i796.i, %._crit_edge.i815.i
  %.060.i813.i = phi i32 [ %338, %._crit_edge.i815.i ], [ 0, %._crit_edge.i796.i ]
  %320 = zext nneg i32 %.060.i813.i to i64
  %321 = shl nuw nsw i64 %320, 5
  %322 = getelementptr i8, ptr %295, i64 %321
  %323 = load ptr, ptr %322, align 8
  %324 = icmp ne ptr %323, @nil_typ
  %325 = icmp ne ptr %323, null
  %.not16.i814.i = and i1 %324, %325
  br i1 %.not16.i814.i, label %326, label %._crit_edge.i815.i

326:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i
  %327 = getelementptr i8, ptr %322, i64 8
  %328 = load i64, ptr %327, align 4
  %.sroa_idx.i816.i = getelementptr i8, ptr %322, i64 16
  %329 = load i64, ptr %.sroa_idx.i816.i, align 4
  %330 = inttoptr i64 %328 to ptr
  %331 = inttoptr i64 %329 to ptr
  %hash_coef_ptr.i.i18.i817.i = getelementptr i8, ptr %323, i64 8
  %tbl_size_ptr.i.i19.i818.i = getelementptr i8, ptr %323, i64 16
  %offset_tbl_ptr.i.i20.i819.i = getelementptr i8, ptr %323, i64 40
  %hash_coef.i.i21.i820.i = load i64, ptr %hash_coef_ptr.i.i18.i817.i, align 4, !noalias !22
  %tbl_size.i.i22.i821.i = load i64, ptr %tbl_size_ptr.i.i19.i818.i, align 4, !noalias !22
  %offset_tbl.i.i23.i822.i = load ptr, ptr %offset_tbl_ptr.i.i20.i819.i, align 8, !noalias !22
  %product.i.i.i24.i823.i = mul i64 %hash_coef.i.i21.i820.i, 4015701072841558310
  %shifted.i.i.i25.i824.i = lshr i64 %product.i.i.i24.i823.i, 32
  %xored.i.i.i26.i825.i = xor i64 %shifted.i.i.i25.i824.i, %product.i.i.i24.i823.i
  %hash.i.i.i27.i826.i = and i64 %xored.i.i.i26.i825.i, %tbl_size.i.i22.i821.i
  %offset_ptr.i.i28.i827.i = getelementptr i32, ptr %offset_tbl.i.i23.i822.i, i64 %hash.i.i.i27.i826.i
  %offset.i.i43.i828.i = load i32, ptr %offset_ptr.i.i28.i827.i, align 4, !noalias !422
  %332 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %323, 0
  %333 = insertvalue { ptr, ptr, ptr, i32 } %332, ptr %330, 1
  %334 = insertvalue { ptr, ptr, ptr, i32 } %333, ptr %331, 2
  %335 = insertvalue { ptr, ptr, ptr, i32 } %334, i32 %offset.i.i43.i828.i, 3
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %337 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %335) #7
  br label %._crit_edge.i815.i

._crit_edge.i815.i:                               ; preds = %326, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i
  %338 = add nuw nsw i32 %.060.i813.i, 1
  %339 = icmp slt i32 %338, %290
  br i1 %339, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i, label %._crit_edge.i.i

._crit_edge.i.i:                                  ; preds = %._crit_edge.i815.i, %291, %288
  %340 = load ptr, ptr %result.i150.i, align 8
  %341 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %342 = load ptr, ptr %28, align 8
  %343 = load ptr, ptr %340, align 8
  %344 = getelementptr i8, ptr %343, i64 72
  %345 = load ptr, ptr %344, align 8
  %result.i.i.i.i = call { i64, i64 } %345(ptr nocapture nofree nonnull readonly %340) #5
  %346 = extractvalue { i64, i64 } %result.i.i.i.i, 0
  %347 = extractvalue { i64, i64 } %result.i.i.i.i, 1
  %348 = urem i64 20, %347
  %349 = icmp eq i64 %348, 0
  %350 = sub i64 %347, %348
  %351 = select i1 %349, i64 0, i64 %350
  %352 = add i64 %346, 20
  %353 = add i64 %352, %351
  %354 = load ptr, ptr %342, align 8
  %355 = getelementptr i8, ptr %354, i64 72
  %356 = load ptr, ptr %355, align 8
  %result.i1.i.i.i = call { i64, i64 } %356(ptr nocapture nofree nonnull readonly %342) #5
  %357 = extractvalue { i64, i64 } %result.i1.i.i.i, 0
  %358 = extractvalue { i64, i64 } %result.i1.i.i.i, 1
  %359 = call i64 @llvm.umax.i64(i64 %347, i64 %358)
  %360 = call i64 @llvm.umax.i64(i64 %359, i64 8)
  %361 = urem i64 %353, %358
  %362 = icmp eq i64 %361, 0
  %363 = sub i64 %358, %361
  %364 = select i1 %362, i64 0, i64 %363
  %365 = add i64 %357, %353
  %366 = add i64 %365, %364
  %367 = urem i64 %366, %360
  %368 = icmp eq i64 %367, 0
  %369 = sub i64 %360, %367
  %370 = select i1 %368, i64 0, i64 %369
  %371 = add i64 %370, %366
  %result.i90.i.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %371, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %340, ptr %result.i90.i.i, align 8
  %372 = getelementptr inbounds i8, ptr %result.i90.i.i, i64 8
  store ptr %342, ptr %372, align 8
  %373 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i.i)
  %374 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %375 = load ptr, ptr %340, align 8
  %376 = getelementptr i8, ptr %375, i64 72
  %377 = load ptr, ptr %376, align 8
  %result.i.i196.i.i = call { i64, i64 } %377(ptr nocapture nofree nonnull readonly %340) #5
  %378 = extractvalue { i64, i64 } %result.i.i196.i.i, 1
  %379 = urem i64 20, %378
  %380 = icmp eq i64 %379, 0
  %reass.sub308 = sub i64 %378, %379
  %381 = add i64 %reass.sub308, 20
  %382 = select i1 %380, i64 20, i64 %381
  %383 = getelementptr i8, ptr %result.i90.i.i, i64 %382
  %384 = getelementptr i8, ptr %375, i64 64
  %385 = load ptr, ptr %384, align 8
  call void %385({ ptr, i160 } %45, ptr nocapture nofree nonnull readonly %340, ptr nocapture nofree writeonly %383) #1
  %386 = load ptr, ptr %result.i90.i.i, align 8
  %387 = load ptr, ptr %386, align 8
  %388 = getelementptr i8, ptr %387, i64 72
  %389 = load ptr, ptr %388, align 8
  %result.i.i197.i.i = call { i64, i64 } %389(ptr nocapture nofree nonnull readonly %386) #5
  %390 = extractvalue { i64, i64 } %result.i.i197.i.i, 0
  %391 = extractvalue { i64, i64 } %result.i.i197.i.i, 1
  %392 = urem i64 20, %391
  %393 = icmp eq i64 %392, 0
  %394 = sub i64 %391, %392
  %395 = select i1 %393, i64 0, i64 %394
  %396 = add i64 %390, 20
  %397 = add i64 %396, %395
  %398 = load ptr, ptr %372, align 8
  %399 = load ptr, ptr %398, align 8
  %400 = getelementptr i8, ptr %399, i64 72
  %401 = load ptr, ptr %400, align 8
  %result.i1.i198.i.i = call { i64, i64 } %401(ptr nocapture nofree nonnull readonly %398) #5
  %402 = extractvalue { i64, i64 } %result.i1.i198.i.i, 1
  %403 = urem i64 %397, %402
  %404 = icmp eq i64 %403, 0
  %405 = sub i64 %402, %403
  %406 = select i1 %404, i64 0, i64 %405
  %407 = getelementptr i8, ptr %result.i90.i.i, i64 %397
  %408 = getelementptr i8, ptr %407, i64 %406
  %409 = getelementptr i8, ptr %399, i64 64
  %410 = load ptr, ptr %409, align 8
  call void %410({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %398, ptr nocapture nofree writeonly %408) #1
  %411 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %412 = getelementptr inbounds i8, ptr %result.i90.i.i, i64 16
  store i32 %48, ptr %412, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %24)
  %413 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %414 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %415 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %416

416:                                              ; preds = %.cont.cont.i.i, %._crit_edge.i.i
  %.0566.i.i = phi i32 [ 0, %._crit_edge.i.i ], [ %417, %.cont.cont.i.i ]
  %.070565.i.i = phi i1 [ true, %._crit_edge.i.i ], [ %483, %.cont.cont.i.i ]
  %.sroa.0.0564.i.i = phi ptr [ @Entry, %._crit_edge.i.i ], [ %vptr.i142.sroa.speculated.i.i, %.cont.cont.i.i ]
  %.sroa.6.0563.i.i = phi ptr [ %result.i90.i.i, %._crit_edge.i.i ], [ %spec.select539.i.i, %.cont.cont.i.i ]
  %.sroa.12.0562.i.i = phi ptr [ undef, %._crit_edge.i.i ], [ %spec.select.i492.i, %.cont.cont.i.i ]
  %.sroa.17.0561.i.i = phi i32 [ 10, %._crit_edge.i.i ], [ %offset.i.i154.i.i, %.cont.cont.i.i ]
  %417 = add nuw nsw i32 %.0566.i.i, 1
  %418 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i.i, 0
  %419 = insertvalue { ptr, ptr, ptr, i32 } %418, ptr %.sroa.6.0563.i.i, 1
  %420 = insertvalue { ptr, ptr, ptr, i32 } %419, ptr %.sroa.12.0562.i.i, 2
  %421 = insertvalue { ptr, ptr, ptr, i32 } %420, i32 %.sroa.17.0561.i.i, 3
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i.i)
  %423 = sext i32 %.sroa.17.0561.i.i to i64
  %424 = getelementptr ptr, ptr %.sroa.0.0564.i.i, i64 %423
  %425 = getelementptr i8, ptr %424, i64 64
  %426 = load ptr, ptr %425, align 8
  %result.i125.i490.i = call ptr %426({ ptr, ptr, ptr, i32 } %421, ptr nocapture nofree noundef nonnull readonly %0) #16
  %427 = call i32 %result.i125.i490.i({ ptr, ptr, ptr, i32 } %421, { ptr, ptr, ptr, i32 } %421, ptr nonnull align 8 %0) #7
  %428 = ptrtoint ptr %.sroa.6.0563.i.i to i64
  %429 = ptrtoint ptr %.sroa.12.0562.i.i to i64
  br i1 %.070565.i.i, label %430, label %446

430:                                              ; preds = %416
  %431 = load i32, ptr %35, align 8
  %432 = add i32 %431, -1
  %433 = and i32 %432, %427
  %434 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %435 = load ptr, ptr %36, align 8
  %436 = sext i32 %433 to i64
  %437 = shl nsw i64 %436, 5
  %438 = getelementptr i8, ptr %435, i64 %437
  %439 = load ptr, ptr %438, align 8
  %440 = getelementptr i8, ptr %438, i64 8
  %441 = load i160, ptr %440, align 4
  store ptr %.sroa.0.0564.i.i, ptr %438, align 8
  store i64 %428, ptr %440, align 4
  %.sroa_idx157.i.i = getelementptr i8, ptr %438, i64 16
  store i64 %429, ptr %.sroa_idx157.i.i, align 4
  %.sroa_idx158.i.i = getelementptr i8, ptr %438, i64 24
  store i32 %.sroa.17.0561.i.i, ptr %.sroa_idx158.i.i, align 4
  %442 = icmp ne ptr %439, @nil_typ
  %443 = icmp ne ptr %439, null
  %.not92.i.i = and i1 %442, %443
  %extract.i.i = lshr i160 %441, 64
  %444 = insertelement <2 x i160> poison, i160 %441, i64 0
  %445 = insertelement <2 x i160> %444, i160 %extract.i.i, i64 1
  br i1 %.not92.i.i, label %.cont.cont.i.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i

446:                                              ; preds = %416
  %447 = add i32 %427, 2127912214
  %448 = shl i32 %427, 12
  %449 = add i32 %447, %448
  %450 = ashr i32 %449, 19
  %451 = xor i32 %449, %450
  %452 = xor i32 %451, -949894596
  %453 = add i32 %452, 374761393
  %454 = shl i32 %452, 5
  %455 = add i32 %453, %454
  %456 = add i32 %455, -744332180
  %457 = shl i32 %455, 9
  %458 = xor i32 %456, %457
  %459 = add i32 %458, -42973499
  %460 = shl i32 %458, 3
  %461 = add i32 %459, %460
  %462 = ashr i32 %461, 16
  %463 = xor i32 %461, %462
  %464 = xor i32 %463, -1252372727
  %465 = load i32, ptr %35, align 8
  %466 = add i32 %465, -1
  %467 = and i32 %466, %464
  %468 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %469 = load ptr, ptr %37, align 8
  %470 = sext i32 %467 to i64
  %471 = shl nsw i64 %470, 5
  %472 = getelementptr i8, ptr %469, i64 %471
  %473 = load ptr, ptr %472, align 8
  %474 = getelementptr i8, ptr %472, i64 8
  %475 = load i160, ptr %474, align 4
  store ptr %.sroa.0.0564.i.i, ptr %472, align 8
  store i64 %428, ptr %474, align 4
  %.sroa_idx161.i.i = getelementptr i8, ptr %472, i64 16
  store i64 %429, ptr %.sroa_idx161.i.i, align 4
  %.sroa_idx162.i.i = getelementptr i8, ptr %472, i64 24
  store i32 %.sroa.17.0561.i.i, ptr %.sroa_idx162.i.i, align 4
  %476 = icmp ne ptr %473, @nil_typ
  %477 = icmp ne ptr %473, null
  %.not90.i.i = and i1 %476, %477
  %extract607.i.i = lshr i160 %475, 64
  %478 = insertelement <2 x i160> poison, i160 %475, i64 0
  %479 = insertelement <2 x i160> %478, i160 %extract607.i.i, i64 1
  br i1 %.not90.i.i, label %.cont.cont.i.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i

.cont.cont.i.i:                                   ; preds = %446, %430
  %vptr.i142.sroa.speculated.i.i = phi ptr [ %439, %430 ], [ %473, %446 ]
  %.in = phi <2 x i160> [ %445, %430 ], [ %479, %446 ]
  %480 = trunc <2 x i160> %.in to <2 x i64>
  %481 = extractelement <2 x i64> %480, i64 1
  %spec.select.i492.i = inttoptr i64 %481 to ptr
  %482 = extractelement <2 x i64> %480, i64 0
  %spec.select539.i.i = inttoptr i64 %482 to ptr
  %483 = xor i1 %.070565.i.i, true
  %hash_coef_ptr.i.i143.i.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i, i64 8
  %tbl_size_ptr.i.i144.i.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i, i64 16
  %offset_tbl_ptr.i.i145.i.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i, i64 40
  %hash_coef.i.i146.i.i = load i64, ptr %hash_coef_ptr.i.i143.i.i, align 4
  %tbl_size.i.i147.i.i = load i64, ptr %tbl_size_ptr.i.i144.i.i, align 4
  %offset_tbl.i.i148.i.i = load ptr, ptr %offset_tbl_ptr.i.i145.i.i, align 8
  %product.i.i.i149.i.i = mul i64 %hash_coef.i.i146.i.i, 4015701072841558310
  %shifted.i.i.i150.i.i = lshr i64 %product.i.i.i149.i.i, 32
  %xored.i.i.i151.i.i = xor i64 %shifted.i.i.i150.i.i, %product.i.i.i149.i.i
  %hash.i.i.i152.i.i = and i64 %xored.i.i.i151.i.i, %tbl_size.i.i147.i.i
  %offset_ptr.i.i153.i.i = getelementptr i32, ptr %offset_tbl.i.i148.i.i, i64 %hash.i.i.i152.i.i
  %offset.i.i154.i.i = load i32, ptr %offset_ptr.i.i153.i.i, align 4
  %484 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %485 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %486 = icmp ult i32 %.0566.i.i, 99
  br i1 %486, label %416, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i: ; preds = %446, %430
  %487 = phi ptr [ %24, %446 ], [ %23, %430 ]
  %488 = load i32, ptr %40, align 4
  store i32 %488, ptr %487, align 4
  %489 = add i32 %488, 1
  %490 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %489, ptr %40, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  br label %CuckooMap_insert_keyK_valueV.exit.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i: ; preds = %.cont.cont.i.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %23)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %24)
  %491 = icmp eq ptr %vptr.i142.sroa.speculated.i.i, null
  br i1 %491, label %CuckooMap_insert_keyK_valueV.exit.i, label %492

492:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i
  %493 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %494 = load ptr, ptr %36, align 8
  %495 = load ptr, ptr %37, align 8
  %496 = load i32, ptr %35, align 8
  %497 = shl i32 %496, 1
  %spec.select.i509.i = call i32 @llvm.smax.i32(i32 %497, i32 16)
  store i32 %spec.select.i509.i, ptr %35, align 8
  %498 = zext nneg i32 %spec.select.i509.i to i64
  %499 = shl nuw nsw i64 %498, 5
  %result.i.i510.i = call noalias ptr @bump_malloc_inner(i64 noundef %499, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i510.i, ptr %36, align 8
  %result.i20.i511.i = call noalias ptr @bump_malloc_inner(i64 noundef %499, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i511.i, ptr %37, align 8
  store i32 0, ptr %40, align 4
  %500 = icmp sgt i32 %496, 0
  br i1 %500, label %.lr.ph.i862.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i

.lr.ph.i862.i:                                    ; preds = %492, %._crit_edge.i877.i
  %.060.i875.i = phi i32 [ %589, %._crit_edge.i877.i ], [ 0, %492 ]
  %501 = zext nneg i32 %.060.i875.i to i64
  %502 = shl nuw nsw i64 %501, 5
  %503 = getelementptr i8, ptr %494, i64 %502
  %504 = load ptr, ptr %503, align 8
  %505 = icmp ne ptr %504, @nil_typ
  %506 = icmp ne ptr %504, null
  %.not16.i876.i = and i1 %505, %506
  br i1 %.not16.i876.i, label %507, label %._crit_edge.i877.i

507:                                              ; preds = %.lr.ph.i862.i
  %508 = getelementptr i8, ptr %503, i64 8
  %509 = load <2 x i64>, ptr %508, align 4
  %hash_coef_ptr.i.i18.i879.i = getelementptr i8, ptr %504, i64 8
  %tbl_size_ptr.i.i19.i880.i = getelementptr i8, ptr %504, i64 16
  %offset_tbl_ptr.i.i20.i881.i = getelementptr i8, ptr %504, i64 40
  %510 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %20)
  %hash_coef.i.i99.i.i = load i64, ptr %hash_coef_ptr.i.i18.i879.i, align 4, !noalias !22
  %tbl_size.i.i100.i.i = load i64, ptr %tbl_size_ptr.i.i19.i880.i, align 4, !noalias !22
  %offset_tbl.i.i101.i.i = load ptr, ptr %offset_tbl_ptr.i.i20.i881.i, align 8, !noalias !22
  %product.i.i.i102.i.i = mul i64 %hash_coef.i.i99.i.i, 4015701072841558310
  %shifted.i.i.i103.i.i = lshr i64 %product.i.i.i102.i.i, 32
  %xored.i.i.i104.i.i = xor i64 %shifted.i.i.i103.i.i, %product.i.i.i102.i.i
  %hash.i.i.i105.i.i = and i64 %xored.i.i.i104.i.i, %tbl_size.i.i100.i.i
  %offset_ptr.i.i106.i.i = getelementptr i32, ptr %offset_tbl.i.i101.i.i, i64 %hash.i.i.i105.i.i
  %offset.i.i121.i.i = load i32, ptr %offset_ptr.i.i106.i.i, align 4, !noalias !425
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %512 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %513 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %514

514:                                              ; preds = %.cont.cont.i1054.i, %507
  %.0566.i1042.i = phi i32 [ 0, %507 ], [ %518, %.cont.cont.i1054.i ]
  %.070565.i1043.i = phi i1 [ true, %507 ], [ %580, %.cont.cont.i1054.i ]
  %.sroa.0.0564.i1044.i = phi ptr [ %504, %507 ], [ %vptr.i142.sroa.speculated.i1057.i, %.cont.cont.i1054.i ]
  %.sroa.17.0561.i1047.i = phi i32 [ %offset.i.i121.i.i, %507 ], [ %offset.i.i154.i1071.i, %.cont.cont.i1054.i ]
  %515 = phi <2 x i64> [ %509, %507 ], [ %579, %.cont.cont.i1054.i ]
  %516 = extractelement <2 x i64> %515, i64 1
  %.sroa.12.0562.i1046.i = inttoptr i64 %516 to ptr
  %517 = extractelement <2 x i64> %515, i64 0
  %.sroa.6.0563.i1045.i = inttoptr i64 %517 to ptr
  %518 = add nuw nsw i32 %.0566.i1042.i, 1
  %519 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1044.i, 0
  %520 = insertvalue { ptr, ptr, ptr, i32 } %519, ptr %.sroa.6.0563.i1045.i, 1
  %521 = insertvalue { ptr, ptr, ptr, i32 } %520, ptr %.sroa.12.0562.i1046.i, 2
  %522 = insertvalue { ptr, ptr, ptr, i32 } %521, i32 %.sroa.17.0561.i1047.i, 3
  %523 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1044.i)
  %524 = sext i32 %.sroa.17.0561.i1047.i to i64
  %525 = getelementptr ptr, ptr %.sroa.0.0564.i1044.i, i64 %524
  %526 = getelementptr i8, ptr %525, i64 64
  %527 = load ptr, ptr %526, align 8
  %result.i125.i.i = call ptr %527({ ptr, ptr, ptr, i32 } %522, ptr nocapture nofree noundef nonnull readonly %0) #16
  %528 = call i32 %result.i125.i.i({ ptr, ptr, ptr, i32 } %522, { ptr, ptr, ptr, i32 } %522, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1043.i, label %529, label %545

529:                                              ; preds = %514
  %530 = load i32, ptr %35, align 8
  %531 = add i32 %530, -1
  %532 = and i32 %531, %528
  %533 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %534 = load ptr, ptr %36, align 8
  %535 = sext i32 %532 to i64
  %536 = shl nsw i64 %535, 5
  %537 = getelementptr i8, ptr %534, i64 %536
  %538 = load ptr, ptr %537, align 8
  %539 = getelementptr i8, ptr %537, i64 8
  %540 = load i160, ptr %539, align 4
  store ptr %.sroa.0.0564.i1044.i, ptr %537, align 8
  store i64 %517, ptr %539, align 4
  %.sroa_idx157.i1073.i = getelementptr i8, ptr %537, i64 16
  store i64 %516, ptr %.sroa_idx157.i1073.i, align 4
  %.sroa_idx158.i1074.i = getelementptr i8, ptr %537, i64 24
  store i32 %.sroa.17.0561.i1047.i, ptr %.sroa_idx158.i1074.i, align 4
  %541 = icmp ne ptr %538, @nil_typ
  %542 = icmp ne ptr %538, null
  %.not92.i1075.i = and i1 %541, %542
  %extract.i1077.i = lshr i160 %540, 64
  %543 = insertelement <2 x i160> poison, i160 %540, i64 0
  %544 = insertelement <2 x i160> %543, i160 %extract.i1077.i, i64 1
  br i1 %.not92.i1075.i, label %.cont.cont.i1054.i, label %584

545:                                              ; preds = %514
  %546 = add i32 %528, 2127912214
  %547 = shl i32 %528, 12
  %548 = add i32 %546, %547
  %549 = ashr i32 %548, 19
  %550 = xor i32 %548, %549
  %551 = xor i32 %550, -949894596
  %552 = add i32 %551, 374761393
  %553 = shl i32 %551, 5
  %554 = add i32 %552, %553
  %555 = add i32 %554, -744332180
  %556 = shl i32 %554, 9
  %557 = xor i32 %555, %556
  %558 = add i32 %557, -42973499
  %559 = shl i32 %557, 3
  %560 = add i32 %558, %559
  %561 = ashr i32 %560, 16
  %562 = xor i32 %560, %561
  %563 = xor i32 %562, -1252372727
  %564 = load i32, ptr %35, align 8
  %565 = add i32 %564, -1
  %566 = and i32 %565, %563
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %568 = load ptr, ptr %37, align 8
  %569 = sext i32 %566 to i64
  %570 = shl nsw i64 %569, 5
  %571 = getelementptr i8, ptr %568, i64 %570
  %572 = load ptr, ptr %571, align 8
  %573 = getelementptr i8, ptr %571, i64 8
  %574 = load i160, ptr %573, align 4
  store ptr %.sroa.0.0564.i1044.i, ptr %571, align 8
  store i64 %517, ptr %573, align 4
  %.sroa_idx161.i1048.i = getelementptr i8, ptr %571, i64 16
  store i64 %516, ptr %.sroa_idx161.i1048.i, align 4
  %.sroa_idx162.i1049.i = getelementptr i8, ptr %571, i64 24
  store i32 %.sroa.17.0561.i1047.i, ptr %.sroa_idx162.i1049.i, align 4
  %575 = icmp ne ptr %572, @nil_typ
  %576 = icmp ne ptr %572, null
  %.not90.i1050.i = and i1 %575, %576
  %extract607.i1052.i = lshr i160 %574, 64
  %577 = insertelement <2 x i160> poison, i160 %574, i64 0
  %578 = insertelement <2 x i160> %577, i160 %extract607.i1052.i, i64 1
  br i1 %.not90.i1050.i, label %.cont.cont.i1054.i, label %584

.cont.cont.i1054.i:                               ; preds = %545, %529
  %vptr.i142.sroa.speculated.i1057.i = phi ptr [ %538, %529 ], [ %572, %545 ]
  %.in313 = phi <2 x i160> [ %544, %529 ], [ %578, %545 ]
  %579 = trunc <2 x i160> %.in313 to <2 x i64>
  %580 = xor i1 %.070565.i1043.i, true
  %hash_coef_ptr.i.i143.i1060.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1057.i, i64 8
  %tbl_size_ptr.i.i144.i1061.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1057.i, i64 16
  %offset_tbl_ptr.i.i145.i1062.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1057.i, i64 40
  %hash_coef.i.i146.i1063.i = load i64, ptr %hash_coef_ptr.i.i143.i1060.i, align 4
  %tbl_size.i.i147.i1064.i = load i64, ptr %tbl_size_ptr.i.i144.i1061.i, align 4
  %offset_tbl.i.i148.i1065.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1062.i, align 8
  %product.i.i.i149.i1066.i = mul i64 %hash_coef.i.i146.i1063.i, 4015701072841558310
  %shifted.i.i.i150.i1067.i = lshr i64 %product.i.i.i149.i1066.i, 32
  %xored.i.i.i151.i1068.i = xor i64 %shifted.i.i.i150.i1067.i, %product.i.i.i149.i1066.i
  %hash.i.i.i152.i1069.i = and i64 %xored.i.i.i151.i1068.i, %tbl_size.i.i147.i1064.i
  %offset_ptr.i.i153.i1070.i = getelementptr i32, ptr %offset_tbl.i.i148.i1065.i, i64 %hash.i.i.i152.i1069.i
  %offset.i.i154.i1071.i = load i32, ptr %offset_ptr.i.i153.i1070.i, align 4
  %581 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %582 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %583 = icmp ult i32 %.0566.i1042.i, 99
  br i1 %583, label %514, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1079.i

584:                                              ; preds = %545, %529
  %585 = phi ptr [ %20, %545 ], [ %19, %529 ]
  %586 = load i32, ptr %40, align 4
  store i32 %586, ptr %585, align 4
  %587 = add i32 %586, 1
  %588 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %587, ptr %40, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1079.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1079.i: ; preds = %.cont.cont.i1054.i, %584
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %19)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %20)
  br label %._crit_edge.i877.i

._crit_edge.i877.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1079.i, %.lr.ph.i862.i
  %589 = add nuw nsw i32 %.060.i875.i, 1
  %590 = icmp slt i32 %589, %496
  br i1 %590, label %.lr.ph.i862.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895.i: ; preds = %._crit_edge.i877.i, %._crit_edge.i913.i
  %.060.i911.i = phi i32 [ %679, %._crit_edge.i913.i ], [ 0, %._crit_edge.i877.i ]
  %591 = zext nneg i32 %.060.i911.i to i64
  %592 = shl nuw nsw i64 %591, 5
  %593 = getelementptr i8, ptr %495, i64 %592
  %594 = load ptr, ptr %593, align 8
  %595 = icmp ne ptr %594, @nil_typ
  %596 = icmp ne ptr %594, null
  %.not16.i912.i = and i1 %595, %596
  br i1 %.not16.i912.i, label %597, label %._crit_edge.i913.i

597:                                              ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895.i
  %598 = getelementptr i8, ptr %593, i64 8
  %599 = load <2 x i64>, ptr %598, align 4
  %hash_coef_ptr.i.i18.i915.i = getelementptr i8, ptr %594, i64 8
  %tbl_size_ptr.i.i19.i916.i = getelementptr i8, ptr %594, i64 16
  %offset_tbl_ptr.i.i20.i917.i = getelementptr i8, ptr %594, i64 40
  %600 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  %hash_coef.i.i99.i1097.i = load i64, ptr %hash_coef_ptr.i.i18.i915.i, align 4, !noalias !22
  %tbl_size.i.i100.i1098.i = load i64, ptr %tbl_size_ptr.i.i19.i916.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1099.i = load ptr, ptr %offset_tbl_ptr.i.i20.i917.i, align 8, !noalias !22
  %product.i.i.i102.i1100.i = mul i64 %hash_coef.i.i99.i1097.i, 4015701072841558310
  %shifted.i.i.i103.i1101.i = lshr i64 %product.i.i.i102.i1100.i, 32
  %xored.i.i.i104.i1102.i = xor i64 %shifted.i.i.i103.i1101.i, %product.i.i.i102.i1100.i
  %hash.i.i.i105.i1103.i = and i64 %xored.i.i.i104.i1102.i, %tbl_size.i.i100.i1098.i
  %offset_ptr.i.i106.i1104.i = getelementptr i32, ptr %offset_tbl.i.i101.i1099.i, i64 %hash.i.i.i105.i1103.i
  %offset.i.i121.i1105.i = load i32, ptr %offset_ptr.i.i106.i1104.i, align 4, !noalias !428
  %601 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %602 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %603 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %604

604:                                              ; preds = %.cont.cont.i1126.i, %597
  %.0566.i1106.i = phi i32 [ 0, %597 ], [ %608, %.cont.cont.i1126.i ]
  %.070565.i1107.i = phi i1 [ true, %597 ], [ %670, %.cont.cont.i1126.i ]
  %.sroa.0.0564.i1108.i = phi ptr [ %594, %597 ], [ %vptr.i142.sroa.speculated.i1129.i, %.cont.cont.i1126.i ]
  %.sroa.17.0561.i1111.i = phi i32 [ %offset.i.i121.i1105.i, %597 ], [ %offset.i.i154.i1143.i, %.cont.cont.i1126.i ]
  %605 = phi <2 x i64> [ %599, %597 ], [ %669, %.cont.cont.i1126.i ]
  %606 = extractelement <2 x i64> %605, i64 1
  %.sroa.12.0562.i1110.i = inttoptr i64 %606 to ptr
  %607 = extractelement <2 x i64> %605, i64 0
  %.sroa.6.0563.i1109.i = inttoptr i64 %607 to ptr
  %608 = add nuw nsw i32 %.0566.i1106.i, 1
  %609 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1108.i, 0
  %610 = insertvalue { ptr, ptr, ptr, i32 } %609, ptr %.sroa.6.0563.i1109.i, 1
  %611 = insertvalue { ptr, ptr, ptr, i32 } %610, ptr %.sroa.12.0562.i1110.i, 2
  %612 = insertvalue { ptr, ptr, ptr, i32 } %611, i32 %.sroa.17.0561.i1111.i, 3
  %613 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1108.i)
  %614 = sext i32 %.sroa.17.0561.i1111.i to i64
  %615 = getelementptr ptr, ptr %.sroa.0.0564.i1108.i, i64 %614
  %616 = getelementptr i8, ptr %615, i64 64
  %617 = load ptr, ptr %616, align 8
  %result.i125.i1112.i = call ptr %617({ ptr, ptr, ptr, i32 } %612, ptr nocapture nofree noundef nonnull readonly %0) #16
  %618 = call i32 %result.i125.i1112.i({ ptr, ptr, ptr, i32 } %612, { ptr, ptr, ptr, i32 } %612, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1107.i, label %619, label %635

619:                                              ; preds = %604
  %620 = load i32, ptr %35, align 8
  %621 = add i32 %620, -1
  %622 = and i32 %621, %618
  %623 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %624 = load ptr, ptr %36, align 8
  %625 = sext i32 %622 to i64
  %626 = shl nsw i64 %625, 5
  %627 = getelementptr i8, ptr %624, i64 %626
  %628 = load ptr, ptr %627, align 8
  %629 = getelementptr i8, ptr %627, i64 8
  %630 = load i160, ptr %629, align 4
  store ptr %.sroa.0.0564.i1108.i, ptr %627, align 8
  store i64 %607, ptr %629, align 4
  %.sroa_idx157.i1155.i = getelementptr i8, ptr %627, i64 16
  store i64 %606, ptr %.sroa_idx157.i1155.i, align 4
  %.sroa_idx158.i1156.i = getelementptr i8, ptr %627, i64 24
  store i32 %.sroa.17.0561.i1111.i, ptr %.sroa_idx158.i1156.i, align 4
  %631 = icmp ne ptr %628, @nil_typ
  %632 = icmp ne ptr %628, null
  %.not92.i1157.i = and i1 %631, %632
  %extract.i1159.i = lshr i160 %630, 64
  %633 = insertelement <2 x i160> poison, i160 %630, i64 0
  %634 = insertelement <2 x i160> %633, i160 %extract.i1159.i, i64 1
  br i1 %.not92.i1157.i, label %.cont.cont.i1126.i, label %674

635:                                              ; preds = %604
  %636 = add i32 %618, 2127912214
  %637 = shl i32 %618, 12
  %638 = add i32 %636, %637
  %639 = ashr i32 %638, 19
  %640 = xor i32 %638, %639
  %641 = xor i32 %640, -949894596
  %642 = add i32 %641, 374761393
  %643 = shl i32 %641, 5
  %644 = add i32 %642, %643
  %645 = add i32 %644, -744332180
  %646 = shl i32 %644, 9
  %647 = xor i32 %645, %646
  %648 = add i32 %647, -42973499
  %649 = shl i32 %647, 3
  %650 = add i32 %648, %649
  %651 = ashr i32 %650, 16
  %652 = xor i32 %650, %651
  %653 = xor i32 %652, -1252372727
  %654 = load i32, ptr %35, align 8
  %655 = add i32 %654, -1
  %656 = and i32 %655, %653
  %657 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %658 = load ptr, ptr %37, align 8
  %659 = sext i32 %656 to i64
  %660 = shl nsw i64 %659, 5
  %661 = getelementptr i8, ptr %658, i64 %660
  %662 = load ptr, ptr %661, align 8
  %663 = getelementptr i8, ptr %661, i64 8
  %664 = load i160, ptr %663, align 4
  store ptr %.sroa.0.0564.i1108.i, ptr %661, align 8
  store i64 %607, ptr %663, align 4
  %.sroa_idx161.i1116.i = getelementptr i8, ptr %661, i64 16
  store i64 %606, ptr %.sroa_idx161.i1116.i, align 4
  %.sroa_idx162.i1117.i = getelementptr i8, ptr %661, i64 24
  store i32 %.sroa.17.0561.i1111.i, ptr %.sroa_idx162.i1117.i, align 4
  %665 = icmp ne ptr %662, @nil_typ
  %666 = icmp ne ptr %662, null
  %.not90.i1118.i = and i1 %665, %666
  %extract607.i1120.i = lshr i160 %664, 64
  %667 = insertelement <2 x i160> poison, i160 %664, i64 0
  %668 = insertelement <2 x i160> %667, i160 %extract607.i1120.i, i64 1
  br i1 %.not90.i1118.i, label %.cont.cont.i1126.i, label %674

.cont.cont.i1126.i:                               ; preds = %635, %619
  %vptr.i142.sroa.speculated.i1129.i = phi ptr [ %628, %619 ], [ %662, %635 ]
  %.in314 = phi <2 x i160> [ %634, %619 ], [ %668, %635 ]
  %669 = trunc <2 x i160> %.in314 to <2 x i64>
  %670 = xor i1 %.070565.i1107.i, true
  %hash_coef_ptr.i.i143.i1132.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1129.i, i64 8
  %tbl_size_ptr.i.i144.i1133.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1129.i, i64 16
  %offset_tbl_ptr.i.i145.i1134.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1129.i, i64 40
  %hash_coef.i.i146.i1135.i = load i64, ptr %hash_coef_ptr.i.i143.i1132.i, align 4
  %tbl_size.i.i147.i1136.i = load i64, ptr %tbl_size_ptr.i.i144.i1133.i, align 4
  %offset_tbl.i.i148.i1137.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1134.i, align 8
  %product.i.i.i149.i1138.i = mul i64 %hash_coef.i.i146.i1135.i, 4015701072841558310
  %shifted.i.i.i150.i1139.i = lshr i64 %product.i.i.i149.i1138.i, 32
  %xored.i.i.i151.i1140.i = xor i64 %shifted.i.i.i150.i1139.i, %product.i.i.i149.i1138.i
  %hash.i.i.i152.i1141.i = and i64 %xored.i.i.i151.i1140.i, %tbl_size.i.i147.i1136.i
  %offset_ptr.i.i153.i1142.i = getelementptr i32, ptr %offset_tbl.i.i148.i1137.i, i64 %hash.i.i.i152.i1141.i
  %offset.i.i154.i1143.i = load i32, ptr %offset_ptr.i.i153.i1142.i, align 4
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %673 = icmp ult i32 %.0566.i1106.i, 99
  br i1 %673, label %604, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161.i

674:                                              ; preds = %635, %619
  %675 = phi ptr [ %18, %635 ], [ %17, %619 ]
  %676 = load i32, ptr %40, align 4
  store i32 %676, ptr %675, align 4
  %677 = add i32 %676, 1
  %678 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %677, ptr %40, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161.i: ; preds = %.cont.cont.i1126.i, %674
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  br label %._crit_edge.i913.i

._crit_edge.i913.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1161.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895.i
  %679 = add nuw nsw i32 %.060.i911.i, 1
  %680 = icmp slt i32 %679, %496
  br i1 %680, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit895.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i: ; preds = %._crit_edge.i913.i, %492
  %681 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %22)
  %hash_coef.i.i99.i534.i = load i64, ptr %hash_coef_ptr.i.i143.i.i, align 4, !noalias !22
  %tbl_size.i.i100.i535.i = load i64, ptr %tbl_size_ptr.i.i144.i.i, align 4, !noalias !22
  %offset_tbl.i.i101.i536.i = load ptr, ptr %offset_tbl_ptr.i.i145.i.i, align 8, !noalias !22
  %product.i.i.i102.i537.i = mul i64 %hash_coef.i.i99.i534.i, 4015701072841558310
  %shifted.i.i.i103.i538.i = lshr i64 %product.i.i.i102.i537.i, 32
  %xored.i.i.i104.i539.i = xor i64 %shifted.i.i.i103.i538.i, %product.i.i.i102.i537.i
  %hash.i.i.i105.i540.i = and i64 %xored.i.i.i104.i539.i, %tbl_size.i.i100.i535.i
  %offset_ptr.i.i106.i541.i = getelementptr i32, ptr %offset_tbl.i.i101.i536.i, i64 %hash.i.i.i105.i540.i
  %offset.i.i121.i542.i = load i32, ptr %offset_ptr.i.i106.i541.i, align 4, !noalias !431
  %682 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %683 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %684 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %685

685:                                              ; preds = %.cont.cont.i564.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i
  %.0566.i544.i = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i ], [ %689, %.cont.cont.i564.i ]
  %.070565.i545.i = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i ], [ %751, %.cont.cont.i564.i ]
  %.sroa.0.0564.i546.i = phi ptr [ %vptr.i142.sroa.speculated.i.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i ], [ %vptr.i142.sroa.speculated.i567.i, %.cont.cont.i564.i ]
  %.sroa.17.0561.i549.i = phi i32 [ %offset.i.i121.i542.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i ], [ %offset.i.i154.i581.i, %.cont.cont.i564.i ]
  %686 = phi <2 x i64> [ %480, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit931.i ], [ %750, %.cont.cont.i564.i ]
  %687 = extractelement <2 x i64> %686, i64 1
  %.sroa.12.0562.i548.i = inttoptr i64 %687 to ptr
  %688 = extractelement <2 x i64> %686, i64 0
  %.sroa.6.0563.i547.i = inttoptr i64 %688 to ptr
  %689 = add nuw nsw i32 %.0566.i544.i, 1
  %690 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i546.i, 0
  %691 = insertvalue { ptr, ptr, ptr, i32 } %690, ptr %.sroa.6.0563.i547.i, 1
  %692 = insertvalue { ptr, ptr, ptr, i32 } %691, ptr %.sroa.12.0562.i548.i, 2
  %693 = insertvalue { ptr, ptr, ptr, i32 } %692, i32 %.sroa.17.0561.i549.i, 3
  %694 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i546.i)
  %695 = sext i32 %.sroa.17.0561.i549.i to i64
  %696 = getelementptr ptr, ptr %.sroa.0.0564.i546.i, i64 %695
  %697 = getelementptr i8, ptr %696, i64 64
  %698 = load ptr, ptr %697, align 8
  %result.i125.i550.i = call ptr %698({ ptr, ptr, ptr, i32 } %693, ptr nocapture nofree noundef nonnull readonly %0) #16
  %699 = call i32 %result.i125.i550.i({ ptr, ptr, ptr, i32 } %693, { ptr, ptr, ptr, i32 } %693, ptr nonnull align 8 %0) #7
  br i1 %.070565.i545.i, label %700, label %716

700:                                              ; preds = %685
  %701 = load i32, ptr %35, align 8
  %702 = add i32 %701, -1
  %703 = and i32 %702, %699
  %704 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %705 = load ptr, ptr %36, align 8
  %706 = sext i32 %703 to i64
  %707 = shl nsw i64 %706, 5
  %708 = getelementptr i8, ptr %705, i64 %707
  %709 = load ptr, ptr %708, align 8
  %710 = getelementptr i8, ptr %708, i64 8
  %711 = load i160, ptr %710, align 4
  store ptr %.sroa.0.0564.i546.i, ptr %708, align 8
  store i64 %688, ptr %710, align 4
  %.sroa_idx157.i593.i = getelementptr i8, ptr %708, i64 16
  store i64 %687, ptr %.sroa_idx157.i593.i, align 4
  %.sroa_idx158.i594.i = getelementptr i8, ptr %708, i64 24
  store i32 %.sroa.17.0561.i549.i, ptr %.sroa_idx158.i594.i, align 4
  %712 = icmp ne ptr %709, @nil_typ
  %713 = icmp ne ptr %709, null
  %.not92.i595.i = and i1 %712, %713
  %extract.i597.i = lshr i160 %711, 64
  %714 = insertelement <2 x i160> poison, i160 %711, i64 0
  %715 = insertelement <2 x i160> %714, i160 %extract.i597.i, i64 1
  br i1 %.not92.i595.i, label %.cont.cont.i564.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.thread.i

716:                                              ; preds = %685
  %717 = add i32 %699, 2127912214
  %718 = shl i32 %699, 12
  %719 = add i32 %717, %718
  %720 = ashr i32 %719, 19
  %721 = xor i32 %719, %720
  %722 = xor i32 %721, -949894596
  %723 = add i32 %722, 374761393
  %724 = shl i32 %722, 5
  %725 = add i32 %723, %724
  %726 = add i32 %725, -744332180
  %727 = shl i32 %725, 9
  %728 = xor i32 %726, %727
  %729 = add i32 %728, -42973499
  %730 = shl i32 %728, 3
  %731 = add i32 %729, %730
  %732 = ashr i32 %731, 16
  %733 = xor i32 %731, %732
  %734 = xor i32 %733, -1252372727
  %735 = load i32, ptr %35, align 8
  %736 = add i32 %735, -1
  %737 = and i32 %736, %734
  %738 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %739 = load ptr, ptr %37, align 8
  %740 = sext i32 %737 to i64
  %741 = shl nsw i64 %740, 5
  %742 = getelementptr i8, ptr %739, i64 %741
  %743 = load ptr, ptr %742, align 8
  %744 = getelementptr i8, ptr %742, i64 8
  %745 = load i160, ptr %744, align 4
  store ptr %.sroa.0.0564.i546.i, ptr %742, align 8
  store i64 %688, ptr %744, align 4
  %.sroa_idx161.i554.i = getelementptr i8, ptr %742, i64 16
  store i64 %687, ptr %.sroa_idx161.i554.i, align 4
  %.sroa_idx162.i555.i = getelementptr i8, ptr %742, i64 24
  store i32 %.sroa.17.0561.i549.i, ptr %.sroa_idx162.i555.i, align 4
  %746 = icmp ne ptr %743, @nil_typ
  %747 = icmp ne ptr %743, null
  %.not90.i556.i = and i1 %746, %747
  %extract607.i558.i = lshr i160 %745, 64
  %748 = insertelement <2 x i160> poison, i160 %745, i64 0
  %749 = insertelement <2 x i160> %748, i160 %extract607.i558.i, i64 1
  br i1 %.not90.i556.i, label %.cont.cont.i564.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.thread.i

.cont.cont.i564.i:                                ; preds = %716, %700
  %vptr.i142.sroa.speculated.i567.i = phi ptr [ %709, %700 ], [ %743, %716 ]
  %.in315 = phi <2 x i160> [ %715, %700 ], [ %749, %716 ]
  %750 = trunc <2 x i160> %.in315 to <2 x i64>
  %751 = xor i1 %.070565.i545.i, true
  %hash_coef_ptr.i.i143.i570.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i567.i, i64 8
  %tbl_size_ptr.i.i144.i571.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i567.i, i64 16
  %offset_tbl_ptr.i.i145.i572.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i567.i, i64 40
  %hash_coef.i.i146.i573.i = load i64, ptr %hash_coef_ptr.i.i143.i570.i, align 4
  %tbl_size.i.i147.i574.i = load i64, ptr %tbl_size_ptr.i.i144.i571.i, align 4
  %offset_tbl.i.i148.i575.i = load ptr, ptr %offset_tbl_ptr.i.i145.i572.i, align 8
  %product.i.i.i149.i576.i = mul i64 %hash_coef.i.i146.i573.i, 4015701072841558310
  %shifted.i.i.i150.i577.i = lshr i64 %product.i.i.i149.i576.i, 32
  %xored.i.i.i151.i578.i = xor i64 %shifted.i.i.i150.i577.i, %product.i.i.i149.i576.i
  %hash.i.i.i152.i579.i = and i64 %xored.i.i.i151.i578.i, %tbl_size.i.i147.i574.i
  %offset_ptr.i.i153.i580.i = getelementptr i32, ptr %offset_tbl.i.i148.i575.i, i64 %hash.i.i.i152.i579.i
  %offset.i.i154.i581.i = load i32, ptr %offset_ptr.i.i153.i580.i, align 4
  %752 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %753 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %754 = icmp ult i32 %.0566.i544.i, 99
  br i1 %754, label %685, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.thread.i: ; preds = %716, %700
  %755 = phi ptr [ %22, %716 ], [ %21, %700 ]
  %756 = load i32, ptr %40, align 4
  store i32 %756, ptr %755, align 4
  %757 = add i32 %756, 1
  %758 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %757, ptr %40, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  br label %CuckooMap_insert_keyK_valueV.exit.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.i: ; preds = %.cont.cont.i564.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %21)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %22)
  %759 = icmp eq ptr %vptr.i142.sroa.speculated.i567.i, null
  br i1 %759, label %CuckooMap_insert_keyK_valueV.exit.i, label %760

760:                                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.i
  %761 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %762 = load ptr, ptr %36, align 8
  %763 = load ptr, ptr %37, align 8
  %764 = load i32, ptr %35, align 8
  %765 = shl i32 %764, 1
  %spec.select.i615.i = call i32 @llvm.smax.i32(i32 %765, i32 16)
  store i32 %spec.select.i615.i, ptr %35, align 8
  %766 = zext nneg i32 %spec.select.i615.i to i64
  %767 = shl nuw nsw i64 %766, 5
  %result.i.i616.i = call noalias ptr @bump_malloc_inner(i64 noundef %767, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i616.i, ptr %36, align 8
  %result.i20.i617.i = call noalias ptr @bump_malloc_inner(i64 noundef %767, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i617.i, ptr %37, align 8
  store i32 0, ptr %40, align 4
  %768 = icmp sgt i32 %764, 0
  br i1 %768, label %.lr.ph.i961.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.thread.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.thread.i: ; preds = %760
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit.i

.lr.ph.i961.i:                                    ; preds = %760, %._crit_edge.i976.i
  %.060.i974.i = phi i32 [ %858, %._crit_edge.i976.i ], [ 0, %760 ]
  %770 = zext nneg i32 %.060.i974.i to i64
  %771 = shl nuw nsw i64 %770, 5
  %772 = getelementptr i8, ptr %762, i64 %771
  %773 = load ptr, ptr %772, align 8
  %774 = icmp ne ptr %773, @nil_typ
  %775 = icmp ne ptr %773, null
  %.not16.i975.i = and i1 %774, %775
  br i1 %.not16.i975.i, label %776, label %._crit_edge.i976.i

776:                                              ; preds = %.lr.ph.i961.i
  %777 = getelementptr i8, ptr %772, i64 8
  %778 = load <2 x i64>, ptr %777, align 4
  %hash_coef_ptr.i.i18.i978.i = getelementptr i8, ptr %773, i64 8
  %tbl_size_ptr.i.i19.i979.i = getelementptr i8, ptr %773, i64 16
  %offset_tbl_ptr.i.i20.i980.i = getelementptr i8, ptr %773, i64 40
  %779 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %16)
  %hash_coef.i.i99.i1179.i = load i64, ptr %hash_coef_ptr.i.i18.i978.i, align 4, !noalias !22
  %tbl_size.i.i100.i1180.i = load i64, ptr %tbl_size_ptr.i.i19.i979.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1181.i = load ptr, ptr %offset_tbl_ptr.i.i20.i980.i, align 8, !noalias !22
  %product.i.i.i102.i1182.i = mul i64 %hash_coef.i.i99.i1179.i, 4015701072841558310
  %shifted.i.i.i103.i1183.i = lshr i64 %product.i.i.i102.i1182.i, 32
  %xored.i.i.i104.i1184.i = xor i64 %shifted.i.i.i103.i1183.i, %product.i.i.i102.i1182.i
  %hash.i.i.i105.i1185.i = and i64 %xored.i.i.i104.i1184.i, %tbl_size.i.i100.i1180.i
  %offset_ptr.i.i106.i1186.i = getelementptr i32, ptr %offset_tbl.i.i101.i1181.i, i64 %hash.i.i.i105.i1185.i
  %offset.i.i121.i1187.i = load i32, ptr %offset_ptr.i.i106.i1186.i, align 4, !noalias !434
  %780 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %781 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %782 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %783

783:                                              ; preds = %.cont.cont.i1208.i, %776
  %.0566.i1188.i = phi i32 [ 0, %776 ], [ %787, %.cont.cont.i1208.i ]
  %.070565.i1189.i = phi i1 [ true, %776 ], [ %849, %.cont.cont.i1208.i ]
  %.sroa.0.0564.i1190.i = phi ptr [ %773, %776 ], [ %vptr.i142.sroa.speculated.i1211.i, %.cont.cont.i1208.i ]
  %.sroa.17.0561.i1193.i = phi i32 [ %offset.i.i121.i1187.i, %776 ], [ %offset.i.i154.i1225.i, %.cont.cont.i1208.i ]
  %784 = phi <2 x i64> [ %778, %776 ], [ %848, %.cont.cont.i1208.i ]
  %785 = extractelement <2 x i64> %784, i64 1
  %.sroa.12.0562.i1192.i = inttoptr i64 %785 to ptr
  %786 = extractelement <2 x i64> %784, i64 0
  %.sroa.6.0563.i1191.i = inttoptr i64 %786 to ptr
  %787 = add nuw nsw i32 %.0566.i1188.i, 1
  %788 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1190.i, 0
  %789 = insertvalue { ptr, ptr, ptr, i32 } %788, ptr %.sroa.6.0563.i1191.i, 1
  %790 = insertvalue { ptr, ptr, ptr, i32 } %789, ptr %.sroa.12.0562.i1192.i, 2
  %791 = insertvalue { ptr, ptr, ptr, i32 } %790, i32 %.sroa.17.0561.i1193.i, 3
  %792 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1190.i)
  %793 = sext i32 %.sroa.17.0561.i1193.i to i64
  %794 = getelementptr ptr, ptr %.sroa.0.0564.i1190.i, i64 %793
  %795 = getelementptr i8, ptr %794, i64 64
  %796 = load ptr, ptr %795, align 8
  %result.i125.i1194.i = call ptr %796({ ptr, ptr, ptr, i32 } %791, ptr nocapture nofree noundef nonnull readonly %0) #16
  %797 = call i32 %result.i125.i1194.i({ ptr, ptr, ptr, i32 } %791, { ptr, ptr, ptr, i32 } %791, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1189.i, label %798, label %814

798:                                              ; preds = %783
  %799 = load i32, ptr %35, align 8
  %800 = add i32 %799, -1
  %801 = and i32 %800, %797
  %802 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %803 = load ptr, ptr %36, align 8
  %804 = sext i32 %801 to i64
  %805 = shl nsw i64 %804, 5
  %806 = getelementptr i8, ptr %803, i64 %805
  %807 = load ptr, ptr %806, align 8
  %808 = getelementptr i8, ptr %806, i64 8
  %809 = load i160, ptr %808, align 4
  store ptr %.sroa.0.0564.i1190.i, ptr %806, align 8
  store i64 %786, ptr %808, align 4
  %.sroa_idx157.i1237.i = getelementptr i8, ptr %806, i64 16
  store i64 %785, ptr %.sroa_idx157.i1237.i, align 4
  %.sroa_idx158.i1238.i = getelementptr i8, ptr %806, i64 24
  store i32 %.sroa.17.0561.i1193.i, ptr %.sroa_idx158.i1238.i, align 4
  %810 = icmp ne ptr %807, @nil_typ
  %811 = icmp ne ptr %807, null
  %.not92.i1239.i = and i1 %810, %811
  %extract.i1241.i = lshr i160 %809, 64
  %812 = insertelement <2 x i160> poison, i160 %809, i64 0
  %813 = insertelement <2 x i160> %812, i160 %extract.i1241.i, i64 1
  br i1 %.not92.i1239.i, label %.cont.cont.i1208.i, label %853

814:                                              ; preds = %783
  %815 = add i32 %797, 2127912214
  %816 = shl i32 %797, 12
  %817 = add i32 %815, %816
  %818 = ashr i32 %817, 19
  %819 = xor i32 %817, %818
  %820 = xor i32 %819, -949894596
  %821 = add i32 %820, 374761393
  %822 = shl i32 %820, 5
  %823 = add i32 %821, %822
  %824 = add i32 %823, -744332180
  %825 = shl i32 %823, 9
  %826 = xor i32 %824, %825
  %827 = add i32 %826, -42973499
  %828 = shl i32 %826, 3
  %829 = add i32 %827, %828
  %830 = ashr i32 %829, 16
  %831 = xor i32 %829, %830
  %832 = xor i32 %831, -1252372727
  %833 = load i32, ptr %35, align 8
  %834 = add i32 %833, -1
  %835 = and i32 %834, %832
  %836 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %837 = load ptr, ptr %37, align 8
  %838 = sext i32 %835 to i64
  %839 = shl nsw i64 %838, 5
  %840 = getelementptr i8, ptr %837, i64 %839
  %841 = load ptr, ptr %840, align 8
  %842 = getelementptr i8, ptr %840, i64 8
  %843 = load i160, ptr %842, align 4
  store ptr %.sroa.0.0564.i1190.i, ptr %840, align 8
  store i64 %786, ptr %842, align 4
  %.sroa_idx161.i1198.i = getelementptr i8, ptr %840, i64 16
  store i64 %785, ptr %.sroa_idx161.i1198.i, align 4
  %.sroa_idx162.i1199.i = getelementptr i8, ptr %840, i64 24
  store i32 %.sroa.17.0561.i1193.i, ptr %.sroa_idx162.i1199.i, align 4
  %844 = icmp ne ptr %841, @nil_typ
  %845 = icmp ne ptr %841, null
  %.not90.i1200.i = and i1 %844, %845
  %extract607.i1202.i = lshr i160 %843, 64
  %846 = insertelement <2 x i160> poison, i160 %843, i64 0
  %847 = insertelement <2 x i160> %846, i160 %extract607.i1202.i, i64 1
  br i1 %.not90.i1200.i, label %.cont.cont.i1208.i, label %853

.cont.cont.i1208.i:                               ; preds = %814, %798
  %vptr.i142.sroa.speculated.i1211.i = phi ptr [ %807, %798 ], [ %841, %814 ]
  %.in316 = phi <2 x i160> [ %813, %798 ], [ %847, %814 ]
  %848 = trunc <2 x i160> %.in316 to <2 x i64>
  %849 = xor i1 %.070565.i1189.i, true
  %hash_coef_ptr.i.i143.i1214.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1211.i, i64 8
  %tbl_size_ptr.i.i144.i1215.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1211.i, i64 16
  %offset_tbl_ptr.i.i145.i1216.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1211.i, i64 40
  %hash_coef.i.i146.i1217.i = load i64, ptr %hash_coef_ptr.i.i143.i1214.i, align 4
  %tbl_size.i.i147.i1218.i = load i64, ptr %tbl_size_ptr.i.i144.i1215.i, align 4
  %offset_tbl.i.i148.i1219.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1216.i, align 8
  %product.i.i.i149.i1220.i = mul i64 %hash_coef.i.i146.i1217.i, 4015701072841558310
  %shifted.i.i.i150.i1221.i = lshr i64 %product.i.i.i149.i1220.i, 32
  %xored.i.i.i151.i1222.i = xor i64 %shifted.i.i.i150.i1221.i, %product.i.i.i149.i1220.i
  %hash.i.i.i152.i1223.i = and i64 %xored.i.i.i151.i1222.i, %tbl_size.i.i147.i1218.i
  %offset_ptr.i.i153.i1224.i = getelementptr i32, ptr %offset_tbl.i.i148.i1219.i, i64 %hash.i.i.i152.i1223.i
  %offset.i.i154.i1225.i = load i32, ptr %offset_ptr.i.i153.i1224.i, align 4
  %850 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %851 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %852 = icmp ult i32 %.0566.i1188.i, 99
  br i1 %852, label %783, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1243.i

853:                                              ; preds = %814, %798
  %854 = phi ptr [ %16, %814 ], [ %15, %798 ]
  %855 = load i32, ptr %40, align 4
  store i32 %855, ptr %854, align 4
  %856 = add i32 %855, 1
  %857 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %856, ptr %40, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1243.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1243.i: ; preds = %.cont.cont.i1208.i, %853
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %15)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %16)
  br label %._crit_edge.i976.i

._crit_edge.i976.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1243.i, %.lr.ph.i961.i
  %858 = add nuw nsw i32 %.060.i974.i, 1
  %859 = icmp slt i32 %858, %764
  br i1 %859, label %.lr.ph.i961.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.i: ; preds = %._crit_edge.i976.i
  %860 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %861

861:                                              ; preds = %._crit_edge.i1012.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.i
  %.060.i1010.i = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.i ], [ %950, %._crit_edge.i1012.i ]
  %862 = zext nneg i32 %.060.i1010.i to i64
  %863 = shl nuw nsw i64 %862, 5
  %864 = getelementptr i8, ptr %763, i64 %863
  %865 = load ptr, ptr %864, align 8
  %866 = icmp ne ptr %865, @nil_typ
  %867 = icmp ne ptr %865, null
  %.not16.i1011.i = and i1 %866, %867
  br i1 %.not16.i1011.i, label %868, label %._crit_edge.i1012.i

868:                                              ; preds = %861
  %869 = getelementptr i8, ptr %864, i64 8
  %870 = load <2 x i64>, ptr %869, align 4
  %hash_coef_ptr.i.i18.i1014.i = getelementptr i8, ptr %865, i64 8
  %tbl_size_ptr.i.i19.i1015.i = getelementptr i8, ptr %865, i64 16
  %offset_tbl_ptr.i.i20.i1016.i = getelementptr i8, ptr %865, i64 40
  %871 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %14)
  %hash_coef.i.i99.i1261.i = load i64, ptr %hash_coef_ptr.i.i18.i1014.i, align 4, !noalias !22
  %tbl_size.i.i100.i1262.i = load i64, ptr %tbl_size_ptr.i.i19.i1015.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1263.i = load ptr, ptr %offset_tbl_ptr.i.i20.i1016.i, align 8, !noalias !22
  %product.i.i.i102.i1264.i = mul i64 %hash_coef.i.i99.i1261.i, 4015701072841558310
  %shifted.i.i.i103.i1265.i = lshr i64 %product.i.i.i102.i1264.i, 32
  %xored.i.i.i104.i1266.i = xor i64 %shifted.i.i.i103.i1265.i, %product.i.i.i102.i1264.i
  %hash.i.i.i105.i1267.i = and i64 %xored.i.i.i104.i1266.i, %tbl_size.i.i100.i1262.i
  %offset_ptr.i.i106.i1268.i = getelementptr i32, ptr %offset_tbl.i.i101.i1263.i, i64 %hash.i.i.i105.i1267.i
  %offset.i.i121.i1269.i = load i32, ptr %offset_ptr.i.i106.i1268.i, align 4, !noalias !437
  %872 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %873 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %874 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %875

875:                                              ; preds = %.cont.cont.i1290.i, %868
  %.0566.i1270.i = phi i32 [ 0, %868 ], [ %879, %.cont.cont.i1290.i ]
  %.070565.i1271.i = phi i1 [ true, %868 ], [ %941, %.cont.cont.i1290.i ]
  %.sroa.0.0564.i1272.i = phi ptr [ %865, %868 ], [ %vptr.i142.sroa.speculated.i1293.i, %.cont.cont.i1290.i ]
  %.sroa.17.0561.i1275.i = phi i32 [ %offset.i.i121.i1269.i, %868 ], [ %offset.i.i154.i1307.i, %.cont.cont.i1290.i ]
  %876 = phi <2 x i64> [ %870, %868 ], [ %940, %.cont.cont.i1290.i ]
  %877 = extractelement <2 x i64> %876, i64 1
  %.sroa.12.0562.i1274.i = inttoptr i64 %877 to ptr
  %878 = extractelement <2 x i64> %876, i64 0
  %.sroa.6.0563.i1273.i = inttoptr i64 %878 to ptr
  %879 = add nuw nsw i32 %.0566.i1270.i, 1
  %880 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1272.i, 0
  %881 = insertvalue { ptr, ptr, ptr, i32 } %880, ptr %.sroa.6.0563.i1273.i, 1
  %882 = insertvalue { ptr, ptr, ptr, i32 } %881, ptr %.sroa.12.0562.i1274.i, 2
  %883 = insertvalue { ptr, ptr, ptr, i32 } %882, i32 %.sroa.17.0561.i1275.i, 3
  %884 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1272.i)
  %885 = sext i32 %.sroa.17.0561.i1275.i to i64
  %886 = getelementptr ptr, ptr %.sroa.0.0564.i1272.i, i64 %885
  %887 = getelementptr i8, ptr %886, i64 64
  %888 = load ptr, ptr %887, align 8
  %result.i125.i1276.i = call ptr %888({ ptr, ptr, ptr, i32 } %883, ptr nocapture nofree noundef nonnull readonly %0) #16
  %889 = call i32 %result.i125.i1276.i({ ptr, ptr, ptr, i32 } %883, { ptr, ptr, ptr, i32 } %883, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1271.i, label %890, label %906

890:                                              ; preds = %875
  %891 = load i32, ptr %35, align 8
  %892 = add i32 %891, -1
  %893 = and i32 %892, %889
  %894 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %895 = load ptr, ptr %36, align 8
  %896 = sext i32 %893 to i64
  %897 = shl nsw i64 %896, 5
  %898 = getelementptr i8, ptr %895, i64 %897
  %899 = load ptr, ptr %898, align 8
  %900 = getelementptr i8, ptr %898, i64 8
  %901 = load i160, ptr %900, align 4
  store ptr %.sroa.0.0564.i1272.i, ptr %898, align 8
  store i64 %878, ptr %900, align 4
  %.sroa_idx157.i1319.i = getelementptr i8, ptr %898, i64 16
  store i64 %877, ptr %.sroa_idx157.i1319.i, align 4
  %.sroa_idx158.i1320.i = getelementptr i8, ptr %898, i64 24
  store i32 %.sroa.17.0561.i1275.i, ptr %.sroa_idx158.i1320.i, align 4
  %902 = icmp ne ptr %899, @nil_typ
  %903 = icmp ne ptr %899, null
  %.not92.i1321.i = and i1 %902, %903
  %extract.i1323.i = lshr i160 %901, 64
  %904 = insertelement <2 x i160> poison, i160 %901, i64 0
  %905 = insertelement <2 x i160> %904, i160 %extract.i1323.i, i64 1
  br i1 %.not92.i1321.i, label %.cont.cont.i1290.i, label %945

906:                                              ; preds = %875
  %907 = add i32 %889, 2127912214
  %908 = shl i32 %889, 12
  %909 = add i32 %907, %908
  %910 = ashr i32 %909, 19
  %911 = xor i32 %909, %910
  %912 = xor i32 %911, -949894596
  %913 = add i32 %912, 374761393
  %914 = shl i32 %912, 5
  %915 = add i32 %913, %914
  %916 = add i32 %915, -744332180
  %917 = shl i32 %915, 9
  %918 = xor i32 %916, %917
  %919 = add i32 %918, -42973499
  %920 = shl i32 %918, 3
  %921 = add i32 %919, %920
  %922 = ashr i32 %921, 16
  %923 = xor i32 %921, %922
  %924 = xor i32 %923, -1252372727
  %925 = load i32, ptr %35, align 8
  %926 = add i32 %925, -1
  %927 = and i32 %926, %924
  %928 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %929 = load ptr, ptr %37, align 8
  %930 = sext i32 %927 to i64
  %931 = shl nsw i64 %930, 5
  %932 = getelementptr i8, ptr %929, i64 %931
  %933 = load ptr, ptr %932, align 8
  %934 = getelementptr i8, ptr %932, i64 8
  %935 = load i160, ptr %934, align 4
  store ptr %.sroa.0.0564.i1272.i, ptr %932, align 8
  store i64 %878, ptr %934, align 4
  %.sroa_idx161.i1280.i = getelementptr i8, ptr %932, i64 16
  store i64 %877, ptr %.sroa_idx161.i1280.i, align 4
  %.sroa_idx162.i1281.i = getelementptr i8, ptr %932, i64 24
  store i32 %.sroa.17.0561.i1275.i, ptr %.sroa_idx162.i1281.i, align 4
  %936 = icmp ne ptr %933, @nil_typ
  %937 = icmp ne ptr %933, null
  %.not90.i1282.i = and i1 %936, %937
  %extract607.i1284.i = lshr i160 %935, 64
  %938 = insertelement <2 x i160> poison, i160 %935, i64 0
  %939 = insertelement <2 x i160> %938, i160 %extract607.i1284.i, i64 1
  br i1 %.not90.i1282.i, label %.cont.cont.i1290.i, label %945

.cont.cont.i1290.i:                               ; preds = %906, %890
  %vptr.i142.sroa.speculated.i1293.i = phi ptr [ %899, %890 ], [ %933, %906 ]
  %.in317 = phi <2 x i160> [ %905, %890 ], [ %939, %906 ]
  %940 = trunc <2 x i160> %.in317 to <2 x i64>
  %941 = xor i1 %.070565.i1271.i, true
  %hash_coef_ptr.i.i143.i1296.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1293.i, i64 8
  %tbl_size_ptr.i.i144.i1297.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1293.i, i64 16
  %offset_tbl_ptr.i.i145.i1298.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1293.i, i64 40
  %hash_coef.i.i146.i1299.i = load i64, ptr %hash_coef_ptr.i.i143.i1296.i, align 4
  %tbl_size.i.i147.i1300.i = load i64, ptr %tbl_size_ptr.i.i144.i1297.i, align 4
  %offset_tbl.i.i148.i1301.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1298.i, align 8
  %product.i.i.i149.i1302.i = mul i64 %hash_coef.i.i146.i1299.i, 4015701072841558310
  %shifted.i.i.i150.i1303.i = lshr i64 %product.i.i.i149.i1302.i, 32
  %xored.i.i.i151.i1304.i = xor i64 %shifted.i.i.i150.i1303.i, %product.i.i.i149.i1302.i
  %hash.i.i.i152.i1305.i = and i64 %xored.i.i.i151.i1304.i, %tbl_size.i.i147.i1300.i
  %offset_ptr.i.i153.i1306.i = getelementptr i32, ptr %offset_tbl.i.i148.i1301.i, i64 %hash.i.i.i152.i1305.i
  %offset.i.i154.i1307.i = load i32, ptr %offset_ptr.i.i153.i1306.i, align 4
  %942 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %943 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %944 = icmp ult i32 %.0566.i1270.i, 99
  br i1 %944, label %875, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1325.i

945:                                              ; preds = %906, %890
  %946 = phi ptr [ %14, %906 ], [ %13, %890 ]
  %947 = load i32, ptr %40, align 4
  store i32 %947, ptr %946, align 4
  %948 = add i32 %947, 1
  %949 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %948, ptr %40, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1325.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1325.i: ; preds = %.cont.cont.i1290.i, %945
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %13)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %14)
  br label %._crit_edge.i1012.i

._crit_edge.i1012.i:                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1325.i, %861
  %950 = add nuw nsw i32 %.060.i1010.i, 1
  %951 = icmp slt i32 %950, %764
  br i1 %951, label %861, label %CuckooMap_insert_keyK_valueV.exit.i

CuckooMap_insert_keyK_valueV.exit.i:              ; preds = %._crit_edge.i1012.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit994.thread.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit599.thread.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit459.i, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %952 = icmp ult i32 %.0213.i, 999999
  br i1 %952, label %._crit_edge.i, label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %CuckooMap_insert_keyK_valueV.exit.i
  %953 = call i64 @clock()
  %954 = load ptr, ptr %33, align 8
  %955 = call i32 %954({ ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  %956 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %957 = load i32, ptr %35, align 8
  %958 = add i32 %957, -1
  %959 = and i32 %958, %955
  %960 = load ptr, ptr %36, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %961 = sext i32 %959 to i64
  %962 = shl nsw i64 %961, 5
  %963 = getelementptr i8, ptr %960, i64 %962
  %964 = load ptr, ptr %963, align 8
  %965 = icmp ne ptr %964, @nil_typ
  %966 = icmp ne ptr %964, null
  %.not44.i.i = and i1 %965, %966
  br i1 %.not44.i.i, label %967, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i

967:                                              ; preds = %._crit_edge2.i
  %968 = getelementptr i8, ptr %963, i64 8
  %969 = load i64, ptr %968, align 4
  %.sroa_idx.i662.i = getelementptr i8, ptr %963, i64 16
  %970 = load i64, ptr %.sroa_idx.i662.i, align 4
  %971 = inttoptr i64 %969 to ptr
  %972 = inttoptr i64 %970 to ptr
  %hash_coef_ptr.i.i46.i.i = getelementptr i8, ptr %964, i64 8
  %tbl_size_ptr.i.i47.i.i = getelementptr i8, ptr %964, i64 16
  %offset_tbl_ptr.i.i48.i.i = getelementptr i8, ptr %964, i64 40
  %hash_coef.i.i49.i.i = load i64, ptr %hash_coef_ptr.i.i46.i.i, align 4, !noalias !440
  %tbl_size.i.i50.i.i = load i64, ptr %tbl_size_ptr.i.i47.i.i, align 4, !noalias !440
  %offset_tbl.i.i51.i.i = load ptr, ptr %offset_tbl_ptr.i.i48.i.i, align 8, !noalias !440
  %product.i.i.i52.i.i = mul i64 %hash_coef.i.i49.i.i, 4015701072841558310
  %shifted.i.i.i53.i.i = lshr i64 %product.i.i.i52.i.i, 32
  %xored.i.i.i54.i.i = xor i64 %shifted.i.i.i53.i.i, %product.i.i.i52.i.i
  %hash.i.i.i55.i.i = and i64 %xored.i.i.i54.i.i, %tbl_size.i.i50.i.i
  %offset_ptr.i.i56.i.i = getelementptr i32, ptr %offset_tbl.i.i51.i.i, i64 %hash.i.i.i55.i.i
  %offset.i.i57.i.i = load i32, ptr %offset_ptr.i.i56.i.i, align 4, !noalias !440
  %973 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %964, 0
  %974 = insertvalue { ptr, ptr, ptr, i32 } %973, ptr %971, 1
  %975 = insertvalue { ptr, ptr, ptr, i32 } %974, ptr %972, 2
  %976 = insertvalue { ptr, ptr, ptr, i32 } %975, i32 %offset.i.i57.i.i, 3
  %977 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %978 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %964) #35
  %979 = sext i32 %offset.i.i57.i.i to i64
  %980 = getelementptr ptr, ptr %964, i64 %979
  %981 = getelementptr i8, ptr %980, i64 64
  %982 = load ptr, ptr %981, align 8
  %result.i.i663.i = call ptr %982({ ptr, ptr, ptr, i32 } %976, ptr nocapture nofree noundef nonnull readonly %0) #16
  %983 = call i32 %result.i.i663.i({ ptr, ptr, ptr, i32 } %976, { ptr, ptr, ptr, i32 } %976, ptr nonnull align 8 %0) #7
  %984 = icmp eq i32 %983, %955
  br i1 %984, label %._crit_edge.i664.i, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i

._crit_edge.i664.i:                               ; preds = %967
  %985 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %986 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %964)
  %987 = getelementptr i8, ptr %980, i64 48
  %988 = load ptr, ptr %987, align 8
  %result.i59.i.i = call ptr %988({ ptr, ptr, ptr, i32 } %976, ptr nocapture nofree noundef nonnull readonly %0) #16
  %989 = call { ptr, i160 } %result.i59.i.i({ ptr, ptr, ptr, i32 } %976, { ptr, ptr, ptr, i32 } %976, ptr nonnull align 8 %0) #7
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %991 = load ptr, ptr %34, align 8
  %992 = call i1 %991({ ptr, i160 } %989, { ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  br i1 %992, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i: ; preds = %._crit_edge.i664.i, %967, %._crit_edge2.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %1000

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i: ; preds = %._crit_edge.i664.i
  %993 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %994 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %964)
  %995 = getelementptr i8, ptr %980, i64 56
  %996 = load ptr, ptr %995, align 8
  %result.i60.i.i = call ptr %996({ ptr, ptr, ptr, i32 } %976, ptr nocapture nofree noundef nonnull readonly %0) #16
  %997 = call { ptr, i160 } %result.i60.i.i({ ptr, ptr, ptr, i32 } %976, { ptr, ptr, ptr, i32 } %976, ptr nonnull align 8 %0) #7
  %.fca.0.extract21.i.i = extractvalue { ptr, i160 } %997, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %998 = icmp ne ptr %.fca.0.extract21.i.i, @nil_typ
  %999 = icmp ne ptr %.fca.0.extract21.i.i, null
  %.not63.i.i = and i1 %998, %999
  br i1 %.not63.i.i, label %CuckooMap_get_keyK.exit.i, label %1000

1000:                                             ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i
  %1001 = add i32 %955, 2127912214
  %1002 = shl i32 %955, 12
  %1003 = add i32 %1001, %1002
  %1004 = ashr i32 %1003, 19
  %1005 = xor i32 %1003, %1004
  %1006 = xor i32 %1005, -949894596
  %1007 = add i32 %1006, 374761393
  %1008 = shl i32 %1006, 5
  %1009 = add i32 %1007, %1008
  %1010 = add i32 %1009, -744332180
  %1011 = shl i32 %1009, 9
  %1012 = xor i32 %1010, %1011
  %1013 = add i32 %1012, -42973499
  %1014 = shl i32 %1012, 3
  %1015 = add i32 %1013, %1014
  %1016 = ashr i32 %1015, 16
  %1017 = xor i32 %1015, %1016
  %1018 = xor i32 %1017, -1252372727
  %1019 = load i32, ptr %35, align 8
  %1020 = add i32 %1019, -1
  %1021 = and i32 %1020, %1018
  %1022 = load ptr, ptr %37, align 8
  %1023 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1024 = sext i32 %1021 to i64
  %1025 = shl nsw i64 %1024, 5
  %1026 = getelementptr i8, ptr %1022, i64 %1025
  %1027 = load ptr, ptr %1026, align 8
  %1028 = icmp ne ptr %1027, @nil_typ
  %1029 = icmp ne ptr %1027, null
  %.not44.i694.i = and i1 %1028, %1029
  br i1 %.not44.i694.i, label %1030, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718.i

1030:                                             ; preds = %1000
  %1031 = getelementptr i8, ptr %1026, i64 8
  %1032 = load i64, ptr %1031, align 4
  %.sroa_idx.i698.i = getelementptr i8, ptr %1026, i64 16
  %1033 = load i64, ptr %.sroa_idx.i698.i, align 4
  %1034 = inttoptr i64 %1032 to ptr
  %1035 = inttoptr i64 %1033 to ptr
  %hash_coef_ptr.i.i46.i699.i = getelementptr i8, ptr %1027, i64 8
  %tbl_size_ptr.i.i47.i700.i = getelementptr i8, ptr %1027, i64 16
  %offset_tbl_ptr.i.i48.i701.i = getelementptr i8, ptr %1027, i64 40
  %hash_coef.i.i49.i702.i = load i64, ptr %hash_coef_ptr.i.i46.i699.i, align 4, !noalias !443
  %tbl_size.i.i50.i703.i = load i64, ptr %tbl_size_ptr.i.i47.i700.i, align 4, !noalias !443
  %offset_tbl.i.i51.i704.i = load ptr, ptr %offset_tbl_ptr.i.i48.i701.i, align 8, !noalias !443
  %product.i.i.i52.i705.i = mul i64 %hash_coef.i.i49.i702.i, 4015701072841558310
  %shifted.i.i.i53.i706.i = lshr i64 %product.i.i.i52.i705.i, 32
  %xored.i.i.i54.i707.i = xor i64 %shifted.i.i.i53.i706.i, %product.i.i.i52.i705.i
  %hash.i.i.i55.i708.i = and i64 %xored.i.i.i54.i707.i, %tbl_size.i.i50.i703.i
  %offset_ptr.i.i56.i709.i = getelementptr i32, ptr %offset_tbl.i.i51.i704.i, i64 %hash.i.i.i55.i708.i
  %offset.i.i57.i710.i = load i32, ptr %offset_ptr.i.i56.i709.i, align 4, !noalias !443
  %1036 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1027, 0
  %1037 = insertvalue { ptr, ptr, ptr, i32 } %1036, ptr %1034, 1
  %1038 = insertvalue { ptr, ptr, ptr, i32 } %1037, ptr %1035, 2
  %1039 = insertvalue { ptr, ptr, ptr, i32 } %1038, i32 %offset.i.i57.i710.i, 3
  %1040 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %1041 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1027) #35
  %1042 = sext i32 %offset.i.i57.i710.i to i64
  %1043 = getelementptr ptr, ptr %1027, i64 %1042
  %1044 = getelementptr i8, ptr %1043, i64 64
  %1045 = load ptr, ptr %1044, align 8
  %result.i.i711.i = call ptr %1045({ ptr, ptr, ptr, i32 } %1039, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1046 = call i32 %result.i.i711.i({ ptr, ptr, ptr, i32 } %1039, { ptr, ptr, ptr, i32 } %1039, ptr nonnull align 8 %0) #7
  %1047 = icmp eq i32 %1046, %955
  br i1 %1047, label %._crit_edge.i712.i, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718.i

._crit_edge.i712.i:                               ; preds = %1030
  %1048 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1049 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1027)
  %1050 = getelementptr i8, ptr %1043, i64 48
  %1051 = load ptr, ptr %1050, align 8
  %result.i59.i713.i = call ptr %1051({ ptr, ptr, ptr, i32 } %1039, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1052 = call { ptr, i160 } %result.i59.i713.i({ ptr, ptr, ptr, i32 } %1039, { ptr, ptr, ptr, i32 } %1039, ptr nonnull align 8 %0) #7
  %1053 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1054 = load ptr, ptr %34, align 8
  %1055 = call i1 %1054({ ptr, i160 } %1052, { ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  br i1 %1055, label %1056, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718.i

1056:                                             ; preds = %._crit_edge.i712.i
  %1057 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1058 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1027)
  %1059 = getelementptr i8, ptr %1043, i64 56
  %1060 = load ptr, ptr %1059, align 8
  %result.i60.i715.i = call ptr %1060({ ptr, ptr, ptr, i32 } %1039, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1061 = call { ptr, i160 } %result.i60.i715.i({ ptr, ptr, ptr, i32 } %1039, { ptr, ptr, ptr, i32 } %1039, ptr nonnull align 8 %0) #7
  %.fca.0.extract21.i716.i = extractvalue { ptr, i160 } %1061, 0
  %.fca.1.extract22.i717.i = extractvalue { ptr, i160 } %1061, 1
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718.i

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718.i: ; preds = %1056, %._crit_edge.i712.i, %1030, %1000
  %.reg2mem43.sroa.3.077.i695.i = phi i160 [ %.fca.1.extract22.i717.i, %1056 ], [ poison, %._crit_edge.i712.i ], [ poison, %1000 ], [ poison, %1030 ]
  %1062 = phi ptr [ %.fca.0.extract21.i716.i, %1056 ], [ @nil_typ, %._crit_edge.i712.i ], [ @nil_typ, %1000 ], [ @nil_typ, %1030 ]
  %.reload40.fca.0.insert.i696.i = insertvalue { ptr, i160 } poison, ptr %1062, 0
  %.reload40.fca.1.insert.i697.i = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i696.i, i160 %.reg2mem43.sroa.3.077.i695.i, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1063 = icmp ne ptr %1062, @nil_typ
  %1064 = icmp ne ptr %1062, null
  %.not65.not.not.i.i = and i1 %1063, %1064
  %cond.fr.i.i = freeze i1 %.not65.not.not.i.i
  %spec.select.i.i = select i1 %cond.fr.i.i, ptr %1062, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit.i

CuckooMap_get_keyK.exit.i:                        ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i
  %.pn.i.i = phi { ptr, i160 } [ %997, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i ], [ %.reload40.fca.1.insert.i697.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718.i ]
  %1065 = phi ptr [ %.fca.0.extract21.i.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i ], [ %spec.select.i.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit718.i ]
  %1066 = icmp ne ptr %1065, @nil_typ
  %1067 = icmp ne ptr %1065, null
  %.not143.i = and i1 %1066, %1067
  br i1 %.not143.i, label %._crit_edge3.i, label %._crit_edge4.i

._crit_edge3.i:                                   ; preds = %CuckooMap_get_keyK.exit.i
  %.fca.1.extract..sroa.354.0106.i.i = extractvalue { ptr, i160 } %.pn.i.i, 1
  %.sroa.2.8.extract.trunc.i = trunc i160 %.fca.1.extract..sroa.354.0106.i.i to i32
  %.not147.i = icmp eq i32 %.sroa.2.8.extract.trunc.i, 1000000
  br label %._crit_edge4.i

._crit_edge4.i:                                   ; preds = %._crit_edge3.i, %CuckooMap_get_keyK.exit.i
  %.2.i = phi i1 [ %.not147.i, %._crit_edge3.i ], [ false, %CuckooMap_get_keyK.exit.i ]
  %1068 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1069 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %1070 = load i32, ptr %40, align 4
  %.not148.i = icmp eq i32 %1070, 1000000
  %1071 = select i1 %.not148.i, i1 %.2.i, i1 false
  %1072 = select i1 %1071, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %result.i162.i = call noalias align 32 dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i162.i, align 32
  %1073 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1074 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %1075 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i732.i = call noalias dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(17) %result.i.i732.i, ptr noundef nonnull align 32 dereferenceable(17) %result.i162.i, i64 17, i1 false)
  %1076 = sub i64 %953, %39
  %1077 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %1078 = getelementptr i8, ptr %result.i.i732.i, i64 17
  store i8 0, ptr %1078, align 1
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i732.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i98.i.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98.i.i, align 16
  %result.i.i356.i.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356.i.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i98.i.i, i64 14, i1 false)
  %puts.i.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356.i.i)
  %1079 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 1000000) #17
  %result.i104.i.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104.i.i, align 16
  %result.i.i370.i.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370.i.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i104.i.i, i64 14, i1 false)
  %puts.i294.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370.i.i)
  %1080 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1076) #17
  %result.i110.i.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110.i.i, align 4
  %result.i.i389.i.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i110.i.i, i64 3, i1 false)
  %puts.i314.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i.i)
  %1081 = icmp sgt i64 %1076, 0
  br i1 %1081, label %1082, label %benchmark_insert_sequential.exit

1082:                                             ; preds = %._crit_edge4.i
  %1083 = mul i64 %1076, 1000000
  %1084 = sdiv i64 %1083, 1000000
  br label %benchmark_insert_sequential.exit

benchmark_insert_sequential.exit:                 ; preds = %._crit_edge4.i, %1082
  %.0.i.i = phi i64 [ %1084, %1082 ], [ 0, %._crit_edge4.i ]
  %result.i115.i.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115.i.i, align 16
  %result.i.i408.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408.i.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i115.i.i, i64 15, i1 false)
  %puts.i334.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i.i)
  %1085 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i.i) #17
  %result.i121.i.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121.i.i, align 4
  %result.i.i427.i.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i121.i.i, i64 3, i1 false)
  %puts.i354.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i.i)
  %result.i166.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i166.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1086 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %1087 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i747.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i747.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i166.i, i64 18, i1 false)
  %1088 = getelementptr i8, ptr %result.i.i747.i, i64 18
  store i8 0, ptr %1088, align 1
  %puts.i348.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i747.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1089 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %1091 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i766.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <4 x i8> %1072, ptr %result.i.i766.i, align 1
  %1092 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %1093 = getelementptr i8, ptr %result.i.i766.i, i64 4
  store i8 0, ptr %1093, align 1
  %puts.i368.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i766.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @benchmark_insert_random(i32 noundef 1000000)
  %result.i151.i32 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @_parameterization_Ptri32, ptr %result.i151.i32, align 8
  %1094 = getelementptr inbounds i8, ptr %result.i151.i32, i64 8
  store ptr @_parameterization_Ptri32, ptr %1094, align 8
  %1095 = getelementptr inbounds i8, ptr %result.i151.i32, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %1095, align 8
  %1096 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i151.i32) #39
  %result.i152.i33 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i.i31)
  %result.i153.i34 = call i32 @VirtualProtect(ptr nofree %result.i152.i33, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i31) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i.i31)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i152.i33, ptr noalias nofree noundef nonnull readnone @svlbjxscwh, ptr noalias nofree noundef nonnull readnone @i32_hasher) #39
  %ret.i.i35 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i152.i33) #40
  %1097 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i152.i33) #39
  %result.i154.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i155.i)
  %result.i156.i = call i32 @VirtualProtect(ptr nofree %result.i154.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i155.i) #26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i155.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i154.i, ptr noalias nofree noundef nonnull readnone @krjmirxnlg, ptr noalias nofree noundef nonnull readnone @i32_eq) #39
  %ret.i157.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i154.i) #40
  %1098 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i154.i) #39
  %1099 = getelementptr inbounds i8, ptr %result.i151.i32, i64 48
  store ptr %ret.i.i35, ptr %1099, align 8
  %1100 = getelementptr inbounds i8, ptr %result.i151.i32, i64 56
  store ptr %ret.i157.i, ptr %1100, align 8
  %1101 = getelementptr inbounds i8, ptr %result.i151.i32, i64 40
  store i32 8, ptr %1101, align 8
  %result.i.i261.i = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %1102 = getelementptr inbounds i8, ptr %result.i151.i32, i64 24
  store ptr %result.i.i261.i, ptr %1102, align 8
  %result.i9.i.i36 = call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %1103 = getelementptr inbounds i8, ptr %result.i151.i32, i64 32
  store ptr %result.i9.i.i36, ptr %1103, align 8
  %1104 = getelementptr inbounds i8, ptr %result.i151.i32, i64 44
  %1105 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMap, ptr undef, ptr undef, i32 undef }, ptr %result.i151.i32, 1
  %1106 = insertvalue { ptr, ptr, ptr, i32 } %1105, ptr undef, 2
  %1107 = insertvalue { ptr, ptr, ptr, i32 } %1106, i32 10, 3
  br label %._crit_edge.i37

._crit_edge.i37:                                  ; preds = %CuckooMap_insert_keyK_valueV.exit.i63, %benchmark_insert_sequential.exit
  %.0251.i = phi i32 [ %1108, %CuckooMap_insert_keyK_valueV.exit.i63 ], [ 0, %benchmark_insert_sequential.exit ]
  %1108 = add nuw nsw i32 %.0251.i, 1
  %.sroa.0133.0.insert.ext.i = zext nneg i32 %.0251.i to i160
  %1109 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0133.0.insert.ext.i, 1
  %.sroa.0130.0.insert.ext.i = zext nneg i32 %1108 to i160
  %1110 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0130.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1111 = load ptr, ptr %1099, align 8
  %1112 = call i32 %1111({ ptr, i160 } %1109) #7
  %1113 = load i32, ptr %1101, align 8
  %1114 = add i32 %1113, -1
  %1115 = and i32 %1114, %1112
  %1116 = load ptr, ptr %1102, align 8
  %1117 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1118 = sext i32 %1115 to i64
  %1119 = shl nsw i64 %1118, 5
  %1120 = getelementptr i8, ptr %1116, i64 %1119
  %1121 = load ptr, ptr %1120, align 8
  %1122 = getelementptr i8, ptr %1120, i64 8
  %1123 = icmp ne ptr %1121, @nil_typ
  %1124 = icmp ne ptr %1121, null
  %.not64.i.i38 = and i1 %1123, %1124
  br i1 %.not64.i.i38, label %1125, label %1223

1125:                                             ; preds = %._crit_edge.i37
  %1126 = load i64, ptr %1122, align 4
  %.sroa_idx.i.i159 = getelementptr i8, ptr %1120, i64 16
  %1127 = load i64, ptr %.sroa_idx.i.i159, align 4
  %1128 = inttoptr i64 %1126 to ptr
  %1129 = inttoptr i64 %1127 to ptr
  %hash_coef_ptr.i.i66.i.i160 = getelementptr i8, ptr %1121, i64 8
  %tbl_size_ptr.i.i67.i.i161 = getelementptr i8, ptr %1121, i64 16
  %offset_tbl_ptr.i.i68.i.i162 = getelementptr i8, ptr %1121, i64 40
  %hash_coef.i.i69.i.i163 = load i64, ptr %hash_coef_ptr.i.i66.i.i160, align 4, !noalias !446
  %tbl_size.i.i70.i.i164 = load i64, ptr %tbl_size_ptr.i.i67.i.i161, align 4, !noalias !446
  %offset_tbl.i.i71.i.i165 = load ptr, ptr %offset_tbl_ptr.i.i68.i.i162, align 8, !noalias !446
  %product.i.i.i72.i.i166 = mul i64 %hash_coef.i.i69.i.i163, 4015701072841558310
  %shifted.i.i.i73.i.i167 = lshr i64 %product.i.i.i72.i.i166, 32
  %xored.i.i.i74.i.i168 = xor i64 %shifted.i.i.i73.i.i167, %product.i.i.i72.i.i166
  %hash.i.i.i75.i.i169 = and i64 %xored.i.i.i74.i.i168, %tbl_size.i.i70.i.i164
  %offset_ptr.i.i76.i.i170 = getelementptr i32, ptr %offset_tbl.i.i71.i.i165, i64 %hash.i.i.i75.i.i169
  %offset.i.i77.i.i171 = load i32, ptr %offset_ptr.i.i76.i.i170, align 4, !noalias !446
  %1130 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1121, 0
  %1131 = insertvalue { ptr, ptr, ptr, i32 } %1130, ptr %1128, 1
  %1132 = insertvalue { ptr, ptr, ptr, i32 } %1131, ptr %1129, 2
  %1133 = insertvalue { ptr, ptr, ptr, i32 } %1132, i32 %offset.i.i77.i.i171, 3
  %1134 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %1135 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1121) #35
  %1136 = sext i32 %offset.i.i77.i.i171 to i64
  %1137 = getelementptr ptr, ptr %1121, i64 %1136
  %1138 = getelementptr i8, ptr %1137, i64 64
  %1139 = load ptr, ptr %1138, align 8
  %result.i.i.i172 = call ptr %1139({ ptr, ptr, ptr, i32 } %1133, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1140 = call i32 %result.i.i.i172({ ptr, ptr, ptr, i32 } %1133, { ptr, ptr, ptr, i32 } %1133, ptr nonnull align 8 %0) #7
  %1141 = icmp eq i32 %1140, %1112
  br i1 %1141, label %._crit_edge.i452.i, label %1223

._crit_edge.i452.i:                               ; preds = %1125
  %1142 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1143 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1121)
  %1144 = getelementptr i8, ptr %1137, i64 48
  %1145 = load ptr, ptr %1144, align 8
  %result.i79.i453.i = call ptr %1145({ ptr, ptr, ptr, i32 } %1133, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1146 = call { ptr, i160 } %result.i79.i453.i({ ptr, ptr, ptr, i32 } %1133, { ptr, ptr, ptr, i32 } %1133, ptr nonnull align 8 %0) #7
  %1147 = load ptr, ptr %1100, align 8
  %1148 = call i1 %1147({ ptr, i160 } %1146, { ptr, i160 } %1109) #7
  br i1 %1148, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i173, label %1223

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i173: ; preds = %._crit_edge.i452.i
  %1149 = load ptr, ptr %result.i151.i32, align 8
  %1150 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1151 = load ptr, ptr %1094, align 8
  %1152 = load ptr, ptr %1149, align 8, !alias.scope !449
  %1153 = getelementptr i8, ptr %1152, i64 72
  %1154 = load ptr, ptr %1153, align 8, !alias.scope !449
  %result.i.i.i454.i = call { i64, i64 } %1154(ptr nocapture nofree nonnull readonly %1149) #5, !alias.scope !449
  %1155 = extractvalue { i64, i64 } %result.i.i.i454.i, 0
  %1156 = extractvalue { i64, i64 } %result.i.i.i454.i, 1
  %1157 = urem i64 20, %1156
  %1158 = icmp eq i64 %1157, 0
  %1159 = sub i64 %1156, %1157
  %1160 = select i1 %1158, i64 0, i64 %1159
  %1161 = add i64 %1155, 20
  %1162 = add i64 %1161, %1160
  %1163 = load ptr, ptr %1151, align 8, !alias.scope !449
  %1164 = getelementptr i8, ptr %1163, i64 72
  %1165 = load ptr, ptr %1164, align 8, !alias.scope !449
  %result.i1.i.i455.i = call { i64, i64 } %1165(ptr nocapture nofree nonnull readonly %1151) #5, !alias.scope !449
  %1166 = extractvalue { i64, i64 } %result.i1.i.i455.i, 0
  %1167 = extractvalue { i64, i64 } %result.i1.i.i455.i, 1
  %1168 = call i64 @llvm.umax.i64(i64 %1156, i64 %1167)
  %1169 = call i64 @llvm.umax.i64(i64 %1168, i64 8)
  %1170 = urem i64 %1162, %1167
  %1171 = icmp eq i64 %1170, 0
  %1172 = sub i64 %1167, %1170
  %1173 = select i1 %1171, i64 0, i64 %1172
  %1174 = add i64 %1166, %1162
  %1175 = add i64 %1174, %1173
  %1176 = urem i64 %1175, %1169
  %1177 = icmp eq i64 %1176, 0
  %1178 = sub i64 %1169, %1176
  %1179 = select i1 %1177, i64 0, i64 %1178
  %1180 = add i64 %1179, %1175
  %result.i83.i.i174 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1180, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1149, ptr %result.i83.i.i174, align 8
  %1181 = getelementptr inbounds i8, ptr %result.i83.i.i174, i64 8
  store ptr %1151, ptr %1181, align 8
  %1182 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i.i174)
  %1183 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1184 = load ptr, ptr %1149, align 8
  %1185 = getelementptr i8, ptr %1184, i64 72
  %1186 = load ptr, ptr %1185, align 8
  %result.i.i118.i.i175 = call { i64, i64 } %1186(ptr nocapture nofree nonnull readonly %1149) #5
  %1187 = extractvalue { i64, i64 } %result.i.i118.i.i175, 1
  %1188 = urem i64 20, %1187
  %1189 = icmp eq i64 %1188, 0
  %reass.sub = sub i64 %1187, %1188
  %1190 = add i64 %reass.sub, 20
  %1191 = select i1 %1189, i64 20, i64 %1190
  %1192 = getelementptr i8, ptr %result.i83.i.i174, i64 %1191
  %1193 = getelementptr i8, ptr %1184, i64 64
  %1194 = load ptr, ptr %1193, align 8
  call void %1194({ ptr, i160 } %1109, ptr nocapture nofree nonnull readonly %1149, ptr nocapture nofree writeonly %1192) #1
  %1195 = load ptr, ptr %result.i83.i.i174, align 8
  %1196 = load ptr, ptr %1195, align 8
  %1197 = getelementptr i8, ptr %1196, i64 72
  %1198 = load ptr, ptr %1197, align 8
  %result.i.i119.i.i176 = call { i64, i64 } %1198(ptr nocapture nofree nonnull readonly %1195) #5
  %1199 = extractvalue { i64, i64 } %result.i.i119.i.i176, 0
  %1200 = extractvalue { i64, i64 } %result.i.i119.i.i176, 1
  %1201 = urem i64 20, %1200
  %1202 = icmp eq i64 %1201, 0
  %1203 = sub i64 %1200, %1201
  %1204 = select i1 %1202, i64 0, i64 %1203
  %1205 = add i64 %1199, 20
  %1206 = add i64 %1205, %1204
  %1207 = load ptr, ptr %1181, align 8
  %1208 = load ptr, ptr %1207, align 8
  %1209 = getelementptr i8, ptr %1208, i64 72
  %1210 = load ptr, ptr %1209, align 8
  %result.i1.i120.i.i177 = call { i64, i64 } %1210(ptr nocapture nofree nonnull readonly %1207) #5
  %1211 = extractvalue { i64, i64 } %result.i1.i120.i.i177, 1
  %1212 = urem i64 %1206, %1211
  %1213 = icmp eq i64 %1212, 0
  %1214 = sub i64 %1211, %1212
  %1215 = select i1 %1213, i64 0, i64 %1214
  %1216 = getelementptr i8, ptr %result.i83.i.i174, i64 %1206
  %1217 = getelementptr i8, ptr %1216, i64 %1215
  %1218 = getelementptr i8, ptr %1208, i64 64
  %1219 = load ptr, ptr %1218, align 8
  call void %1219({ ptr, i160 } %1110, ptr nocapture nofree nonnull readonly %1207, ptr nocapture nofree writeonly %1217) #1
  %1220 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1221 = getelementptr inbounds i8, ptr %result.i83.i.i174, i64 16
  store i32 %1112, ptr %1221, align 8
  store ptr @Entry, ptr %1120, align 8
  %1222 = ptrtoint ptr %result.i83.i.i174 to i64
  store i64 %1222, ptr %1122, align 4
  %.sroa_idx28.i.i178 = getelementptr i8, ptr %1120, i64 24
  store i32 10, ptr %.sroa_idx28.i.i178, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %CuckooMap_insert_keyK_valueV.exit.i63

1223:                                             ; preds = %._crit_edge.i452.i, %1125, %._crit_edge.i37
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1224 = add i32 %1112, 2127912214
  %1225 = shl i32 %1112, 12
  %1226 = add i32 %1224, %1225
  %1227 = ashr i32 %1226, 19
  %1228 = xor i32 %1226, %1227
  %1229 = xor i32 %1228, -949894596
  %1230 = add i32 %1229, 374761393
  %1231 = shl i32 %1229, 5
  %1232 = add i32 %1230, %1231
  %1233 = add i32 %1232, -744332180
  %1234 = shl i32 %1232, 9
  %1235 = xor i32 %1233, %1234
  %1236 = add i32 %1235, -42973499
  %1237 = shl i32 %1235, 3
  %1238 = add i32 %1236, %1237
  %1239 = ashr i32 %1238, 16
  %1240 = xor i32 %1238, %1239
  %1241 = xor i32 %1240, -1252372727
  %1242 = load i32, ptr %1101, align 8
  %1243 = add i32 %1242, -1
  %1244 = and i32 %1243, %1241
  %1245 = load ptr, ptr %1103, align 8
  %1246 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1247 = sext i32 %1244 to i64
  %1248 = shl nsw i64 %1247, 5
  %1249 = getelementptr i8, ptr %1245, i64 %1248
  %1250 = load ptr, ptr %1249, align 8
  %1251 = getelementptr i8, ptr %1249, i64 8
  %1252 = icmp ne ptr %1250, @nil_typ
  %1253 = icmp ne ptr %1250, null
  %.not64.i484.i = and i1 %1252, %1253
  br i1 %.not64.i484.i, label %1254, label %1352

1254:                                             ; preds = %1223
  %1255 = load i64, ptr %1251, align 4
  %.sroa_idx.i486.i = getelementptr i8, ptr %1249, i64 16
  %1256 = load i64, ptr %.sroa_idx.i486.i, align 4
  %1257 = inttoptr i64 %1255 to ptr
  %1258 = inttoptr i64 %1256 to ptr
  %hash_coef_ptr.i.i66.i487.i = getelementptr i8, ptr %1250, i64 8
  %tbl_size_ptr.i.i67.i488.i = getelementptr i8, ptr %1250, i64 16
  %offset_tbl_ptr.i.i68.i489.i = getelementptr i8, ptr %1250, i64 40
  %hash_coef.i.i69.i490.i = load i64, ptr %hash_coef_ptr.i.i66.i487.i, align 4, !noalias !452
  %tbl_size.i.i70.i491.i = load i64, ptr %tbl_size_ptr.i.i67.i488.i, align 4, !noalias !452
  %offset_tbl.i.i71.i492.i = load ptr, ptr %offset_tbl_ptr.i.i68.i489.i, align 8, !noalias !452
  %product.i.i.i72.i493.i = mul i64 %hash_coef.i.i69.i490.i, 4015701072841558310
  %shifted.i.i.i73.i494.i = lshr i64 %product.i.i.i72.i493.i, 32
  %xored.i.i.i74.i495.i = xor i64 %shifted.i.i.i73.i494.i, %product.i.i.i72.i493.i
  %hash.i.i.i75.i496.i = and i64 %xored.i.i.i74.i495.i, %tbl_size.i.i70.i491.i
  %offset_ptr.i.i76.i497.i = getelementptr i32, ptr %offset_tbl.i.i71.i492.i, i64 %hash.i.i.i75.i496.i
  %offset.i.i77.i498.i = load i32, ptr %offset_ptr.i.i76.i497.i, align 4, !noalias !452
  %1259 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1250, 0
  %1260 = insertvalue { ptr, ptr, ptr, i32 } %1259, ptr %1257, 1
  %1261 = insertvalue { ptr, ptr, ptr, i32 } %1260, ptr %1258, 2
  %1262 = insertvalue { ptr, ptr, ptr, i32 } %1261, i32 %offset.i.i77.i498.i, 3
  %1263 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %1264 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1250) #35
  %1265 = sext i32 %offset.i.i77.i498.i to i64
  %1266 = getelementptr ptr, ptr %1250, i64 %1265
  %1267 = getelementptr i8, ptr %1266, i64 64
  %1268 = load ptr, ptr %1267, align 8
  %result.i.i499.i = call ptr %1268({ ptr, ptr, ptr, i32 } %1262, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1269 = call i32 %result.i.i499.i({ ptr, ptr, ptr, i32 } %1262, { ptr, ptr, ptr, i32 } %1262, ptr nonnull align 8 %0) #7
  %1270 = icmp eq i32 %1269, %1112
  br i1 %1270, label %._crit_edge.i500.i, label %1352

._crit_edge.i500.i:                               ; preds = %1254
  %1271 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1272 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %1250)
  %1273 = getelementptr i8, ptr %1266, i64 48
  %1274 = load ptr, ptr %1273, align 8
  %result.i79.i501.i = call ptr %1274({ ptr, ptr, ptr, i32 } %1262, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1275 = call { ptr, i160 } %result.i79.i501.i({ ptr, ptr, ptr, i32 } %1262, { ptr, ptr, ptr, i32 } %1262, ptr nonnull align 8 %0) #7
  %1276 = load ptr, ptr %1100, align 8
  %1277 = call i1 %1276({ ptr, i160 } %1275, { ptr, i160 } %1109) #7
  br i1 %1277, label %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit513.i, label %1352

CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit513.i: ; preds = %._crit_edge.i500.i
  %1278 = load ptr, ptr %result.i151.i32, align 8
  %1279 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1280 = load ptr, ptr %1094, align 8
  %1281 = load ptr, ptr %1278, align 8, !alias.scope !455
  %1282 = getelementptr i8, ptr %1281, i64 72
  %1283 = load ptr, ptr %1282, align 8, !alias.scope !455
  %result.i.i.i505.i = call { i64, i64 } %1283(ptr nocapture nofree nonnull readonly %1278) #5, !alias.scope !455
  %1284 = extractvalue { i64, i64 } %result.i.i.i505.i, 0
  %1285 = extractvalue { i64, i64 } %result.i.i.i505.i, 1
  %1286 = urem i64 20, %1285
  %1287 = icmp eq i64 %1286, 0
  %1288 = sub i64 %1285, %1286
  %1289 = select i1 %1287, i64 0, i64 %1288
  %1290 = add i64 %1284, 20
  %1291 = add i64 %1290, %1289
  %1292 = load ptr, ptr %1280, align 8, !alias.scope !455
  %1293 = getelementptr i8, ptr %1292, i64 72
  %1294 = load ptr, ptr %1293, align 8, !alias.scope !455
  %result.i1.i.i506.i = call { i64, i64 } %1294(ptr nocapture nofree nonnull readonly %1280) #5, !alias.scope !455
  %1295 = extractvalue { i64, i64 } %result.i1.i.i506.i, 0
  %1296 = extractvalue { i64, i64 } %result.i1.i.i506.i, 1
  %1297 = call i64 @llvm.umax.i64(i64 %1285, i64 %1296)
  %1298 = call i64 @llvm.umax.i64(i64 %1297, i64 8)
  %1299 = urem i64 %1291, %1296
  %1300 = icmp eq i64 %1299, 0
  %1301 = sub i64 %1296, %1299
  %1302 = select i1 %1300, i64 0, i64 %1301
  %1303 = add i64 %1295, %1291
  %1304 = add i64 %1303, %1302
  %1305 = urem i64 %1304, %1298
  %1306 = icmp eq i64 %1305, 0
  %1307 = sub i64 %1298, %1305
  %1308 = select i1 %1306, i64 0, i64 %1307
  %1309 = add i64 %1308, %1304
  %result.i83.i507.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1309, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1278, ptr %result.i83.i507.i, align 8
  %1310 = getelementptr inbounds i8, ptr %result.i83.i507.i, i64 8
  store ptr %1280, ptr %1310, align 8
  %1311 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83.i507.i)
  %1312 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1313 = load ptr, ptr %1278, align 8
  %1314 = getelementptr i8, ptr %1313, i64 72
  %1315 = load ptr, ptr %1314, align 8
  %result.i.i118.i508.i = call { i64, i64 } %1315(ptr nocapture nofree nonnull readonly %1278) #5
  %1316 = extractvalue { i64, i64 } %result.i.i118.i508.i, 1
  %1317 = urem i64 20, %1316
  %1318 = icmp eq i64 %1317, 0
  %reass.sub312 = sub i64 %1316, %1317
  %1319 = add i64 %reass.sub312, 20
  %1320 = select i1 %1318, i64 20, i64 %1319
  %1321 = getelementptr i8, ptr %result.i83.i507.i, i64 %1320
  %1322 = getelementptr i8, ptr %1313, i64 64
  %1323 = load ptr, ptr %1322, align 8
  call void %1323({ ptr, i160 } %1109, ptr nocapture nofree nonnull readonly %1278, ptr nocapture nofree writeonly %1321) #1
  %1324 = load ptr, ptr %result.i83.i507.i, align 8
  %1325 = load ptr, ptr %1324, align 8
  %1326 = getelementptr i8, ptr %1325, i64 72
  %1327 = load ptr, ptr %1326, align 8
  %result.i.i119.i510.i = call { i64, i64 } %1327(ptr nocapture nofree nonnull readonly %1324) #5
  %1328 = extractvalue { i64, i64 } %result.i.i119.i510.i, 0
  %1329 = extractvalue { i64, i64 } %result.i.i119.i510.i, 1
  %1330 = urem i64 20, %1329
  %1331 = icmp eq i64 %1330, 0
  %1332 = sub i64 %1329, %1330
  %1333 = select i1 %1331, i64 0, i64 %1332
  %1334 = add i64 %1328, 20
  %1335 = add i64 %1334, %1333
  %1336 = load ptr, ptr %1310, align 8
  %1337 = load ptr, ptr %1336, align 8
  %1338 = getelementptr i8, ptr %1337, i64 72
  %1339 = load ptr, ptr %1338, align 8
  %result.i1.i120.i511.i = call { i64, i64 } %1339(ptr nocapture nofree nonnull readonly %1336) #5
  %1340 = extractvalue { i64, i64 } %result.i1.i120.i511.i, 1
  %1341 = urem i64 %1335, %1340
  %1342 = icmp eq i64 %1341, 0
  %1343 = sub i64 %1340, %1341
  %1344 = select i1 %1342, i64 0, i64 %1343
  %1345 = getelementptr i8, ptr %result.i83.i507.i, i64 %1335
  %1346 = getelementptr i8, ptr %1345, i64 %1344
  %1347 = getelementptr i8, ptr %1337, i64 64
  %1348 = load ptr, ptr %1347, align 8
  call void %1348({ ptr, i160 } %1110, ptr nocapture nofree nonnull readonly %1336, ptr nocapture nofree writeonly %1346) #1
  %1349 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1350 = getelementptr inbounds i8, ptr %result.i83.i507.i, i64 16
  store i32 %1112, ptr %1350, align 8
  store ptr @Entry, ptr %1249, align 8
  %1351 = ptrtoint ptr %result.i83.i507.i to i64
  store i64 %1351, ptr %1251, align 4
  %.sroa_idx28.i512.i = getelementptr i8, ptr %1249, i64 24
  store i32 10, ptr %.sroa_idx28.i512.i, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %CuckooMap_insert_keyK_valueV.exit.i63

1352:                                             ; preds = %._crit_edge.i500.i, %1254, %1223
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1353 = load i32, ptr %1104, align 4
  %1354 = load i32, ptr %1101, align 8
  %.not.i.i39 = icmp slt i32 %1353, %1354
  br i1 %.not.i.i39, label %._crit_edge.i.i42, label %1355

1355:                                             ; preds = %1352
  %1356 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1357 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1358 = load ptr, ptr %1102, align 8
  %1359 = load ptr, ptr %1103, align 8
  %1360 = shl i32 %1354, 1
  %spec.select.i528.i = call i32 @llvm.smax.i32(i32 %1360, i32 16)
  store i32 %spec.select.i528.i, ptr %1101, align 8
  %1361 = zext nneg i32 %spec.select.i528.i to i64
  %1362 = shl nuw nsw i64 %1361, 5
  %result.i.i529.i = call noalias ptr @bump_malloc_inner(i64 noundef %1362, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i529.i, ptr %1102, align 8
  %result.i20.i.i40 = call noalias ptr @bump_malloc_inner(i64 noundef %1362, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i.i40, ptr %1103, align 8
  store i32 0, ptr %1104, align 4
  %1363 = icmp sgt i32 %1354, 0
  br i1 %1363, label %.lr.ph.i.i142, label %._crit_edge.i.i42

.lr.ph.i.i142:                                    ; preds = %1355, %._crit_edge.i869.i
  %.060.i.i143 = phi i32 [ %1382, %._crit_edge.i869.i ], [ 0, %1355 ]
  %1364 = zext nneg i32 %.060.i.i143 to i64
  %1365 = shl nuw nsw i64 %1364, 5
  %1366 = getelementptr i8, ptr %1358, i64 %1365
  %1367 = load ptr, ptr %1366, align 8
  %1368 = icmp ne ptr %1367, @nil_typ
  %1369 = icmp ne ptr %1367, null
  %.not16.i.i144 = and i1 %1368, %1369
  br i1 %.not16.i.i144, label %1370, label %._crit_edge.i869.i

1370:                                             ; preds = %.lr.ph.i.i142
  %1371 = getelementptr i8, ptr %1366, i64 8
  %1372 = load i64, ptr %1371, align 4
  %.sroa_idx.i870.i = getelementptr i8, ptr %1366, i64 16
  %1373 = load i64, ptr %.sroa_idx.i870.i, align 4
  %1374 = inttoptr i64 %1372 to ptr
  %1375 = inttoptr i64 %1373 to ptr
  %hash_coef_ptr.i.i18.i.i146 = getelementptr i8, ptr %1367, i64 8
  %tbl_size_ptr.i.i19.i.i147 = getelementptr i8, ptr %1367, i64 16
  %offset_tbl_ptr.i.i20.i.i148 = getelementptr i8, ptr %1367, i64 40
  %hash_coef.i.i21.i.i149 = load i64, ptr %hash_coef_ptr.i.i18.i.i146, align 4, !noalias !22
  %tbl_size.i.i22.i.i150 = load i64, ptr %tbl_size_ptr.i.i19.i.i147, align 4, !noalias !22
  %offset_tbl.i.i23.i.i151 = load ptr, ptr %offset_tbl_ptr.i.i20.i.i148, align 8, !noalias !22
  %product.i.i.i24.i.i152 = mul i64 %hash_coef.i.i21.i.i149, 4015701072841558310
  %shifted.i.i.i25.i.i153 = lshr i64 %product.i.i.i24.i.i152, 32
  %xored.i.i.i26.i.i154 = xor i64 %shifted.i.i.i25.i.i153, %product.i.i.i24.i.i152
  %hash.i.i.i27.i.i155 = and i64 %xored.i.i.i26.i.i154, %tbl_size.i.i22.i.i150
  %offset_ptr.i.i28.i.i156 = getelementptr i32, ptr %offset_tbl.i.i23.i.i151, i64 %hash.i.i.i27.i.i155
  %offset.i.i43.i.i157 = load i32, ptr %offset_ptr.i.i28.i.i156, align 4, !noalias !458
  %1376 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1367, 0
  %1377 = insertvalue { ptr, ptr, ptr, i32 } %1376, ptr %1374, 1
  %1378 = insertvalue { ptr, ptr, ptr, i32 } %1377, ptr %1375, 2
  %1379 = insertvalue { ptr, ptr, ptr, i32 } %1378, i32 %offset.i.i43.i.i157, 3
  %1380 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %1381 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %1107, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %1379) #7
  br label %._crit_edge.i869.i

._crit_edge.i869.i:                               ; preds = %1370, %.lr.ph.i.i142
  %1382 = add nuw nsw i32 %.060.i.i143, 1
  %1383 = icmp slt i32 %1382, %1354
  br i1 %1383, label %.lr.ph.i.i142, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145: ; preds = %._crit_edge.i869.i, %._crit_edge.i888.i
  %.060.i886.i = phi i32 [ %1402, %._crit_edge.i888.i ], [ 0, %._crit_edge.i869.i ]
  %1384 = zext nneg i32 %.060.i886.i to i64
  %1385 = shl nuw nsw i64 %1384, 5
  %1386 = getelementptr i8, ptr %1359, i64 %1385
  %1387 = load ptr, ptr %1386, align 8
  %1388 = icmp ne ptr %1387, @nil_typ
  %1389 = icmp ne ptr %1387, null
  %.not16.i887.i = and i1 %1388, %1389
  br i1 %.not16.i887.i, label %1390, label %._crit_edge.i888.i

1390:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145
  %1391 = getelementptr i8, ptr %1386, i64 8
  %1392 = load i64, ptr %1391, align 4
  %.sroa_idx.i889.i = getelementptr i8, ptr %1386, i64 16
  %1393 = load i64, ptr %.sroa_idx.i889.i, align 4
  %1394 = inttoptr i64 %1392 to ptr
  %1395 = inttoptr i64 %1393 to ptr
  %hash_coef_ptr.i.i18.i890.i = getelementptr i8, ptr %1387, i64 8
  %tbl_size_ptr.i.i19.i891.i = getelementptr i8, ptr %1387, i64 16
  %offset_tbl_ptr.i.i20.i892.i = getelementptr i8, ptr %1387, i64 40
  %hash_coef.i.i21.i893.i = load i64, ptr %hash_coef_ptr.i.i18.i890.i, align 4, !noalias !22
  %tbl_size.i.i22.i894.i = load i64, ptr %tbl_size_ptr.i.i19.i891.i, align 4, !noalias !22
  %offset_tbl.i.i23.i895.i = load ptr, ptr %offset_tbl_ptr.i.i20.i892.i, align 8, !noalias !22
  %product.i.i.i24.i896.i = mul i64 %hash_coef.i.i21.i893.i, 4015701072841558310
  %shifted.i.i.i25.i897.i = lshr i64 %product.i.i.i24.i896.i, 32
  %xored.i.i.i26.i898.i = xor i64 %shifted.i.i.i25.i897.i, %product.i.i.i24.i896.i
  %hash.i.i.i27.i899.i = and i64 %xored.i.i.i26.i898.i, %tbl_size.i.i22.i894.i
  %offset_ptr.i.i28.i900.i = getelementptr i32, ptr %offset_tbl.i.i23.i895.i, i64 %hash.i.i.i27.i899.i
  %offset.i.i43.i901.i = load i32, ptr %offset_ptr.i.i28.i900.i, align 4, !noalias !461
  %1396 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1387, 0
  %1397 = insertvalue { ptr, ptr, ptr, i32 } %1396, ptr %1394, 1
  %1398 = insertvalue { ptr, ptr, ptr, i32 } %1397, ptr %1395, 2
  %1399 = insertvalue { ptr, ptr, ptr, i32 } %1398, i32 %offset.i.i43.i901.i, 3
  %1400 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  %1401 = call { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %1107, { ptr, ptr, ptr, i32 } poison, ptr nonnull align 8 poison, { ptr, ptr, ptr, i32 } %1399) #7
  br label %._crit_edge.i888.i

._crit_edge.i888.i:                               ; preds = %1390, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145
  %1402 = add nuw nsw i32 %.060.i886.i, 1
  %1403 = icmp slt i32 %1402, %1354
  br i1 %1403, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit.i145, label %._crit_edge.i.i42

._crit_edge.i.i42:                                ; preds = %._crit_edge.i888.i, %1355, %1352
  %1404 = load ptr, ptr %result.i151.i32, align 8
  %1405 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1406 = load ptr, ptr %1094, align 8
  %1407 = load ptr, ptr %1404, align 8
  %1408 = getelementptr i8, ptr %1407, i64 72
  %1409 = load ptr, ptr %1408, align 8
  %result.i.i.i.i43 = call { i64, i64 } %1409(ptr nocapture nofree nonnull readonly %1404) #5
  %1410 = extractvalue { i64, i64 } %result.i.i.i.i43, 0
  %1411 = extractvalue { i64, i64 } %result.i.i.i.i43, 1
  %1412 = urem i64 20, %1411
  %1413 = icmp eq i64 %1412, 0
  %1414 = sub i64 %1411, %1412
  %1415 = select i1 %1413, i64 0, i64 %1414
  %1416 = add i64 %1410, 20
  %1417 = add i64 %1416, %1415
  %1418 = load ptr, ptr %1406, align 8
  %1419 = getelementptr i8, ptr %1418, i64 72
  %1420 = load ptr, ptr %1419, align 8
  %result.i1.i.i.i44 = call { i64, i64 } %1420(ptr nocapture nofree nonnull readonly %1406) #5
  %1421 = extractvalue { i64, i64 } %result.i1.i.i.i44, 0
  %1422 = extractvalue { i64, i64 } %result.i1.i.i.i44, 1
  %1423 = call i64 @llvm.umax.i64(i64 %1411, i64 %1422)
  %1424 = call i64 @llvm.umax.i64(i64 %1423, i64 8)
  %1425 = urem i64 %1417, %1422
  %1426 = icmp eq i64 %1425, 0
  %1427 = sub i64 %1422, %1425
  %1428 = select i1 %1426, i64 0, i64 %1427
  %1429 = add i64 %1421, %1417
  %1430 = add i64 %1429, %1428
  %1431 = urem i64 %1430, %1424
  %1432 = icmp eq i64 %1431, 0
  %1433 = sub i64 %1424, %1431
  %1434 = select i1 %1432, i64 0, i64 %1433
  %1435 = add i64 %1434, %1430
  %result.i90.i.i45 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1435, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %1404, ptr %result.i90.i.i45, align 8
  %1436 = getelementptr inbounds i8, ptr %result.i90.i.i45, i64 8
  store ptr %1406, ptr %1436, align 8
  %1437 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90.i.i45)
  %1438 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1439 = load ptr, ptr %1404, align 8
  %1440 = getelementptr i8, ptr %1439, i64 72
  %1441 = load ptr, ptr %1440, align 8
  %result.i.i196.i.i46 = call { i64, i64 } %1441(ptr nocapture nofree nonnull readonly %1404) #5
  %1442 = extractvalue { i64, i64 } %result.i.i196.i.i46, 1
  %1443 = urem i64 20, %1442
  %1444 = icmp eq i64 %1443, 0
  %reass.sub311 = sub i64 %1442, %1443
  %1445 = add i64 %reass.sub311, 20
  %1446 = select i1 %1444, i64 20, i64 %1445
  %1447 = getelementptr i8, ptr %result.i90.i.i45, i64 %1446
  %1448 = getelementptr i8, ptr %1439, i64 64
  %1449 = load ptr, ptr %1448, align 8
  call void %1449({ ptr, i160 } %1109, ptr nocapture nofree nonnull readonly %1404, ptr nocapture nofree writeonly %1447) #1
  %1450 = load ptr, ptr %result.i90.i.i45, align 8
  %1451 = load ptr, ptr %1450, align 8
  %1452 = getelementptr i8, ptr %1451, i64 72
  %1453 = load ptr, ptr %1452, align 8
  %result.i.i197.i.i48 = call { i64, i64 } %1453(ptr nocapture nofree nonnull readonly %1450) #5
  %1454 = extractvalue { i64, i64 } %result.i.i197.i.i48, 0
  %1455 = extractvalue { i64, i64 } %result.i.i197.i.i48, 1
  %1456 = urem i64 20, %1455
  %1457 = icmp eq i64 %1456, 0
  %1458 = sub i64 %1455, %1456
  %1459 = select i1 %1457, i64 0, i64 %1458
  %1460 = add i64 %1454, 20
  %1461 = add i64 %1460, %1459
  %1462 = load ptr, ptr %1436, align 8
  %1463 = load ptr, ptr %1462, align 8
  %1464 = getelementptr i8, ptr %1463, i64 72
  %1465 = load ptr, ptr %1464, align 8
  %result.i1.i198.i.i49 = call { i64, i64 } %1465(ptr nocapture nofree nonnull readonly %1462) #5
  %1466 = extractvalue { i64, i64 } %result.i1.i198.i.i49, 1
  %1467 = urem i64 %1461, %1466
  %1468 = icmp eq i64 %1467, 0
  %1469 = sub i64 %1466, %1467
  %1470 = select i1 %1468, i64 0, i64 %1469
  %1471 = getelementptr i8, ptr %result.i90.i.i45, i64 %1461
  %1472 = getelementptr i8, ptr %1471, i64 %1470
  %1473 = getelementptr i8, ptr %1463, i64 64
  %1474 = load ptr, ptr %1473, align 8
  call void %1474({ ptr, i160 } %1110, ptr nocapture nofree nonnull readonly %1462, ptr nocapture nofree writeonly %1472) #1
  %1475 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %1476 = getelementptr inbounds i8, ptr %result.i90.i.i45, i64 16
  store i32 %1112, ptr %1476, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  %1477 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1478 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1479 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1480

1480:                                             ; preds = %.cont.cont.i.i108, %._crit_edge.i.i42
  %.0566.i.i50 = phi i32 [ 0, %._crit_edge.i.i42 ], [ %1481, %.cont.cont.i.i108 ]
  %.070565.i.i51 = phi i1 [ true, %._crit_edge.i.i42 ], [ %1547, %.cont.cont.i.i108 ]
  %.sroa.0.0564.i.i52 = phi ptr [ @Entry, %._crit_edge.i.i42 ], [ %vptr.i142.sroa.speculated.i.i111, %.cont.cont.i.i108 ]
  %.sroa.6.0563.i.i53 = phi ptr [ %result.i90.i.i45, %._crit_edge.i.i42 ], [ %spec.select539.i.i112, %.cont.cont.i.i108 ]
  %.sroa.12.0562.i.i54 = phi ptr [ undef, %._crit_edge.i.i42 ], [ %spec.select.i546.i, %.cont.cont.i.i108 ]
  %.sroa.17.0561.i.i55 = phi i32 [ 10, %._crit_edge.i.i42 ], [ %offset.i.i154.i.i124, %.cont.cont.i.i108 ]
  %1481 = add nuw nsw i32 %.0566.i.i50, 1
  %1482 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i.i52, 0
  %1483 = insertvalue { ptr, ptr, ptr, i32 } %1482, ptr %.sroa.6.0563.i.i53, 1
  %1484 = insertvalue { ptr, ptr, ptr, i32 } %1483, ptr %.sroa.12.0562.i.i54, 2
  %1485 = insertvalue { ptr, ptr, ptr, i32 } %1484, i32 %.sroa.17.0561.i.i55, 3
  %1486 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i.i52)
  %1487 = sext i32 %.sroa.17.0561.i.i55 to i64
  %1488 = getelementptr ptr, ptr %.sroa.0.0564.i.i52, i64 %1487
  %1489 = getelementptr i8, ptr %1488, i64 64
  %1490 = load ptr, ptr %1489, align 8
  %result.i125.i544.i = call ptr %1490({ ptr, ptr, ptr, i32 } %1485, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1491 = call i32 %result.i125.i544.i({ ptr, ptr, ptr, i32 } %1485, { ptr, ptr, ptr, i32 } %1485, ptr nonnull align 8 %0) #7
  %1492 = ptrtoint ptr %.sroa.6.0563.i.i53 to i64
  %1493 = ptrtoint ptr %.sroa.12.0562.i.i54 to i64
  br i1 %.070565.i.i51, label %1494, label %1510

1494:                                             ; preds = %1480
  %1495 = load i32, ptr %1101, align 8
  %1496 = add i32 %1495, -1
  %1497 = and i32 %1496, %1491
  %1498 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1499 = load ptr, ptr %1102, align 8
  %1500 = sext i32 %1497 to i64
  %1501 = shl nsw i64 %1500, 5
  %1502 = getelementptr i8, ptr %1499, i64 %1501
  %1503 = load ptr, ptr %1502, align 8
  %1504 = getelementptr i8, ptr %1502, i64 8
  %1505 = load i160, ptr %1504, align 4
  store ptr %.sroa.0.0564.i.i52, ptr %1502, align 8
  store i64 %1492, ptr %1504, align 4
  %.sroa_idx157.i.i136 = getelementptr i8, ptr %1502, i64 16
  store i64 %1493, ptr %.sroa_idx157.i.i136, align 4
  %.sroa_idx158.i.i137 = getelementptr i8, ptr %1502, i64 24
  store i32 %.sroa.17.0561.i.i55, ptr %.sroa_idx158.i.i137, align 4
  %1506 = icmp ne ptr %1503, @nil_typ
  %1507 = icmp ne ptr %1503, null
  %.not92.i.i138 = and i1 %1506, %1507
  %extract.i.i140 = lshr i160 %1505, 64
  %1508 = insertelement <2 x i160> poison, i160 %1505, i64 0
  %1509 = insertelement <2 x i160> %1508, i160 %extract.i.i140, i64 1
  br i1 %.not92.i.i138, label %.cont.cont.i.i108, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i62

1510:                                             ; preds = %1480
  %1511 = add i32 %1491, 2127912214
  %1512 = shl i32 %1491, 12
  %1513 = add i32 %1511, %1512
  %1514 = ashr i32 %1513, 19
  %1515 = xor i32 %1513, %1514
  %1516 = xor i32 %1515, -949894596
  %1517 = add i32 %1516, 374761393
  %1518 = shl i32 %1516, 5
  %1519 = add i32 %1517, %1518
  %1520 = add i32 %1519, -744332180
  %1521 = shl i32 %1519, 9
  %1522 = xor i32 %1520, %1521
  %1523 = add i32 %1522, -42973499
  %1524 = shl i32 %1522, 3
  %1525 = add i32 %1523, %1524
  %1526 = ashr i32 %1525, 16
  %1527 = xor i32 %1525, %1526
  %1528 = xor i32 %1527, -1252372727
  %1529 = load i32, ptr %1101, align 8
  %1530 = add i32 %1529, -1
  %1531 = and i32 %1530, %1528
  %1532 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1533 = load ptr, ptr %1103, align 8
  %1534 = sext i32 %1531 to i64
  %1535 = shl nsw i64 %1534, 5
  %1536 = getelementptr i8, ptr %1533, i64 %1535
  %1537 = load ptr, ptr %1536, align 8
  %1538 = getelementptr i8, ptr %1536, i64 8
  %1539 = load i160, ptr %1538, align 4
  store ptr %.sroa.0.0564.i.i52, ptr %1536, align 8
  store i64 %1492, ptr %1538, align 4
  %.sroa_idx161.i.i56 = getelementptr i8, ptr %1536, i64 16
  store i64 %1493, ptr %.sroa_idx161.i.i56, align 4
  %.sroa_idx162.i.i57 = getelementptr i8, ptr %1536, i64 24
  store i32 %.sroa.17.0561.i.i55, ptr %.sroa_idx162.i.i57, align 4
  %1540 = icmp ne ptr %1537, @nil_typ
  %1541 = icmp ne ptr %1537, null
  %.not90.i.i58 = and i1 %1540, %1541
  %extract607.i.i60 = lshr i160 %1539, 64
  %1542 = insertelement <2 x i160> poison, i160 %1539, i64 0
  %1543 = insertelement <2 x i160> %1542, i160 %extract607.i.i60, i64 1
  br i1 %.not90.i.i58, label %.cont.cont.i.i108, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i62

.cont.cont.i.i108:                                ; preds = %1510, %1494
  %vptr.i142.sroa.speculated.i.i111 = phi ptr [ %1503, %1494 ], [ %1537, %1510 ]
  %.in318 = phi <2 x i160> [ %1509, %1494 ], [ %1543, %1510 ]
  %1544 = trunc <2 x i160> %.in318 to <2 x i64>
  %1545 = extractelement <2 x i64> %1544, i64 1
  %spec.select.i546.i = inttoptr i64 %1545 to ptr
  %1546 = extractelement <2 x i64> %1544, i64 0
  %spec.select539.i.i112 = inttoptr i64 %1546 to ptr
  %1547 = xor i1 %.070565.i.i51, true
  %hash_coef_ptr.i.i143.i.i113 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i111, i64 8
  %tbl_size_ptr.i.i144.i.i114 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i111, i64 16
  %offset_tbl_ptr.i.i145.i.i115 = getelementptr i8, ptr %vptr.i142.sroa.speculated.i.i111, i64 40
  %hash_coef.i.i146.i.i116 = load i64, ptr %hash_coef_ptr.i.i143.i.i113, align 4
  %tbl_size.i.i147.i.i117 = load i64, ptr %tbl_size_ptr.i.i144.i.i114, align 4
  %offset_tbl.i.i148.i.i118 = load ptr, ptr %offset_tbl_ptr.i.i145.i.i115, align 8
  %product.i.i.i149.i.i119 = mul i64 %hash_coef.i.i146.i.i116, 4015701072841558310
  %shifted.i.i.i150.i.i120 = lshr i64 %product.i.i.i149.i.i119, 32
  %xored.i.i.i151.i.i121 = xor i64 %shifted.i.i.i150.i.i120, %product.i.i.i149.i.i119
  %hash.i.i.i152.i.i122 = and i64 %xored.i.i.i151.i.i121, %tbl_size.i.i147.i.i117
  %offset_ptr.i.i153.i.i123 = getelementptr i32, ptr %offset_tbl.i.i148.i.i118, i64 %hash.i.i.i152.i.i122
  %offset.i.i154.i.i124 = load i32, ptr %offset_ptr.i.i153.i.i123, align 4
  %1548 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1550 = icmp ult i32 %.0566.i.i50, 99
  br i1 %1550, label %1480, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i125

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i62: ; preds = %1510, %1494
  %1551 = phi ptr [ %12, %1510 ], [ %11, %1494 ]
  %1552 = load i32, ptr %1104, align 4
  store i32 %1552, ptr %1551, align 4
  %1553 = add i32 %1552, 1
  %1554 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1553, ptr %1104, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  br label %CuckooMap_insert_keyK_valueV.exit.i63

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i125: ; preds = %.cont.cont.i.i108
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  %1555 = icmp eq ptr %vptr.i142.sroa.speculated.i.i111, null
  br i1 %1555, label %CuckooMap_insert_keyK_valueV.exit.i63, label %1556

1556:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i125
  %1557 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1558 = load ptr, ptr %1102, align 8
  %1559 = load ptr, ptr %1103, align 8
  %1560 = load i32, ptr %1101, align 8
  %1561 = shl i32 %1560, 1
  %spec.select.i563.i = call i32 @llvm.smax.i32(i32 %1561, i32 16)
  store i32 %spec.select.i563.i, ptr %1101, align 8
  %1562 = zext nneg i32 %spec.select.i563.i to i64
  %1563 = shl nuw nsw i64 %1562, 5
  %result.i.i564.i = call noalias ptr @bump_malloc_inner(i64 noundef %1563, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i564.i, ptr %1102, align 8
  %result.i20.i565.i = call noalias ptr @bump_malloc_inner(i64 noundef %1563, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i565.i, ptr %1103, align 8
  store i32 0, ptr %1104, align 4
  %1564 = icmp sgt i32 %1560, 0
  br i1 %1564, label %.lr.ph.i935.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i

.lr.ph.i935.i:                                    ; preds = %1556, %._crit_edge.i950.i
  %.060.i948.i = phi i32 [ %1653, %._crit_edge.i950.i ], [ 0, %1556 ]
  %1565 = zext nneg i32 %.060.i948.i to i64
  %1566 = shl nuw nsw i64 %1565, 5
  %1567 = getelementptr i8, ptr %1558, i64 %1566
  %1568 = load ptr, ptr %1567, align 8
  %1569 = icmp ne ptr %1568, @nil_typ
  %1570 = icmp ne ptr %1568, null
  %.not16.i949.i = and i1 %1569, %1570
  br i1 %.not16.i949.i, label %1571, label %._crit_edge.i950.i

1571:                                             ; preds = %.lr.ph.i935.i
  %1572 = getelementptr i8, ptr %1567, i64 8
  %1573 = load <2 x i64>, ptr %1572, align 4
  %hash_coef_ptr.i.i18.i952.i = getelementptr i8, ptr %1568, i64 8
  %tbl_size_ptr.i.i19.i953.i = getelementptr i8, ptr %1568, i64 16
  %offset_tbl_ptr.i.i20.i954.i = getelementptr i8, ptr %1568, i64 40
  %1574 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  %hash_coef.i.i99.i.i126 = load i64, ptr %hash_coef_ptr.i.i18.i952.i, align 4, !noalias !22
  %tbl_size.i.i100.i.i127 = load i64, ptr %tbl_size_ptr.i.i19.i953.i, align 4, !noalias !22
  %offset_tbl.i.i101.i.i128 = load ptr, ptr %offset_tbl_ptr.i.i20.i954.i, align 8, !noalias !22
  %product.i.i.i102.i.i129 = mul i64 %hash_coef.i.i99.i.i126, 4015701072841558310
  %shifted.i.i.i103.i.i130 = lshr i64 %product.i.i.i102.i.i129, 32
  %xored.i.i.i104.i.i131 = xor i64 %shifted.i.i.i103.i.i130, %product.i.i.i102.i.i129
  %hash.i.i.i105.i.i132 = and i64 %xored.i.i.i104.i.i131, %tbl_size.i.i100.i.i127
  %offset_ptr.i.i106.i.i133 = getelementptr i32, ptr %offset_tbl.i.i101.i.i128, i64 %hash.i.i.i105.i.i132
  %offset.i.i121.i.i134 = load i32, ptr %offset_ptr.i.i106.i.i133, align 4, !noalias !464
  %1575 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1576 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1577 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1578

1578:                                             ; preds = %.cont.cont.i1127.i, %1571
  %.0566.i1115.i = phi i32 [ 0, %1571 ], [ %1582, %.cont.cont.i1127.i ]
  %.070565.i1116.i = phi i1 [ true, %1571 ], [ %1644, %.cont.cont.i1127.i ]
  %.sroa.0.0564.i1117.i = phi ptr [ %1568, %1571 ], [ %vptr.i142.sroa.speculated.i1130.i, %.cont.cont.i1127.i ]
  %.sroa.17.0561.i1120.i = phi i32 [ %offset.i.i121.i.i134, %1571 ], [ %offset.i.i154.i1144.i, %.cont.cont.i1127.i ]
  %1579 = phi <2 x i64> [ %1573, %1571 ], [ %1643, %.cont.cont.i1127.i ]
  %1580 = extractelement <2 x i64> %1579, i64 1
  %.sroa.12.0562.i1119.i = inttoptr i64 %1580 to ptr
  %1581 = extractelement <2 x i64> %1579, i64 0
  %.sroa.6.0563.i1118.i = inttoptr i64 %1581 to ptr
  %1582 = add nuw nsw i32 %.0566.i1115.i, 1
  %1583 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1117.i, 0
  %1584 = insertvalue { ptr, ptr, ptr, i32 } %1583, ptr %.sroa.6.0563.i1118.i, 1
  %1585 = insertvalue { ptr, ptr, ptr, i32 } %1584, ptr %.sroa.12.0562.i1119.i, 2
  %1586 = insertvalue { ptr, ptr, ptr, i32 } %1585, i32 %.sroa.17.0561.i1120.i, 3
  %1587 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1117.i)
  %1588 = sext i32 %.sroa.17.0561.i1120.i to i64
  %1589 = getelementptr ptr, ptr %.sroa.0.0564.i1117.i, i64 %1588
  %1590 = getelementptr i8, ptr %1589, i64 64
  %1591 = load ptr, ptr %1590, align 8
  %result.i125.i.i135 = call ptr %1591({ ptr, ptr, ptr, i32 } %1586, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1592 = call i32 %result.i125.i.i135({ ptr, ptr, ptr, i32 } %1586, { ptr, ptr, ptr, i32 } %1586, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1116.i, label %1593, label %1609

1593:                                             ; preds = %1578
  %1594 = load i32, ptr %1101, align 8
  %1595 = add i32 %1594, -1
  %1596 = and i32 %1595, %1592
  %1597 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1598 = load ptr, ptr %1102, align 8
  %1599 = sext i32 %1596 to i64
  %1600 = shl nsw i64 %1599, 5
  %1601 = getelementptr i8, ptr %1598, i64 %1600
  %1602 = load ptr, ptr %1601, align 8
  %1603 = getelementptr i8, ptr %1601, i64 8
  %1604 = load i160, ptr %1603, align 4
  store ptr %.sroa.0.0564.i1117.i, ptr %1601, align 8
  store i64 %1581, ptr %1603, align 4
  %.sroa_idx157.i1146.i = getelementptr i8, ptr %1601, i64 16
  store i64 %1580, ptr %.sroa_idx157.i1146.i, align 4
  %.sroa_idx158.i1147.i = getelementptr i8, ptr %1601, i64 24
  store i32 %.sroa.17.0561.i1120.i, ptr %.sroa_idx158.i1147.i, align 4
  %1605 = icmp ne ptr %1602, @nil_typ
  %1606 = icmp ne ptr %1602, null
  %.not92.i1148.i = and i1 %1605, %1606
  %extract.i1150.i = lshr i160 %1604, 64
  %1607 = insertelement <2 x i160> poison, i160 %1604, i64 0
  %1608 = insertelement <2 x i160> %1607, i160 %extract.i1150.i, i64 1
  br i1 %.not92.i1148.i, label %.cont.cont.i1127.i, label %1648

1609:                                             ; preds = %1578
  %1610 = add i32 %1592, 2127912214
  %1611 = shl i32 %1592, 12
  %1612 = add i32 %1610, %1611
  %1613 = ashr i32 %1612, 19
  %1614 = xor i32 %1612, %1613
  %1615 = xor i32 %1614, -949894596
  %1616 = add i32 %1615, 374761393
  %1617 = shl i32 %1615, 5
  %1618 = add i32 %1616, %1617
  %1619 = add i32 %1618, -744332180
  %1620 = shl i32 %1618, 9
  %1621 = xor i32 %1619, %1620
  %1622 = add i32 %1621, -42973499
  %1623 = shl i32 %1621, 3
  %1624 = add i32 %1622, %1623
  %1625 = ashr i32 %1624, 16
  %1626 = xor i32 %1624, %1625
  %1627 = xor i32 %1626, -1252372727
  %1628 = load i32, ptr %1101, align 8
  %1629 = add i32 %1628, -1
  %1630 = and i32 %1629, %1627
  %1631 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1632 = load ptr, ptr %1103, align 8
  %1633 = sext i32 %1630 to i64
  %1634 = shl nsw i64 %1633, 5
  %1635 = getelementptr i8, ptr %1632, i64 %1634
  %1636 = load ptr, ptr %1635, align 8
  %1637 = getelementptr i8, ptr %1635, i64 8
  %1638 = load i160, ptr %1637, align 4
  store ptr %.sroa.0.0564.i1117.i, ptr %1635, align 8
  store i64 %1581, ptr %1637, align 4
  %.sroa_idx161.i1121.i = getelementptr i8, ptr %1635, i64 16
  store i64 %1580, ptr %.sroa_idx161.i1121.i, align 4
  %.sroa_idx162.i1122.i = getelementptr i8, ptr %1635, i64 24
  store i32 %.sroa.17.0561.i1120.i, ptr %.sroa_idx162.i1122.i, align 4
  %1639 = icmp ne ptr %1636, @nil_typ
  %1640 = icmp ne ptr %1636, null
  %.not90.i1123.i = and i1 %1639, %1640
  %extract607.i1125.i = lshr i160 %1638, 64
  %1641 = insertelement <2 x i160> poison, i160 %1638, i64 0
  %1642 = insertelement <2 x i160> %1641, i160 %extract607.i1125.i, i64 1
  br i1 %.not90.i1123.i, label %.cont.cont.i1127.i, label %1648

.cont.cont.i1127.i:                               ; preds = %1609, %1593
  %vptr.i142.sroa.speculated.i1130.i = phi ptr [ %1602, %1593 ], [ %1636, %1609 ]
  %.in319 = phi <2 x i160> [ %1608, %1593 ], [ %1642, %1609 ]
  %1643 = trunc <2 x i160> %.in319 to <2 x i64>
  %1644 = xor i1 %.070565.i1116.i, true
  %hash_coef_ptr.i.i143.i1133.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1130.i, i64 8
  %tbl_size_ptr.i.i144.i1134.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1130.i, i64 16
  %offset_tbl_ptr.i.i145.i1135.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1130.i, i64 40
  %hash_coef.i.i146.i1136.i = load i64, ptr %hash_coef_ptr.i.i143.i1133.i, align 4
  %tbl_size.i.i147.i1137.i = load i64, ptr %tbl_size_ptr.i.i144.i1134.i, align 4
  %offset_tbl.i.i148.i1138.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1135.i, align 8
  %product.i.i.i149.i1139.i = mul i64 %hash_coef.i.i146.i1136.i, 4015701072841558310
  %shifted.i.i.i150.i1140.i = lshr i64 %product.i.i.i149.i1139.i, 32
  %xored.i.i.i151.i1141.i = xor i64 %shifted.i.i.i150.i1140.i, %product.i.i.i149.i1139.i
  %hash.i.i.i152.i1142.i = and i64 %xored.i.i.i151.i1141.i, %tbl_size.i.i147.i1137.i
  %offset_ptr.i.i153.i1143.i = getelementptr i32, ptr %offset_tbl.i.i148.i1138.i, i64 %hash.i.i.i152.i1142.i
  %offset.i.i154.i1144.i = load i32, ptr %offset_ptr.i.i153.i1143.i, align 4
  %1645 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1646 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1647 = icmp ult i32 %.0566.i1115.i, 99
  br i1 %1647, label %1578, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1152.i

1648:                                             ; preds = %1609, %1593
  %1649 = phi ptr [ %8, %1609 ], [ %7, %1593 ]
  %1650 = load i32, ptr %1104, align 4
  store i32 %1650, ptr %1649, align 4
  %1651 = add i32 %1650, 1
  %1652 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1651, ptr %1104, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1152.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1152.i: ; preds = %.cont.cont.i1127.i, %1648
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  br label %._crit_edge.i950.i

._crit_edge.i950.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1152.i, %.lr.ph.i935.i
  %1653 = add nuw nsw i32 %.060.i948.i, 1
  %1654 = icmp slt i32 %1653, %1560
  br i1 %1654, label %.lr.ph.i935.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968.i: ; preds = %._crit_edge.i950.i, %._crit_edge.i986.i
  %.060.i984.i = phi i32 [ %1743, %._crit_edge.i986.i ], [ 0, %._crit_edge.i950.i ]
  %1655 = zext nneg i32 %.060.i984.i to i64
  %1656 = shl nuw nsw i64 %1655, 5
  %1657 = getelementptr i8, ptr %1559, i64 %1656
  %1658 = load ptr, ptr %1657, align 8
  %1659 = icmp ne ptr %1658, @nil_typ
  %1660 = icmp ne ptr %1658, null
  %.not16.i985.i = and i1 %1659, %1660
  br i1 %.not16.i985.i, label %1661, label %._crit_edge.i986.i

1661:                                             ; preds = %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968.i
  %1662 = getelementptr i8, ptr %1657, i64 8
  %1663 = load <2 x i64>, ptr %1662, align 4
  %hash_coef_ptr.i.i18.i988.i = getelementptr i8, ptr %1658, i64 8
  %tbl_size_ptr.i.i19.i989.i = getelementptr i8, ptr %1658, i64 16
  %offset_tbl_ptr.i.i20.i990.i = getelementptr i8, ptr %1658, i64 40
  %1664 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  %hash_coef.i.i99.i1170.i = load i64, ptr %hash_coef_ptr.i.i18.i988.i, align 4, !noalias !22
  %tbl_size.i.i100.i1171.i = load i64, ptr %tbl_size_ptr.i.i19.i989.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1172.i = load ptr, ptr %offset_tbl_ptr.i.i20.i990.i, align 8, !noalias !22
  %product.i.i.i102.i1173.i = mul i64 %hash_coef.i.i99.i1170.i, 4015701072841558310
  %shifted.i.i.i103.i1174.i = lshr i64 %product.i.i.i102.i1173.i, 32
  %xored.i.i.i104.i1175.i = xor i64 %shifted.i.i.i103.i1174.i, %product.i.i.i102.i1173.i
  %hash.i.i.i105.i1176.i = and i64 %xored.i.i.i104.i1175.i, %tbl_size.i.i100.i1171.i
  %offset_ptr.i.i106.i1177.i = getelementptr i32, ptr %offset_tbl.i.i101.i1172.i, i64 %hash.i.i.i105.i1176.i
  %offset.i.i121.i1178.i = load i32, ptr %offset_ptr.i.i106.i1177.i, align 4, !noalias !467
  %1665 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1666 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1667 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1668

1668:                                             ; preds = %.cont.cont.i1199.i, %1661
  %.0566.i1179.i = phi i32 [ 0, %1661 ], [ %1672, %.cont.cont.i1199.i ]
  %.070565.i1180.i = phi i1 [ true, %1661 ], [ %1734, %.cont.cont.i1199.i ]
  %.sroa.0.0564.i1181.i = phi ptr [ %1658, %1661 ], [ %vptr.i142.sroa.speculated.i1202.i, %.cont.cont.i1199.i ]
  %.sroa.17.0561.i1184.i = phi i32 [ %offset.i.i121.i1178.i, %1661 ], [ %offset.i.i154.i1216.i, %.cont.cont.i1199.i ]
  %1669 = phi <2 x i64> [ %1663, %1661 ], [ %1733, %.cont.cont.i1199.i ]
  %1670 = extractelement <2 x i64> %1669, i64 1
  %.sroa.12.0562.i1183.i = inttoptr i64 %1670 to ptr
  %1671 = extractelement <2 x i64> %1669, i64 0
  %.sroa.6.0563.i1182.i = inttoptr i64 %1671 to ptr
  %1672 = add nuw nsw i32 %.0566.i1179.i, 1
  %1673 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1181.i, 0
  %1674 = insertvalue { ptr, ptr, ptr, i32 } %1673, ptr %.sroa.6.0563.i1182.i, 1
  %1675 = insertvalue { ptr, ptr, ptr, i32 } %1674, ptr %.sroa.12.0562.i1183.i, 2
  %1676 = insertvalue { ptr, ptr, ptr, i32 } %1675, i32 %.sroa.17.0561.i1184.i, 3
  %1677 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1181.i)
  %1678 = sext i32 %.sroa.17.0561.i1184.i to i64
  %1679 = getelementptr ptr, ptr %.sroa.0.0564.i1181.i, i64 %1678
  %1680 = getelementptr i8, ptr %1679, i64 64
  %1681 = load ptr, ptr %1680, align 8
  %result.i125.i1185.i = call ptr %1681({ ptr, ptr, ptr, i32 } %1676, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1682 = call i32 %result.i125.i1185.i({ ptr, ptr, ptr, i32 } %1676, { ptr, ptr, ptr, i32 } %1676, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1180.i, label %1683, label %1699

1683:                                             ; preds = %1668
  %1684 = load i32, ptr %1101, align 8
  %1685 = add i32 %1684, -1
  %1686 = and i32 %1685, %1682
  %1687 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1688 = load ptr, ptr %1102, align 8
  %1689 = sext i32 %1686 to i64
  %1690 = shl nsw i64 %1689, 5
  %1691 = getelementptr i8, ptr %1688, i64 %1690
  %1692 = load ptr, ptr %1691, align 8
  %1693 = getelementptr i8, ptr %1691, i64 8
  %1694 = load i160, ptr %1693, align 4
  store ptr %.sroa.0.0564.i1181.i, ptr %1691, align 8
  store i64 %1671, ptr %1693, align 4
  %.sroa_idx157.i1228.i = getelementptr i8, ptr %1691, i64 16
  store i64 %1670, ptr %.sroa_idx157.i1228.i, align 4
  %.sroa_idx158.i1229.i = getelementptr i8, ptr %1691, i64 24
  store i32 %.sroa.17.0561.i1184.i, ptr %.sroa_idx158.i1229.i, align 4
  %1695 = icmp ne ptr %1692, @nil_typ
  %1696 = icmp ne ptr %1692, null
  %.not92.i1230.i = and i1 %1695, %1696
  %extract.i1232.i = lshr i160 %1694, 64
  %1697 = insertelement <2 x i160> poison, i160 %1694, i64 0
  %1698 = insertelement <2 x i160> %1697, i160 %extract.i1232.i, i64 1
  br i1 %.not92.i1230.i, label %.cont.cont.i1199.i, label %1738

1699:                                             ; preds = %1668
  %1700 = add i32 %1682, 2127912214
  %1701 = shl i32 %1682, 12
  %1702 = add i32 %1700, %1701
  %1703 = ashr i32 %1702, 19
  %1704 = xor i32 %1702, %1703
  %1705 = xor i32 %1704, -949894596
  %1706 = add i32 %1705, 374761393
  %1707 = shl i32 %1705, 5
  %1708 = add i32 %1706, %1707
  %1709 = add i32 %1708, -744332180
  %1710 = shl i32 %1708, 9
  %1711 = xor i32 %1709, %1710
  %1712 = add i32 %1711, -42973499
  %1713 = shl i32 %1711, 3
  %1714 = add i32 %1712, %1713
  %1715 = ashr i32 %1714, 16
  %1716 = xor i32 %1714, %1715
  %1717 = xor i32 %1716, -1252372727
  %1718 = load i32, ptr %1101, align 8
  %1719 = add i32 %1718, -1
  %1720 = and i32 %1719, %1717
  %1721 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1722 = load ptr, ptr %1103, align 8
  %1723 = sext i32 %1720 to i64
  %1724 = shl nsw i64 %1723, 5
  %1725 = getelementptr i8, ptr %1722, i64 %1724
  %1726 = load ptr, ptr %1725, align 8
  %1727 = getelementptr i8, ptr %1725, i64 8
  %1728 = load i160, ptr %1727, align 4
  store ptr %.sroa.0.0564.i1181.i, ptr %1725, align 8
  store i64 %1671, ptr %1727, align 4
  %.sroa_idx161.i1189.i = getelementptr i8, ptr %1725, i64 16
  store i64 %1670, ptr %.sroa_idx161.i1189.i, align 4
  %.sroa_idx162.i1190.i = getelementptr i8, ptr %1725, i64 24
  store i32 %.sroa.17.0561.i1184.i, ptr %.sroa_idx162.i1190.i, align 4
  %1729 = icmp ne ptr %1726, @nil_typ
  %1730 = icmp ne ptr %1726, null
  %.not90.i1191.i = and i1 %1729, %1730
  %extract607.i1193.i = lshr i160 %1728, 64
  %1731 = insertelement <2 x i160> poison, i160 %1728, i64 0
  %1732 = insertelement <2 x i160> %1731, i160 %extract607.i1193.i, i64 1
  br i1 %.not90.i1191.i, label %.cont.cont.i1199.i, label %1738

.cont.cont.i1199.i:                               ; preds = %1699, %1683
  %vptr.i142.sroa.speculated.i1202.i = phi ptr [ %1692, %1683 ], [ %1726, %1699 ]
  %.in320 = phi <2 x i160> [ %1698, %1683 ], [ %1732, %1699 ]
  %1733 = trunc <2 x i160> %.in320 to <2 x i64>
  %1734 = xor i1 %.070565.i1180.i, true
  %hash_coef_ptr.i.i143.i1205.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1202.i, i64 8
  %tbl_size_ptr.i.i144.i1206.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1202.i, i64 16
  %offset_tbl_ptr.i.i145.i1207.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1202.i, i64 40
  %hash_coef.i.i146.i1208.i = load i64, ptr %hash_coef_ptr.i.i143.i1205.i, align 4
  %tbl_size.i.i147.i1209.i = load i64, ptr %tbl_size_ptr.i.i144.i1206.i, align 4
  %offset_tbl.i.i148.i1210.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1207.i, align 8
  %product.i.i.i149.i1211.i = mul i64 %hash_coef.i.i146.i1208.i, 4015701072841558310
  %shifted.i.i.i150.i1212.i = lshr i64 %product.i.i.i149.i1211.i, 32
  %xored.i.i.i151.i1213.i = xor i64 %shifted.i.i.i150.i1212.i, %product.i.i.i149.i1211.i
  %hash.i.i.i152.i1214.i = and i64 %xored.i.i.i151.i1213.i, %tbl_size.i.i147.i1209.i
  %offset_ptr.i.i153.i1215.i = getelementptr i32, ptr %offset_tbl.i.i148.i1210.i, i64 %hash.i.i.i152.i1214.i
  %offset.i.i154.i1216.i = load i32, ptr %offset_ptr.i.i153.i1215.i, align 4
  %1735 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1736 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1737 = icmp ult i32 %.0566.i1179.i, 99
  br i1 %1737, label %1668, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1234.i

1738:                                             ; preds = %1699, %1683
  %1739 = phi ptr [ %6, %1699 ], [ %5, %1683 ]
  %1740 = load i32, ptr %1104, align 4
  store i32 %1740, ptr %1739, align 4
  %1741 = add i32 %1740, 1
  %1742 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1741, ptr %1104, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1234.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1234.i: ; preds = %.cont.cont.i1199.i, %1738
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %._crit_edge.i986.i

._crit_edge.i986.i:                               ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1234.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968.i
  %1743 = add nuw nsw i32 %.060.i984.i, 1
  %1744 = icmp slt i32 %1743, %1560
  br i1 %1744, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit968.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i: ; preds = %._crit_edge.i986.i, %1556
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  %hash_coef.i.i99.i588.i = load i64, ptr %hash_coef_ptr.i.i143.i.i113, align 4, !noalias !22
  %tbl_size.i.i100.i589.i = load i64, ptr %tbl_size_ptr.i.i144.i.i114, align 4, !noalias !22
  %offset_tbl.i.i101.i590.i = load ptr, ptr %offset_tbl_ptr.i.i145.i.i115, align 8, !noalias !22
  %product.i.i.i102.i591.i = mul i64 %hash_coef.i.i99.i588.i, 4015701072841558310
  %shifted.i.i.i103.i592.i = lshr i64 %product.i.i.i102.i591.i, 32
  %xored.i.i.i104.i593.i = xor i64 %shifted.i.i.i103.i592.i, %product.i.i.i102.i591.i
  %hash.i.i.i105.i594.i = and i64 %xored.i.i.i104.i593.i, %tbl_size.i.i100.i589.i
  %offset_ptr.i.i106.i595.i = getelementptr i32, ptr %offset_tbl.i.i101.i590.i, i64 %hash.i.i.i105.i594.i
  %offset.i.i121.i596.i = load i32, ptr %offset_ptr.i.i106.i595.i, align 4, !noalias !470
  %1746 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1747 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1748 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1749

1749:                                             ; preds = %.cont.cont.i618.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i
  %.0566.i598.i = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i ], [ %1753, %.cont.cont.i618.i ]
  %.070565.i599.i = phi i1 [ true, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i ], [ %1815, %.cont.cont.i618.i ]
  %.sroa.0.0564.i600.i = phi ptr [ %vptr.i142.sroa.speculated.i.i111, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i ], [ %vptr.i142.sroa.speculated.i621.i, %.cont.cont.i618.i ]
  %.sroa.17.0561.i603.i = phi i32 [ %offset.i.i121.i596.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i ], [ %offset.i.i154.i635.i, %.cont.cont.i618.i ]
  %1750 = phi <2 x i64> [ %1544, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1004.i ], [ %1814, %.cont.cont.i618.i ]
  %1751 = extractelement <2 x i64> %1750, i64 1
  %.sroa.12.0562.i602.i = inttoptr i64 %1751 to ptr
  %1752 = extractelement <2 x i64> %1750, i64 0
  %.sroa.6.0563.i601.i = inttoptr i64 %1752 to ptr
  %1753 = add nuw nsw i32 %.0566.i598.i, 1
  %1754 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i600.i, 0
  %1755 = insertvalue { ptr, ptr, ptr, i32 } %1754, ptr %.sroa.6.0563.i601.i, 1
  %1756 = insertvalue { ptr, ptr, ptr, i32 } %1755, ptr %.sroa.12.0562.i602.i, 2
  %1757 = insertvalue { ptr, ptr, ptr, i32 } %1756, i32 %.sroa.17.0561.i603.i, 3
  %1758 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i600.i)
  %1759 = sext i32 %.sroa.17.0561.i603.i to i64
  %1760 = getelementptr ptr, ptr %.sroa.0.0564.i600.i, i64 %1759
  %1761 = getelementptr i8, ptr %1760, i64 64
  %1762 = load ptr, ptr %1761, align 8
  %result.i125.i604.i = call ptr %1762({ ptr, ptr, ptr, i32 } %1757, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1763 = call i32 %result.i125.i604.i({ ptr, ptr, ptr, i32 } %1757, { ptr, ptr, ptr, i32 } %1757, ptr nonnull align 8 %0) #7
  br i1 %.070565.i599.i, label %1764, label %1780

1764:                                             ; preds = %1749
  %1765 = load i32, ptr %1101, align 8
  %1766 = add i32 %1765, -1
  %1767 = and i32 %1766, %1763
  %1768 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1769 = load ptr, ptr %1102, align 8
  %1770 = sext i32 %1767 to i64
  %1771 = shl nsw i64 %1770, 5
  %1772 = getelementptr i8, ptr %1769, i64 %1771
  %1773 = load ptr, ptr %1772, align 8
  %1774 = getelementptr i8, ptr %1772, i64 8
  %1775 = load i160, ptr %1774, align 4
  store ptr %.sroa.0.0564.i600.i, ptr %1772, align 8
  store i64 %1752, ptr %1774, align 4
  %.sroa_idx157.i647.i = getelementptr i8, ptr %1772, i64 16
  store i64 %1751, ptr %.sroa_idx157.i647.i, align 4
  %.sroa_idx158.i648.i = getelementptr i8, ptr %1772, i64 24
  store i32 %.sroa.17.0561.i603.i, ptr %.sroa_idx158.i648.i, align 4
  %1776 = icmp ne ptr %1773, @nil_typ
  %1777 = icmp ne ptr %1773, null
  %.not92.i649.i = and i1 %1776, %1777
  %extract.i651.i = lshr i160 %1775, 64
  %1778 = insertelement <2 x i160> poison, i160 %1775, i64 0
  %1779 = insertelement <2 x i160> %1778, i160 %extract.i651.i, i64 1
  br i1 %.not92.i649.i, label %.cont.cont.i618.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.thread.i

1780:                                             ; preds = %1749
  %1781 = add i32 %1763, 2127912214
  %1782 = shl i32 %1763, 12
  %1783 = add i32 %1781, %1782
  %1784 = ashr i32 %1783, 19
  %1785 = xor i32 %1783, %1784
  %1786 = xor i32 %1785, -949894596
  %1787 = add i32 %1786, 374761393
  %1788 = shl i32 %1786, 5
  %1789 = add i32 %1787, %1788
  %1790 = add i32 %1789, -744332180
  %1791 = shl i32 %1789, 9
  %1792 = xor i32 %1790, %1791
  %1793 = add i32 %1792, -42973499
  %1794 = shl i32 %1792, 3
  %1795 = add i32 %1793, %1794
  %1796 = ashr i32 %1795, 16
  %1797 = xor i32 %1795, %1796
  %1798 = xor i32 %1797, -1252372727
  %1799 = load i32, ptr %1101, align 8
  %1800 = add i32 %1799, -1
  %1801 = and i32 %1800, %1798
  %1802 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1803 = load ptr, ptr %1103, align 8
  %1804 = sext i32 %1801 to i64
  %1805 = shl nsw i64 %1804, 5
  %1806 = getelementptr i8, ptr %1803, i64 %1805
  %1807 = load ptr, ptr %1806, align 8
  %1808 = getelementptr i8, ptr %1806, i64 8
  %1809 = load i160, ptr %1808, align 4
  store ptr %.sroa.0.0564.i600.i, ptr %1806, align 8
  store i64 %1752, ptr %1808, align 4
  %.sroa_idx161.i608.i = getelementptr i8, ptr %1806, i64 16
  store i64 %1751, ptr %.sroa_idx161.i608.i, align 4
  %.sroa_idx162.i609.i = getelementptr i8, ptr %1806, i64 24
  store i32 %.sroa.17.0561.i603.i, ptr %.sroa_idx162.i609.i, align 4
  %1810 = icmp ne ptr %1807, @nil_typ
  %1811 = icmp ne ptr %1807, null
  %.not90.i610.i = and i1 %1810, %1811
  %extract607.i612.i = lshr i160 %1809, 64
  %1812 = insertelement <2 x i160> poison, i160 %1809, i64 0
  %1813 = insertelement <2 x i160> %1812, i160 %extract607.i612.i, i64 1
  br i1 %.not90.i610.i, label %.cont.cont.i618.i, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.thread.i

.cont.cont.i618.i:                                ; preds = %1780, %1764
  %vptr.i142.sroa.speculated.i621.i = phi ptr [ %1773, %1764 ], [ %1807, %1780 ]
  %.in321 = phi <2 x i160> [ %1779, %1764 ], [ %1813, %1780 ]
  %1814 = trunc <2 x i160> %.in321 to <2 x i64>
  %1815 = xor i1 %.070565.i599.i, true
  %hash_coef_ptr.i.i143.i624.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i621.i, i64 8
  %tbl_size_ptr.i.i144.i625.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i621.i, i64 16
  %offset_tbl_ptr.i.i145.i626.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i621.i, i64 40
  %hash_coef.i.i146.i627.i = load i64, ptr %hash_coef_ptr.i.i143.i624.i, align 4
  %tbl_size.i.i147.i628.i = load i64, ptr %tbl_size_ptr.i.i144.i625.i, align 4
  %offset_tbl.i.i148.i629.i = load ptr, ptr %offset_tbl_ptr.i.i145.i626.i, align 8
  %product.i.i.i149.i630.i = mul i64 %hash_coef.i.i146.i627.i, 4015701072841558310
  %shifted.i.i.i150.i631.i = lshr i64 %product.i.i.i149.i630.i, 32
  %xored.i.i.i151.i632.i = xor i64 %shifted.i.i.i150.i631.i, %product.i.i.i149.i630.i
  %hash.i.i.i152.i633.i = and i64 %xored.i.i.i151.i632.i, %tbl_size.i.i147.i628.i
  %offset_ptr.i.i153.i634.i = getelementptr i32, ptr %offset_tbl.i.i148.i629.i, i64 %hash.i.i.i152.i633.i
  %offset.i.i154.i635.i = load i32, ptr %offset_ptr.i.i153.i634.i, align 4
  %1816 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1817 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1818 = icmp ult i32 %.0566.i598.i, 99
  br i1 %1818, label %1749, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.thread.i: ; preds = %1780, %1764
  %1819 = phi ptr [ %10, %1780 ], [ %9, %1764 ]
  %1820 = load i32, ptr %1104, align 4
  store i32 %1820, ptr %1819, align 4
  %1821 = add i32 %1820, 1
  %1822 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1821, ptr %1104, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  br label %CuckooMap_insert_keyK_valueV.exit.i63

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.i: ; preds = %.cont.cont.i618.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  %1823 = icmp eq ptr %vptr.i142.sroa.speculated.i621.i, null
  br i1 %1823, label %CuckooMap_insert_keyK_valueV.exit.i63, label %1824

1824:                                             ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.i
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1826 = load ptr, ptr %1102, align 8
  %1827 = load ptr, ptr %1103, align 8
  %1828 = load i32, ptr %1101, align 8
  %1829 = shl i32 %1828, 1
  %spec.select.i669.i = call i32 @llvm.smax.i32(i32 %1829, i32 16)
  store i32 %spec.select.i669.i, ptr %1101, align 8
  %1830 = zext nneg i32 %spec.select.i669.i to i64
  %1831 = shl nuw nsw i64 %1830, 5
  %result.i.i670.i = call noalias ptr @bump_malloc_inner(i64 noundef %1831, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i670.i, ptr %1102, align 8
  %result.i20.i671.i = call noalias ptr @bump_malloc_inner(i64 noundef %1831, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i20.i671.i, ptr %1103, align 8
  store i32 0, ptr %1104, align 4
  %1832 = icmp sgt i32 %1828, 0
  br i1 %1832, label %.lr.ph.i1034.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.thread.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.thread.i: ; preds = %1824
  %1833 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %CuckooMap_insert_keyK_valueV.exit.i63

.lr.ph.i1034.i:                                   ; preds = %1824, %._crit_edge.i1049.i
  %.060.i1047.i = phi i32 [ %1922, %._crit_edge.i1049.i ], [ 0, %1824 ]
  %1834 = zext nneg i32 %.060.i1047.i to i64
  %1835 = shl nuw nsw i64 %1834, 5
  %1836 = getelementptr i8, ptr %1826, i64 %1835
  %1837 = load ptr, ptr %1836, align 8
  %1838 = icmp ne ptr %1837, @nil_typ
  %1839 = icmp ne ptr %1837, null
  %.not16.i1048.i = and i1 %1838, %1839
  br i1 %.not16.i1048.i, label %1840, label %._crit_edge.i1049.i

1840:                                             ; preds = %.lr.ph.i1034.i
  %1841 = getelementptr i8, ptr %1836, i64 8
  %1842 = load <2 x i64>, ptr %1841, align 4
  %hash_coef_ptr.i.i18.i1051.i = getelementptr i8, ptr %1837, i64 8
  %tbl_size_ptr.i.i19.i1052.i = getelementptr i8, ptr %1837, i64 16
  %offset_tbl_ptr.i.i20.i1053.i = getelementptr i8, ptr %1837, i64 40
  %1843 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  %hash_coef.i.i99.i1252.i = load i64, ptr %hash_coef_ptr.i.i18.i1051.i, align 4, !noalias !22
  %tbl_size.i.i100.i1253.i = load i64, ptr %tbl_size_ptr.i.i19.i1052.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1254.i = load ptr, ptr %offset_tbl_ptr.i.i20.i1053.i, align 8, !noalias !22
  %product.i.i.i102.i1255.i = mul i64 %hash_coef.i.i99.i1252.i, 4015701072841558310
  %shifted.i.i.i103.i1256.i = lshr i64 %product.i.i.i102.i1255.i, 32
  %xored.i.i.i104.i1257.i = xor i64 %shifted.i.i.i103.i1256.i, %product.i.i.i102.i1255.i
  %hash.i.i.i105.i1258.i = and i64 %xored.i.i.i104.i1257.i, %tbl_size.i.i100.i1253.i
  %offset_ptr.i.i106.i1259.i = getelementptr i32, ptr %offset_tbl.i.i101.i1254.i, i64 %hash.i.i.i105.i1258.i
  %offset.i.i121.i1260.i = load i32, ptr %offset_ptr.i.i106.i1259.i, align 4, !noalias !473
  %1844 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1845 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1846 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1847

1847:                                             ; preds = %.cont.cont.i1281.i, %1840
  %.0566.i1261.i = phi i32 [ 0, %1840 ], [ %1851, %.cont.cont.i1281.i ]
  %.070565.i1262.i = phi i1 [ true, %1840 ], [ %1913, %.cont.cont.i1281.i ]
  %.sroa.0.0564.i1263.i = phi ptr [ %1837, %1840 ], [ %vptr.i142.sroa.speculated.i1284.i, %.cont.cont.i1281.i ]
  %.sroa.17.0561.i1266.i = phi i32 [ %offset.i.i121.i1260.i, %1840 ], [ %offset.i.i154.i1298.i, %.cont.cont.i1281.i ]
  %1848 = phi <2 x i64> [ %1842, %1840 ], [ %1912, %.cont.cont.i1281.i ]
  %1849 = extractelement <2 x i64> %1848, i64 1
  %.sroa.12.0562.i1265.i = inttoptr i64 %1849 to ptr
  %1850 = extractelement <2 x i64> %1848, i64 0
  %.sroa.6.0563.i1264.i = inttoptr i64 %1850 to ptr
  %1851 = add nuw nsw i32 %.0566.i1261.i, 1
  %1852 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1263.i, 0
  %1853 = insertvalue { ptr, ptr, ptr, i32 } %1852, ptr %.sroa.6.0563.i1264.i, 1
  %1854 = insertvalue { ptr, ptr, ptr, i32 } %1853, ptr %.sroa.12.0562.i1265.i, 2
  %1855 = insertvalue { ptr, ptr, ptr, i32 } %1854, i32 %.sroa.17.0561.i1266.i, 3
  %1856 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1263.i)
  %1857 = sext i32 %.sroa.17.0561.i1266.i to i64
  %1858 = getelementptr ptr, ptr %.sroa.0.0564.i1263.i, i64 %1857
  %1859 = getelementptr i8, ptr %1858, i64 64
  %1860 = load ptr, ptr %1859, align 8
  %result.i125.i1267.i = call ptr %1860({ ptr, ptr, ptr, i32 } %1855, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1861 = call i32 %result.i125.i1267.i({ ptr, ptr, ptr, i32 } %1855, { ptr, ptr, ptr, i32 } %1855, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1262.i, label %1862, label %1878

1862:                                             ; preds = %1847
  %1863 = load i32, ptr %1101, align 8
  %1864 = add i32 %1863, -1
  %1865 = and i32 %1864, %1861
  %1866 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1867 = load ptr, ptr %1102, align 8
  %1868 = sext i32 %1865 to i64
  %1869 = shl nsw i64 %1868, 5
  %1870 = getelementptr i8, ptr %1867, i64 %1869
  %1871 = load ptr, ptr %1870, align 8
  %1872 = getelementptr i8, ptr %1870, i64 8
  %1873 = load i160, ptr %1872, align 4
  store ptr %.sroa.0.0564.i1263.i, ptr %1870, align 8
  store i64 %1850, ptr %1872, align 4
  %.sroa_idx157.i1310.i = getelementptr i8, ptr %1870, i64 16
  store i64 %1849, ptr %.sroa_idx157.i1310.i, align 4
  %.sroa_idx158.i1311.i = getelementptr i8, ptr %1870, i64 24
  store i32 %.sroa.17.0561.i1266.i, ptr %.sroa_idx158.i1311.i, align 4
  %1874 = icmp ne ptr %1871, @nil_typ
  %1875 = icmp ne ptr %1871, null
  %.not92.i1312.i = and i1 %1874, %1875
  %extract.i1314.i = lshr i160 %1873, 64
  %1876 = insertelement <2 x i160> poison, i160 %1873, i64 0
  %1877 = insertelement <2 x i160> %1876, i160 %extract.i1314.i, i64 1
  br i1 %.not92.i1312.i, label %.cont.cont.i1281.i, label %1917

1878:                                             ; preds = %1847
  %1879 = add i32 %1861, 2127912214
  %1880 = shl i32 %1861, 12
  %1881 = add i32 %1879, %1880
  %1882 = ashr i32 %1881, 19
  %1883 = xor i32 %1881, %1882
  %1884 = xor i32 %1883, -949894596
  %1885 = add i32 %1884, 374761393
  %1886 = shl i32 %1884, 5
  %1887 = add i32 %1885, %1886
  %1888 = add i32 %1887, -744332180
  %1889 = shl i32 %1887, 9
  %1890 = xor i32 %1888, %1889
  %1891 = add i32 %1890, -42973499
  %1892 = shl i32 %1890, 3
  %1893 = add i32 %1891, %1892
  %1894 = ashr i32 %1893, 16
  %1895 = xor i32 %1893, %1894
  %1896 = xor i32 %1895, -1252372727
  %1897 = load i32, ptr %1101, align 8
  %1898 = add i32 %1897, -1
  %1899 = and i32 %1898, %1896
  %1900 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1901 = load ptr, ptr %1103, align 8
  %1902 = sext i32 %1899 to i64
  %1903 = shl nsw i64 %1902, 5
  %1904 = getelementptr i8, ptr %1901, i64 %1903
  %1905 = load ptr, ptr %1904, align 8
  %1906 = getelementptr i8, ptr %1904, i64 8
  %1907 = load i160, ptr %1906, align 4
  store ptr %.sroa.0.0564.i1263.i, ptr %1904, align 8
  store i64 %1850, ptr %1906, align 4
  %.sroa_idx161.i1271.i = getelementptr i8, ptr %1904, i64 16
  store i64 %1849, ptr %.sroa_idx161.i1271.i, align 4
  %.sroa_idx162.i1272.i = getelementptr i8, ptr %1904, i64 24
  store i32 %.sroa.17.0561.i1266.i, ptr %.sroa_idx162.i1272.i, align 4
  %1908 = icmp ne ptr %1905, @nil_typ
  %1909 = icmp ne ptr %1905, null
  %.not90.i1273.i = and i1 %1908, %1909
  %extract607.i1275.i = lshr i160 %1907, 64
  %1910 = insertelement <2 x i160> poison, i160 %1907, i64 0
  %1911 = insertelement <2 x i160> %1910, i160 %extract607.i1275.i, i64 1
  br i1 %.not90.i1273.i, label %.cont.cont.i1281.i, label %1917

.cont.cont.i1281.i:                               ; preds = %1878, %1862
  %vptr.i142.sroa.speculated.i1284.i = phi ptr [ %1871, %1862 ], [ %1905, %1878 ]
  %.in322 = phi <2 x i160> [ %1877, %1862 ], [ %1911, %1878 ]
  %1912 = trunc <2 x i160> %.in322 to <2 x i64>
  %1913 = xor i1 %.070565.i1262.i, true
  %hash_coef_ptr.i.i143.i1287.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1284.i, i64 8
  %tbl_size_ptr.i.i144.i1288.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1284.i, i64 16
  %offset_tbl_ptr.i.i145.i1289.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1284.i, i64 40
  %hash_coef.i.i146.i1290.i = load i64, ptr %hash_coef_ptr.i.i143.i1287.i, align 4
  %tbl_size.i.i147.i1291.i = load i64, ptr %tbl_size_ptr.i.i144.i1288.i, align 4
  %offset_tbl.i.i148.i1292.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1289.i, align 8
  %product.i.i.i149.i1293.i = mul i64 %hash_coef.i.i146.i1290.i, 4015701072841558310
  %shifted.i.i.i150.i1294.i = lshr i64 %product.i.i.i149.i1293.i, 32
  %xored.i.i.i151.i1295.i = xor i64 %shifted.i.i.i150.i1294.i, %product.i.i.i149.i1293.i
  %hash.i.i.i152.i1296.i = and i64 %xored.i.i.i151.i1295.i, %tbl_size.i.i147.i1291.i
  %offset_ptr.i.i153.i1297.i = getelementptr i32, ptr %offset_tbl.i.i148.i1292.i, i64 %hash.i.i.i152.i1296.i
  %offset.i.i154.i1298.i = load i32, ptr %offset_ptr.i.i153.i1297.i, align 4
  %1914 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1915 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1916 = icmp ult i32 %.0566.i1261.i, 99
  br i1 %1916, label %1847, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1316.i

1917:                                             ; preds = %1878, %1862
  %1918 = phi ptr [ %4, %1878 ], [ %3, %1862 ]
  %1919 = load i32, ptr %1104, align 4
  store i32 %1919, ptr %1918, align 4
  %1920 = add i32 %1919, 1
  %1921 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %1920, ptr %1104, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1316.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1316.i: ; preds = %.cont.cont.i1281.i, %1917
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %._crit_edge.i1049.i

._crit_edge.i1049.i:                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1316.i, %.lr.ph.i1034.i
  %1922 = add nuw nsw i32 %.060.i1047.i, 1
  %1923 = icmp slt i32 %1922, %1828
  br i1 %1923, label %.lr.ph.i1034.i, label %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.i

CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.i: ; preds = %._crit_edge.i1049.i
  %1924 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #41
  br label %1925

1925:                                             ; preds = %._crit_edge.i1085.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.i
  %.060.i1083.i = phi i32 [ 0, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.i ], [ %2014, %._crit_edge.i1085.i ]
  %1926 = zext nneg i32 %.060.i1083.i to i64
  %1927 = shl nuw nsw i64 %1926, 5
  %1928 = getelementptr i8, ptr %1827, i64 %1927
  %1929 = load ptr, ptr %1928, align 8
  %1930 = icmp ne ptr %1929, @nil_typ
  %1931 = icmp ne ptr %1929, null
  %.not16.i1084.i = and i1 %1930, %1931
  br i1 %.not16.i1084.i, label %1932, label %._crit_edge.i1085.i

1932:                                             ; preds = %1925
  %1933 = getelementptr i8, ptr %1928, i64 8
  %1934 = load <2 x i64>, ptr %1933, align 4
  %hash_coef_ptr.i.i18.i1087.i = getelementptr i8, ptr %1929, i64 8
  %tbl_size_ptr.i.i19.i1088.i = getelementptr i8, ptr %1929, i64 16
  %offset_tbl_ptr.i.i20.i1089.i = getelementptr i8, ptr %1929, i64 40
  %1935 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #39
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  %hash_coef.i.i99.i1334.i = load i64, ptr %hash_coef_ptr.i.i18.i1087.i, align 4, !noalias !22
  %tbl_size.i.i100.i1335.i = load i64, ptr %tbl_size_ptr.i.i19.i1088.i, align 4, !noalias !22
  %offset_tbl.i.i101.i1336.i = load ptr, ptr %offset_tbl_ptr.i.i20.i1089.i, align 8, !noalias !22
  %product.i.i.i102.i1337.i = mul i64 %hash_coef.i.i99.i1334.i, 4015701072841558310
  %shifted.i.i.i103.i1338.i = lshr i64 %product.i.i.i102.i1337.i, 32
  %xored.i.i.i104.i1339.i = xor i64 %shifted.i.i.i103.i1338.i, %product.i.i.i102.i1337.i
  %hash.i.i.i105.i1340.i = and i64 %xored.i.i.i104.i1339.i, %tbl_size.i.i100.i1335.i
  %offset_ptr.i.i106.i1341.i = getelementptr i32, ptr %offset_tbl.i.i101.i1336.i, i64 %hash.i.i.i105.i1340.i
  %offset.i.i121.i1342.i = load i32, ptr %offset_ptr.i.i106.i1341.i, align 4, !noalias !476
  %1936 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %1937 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %1938 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1939

1939:                                             ; preds = %.cont.cont.i1363.i, %1932
  %.0566.i1343.i = phi i32 [ 0, %1932 ], [ %1943, %.cont.cont.i1363.i ]
  %.070565.i1344.i = phi i1 [ true, %1932 ], [ %2005, %.cont.cont.i1363.i ]
  %.sroa.0.0564.i1345.i = phi ptr [ %1929, %1932 ], [ %vptr.i142.sroa.speculated.i1366.i, %.cont.cont.i1363.i ]
  %.sroa.17.0561.i1348.i = phi i32 [ %offset.i.i121.i1342.i, %1932 ], [ %offset.i.i154.i1380.i, %.cont.cont.i1363.i ]
  %1940 = phi <2 x i64> [ %1934, %1932 ], [ %2004, %.cont.cont.i1363.i ]
  %1941 = extractelement <2 x i64> %1940, i64 1
  %.sroa.12.0562.i1347.i = inttoptr i64 %1941 to ptr
  %1942 = extractelement <2 x i64> %1940, i64 0
  %.sroa.6.0563.i1346.i = inttoptr i64 %1942 to ptr
  %1943 = add nuw nsw i32 %.0566.i1343.i, 1
  %1944 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564.i1345.i, 0
  %1945 = insertvalue { ptr, ptr, ptr, i32 } %1944, ptr %.sroa.6.0563.i1346.i, 1
  %1946 = insertvalue { ptr, ptr, ptr, i32 } %1945, ptr %.sroa.12.0562.i1347.i, 2
  %1947 = insertvalue { ptr, ptr, ptr, i32 } %1946, i32 %.sroa.17.0561.i1348.i, 3
  %1948 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564.i1345.i)
  %1949 = sext i32 %.sroa.17.0561.i1348.i to i64
  %1950 = getelementptr ptr, ptr %.sroa.0.0564.i1345.i, i64 %1949
  %1951 = getelementptr i8, ptr %1950, i64 64
  %1952 = load ptr, ptr %1951, align 8
  %result.i125.i1349.i = call ptr %1952({ ptr, ptr, ptr, i32 } %1947, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1953 = call i32 %result.i125.i1349.i({ ptr, ptr, ptr, i32 } %1947, { ptr, ptr, ptr, i32 } %1947, ptr nonnull align 8 %0) #7
  br i1 %.070565.i1344.i, label %1954, label %1970

1954:                                             ; preds = %1939
  %1955 = load i32, ptr %1101, align 8
  %1956 = add i32 %1955, -1
  %1957 = and i32 %1956, %1953
  %1958 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1959 = load ptr, ptr %1102, align 8
  %1960 = sext i32 %1957 to i64
  %1961 = shl nsw i64 %1960, 5
  %1962 = getelementptr i8, ptr %1959, i64 %1961
  %1963 = load ptr, ptr %1962, align 8
  %1964 = getelementptr i8, ptr %1962, i64 8
  %1965 = load i160, ptr %1964, align 4
  store ptr %.sroa.0.0564.i1345.i, ptr %1962, align 8
  store i64 %1942, ptr %1964, align 4
  %.sroa_idx157.i1392.i = getelementptr i8, ptr %1962, i64 16
  store i64 %1941, ptr %.sroa_idx157.i1392.i, align 4
  %.sroa_idx158.i1393.i = getelementptr i8, ptr %1962, i64 24
  store i32 %.sroa.17.0561.i1348.i, ptr %.sroa_idx158.i1393.i, align 4
  %1966 = icmp ne ptr %1963, @nil_typ
  %1967 = icmp ne ptr %1963, null
  %.not92.i1394.i = and i1 %1966, %1967
  %extract.i1396.i = lshr i160 %1965, 64
  %1968 = insertelement <2 x i160> poison, i160 %1965, i64 0
  %1969 = insertelement <2 x i160> %1968, i160 %extract.i1396.i, i64 1
  br i1 %.not92.i1394.i, label %.cont.cont.i1363.i, label %2009

1970:                                             ; preds = %1939
  %1971 = add i32 %1953, 2127912214
  %1972 = shl i32 %1953, 12
  %1973 = add i32 %1971, %1972
  %1974 = ashr i32 %1973, 19
  %1975 = xor i32 %1973, %1974
  %1976 = xor i32 %1975, -949894596
  %1977 = add i32 %1976, 374761393
  %1978 = shl i32 %1976, 5
  %1979 = add i32 %1977, %1978
  %1980 = add i32 %1979, -744332180
  %1981 = shl i32 %1979, 9
  %1982 = xor i32 %1980, %1981
  %1983 = add i32 %1982, -42973499
  %1984 = shl i32 %1982, 3
  %1985 = add i32 %1983, %1984
  %1986 = ashr i32 %1985, 16
  %1987 = xor i32 %1985, %1986
  %1988 = xor i32 %1987, -1252372727
  %1989 = load i32, ptr %1101, align 8
  %1990 = add i32 %1989, -1
  %1991 = and i32 %1990, %1988
  %1992 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %1993 = load ptr, ptr %1103, align 8
  %1994 = sext i32 %1991 to i64
  %1995 = shl nsw i64 %1994, 5
  %1996 = getelementptr i8, ptr %1993, i64 %1995
  %1997 = load ptr, ptr %1996, align 8
  %1998 = getelementptr i8, ptr %1996, i64 8
  %1999 = load i160, ptr %1998, align 4
  store ptr %.sroa.0.0564.i1345.i, ptr %1996, align 8
  store i64 %1942, ptr %1998, align 4
  %.sroa_idx161.i1353.i = getelementptr i8, ptr %1996, i64 16
  store i64 %1941, ptr %.sroa_idx161.i1353.i, align 4
  %.sroa_idx162.i1354.i = getelementptr i8, ptr %1996, i64 24
  store i32 %.sroa.17.0561.i1348.i, ptr %.sroa_idx162.i1354.i, align 4
  %2000 = icmp ne ptr %1997, @nil_typ
  %2001 = icmp ne ptr %1997, null
  %.not90.i1355.i = and i1 %2000, %2001
  %extract607.i1357.i = lshr i160 %1999, 64
  %2002 = insertelement <2 x i160> poison, i160 %1999, i64 0
  %2003 = insertelement <2 x i160> %2002, i160 %extract607.i1357.i, i64 1
  br i1 %.not90.i1355.i, label %.cont.cont.i1363.i, label %2009

.cont.cont.i1363.i:                               ; preds = %1970, %1954
  %vptr.i142.sroa.speculated.i1366.i = phi ptr [ %1963, %1954 ], [ %1997, %1970 ]
  %.in323 = phi <2 x i160> [ %1969, %1954 ], [ %2003, %1970 ]
  %2004 = trunc <2 x i160> %.in323 to <2 x i64>
  %2005 = xor i1 %.070565.i1344.i, true
  %hash_coef_ptr.i.i143.i1369.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1366.i, i64 8
  %tbl_size_ptr.i.i144.i1370.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1366.i, i64 16
  %offset_tbl_ptr.i.i145.i1371.i = getelementptr i8, ptr %vptr.i142.sroa.speculated.i1366.i, i64 40
  %hash_coef.i.i146.i1372.i = load i64, ptr %hash_coef_ptr.i.i143.i1369.i, align 4
  %tbl_size.i.i147.i1373.i = load i64, ptr %tbl_size_ptr.i.i144.i1370.i, align 4
  %offset_tbl.i.i148.i1374.i = load ptr, ptr %offset_tbl_ptr.i.i145.i1371.i, align 8
  %product.i.i.i149.i1375.i = mul i64 %hash_coef.i.i146.i1372.i, 4015701072841558310
  %shifted.i.i.i150.i1376.i = lshr i64 %product.i.i.i149.i1375.i, 32
  %xored.i.i.i151.i1377.i = xor i64 %shifted.i.i.i150.i1376.i, %product.i.i.i149.i1375.i
  %hash.i.i.i152.i1378.i = and i64 %xored.i.i.i151.i1377.i, %tbl_size.i.i147.i1373.i
  %offset_ptr.i.i153.i1379.i = getelementptr i32, ptr %offset_tbl.i.i148.i1374.i, i64 %hash.i.i.i152.i1378.i
  %offset.i.i154.i1380.i = load i32, ptr %offset_ptr.i.i153.i1379.i, align 4
  %2006 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %2007 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %2008 = icmp ult i32 %.0566.i1343.i, 99
  br i1 %2008, label %1939, label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1398.i

2009:                                             ; preds = %1970, %1954
  %2010 = phi ptr [ %2, %1970 ], [ %1, %1954 ]
  %2011 = load i32, ptr %1104, align 4
  store i32 %2011, ptr %2010, align 4
  %2012 = add i32 %2011, 1
  %2013 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  store i32 %2012, ptr %1104, align 4
  br label %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1398.i

CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1398.i: ; preds = %.cont.cont.i1363.i, %2009
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %._crit_edge.i1085.i

._crit_edge.i1085.i:                              ; preds = %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit1398.i, %1925
  %2014 = add nuw nsw i32 %.060.i1083.i, 1
  %2015 = icmp slt i32 %2014, %1828
  br i1 %2015, label %1925, label %CuckooMap_insert_keyK_valueV.exit.i63

CuckooMap_insert_keyK_valueV.exit.i63:            ; preds = %._crit_edge.i1085.i, %CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32.exit1067.thread.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit653.thread.i, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.i125, %CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V.exit.thread.i62, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit513.i, %CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i173
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2016 = icmp ult i32 %.0251.i, 999999
  br i1 %2016, label %._crit_edge.i37, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %CuckooMap_insert_keyK_valueV.exit.i63
  %2017 = call i64 @clock()
  br label %2018

2018:                                             ; preds = %._crit_edge2.i72, %.lr.ph.i
  %.2254.i = phi i32 [ 0, %.lr.ph.i ], [ %2146, %._crit_edge2.i72 ]
  %.0141253.i = phi i64 [ 0, %.lr.ph.i ], [ %.2143.i, %._crit_edge2.i72 ]
  %.0144252.i = phi i1 [ true, %.lr.ph.i ], [ %.2146.i, %._crit_edge2.i72 ]
  %.sroa.0117.0.insert.ext.i = zext nneg i32 %.2254.i to i160
  %2019 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext.i, 1
  %2020 = load ptr, ptr %1099, align 8
  %2021 = call i32 %2020({ ptr, i160 } %2019) #7
  %2022 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap) #35
  %2023 = load i32, ptr %1101, align 8
  %2024 = add i32 %2023, -1
  %2025 = and i32 %2024, %2021
  %2026 = load ptr, ptr %1102, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2027 = sext i32 %2025 to i64
  %2028 = shl nsw i64 %2027, 5
  %2029 = getelementptr i8, ptr %2026, i64 %2028
  %2030 = load ptr, ptr %2029, align 8
  %2031 = icmp ne ptr %2030, @nil_typ
  %2032 = icmp ne ptr %2030, null
  %.not44.i.i64 = and i1 %2031, %2032
  br i1 %.not44.i.i64, label %2033, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i65

2033:                                             ; preds = %2018
  %2034 = getelementptr i8, ptr %2029, i64 8
  %2035 = load i64, ptr %2034, align 4
  %.sroa_idx.i716.i = getelementptr i8, ptr %2029, i64 16
  %2036 = load i64, ptr %.sroa_idx.i716.i, align 4
  %2037 = inttoptr i64 %2035 to ptr
  %2038 = inttoptr i64 %2036 to ptr
  %hash_coef_ptr.i.i46.i.i91 = getelementptr i8, ptr %2030, i64 8
  %tbl_size_ptr.i.i47.i.i92 = getelementptr i8, ptr %2030, i64 16
  %offset_tbl_ptr.i.i48.i.i93 = getelementptr i8, ptr %2030, i64 40
  %hash_coef.i.i49.i.i94 = load i64, ptr %hash_coef_ptr.i.i46.i.i91, align 4, !noalias !479
  %tbl_size.i.i50.i.i95 = load i64, ptr %tbl_size_ptr.i.i47.i.i92, align 4, !noalias !479
  %offset_tbl.i.i51.i.i96 = load ptr, ptr %offset_tbl_ptr.i.i48.i.i93, align 8, !noalias !479
  %product.i.i.i52.i.i97 = mul i64 %hash_coef.i.i49.i.i94, 4015701072841558310
  %shifted.i.i.i53.i.i98 = lshr i64 %product.i.i.i52.i.i97, 32
  %xored.i.i.i54.i.i99 = xor i64 %shifted.i.i.i53.i.i98, %product.i.i.i52.i.i97
  %hash.i.i.i55.i.i100 = and i64 %xored.i.i.i54.i.i99, %tbl_size.i.i50.i.i95
  %offset_ptr.i.i56.i.i101 = getelementptr i32, ptr %offset_tbl.i.i51.i.i96, i64 %hash.i.i.i55.i.i100
  %offset.i.i57.i.i102 = load i32, ptr %offset_ptr.i.i56.i.i101, align 4, !noalias !479
  %2039 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2030, 0
  %2040 = insertvalue { ptr, ptr, ptr, i32 } %2039, ptr %2037, 1
  %2041 = insertvalue { ptr, ptr, ptr, i32 } %2040, ptr %2038, 2
  %2042 = insertvalue { ptr, ptr, ptr, i32 } %2041, i32 %offset.i.i57.i.i102, 3
  %2043 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %2044 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2030) #35
  %2045 = sext i32 %offset.i.i57.i.i102 to i64
  %2046 = getelementptr ptr, ptr %2030, i64 %2045
  %2047 = getelementptr i8, ptr %2046, i64 64
  %2048 = load ptr, ptr %2047, align 8
  %result.i.i717.i = call ptr %2048({ ptr, ptr, ptr, i32 } %2042, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2049 = call i32 %result.i.i717.i({ ptr, ptr, ptr, i32 } %2042, { ptr, ptr, ptr, i32 } %2042, ptr nonnull align 8 %0) #7
  %2050 = icmp eq i32 %2049, %2021
  br i1 %2050, label %._crit_edge.i718.i, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i65

._crit_edge.i718.i:                               ; preds = %2033
  %2051 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2052 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2030)
  %2053 = getelementptr i8, ptr %2046, i64 48
  %2054 = load ptr, ptr %2053, align 8
  %result.i59.i.i103 = call ptr %2054({ ptr, ptr, ptr, i32 } %2042, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2055 = call { ptr, i160 } %result.i59.i.i103({ ptr, ptr, ptr, i32 } %2042, { ptr, ptr, ptr, i32 } %2042, ptr nonnull align 8 %0) #7
  %2056 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2057 = load ptr, ptr %1100, align 8
  %2058 = call i1 %2057({ ptr, i160 } %2055, { ptr, i160 } %2019) #7
  br i1 %2058, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i104, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i65

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i65: ; preds = %._crit_edge.i718.i, %2033, %2018
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %2067

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i104: ; preds = %._crit_edge.i718.i
  %2059 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2060 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2030)
  %2061 = getelementptr i8, ptr %2046, i64 56
  %2062 = load ptr, ptr %2061, align 8
  %result.i60.i.i105 = call ptr %2062({ ptr, ptr, ptr, i32 } %2042, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2063 = call { ptr, i160 } %result.i60.i.i105({ ptr, ptr, ptr, i32 } %2042, { ptr, ptr, ptr, i32 } %2042, ptr nonnull align 8 %0) #7
  %.fca.0.extract21.i.i106 = extractvalue { ptr, i160 } %2063, 0
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2064 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2065 = icmp ne ptr %.fca.0.extract21.i.i106, @nil_typ
  %2066 = icmp ne ptr %.fca.0.extract21.i.i106, null
  %.not63.i.i107 = and i1 %2065, %2066
  br i1 %.not63.i.i107, label %CuckooMap_get_keyK.exit.i69, label %2067

2067:                                             ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i104, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.thread.i65
  %2068 = add i32 %2021, 2127912214
  %2069 = shl i32 %2021, 12
  %2070 = add i32 %2068, %2069
  %2071 = ashr i32 %2070, 19
  %2072 = xor i32 %2070, %2071
  %2073 = xor i32 %2072, -949894596
  %2074 = add i32 %2073, 374761393
  %2075 = shl i32 %2073, 5
  %2076 = add i32 %2074, %2075
  %2077 = add i32 %2076, -744332180
  %2078 = shl i32 %2076, 9
  %2079 = xor i32 %2077, %2078
  %2080 = add i32 %2079, -42973499
  %2081 = shl i32 %2079, 3
  %2082 = add i32 %2080, %2081
  %2083 = ashr i32 %2082, 16
  %2084 = xor i32 %2082, %2083
  %2085 = xor i32 %2084, -1252372727
  %2086 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2087 = load i32, ptr %1101, align 8
  %2088 = add i32 %2087, -1
  %2089 = and i32 %2088, %2085
  %2090 = load ptr, ptr %1103, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2091 = sext i32 %2089 to i64
  %2092 = shl nsw i64 %2091, 5
  %2093 = getelementptr i8, ptr %2090, i64 %2092
  %2094 = load ptr, ptr %2093, align 8
  %2095 = icmp ne ptr %2094, @nil_typ
  %2096 = icmp ne ptr %2094, null
  %.not44.i748.i = and i1 %2095, %2096
  br i1 %.not44.i748.i, label %2097, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772.i

2097:                                             ; preds = %2067
  %2098 = getelementptr i8, ptr %2093, i64 8
  %2099 = load i64, ptr %2098, align 4
  %.sroa_idx.i752.i = getelementptr i8, ptr %2093, i64 16
  %2100 = load i64, ptr %.sroa_idx.i752.i, align 4
  %2101 = inttoptr i64 %2099 to ptr
  %2102 = inttoptr i64 %2100 to ptr
  %hash_coef_ptr.i.i46.i753.i = getelementptr i8, ptr %2094, i64 8
  %tbl_size_ptr.i.i47.i754.i = getelementptr i8, ptr %2094, i64 16
  %offset_tbl_ptr.i.i48.i755.i = getelementptr i8, ptr %2094, i64 40
  %hash_coef.i.i49.i756.i = load i64, ptr %hash_coef_ptr.i.i46.i753.i, align 4, !noalias !482
  %tbl_size.i.i50.i757.i = load i64, ptr %tbl_size_ptr.i.i47.i754.i, align 4, !noalias !482
  %offset_tbl.i.i51.i758.i = load ptr, ptr %offset_tbl_ptr.i.i48.i755.i, align 8, !noalias !482
  %product.i.i.i52.i759.i = mul i64 %hash_coef.i.i49.i756.i, 4015701072841558310
  %shifted.i.i.i53.i760.i = lshr i64 %product.i.i.i52.i759.i, 32
  %xored.i.i.i54.i761.i = xor i64 %shifted.i.i.i53.i760.i, %product.i.i.i52.i759.i
  %hash.i.i.i55.i762.i = and i64 %xored.i.i.i54.i761.i, %tbl_size.i.i50.i757.i
  %offset_ptr.i.i56.i763.i = getelementptr i32, ptr %offset_tbl.i.i51.i758.i, i64 %hash.i.i.i55.i762.i
  %offset.i.i57.i764.i = load i32, ptr %offset_ptr.i.i56.i763.i, align 4, !noalias !482
  %2103 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2094, 0
  %2104 = insertvalue { ptr, ptr, ptr, i32 } %2103, ptr %2101, 1
  %2105 = insertvalue { ptr, ptr, ptr, i32 } %2104, ptr %2102, 2
  %2106 = insertvalue { ptr, ptr, ptr, i32 } %2105, i32 %offset.i.i57.i764.i, 3
  %2107 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %2108 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2094) #35
  %2109 = sext i32 %offset.i.i57.i764.i to i64
  %2110 = getelementptr ptr, ptr %2094, i64 %2109
  %2111 = getelementptr i8, ptr %2110, i64 64
  %2112 = load ptr, ptr %2111, align 8
  %result.i.i765.i = call ptr %2112({ ptr, ptr, ptr, i32 } %2106, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2113 = call i32 %result.i.i765.i({ ptr, ptr, ptr, i32 } %2106, { ptr, ptr, ptr, i32 } %2106, ptr nonnull align 8 %0) #7
  %2114 = icmp eq i32 %2113, %2021
  br i1 %2114, label %._crit_edge.i766.i, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772.i

._crit_edge.i766.i:                               ; preds = %2097
  %2115 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2116 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2094)
  %2117 = getelementptr i8, ptr %2110, i64 48
  %2118 = load ptr, ptr %2117, align 8
  %result.i59.i767.i = call ptr %2118({ ptr, ptr, ptr, i32 } %2106, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2119 = call { ptr, i160 } %result.i59.i767.i({ ptr, ptr, ptr, i32 } %2106, { ptr, ptr, ptr, i32 } %2106, ptr nonnull align 8 %0) #7
  %2120 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2121 = load ptr, ptr %1100, align 8
  %2122 = call i1 %2121({ ptr, i160 } %2119, { ptr, i160 } %2019) #7
  br i1 %2122, label %2123, label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772.i

2123:                                             ; preds = %._crit_edge.i766.i
  %2124 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2125 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %2094)
  %2126 = getelementptr i8, ptr %2110, i64 56
  %2127 = load ptr, ptr %2126, align 8
  %result.i60.i769.i = call ptr %2127({ ptr, ptr, ptr, i32 } %2106, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2128 = call { ptr, i160 } %result.i60.i769.i({ ptr, ptr, ptr, i32 } %2106, { ptr, ptr, ptr, i32 } %2106, ptr nonnull align 8 %0) #7
  %.fca.0.extract21.i770.i = extractvalue { ptr, i160 } %2128, 0
  %.fca.1.extract22.i771.i = extractvalue { ptr, i160 } %2128, 1
  br label %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772.i

CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772.i: ; preds = %2123, %._crit_edge.i766.i, %2097, %2067
  %.reg2mem43.sroa.3.077.i749.i = phi i160 [ %.fca.1.extract22.i771.i, %2123 ], [ poison, %._crit_edge.i766.i ], [ poison, %2067 ], [ poison, %2097 ]
  %2129 = phi ptr [ %.fca.0.extract21.i770.i, %2123 ], [ @nil_typ, %._crit_edge.i766.i ], [ @nil_typ, %2067 ], [ @nil_typ, %2097 ]
  %.reload40.fca.0.insert.i750.i = insertvalue { ptr, i160 } poison, ptr %2129, 0
  %.reload40.fca.1.insert.i751.i = insertvalue { ptr, i160 } %.reload40.fca.0.insert.i750.i, i160 %.reg2mem43.sroa.3.077.i749.i, 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2130 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull @CuckooMap)
  %2131 = icmp ne ptr %2129, @nil_typ
  %2132 = icmp ne ptr %2129, null
  %.not65.not.not.i.i66 = and i1 %2131, %2132
  %cond.fr.i.i67 = freeze i1 %.not65.not.not.i.i66
  %spec.select.i.i68 = select i1 %cond.fr.i.i67, ptr %2129, ptr @nil_typ
  br label %CuckooMap_get_keyK.exit.i69

CuckooMap_get_keyK.exit.i69:                      ; preds = %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i104
  %.pn.i.i70 = phi { ptr, i160 } [ %2063, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i104 ], [ %.reload40.fca.1.insert.i751.i, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772.i ]
  %2133 = phi ptr [ %.fca.0.extract21.i.i106, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit.i104 ], [ %spec.select.i.i68, %CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil.exit772.i ]
  %2134 = icmp ne ptr %2133, @nil_typ
  %2135 = icmp ne ptr %2133, null
  %.not150.i = and i1 %2134, %2135
  br i1 %.not150.i, label %2136, label %._crit_edge.lr.ph.i.i

2136:                                             ; preds = %CuckooMap_get_keyK.exit.i69
  %.fca.1.extract..sroa.354.0106.i.i89 = extractvalue { ptr, i160 } %.pn.i.i70, 1
  %.sroa.2.8.extract.trunc.i90 = trunc i160 %.fca.1.extract..sroa.354.0106.i.i89 to i32
  %2137 = sext i32 %.sroa.2.8.extract.trunc.i90 to i64
  %2138 = add i64 %.0141253.i, %2137
  br label %._crit_edge2.i72

._crit_edge.lr.ph.i.i:                            ; preds = %CuckooMap_get_keyK.exit.i69
  %result.i161.i = call noalias align 64 dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %2139 = load <55 x i8>, ptr @gvbps_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  store <55 x i8> %2139, ptr %result.i161.i, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2140 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %2141 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i786.i = call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(55) %result.i.i786.i, ptr noundef nonnull align 64 dereferenceable(55) %result.i161.i, i64 55, i1 false)
  %2142 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2143 = getelementptr i8, ptr %result.i.i786.i, i64 55
  store i8 0, ptr %2143, align 1
  %puts.i.i71 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i786.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2144 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2145 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2254.i) #17
  br label %._crit_edge2.i72

._crit_edge2.i72:                                 ; preds = %._crit_edge.lr.ph.i.i, %2136
  %.2146.i = phi i1 [ %.0144252.i, %2136 ], [ false, %._crit_edge.lr.ph.i.i ]
  %.2143.i = phi i64 [ %2138, %2136 ], [ %.0141253.i, %._crit_edge.lr.ph.i.i ]
  %2146 = add nuw nsw i32 %.2254.i, 1
  %2147 = icmp ult i32 %.2254.i, 999999
  br i1 %2147, label %2018, label %._crit_edge.lr.ph.i802.i

._crit_edge.lr.ph.i802.i:                         ; preds = %._crit_edge2.i72
  %2148 = call i64 @clock()
  %result.i167.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i167.i, align 32
  %2149 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2150 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %2151 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i801.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i801.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i167.i, i64 18, i1 false)
  %2152 = sub i64 %2148, %2017
  %2153 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2154 = getelementptr i8, ptr %result.i.i801.i, i64 18
  store i8 0, ptr %2154, align 1
  %puts.i382.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i801.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i98.i.i73 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i98.i.i73, align 16
  %result.i.i356.i.i74 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i356.i.i74, ptr noundef nonnull align 16 dereferenceable(14) %result.i98.i.i73, i64 14, i1 false)
  %puts.i.i.i75 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i356.i.i74)
  %2155 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 1000000) #17
  %result.i104.i.i76 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i104.i.i76, align 16
  %result.i.i370.i.i77 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i370.i.i77, ptr noundef nonnull align 16 dereferenceable(14) %result.i104.i.i76, i64 14, i1 false)
  %puts.i294.i.i78 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i370.i.i77)
  %2156 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2152) #17
  %result.i110.i.i79 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i110.i.i79, align 4
  %result.i.i389.i.i80 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i389.i.i80, ptr noundef nonnull align 4 dereferenceable(3) %result.i110.i.i79, i64 3, i1 false)
  %puts.i314.i.i81 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i.i80)
  %2157 = icmp sgt i64 %2152, 0
  br i1 %2157, label %2158, label %._crit_edge.lr.ph.i288

2158:                                             ; preds = %._crit_edge.lr.ph.i802.i
  %2159 = mul i64 %2152, 1000000
  %2160 = sdiv i64 %2159, 1000000
  br label %._crit_edge.lr.ph.i288

._crit_edge.lr.ph.i288:                           ; preds = %._crit_edge.lr.ph.i802.i, %2158
  %.0.i.i82 = phi i64 [ %2160, %2158 ], [ 0, %._crit_edge.lr.ph.i802.i ]
  %result.i115.i.i83 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i115.i.i83, align 16
  %result.i.i408.i.i84 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i408.i.i84, ptr noundef nonnull align 16 dereferenceable(15) %result.i115.i.i83, i64 15, i1 false)
  %puts.i334.i.i85 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i.i84)
  %2161 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i.i82) #17
  %result.i121.i.i86 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i121.i.i86, align 4
  %result.i.i427.i.i87 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i427.i.i87, ptr noundef nonnull align 4 dereferenceable(3) %result.i121.i.i86, i64 3, i1 false)
  %puts.i354.i.i88 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i.i87)
  %.not.i = icmp eq i64 %.2143.i, 500000500000
  %result.i171.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i171.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2162 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %2163 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i820.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i820.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i171.i, i64 18, i1 false)
  %spec.select.i = select i1 %.not.i, i1 %.2146.i, i1 false
  %2164 = getelementptr i8, ptr %result.i.i820.i, i64 18
  store i8 0, ptr %2164, align 1
  %puts.i402.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i820.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %..i = select i1 %spec.select.i, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %2165 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2166 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %2167 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i839.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <4 x i8> %..i, ptr %result.i.i839.i, align 1
  %2168 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2169 = getelementptr i8, ptr %result.i.i839.i, i64 4
  store i8 0, ptr %2169, align 1
  %puts.i422.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i839.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @benchmark_get_random_hit(i32 noundef 1000000)
  call void @benchmark_get_random_miss(i32 noundef 1000000)
  call void @benchmark_remove_random(i32 noundef 1000000)
  %result.i179 = call noalias align 32 dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <27 x i8> <i8 45, i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %result.i179, align 32
  %2170 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2171 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #35
  %2172 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #35
  %result.i.i287 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(27) %result.i.i287, ptr noundef nonnull align 32 dereferenceable(27) %result.i179, i64 27, i1 false)
  %2173 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %2174 = getelementptr i8, ptr %result.i.i287, i64 27
  store i8 0, ptr %2174, align 1
  %puts.i251 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i287)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_bool_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_bool_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_bool_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #8

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_any_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Object(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i8_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i8_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i8_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i32_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i32_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i32, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i32 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i32_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  store i32 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i64_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i64_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i64_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i128_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 16, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i128_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %.sroa.2.sroa.0.0.copyload = load i128, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i128 %.sroa.2.sroa.0.0.copyload to i160
  %3 = insertvalue { ptr, i160 } { ptr @i128_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i128_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i128
  store i128 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_f64_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_f64_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_f64_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nil_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nil_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #0 {
  ret { ptr, i160 } { ptr @nil_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nil_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nothing_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nothing_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #0 {
  ret { ptr, i160 } { ptr @nothing_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nothing_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_coroutine_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_coroutine_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @coroutine_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_coroutine_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_function_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_function_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_function_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_buffer_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_buffer_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @buffer_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define { ptr, i160 } @_box_tuple_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #9 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = getelementptr i8, ptr %1, i64 8
  %4 = load i64, ptr %3, align 4
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %13, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %19, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem14.0.i = phi i64 [ %20, %.lr.ph.i ], [ 1, %2 ]
  %.in.reg2mem.0.i = phi i64 [ %22, %.lr.ph.i ], [ %4, %2 ]
  %6 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { i64, i64 } %9(ptr nonnull align 8 %6) #7
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = tail call i64 @llvm.umax.i64(i64 %12, i64 %.reg2mem20.010.reg2mem.0.i)
  %14 = urem i64 %.reg2mem22.011.reg2mem.0.i, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %11, %.reg2mem22.011.reg2mem.0.i
  %19 = add i64 %18, %17
  %20 = add i64 %.reg2mem14.0.i, 1
  %21 = getelementptr ptr, ptr %1, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %2
  %.reg2mem22.0.lcssa.reg2mem.0.i = phi i64 [ 0, %2 ], [ %19, %.lr.ph.i ]
  %.reg2mem20.0.lcssa.reg2mem.0.i = phi i64 [ 1, %2 ], [ %13, %.lr.ph.i ]
  %24 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0.i, %.reg2mem20.0.lcssa.reg2mem.0.i
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0.i, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %27, %.reg2mem22.0.lcssa.reg2mem.0.i
  %29 = icmp slt i64 %28, 17
  br i1 %29, label %31, label %30

30:                                               ; preds = %_data_size_tuple_typ.exit
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  tail call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %result.i4, ptr nocapture nofree readonly align 1 %0, i64 %28, i1 noundef false) #35
  store ptr %result.i4, ptr %.sroa.2, align 8
  br label %32

31:                                               ; preds = %_data_size_tuple_typ.exit
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %28, i1 noundef false) #35
  br label %32

32:                                               ; preds = %31, %30
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %33 = insertvalue { ptr, i160 } { ptr @tuple_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %33
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define void @_unbox_tuple_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #9 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %3, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %3 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %3 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8) #7
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = add i64 %20, %19
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %3
  %.reg2mem22.0.lcssa.reg2mem.0.i = phi i64 [ 0, %3 ], [ %21, %.lr.ph.i ]
  %.reg2mem20.0.lcssa.reg2mem.0.i = phi i64 [ 1, %3 ], [ %15, %.lr.ph.i ]
  %26 = trunc i160 %.fca.1.extract to i64
  %27 = inttoptr i64 %26 to ptr
  %28 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0.i, %.reg2mem20.0.lcssa.reg2mem.0.i
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0.i, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %31, %.reg2mem22.0.lcssa.reg2mem.0.i
  %33 = icmp slt i64 %32, 17
  %34 = select i1 %33, ptr %.fca.1.gep, ptr %27
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %34, i64 %32, i1 noundef false) #35
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define { ptr, i160 } @_box_union_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #9 {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @union_typ, ptr %3, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %2 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %2 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8) #7
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 noundef %14, i64 noundef %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = tail call i64 @llvm.umax.i64(i64 noundef %20, i64 noundef %19)
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %21, 32
  %spec.select12.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select12.i, %21
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %2, %._crit_edge.i
  %.reg2mem20.0.lcssa.reg2mem.011.i = phi i64 [ 1, %2 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %2 ], [ %26, %._crit_edge.i ]
  %27 = urem i64 %final_size.i, %.reg2mem20.0.lcssa.reg2mem.011.i
  %28 = icmp eq i64 %27, 0
  %29 = sub i64 %.reg2mem20.0.lcssa.reg2mem.011.i, %27
  %30 = select i1 %28, i64 0, i64 %29
  %31 = add i64 %30, %final_size.i
  %32 = icmp eq i64 %31, 32
  br i1 %32, label %._crit_edge, label %33

._crit_edge:                                      ; preds = %33, %_data_size_union_typ.exit
  %.reg2mem10.0 = phi ptr [ %3, %_data_size_union_typ.exit ], [ %4, %33 ]
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.reg2mem10.0, ptr nocapture nofree readonly align 1 %0, i64 %31, i1 noundef false) #35
  %.pre = load ptr, ptr %3, align 8
  br label %36

33:                                               ; preds = %_data_size_union_typ.exit
  %34 = icmp slt i64 %31, 17
  br i1 %34, label %._crit_edge, label %35

35:                                               ; preds = %33
  %result.i5 = tail call noalias ptr @bump_malloc_inner(i64 noundef %31, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  tail call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %result.i5, ptr nocapture nofree readonly align 1 %0, i64 %31, i1 noundef false) #35
  store ptr %result.i5, ptr %4, align 8
  br label %36

36:                                               ; preds = %35, %._crit_edge
  %37 = phi ptr [ @union_typ, %35 ], [ %.pre, %._crit_edge ]
  %38 = insertvalue { ptr, i160 } undef, ptr %37, 0
  %39 = load i160, ptr %4, align 8
  %40 = insertvalue { ptr, i160 } %38, i160 %39, 1
  ret { ptr, i160 } %40
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Entry(ptr nocapture nofree readonly align 8 %0) #10 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 0
  %21 = extractvalue { i64, i64 } %result.i1, 1
  %22 = tail call i64 @llvm.umax.i64(i64 %8, i64 %21)
  %23 = tail call i64 @llvm.umax.i64(i64 %22, i64 8)
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %29, %33
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_init_keyK_valueV_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_primary_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_to_pair_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_init_keyK_valueV_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #2 {
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !485
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !485
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !485
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !485
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract12) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract12, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  tail call void %13(ptr %.fca.1.extract13, { ptr, i160 } %3) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract12) #35
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract13, { ptr, i160 } %4) #36
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract12) #35
  %20 = getelementptr i8, ptr %9, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  tail call void %23(ptr %.fca.1.extract13, i32 %5) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !488
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !488
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !488
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !488
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #37
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !491
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !491
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !491
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !491
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 32
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #37
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Entry_primary_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !494
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !494
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !494
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !494
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #37
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Entry_to_pair_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract27, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !497
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !497
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !497
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !497
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract27, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract28) #37
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #35
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call { ptr, i160 } %14(ptr %.fca.1.extract28) #37
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #35
  %17 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract28) #5
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #35
  %19 = getelementptr i8, ptr %6, i64 8
  %20 = load ptr, ptr %19, align 8
  %result.i31 = tail call ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract28) #5
  %21 = load ptr, ptr %result.i, align 8, !alias.scope !500
  %22 = getelementptr i8, ptr %21, i64 72
  %23 = load ptr, ptr %22, align 8, !alias.scope !500
  %result.i.i = tail call { i64, i64 } %23(ptr nocapture nofree nonnull readonly %result.i) #5, !alias.scope !500
  %24 = extractvalue { i64, i64 } %result.i.i, 0
  %25 = extractvalue { i64, i64 } %result.i.i, 1
  %26 = urem i64 16, %25
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 %25, %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %24, 16
  %31 = add i64 %30, %29
  %32 = load ptr, ptr %result.i31, align 8, !alias.scope !500
  %33 = getelementptr i8, ptr %32, i64 72
  %34 = load ptr, ptr %33, align 8, !alias.scope !500
  %result.i1.i = tail call { i64, i64 } %34(ptr nocapture nofree nonnull readonly %result.i31) #5, !alias.scope !500
  %35 = extractvalue { i64, i64 } %result.i1.i, 0
  %36 = extractvalue { i64, i64 } %result.i1.i, 1
  %37 = tail call i64 @llvm.umax.i64(i64 %25, i64 %36)
  %38 = tail call i64 @llvm.umax.i64(i64 %37, i64 8)
  %39 = urem i64 %31, %36
  %40 = icmp eq i64 %39, 0
  %41 = sub i64 %36, %39
  %42 = select i1 %40, i64 0, i64 %41
  %43 = add i64 %35, %31
  %44 = add i64 %43, %42
  %45 = urem i64 %44, %38
  %46 = icmp eq i64 %45, 0
  %47 = sub i64 %38, %45
  %48 = select i1 %46, i64 0, i64 %47
  %49 = add i64 %48, %44
  %result.i33 = tail call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %49, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i33, align 8
  %50 = getelementptr inbounds i8, ptr %result.i33, i64 8
  store ptr %result.i31, ptr %50, align 8
  %51 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i33) #35
  %52 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #35
  %53 = load ptr, ptr %7, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = tail call { ptr, i160 } %54(ptr %.fca.1.extract28) #37
  %56 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #35
  %57 = load ptr, ptr %12, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = tail call { ptr, i160 } %58(ptr %.fca.1.extract28) #37
  %60 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Pair, ptr undef, ptr undef, i32 undef }, ptr %result.i33, 1
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr undef, 2
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 10, 3
  %63 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #35
  %64 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.fca.0.extract27) #35
  %65 = load ptr, ptr %result.i, align 8
  %66 = getelementptr i8, ptr %65, i64 72
  %67 = load ptr, ptr %66, align 8
  %result.i.i64 = tail call { i64, i64 } %67(ptr nocapture nofree nonnull readonly %result.i) #5
  %68 = extractvalue { i64, i64 } %result.i.i64, 1
  %69 = urem i64 16, %68
  %70 = icmp eq i64 %69, 0
  %reass.sub = sub i64 %68, %69
  %71 = add i64 %reass.sub, 16
  %72 = select i1 %70, i64 16, i64 %71
  %73 = getelementptr i8, ptr %result.i33, i64 %72
  %74 = getelementptr i8, ptr %65, i64 64
  %75 = load ptr, ptr %74, align 8
  tail call void %75({ ptr, i160 } %55, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %73) #1
  %76 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #35
  %77 = load ptr, ptr %result.i33, align 8
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr i8, ptr %78, i64 72
  %80 = load ptr, ptr %79, align 8
  %result.i.i65 = tail call { i64, i64 } %80(ptr nocapture nofree nonnull readonly %77) #5
  %81 = extractvalue { i64, i64 } %result.i.i65, 0
  %82 = extractvalue { i64, i64 } %result.i.i65, 1
  %83 = urem i64 16, %82
  %84 = icmp eq i64 %83, 0
  %85 = sub i64 %82, %83
  %86 = select i1 %84, i64 0, i64 %85
  %87 = add i64 %81, 16
  %88 = add i64 %87, %86
  %89 = load ptr, ptr %50, align 8
  %90 = load ptr, ptr %89, align 8
  %91 = getelementptr i8, ptr %90, i64 72
  %92 = load ptr, ptr %91, align 8
  %result.i1.i66 = tail call { i64, i64 } %92(ptr nocapture nofree nonnull readonly %89) #5
  %93 = extractvalue { i64, i64 } %result.i1.i66, 1
  %94 = urem i64 %88, %93
  %95 = icmp eq i64 %94, 0
  %96 = sub i64 %93, %94
  %97 = select i1 %95, i64 0, i64 %96
  %98 = getelementptr i8, ptr %result.i33, i64 %88
  %99 = getelementptr i8, ptr %98, i64 %97
  %100 = getelementptr i8, ptr %90, i64 64
  %101 = load ptr, ptr %100, align 8
  tail call void %101({ ptr, i160 } %59, ptr nocapture nofree nonnull readonly %89, ptr nocapture nofree writeonly %99) #1
  ret { ptr, ptr, ptr, i32 } %62
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_value(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 0
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 20
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i1 = tail call { i64, i64 } %18(ptr nocapture nofree nonnull readonly %15) #5
  %19 = extractvalue { i64, i64 } %result.i1, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = tail call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly %15) #5
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_value(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  tail call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %16, ptr nocapture nofree writeonly %26) #1
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_key(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 20, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 20
  %10 = select i1 %8, i64 20, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = tail call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly %2) #5
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_key(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  tail call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %3, ptr nocapture nofree writeonly %12) #1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_primary_hash(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_primary_hash(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMap(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 64, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMap_field_CuckooMap_6(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @CuckooMap_B__Self_max_displacements_(ptr nocapture nofree %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %0) #35
  ret ptr @CuckooMap__Self_max_displacements_
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_hash1_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_hash2_from_primary_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index1_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_index2_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_resize_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 528
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B__index_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 544
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 552
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 560
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 568
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 576
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 584
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 592
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 600
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 608
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 616
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMap_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 624
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i32 @CuckooMap__Self_max_displacements_(ptr nocapture nofree readnone %0) #0 {
  ret i32 100
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMap_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !503
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !503
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !503
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !503
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract8, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3) #36
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %14 = getelementptr i8, ptr %8, i64 64
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, { ptr } %4) #36
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %19 = getelementptr i8, ptr %8, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 8) #36
  %result.i = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %24 = getelementptr i8, ptr %8, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %27(ptr %.fca.1.extract, { ptr } %28) #36
  %result.i9 = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %30 = getelementptr i8, ptr %8, i64 32
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr } undef, ptr %result.i9, 0
  tail call void %33(ptr %.fca.1.extract, { ptr } %34) #36
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %36 = getelementptr i8, ptr %8, i64 48
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  tail call void %39(ptr %.fca.1.extract, i32 0) #36
  ret void
}

define i32 @CuckooMap_hash1_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) {
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !506
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !506
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !506
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !506
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract6) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract6, i64 %6
  %8 = getelementptr i8, ptr %7, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr } %10(ptr %.fca.1.extract7) #37
  %.fca.0.extract = extractvalue { ptr } %11, 0
  %12 = tail call i32 %.fca.0.extract({ ptr, i160 } %3)
  ret i32 %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @CuckooMap_hash2_from_primary_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #0 {
  %5 = add i32 %3, 2127912214
  %6 = shl i32 %3, 12
  %7 = add i32 %5, %6
  %8 = ashr i32 %7, 19
  %9 = xor i32 %7, %8
  %10 = xor i32 %9, -949894596
  %11 = add i32 %10, 374761393
  %12 = shl i32 %10, 5
  %13 = add i32 %11, %12
  %14 = add i32 %13, -744332180
  %15 = shl i32 %13, 9
  %16 = xor i32 %14, %15
  %17 = add i32 %16, -42973499
  %18 = shl i32 %16, 3
  %19 = add i32 %17, %18
  %20 = ashr i32 %19, 16
  %21 = xor i32 %19, %20
  %22 = xor i32 %21, -1252372727
  ret i32 %22
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @CuckooMap_index1_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !509
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !509
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !509
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !509
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract) #37
  %12 = add i32 %11, -1
  %13 = and i32 %12, %3
  ret i32 %13
}

; Function Attrs: nounwind
define i32 @CuckooMap_index2_primary_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !512
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !512
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !512
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !512
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i.i, 3
  %9 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %9, align 8
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %9) #35
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract) #35
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 96
  %15 = load ptr, ptr %14, align 8
  %16 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %16, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly %16) #16
  %17 = call i32 %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 dereferenceable(8) %9, i32 %3) #7
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = getelementptr i8, ptr %13, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call i32 %21(ptr %.fca.1.extract) #37
  %23 = add i32 %22, -1
  %24 = and i32 %23, %17
  ret i32 %24
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMap_place_entry_or_get_failed_entry_to_insertEntryK._V({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
.lr.ph:
  %4 = alloca {}, align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca i32, align 4
  %8 = alloca [1 x ptr], align 8
  %9 = alloca { ptr }, align 8
  %10 = alloca i32, align 4
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !515
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !515
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !515
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !515
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i96 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i97 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i98 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i99 = load i64, ptr %hash_coef_ptr.i.i96, align 4, !noalias !22
  %tbl_size.i.i100 = load i64, ptr %tbl_size_ptr.i.i97, align 4, !noalias !22
  %offset_tbl.i.i101 = load ptr, ptr %offset_tbl_ptr.i.i98, align 8, !noalias !22
  %product.i.i.i102 = mul i64 %hash_coef.i.i99, 4015701072841558310
  %shifted.i.i.i103 = lshr i64 %product.i.i.i102, 32
  %xored.i.i.i104 = xor i64 %shifted.i.i.i103, %product.i.i.i102
  %hash.i.i.i105 = and i64 %xored.i.i.i104, %tbl_size.i.i100
  %offset_ptr.i.i106 = getelementptr i32, ptr %offset_tbl.i.i101, i64 %hash.i.i.i105
  %offset.i.i121 = load i32, ptr %offset_ptr.i.i106, align 4, !noalias !518
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8) #39
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract8, i64 %12
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8) #39
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %4) #35
  %.fca.2.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract9, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract10, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i, 3
  %22 = getelementptr i8, ptr %13, i64 112
  %23 = getelementptr i8, ptr %13, i64 32
  %24 = getelementptr i8, ptr %13, i64 104
  %25 = getelementptr i8, ptr %13, i64 24
  %26 = insertelement <2 x ptr> poison, ptr %.fca.1.extract, i64 0
  %27 = insertelement <2 x ptr> %26, ptr %.fca.2.extract, i64 1
  br label %28

28:                                               ; preds = %.lr.ph, %.cont.cont
  %.0566 = phi i32 [ 0, %.lr.ph ], [ %30, %.cont.cont ]
  %.070565 = phi i1 [ true, %.lr.ph ], [ %95, %.cont.cont ]
  %.sroa.0.0564 = phi ptr [ %.fca.0.extract, %.lr.ph ], [ %vptr.i142.sroa.speculated, %.cont.cont ]
  %.sroa.17.0561 = phi i32 [ %offset.i.i121, %.lr.ph ], [ %offset.i.i154, %.cont.cont ]
  %29 = phi <2 x ptr> [ %27, %.lr.ph ], [ %94, %.cont.cont ]
  %30 = add nuw nsw i32 %.0566, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.sroa.0.0564, 0
  %32 = extractelement <2 x ptr> %29, i64 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %32, 1
  %34 = extractelement <2 x ptr> %29, i64 1
  %35 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %34, 2
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, i32 %.sroa.17.0561, 3
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %.sroa.0.0564)
  %38 = sext i32 %.sroa.17.0561 to i64
  %39 = getelementptr ptr, ptr %.sroa.0.0564, i64 %38
  %40 = getelementptr i8, ptr %39, i64 64
  %41 = load ptr, ptr %40, align 8
  %result.i125 = call ptr %41({ ptr, ptr, ptr, i32 } %36, ptr nocapture nofree noundef nonnull readonly %4) #16
  %42 = call i32 %result.i125({ ptr, ptr, ptr, i32 } %36, { ptr, ptr, ptr, i32 } %36, ptr nonnull align 8 %4) #7
  br i1 %.070565, label %43, label %68

43:                                               ; preds = %28
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %46 = load ptr, ptr %24, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i126 = call ptr %46({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #16
  %47 = call i32 %result.i126({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 dereferenceable(8) %5, i32 %42) #7
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %49 = load ptr, ptr %25, align 8
  %50 = load ptr, ptr %49, align 8
  %51 = call { ptr } %50(ptr %.fca.1.extract9) #37
  %.fca.0.extract60 = extractvalue { ptr } %51, 0
  %52 = sext i32 %47 to i64
  %53 = shl nsw i64 %52, 5
  %54 = getelementptr i8, ptr %.fca.0.extract60, i64 %53
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr i8, ptr %54, i64 8
  %57 = load i160, ptr %56, align 4
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %59 = call { ptr } %50(ptr %.fca.1.extract9) #37
  %.fca.0.extract58 = extractvalue { ptr } %59, 0
  %60 = getelementptr i8, ptr %.fca.0.extract58, i64 %53
  store ptr %.sroa.0.0564, ptr %60, align 8
  %61 = getelementptr i8, ptr %60, i64 8
  %62 = ptrtoint ptr %32 to i64
  %63 = ptrtoint ptr %34 to i64
  store i64 %62, ptr %61, align 4
  %.sroa_idx157 = getelementptr i8, ptr %60, i64 16
  store i64 %63, ptr %.sroa_idx157, align 4
  %.sroa_idx158 = getelementptr i8, ptr %60, i64 24
  store i32 %.sroa.17.0561, ptr %.sroa_idx158, align 4
  %64 = icmp ne ptr %55, @nil_typ
  %65 = icmp ne ptr %55, null
  %.not92 = and i1 %64, %65
  %extract = lshr i160 %57, 64
  %66 = insertelement <2 x i160> poison, i160 %57, i64 0
  %67 = insertelement <2 x i160> %66, i160 %extract, i64 1
  br i1 %.not92, label %.cont.cont, label %99

68:                                               ; preds = %28
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %71 = load ptr, ptr %22, align 8
  store ptr @i32_typ, ptr %9, align 8
  %result.i127 = call ptr %71({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %9) #16
  %72 = call i32 %result.i127({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 dereferenceable(8) %8, i32 %42) #7
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %74 = load ptr, ptr %23, align 8
  %75 = load ptr, ptr %74, align 8
  %76 = call { ptr } %75(ptr %.fca.1.extract9) #37
  %.fca.0.extract53 = extractvalue { ptr } %76, 0
  %77 = sext i32 %72 to i64
  %78 = shl nsw i64 %77, 5
  %79 = getelementptr i8, ptr %.fca.0.extract53, i64 %78
  %80 = load ptr, ptr %79, align 8
  %81 = getelementptr i8, ptr %79, i64 8
  %82 = load i160, ptr %81, align 4
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %84 = call { ptr } %75(ptr %.fca.1.extract9) #37
  %.fca.0.extract51 = extractvalue { ptr } %84, 0
  %85 = getelementptr i8, ptr %.fca.0.extract51, i64 %78
  store ptr %.sroa.0.0564, ptr %85, align 8
  %86 = getelementptr i8, ptr %85, i64 8
  %87 = ptrtoint ptr %32 to i64
  %88 = ptrtoint ptr %34 to i64
  store i64 %87, ptr %86, align 4
  %.sroa_idx161 = getelementptr i8, ptr %85, i64 16
  store i64 %88, ptr %.sroa_idx161, align 4
  %.sroa_idx162 = getelementptr i8, ptr %85, i64 24
  store i32 %.sroa.17.0561, ptr %.sroa_idx162, align 4
  %89 = icmp ne ptr %80, @nil_typ
  %90 = icmp ne ptr %80, null
  %.not90 = and i1 %89, %90
  %extract607 = lshr i160 %82, 64
  %91 = insertelement <2 x i160> poison, i160 %82, i64 0
  %92 = insertelement <2 x i160> %91, i160 %extract607, i64 1
  br i1 %.not90, label %.cont.cont, label %99

.cont.cont:                                       ; preds = %68, %43
  %vptr.i142.sroa.speculated = phi ptr [ %55, %43 ], [ %80, %68 ]
  %.in = phi <2 x i160> [ %67, %43 ], [ %92, %68 ]
  %93 = trunc <2 x i160> %.in to <2 x i64>
  %94 = inttoptr <2 x i64> %93 to <2 x ptr>
  %95 = xor i1 %.070565, true
  %hash_coef_ptr.i.i143 = getelementptr i8, ptr %vptr.i142.sroa.speculated, i64 8
  %tbl_size_ptr.i.i144 = getelementptr i8, ptr %vptr.i142.sroa.speculated, i64 16
  %offset_tbl_ptr.i.i145 = getelementptr i8, ptr %vptr.i142.sroa.speculated, i64 40
  %hash_coef.i.i146 = load i64, ptr %hash_coef_ptr.i.i143, align 4
  %tbl_size.i.i147 = load i64, ptr %tbl_size_ptr.i.i144, align 4
  %offset_tbl.i.i148 = load ptr, ptr %offset_tbl_ptr.i.i145, align 8
  %product.i.i.i149 = mul i64 %hash_coef.i.i146, 4015701072841558310
  %shifted.i.i.i150 = lshr i64 %product.i.i.i149, 32
  %xored.i.i.i151 = xor i64 %shifted.i.i.i150, %product.i.i.i149
  %hash.i.i.i152 = and i64 %xored.i.i.i151, %tbl_size.i.i147
  %offset_ptr.i.i153 = getelementptr i32, ptr %offset_tbl.i.i148, i64 %hash.i.i.i152
  %offset.i.i154 = load i32, ptr %offset_ptr.i.i153, align 4
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull align 16 dereferenceable(2256) @CuckooMap) #39
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %4) #35
  %98 = icmp ult i32 %.0566, 99
  br i1 %98, label %28, label %._crit_edge

99:                                               ; preds = %68, %43
  %100 = phi ptr [ %10, %68 ], [ %7, %43 ]
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %102 = getelementptr i8, ptr %13, i64 48
  %103 = load ptr, ptr %102, align 8
  %104 = load ptr, ptr %103, align 8
  %105 = call i32 %104(ptr %.fca.1.extract9) #37
  store i32 %105, ptr %100, align 4
  %106 = add i32 %105, 1
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract8)
  %108 = getelementptr i8, ptr %103, i64 8
  %109 = load ptr, ptr %108, align 8
  call void %109(ptr %.fca.1.extract9, i32 %106) #36
  br label %112

._crit_edge:                                      ; preds = %.cont.cont
  %.sroa.17.8.insert.ext = zext i32 %offset.i.i154 to i160
  %.sroa.17.8.insert.shift = shl nuw i160 %.sroa.17.8.insert.ext, 128
  %110 = extractelement <2 x i64> %93, i64 1
  %.sroa.12.8.insert.ext = zext i64 %110 to i160
  %.sroa.12.8.insert.shift = shl nuw nsw i160 %.sroa.12.8.insert.ext, 64
  %.sroa.12.8.insert.insert = or disjoint i160 %.sroa.17.8.insert.shift, %.sroa.12.8.insert.shift
  %111 = extractelement <2 x i64> %93, i64 0
  %.sroa.6.8.insert.ext = zext i64 %111 to i160
  %.sroa.6.8.insert.insert = or disjoint i160 %.sroa.12.8.insert.insert, %.sroa.6.8.insert.ext
  br label %112

112:                                              ; preds = %._crit_edge, %99
  %.reg2mem141.sroa.3.0 = phi i160 [ undef, %99 ], [ %.sroa.6.8.insert.insert, %._crit_edge ]
  %.reg2mem141.sroa.0.0 = phi ptr [ @nil_typ, %99 ], [ %vptr.i142.sroa.speculated, %._crit_edge ]
  %.reload142.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem141.sroa.0.0, 0
  %.reload142.fca.1.insert = insertvalue { ptr, i160 } %.reload142.fca.0.insert, i160 %.reg2mem141.sroa.3.0, 1
  ret { ptr, i160 } %.reload142.fca.1.insert
}

; Function Attrs: nounwind
define void @CuckooMap_move_entries_old_tableBufferEntryK._V_or_Nil_old_capacity_per_tablePtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4) #7 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %8 = icmp sgt i32 %4, 0
  br i1 %8, label %.lr.ph, label %._crit_edge2._crit_edge

.lr.ph:                                           ; preds = %5
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !521
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !521
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !521
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !521
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = sext i32 %offset.i.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract4, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = getelementptr i8, ptr %14, i64 120
  br label %17

17:                                               ; preds = %.lr.ph, %._crit_edge
  %.060 = phi i32 [ 0, %.lr.ph ], [ %46, %._crit_edge ]
  %18 = zext nneg i32 %.060 to i64
  %19 = shl nuw nsw i64 %18, 5
  %20 = getelementptr i8, ptr %.fca.0.extract, i64 %19
  %21 = load ptr, ptr %20, align 8
  %22 = icmp ne ptr %21, @nil_typ
  %23 = icmp ne ptr %21, null
  %.not16 = and i1 %22, %23
  br i1 %.not16, label %24, label %._crit_edge

24:                                               ; preds = %17
  %25 = getelementptr i8, ptr %20, i64 8
  %26 = load i64, ptr %25, align 4
  %.sroa_idx = getelementptr i8, ptr %20, i64 16
  %27 = load i64, ptr %.sroa_idx, align 4
  %28 = inttoptr i64 %26 to ptr
  %29 = inttoptr i64 %27 to ptr
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %21, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %21, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %21, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4015701072841558310
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !524
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %28, 1
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %29, 2
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, i32 %offset.i.i43, 3
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract4) #39
  %35 = load ptr, ptr %14, align 8
  %result.i = call ptr %35(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract4) #39
  %37 = load ptr, ptr %15, align 8
  %result.i45 = call ptr %37(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i46 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %38 = getelementptr inbounds i8, ptr %result.i46, i64 16
  store ptr %result.i45, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %result.i46, i64 8
  store ptr %result.i, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %result.i46, i64 24
  store ptr null, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i46) #39
  store ptr @Entry, ptr %result.i46, align 8
  store ptr %result.i46, ptr %6, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #39
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract4) #39
  %44 = load ptr, ptr %16, align 8
  store ptr %21, ptr %7, align 8
  %result.i47 = call ptr %44({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %7) #16
  %45 = call { ptr, i160 } %result.i47({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %6, { ptr, ptr, ptr, i32 } %33) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %24, %17
  %46 = add nuw nsw i32 %.060, 1
  %47 = icmp slt i32 %46, %4
  br i1 %47, label %17, label %._crit_edge2._crit_edge

._crit_edge2._crit_edge:                          ; preds = %._crit_edge, %5
  ret void
}

; Function Attrs: nounwind
define void @CuckooMap_resize_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
._crit_edge:
  %3 = alloca [2 x ptr], align 8
  %4 = alloca { ptr, ptr }, align 8
  %5 = alloca [2 x ptr], align 8
  %6 = alloca { ptr, ptr }, align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !527
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !527
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !527
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !527
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract14, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call { ptr } %12(ptr %.fca.1.extract) #37
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #35
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call { ptr } %17(ptr %.fca.1.extract) #37
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #35
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = tail call i32 %22(ptr %.fca.1.extract) #37
  %24 = shl i32 %23, 1
  %spec.select = tail call i32 @llvm.smax.i32(i32 %24, i32 16)
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #41
  %26 = getelementptr i8, ptr %21, i64 8
  %27 = load ptr, ptr %26, align 8
  tail call void %27(ptr %.fca.1.extract, i32 %spec.select) #36
  %28 = zext nneg i32 %spec.select to i64
  %29 = shl nuw nsw i64 %28, 5
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %29, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #41
  %31 = load ptr, ptr %10, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %33(ptr %.fca.1.extract, { ptr } %34) #36
  %result.i20 = tail call noalias ptr @bump_malloc_inner(i64 noundef %29, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #41
  %36 = load ptr, ptr %15, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %39 = insertvalue { ptr } undef, ptr %result.i20, 0
  tail call void %38(ptr %.fca.1.extract, { ptr } %39) #36
  %40 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #41
  %41 = getelementptr i8, ptr %9, i64 48
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  tail call void %44(ptr %.fca.1.extract, i32 0) #36
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.1.extract, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.2.extract, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %offset.i.i, 3
  %result.i21 = tail call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %49 = getelementptr inbounds i8, ptr %result.i21, i64 8
  store ptr null, ptr %49, align 8
  store ptr @buffer_typ, ptr %result.i21, align 8
  store ptr %result.i21, ptr %3, align 8
  %50 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @_parameterization_Ptri32, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %3) #41
  %52 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #41
  %53 = getelementptr i8, ptr %9, i64 128
  %54 = load ptr, ptr %53, align 8
  store ptr @buffer_typ, ptr %4, align 8
  %55 = getelementptr inbounds i8, ptr %4, i64 8
  store ptr @i32_typ, ptr %55, align 8
  %result.i22 = call ptr %54({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %4) #16
  call void %result.i22({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %3, { ptr } %13, i32 %23) #7
  %result.i23 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %56 = getelementptr inbounds i8, ptr %result.i23, i64 8
  store ptr null, ptr %56, align 8
  store ptr @buffer_typ, ptr %result.i23, align 8
  store ptr %result.i23, ptr %5, align 8
  %57 = getelementptr inbounds i8, ptr %5, i64 8
  store ptr @_parameterization_Ptri32, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %5) #41
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract14) #41
  %60 = load ptr, ptr %53, align 8
  store ptr @buffer_typ, ptr %6, align 8
  %61 = getelementptr inbounds i8, ptr %6, i64 8
  store ptr @i32_typ, ptr %61, align 8
  %result.i24 = call ptr %60({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i24({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 dereferenceable(16) %5, { ptr } %18, i32 %23) #7
  ret void
}

define noundef i1 @CuckooMap_replace_in_table_keyK_valueV_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5, i32 %6, { ptr } %7) {
  %9 = alloca [0 x ptr], align 8
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !530
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !530
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !530
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !530
  %.fca.0.extract = extractvalue { ptr } %7, 0
  %10 = sext i32 %6 to i64
  %11 = shl nsw i64 %10, 5
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 %11
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %12, i64 8
  %15 = icmp ne ptr %13, @nil_typ
  %16 = icmp ne ptr %13, null
  %.not64 = and i1 %15, %16
  br i1 %.not64, label %17, label %._crit_edge.thread

17:                                               ; preds = %8
  %18 = load i64, ptr %14, align 4
  %.sroa_idx = getelementptr i8, ptr %12, i64 16
  %19 = load i64, ptr %.sroa_idx, align 4
  %20 = inttoptr i64 %18 to ptr
  %21 = inttoptr i64 %19 to ptr
  %hash_coef_ptr.i.i66 = getelementptr i8, ptr %13, i64 8
  %tbl_size_ptr.i.i67 = getelementptr i8, ptr %13, i64 16
  %offset_tbl_ptr.i.i68 = getelementptr i8, ptr %13, i64 40
  %hash_coef.i.i69 = load i64, ptr %hash_coef_ptr.i.i66, align 4, !noalias !533
  %tbl_size.i.i70 = load i64, ptr %tbl_size_ptr.i.i67, align 4, !noalias !533
  %offset_tbl.i.i71 = load ptr, ptr %offset_tbl_ptr.i.i68, align 8, !noalias !533
  %product.i.i.i72 = mul i64 %hash_coef.i.i69, 4015701072841558310
  %shifted.i.i.i73 = lshr i64 %product.i.i.i72, 32
  %xored.i.i.i74 = xor i64 %shifted.i.i.i73, %product.i.i.i72
  %hash.i.i.i75 = and i64 %xored.i.i.i74, %tbl_size.i.i70
  %offset_ptr.i.i76 = getelementptr i32, ptr %offset_tbl.i.i71, i64 %hash.i.i.i75
  %offset.i.i77 = load i32, ptr %offset_ptr.i.i76, align 4, !noalias !533
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %21, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i77, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13) #35
  %28 = sext i32 %offset.i.i77 to i64
  %29 = getelementptr ptr, ptr %13, i64 %28
  %30 = getelementptr i8, ptr %29, i64 64
  %31 = load ptr, ptr %30, align 8
  %result.i = call ptr %31({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly %9) #16
  %32 = call i32 %result.i({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %9) #7
  %33 = icmp eq i32 %32, %5
  br i1 %33, label %._crit_edge, label %._crit_edge.thread

._crit_edge:                                      ; preds = %17
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %9)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %13)
  %36 = getelementptr i8, ptr %29, i64 48
  %37 = load ptr, ptr %36, align 8
  %result.i79 = call ptr %37({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly %9) #16
  %38 = call { ptr, i160 } %result.i79({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %9) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract20)
  %40 = sext i32 %offset.i.i to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract20, i64 %40
  %42 = getelementptr i8, ptr %41, i64 64
  %43 = load ptr, ptr %42, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr } %44(ptr %.fca.1.extract21) #37
  %.fca.0.extract47 = extractvalue { ptr } %45, 0
  %46 = call i1 %.fca.0.extract47({ ptr, i160 } %38, { ptr, i160 } %3)
  br i1 %46, label %47, label %._crit_edge.thread

47:                                               ; preds = %._crit_edge
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract20)
  %49 = load ptr, ptr %41, align 8
  %result.i80 = call ptr %49(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract21) #5
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract20)
  %51 = getelementptr i8, ptr %41, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i81 = call ptr %52(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract21) #5
  %53 = load ptr, ptr %result.i80, align 8, !alias.scope !536
  %54 = getelementptr i8, ptr %53, i64 72
  %55 = load ptr, ptr %54, align 8, !alias.scope !536
  %result.i.i = call { i64, i64 } %55(ptr nocapture nofree nonnull readonly %result.i80) #5, !alias.scope !536
  %56 = extractvalue { i64, i64 } %result.i.i, 0
  %57 = extractvalue { i64, i64 } %result.i.i, 1
  %58 = urem i64 20, %57
  %59 = icmp eq i64 %58, 0
  %60 = sub i64 %57, %58
  %61 = select i1 %59, i64 0, i64 %60
  %62 = add i64 %56, 20
  %63 = add i64 %62, %61
  %64 = load ptr, ptr %result.i81, align 8, !alias.scope !536
  %65 = getelementptr i8, ptr %64, i64 72
  %66 = load ptr, ptr %65, align 8, !alias.scope !536
  %result.i1.i = call { i64, i64 } %66(ptr nocapture nofree nonnull readonly %result.i81) #5, !alias.scope !536
  %67 = extractvalue { i64, i64 } %result.i1.i, 0
  %68 = extractvalue { i64, i64 } %result.i1.i, 1
  %69 = call i64 @llvm.umax.i64(i64 %57, i64 %68)
  %70 = call i64 @llvm.umax.i64(i64 %69, i64 8)
  %71 = urem i64 %63, %68
  %72 = icmp eq i64 %71, 0
  %73 = sub i64 %68, %71
  %74 = select i1 %72, i64 0, i64 %73
  %75 = add i64 %67, %63
  %76 = add i64 %75, %74
  %77 = urem i64 %76, %70
  %78 = icmp eq i64 %77, 0
  %79 = sub i64 %70, %77
  %80 = select i1 %78, i64 0, i64 %79
  %81 = add i64 %80, %76
  %result.i83 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %81, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i80, ptr %result.i83, align 8
  %82 = getelementptr inbounds i8, ptr %result.i83, i64 8
  store ptr %result.i81, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i83)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract20)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract20)
  %86 = load ptr, ptr %result.i80, align 8
  %87 = getelementptr i8, ptr %86, i64 72
  %88 = load ptr, ptr %87, align 8
  %result.i.i118 = call { i64, i64 } %88(ptr nocapture nofree nonnull readonly %result.i80) #5
  %89 = extractvalue { i64, i64 } %result.i.i118, 1
  %90 = urem i64 20, %89
  %91 = icmp eq i64 %90, 0
  %reass.sub = sub i64 %89, %90
  %92 = add i64 %reass.sub, 20
  %93 = select i1 %91, i64 20, i64 %92
  %94 = getelementptr i8, ptr %result.i83, i64 %93
  %95 = getelementptr i8, ptr %86, i64 64
  %96 = load ptr, ptr %95, align 8
  call void %96({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly %result.i80, ptr nocapture nofree writeonly %94) #1
  %97 = load ptr, ptr %result.i83, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr i8, ptr %98, i64 72
  %100 = load ptr, ptr %99, align 8
  %result.i.i119 = call { i64, i64 } %100(ptr nocapture nofree nonnull readonly %97) #5
  %101 = extractvalue { i64, i64 } %result.i.i119, 0
  %102 = extractvalue { i64, i64 } %result.i.i119, 1
  %103 = urem i64 20, %102
  %104 = icmp eq i64 %103, 0
  %105 = sub i64 %102, %103
  %106 = select i1 %104, i64 0, i64 %105
  %107 = add i64 %101, 20
  %108 = add i64 %107, %106
  %109 = load ptr, ptr %82, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = getelementptr i8, ptr %110, i64 72
  %112 = load ptr, ptr %111, align 8
  %result.i1.i120 = call { i64, i64 } %112(ptr nocapture nofree nonnull readonly %109) #5
  %113 = extractvalue { i64, i64 } %result.i1.i120, 1
  %114 = urem i64 %108, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = getelementptr i8, ptr %result.i83, i64 %108
  %119 = getelementptr i8, ptr %118, i64 %117
  %120 = getelementptr i8, ptr %110, i64 64
  %121 = load ptr, ptr %120, align 8
  call void %121({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly %109, ptr nocapture nofree writeonly %119) #1
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %123 = getelementptr inbounds i8, ptr %result.i83, i64 16
  store i32 %5, ptr %123, align 8
  store ptr @Entry, ptr %12, align 8
  %124 = ptrtoint ptr %result.i83 to i64
  store i64 %124, ptr %14, align 4
  %.sroa_idx28 = getelementptr i8, ptr %12, i64 24
  store i32 10, ptr %.sroa_idx28, align 4
  br label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %17, %8, %47, %._crit_edge
  %.reg2mem45.0 = phi i1 [ false, %._crit_edge ], [ true, %47 ], [ false, %8 ], [ false, %17 ]
  ret i1 %.reg2mem45.0
}

define { ptr, i160 } @CuckooMap_get_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !539
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !539
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !539
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !539
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 5
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = icmp ne ptr %12, @nil_typ
  %14 = icmp ne ptr %12, null
  %.not44 = and i1 %13, %14
  br i1 %.not44, label %15, label %.thread

15:                                               ; preds = %7
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load i64, ptr %16, align 4
  %.sroa_idx = getelementptr i8, ptr %11, i64 16
  %18 = load i64, ptr %.sroa_idx, align 4
  %19 = inttoptr i64 %17 to ptr
  %20 = inttoptr i64 %18 to ptr
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %12, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %12, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %12, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !542
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !542
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !542
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4015701072841558310
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !542
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %12, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %19, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i57, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8) #35
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12) #35
  %27 = sext i32 %offset.i.i57 to i64
  %28 = getelementptr ptr, ptr %12, i64 %27
  %29 = getelementptr i8, ptr %28, i64 64
  %30 = load ptr, ptr %29, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #16
  %31 = call i32 %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %32 = icmp eq i32 %31, %4
  br i1 %32, label %._crit_edge, label %.thread

._crit_edge:                                      ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12)
  %35 = getelementptr i8, ptr %28, i64 48
  %36 = load ptr, ptr %35, align 8
  %result.i59 = call ptr %36({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #16
  %37 = call { ptr, i160 } %result.i59({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract13)
  %39 = sext i32 %offset.i.i to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract13, i64 %39
  %41 = getelementptr i8, ptr %40, i64 64
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract14) #37
  %.fca.0.extract27 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract27({ ptr, i160 } %37, { ptr, i160 } %3)
  br i1 %45, label %46, label %.thread

46:                                               ; preds = %._crit_edge
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12)
  %49 = getelementptr i8, ptr %28, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i60 = call ptr %50({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #16
  %51 = call { ptr, i160 } %result.i60({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %.fca.0.extract21 = extractvalue { ptr, i160 } %51, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %51, 1
  br label %.thread

.thread:                                          ; preds = %15, %7, %._crit_edge, %46
  %.reg2mem43.sroa.3.077 = phi i160 [ %.fca.1.extract22, %46 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %15 ]
  %52 = phi ptr [ %.fca.0.extract21, %46 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %15 ]
  %.reload40.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %52, 0
  %.reload40.fca.1.insert = insertvalue { ptr, i160 } %.reload40.fca.0.insert, i160 %.reg2mem43.sroa.3.077, 1
  ret { ptr, i160 } %.reload40.fca.1.insert
}

define { ptr, i160 } @CuckooMap_remove_from_table_keyK_h1Ptri32_idxPtri32_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4, i32 %5, { ptr } %6) {
  %8 = alloca [0 x ptr], align 8
  %.fca.0.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !545
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !545
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !545
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !545
  %.fca.0.extract = extractvalue { ptr } %6, 0
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 5
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 %10
  %12 = load ptr, ptr %11, align 8
  %13 = icmp ne ptr %12, @nil_typ
  %14 = icmp ne ptr %12, null
  %.not51 = and i1 %13, %14
  br i1 %.not51, label %15, label %.thread

15:                                               ; preds = %7
  %16 = getelementptr i8, ptr %11, i64 8
  %17 = load i64, ptr %16, align 4
  %.sroa_idx = getelementptr i8, ptr %11, i64 16
  %18 = load i64, ptr %.sroa_idx, align 4
  %19 = inttoptr i64 %17 to ptr
  %20 = inttoptr i64 %18 to ptr
  %hash_coef_ptr.i.i53 = getelementptr i8, ptr %12, i64 8
  %tbl_size_ptr.i.i54 = getelementptr i8, ptr %12, i64 16
  %offset_tbl_ptr.i.i55 = getelementptr i8, ptr %12, i64 40
  %hash_coef.i.i56 = load i64, ptr %hash_coef_ptr.i.i53, align 4, !noalias !548
  %tbl_size.i.i57 = load i64, ptr %tbl_size_ptr.i.i54, align 4, !noalias !548
  %offset_tbl.i.i58 = load ptr, ptr %offset_tbl_ptr.i.i55, align 8, !noalias !548
  %product.i.i.i59 = mul i64 %hash_coef.i.i56, 4015701072841558310
  %shifted.i.i.i60 = lshr i64 %product.i.i.i59, 32
  %xored.i.i.i61 = xor i64 %shifted.i.i.i60, %product.i.i.i59
  %hash.i.i.i62 = and i64 %xored.i.i.i61, %tbl_size.i.i57
  %offset_ptr.i.i63 = getelementptr i32, ptr %offset_tbl.i.i58, i64 %hash.i.i.i62
  %offset.i.i64 = load i32, ptr %offset_ptr.i.i63, align 4, !noalias !548
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %12, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %19, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %20, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i64, 3
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8) #35
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12) #35
  %27 = sext i32 %offset.i.i64 to i64
  %28 = getelementptr ptr, ptr %12, i64 %27
  %29 = getelementptr i8, ptr %28, i64 64
  %30 = load ptr, ptr %29, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #16
  %31 = call i32 %result.i({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %32 = icmp eq i32 %31, %4
  br i1 %32, label %._crit_edge, label %.thread

._crit_edge:                                      ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12)
  %35 = getelementptr i8, ptr %28, i64 48
  %36 = load ptr, ptr %35, align 8
  %result.i66 = call ptr %36({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #16
  %37 = call { ptr, i160 } %result.i66({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract15)
  %39 = sext i32 %offset.i.i to i64
  %40 = getelementptr ptr, ptr %.fca.0.extract15, i64 %39
  %41 = getelementptr i8, ptr %40, i64 64
  %42 = load ptr, ptr %41, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr } %43(ptr %.fca.1.extract16) #37
  %.fca.0.extract34 = extractvalue { ptr } %44, 0
  %45 = call i1 %.fca.0.extract34({ ptr, i160 } %37, { ptr, i160 } %3)
  br i1 %45, label %46, label %.thread

46:                                               ; preds = %._crit_edge
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %8)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull %12)
  %49 = getelementptr i8, ptr %28, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i67 = call ptr %50({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %8) #16
  %51 = call { ptr, i160 } %result.i67({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 %8) #7
  %.fca.0.extract28 = extractvalue { ptr, i160 } %51, 0
  %.fca.1.extract29 = extractvalue { ptr, i160 } %51, 1
  store ptr @nil_typ, ptr %11, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract15)
  %53 = getelementptr i8, ptr %40, i64 48
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call i32 %55(ptr %.fca.1.extract16) #37
  %57 = add i32 %56, -1
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract15)
  %59 = getelementptr i8, ptr %54, i64 8
  %60 = load ptr, ptr %59, align 8
  call void %60(ptr %.fca.1.extract16, i32 %57) #36
  br label %.thread

.thread:                                          ; preds = %15, %7, %._crit_edge, %46
  %.reg2mem47.sroa.3.088 = phi i160 [ %.fca.1.extract29, %46 ], [ poison, %._crit_edge ], [ poison, %7 ], [ poison, %15 ]
  %61 = phi ptr [ %.fca.0.extract28, %46 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %7 ], [ @nil_typ, %15 ]
  %.reload44.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %61, 0
  %.reload44.fca.1.insert = insertvalue { ptr, i160 } %.reload44.fca.0.insert, i160 %.reg2mem47.sroa.3.088, 1
  ret { ptr, i160 } %.reload44.fca.1.insert
}

define void @CuckooMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) {
  %6 = alloca [0 x ptr], align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %9 = alloca [5 x ptr], align 8
  %10 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %11 = alloca [1 x ptr], align 8
  %12 = alloca { ptr }, align 8
  %.fca.0.extract34 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract34, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract29 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract20 = extractvalue { ptr, i160 } %4, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract34, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract35, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i, 3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract34) #39
  %18 = sext i32 %offset.i.i to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract34, i64 %18
  %20 = load ptr, ptr %19, align 8
  %result.i = tail call ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %21 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %21) #39
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract34) #39
  %24 = getelementptr i8, ptr %19, i64 88
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr }, align 8
  store ptr %.fca.0.extract29, ptr %26, align 8
  %result.i75 = call ptr %25({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %26) #16
  %27 = call i32 %result.i75({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %21, { ptr, i160 } %3) #7
  %28 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %28, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %28)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract34)
  %31 = getelementptr i8, ptr %19, i64 104
  %32 = load ptr, ptr %31, align 8
  %33 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %33, align 8
  %result.i76 = call ptr %32({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %33) #16
  %34 = call i32 %result.i76({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %28, i32 %27) #7
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract34)
  %36 = getelementptr i8, ptr %19, i64 24
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = call { ptr } %38(ptr %.fca.1.extract35) #37
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract34)
  %41 = load ptr, ptr %19, align 8
  %result.i77 = call ptr %41(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract34)
  %43 = getelementptr i8, ptr %19, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i78 = call ptr %44(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %result.i79 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @buffer_typ, ptr %result.i79, align 8
  %45 = alloca [5 x ptr], align 8
  store ptr %result.i77, ptr %45, align 8
  %46 = getelementptr inbounds i8, ptr %45, i64 8
  store ptr %result.i78, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %45, i64 16
  store ptr @_parameterization_Ptri32, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %45, i64 24
  store ptr @_parameterization_Ptri32, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %45, i64 32
  store ptr %result.i79, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %45)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract34)
  %52 = getelementptr i8, ptr %19, i64 144
  %53 = load ptr, ptr %52, align 8
  %54 = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract29, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %54, i64 8
  store ptr %.fca.0.extract20, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %54, i64 16
  store ptr @i32_typ, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %54, i64 24
  store ptr @i32_typ, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %54, i64 32
  store ptr @buffer_typ, ptr %58, align 8
  %result.i80 = call ptr %53({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %54) #16
  %59 = call i1 %result.i80({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(40) %45, { ptr, i160 } %3, { ptr, i160 } %4, i32 %27, i32 %34, { ptr } %39) #7
  br i1 %59, label %.thread, label %60

60:                                               ; preds = %5
  store ptr @_parameterization_Ptri32, ptr %7, align 8
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %63 = getelementptr i8, ptr %19, i64 112
  %64 = load ptr, ptr %63, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i81 = call ptr %64({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %8) #16
  %65 = call i32 %result.i81({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %7, i32 %27) #7
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %67 = getelementptr i8, ptr %19, i64 32
  %68 = load ptr, ptr %67, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = call { ptr } %69(ptr %.fca.1.extract35) #37
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %72 = load ptr, ptr %19, align 8
  %result.i82 = call ptr %72(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %74 = load ptr, ptr %43, align 8
  %result.i83 = call ptr %74(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %result.i84 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @buffer_typ, ptr %result.i84, align 8
  store ptr %result.i82, ptr %9, align 8
  %75 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %result.i83, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %9, i64 16
  store ptr @_parameterization_Ptri32, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %9, i64 24
  store ptr @_parameterization_Ptri32, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %9, i64 32
  store ptr %result.i84, ptr %78, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 25, ptr nocapture nofree noundef nonnull align 8 dereferenceable(40) %9)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %81 = load ptr, ptr %52, align 8
  store ptr %.fca.0.extract29, ptr %10, align 8
  %82 = getelementptr inbounds i8, ptr %10, i64 8
  store ptr %.fca.0.extract20, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %10, i64 16
  store ptr @i32_typ, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %10, i64 24
  store ptr @i32_typ, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %10, i64 32
  store ptr @buffer_typ, ptr %85, align 8
  %result.i85 = call ptr %81({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %10) #16
  %86 = call i1 %result.i85({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(40) %9, { ptr, i160 } %3, { ptr, i160 } %4, i32 %27, i32 %65, { ptr } %70) #7
  br i1 %86, label %.thread, label %87

87:                                               ; preds = %60
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %89 = getelementptr i8, ptr %19, i64 48
  %90 = load ptr, ptr %89, align 8
  %91 = load ptr, ptr %90, align 8
  %92 = call i32 %91(ptr %.fca.1.extract35) #37
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %94 = getelementptr i8, ptr %19, i64 40
  %95 = load ptr, ptr %94, align 8
  %96 = load ptr, ptr %95, align 8
  %97 = call i32 %96(ptr %.fca.1.extract35) #37
  %.not = icmp slt i32 %92, %97
  br i1 %.not, label %._crit_edge, label %98

98:                                               ; preds = %87
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %101 = getelementptr i8, ptr %19, i64 136
  %102 = load ptr, ptr %101, align 8
  %result.i86 = call ptr %102({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i86({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %87, %98
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %104 = load ptr, ptr %19, align 8
  %result.i87 = call ptr %104(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %106 = load ptr, ptr %43, align 8
  %result.i88 = call ptr %106(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %107 = load ptr, ptr %result.i87, align 8
  %108 = getelementptr i8, ptr %107, i64 72
  %109 = load ptr, ptr %108, align 8
  %result.i.i = call { i64, i64 } %109(ptr nocapture nofree nonnull readonly %result.i87) #5
  %110 = extractvalue { i64, i64 } %result.i.i, 0
  %111 = extractvalue { i64, i64 } %result.i.i, 1
  %112 = urem i64 20, %111
  %113 = icmp eq i64 %112, 0
  %114 = sub i64 %111, %112
  %115 = select i1 %113, i64 0, i64 %114
  %116 = add i64 %110, 20
  %117 = add i64 %116, %115
  %118 = load ptr, ptr %result.i88, align 8
  %119 = getelementptr i8, ptr %118, i64 72
  %120 = load ptr, ptr %119, align 8
  %result.i1.i = call { i64, i64 } %120(ptr nocapture nofree nonnull readonly %result.i88) #5
  %121 = extractvalue { i64, i64 } %result.i1.i, 0
  %122 = extractvalue { i64, i64 } %result.i1.i, 1
  %123 = call i64 @llvm.umax.i64(i64 %111, i64 %122)
  %124 = call i64 @llvm.umax.i64(i64 %123, i64 8)
  %125 = urem i64 %117, %122
  %126 = icmp eq i64 %125, 0
  %127 = sub i64 %122, %125
  %128 = select i1 %126, i64 0, i64 %127
  %129 = add i64 %121, %117
  %130 = add i64 %129, %128
  %131 = urem i64 %130, %124
  %132 = icmp eq i64 %131, 0
  %133 = sub i64 %124, %131
  %134 = select i1 %132, i64 0, i64 %133
  %135 = add i64 %134, %130
  %result.i90 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %135, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i87, ptr %result.i90, align 8
  %136 = getelementptr inbounds i8, ptr %result.i90, i64 8
  store ptr %result.i88, ptr %136, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i90)
  %138 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i90, 1
  %139 = insertvalue { ptr, ptr, ptr, i32 } %138, ptr undef, 2
  %140 = insertvalue { ptr, ptr, ptr, i32 } %139, i32 10, 3
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %143 = load ptr, ptr %result.i87, align 8
  %144 = getelementptr i8, ptr %143, i64 72
  %145 = load ptr, ptr %144, align 8
  %result.i.i196 = call { i64, i64 } %145(ptr nocapture nofree nonnull readonly %result.i87) #5
  %146 = extractvalue { i64, i64 } %result.i.i196, 1
  %147 = urem i64 20, %146
  %148 = icmp eq i64 %147, 0
  %reass.sub = sub i64 %146, %147
  %149 = add i64 %reass.sub, 20
  %150 = select i1 %148, i64 20, i64 %149
  %151 = getelementptr i8, ptr %result.i90, i64 %150
  %152 = getelementptr i8, ptr %143, i64 64
  %153 = load ptr, ptr %152, align 8
  call void %153({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly %result.i87, ptr nocapture nofree writeonly %151) #1
  %154 = load ptr, ptr %result.i90, align 8
  %155 = load ptr, ptr %154, align 8
  %156 = getelementptr i8, ptr %155, i64 72
  %157 = load ptr, ptr %156, align 8
  %result.i.i197 = call { i64, i64 } %157(ptr nocapture nofree nonnull readonly %154) #5
  %158 = extractvalue { i64, i64 } %result.i.i197, 0
  %159 = extractvalue { i64, i64 } %result.i.i197, 1
  %160 = urem i64 20, %159
  %161 = icmp eq i64 %160, 0
  %162 = sub i64 %159, %160
  %163 = select i1 %161, i64 0, i64 %162
  %164 = add i64 %158, 20
  %165 = add i64 %164, %163
  %166 = load ptr, ptr %136, align 8
  %167 = load ptr, ptr %166, align 8
  %168 = getelementptr i8, ptr %167, i64 72
  %169 = load ptr, ptr %168, align 8
  %result.i1.i198 = call { i64, i64 } %169(ptr nocapture nofree nonnull readonly %166) #5
  %170 = extractvalue { i64, i64 } %result.i1.i198, 1
  %171 = urem i64 %165, %170
  %172 = icmp eq i64 %171, 0
  %173 = sub i64 %170, %171
  %174 = select i1 %172, i64 0, i64 %173
  %175 = getelementptr i8, ptr %result.i90, i64 %165
  %176 = getelementptr i8, ptr %175, i64 %174
  %177 = getelementptr i8, ptr %167, i64 64
  %178 = load ptr, ptr %177, align 8
  call void %178({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly %166, ptr nocapture nofree writeonly %176) #1
  %179 = call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef nonnull @Entry) #35
  %180 = getelementptr inbounds i8, ptr %result.i90, i64 16
  store i32 %27, ptr %180, align 8
  %181 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %182 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %183 = getelementptr i8, ptr %19, i64 120
  %184 = getelementptr i8, ptr %19, i64 136
  %185 = load ptr, ptr %19, align 8
  %result.i122 = call ptr %185(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %186 = load ptr, ptr %43, align 8
  %result.i123 = call ptr %186(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %result.i124 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %187 = getelementptr inbounds i8, ptr %result.i124, i64 16
  store ptr @_parameterization_Nil, ptr %187, align 8
  %result.i125 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %188 = getelementptr inbounds i8, ptr %result.i125, i64 16
  store ptr %result.i123, ptr %188, align 8
  %189 = getelementptr inbounds i8, ptr %result.i125, i64 8
  store ptr %result.i122, ptr %189, align 8
  %190 = getelementptr inbounds i8, ptr %result.i125, i64 24
  store ptr null, ptr %190, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i125)
  store ptr @Entry, ptr %result.i125, align 8
  %192 = getelementptr inbounds i8, ptr %result.i124, i64 8
  store ptr %result.i125, ptr %192, align 8
  %193 = getelementptr inbounds i8, ptr %result.i124, i64 24
  store ptr null, ptr %193, align 8
  %194 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i124)
  store ptr @union_typ, ptr %result.i124, align 8
  store ptr %result.i124, ptr %11, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %197 = load ptr, ptr %183, align 8
  store ptr @union_typ, ptr %12, align 8
  %result.i126 = call ptr %197({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %12) #16
  %198 = call { ptr, i160 } %result.i126({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %140) #7
  %.fca.0.extract41 = extractvalue { ptr, i160 } %198, 0
  %199 = icmp eq ptr %.fca.0.extract41, @nil_typ
  %200 = icmp eq ptr %.fca.0.extract41, null
  %201 = or i1 %199, %200
  br i1 %201, label %.thread, label %202

202:                                              ; preds = %._crit_edge
  %.fca.1.extract42 = extractvalue { ptr, i160 } %198, 1
  %203 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %205 = load ptr, ptr %184, align 8
  %result.i127 = call ptr %205({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i127({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #7
  %.sroa.3179.8.extract.trunc = trunc i160 %.fca.1.extract42 to i64
  %206 = inttoptr i64 %.sroa.3179.8.extract.trunc to ptr
  %.sroa.6.8.extract.shift = lshr i160 %.fca.1.extract42, 64
  %.sroa.6.8.extract.trunc = trunc i160 %.sroa.6.8.extract.shift to i64
  %207 = inttoptr i64 %.sroa.6.8.extract.trunc to ptr
  %hash_coef_ptr.i.i109.1 = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i.i110.1 = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i.i111.1 = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i.i112.1 = load i64, ptr %hash_coef_ptr.i.i109.1, align 4
  %tbl_size.i.i113.1 = load i64, ptr %tbl_size_ptr.i.i110.1, align 4
  %offset_tbl.i.i114.1 = load ptr, ptr %offset_tbl_ptr.i.i111.1, align 8
  %product.i.i.i115.1 = mul i64 %hash_coef.i.i112.1, 4015701072841558310
  %shifted.i.i.i116.1 = lshr i64 %product.i.i.i115.1, 32
  %xored.i.i.i117.1 = xor i64 %shifted.i.i.i116.1, %product.i.i.i115.1
  %hash.i.i.i118.1 = and i64 %xored.i.i.i117.1, %tbl_size.i.i113.1
  %offset_ptr.i.i119.1 = getelementptr i32, ptr %offset_tbl.i.i114.1, i64 %hash.i.i.i118.1
  %offset.i.i120.1 = load i32, ptr %offset_ptr.i.i119.1, align 4
  %208 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %209 = insertvalue { ptr, ptr, ptr, i32 } %208, ptr %206, 1
  %210 = insertvalue { ptr, ptr, ptr, i32 } %209, ptr %207, 2
  %211 = insertvalue { ptr, ptr, ptr, i32 } %210, i32 %offset.i.i120.1, 3
  %212 = load ptr, ptr %19, align 8
  %result.i122.1 = call ptr %212(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %213 = load ptr, ptr %43, align 8
  %result.i123.1 = call ptr %213(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract35) #5
  %result.i124.1 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %214 = getelementptr inbounds i8, ptr %result.i124.1, i64 16
  store ptr @_parameterization_Nil, ptr %214, align 8
  %result.i125.1 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %215 = getelementptr inbounds i8, ptr %result.i125.1, i64 16
  store ptr %result.i123.1, ptr %215, align 8
  %216 = getelementptr inbounds i8, ptr %result.i125.1, i64 8
  store ptr %result.i122.1, ptr %216, align 8
  %217 = getelementptr inbounds i8, ptr %result.i125.1, i64 24
  store ptr null, ptr %217, align 8
  %218 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i125.1)
  store ptr @Entry, ptr %result.i125.1, align 8
  %219 = getelementptr inbounds i8, ptr %result.i124.1, i64 8
  store ptr %result.i125.1, ptr %219, align 8
  %220 = getelementptr inbounds i8, ptr %result.i124.1, i64 24
  store ptr null, ptr %220, align 8
  %221 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i124.1)
  store ptr @union_typ, ptr %result.i124.1, align 8
  store ptr %result.i124.1, ptr %11, align 8
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11)
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %224 = load ptr, ptr %183, align 8
  store ptr @union_typ, ptr %12, align 8
  %result.i126.1 = call ptr %224({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %12) #16
  %225 = call { ptr, i160 } %result.i126.1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %211) #7
  %.fca.0.extract41.1 = extractvalue { ptr, i160 } %225, 0
  %226 = icmp eq ptr %.fca.0.extract41.1, @nil_typ
  %227 = icmp eq ptr %.fca.0.extract41.1, null
  %228 = or i1 %226, %227
  br i1 %228, label %.thread, label %229

229:                                              ; preds = %202
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract34)
  %232 = load ptr, ptr %184, align 8
  %result.i127.1 = call ptr %232({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i127.1({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %6) #7
  br label %.thread

.thread:                                          ; preds = %._crit_edge, %202, %229, %60, %5
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @CuckooMap_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !551
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !551
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !551
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !551
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 48
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #37
  ret i32 %10
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMap_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !554
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !554
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !554
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !554
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract31, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract32, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31) #35
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract31, i64 %14
  %16 = load ptr, ptr %15, align 8
  %result.i = tail call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #5
  %17 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17) #35
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31) #35
  %20 = getelementptr i8, ptr %15, i64 88
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %22, align 8
  %result.i68 = call ptr %21({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %22) #16
  %23 = call i32 %result.i68({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %17, { ptr, i160 } %3) #7
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %27 = getelementptr i8, ptr %15, i64 104
  %28 = load ptr, ptr %27, align 8
  %29 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %29, align 8
  %result.i69 = call ptr %28({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %29) #16
  %30 = call i32 %result.i69({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %24, i32 %23) #7
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %32 = getelementptr i8, ptr %15, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr %.fca.1.extract32) #37
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %37 = load ptr, ptr %15, align 8
  %result.i70 = call ptr %37(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #5
  %result.i71 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @buffer_typ, ptr %result.i71, align 8
  %38 = alloca [4 x ptr], align 8
  store ptr %result.i70, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %38, i64 16
  store ptr @_parameterization_Ptri32, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %38, i64 24
  store ptr %result.i71, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %38)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %44 = getelementptr i8, ptr %15, i64 152
  %45 = load ptr, ptr %44, align 8
  %46 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @i32_typ, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @i32_typ, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr @buffer_typ, ptr %49, align 8
  %result.i72 = call ptr %45({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %46) #16
  %50 = call { ptr, i160 } %result.i72({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %38, { ptr, i160 } %3, i32 %23, i32 %30, { ptr } %35) #7
  %.fca.0.extract = extractvalue { ptr, i160 } %50, 0
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %52 = icmp ne ptr %.fca.0.extract, @nil_typ
  %53 = icmp ne ptr %.fca.0.extract, null
  %.not63 = and i1 %52, %53
  br i1 %.not63, label %.thread, label %54

54:                                               ; preds = %4
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %57 = getelementptr i8, ptr %15, i64 112
  %58 = load ptr, ptr %57, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i73 = call ptr %58({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %6) #16
  %59 = call i32 %result.i73({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %5, i32 %23) #7
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %61 = getelementptr i8, ptr %15, i64 32
  %62 = load ptr, ptr %61, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = call { ptr } %63(ptr %.fca.1.extract32) #37
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %66 = load ptr, ptr %15, align 8
  %result.i74 = call ptr %66(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #5
  %result.i75 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @buffer_typ, ptr %result.i75, align 8
  store ptr %result.i74, ptr %7, align 8
  %67 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_Ptri32, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_Ptri32, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %result.i75, ptr %69, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %72 = load ptr, ptr %44, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %73 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %75, align 8
  %result.i76 = call ptr %72({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %8) #16
  %76 = call { ptr, i160 } %result.i76({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %7, { ptr, i160 } %3, i32 %23, i32 %59, { ptr } %64) #7
  %.fca.0.extract51 = extractvalue { ptr, i160 } %76, 0
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %78 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %79 = icmp ne ptr %.fca.0.extract51, null
  %.not65.not.not = and i1 %78, %79
  %cond.fr = freeze i1 %.not65.not.not
  %spec.select = select i1 %cond.fr, ptr %.fca.0.extract51, ptr @nil_typ
  br label %.thread

.thread:                                          ; preds = %54, %4
  %.pn = phi { ptr, i160 } [ %50, %4 ], [ %76, %54 ]
  %80 = phi ptr [ %.fca.0.extract, %4 ], [ %spec.select, %54 ]
  %.fca.1.extract..sroa.354.0106 = extractvalue { ptr, i160 } %.pn, 1
  %.reload55.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %80, 0
  %.reload55.fca.1.insert = insertvalue { ptr, i160 } %.reload55.fca.0.insert, i160 %.fca.1.extract..sroa.354.0106, 1
  ret { ptr, i160 } %.reload55.fca.1.insert
}

; Function Attrs: nounwind
define void @CuckooMap__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #7 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !557
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !557
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !557
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !557
  %.fca.0.extract7 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract12, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract11) #35
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract11, i64 %11
  %13 = load ptr, ptr %12, align 8
  %result.i = tail call ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract11) #35
  %15 = getelementptr i8, ptr %12, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i15 = tail call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %17 = alloca [2 x ptr], align 8
  store ptr %result.i, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %17, i64 8
  store ptr %result.i15, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %17) #35
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract11) #35
  %21 = getelementptr i8, ptr %12, i64 168
  %22 = load ptr, ptr %21, align 8
  %23 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract7, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %23, i64 8
  store ptr %.fca.0.extract, ptr %24, align 8
  %result.i16 = call ptr %22({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %23) #16
  call void %result.i16({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 dereferenceable(16) %17, { ptr, i160 } %3, { ptr, i160 } %4) #7
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMap_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [4 x ptr], align 8
  %8 = alloca { ptr, ptr, ptr, ptr }, align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !560
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !560
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !560
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !560
  %.fca.0.extract24 = extractvalue { ptr, i160 } %3, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract31, 0
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.1.extract32, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.2.extract, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %offset.i.i, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31) #35
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract31, i64 %14
  %16 = load ptr, ptr %15, align 8
  %result.i = tail call ptr %16(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #5
  %17 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %17) #35
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31) #35
  %20 = getelementptr i8, ptr %15, i64 88
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr }, align 8
  store ptr %.fca.0.extract24, ptr %22, align 8
  %result.i68 = call ptr %21({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %22) #16
  %23 = call i32 %result.i68({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %17, { ptr, i160 } %3) #7
  %24 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %24, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %27 = getelementptr i8, ptr %15, i64 104
  %28 = load ptr, ptr %27, align 8
  %29 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %29, align 8
  %result.i69 = call ptr %28({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %29) #16
  %30 = call i32 %result.i69({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %24, i32 %23) #7
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %32 = getelementptr i8, ptr %15, i64 24
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = call { ptr } %34(ptr %.fca.1.extract32) #37
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %37 = load ptr, ptr %15, align 8
  %result.i70 = call ptr %37(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #5
  %result.i71 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @buffer_typ, ptr %result.i71, align 8
  %38 = alloca [4 x ptr], align 8
  store ptr %result.i70, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %38, i64 8
  store ptr @_parameterization_Ptri32, ptr %39, align 8
  %40 = getelementptr inbounds i8, ptr %38, i64 16
  store ptr @_parameterization_Ptri32, ptr %40, align 8
  %41 = getelementptr inbounds i8, ptr %38, i64 24
  store ptr %result.i71, ptr %41, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %38)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %44 = getelementptr i8, ptr %15, i64 160
  %45 = load ptr, ptr %44, align 8
  %46 = alloca { ptr, ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract24, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %46, i64 8
  store ptr @i32_typ, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %46, i64 16
  store ptr @i32_typ, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %46, i64 24
  store ptr @buffer_typ, ptr %49, align 8
  %result.i72 = call ptr %45({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %46) #16
  %50 = call { ptr, i160 } %result.i72({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %38, { ptr, i160 } %3, i32 %23, i32 %30, { ptr } %35) #7
  %.fca.0.extract = extractvalue { ptr, i160 } %50, 0
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract31)
  %52 = icmp ne ptr %.fca.0.extract, @nil_typ
  %53 = icmp ne ptr %.fca.0.extract, null
  %.not63 = and i1 %52, %53
  br i1 %.not63, label %.thread, label %54

54:                                               ; preds = %4
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %57 = getelementptr i8, ptr %15, i64 112
  %58 = load ptr, ptr %57, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i73 = call ptr %58({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %6) #16
  %59 = call i32 %result.i73({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(8) %5, i32 %23) #7
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %61 = getelementptr i8, ptr %15, i64 32
  %62 = load ptr, ptr %61, align 8
  %63 = load ptr, ptr %62, align 8
  %64 = call { ptr } %63(ptr %.fca.1.extract32) #37
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %66 = load ptr, ptr %15, align 8
  %result.i74 = call ptr %66(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract32) #5
  %result.i75 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @buffer_typ, ptr %result.i75, align 8
  store ptr %result.i74, ptr %7, align 8
  %67 = getelementptr inbounds i8, ptr %7, i64 8
  store ptr @_parameterization_Ptri32, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %7, i64 16
  store ptr @_parameterization_Ptri32, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %7, i64 24
  store ptr %result.i75, ptr %69, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %7)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %72 = load ptr, ptr %44, align 8
  store ptr %.fca.0.extract24, ptr %8, align 8
  %73 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr @i32_typ, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %8, i64 16
  store ptr @i32_typ, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %8, i64 24
  store ptr @buffer_typ, ptr %75, align 8
  %result.i76 = call ptr %72({ ptr, ptr, ptr, i32 } %12, ptr nocapture nofree noundef nonnull readonly %8) #16
  %76 = call { ptr, i160 } %result.i76({ ptr, ptr, ptr, i32 } %12, { ptr, ptr, ptr, i32 } %12, ptr nonnull align 8 dereferenceable(32) %7, { ptr, i160 } %3, i32 %23, i32 %59, { ptr } %64) #7
  %.fca.0.extract51 = extractvalue { ptr, i160 } %76, 0
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef nonnull %.fca.0.extract31)
  %78 = icmp ne ptr %.fca.0.extract51, @nil_typ
  %79 = icmp ne ptr %.fca.0.extract51, null
  %.not65.not.not = and i1 %78, %79
  %cond.fr = freeze i1 %.not65.not.not
  %spec.select = select i1 %cond.fr, ptr %.fca.0.extract51, ptr @nil_typ
  br label %.thread

.thread:                                          ; preds = %54, %4
  %.pn = phi { ptr, i160 } [ %50, %4 ], [ %76, %54 ]
  %80 = phi ptr [ %.fca.0.extract, %4 ], [ %spec.select, %54 ]
  %.fca.1.extract..sroa.354.0106 = extractvalue { ptr, i160 } %.pn, 1
  %.reload55.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %80, 0
  %.reload55.fca.1.insert = insertvalue { ptr, i160 } %.reload55.fca.0.insert, i160 %.fca.1.extract..sroa.354.0106, 1
  ret { ptr, i160 } %.reload55.fca.1.insert
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMap_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !563
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !563
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !563
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !563
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 40
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  tail call void %10(ptr %.fca.1.extract, i32 8) #36
  %result.i = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract) #35
  %12 = getelementptr i8, ptr %6, i64 24
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %15(ptr %.fca.1.extract, { ptr } %16) #36
  %result.i5 = tail call noalias dereferenceable_or_null(256) ptr @bump_malloc_inner(i64 noundef 256, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract) #35
  %18 = getelementptr i8, ptr %6, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr } undef, ptr %result.i5, 0
  tail call void %21(ptr %.fca.1.extract, { ptr } %22) #36
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract) #35
  %24 = getelementptr i8, ptr %6, i64 48
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  tail call void %27(ptr %.fca.1.extract, i32 0) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @CuckooMap_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !566
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !566
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !566
  %product.i.i.i = mul i64 %hash_coef.i.i, 3547150501766965522
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !566
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract13, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr } %9(ptr %.fca.1.extract) #37
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call { ptr } %14(ptr %.fca.1.extract) #37
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %17 = getelementptr i8, ptr %6, i64 40
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call i32 %19(ptr %.fca.1.extract) #37
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %22 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %22(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %24 = getelementptr i8, ptr %6, i64 8
  %25 = load ptr, ptr %24, align 8
  %result.i14 = tail call ptr %25(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %result.i15 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %28 = getelementptr inbounds i8, ptr %result.i15, i64 16
  store ptr %result.i14, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i15, i64 8
  store ptr %result.i, ptr %29, align 8
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i15) #35
  store ptr @Pair, ptr %result.i15, align 8
  %result.i17 = tail call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i17, align 8
  %31 = getelementptr inbounds i8, ptr %result.i17, i64 8
  store ptr %result.i14, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %result.i17, i64 16
  store ptr %result.i15, ptr %32, align 8
  %33 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i17) #35
  %34 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %35 = load ptr, ptr %7, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = tail call { ptr } %36(ptr %.fca.1.extract) #37
  %38 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %39 = load ptr, ptr %12, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = tail call { ptr } %40(ptr %.fca.1.extract) #37
  %42 = tail call ptr @llvm.invariant.start.p0(i64 noundef 2176, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %43 = load ptr, ptr %17, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = tail call i32 %44(ptr %.fca.1.extract) #37
  %46 = insertvalue { ptr, ptr, ptr, i32 } { ptr @CuckooMapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i17, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr undef, 2
  %48 = getelementptr inbounds i8, ptr %result.i17, i64 24
  %.fca.0.extract.i = extractvalue { ptr } %37, 0
  store ptr %.fca.0.extract.i, ptr %48, align 8
  %49 = getelementptr inbounds i8, ptr %result.i17, i64 32
  %.fca.0.extract.i51 = extractvalue { ptr } %41, 0
  store ptr %.fca.0.extract.i51, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i17, i64 40
  store i32 %45, ptr %50, align 8
  %51 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull @CuckooMapIterator) #35
  %52 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 24, 3
  ret { ptr, ptr, ptr, i32 } %52
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_CuckooMapIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @CuckooMapIterator_field_CuckooMapIterator_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_lenPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @CuckooMapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @CuckooMapIterator_init_map_table1BufferEntryK._V_or_Nil_map_table2BufferEntryK._V_or_Nil_table_lenPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4, i32 %5) #2 {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !569
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !569
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !569
  %product.i.i.i = mul i64 %hash_coef.i.i, -1975748647346050920
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !569
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract5, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  tail call void %13(ptr %.fca.1.extract, { ptr } %3) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #35
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract, { ptr } %4) #36
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #35
  %20 = getelementptr i8, ptr %9, i64 40
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  tail call void %23(ptr %.fca.1.extract, i32 %5) #36
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #35
  %25 = getelementptr i8, ptr %9, i64 48
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  tail call void %28(ptr %.fca.1.extract, i32 0) #36
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #35
  %30 = getelementptr i8, ptr %9, i64 56
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  tail call void %33(ptr %.fca.1.extract, i1 false) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @CuckooMapIterator_next_from_table_tableBufferEntryK._V_or_Nil({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -1975748647346050920
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract = extractvalue { ptr } %3, 0
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #39
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract5, i64 %7
  %9 = getelementptr i8, ptr %8, i64 48
  %10 = getelementptr i8, ptr %8, i64 40
  br label %11

11:                                               ; preds = %20, %4
  %12 = load ptr, ptr %9, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = tail call i32 %13(ptr %.fca.1.extract6) #37
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #39
  %16 = load ptr, ptr %10, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract6) #37
  %19 = icmp slt i32 %14, %18
  br i1 %19, label %20, label %.thread83

20:                                               ; preds = %11
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %22 = tail call i32 %13(ptr %.fca.1.extract6) #37
  %23 = sext i32 %22 to i64
  %24 = shl nsw i64 %23, 5
  %25 = getelementptr i8, ptr %.fca.0.extract, i64 %24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %25, i64 8
  %28 = load i160, ptr %27, align 4
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %30 = tail call i32 %13(ptr %.fca.1.extract6) #37
  %31 = add i32 %30, 1
  %32 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %33 = getelementptr i8, ptr %12, i64 8
  %34 = load ptr, ptr %33, align 8
  tail call void %34(ptr %.fca.1.extract6, i32 %31) #36
  %35 = icmp eq ptr %26, @nil_typ
  %36 = icmp eq ptr %26, null
  %.not30.not = or i1 %35, %36
  br i1 %.not30.not, label %11, label %37

37:                                               ; preds = %20
  %.sroa.373.8.extract.trunc = trunc i160 %28 to i64
  %38 = inttoptr i64 %.sroa.373.8.extract.trunc to ptr
  %.sroa.574.8.extract.shift = lshr i160 %28, 64
  %.sroa.574.8.extract.trunc = trunc i160 %.sroa.574.8.extract.shift to i64
  %39 = inttoptr i64 %.sroa.574.8.extract.trunc to ptr
  %hash_coef_ptr.i.i32 = getelementptr i8, ptr %26, i64 8
  %tbl_size_ptr.i.i33 = getelementptr i8, ptr %26, i64 16
  %offset_tbl_ptr.i.i34 = getelementptr i8, ptr %26, i64 40
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i32, align 4
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i33, align 4
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i34, align 8
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 4015701072841558310
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %26, 0
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %38, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %39, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %offset.i.i43, 3
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %45 = tail call ptr @llvm.invariant.start.p0(i64 noundef 120, ptr nocapture nofree noundef %26)
  %46 = sext i32 %offset.i.i43 to i64
  %47 = getelementptr ptr, ptr %26, i64 %46
  %48 = getelementptr i8, ptr %47, i64 72
  %49 = load ptr, ptr %48, align 8
  %result.i = call ptr %49({ ptr, ptr, ptr, i32 } %43, ptr nocapture nofree noundef nonnull readonly %5) #16
  %50 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr nonnull align 8 %5) #7
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %50, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %50, 1
  %.fca.2.extract10 = extractvalue { ptr, ptr, ptr, i32 } %50, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 9197944775169318296
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i56, align 4
  %51 = ptrtoint ptr %.fca.1.extract9 to i64
  %52 = ptrtoint ptr %.fca.2.extract10 to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i.i57 to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %52 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext = zext i64 %51 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext
  br label %.thread83

.thread83:                                        ; preds = %11, %37
  %.reg2mem26.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %37 ], [ undef, %11 ]
  %.reg2mem26.sroa.0.0 = phi ptr [ %.fca.0.extract8, %37 ], [ @nil_typ, %11 ]
  %.reload27.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem26.sroa.0.0, 0
  %.reload27.fca.1.insert = insertvalue { ptr, i160 } %.reload27.fca.0.insert, i160 %.reg2mem26.sroa.3.0, 1
  ret { ptr, i160 } %.reload27.fca.1.insert
}

define { ptr, i160 } @CuckooMapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [1 x ptr], align 8
  %5 = alloca { ptr }, align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -1975748647346050920
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef %.fca.0.extract5) #35
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract5, i64 %9
  %11 = getelementptr i8, ptr %10, i64 56
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = tail call i1 %13(ptr %.fca.1.extract6) #37
  br i1 %14, label %._crit_edge, label %15

._crit_edge:                                      ; preds = %3
  %.pre = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %.pre65 = insertvalue { ptr, ptr, ptr, i32 } %.pre, ptr %.fca.1.extract6, 1
  %.pre67 = insertvalue { ptr, ptr, ptr, i32 } %.pre65, ptr %.fca.2.extract, 2
  %.pre69 = insertvalue { ptr, ptr, ptr, i32 } %.pre67, i32 %offset.i.i, 3
  br label %43

15:                                               ; preds = %3
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #41
  %17 = getelementptr i8, ptr %10, i64 24
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract6) #37
  %21 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.1.extract6, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.2.extract, 2
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, i32 %offset.i.i, 3
  %result.i = tail call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr @buffer_typ, ptr %result.i, align 8
  store ptr %result.i, ptr %4, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %4) #41
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #41
  %27 = getelementptr i8, ptr %10, i64 72
  %28 = load ptr, ptr %27, align 8
  store ptr @buffer_typ, ptr %5, align 8
  %result.i25 = call ptr %28({ ptr, ptr, ptr, i32 } %24, ptr nocapture nofree noundef nonnull readonly %5) #16
  %29 = call { ptr, i160 } %result.i25({ ptr, ptr, ptr, i32 } %24, { ptr, ptr, ptr, i32 } %24, ptr nonnull align 8 dereferenceable(8) %4, { ptr } %20) #7
  %.fca.0.extract15 = extractvalue { ptr, i160 } %29, 0
  %30 = icmp ne ptr %.fca.0.extract15, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract15, null
  %.not22.not.not = and i1 %30, %31
  br i1 %.not22.not.not, label %42, label %32

32:                                               ; preds = %15
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %34 = getelementptr i8, ptr %10, i64 48
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  call void %37(ptr %.fca.1.extract6, i32 0) #36
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %39 = load ptr, ptr %11, align 8
  %40 = getelementptr i8, ptr %39, i64 8
  %41 = load ptr, ptr %40, align 8
  call void %41(ptr %.fca.1.extract6, i1 true) #36
  br label %43

42:                                               ; preds = %15
  %.fca.1.extract16 = extractvalue { ptr, i160 } %29, 1
  %hash_coef_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract15, i64 8
  %tbl_size_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract15, i64 16
  %offset_tbl_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract15, i64 40
  %hash_coef.i.i30 = load i64, ptr %hash_coef_ptr.i.i27, align 4
  %tbl_size.i.i31 = load i64, ptr %tbl_size_ptr.i.i28, align 4
  %offset_tbl.i.i32 = load ptr, ptr %offset_tbl_ptr.i.i29, align 8
  %product.i.i.i33 = mul i64 %hash_coef.i.i30, 9197944775169318296
  %shifted.i.i.i34 = lshr i64 %product.i.i.i33, 32
  %xored.i.i.i35 = xor i64 %shifted.i.i.i34, %product.i.i.i33
  %hash.i.i.i36 = and i64 %xored.i.i.i35, %tbl_size.i.i31
  %offset_ptr.i.i37 = getelementptr i32, ptr %offset_tbl.i.i32, i64 %hash.i.i.i36
  %offset.i.i38 = load i32, ptr %offset_ptr.i.i37, align 4
  %.sroa.5.8.insert.ext = zext i32 %offset.i.i38 to i160
  %.sroa.5.8.insert.shift = shl nuw i160 %.sroa.5.8.insert.ext, 128
  %.sroa.3.8.insert.ext = and i160 %.fca.1.extract16, 340282366920938463463374607431768211455
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.shift, %.sroa.3.8.insert.ext
  br label %55

43:                                               ; preds = %._crit_edge, %32
  %.pre-phi70 = phi { ptr, ptr, ptr, i32 } [ %.pre69, %._crit_edge ], [ %24, %32 ]
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #41
  %45 = getelementptr i8, ptr %10, i64 32
  %46 = load ptr, ptr %45, align 8
  %47 = load ptr, ptr %46, align 8
  %48 = call { ptr } %47(ptr %.fca.1.extract6) #37
  %result.i40 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %49 = getelementptr inbounds i8, ptr %result.i40, i64 8
  store ptr null, ptr %49, align 8
  store ptr @buffer_typ, ptr %result.i40, align 8
  store ptr %result.i40, ptr %6, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #41
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 136, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #41
  %52 = getelementptr i8, ptr %10, i64 72
  %53 = load ptr, ptr %52, align 8
  store ptr @buffer_typ, ptr %7, align 8
  %result.i41 = call ptr %53({ ptr, ptr, ptr, i32 } %.pre-phi70, ptr nocapture nofree noundef nonnull readonly %7) #16
  %54 = call { ptr, i160 } %result.i41({ ptr, ptr, ptr, i32 } %.pre-phi70, { ptr, ptr, ptr, i32 } %.pre-phi70, ptr nonnull align 8 dereferenceable(8) %6, { ptr } %48) #7
  %.fca.0.extract7 = extractvalue { ptr, i160 } %54, 0
  %.fca.1.extract8 = extractvalue { ptr, i160 } %54, 1
  br label %55

55:                                               ; preds = %42, %43
  %.reg2mem37.sroa.0.0 = phi ptr [ %.fca.0.extract7, %43 ], [ %.fca.0.extract15, %42 ]
  %.reg2mem37.sroa.3.0 = phi i160 [ %.fca.1.extract8, %43 ], [ %.sroa.3.8.insert.insert, %42 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem37.sroa.0.0, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem37.sroa.3.0, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @CuckooMapIterator_getter_on_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_on_second(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMapIterator_getter_table_len(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_table_len(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table2(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table2(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMapIterator_getter_map_table1(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMapIterator_setter_map_table1(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_eq(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_eq(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_hasher(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_hasher(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_size(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 44
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_size(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 44
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @CuckooMap_getter_table_len(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table_len(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table2(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table2(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @CuckooMap_getter_table1(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @CuckooMap_setter_table1(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_KeyNotFound(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @KeyNotFound_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_message(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_message(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @KeyNotFound_getter_file_name(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_file_name(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @KeyNotFound_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @KeyNotFound_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Map(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMap(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Map_field_Map_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Map_field_Map_1(ptr nocapture nofree readonly align 8 %0) local_unnamed_addr #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Map_field_Map_2(ptr nocapture nofree readonly align 8 %0) local_unnamed_addr #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define { ptr, i160 } @Map__index_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !572
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !572
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !572
  %product.i.i.i = mul i64 %hash_coef.i.i, -5249855671126779970
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !572
  %.fca.0.extract6 = extractvalue { ptr, i160 } %3, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract12, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i.i, 3
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 480, ptr nocapture nofree noundef %.fca.0.extract11) #35
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract11, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i = tail call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %13 = alloca [1 x ptr], align 8
  store ptr %result.i, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %13) #35
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 480, ptr nocapture nofree noundef %.fca.0.extract11) #35
  %16 = getelementptr i8, ptr %11, i64 32
  %17 = load ptr, ptr %16, align 8
  %18 = alloca { ptr }, align 8
  store ptr %.fca.0.extract6, ptr %18, align 8
  %result.i51 = call ptr %17({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly %18) #16
  %19 = call { ptr, i160 } %result.i51({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 dereferenceable(8) %13, { ptr, i160 } %3) #7
  %.fca.0.extract = extractvalue { ptr, i160 } %19, 0
  %20 = icmp eq ptr %.fca.0.extract, @nil_typ
  %21 = icmp eq ptr %.fca.0.extract, null
  %22 = or i1 %20, %21
  br i1 %22, label %23, label %._crit_edge

23:                                               ; preds = %4
  %result.i53 = call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i = call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %24 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %24, align 4
  %25 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %25, align 4
  %26 = getelementptr i8, ptr %result.i53, i64 40
  store ptr @String, ptr %26, align 8
  %27 = getelementptr i8, ptr %result.i53, i64 48
  store ptr %result.i29.i, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i53, i64 64
  store i32 10, ptr %28, align 4
  %29 = getelementptr i8, ptr %result.i53, i64 8
  %30 = getelementptr i8, ptr %result.i53, i64 16
  %31 = getelementptr i8, ptr %result.i53, i64 32
  %result.i55 = call noalias align 8 dereferenceable_or_null(9) ptr @bump_malloc_inner(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <8 x i8> <i8 109, i8 97, i8 112, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i55, align 8
  %result.i57 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i55, ptr %result.i57, align 8
  %32 = getelementptr i8, ptr %result.i57, i64 8
  store i32 8, ptr %32, align 4
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %34 = getelementptr i8, ptr %result.i57, i64 12
  store i32 9, ptr %34, align 4
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @KeyNotFound)
  store i32 16, ptr %result.i53, align 4
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @KeyNotFound) #35
  store ptr @String, ptr %29, align 8
  store ptr %result.i57, ptr %30, align 8
  store i32 10, ptr %31, align 4
  %37 = ptrtoint ptr %result.i53 to i64
  %.sroa.444.8.insert.ext = zext i64 %37 to i160
  %.sroa.444.8.insert.insert = or disjoint i160 %.sroa.444.8.insert.ext, 3402823669209384634633746074317682114560
  %38 = insertvalue { ptr, i160 } { ptr @KeyNotFound, i160 undef }, i160 %.sroa.444.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %39 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %38, ptr %39, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %23
  %.sroa.0.0 = phi ptr [ @nil_typ, %23 ], [ %.fca.0.extract, %4 ]
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 480, ptr nocapture nofree noundef nonnull %.fca.0.extract11)
  %.fca.1.extract = extractvalue { ptr, i160 } %19, 1
  %.reload13.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.sroa.0.0, 0
  %.reload13.fca.1.insert = insertvalue { ptr, i160 } %.reload13.fca.0.insert, i160 %.fca.1.extract, 1
  ret { ptr, i160 } %.reload13.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B__index_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Map_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_1(ptr nocapture nofree readonly align 8 %0) local_unnamed_addr #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_4(ptr nocapture nofree readonly align 8 %0) local_unnamed_addr #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B__set_index_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B__index_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #0 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #0 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

; Function Attrs: nounwind
define range(i32 0, -2147483648) i32 @string_hasher({ ptr, ptr, ptr, i32 } %0) local_unnamed_addr #7 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !575
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !575
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !575
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !575
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract6, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract7, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract8, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i, 3
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #39
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract6) #39
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract6, i64 %9
  %11 = getelementptr i8, ptr %10, i64 136
  %12 = load ptr, ptr %11, align 8
  %result.i = call ptr %12({ ptr, ptr, ptr, i32 } %6, ptr nocapture nofree noundef nonnull readonly %2) #16
  %13 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %6, { ptr, ptr, ptr, i32 } %6, ptr nonnull align 8 %2) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 2
  %hash_coef_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i34 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i32, align 4, !noalias !22
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i33, align 4, !noalias !22
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i34, align 8, !noalias !22
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, -7260570988945952630
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !578
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i57, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %20 = sext i32 %offset.i.i57 to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %21, i64 32
  %23 = load ptr, ptr %22, align 8
  %result.i59102 = call ptr %23({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %2) #16
  %24 = call { ptr, i160 } %result.i59102({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %2) #7
  %.fca.0.extract21103 = extractvalue { ptr, i160 } %24, 0
  %25 = icmp ne ptr %.fca.0.extract21103, @nil_typ
  %26 = icmp ne ptr %.fca.0.extract21103, null
  %.not30104 = and i1 %25, %26
  br i1 %.not30104, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %1
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.fca.0.extract21106 = phi ptr [ %.fca.0.extract21103, %._crit_edge.lr.ph ], [ %.fca.0.extract21, %._crit_edge ]
  %28 = phi { ptr, i160 } [ %24, %._crit_edge.lr.ph ], [ %46, %._crit_edge ]
  %.0105 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %44, %._crit_edge ]
  %.fca.1.extract22 = extractvalue { ptr, i160 } %28, 1
  %.sroa.7.8.extract.shift = lshr i160 %.fca.1.extract22, 64
  %.sroa.7.8.extract.trunc = trunc i160 %.sroa.7.8.extract.shift to i64
  %.sroa.428.8.extract.trunc = trunc i160 %.fca.1.extract22 to i64
  %29 = inttoptr i64 %.sroa.428.8.extract.trunc to ptr
  %30 = inttoptr i64 %.sroa.7.8.extract.trunc to ptr
  %hash_coef_ptr.i.i61 = getelementptr i8, ptr %.fca.0.extract21106, i64 8
  %tbl_size_ptr.i.i62 = getelementptr i8, ptr %.fca.0.extract21106, i64 16
  %offset_tbl_ptr.i.i63 = getelementptr i8, ptr %.fca.0.extract21106, i64 40
  %hash_coef.i.i64 = load i64, ptr %hash_coef_ptr.i.i61, align 4, !noalias !581
  %tbl_size.i.i65 = load i64, ptr %tbl_size_ptr.i.i62, align 4, !noalias !581
  %offset_tbl.i.i66 = load ptr, ptr %offset_tbl_ptr.i.i63, align 8, !noalias !581
  %product.i.i.i67 = mul i64 %hash_coef.i.i64, 6681222582356018452
  %shifted.i.i.i68 = lshr i64 %product.i.i.i67, 32
  %xored.i.i.i69 = xor i64 %shifted.i.i.i68, %product.i.i.i67
  %hash.i.i.i70 = and i64 %xored.i.i.i69, %tbl_size.i.i65
  %offset_ptr.i.i71 = getelementptr i32, ptr %offset_tbl.i.i66, i64 %hash.i.i.i70
  %offset.i.i72 = load i32, ptr %offset_ptr.i.i71, align 4, !noalias !581
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21106, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %29, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %30, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %offset.i.i72, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull %.fca.0.extract21106)
  %36 = sext i32 %offset.i.i72 to i64
  %37 = getelementptr ptr, ptr %.fca.0.extract21106, i64 %36
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %result.i74 = call ptr %39({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly %2) #16
  %40 = call i8 %result.i74({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %2) #7
  %41 = sext i8 %40 to i32
  %42 = mul i32 %.0105, 31
  %43 = add i32 %42, %41
  %44 = and i32 %43, 2147483647
  %45 = load ptr, ptr %22, align 8
  %result.i59 = call ptr %45({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %2) #16
  %46 = call { ptr, i160 } %result.i59({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %2) #7
  %.fca.0.extract21 = extractvalue { ptr, i160 } %46, 0
  %47 = icmp ne ptr %.fca.0.extract21, @nil_typ
  %48 = icmp ne ptr %.fca.0.extract21, null
  %.not30 = and i1 %47, %48
  br i1 %.not30, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %1
  %.0.lcssa = phi i32 [ 0, %1 ], [ %44, %._crit_edge ]
  ret i32 %.0.lcssa
}

; Function Attrs: nounwind
define i1 @string_eq({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1) local_unnamed_addr #7 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !584
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !584
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !584
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !584
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !587
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i35, 3
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract2, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract3, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract1, i64 %14
  %16 = getelementptr i8, ptr %15, i64 112
  %17 = load ptr, ptr %16, align 8
  %18 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %18, align 8
  %result.i = call ptr %17({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %18) #16
  %19 = call i1 %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %6) #7
  ret i1 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Representable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #13 {
  %result.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %result.i, align 8
  %result.i15 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i15, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i, ptr %result.i15, align 8
  %7 = getelementptr i8, ptr %result.i15, i64 8
  store i32 6, ptr %7, align 4
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %9 = getelementptr i8, ptr %result.i15, i64 12
  store i32 7, ptr %9, align 4
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_String(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @String_field_String_0(ptr nocapture nofree readnone %0) #0 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @String_B__Self_from_c_string_c_stringBufferPtri8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  ret ptr @String__Self_from_c_string_c_stringBufferPtri8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferPtri8_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_bytes_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_xPtri8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_extend_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_pop_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String__Self_from_c_string_c_stringBufferPtri8(ptr nocapture nofree readnone %0, { ptr } %1) #14 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge, %2
  %.0 = phi i32 [ 0, %2 ], [ %6, %._crit_edge ]
  %3 = sext i32 %.0 to i64
  %4 = getelementptr i8, ptr %.fca.0.extract, i64 %3
  %5 = load i8, ptr %4, align 1
  %.not = icmp eq i8 %5, 0
  %6 = add i32 %.0, 1
  br i1 %.not, label %7, label %._crit_edge

7:                                                ; preds = %._crit_edge
  %result.i23 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %8 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i23, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr undef, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 10, 3
  store ptr %.fca.0.extract, ptr %result.i23, align 8
  %11 = getelementptr i8, ptr %result.i23, i64 8
  store i32 %.0, ptr %11, align 4
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %13 = getelementptr i8, ptr %result.i23, i64 12
  store i32 %6, ptr %13, align 4
  ret { ptr, ptr, ptr, i32 } %10
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !590
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !590
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !590
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !590
  %result.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %9(ptr %.fca.1.extract, { ptr } %10) #36
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #35
  %12 = getelementptr i8, ptr %6, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 1) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #35
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, i32 0) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_bytesBufferPtri8_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !593
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !593
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !593
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !593
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract2, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3) #36
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4) #36
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 %5) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !596
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !596
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !596
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !596
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #37
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !599
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !599
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !599
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !599
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #37
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr } @String_bytes_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !602
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !602
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !602
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !602
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract1, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { ptr } %8(ptr %.fca.1.extract) #37
  ret { ptr } %9
}

; Function Attrs: nounwind
define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !605
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !605
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !605
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !605
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #39
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #37
  %11 = add i32 %10, 1
  %12 = sext i32 %11 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %14 = load ptr, ptr %7, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract) #37
  %17 = icmp sgt i32 %16, 0
  br i1 %17, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %3
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.029 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %26, %._crit_edge ]
  %19 = load ptr, ptr %6, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { ptr } %20(ptr %.fca.1.extract) #37
  %.fca.0.extract15 = extractvalue { ptr } %21, 0
  %22 = zext nneg i32 %.029 to i64
  %23 = getelementptr i8, ptr %.fca.0.extract15, i64 %22
  %24 = load i8, ptr %23, align 1
  %25 = getelementptr i8, ptr %result.i, i64 %22
  store i8 %24, ptr %25, align 1
  %26 = add nuw nsw i32 %.029, 1
  %27 = load ptr, ptr %7, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = tail call i32 %28(ptr %.fca.1.extract) #37
  %30 = icmp slt i32 %26, %29
  br i1 %30, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %31 = phi ptr [ %15, %3 ], [ %28, %._crit_edge ]
  %32 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %33 = tail call i32 %31(ptr %.fca.1.extract) #37
  %34 = sext i32 %33 to i64
  %35 = getelementptr i8, ptr %result.i, i64 %34
  store i8 0, ptr %35, align 1
  %36 = insertvalue { ptr } undef, ptr %result.i, 0
  ret { ptr } %36
}

define { ptr, ptr, ptr, i32 } @String_append_xPtri8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) {
  %.sroa.091 = alloca ptr, align 8
  %5 = alloca i32, align 4
  %.sroa.087 = alloca ptr, align 8
  %.sroa.188 = alloca ptr, align 8
  %.sroa.289 = alloca ptr, align 8
  %.sroa.390 = alloca i32, align 8
  %.sroa.086 = alloca ptr, align 8
  %6 = alloca i32, align 4
  %.sroa.085 = alloca ptr, align 8
  %.sroa.1 = alloca ptr, align 8
  %.sroa.2 = alloca ptr, align 8
  %.sroa.3 = alloca i32, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #39
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract) #37
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #39
  %15 = getelementptr i8, ptr %9, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract) #37
  %19 = icmp slt i32 %13, %18
  br i1 %19, label %._crit_edge.thread, label %20

20:                                               ; preds = %4
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %22 = tail call i32 %17(ptr %.fca.1.extract) #37
  %23 = shl i32 %22, 1
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %25 = getelementptr i8, ptr %16, i64 8
  %26 = load ptr, ptr %25, align 8
  tail call void %26(ptr %.fca.1.extract, i32 %23) #36
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %28 = load ptr, ptr %9, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call { ptr } %29(ptr %.fca.1.extract) #37
  %.fca.0.extract17 = extractvalue { ptr } %30, 0
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = load ptr, ptr %15, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call i32 %33(ptr %.fca.1.extract) #37
  %35 = sext i32 %34 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %35, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %37 = load ptr, ptr %9, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %39(ptr %.fca.1.extract, { ptr } %40) #36
  %41 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %42 = load ptr, ptr %10, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = tail call i32 %43(ptr %.fca.1.extract) #37
  %45 = icmp sgt i32 %44, 0
  br i1 %45, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %20
  %46 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.093 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %54, %._crit_edge ]
  %47 = zext nneg i32 %.093 to i64
  %48 = getelementptr i8, ptr %.fca.0.extract17, i64 %47
  %49 = load i8, ptr %48, align 1
  %50 = load ptr, ptr %9, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = tail call { ptr } %51(ptr %.fca.1.extract) #37
  %.fca.0.extract5 = extractvalue { ptr } %52, 0
  %53 = getelementptr i8, ptr %.fca.0.extract5, i64 %47
  store i8 %49, ptr %53, align 1
  %54 = add nuw nsw i32 %.093, 1
  %55 = load ptr, ptr %10, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = tail call i32 %56(ptr %.fca.1.extract) #37
  %58 = icmp slt i32 %54, %57
  br i1 %58, label %._crit_edge, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %20, %4
  %.sroa.phi = phi ptr [ %.sroa.188, %4 ], [ %.sroa.1, %20 ], [ %.sroa.1, %._crit_edge ]
  %.sroa.phi76 = phi ptr [ %.sroa.289, %4 ], [ %.sroa.2, %20 ], [ %.sroa.2, %._crit_edge ]
  %.sroa.phi79 = phi ptr [ %.sroa.390, %4 ], [ %.sroa.3, %20 ], [ %.sroa.3, %._crit_edge ]
  %59 = phi ptr [ %.sroa.087, %4 ], [ %.sroa.085, %20 ], [ %.sroa.085, %._crit_edge ]
  %60 = phi ptr [ %5, %4 ], [ %6, %20 ], [ %6, %._crit_edge ]
  %61 = phi ptr [ %.sroa.091, %4 ], [ %.sroa.086, %20 ], [ %.sroa.086, %._crit_edge ]
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %62 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %63 = load ptr, ptr %9, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = tail call { ptr } %64(ptr %.fca.1.extract) #37
  %66 = extractvalue { ptr } %65, 0
  store ptr %66, ptr %61, align 8
  %67 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %68 = load ptr, ptr %10, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = tail call i32 %69(ptr %.fca.1.extract) #37
  %71 = sext i32 %70 to i64
  %72 = getelementptr i8, ptr %66, i64 %71
  store i8 %3, ptr %72, align 1
  %73 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %74 = load ptr, ptr %10, align 8
  %75 = load ptr, ptr %74, align 8
  %76 = tail call i32 %75(ptr %.fca.1.extract) #37
  store i32 %76, ptr %60, align 4
  %77 = add i32 %76, 1
  %78 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %79 = getelementptr i8, ptr %74, i64 8
  %80 = load ptr, ptr %79, align 8
  tail call void %80(ptr %.fca.1.extract, i32 %77) #36
  store ptr %.fca.0.extract, ptr %59, align 8
  store ptr %.fca.1.extract, ptr %.sroa.phi, align 8
  store ptr %.fca.2.extract, ptr %.sroa.phi76, align 8
  store i32 %offset.i.i, ptr %.sroa.phi79, align 8
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, 6499063144389013426
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i34 = load i32, ptr %offset_ptr.i.i33, align 4
  store i32 %offset.i.i34, ptr %.sroa.phi79, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %82 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %.fca.1.extract, 1
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %.fca.2.extract, 2
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %offset.i.i34, 3
  ret { ptr, ptr, ptr, i32 } %84
}

define { ptr, ptr, ptr, i32 } @String_extend_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca [0 x ptr], align 8
  %.sroa.0168 = alloca ptr, align 8
  %.sroa.1169 = alloca ptr, align 8
  %.sroa.2170 = alloca ptr, align 8
  %.sroa.3171 = alloca i32, align 8
  %.sroa.0167 = alloca ptr, align 8
  %.sroa.1 = alloca ptr, align 8
  %.sroa.2 = alloca ptr, align 8
  %.sroa.3 = alloca i32, align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i75 = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i76 = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i77 = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i78 = load i64, ptr %hash_coef_ptr.i.i75, align 4
  %tbl_size.i.i79 = load i64, ptr %tbl_size_ptr.i.i76, align 4
  %offset_tbl.i.i80 = load ptr, ptr %offset_tbl_ptr.i.i77, align 8
  %product.i.i.i81 = mul i64 %hash_coef.i.i78, 6499063144389013426
  %shifted.i.i.i82 = lshr i64 %product.i.i.i81, 32
  %xored.i.i.i83 = xor i64 %shifted.i.i.i82, %product.i.i.i81
  %hash.i.i.i84 = and i64 %xored.i.i.i83, %tbl_size.i.i79
  %offset_ptr.i.i85 = getelementptr i32, ptr %offset_tbl.i.i80, i64 %hash.i.i.i84
  %offset.i.i86 = load i32, ptr %offset_ptr.i.i85, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i86, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #39
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract11) #39
  %12 = sext i32 %offset.i.i86 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract11, i64 %12
  %14 = getelementptr i8, ptr %13, i64 72
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract11)
  %19 = getelementptr i8, ptr %13, i64 56
  %20 = load ptr, ptr %19, align 8
  %result.i88 = call ptr %20({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %21 = call i32 %result.i88({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract12)
  %23 = sext i32 %offset.i.i to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract12, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %.fca.1.extract13) #37
  %29 = add i32 %28, %21
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract12)
  %31 = getelementptr i8, ptr %24, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract13) #37
  %35 = icmp slt i32 %29, %34
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %37 = call i32 %27(ptr %.fca.1.extract13) #37
  br i1 %35, label %38, label %59

38:                                               ; preds = %4
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %40 = call i32 %27(ptr %.fca.1.extract13) #37
  %41 = add i32 %40, %21
  %42 = icmp slt i32 %37, %41
  br i1 %42, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %38
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.0181 = phi i32 [ %37, %._crit_edge.lr.ph ], [ %52, %._crit_edge ]
  %.068180 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %53, %._crit_edge ]
  %44 = sext i32 %.068180 to i64
  %45 = getelementptr i8, ptr %.fca.0.extract, i64 %44
  %46 = load i8, ptr %45, align 1
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract13) #37
  %.fca.0.extract57 = extractvalue { ptr } %49, 0
  %50 = sext i32 %.0181 to i64
  %51 = getelementptr i8, ptr %.fca.0.extract57, i64 %50
  store i8 %46, ptr %51, align 1
  %52 = add nsw i32 %.0181, 1
  %53 = add i32 %.068180, 1
  %54 = load ptr, ptr %25, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call i32 %55(ptr %.fca.1.extract13) #37
  %57 = add i32 %56, %21
  %58 = icmp slt i32 %52, %57
  br i1 %58, label %._crit_edge, label %._crit_edge.thread

59:                                               ; preds = %4
  %60 = add i32 %37, %21
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %62 = getelementptr i8, ptr %32, i64 8
  %63 = load ptr, ptr %62, align 8
  call void %63(ptr %.fca.1.extract13, i32 %60) #36
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %65 = load ptr, ptr %24, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr } %66(ptr %.fca.1.extract13) #37
  %.fca.0.extract49 = extractvalue { ptr } %67, 0
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %69 = load ptr, ptr %31, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call i32 %70(ptr %.fca.1.extract13) #37
  %72 = sext i32 %71 to i64
  %result.i89 = call noalias ptr @bump_malloc_inner(i64 noundef %72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %74 = load ptr, ptr %24, align 8
  %75 = getelementptr i8, ptr %74, i64 8
  %76 = load ptr, ptr %75, align 8
  %77 = insertvalue { ptr } undef, ptr %result.i89, 0
  call void %76(ptr %.fca.1.extract13, { ptr } %77) #36
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %79 = load ptr, ptr %25, align 8
  %80 = load ptr, ptr %79, align 8
  %81 = call i32 %80(ptr %.fca.1.extract13) #37
  %82 = add i32 %81, %21
  %83 = icmp sgt i32 %82, 0
  br i1 %83, label %.lr.ph, label %._crit_edge.thread

.lr.ph:                                           ; preds = %59
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  br label %85

85:                                               ; preds = %.lr.ph, %._crit_edge2
  %86 = phi ptr [ %80, %.lr.ph ], [ %110, %._crit_edge2 ]
  %.070178 = phi i32 [ 0, %.lr.ph ], [ %.171, %._crit_edge2 ]
  %.072177 = phi i32 [ 0, %.lr.ph ], [ %.173, %._crit_edge2 ]
  %87 = call i32 %86(ptr %.fca.1.extract13) #37
  %88 = icmp slt i32 %.070178, %87
  br i1 %88, label %89, label %98

89:                                               ; preds = %85
  %90 = zext nneg i32 %.070178 to i64
  %91 = getelementptr i8, ptr %.fca.0.extract49, i64 %90
  %92 = load i8, ptr %91, align 1
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %94 = load ptr, ptr %24, align 8
  %95 = load ptr, ptr %94, align 8
  %96 = call { ptr } %95(ptr %.fca.1.extract13) #37
  %.fca.0.extract29 = extractvalue { ptr } %96, 0
  %97 = getelementptr i8, ptr %.fca.0.extract29, i64 %90
  store i8 %92, ptr %97, align 1
  br label %._crit_edge2

98:                                               ; preds = %85
  %99 = sext i32 %.072177 to i64
  %100 = getelementptr i8, ptr %.fca.0.extract, i64 %99
  %101 = load i8, ptr %100, align 1
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %103 = load ptr, ptr %24, align 8
  %104 = load ptr, ptr %103, align 8
  %105 = call { ptr } %104(ptr %.fca.1.extract13) #37
  %.fca.0.extract24 = extractvalue { ptr } %105, 0
  %106 = zext nneg i32 %.070178 to i64
  %107 = getelementptr i8, ptr %.fca.0.extract24, i64 %106
  store i8 %101, ptr %107, align 1
  %108 = add i32 %.072177, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %89, %98
  %.173 = phi i32 [ %.072177, %89 ], [ %108, %98 ]
  %.171 = add nuw nsw i32 %.070178, 1
  %109 = load ptr, ptr %25, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = call i32 %110(ptr %.fca.1.extract13) #37
  %112 = add i32 %111, %21
  %113 = icmp slt i32 %.171, %112
  br i1 %113, label %85, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge2, %._crit_edge, %59, %38
  %114 = phi ptr [ %27, %38 ], [ %80, %59 ], [ %55, %._crit_edge ], [ %110, %._crit_edge2 ]
  %115 = phi ptr [ %26, %38 ], [ %79, %59 ], [ %54, %._crit_edge ], [ %109, %._crit_edge2 ]
  %.sroa.phi = phi ptr [ %.sroa.1169, %38 ], [ %.sroa.1, %59 ], [ %.sroa.1169, %._crit_edge ], [ %.sroa.1, %._crit_edge2 ]
  %.sroa.phi158 = phi ptr [ %.sroa.2170, %38 ], [ %.sroa.2, %59 ], [ %.sroa.2170, %._crit_edge ], [ %.sroa.2, %._crit_edge2 ]
  %.sroa.phi161 = phi ptr [ %.sroa.3171, %38 ], [ %.sroa.3, %59 ], [ %.sroa.3171, %._crit_edge ], [ %.sroa.3, %._crit_edge2 ]
  %116 = phi ptr [ %.sroa.0168, %38 ], [ %.sroa.0167, %59 ], [ %.sroa.0168, %._crit_edge ], [ %.sroa.0167, %._crit_edge2 ]
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %118 = call i32 %114(ptr %.fca.1.extract13) #37
  %119 = add i32 %118, %21
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %121 = getelementptr i8, ptr %115, i64 8
  %122 = load ptr, ptr %121, align 8
  call void %122(ptr %.fca.1.extract13, i32 %119) #36
  store ptr %.fca.0.extract12, ptr %116, align 8
  store ptr %.fca.1.extract13, ptr %.sroa.phi, align 8
  store ptr %.fca.2.extract14, ptr %.sroa.phi158, align 8
  store i32 %offset.i.i, ptr %.sroa.phi161, align 8
  %hash_coef.i.i94 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i95 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i96 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i97 = mul i64 %hash_coef.i.i94, 6499063144389013426
  %shifted.i.i.i98 = lshr i64 %product.i.i.i97, 32
  %xored.i.i.i99 = xor i64 %shifted.i.i.i98, %product.i.i.i97
  %hash.i.i.i100 = and i64 %xored.i.i.i99, %tbl_size.i.i95
  %offset_ptr.i.i101 = getelementptr i32, ptr %offset_tbl.i.i96, i64 %hash.i.i.i100
  %offset.i.i102 = load i32, ptr %offset_ptr.i.i101, align 4
  store i32 %offset.i.i102, ptr %.sroa.phi161, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract12, 0
  %124 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %.fca.1.extract13, 1
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, ptr %.fca.2.extract14, 2
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, i32 %offset.i.i102, 3
  ret { ptr, ptr, ptr, i32 } %126
}

define i8 @String__index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract) #37
  %12 = add i32 %11, -1
  %13 = icmp sgt i32 %3, %12
  br i1 %13, label %14, label %._crit_edge

14:                                               ; preds = %4
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %14
  %15 = icmp sgt i32 %3, -1
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  br i1 %15, label %17, label %23

17:                                               ; preds = %._crit_edge
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #37
  %.fca.0.extract18 = extractvalue { ptr } %20, 0
  %21 = zext nneg i32 %3 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract18, i64 %21
  br label %40

23:                                               ; preds = %._crit_edge
  %24 = load ptr, ptr %8, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = tail call i32 %25(ptr %.fca.1.extract) #37
  %27 = add i32 %26, %3
  %28 = icmp slt i32 %27, 0
  br i1 %28, label %29, label %._crit_edge1

29:                                               ; preds = %23
  %current_coroutine.i22 = load ptr, ptr @current_coroutine, align 8
  %into_callee_buf.i23 = getelementptr i8, ptr %current_coroutine.i22, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i23, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  %.pre = load ptr, ptr %8, align 8
  %.pre36 = load ptr, ptr %.pre, align 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %23, %29
  %30 = phi ptr [ %25, %23 ], [ %.pre36, %29 ]
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = load ptr, ptr %7, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call { ptr } %33(ptr %.fca.1.extract) #37
  %.fca.0.extract11 = extractvalue { ptr } %34, 0
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %36 = tail call i32 %30(ptr %.fca.1.extract) #37
  %37 = add i32 %36, %3
  %38 = sext i32 %37 to i64
  %39 = getelementptr i8, ptr %.fca.0.extract11, i64 %38
  br label %40

40:                                               ; preds = %._crit_edge1, %17
  %.reg2mem20.0.in = phi ptr [ %22, %17 ], [ %39, %._crit_edge1 ]
  %.reg2mem20.0 = load i8, ptr %.reg2mem20.0.in, align 1
  ret i8 %.reg2mem20.0
}

; Function Attrs: nounwind
define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !608
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !608
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !608
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !608
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i30 = load i64, ptr %hash_coef_ptr.i.i27, align 4, !noalias !611
  %tbl_size.i.i31 = load i64, ptr %tbl_size_ptr.i.i28, align 4, !noalias !611
  %offset_tbl.i.i32 = load ptr, ptr %offset_tbl_ptr.i.i29, align 8, !noalias !611
  %product.i.i.i33 = mul i64 %hash_coef.i.i30, 6499063144389013426
  %shifted.i.i.i34 = lshr i64 %product.i.i.i33, 32
  %xored.i.i.i35 = xor i64 %shifted.i.i.i34, %product.i.i.i33
  %hash.i.i.i36 = and i64 %xored.i.i.i35, %tbl_size.i.i31
  %offset_ptr.i.i37 = getelementptr i32, ptr %offset_tbl.i.i32, i64 %hash.i.i.i36
  %offset.i.i38 = load i32, ptr %offset_ptr.i.i37, align 4, !noalias !611
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract2) #39
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call i32 %11(ptr %.fca.1.extract3) #37
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i38, 3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = sext i32 %offset.i.i38 to i64
  %20 = getelementptr ptr, ptr %.fca.0.extract, i64 %19
  %21 = getelementptr i8, ptr %20, i64 56
  %22 = load ptr, ptr %21, align 8
  %result.i = call ptr %22({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %5) #16
  %23 = call i32 %result.i({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %5) #7
  %.not = icmp eq i32 %12, %23
  br i1 %.not, label %.preheader, label %.thread

.preheader:                                       ; preds = %4
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract2)
  %25 = getelementptr i8, ptr %20, i64 72
  br label %26

26:                                               ; preds = %.preheader, %30
  %.0 = phi i32 [ %44, %30 ], [ 0, %.preheader ]
  %27 = load ptr, ptr %9, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = call i32 %28(ptr %.fca.1.extract3) #37
  %.not52.not.not = icmp sge i32 %.0, %29
  br i1 %.not52.not.not, label %.thread, label %30

30:                                               ; preds = %26
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract2)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr } %33(ptr %.fca.1.extract3) #37
  %.fca.0.extract17 = extractvalue { ptr } %34, 0
  %35 = zext nneg i32 %.0 to i64
  %36 = getelementptr i8, ptr %.fca.0.extract17, i64 %35
  %37 = load i8, ptr %36, align 1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %40 = load ptr, ptr %25, align 8
  %result.i40 = call ptr %40({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %5) #16
  %41 = call { ptr } %result.i40({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %5) #7
  %.fca.0.extract14 = extractvalue { ptr } %41, 0
  %42 = getelementptr i8, ptr %.fca.0.extract14, i64 %35
  %43 = load i8, ptr %42, align 1
  %.not25 = icmp eq i8 %37, %43
  %44 = add nuw nsw i32 %.0, 1
  br i1 %.not25, label %26, label %.thread

.thread:                                          ; preds = %26, %30, %4
  %.reg2mem42.0 = phi i1 [ false, %4 ], [ %.not52.not.not, %30 ], [ %.not52.not.not, %26 ]
  ret i1 %.reg2mem42.0
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i8 } @String_pop_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !614
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !614
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !614
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !614
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract4) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract4, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract5) #37
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %30, label %12

12:                                               ; preds = %3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %14 = tail call i32 %9(ptr %.fca.1.extract5) #37
  %15 = add i32 %14, -1
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %17 = getelementptr i8, ptr %8, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract5, i32 %15) #36
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %20 = load ptr, ptr %6, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call { ptr } %21(ptr %.fca.1.extract5) #37
  %.fca.0.extract10 = extractvalue { ptr } %22, 0
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = tail call i32 %25(ptr %.fca.1.extract5) #37
  %27 = sext i32 %26 to i64
  %28 = getelementptr i8, ptr %.fca.0.extract10, i64 %27
  %29 = load i8, ptr %28, align 1
  br label %30

30:                                               ; preds = %3, %12
  %.reg2mem19.sroa.0.0 = phi ptr [ @i8_typ, %12 ], [ @nil_typ, %3 ]
  %.reg2mem19.sroa.3.0 = phi i8 [ %29, %12 ], [ undef, %3 ]
  %.reload20.fca.0.insert = insertvalue { ptr, i8 } poison, ptr %.reg2mem19.sroa.0.0, 0
  %.reload20.fca.1.insert = insertvalue { ptr, i8 } %.reload20.fca.0.insert, i8 %.reg2mem19.sroa.3.0, 1
  ret { ptr, i8 } %.reload20.fca.1.insert
}

define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #39
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #37
  %11 = sext i32 %10 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #37
  %16 = icmp sgt i32 %15, 0
  br i1 %16, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.083 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %25, %._crit_edge ]
  %18 = load ptr, ptr %6, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #37
  %.fca.0.extract24 = extractvalue { ptr } %20, 0
  %21 = zext nneg i32 %.083 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract24, i64 %21
  %23 = load i8, ptr %22, align 1
  %24 = getelementptr i8, ptr %result.i, i64 %21
  store i8 %23, ptr %24, align 1
  %25 = add nuw nsw i32 %.083, 1
  %26 = load ptr, ptr %7, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = tail call i32 %27(ptr %.fca.1.extract) #37
  %29 = icmp slt i32 %25, %28
  br i1 %29, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %30 = phi ptr [ %14, %3 ], [ %27, %._crit_edge ]
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = tail call i32 %30(ptr %.fca.1.extract) #37
  %33 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %34 = tail call i32 %30(ptr %.fca.1.extract) #37
  %result.i29 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %36 = load ptr, ptr %7, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = tail call i32 %37(ptr %.fca.1.extract) #37
  %39 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %40 = tail call i32 %37(ptr %.fca.1.extract) #37
  %41 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i29, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr undef, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 10, 3
  store ptr %result.i, ptr %result.i29, align 8
  %44 = getelementptr i8, ptr %result.i29, i64 8
  store i32 %38, ptr %44, align 4
  %45 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %46 = getelementptr i8, ptr %result.i29, i64 12
  store i32 %40, ptr %46, align 4
  ret { ptr, ptr, ptr, i32 } %43
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #15 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %result.i7 = tail call noalias dereferenceable_or_null(40) ptr @bump_malloc_inner(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %hash_coef.i.i12 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i13 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i14 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i15 = mul i64 %hash_coef.i.i12, 6499063144389013426
  %shifted.i.i.i16 = lshr i64 %product.i.i.i15, 32
  %xored.i.i.i17 = xor i64 %shifted.i.i.i16, %product.i.i.i15
  %hash.i.i.i18 = and i64 %xored.i.i.i17, %tbl_size.i.i13
  %offset_ptr.i.i19 = getelementptr i32, ptr %offset_tbl.i.i14, i64 %hash.i.i.i18
  %offset.i.i20 = load i32, ptr %offset_ptr.i.i19, align 4, !noalias !22
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  store ptr %.fca.0.extract, ptr %result.i7, align 8
  %6 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store i32 %offset.i.i20, ptr %8, align 4
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @StringIterator) #35
  %10 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #16 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i13 = load i32, ptr %offset_ptr.i.i, align 4, !noalias !617
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i.i13, 3
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_StringIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @StringIterator_field_StringIterator_0(ptr nocapture nofree readnone %0) #0 {
  ret ptr @_parameterization_Character
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !620
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !620
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !620
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !620
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !623
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i.i35, 3
  tail call void %10(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %14) #36
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %16 = getelementptr i8, ptr %7, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  tail call void %19(ptr %.fca.1.extract2, i32 0) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !626
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !626
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !626
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !626
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract10) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract12) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract10) #35
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call { ptr, ptr, ptr, i32 } %14(ptr %.fca.1.extract12) #37
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 3
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %.fca.3.extract, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #35
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract) #35
  %22 = sext i32 %.fca.3.extract to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract, i64 %22
  %24 = getelementptr i8, ptr %23, i64 56
  %25 = load ptr, ptr %24, align 8
  %result.i = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly %4) #16
  %26 = call i32 %result.i({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %4) #7
  %27 = icmp slt i32 %11, %26
  br i1 %27, label %28, label %81

28:                                               ; preds = %3
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %30 = load ptr, ptr %8, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = call i32 %31(ptr %.fca.1.extract12) #37
  %33 = add i32 %32, 1
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %35 = getelementptr i8, ptr %30, i64 8
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr %.fca.1.extract12, i32 %33) #36
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %38 = load ptr, ptr %7, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract12) #37
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract51 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract47, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract49, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract51, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract45)
  %47 = sext i32 %.fca.3.extract51 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract45, i64 %47
  %49 = getelementptr i8, ptr %48, i64 72
  %50 = load ptr, ptr %49, align 8
  %result.i56 = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %4) #16
  %51 = call { ptr } %result.i56({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4) #7
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %53 = load ptr, ptr %8, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call i32 %54(ptr %.fca.1.extract12) #37
  %result.i58 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %57 = load ptr, ptr %7, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, ptr, ptr, i32 } %58(ptr %.fca.1.extract12) #37
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %59, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %59, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %59, 3
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.1.extract29, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.2.extract31, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %.fca.3.extract33, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract27)
  %66 = sext i32 %.fca.3.extract33 to i64
  %67 = getelementptr ptr, ptr %.fca.0.extract27, i64 %66
  %68 = getelementptr i8, ptr %67, i64 72
  %69 = load ptr, ptr %68, align 8
  %result.i59 = call ptr %69({ ptr, ptr, ptr, i32 } %63, ptr nocapture nofree noundef nonnull readonly %4) #16
  %70 = call { ptr } %result.i59({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull align 8 %4) #7
  %.fca.0.extract24 = extractvalue { ptr } %70, 0
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %72 = load ptr, ptr %8, align 8
  %73 = load ptr, ptr %72, align 8
  %74 = call i32 %73(ptr %.fca.1.extract12) #37
  %75 = add i32 %74, -1
  %76 = sext i32 %75 to i64
  %77 = getelementptr i8, ptr %.fca.0.extract24, i64 %76
  %78 = load i8, ptr %77, align 1
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @Character) #35
  store i8 %78, ptr %result.i58, align 1
  %80 = ptrtoint ptr %result.i58 to i64
  %.sroa.3.8.insert.ext = zext i64 %80 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %81

81:                                               ; preds = %3, %28
  %.reg2mem25.sroa.0.0 = phi ptr [ @Character, %28 ], [ @nil_typ, %3 ]
  %.reg2mem25.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %28 ], [ undef, %3 ]
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Character(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_byte_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_bytePtri8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define i8 @Character_byte_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !629
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !629
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !629
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !629
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i8 %8(ptr %.fca.1.extract) #37
  ret i8 %9
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Character_init_bytePtri8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !632
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !632
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !632
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !632
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  tail call void %10(ptr %.fca.1.extract, i8 %3) #36
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i8 @Character_getter_byte(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0) #5 {
  %2 = load i8, ptr %0, align 1
  ret i8 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_byte(ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %0, i8 %1) #6 {
  store i8 %1, ptr %0, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_length(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_length(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #6 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Exception(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !635
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !635
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !635
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !635
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i22 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i23 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i24 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i25 = load i64, ptr %hash_coef_ptr.i.i22, align 4, !noalias !22
  %tbl_size.i.i26 = load i64, ptr %tbl_size_ptr.i.i23, align 4, !noalias !22
  %offset_tbl.i.i27 = load ptr, ptr %offset_tbl_ptr.i.i24, align 8, !noalias !22
  %product.i.i.i28 = mul i64 %hash_coef.i.i25, 6499063144389013426
  %shifted.i.i.i29 = lshr i64 %product.i.i.i28, 32
  %xored.i.i.i30 = xor i64 %shifted.i.i.i29, %product.i.i.i28
  %hash.i.i.i31 = and i64 %xored.i.i.i30, %tbl_size.i.i26
  %offset_ptr.i.i32 = getelementptr i32, ptr %offset_tbl.i.i27, i64 %hash.i.i.i31
  %offset.i.i47 = load i32, ptr %offset_ptr.i.i32, align 4, !noalias !638
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i47, 3
  tail call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %17 = load ptr, ptr %7, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  tail call void %19(ptr %.fca.1.extract14, i32 0) #36
  %result.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i50 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i50, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  store ptr %result.i, ptr %result.i50, align 8
  %23 = getelementptr i8, ptr %result.i50, i64 8
  store i32 0, ptr %23, align 4
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %25 = getelementptr i8, ptr %result.i50, i64 12
  store i32 1, ptr %25, align 4
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13)
  %27 = getelementptr i8, ptr %7, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %22) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !641
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !641
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !641
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !641
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  tail call void %9(ptr %.fca.1.extract, i32 0) #36
  %result.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i, align 8
  %result.i29 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i29, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  store ptr %result.i, ptr %result.i29, align 8
  %13 = getelementptr i8, ptr %result.i29, i64 8
  store i32 6, ptr %13, align 4
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %15 = getelementptr i8, ptr %result.i29, i64 12
  store i32 7, ptr %15, align 4
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract)
  %17 = getelementptr i8, ptr %6, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %12) #36
  %result.i45 = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i47 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i47, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i45, ptr %result.i47, align 8
  %24 = getelementptr i8, ptr %result.i47, i64 8
  store i32 0, ptr %24, align 4
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %26 = getelementptr i8, ptr %result.i47, i64 12
  store i32 1, ptr %26, align 4
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract)
  %28 = getelementptr i8, ptr %6, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  tail call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !644
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !644
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !644
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !644
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract1, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract2, i32 %3) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !647
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i35, 3
  tail call void %16(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %20) #36
  ret void
}

; Function Attrs: nounwind
define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
._crit_edge.lr.ph.i:
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract89 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract91 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !650
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !650
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !650
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !650
  %result.i = tail call noalias align 16 dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i, align 16
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #35
  %result.i.i = tail call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i.i, ptr noundef nonnull align 16 dereferenceable(9) %result.i, i64 9, i1 false)
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  %result.i106 = tail call noalias align 32 dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <26 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110, i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105, i8 108, i8 101>, ptr %result.i106, align 32
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #35
  %result.i.i178 = tail call noalias dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i.i178, ptr noundef nonnull align 32 dereferenceable(26) %result.i106, i64 26, i1 false)
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts97 = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i178)
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract89, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call { ptr, ptr, ptr, i32 } %12(ptr %.fca.1.extract91) #37
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %13, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 3
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract52, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %.fca.3.extract, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract52)
  %20 = sext i32 %.fca.3.extract to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract52, i64 %20
  %22 = getelementptr i8, ptr %21, i64 80
  %23 = load ptr, ptr %22, align 8
  %result.i111 = call ptr %23({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %3) #16
  %24 = call { ptr } %result.i111({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %3) #7
  %.fca.0.extract50 = extractvalue { ptr } %24, 0
  %puts98 = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract50)
  %result.i112 = call noalias align 8 dereferenceable_or_null(8) ptr @bump_malloc_inner(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <7 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101>, ptr %result.i112, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #35
  %result.i.i210 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_inner(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(7) %result.i.i210, ptr noundef nonnull align 8 dereferenceable(7) %result.i112, i64 7, i1 false)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts99 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i210)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %29 = load ptr, ptr %9, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call i32 %30(ptr %.fca.1.extract91) #37
  %32 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %31) #7
  %result.i117 = call noalias align 16 dereferenceable_or_null(13) ptr @bump_malloc_inner(i64 noundef 13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <12 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115, i8 115, i8 97, i8 103, i8 101>, ptr %result.i117, align 16
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #35
  %result.i.i242 = call noalias dereferenceable_or_null(13) ptr @bump_malloc_inner(i64 noundef 13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(12) %result.i.i242, ptr noundef nonnull align 16 dereferenceable(12) %result.i117, i64 12, i1 false)
  %.fca.2.extract93 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts100 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i242)
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract89, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract91, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract93, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %offset.i.i, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %42 = getelementptr i8, ptr %9, i64 56
  %43 = load ptr, ptr %42, align 8
  %result.i122 = call ptr %43({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly %3) #16
  call void %result.i122({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %3) #7
  %result.i123 = call noalias align 16 dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i123, align 16
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #35
  %result.i.i274 = call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i.i274, ptr noundef nonnull align 16 dereferenceable(9) %result.i123, i64 9, i1 false)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts101 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i274)
  ret void
}

; Function Attrs: nounwind
define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !653
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !653
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !653
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !653
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract2, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract4) #37
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract1) #41
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 80
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #17

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: nounwind
define void @report_exception({ ptr } %0) local_unnamed_addr #7 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %3 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %4 = load { ptr, i160 }, ptr %3, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %5 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %6 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %7 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %8 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %9 = load i64, ptr %5, align 4
  %10 = load i64, ptr %6, align 4
  %11 = load ptr, ptr %7, align 8
  %12 = load ptr, ptr %8, align 8
  %result.i = tail call i1 %11(i64 %10, i64 %9, i64 9027164862567808692, i64 ptrtoint (ptr @Exception to i64), ptr readonly %12) #5
  br i1 %result.i, label %13, label %._crit_edge

13:                                               ; preds = %1
  %.fca.1.extract = extractvalue { ptr, i160 } %4, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %14 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %15 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !656
  %product.i.i.i = mul i64 %9, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %10
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !656
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %14, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %15, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i.i, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #35
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract) #35
  %22 = sext i32 %offset.i.i to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract, i64 %22
  %24 = getelementptr i8, ptr %23, i64 48
  %25 = load ptr, ptr %24, align 8
  %result.i4 = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly %2) #16
  call void %result.i4({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %2) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %1, %13
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Pair(ptr nocapture nofree readonly align 8 %0) #10 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 0
  %21 = extractvalue { i64, i64 } %result.i1, 1
  %22 = tail call i64 @llvm.umax.i64(i64 %8, i64 %21)
  %23 = tail call i64 @llvm.umax.i64(i64 %22, i64 8)
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %29, %33
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #2 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !659
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !659
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !659
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !659
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract11) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract11, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract12, { ptr, i160 } %3) #36
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract11) #35
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract12, { ptr, i160 } %4) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !662
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !662
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !662
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !662
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #37
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !665
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !665
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !665
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !665
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #37
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_second(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 0
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 16
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i1 = tail call { i64, i64 } %18(ptr nocapture nofree nonnull readonly %15) #5
  %19 = extractvalue { i64, i64 } %result.i1, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = tail call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly %15) #5
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_second(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  tail call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %16, ptr nocapture nofree writeonly %26) #1
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_first(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 16, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 16
  %10 = select i1 %8, i64 16, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = tail call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly %2) #5
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_first(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  tail call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %3, ptr nocapture nofree writeonly %12) #1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Container(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable_field_MapIterable_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterable_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !668
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !668
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !668
  %product.i.i.i = mul i64 %hash_coef.i.i, -7488770571603291722
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !668
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !22
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !22
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !22
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 3037712219555723519
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !671
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #36
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @MapIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !674
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !674
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !674
  %product.i.i.i = mul i64 %hash_coef.i.i, -7488770571603291722
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !674
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #37
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract27) #41
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr %.fca.1.extract37) #37
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i61 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i62 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %result.i64 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i61, ptr %result.i64, align 8
  %33 = getelementptr inbounds i8, ptr %result.i64, i64 8
  store ptr %result.i62, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i64)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr %.fca.1.extract37) #37
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract3, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract4, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract5, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract2)
  %45 = sext i32 %.fca.3.extract5 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract2, i64 %45
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %result.i65 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly %4) #16
  %49 = call { ptr, ptr, ptr, i32 } %result.i65({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %hash_coef_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i69 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i70 = load i64, ptr %hash_coef_ptr.i.i67, align 4, !noalias !22
  %tbl_size.i.i71 = load i64, ptr %tbl_size_ptr.i.i68, align 4, !noalias !22
  %offset_tbl.i.i72 = load ptr, ptr %offset_tbl_ptr.i.i69, align 8, !noalias !22
  %product.i.i.i73 = mul i64 %hash_coef.i.i70, 8673632051301757104
  %shifted.i.i.i74 = lshr i64 %product.i.i.i73, 32
  %xored.i.i.i75 = xor i64 %shifted.i.i.i74, %product.i.i.i73
  %hash.i.i.i76 = and i64 %xored.i.i.i75, %tbl_size.i.i71
  %offset_ptr.i.i77 = getelementptr i32, ptr %offset_tbl.i.i72, i64 %hash.i.i.i76
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr %.fca.1.extract37) #37
  %offset.i.i92 = load i32, ptr %offset_ptr.i.i77, align 4, !noalias !22
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i64, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %59 = getelementptr inbounds i8, ptr %result.i64, i64 16
  store ptr %.fca.0.extract1, ptr %59, align 8
  %60 = getelementptr inbounds i8, ptr %result.i64, i64 24
  store ptr %.fca.1.extract, ptr %60, align 8
  %61 = getelementptr inbounds i8, ptr %result.i64, i64 32
  store ptr %.fca.2.extract, ptr %61, align 8
  %62 = getelementptr inbounds i8, ptr %result.i64, i64 40
  store i32 %offset.i.i92, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @MapIterator) #35
  %64 = getelementptr inbounds i8, ptr %result.i64, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %64, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %65
}

define void @Iterable_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !677
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !677
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !677
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !677
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #39
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #39
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !22
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !22
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !22
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 8673632051301757104
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !680
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i55, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i55 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %result.i5764 = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #16
  %27 = call { ptr, i160 } %result.i5764({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract2265 = extractvalue { ptr, i160 } %27, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %29 = icmp ne ptr %.fca.0.extract2265, @nil_typ
  %30 = icmp ne ptr %.fca.0.extract2265, null
  %.not2866 = and i1 %29, %30
  br i1 %.not2866, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %4, %._crit_edge
  %31 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %27, %4 ]
  call void %.fca.0.extract3({ ptr, i160 } %31)
  %32 = load ptr, ptr %25, align 8
  %result.i57 = call ptr %32({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #16
  %33 = call { ptr, i160 } %result.i57({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract22 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %35 = icmp ne ptr %.fca.0.extract22, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract22, null
  %.not28 = and i1 %35, %36
  br i1 %.not28, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %._crit_edge, %4
  ret void
}

define { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !683
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !683
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !683
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !683
  %.fca.0.extract3 = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract14, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract15, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #39
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13) #39
  %13 = sext i32 %offset.i.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract13, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i = call ptr %16({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %6) #16
  %17 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %hash_coef_ptr.i.i50 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i51 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i52 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i53 = load i64, ptr %hash_coef_ptr.i.i50, align 4, !noalias !22
  %tbl_size.i.i54 = load i64, ptr %tbl_size_ptr.i.i51, align 4, !noalias !22
  %offset_tbl.i.i55 = load ptr, ptr %offset_tbl_ptr.i.i52, align 8, !noalias !22
  %product.i.i.i56 = mul i64 %hash_coef.i.i53, 8673632051301757104
  %shifted.i.i.i57 = lshr i64 %product.i.i.i56, 32
  %xored.i.i.i58 = xor i64 %shifted.i.i.i57, %product.i.i.i56
  %hash.i.i.i59 = and i64 %xored.i.i.i58, %tbl_size.i.i54
  %offset_ptr.i.i60 = getelementptr i32, ptr %offset_tbl.i.i55, i64 %hash.i.i.i59
  %offset.i.i75 = load i32, ptr %offset_ptr.i.i60, align 4, !noalias !686
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i75, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %24 = sext i32 %offset.i.i75 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i7789 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #16
  %28 = call { ptr, i160 } %result.i7789({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6) #7
  %.fca.0.extract4090 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13)
  %30 = icmp ne ptr %.fca.0.extract4090, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract4090, null
  %.not4891 = and i1 %30, %31
  br i1 %.not4891, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge:                                      ; preds = %5, %._crit_edge
  %32 = phi { ptr, i160 } [ %35, %._crit_edge ], [ %28, %5 ]
  %.pn92 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %3, %5 ]
  %33 = call { ptr, i160 } %.fca.0.extract3({ ptr, i160 } %.pn92, { ptr, i160 } %32)
  %34 = load ptr, ptr %26, align 8
  %result.i77 = call ptr %34({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #16
  %35 = call { ptr, i160 } %result.i77({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6) #7
  %.fca.0.extract40 = extractvalue { ptr, i160 } %35, 0
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13)
  %37 = icmp ne ptr %.fca.0.extract40, @nil_typ
  %38 = icmp ne ptr %.fca.0.extract40, null
  %.not48 = and i1 %37, %38
  br i1 %.not48, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %5
  %.pn.lcssa = phi { ptr, i160 } [ %3, %5 ], [ %33, %._crit_edge ]
  ret { ptr, i160 } %.pn.lcssa
}

define noundef i1 @Iterable_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !689
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !689
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !689
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !689
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #39
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #39
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i34 = load i64, ptr %hash_coef_ptr.i.i31, align 4, !noalias !22
  %tbl_size.i.i35 = load i64, ptr %tbl_size_ptr.i.i32, align 4, !noalias !22
  %offset_tbl.i.i36 = load ptr, ptr %offset_tbl_ptr.i.i33, align 8, !noalias !22
  %product.i.i.i37 = mul i64 %hash_coef.i.i34, 8673632051301757104
  %shifted.i.i.i38 = lshr i64 %product.i.i.i37, 32
  %xored.i.i.i39 = xor i64 %shifted.i.i.i38, %product.i.i.i37
  %hash.i.i.i40 = and i64 %xored.i.i.i39, %tbl_size.i.i35
  %offset_ptr.i.i41 = getelementptr i32, ptr %offset_tbl.i.i36, i64 %hash.i.i.i40
  %offset.i.i56 = load i32, ptr %offset_ptr.i.i41, align 4, !noalias !692
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i56, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i56 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i58 = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #16
  %28 = call { ptr, i160 } %result.i58({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract25 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %30 = icmp eq ptr %.fca.0.extract25, @nil_typ
  %31 = icmp eq ptr %.fca.0.extract25, null
  %.not28.not = or i1 %30, %31
  br i1 %.not28.not, label %.critedge, label %32

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract3({ ptr, i160 } %28)
  br i1 %33, label %26, label %.critedge

.critedge:                                        ; preds = %26, %32
  ret i1 %.not28.not
}

define noundef i1 @Iterable_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !695
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !695
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !695
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !695
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #39
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #39
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i31 = load i64, ptr %hash_coef_ptr.i.i28, align 4, !noalias !22
  %tbl_size.i.i32 = load i64, ptr %tbl_size_ptr.i.i29, align 4, !noalias !22
  %offset_tbl.i.i33 = load ptr, ptr %offset_tbl_ptr.i.i30, align 8, !noalias !22
  %product.i.i.i34 = mul i64 %hash_coef.i.i31, 8673632051301757104
  %shifted.i.i.i35 = lshr i64 %product.i.i.i34, 32
  %xored.i.i.i36 = xor i64 %shifted.i.i.i35, %product.i.i.i34
  %hash.i.i.i37 = and i64 %xored.i.i.i36, %tbl_size.i.i32
  %offset_ptr.i.i38 = getelementptr i32, ptr %offset_tbl.i.i33, i64 %hash.i.i.i37
  %offset.i.i53 = load i32, ptr %offset_ptr.i.i38, align 4, !noalias !698
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i53, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i53 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i55 = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #16
  %28 = call { ptr, i160 } %result.i55({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract23 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %30 = icmp ne ptr %.fca.0.extract23, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract23, null
  %.not26 = and i1 %30, %31
  br i1 %.not26, label %32, label %.critedge

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract3({ ptr, i160 } %28)
  br i1 %33, label %.critedge, label %26

.critedge:                                        ; preds = %26, %32
  ret i1 %.not26
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readonly %2, { ptr } %3) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !701
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !701
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !701
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !701
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i10 = tail call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i10, align 8
  %12 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %11, ptr %12, align 8
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i10) #35
  %hash_coef.i.i15 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i16 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i17 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i18 = mul i64 %hash_coef.i.i15, 3037712219555723519
  %shifted.i.i.i19 = lshr i64 %product.i.i.i18, 32
  %xored.i.i.i20 = xor i64 %shifted.i.i.i19, %product.i.i.i18
  %hash.i.i.i21 = and i64 %xored.i.i.i20, %tbl_size.i.i16
  %offset_ptr.i.i22 = getelementptr i32, ptr %offset_tbl.i.i17, i64 %hash.i.i.i21
  %offset.i.i23 = load i32, ptr %offset_ptr.i.i22, align 4, !noalias !22
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 10, 3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %19 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.0.extract8, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store i32 %offset.i.i23, ptr %22, align 8
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef nonnull @MapIterable) #35
  %24 = getelementptr inbounds i8, ptr %result.i10, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %24, align 8
  ret { ptr, ptr, ptr, i32 } %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !704
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !704
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !704
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !704
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i10 = tail call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i10, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i10) #35
  %hash_coef.i.i15 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i16 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i17 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i18 = mul i64 %hash_coef.i.i15, 3037712219555723519
  %shifted.i.i.i19 = lshr i64 %product.i.i.i18, 32
  %xored.i.i.i20 = xor i64 %shifted.i.i.i19, %product.i.i.i18
  %hash.i.i.i21 = and i64 %xored.i.i.i20, %tbl_size.i.i16
  %offset_ptr.i.i22 = getelementptr i32, ptr %offset_tbl.i.i17, i64 %hash.i.i.i21
  %offset.i.i23 = load i32, ptr %offset_ptr.i.i22, align 4, !noalias !22
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #35
  %15 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %.fca.0.extract8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.1.extract, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.2.extract, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store i32 %offset.i.i23, ptr %18, align 8
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @FilterIterable) #35
  %20 = getelementptr inbounds i8, ptr %result.i10, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %20, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !707
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !707
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !707
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !707
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i16 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i17 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #5
  %result.i30 = tail call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i30, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i30) #35
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 3037712219555723519
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !22
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i30, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #35
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #35
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @ChainIterable) #35
  %16 = getelementptr inbounds i8, ptr %result.i30, i64 8
  store ptr %.fca.0.extract7, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i30, i64 16
  store ptr %.fca.1.extract8, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i30, i64 24
  store ptr %.fca.2.extract9, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i30, i64 32
  store i32 %offset.i.i43, ptr %19, align 8
  %hash_coef.i.i114 = load i64, ptr %hash_coef_ptr.i.i16, align 4, !noalias !22
  %tbl_size.i.i115 = load i64, ptr %tbl_size_ptr.i.i17, align 4, !noalias !22
  %offset_tbl.i.i116 = load ptr, ptr %offset_tbl_ptr.i.i18, align 8, !noalias !22
  %product.i.i.i117 = mul i64 %hash_coef.i.i114, 3037712219555723519
  %shifted.i.i.i118 = lshr i64 %product.i.i.i117, 32
  %xored.i.i.i119 = xor i64 %shifted.i.i.i118, %product.i.i.i117
  %hash.i.i.i120 = and i64 %xored.i.i.i119, %tbl_size.i.i115
  %offset_ptr.i.i121 = getelementptr i32, ptr %offset_tbl.i.i116, i64 %hash.i.i.i120
  %offset.i.i109 = load i32, ptr %offset_ptr.i.i121, align 4, !noalias !710
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @ChainIterable) #35
  %21 = getelementptr inbounds i8, ptr %result.i30, i64 40
  store ptr %.fca.0.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i30, i64 48
  store ptr %.fca.1.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i30, i64 56
  store ptr %.fca.2.extract, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %result.i30, i64 64
  store i32 %offset.i.i109, ptr %24, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !713
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !713
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !713
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !713
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i16 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i17 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #5
  %result.i30 = tail call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i30, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i30) #35
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 3037712219555723519
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !22
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i30, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #35
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #35
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @InterleaveIterable) #35
  %16 = getelementptr inbounds i8, ptr %result.i30, i64 8
  store ptr %.fca.0.extract7, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i30, i64 16
  store ptr %.fca.1.extract8, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i30, i64 24
  store ptr %.fca.2.extract9, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i30, i64 32
  store i32 %offset.i.i43, ptr %19, align 8
  %hash_coef.i.i114 = load i64, ptr %hash_coef_ptr.i.i16, align 4, !noalias !22
  %tbl_size.i.i115 = load i64, ptr %tbl_size_ptr.i.i17, align 4, !noalias !22
  %offset_tbl.i.i116 = load ptr, ptr %offset_tbl_ptr.i.i18, align 8, !noalias !22
  %product.i.i.i117 = mul i64 %hash_coef.i.i114, 3037712219555723519
  %shifted.i.i.i118 = lshr i64 %product.i.i.i117, 32
  %xored.i.i.i119 = xor i64 %shifted.i.i.i118, %product.i.i.i117
  %hash.i.i.i120 = and i64 %xored.i.i.i119, %tbl_size.i.i115
  %offset_ptr.i.i121 = getelementptr i32, ptr %offset_tbl.i.i116, i64 %hash.i.i.i120
  %offset.i.i109 = load i32, ptr %offset_ptr.i.i121, align 4, !noalias !716
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @InterleaveIterable) #35
  %21 = getelementptr inbounds i8, ptr %result.i30, i64 40
  store ptr %.fca.0.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i30, i64 48
  store ptr %.fca.1.extract, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i30, i64 56
  store ptr %.fca.2.extract, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %result.i30, i64 64
  store i32 %offset.i.i109, ptr %24, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !719
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !719
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !719
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !719
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i40 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #5
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #35
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i52 = tail call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #5
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #35
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #35
  %result.i53 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %15 = getelementptr inbounds i8, ptr %result.i53, i64 16
  store ptr %result.i52, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i53, i64 8
  store ptr %result.i, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i53) #35
  store ptr @Pair, ptr %result.i53, align 8
  %result.i55 = tail call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i55, align 8
  %18 = getelementptr inbounds i8, ptr %result.i55, i64 8
  store ptr %result.i52, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i55, i64 16
  store ptr %result.i53, ptr %19, align 8
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i55) #35
  %hash_coef.i.i60 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i61 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i62 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i63 = mul i64 %hash_coef.i.i60, 3037712219555723519
  %shifted.i.i.i64 = lshr i64 %product.i.i.i63, 32
  %xored.i.i.i65 = xor i64 %shifted.i.i.i64, %product.i.i.i63
  %hash.i.i.i66 = and i64 %xored.i.i.i65, %tbl_size.i.i61
  %offset_ptr.i.i67 = getelementptr i32, ptr %offset_tbl.i.i62, i64 %hash.i.i.i66
  %offset.i.i68 = load i32, ptr %offset_ptr.i.i67, align 4, !noalias !22
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i55, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #35
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #35
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ZipIterable) #35
  %27 = getelementptr inbounds i8, ptr %result.i55, i64 24
  store ptr %.fca.0.extract30, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i55, i64 32
  store ptr %.fca.1.extract31, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i55, i64 40
  store ptr %.fca.2.extract32, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i55, i64 48
  store i32 %offset.i.i68, ptr %30, align 8
  %hash_coef.i.i139 = load i64, ptr %hash_coef_ptr.i.i39, align 4, !noalias !22
  %tbl_size.i.i140 = load i64, ptr %tbl_size_ptr.i.i40, align 4, !noalias !22
  %offset_tbl.i.i141 = load ptr, ptr %offset_tbl_ptr.i.i41, align 8, !noalias !22
  %product.i.i.i142 = mul i64 %hash_coef.i.i139, 3037712219555723519
  %shifted.i.i.i143 = lshr i64 %product.i.i.i142, 32
  %xored.i.i.i144 = xor i64 %shifted.i.i.i143, %product.i.i.i142
  %hash.i.i.i145 = and i64 %xored.i.i.i144, %tbl_size.i.i140
  %offset_ptr.i.i146 = getelementptr i32, ptr %offset_tbl.i.i141, i64 %hash.i.i.i145
  %offset.i.i134 = load i32, ptr %offset_ptr.i.i146, align 4, !noalias !722
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ZipIterable) #35
  %32 = getelementptr inbounds i8, ptr %result.i55, i64 56
  store ptr %.fca.0.extract23, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i55, i64 64
  store ptr %.fca.1.extract24, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i55, i64 72
  store ptr %.fca.2.extract25, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i55, i64 80
  store i32 %offset.i.i134, ptr %35, align 8
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !725
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !725
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !725
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !725
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i40 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #5
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #35
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i52 = tail call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #5
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #35
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #35
  %result.i53 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %15 = getelementptr inbounds i8, ptr %result.i53, i64 16
  store ptr %result.i52, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i53, i64 8
  store ptr %result.i, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i53) #35
  store ptr @Pair, ptr %result.i53, align 8
  %result.i55 = tail call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i55, align 8
  %18 = getelementptr inbounds i8, ptr %result.i55, i64 8
  store ptr %result.i52, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i55, i64 16
  store ptr %result.i53, ptr %19, align 8
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i55) #35
  %hash_coef.i.i60 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i61 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i62 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i63 = mul i64 %hash_coef.i.i60, 3037712219555723519
  %shifted.i.i.i64 = lshr i64 %product.i.i.i63, 32
  %xored.i.i.i65 = xor i64 %shifted.i.i.i64, %product.i.i.i63
  %hash.i.i.i66 = and i64 %xored.i.i.i65, %tbl_size.i.i61
  %offset_ptr.i.i67 = getelementptr i32, ptr %offset_tbl.i.i62, i64 %hash.i.i.i66
  %offset.i.i68 = load i32, ptr %offset_ptr.i.i67, align 4, !noalias !22
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterable, ptr undef, ptr undef, i32 undef }, ptr %result.i55, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #35
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #35
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ProductIterable) #35
  %27 = getelementptr inbounds i8, ptr %result.i55, i64 24
  store ptr %.fca.0.extract30, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i55, i64 32
  store ptr %.fca.1.extract31, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i55, i64 40
  store ptr %.fca.2.extract32, ptr %29, align 8
  %30 = getelementptr inbounds i8, ptr %result.i55, i64 48
  store i32 %offset.i.i68, ptr %30, align 8
  %hash_coef.i.i139 = load i64, ptr %hash_coef_ptr.i.i39, align 4, !noalias !22
  %tbl_size.i.i140 = load i64, ptr %tbl_size_ptr.i.i40, align 4, !noalias !22
  %offset_tbl.i.i141 = load ptr, ptr %offset_tbl_ptr.i.i41, align 8, !noalias !22
  %product.i.i.i142 = mul i64 %hash_coef.i.i139, 3037712219555723519
  %shifted.i.i.i143 = lshr i64 %product.i.i.i142, 32
  %xored.i.i.i144 = xor i64 %shifted.i.i.i143, %product.i.i.i142
  %hash.i.i.i145 = and i64 %xored.i.i.i144, %tbl_size.i.i140
  %offset_ptr.i.i146 = getelementptr i32, ptr %offset_tbl.i.i141, i64 %hash.i.i.i145
  %offset.i.i134 = load i32, ptr %offset_ptr.i.i146, align 4, !noalias !728
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ProductIterable) #35
  %32 = getelementptr inbounds i8, ptr %result.i55, i64 56
  store ptr %.fca.0.extract23, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i55, i64 64
  store ptr %.fca.1.extract24, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i55, i64 72
  store ptr %.fca.2.extract25, ptr %34, align 8
  %35 = getelementptr inbounds i8, ptr %result.i55, i64 80
  store i32 %offset.i.i134, ptr %35, align 8
  ret { ptr, ptr, ptr, i32 } %23
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable_field_ProductIterable_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ProductIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !731
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !731
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !731
  %product.i.i.i = mul i64 %hash_coef.i.i, 4128338911757318636
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !731
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 3037712219555723519
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !734
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 3037712219555723519
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !737
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ProductIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !740
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !740
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !740
  %product.i.i.i = mul i64 %hash_coef.i.i, 4128338911757318636
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !740
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract51, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract53) #37
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43) #41
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract53) #37
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %29 = load ptr, ptr %7, align 8
  %result.i77 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #5
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i78 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #5
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %result.i79 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %35 = getelementptr inbounds i8, ptr %result.i79, i64 16
  store ptr %result.i78, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %result.i79, i64 8
  store ptr %result.i77, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i79)
  store ptr @Pair, ptr %result.i79, align 8
  %result.i81 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_inner(i64 noundef 152, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i77, ptr %result.i81, align 8
  %38 = getelementptr inbounds i8, ptr %result.i81, i64 8
  store ptr %result.i78, ptr %38, align 8
  %39 = getelementptr inbounds i8, ptr %result.i81, i64 16
  store ptr %result.i79, ptr %39, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i81)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %42 = load ptr, ptr %8, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr, ptr, ptr, i32 } %43(ptr %.fca.1.extract53) #37
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %44, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %44, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %44, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %44, 3
  %45 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %.fca.1.extract11, 1
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.2.extract13, 2
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, i32 %.fca.3.extract15, 3
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract9)
  %51 = sext i32 %.fca.3.extract15 to i64
  %52 = getelementptr ptr, ptr %.fca.0.extract9, i64 %51
  %53 = getelementptr i8, ptr %52, i64 8
  %54 = load ptr, ptr %53, align 8
  %result.i82 = call ptr %54({ ptr, ptr, ptr, i32 } %48, ptr nocapture nofree noundef nonnull readonly %4) #16
  %55 = call { ptr, ptr, ptr, i32 } %result.i82({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %55, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %55, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %55, 2
  %hash_coef_ptr.i.i84 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i85 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i86 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i87 = load i64, ptr %hash_coef_ptr.i.i84, align 4, !noalias !22
  %tbl_size.i.i88 = load i64, ptr %tbl_size_ptr.i.i85, align 4, !noalias !22
  %offset_tbl.i.i89 = load ptr, ptr %offset_tbl_ptr.i.i86, align 8, !noalias !22
  %product.i.i.i90 = mul i64 %hash_coef.i.i87, 8673632051301757104
  %shifted.i.i.i91 = lshr i64 %product.i.i.i90, 32
  %xored.i.i.i92 = xor i64 %shifted.i.i.i91, %product.i.i.i90
  %hash.i.i.i93 = and i64 %xored.i.i.i92, %tbl_size.i.i88
  %offset_ptr.i.i94 = getelementptr i32, ptr %offset_tbl.i.i89, i64 %hash.i.i.i93
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %57 = load ptr, ptr %24, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, ptr, ptr, i32 } %58(ptr %.fca.1.extract53) #37
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %59, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %59, 2
  %offset.i.i109 = load i32, ptr %offset_ptr.i.i94, align 4, !noalias !22
  %hash_coef_ptr.i.i112 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i113 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i114 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.1.extract, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.2.extract, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i81, 1
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, ptr undef, 2
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %4)
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator) #35
  %68 = getelementptr inbounds i8, ptr %result.i81, i64 24
  store ptr %.fca.0.extract1, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %result.i81, i64 32
  store ptr %.fca.1.extract3, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i81, i64 40
  store ptr %.fca.2.extract5, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i81, i64 48
  store i32 %offset.i.i109, ptr %71, align 8
  %hash_coef.i.i89.i = load i64, ptr %hash_coef_ptr.i.i112, align 4, !noalias !22
  %tbl_size.i.i90.i = load i64, ptr %tbl_size_ptr.i.i113, align 4, !noalias !22
  %offset_tbl.i.i91.i = load ptr, ptr %offset_tbl_ptr.i.i114, align 8, !noalias !22
  %product.i.i.i92.i = mul i64 %hash_coef.i.i89.i, 3037712219555723519
  %shifted.i.i.i93.i = lshr i64 %product.i.i.i92.i, 32
  %xored.i.i.i94.i = xor i64 %shifted.i.i.i93.i, %product.i.i.i92.i
  %hash.i.i.i95.i = and i64 %xored.i.i.i94.i, %tbl_size.i.i90.i
  %offset_ptr.i.i96.i = getelementptr i32, ptr %offset_tbl.i.i91.i, i64 %hash.i.i.i95.i
  %offset.i.i111.i = load i32, ptr %offset_ptr.i.i96.i, align 4, !noalias !743
  %72 = getelementptr inbounds i8, ptr %result.i81, i64 88
  store ptr %.fca.0.extract, ptr %72, align 8
  %73 = getelementptr inbounds i8, ptr %result.i81, i64 96
  store ptr %.fca.1.extract, ptr %73, align 8
  %74 = getelementptr inbounds i8, ptr %result.i81, i64 104
  store ptr %.fca.2.extract, ptr %74, align 8
  %75 = getelementptr inbounds i8, ptr %result.i81, i64 112
  store i32 %offset.i.i111.i, ptr %75, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator) #35
  %77 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %offset.i.i111.i, 3
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #35
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract) #35
  %80 = sext i32 %offset.i.i111.i to i64
  %81 = getelementptr ptr, ptr %.fca.0.extract, i64 %80
  %82 = getelementptr i8, ptr %81, i64 8
  %83 = load ptr, ptr %82, align 8
  %result.i.i = call ptr %83({ ptr, ptr, ptr, i32 } %77, ptr nocapture nofree noundef nonnull readonly %4) #16
  %84 = call { ptr, ptr, ptr, i32 } %result.i.i({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull align 8 %4) #7
  %.fca.0.extract3.i = extractvalue { ptr, ptr, ptr, i32 } %84, 0
  %.fca.1.extract5.i = extractvalue { ptr, ptr, ptr, i32 } %84, 1
  %.fca.2.extract7.i = extractvalue { ptr, ptr, ptr, i32 } %84, 2
  %hash_coef_ptr.i.i114.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 8
  %tbl_size_ptr.i.i115.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 16
  %offset_tbl_ptr.i.i116.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 40
  %hash_coef.i.i117.i = load i64, ptr %hash_coef_ptr.i.i114.i, align 4, !noalias !22
  %tbl_size.i.i118.i = load i64, ptr %tbl_size_ptr.i.i115.i, align 4, !noalias !22
  %offset_tbl.i.i119.i = load ptr, ptr %offset_tbl_ptr.i.i116.i, align 8, !noalias !22
  %product.i.i.i120.i = mul i64 %hash_coef.i.i117.i, 8673632051301757104
  %shifted.i.i.i121.i = lshr i64 %product.i.i.i120.i, 32
  %xored.i.i.i122.i = xor i64 %shifted.i.i.i121.i, %product.i.i.i120.i
  %hash.i.i.i123.i = and i64 %xored.i.i.i122.i, %tbl_size.i.i118.i
  %offset_ptr.i.i124.i = getelementptr i32, ptr %offset_tbl.i.i119.i, i64 %hash.i.i.i123.i
  %offset.i.i139.i = load i32, ptr %offset_ptr.i.i124.i, align 4, !noalias !746
  %85 = getelementptr inbounds i8, ptr %result.i81, i64 56
  store ptr %.fca.0.extract3.i, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %result.i81, i64 64
  store ptr %.fca.1.extract5.i, ptr %86, align 8
  %87 = getelementptr inbounds i8, ptr %result.i81, i64 72
  store ptr %.fca.2.extract7.i, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i81, i64 80
  store i32 %offset.i.i139.i, ptr %88, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator)
  %90 = load ptr, ptr %68, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %90, 0
  %92 = load ptr, ptr %69, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, ptr %92, 1
  %94 = load ptr, ptr %70, align 8
  %95 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %94, 2
  %96 = load i32, ptr %71, align 8
  %97 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %96, 3
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %99 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %90)
  %100 = sext i32 %96 to i64
  %101 = getelementptr ptr, ptr %90, i64 %100
  %102 = getelementptr i8, ptr %101, i64 8
  %103 = load ptr, ptr %102, align 8
  %result.i141.i = call ptr %103({ ptr, ptr, ptr, i32 } %97, ptr nocapture nofree noundef nonnull readonly %4) #16
  %104 = call { ptr, i160 } %result.i141.i({ ptr, ptr, ptr, i32 } %97, { ptr, ptr, ptr, i32 } %97, ptr nonnull align 8 %4) #7
  %105 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator)
  %106 = getelementptr inbounds i8, ptr %result.i81, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %104, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %104, 1
  store ptr %.fca.0.extract.i, ptr %106, align 8
  %107 = getelementptr inbounds i8, ptr %result.i81, i64 128
  store i160 %.fca.1.extract.i, ptr %107, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %4)
  %108 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %108
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 152, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator_field_ProductIterator_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator_B_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define void @ProductIterator_init_first_iteratorIteratorT_second_iterableIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #7 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !749
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !749
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !749
  %product.i.i.i = mul i64 %hash_coef.i.i, 1697250377212095568
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !749
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i58 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i59 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i60 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i61 = load i64, ptr %hash_coef_ptr.i.i58, align 4, !noalias !22
  %tbl_size.i.i62 = load i64, ptr %tbl_size_ptr.i.i59, align 4, !noalias !22
  %offset_tbl.i.i63 = load ptr, ptr %offset_tbl_ptr.i.i60, align 8, !noalias !22
  %product.i.i.i64 = mul i64 %hash_coef.i.i61, 8673632051301757104
  %shifted.i.i.i65 = lshr i64 %product.i.i.i64, 32
  %xored.i.i.i66 = xor i64 %shifted.i.i.i65, %product.i.i.i64
  %hash.i.i.i67 = and i64 %xored.i.i.i66, %tbl_size.i.i62
  %offset_ptr.i.i68 = getelementptr i32, ptr %offset_tbl.i.i63, i64 %hash.i.i.i67
  %offset.i.i83 = load i32, ptr %offset_ptr.i.i68, align 4, !noalias !752
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract45, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract35, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract37, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i83, 3
  tail call void %13(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %17) #36
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i86 = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i87 = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i88 = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i89 = load i64, ptr %hash_coef_ptr.i.i86, align 4, !noalias !22
  %tbl_size.i.i90 = load i64, ptr %tbl_size_ptr.i.i87, align 4, !noalias !22
  %offset_tbl.i.i91 = load ptr, ptr %offset_tbl_ptr.i.i88, align 8, !noalias !22
  %product.i.i.i92 = mul i64 %hash_coef.i.i89, 3037712219555723519
  %shifted.i.i.i93 = lshr i64 %product.i.i.i92, 32
  %xored.i.i.i94 = xor i64 %shifted.i.i.i93, %product.i.i.i92
  %hash.i.i.i95 = and i64 %xored.i.i.i94, %tbl_size.i.i90
  %offset_ptr.i.i96 = getelementptr i32, ptr %offset_tbl.i.i91, i64 %hash.i.i.i95
  %offset.i.i111 = load i32, ptr %offset_ptr.i.i96, align 4, !noalias !755
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #35
  %19 = getelementptr i8, ptr %9, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract23, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract25, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i111, 3
  tail call void %22(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %26) #36
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #35
  %28 = load ptr, ptr %19, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call { ptr, ptr, ptr, i32 } %29(ptr %.fca.1.extract47) #37
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %30, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %30, 1
  %.fca.2.extract17 = extractvalue { ptr, ptr, ptr, i32 } %30, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %30, 3
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract15, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract17, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %.fca.3.extract19, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #35
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13) #35
  %37 = sext i32 %.fca.3.extract19 to i64
  %38 = getelementptr ptr, ptr %.fca.0.extract13, i64 %37
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %result.i = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly %6) #16
  %41 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %6) #7
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %hash_coef_ptr.i.i114 = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i115 = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i116 = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i117 = load i64, ptr %hash_coef_ptr.i.i114, align 4, !noalias !22
  %tbl_size.i.i118 = load i64, ptr %tbl_size_ptr.i.i115, align 4, !noalias !22
  %offset_tbl.i.i119 = load ptr, ptr %offset_tbl_ptr.i.i116, align 8, !noalias !22
  %product.i.i.i120 = mul i64 %hash_coef.i.i117, 8673632051301757104
  %shifted.i.i.i121 = lshr i64 %product.i.i.i120, 32
  %xored.i.i.i122 = xor i64 %shifted.i.i.i121, %product.i.i.i120
  %hash.i.i.i123 = and i64 %xored.i.i.i122, %tbl_size.i.i118
  %offset_ptr.i.i124 = getelementptr i32, ptr %offset_tbl.i.i119, i64 %hash.i.i.i123
  %offset.i.i139 = load i32, ptr %offset_ptr.i.i124, align 4, !noalias !758
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %43 = getelementptr i8, ptr %9, i64 32
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %44, i64 8
  %46 = load ptr, ptr %45, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract5, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract7, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i.i139, 3
  call void %46(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %50) #36
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %52 = load ptr, ptr %10, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %.fca.1.extract47) #37
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.1.extract2, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.2.extract, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %.fca.3.extract, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %61 = sext i32 %.fca.3.extract to i64
  %62 = getelementptr ptr, ptr %.fca.0.extract1, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %result.i141 = call ptr %64({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly %6) #16
  %65 = call { ptr, i160 } %result.i141({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %6) #7
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %67 = getelementptr i8, ptr %9, i64 48
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  call void %70(ptr %.fca.1.extract47, { ptr, i160 } %65) #36
  ret void
}

define { ptr, i160 } @ProductIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 1697250377212095568
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract10) #39
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = getelementptr i8, ptr %7, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, i160 } %10(ptr %.fca.1.extract12) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %.sroa.0.0189 = extractvalue { ptr, i160 } %11, 0
  %13 = icmp ne ptr %.sroa.0.0189, @nil_typ
  %14 = icmp ne ptr %.sroa.0.0189, null
  %.not82190 = and i1 %13, %14
  br i1 %.not82190, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %3
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %16 = getelementptr i8, ptr %7, i64 32
  %17 = getelementptr i8, ptr %7, i64 24
  %18 = getelementptr i8, ptr %7, i64 40
  br label %19

19:                                               ; preds = %.lr.ph, %38
  %.pn191 = phi { ptr, i160 } [ %11, %.lr.ph ], [ %83, %38 ]
  %20 = load ptr, ptr %16, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call { ptr, ptr, ptr, i32 } %21(ptr %.fca.1.extract12) #37
  %.fca.0.extract68 = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract70 = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract72 = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %.fca.3.extract74 = extractvalue { ptr, ptr, ptr, i32 } %22, 3
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract68, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract70, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract72, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %.fca.3.extract74, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract68)
  %29 = sext i32 %.fca.3.extract74 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract68, i64 %29
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i = call ptr %32({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %4) #16
  %33 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %4) #7
  %.fca.0.extract61 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %35 = icmp ne ptr %.fca.0.extract61, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract61, null
  %.not84 = and i1 %35, %36
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  br i1 %.not84, label %86, label %38

38:                                               ; preds = %19
  %39 = load ptr, ptr %17, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call { ptr, ptr, ptr, i32 } %40(ptr %.fca.1.extract12) #37
  %.fca.0.extract42 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract46 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %.fca.3.extract48 = extractvalue { ptr, ptr, ptr, i32 } %41, 3
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract42, 0
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.1.extract44, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.2.extract46, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %.fca.3.extract48, 3
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract42)
  %48 = sext i32 %.fca.3.extract48 to i64
  %49 = getelementptr ptr, ptr %.fca.0.extract42, i64 %48
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  %result.i85 = call ptr %51({ ptr, ptr, ptr, i32 } %45, ptr nocapture nofree noundef nonnull readonly %4) #16
  %52 = call { ptr, i160 } %result.i85({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull align 8 %4) #7
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %54 = load ptr, ptr %8, align 8
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  call void %56(ptr %.fca.1.extract12, { ptr, i160 } %52) #36
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %58 = load ptr, ptr %18, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract12) #37
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract35 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract30, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract32, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract34, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract35, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30)
  %67 = sext i32 %.fca.3.extract35 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract30, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i86 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #16
  %71 = call { ptr, ptr, ptr, i32 } %result.i86({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract24 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i88 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i.i89 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i.i90 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i.i91 = load i64, ptr %hash_coef_ptr.i.i88, align 4
  %tbl_size.i.i92 = load i64, ptr %tbl_size_ptr.i.i89, align 4
  %offset_tbl.i.i93 = load ptr, ptr %offset_tbl_ptr.i.i90, align 8
  %product.i.i.i94 = mul i64 %hash_coef.i.i91, 8673632051301757104
  %shifted.i.i.i95 = lshr i64 %product.i.i.i94, 32
  %xored.i.i.i96 = xor i64 %shifted.i.i.i95, %product.i.i.i94
  %hash.i.i.i97 = and i64 %xored.i.i.i96, %tbl_size.i.i92
  %offset_ptr.i.i98 = getelementptr i32, ptr %offset_tbl.i.i93, i64 %hash.i.i.i97
  %offset.i.i113 = load i32, ptr %offset_ptr.i.i98, align 4
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %73 = load ptr, ptr %16, align 8
  %74 = getelementptr i8, ptr %73, i64 8
  %75 = load ptr, ptr %74, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.fca.1.extract22, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.fca.2.extract24, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %offset.i.i113, 3
  call void %75(ptr %.fca.1.extract12, { ptr, ptr, ptr, i32 } %79) #36
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %81 = load ptr, ptr %8, align 8
  %82 = load ptr, ptr %81, align 8
  %83 = call { ptr, i160 } %82(ptr %.fca.1.extract12) #37
  %.sroa.0.0 = extractvalue { ptr, i160 } %83, 0
  %84 = icmp ne ptr %.sroa.0.0, @nil_typ
  %85 = icmp ne ptr %.sroa.0.0, null
  %.not82 = and i1 %84, %85
  br i1 %.not82, label %19, label %.loopexit

86:                                               ; preds = %19
  %87 = load ptr, ptr %7, align 8
  %result.i115 = call ptr %87(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %89 = getelementptr i8, ptr %7, i64 8
  %90 = load ptr, ptr %89, align 8
  %result.i116 = call ptr %90(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %91 = load ptr, ptr %result.i115, align 8
  %92 = getelementptr i8, ptr %91, i64 72
  %93 = load ptr, ptr %92, align 8
  %result.i.i = call { i64, i64 } %93(ptr nocapture nofree nonnull readonly %result.i115) #5
  %94 = extractvalue { i64, i64 } %result.i.i, 0
  %95 = extractvalue { i64, i64 } %result.i.i, 1
  %96 = urem i64 16, %95
  %97 = icmp eq i64 %96, 0
  %98 = sub i64 %95, %96
  %99 = select i1 %97, i64 0, i64 %98
  %100 = add i64 %94, 16
  %101 = add i64 %100, %99
  %102 = load ptr, ptr %result.i116, align 8
  %103 = getelementptr i8, ptr %102, i64 72
  %104 = load ptr, ptr %103, align 8
  %result.i1.i = call { i64, i64 } %104(ptr nocapture nofree nonnull readonly %result.i116) #5
  %105 = extractvalue { i64, i64 } %result.i1.i, 0
  %106 = extractvalue { i64, i64 } %result.i1.i, 1
  %107 = call i64 @llvm.umax.i64(i64 %95, i64 %106)
  %108 = call i64 @llvm.umax.i64(i64 %107, i64 8)
  %109 = urem i64 %101, %106
  %110 = icmp eq i64 %109, 0
  %111 = sub i64 %106, %109
  %112 = select i1 %110, i64 0, i64 %111
  %113 = add i64 %105, %101
  %114 = add i64 %113, %112
  %115 = urem i64 %114, %108
  %116 = icmp eq i64 %115, 0
  %117 = sub i64 %108, %115
  %118 = select i1 %116, i64 0, i64 %117
  %119 = add i64 %118, %114
  %result.i118 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %119, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i115, ptr %result.i118, align 8
  %120 = getelementptr inbounds i8, ptr %result.i118, i64 8
  store ptr %result.i116, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i118)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %124 = load ptr, ptr %result.i115, align 8
  %125 = getelementptr i8, ptr %124, i64 72
  %126 = load ptr, ptr %125, align 8
  %result.i.i202 = call { i64, i64 } %126(ptr nocapture nofree nonnull readonly %result.i115) #5
  %127 = extractvalue { i64, i64 } %result.i.i202, 1
  %128 = urem i64 16, %127
  %129 = icmp eq i64 %128, 0
  %reass.sub = sub i64 %127, %128
  %130 = add i64 %reass.sub, 16
  %131 = select i1 %129, i64 16, i64 %130
  %132 = getelementptr i8, ptr %result.i118, i64 %131
  %133 = getelementptr i8, ptr %124, i64 64
  %134 = load ptr, ptr %133, align 8
  call void %134({ ptr, i160 } %.pn191, ptr nocapture nofree nonnull readonly %result.i115, ptr nocapture nofree writeonly %132) #1
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #35
  %136 = load ptr, ptr %result.i118, align 8
  %137 = load ptr, ptr %136, align 8
  %138 = getelementptr i8, ptr %137, i64 72
  %139 = load ptr, ptr %138, align 8
  %result.i.i203 = call { i64, i64 } %139(ptr nocapture nofree nonnull readonly %136) #5
  %140 = extractvalue { i64, i64 } %result.i.i203, 0
  %141 = extractvalue { i64, i64 } %result.i.i203, 1
  %142 = urem i64 16, %141
  %143 = icmp eq i64 %142, 0
  %144 = sub i64 %141, %142
  %145 = select i1 %143, i64 0, i64 %144
  %146 = add i64 %140, 16
  %147 = add i64 %146, %145
  %148 = load ptr, ptr %120, align 8
  %149 = load ptr, ptr %148, align 8
  %150 = getelementptr i8, ptr %149, i64 72
  %151 = load ptr, ptr %150, align 8
  %result.i1.i204 = call { i64, i64 } %151(ptr nocapture nofree nonnull readonly %148) #5
  %152 = extractvalue { i64, i64 } %result.i1.i204, 1
  %153 = urem i64 %147, %152
  %154 = icmp eq i64 %153, 0
  %155 = sub i64 %152, %153
  %156 = select i1 %154, i64 0, i64 %155
  %157 = getelementptr i8, ptr %result.i118, i64 %147
  %158 = getelementptr i8, ptr %157, i64 %156
  %159 = getelementptr i8, ptr %149, i64 64
  %160 = load ptr, ptr %159, align 8
  call void %160({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %148, ptr nocapture nofree writeonly %158) #1
  %161 = ptrtoint ptr %result.i118 to i64
  %.sroa.3.8.insert.ext = zext i64 %161 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.loopexit

.loopexit:                                        ; preds = %38, %3, %86
  %.reg2mem48.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %86 ], [ undef, %3 ], [ undef, %38 ]
  %.reg2mem48.sroa.0.0 = phi ptr [ @Pair, %86 ], [ @nil_typ, %3 ], [ @nil_typ, %38 ]
  %.reload49.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem48.sroa.0.0, 0
  %.reload49.fca.1.insert = insertvalue { ptr, i160 } %.reload49.fca.0.insert, i160 %.reg2mem48.sroa.3.0, 1
  ret { ptr, i160 } %.reload49.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @ProductIterator_getter_current_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 4
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_current_first(ptr nocapture nofree writeonly %0, { ptr, i160 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_second_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_second_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator_getter_first_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator_setter_first_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable_field_ZipIterable_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterable_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !761
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !761
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !761
  %product.i.i.i = mul i64 %hash_coef.i.i, 35232740166152944
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !761
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 3037712219555723519
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !764
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 3037712219555723519
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !767
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ZipIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !770
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !770
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !770
  %product.i.i.i = mul i64 %hash_coef.i.i, 35232740166152944
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !770
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #37
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #41
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #37
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #16
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i113 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %result.i114 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %46 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %result.i113, ptr %46, align 8
  %47 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %result.i112, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i114)
  store ptr @Pair, ptr %result.i114, align 8
  %result.i116 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i112, ptr %result.i116, align 8
  %49 = getelementptr inbounds i8, ptr %result.i116, i64 8
  store ptr %result.i113, ptr %49, align 8
  %50 = getelementptr inbounds i8, ptr %result.i116, i64 16
  store ptr %result.i114, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i116)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %53 = load ptr, ptr %8, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr, ptr, ptr, i32 } %54(ptr %.fca.1.extract73) #37
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %55, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %55, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %55, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %55, 3
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.1.extract19, 1
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %.fca.2.extract21, 2
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %.fca.3.extract23, 3
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %62 = sext i32 %.fca.3.extract23 to i64
  %63 = getelementptr ptr, ptr %.fca.0.extract17, i64 %62
  %64 = getelementptr i8, ptr %63, i64 8
  %65 = load ptr, ptr %64, align 8
  %result.i117 = call ptr %65({ ptr, ptr, ptr, i32 } %59, ptr nocapture nofree noundef nonnull readonly %4) #16
  %66 = call { ptr, ptr, ptr, i32 } %result.i117({ ptr, ptr, ptr, i32 } %59, { ptr, ptr, ptr, i32 } %59, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %66, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %66, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %66, 2
  %hash_coef_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i120 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i121 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %68 = load ptr, ptr %24, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = call { ptr, ptr, ptr, i32 } %69(ptr %.fca.1.extract73) #37
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %70, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %70, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %70, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %70, 3
  %71 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr %.fca.1.extract2, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %.fca.2.extract3, 2
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 %.fca.3.extract4, 3
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %77 = sext i32 %.fca.3.extract4 to i64
  %78 = getelementptr ptr, ptr %.fca.0.extract1, i64 %77
  %79 = getelementptr i8, ptr %78, i64 8
  %80 = load ptr, ptr %79, align 8
  %result.i132 = call ptr %80({ ptr, ptr, ptr, i32 } %74, ptr nocapture nofree noundef nonnull readonly %4) #16
  %81 = call { ptr, ptr, ptr, i32 } %result.i132({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %81, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %81, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %81, 2
  %hash_coef_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i135 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i136 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i151 = load i64, ptr %hash_coef_ptr.i.i119, align 4, !noalias !22
  %tbl_size.i.i152 = load i64, ptr %tbl_size_ptr.i.i120, align 4, !noalias !22
  %offset_tbl.i.i153 = load ptr, ptr %offset_tbl_ptr.i.i121, align 8, !noalias !22
  %product.i.i.i154 = mul i64 %hash_coef.i.i151, 8673632051301757104
  %shifted.i.i.i155 = lshr i64 %product.i.i.i154, 32
  %xored.i.i.i156 = xor i64 %shifted.i.i.i155, %product.i.i.i154
  %hash.i.i.i157 = and i64 %xored.i.i.i156, %tbl_size.i.i152
  %offset_ptr.i.i158 = getelementptr i32, ptr %offset_tbl.i.i153, i64 %hash.i.i.i157
  %offset.i.i159 = load i32, ptr %offset_ptr.i.i158, align 4, !noalias !22
  %82 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i116, 1
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr undef, 2
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull @ZipIterator) #35
  %87 = getelementptr inbounds i8, ptr %result.i116, i64 24
  store ptr %.fca.0.extract5, ptr %87, align 8
  %88 = getelementptr inbounds i8, ptr %result.i116, i64 32
  store ptr %.fca.1.extract7, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i116, i64 40
  store ptr %.fca.2.extract9, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i116, i64 48
  store i32 %offset.i.i159, ptr %90, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i134, align 4, !noalias !22
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i135, align 4, !noalias !22
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i136, align 8, !noalias !22
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 8673632051301757104
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !773
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull @ZipIterator) #35
  %92 = getelementptr inbounds i8, ptr %result.i116, i64 56
  store ptr %.fca.0.extract, ptr %92, align 8
  %93 = getelementptr inbounds i8, ptr %result.i116, i64 64
  store ptr %.fca.1.extract, ptr %93, align 8
  %94 = getelementptr inbounds i8, ptr %result.i116, i64 72
  store ptr %.fca.2.extract, ptr %94, align 8
  %95 = getelementptr inbounds i8, ptr %result.i116, i64 80
  store i32 %offset.i.i71.i, ptr %95, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %96
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator_field_ZipIterator_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator_B_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterator_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !776
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !776
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !776
  %product.i.i.i = mul i64 %hash_coef.i.i, -2141114445739585318
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !776
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 8673632051301757104
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !779
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 8673632051301757104
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !782
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ZipIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !785
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !785
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !785
  %product.i.i.i = mul i64 %hash_coef.i.i, -2141114445739585318
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !785
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract28, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract30) #37
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract12 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract14 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract10, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract12, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract14, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract8) #41
  %18 = sext i32 %.fca.3.extract14 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract8, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract4 = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract30) #37
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract3, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract2, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i60 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #16
  %38 = call { ptr, i160 } %result.i60({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28)
  %40 = load ptr, ptr %7, align 8
  %41 = icmp ne ptr %.fca.0.extract4, @nil_typ
  %42 = icmp ne ptr %.fca.0.extract4, null
  %.not55 = and i1 %41, %42
  br i1 %.not55, label %43, label %.thread

43:                                               ; preds = %3
  %.fca.0.extract = extractvalue { ptr, i160 } %38, 0
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull %.fca.0.extract28)
  %45 = icmp ne ptr %.fca.0.extract, @nil_typ
  %46 = icmp ne ptr %.fca.0.extract, null
  %.not57.not.not = and i1 %45, %46
  br i1 %.not57.not.not, label %47, label %.thread

47:                                               ; preds = %43
  %48 = getelementptr i8, ptr %7, i64 8
  %49 = load ptr, ptr %48, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull %.fca.0.extract28)
  %result.i61 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract30) #5
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull %.fca.0.extract28)
  %result.i62 = call ptr %49(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract30) #5
  %52 = load ptr, ptr %result.i61, align 8, !alias.scope !788
  %53 = getelementptr i8, ptr %52, i64 72
  %54 = load ptr, ptr %53, align 8, !alias.scope !788
  %result.i.i = call { i64, i64 } %54(ptr nocapture nofree nonnull readonly %result.i61) #5, !alias.scope !788
  %55 = extractvalue { i64, i64 } %result.i.i, 0
  %56 = extractvalue { i64, i64 } %result.i.i, 1
  %57 = urem i64 16, %56
  %58 = icmp eq i64 %57, 0
  %59 = sub i64 %56, %57
  %60 = select i1 %58, i64 0, i64 %59
  %61 = add i64 %55, 16
  %62 = add i64 %61, %60
  %63 = load ptr, ptr %result.i62, align 8, !alias.scope !788
  %64 = getelementptr i8, ptr %63, i64 72
  %65 = load ptr, ptr %64, align 8, !alias.scope !788
  %result.i1.i = call { i64, i64 } %65(ptr nocapture nofree nonnull readonly %result.i62) #5, !alias.scope !788
  %66 = extractvalue { i64, i64 } %result.i1.i, 0
  %67 = extractvalue { i64, i64 } %result.i1.i, 1
  %68 = call i64 @llvm.umax.i64(i64 %56, i64 %67)
  %69 = call i64 @llvm.umax.i64(i64 %68, i64 8)
  %70 = urem i64 %62, %67
  %71 = icmp eq i64 %70, 0
  %72 = sub i64 %67, %70
  %73 = select i1 %71, i64 0, i64 %72
  %74 = add i64 %66, %62
  %75 = add i64 %74, %73
  %76 = urem i64 %75, %69
  %77 = icmp eq i64 %76, 0
  %78 = sub i64 %69, %76
  %79 = select i1 %77, i64 0, i64 %78
  %80 = add i64 %79, %75
  %result.i64 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i61, ptr %result.i64, align 8
  %81 = getelementptr inbounds i8, ptr %result.i64, i64 8
  store ptr %result.i62, ptr %81, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i64)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull %.fca.0.extract28)
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull %.fca.0.extract28)
  %85 = load ptr, ptr %result.i61, align 8
  %86 = getelementptr i8, ptr %85, i64 72
  %87 = load ptr, ptr %86, align 8
  %result.i.i86 = call { i64, i64 } %87(ptr nocapture nofree nonnull readonly %result.i61) #5
  %88 = extractvalue { i64, i64 } %result.i.i86, 1
  %89 = urem i64 16, %88
  %90 = icmp eq i64 %89, 0
  %reass.sub = sub i64 %88, %89
  %91 = add i64 %reass.sub, 16
  %92 = select i1 %90, i64 16, i64 %91
  %93 = getelementptr i8, ptr %result.i64, i64 %92
  %94 = getelementptr i8, ptr %85, i64 64
  %95 = load ptr, ptr %94, align 8
  call void %95({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly %result.i61, ptr nocapture nofree writeonly %93) #1
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #35
  %97 = load ptr, ptr %result.i64, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr i8, ptr %98, i64 72
  %100 = load ptr, ptr %99, align 8
  %result.i.i87 = call { i64, i64 } %100(ptr nocapture nofree nonnull readonly %97) #5
  %101 = extractvalue { i64, i64 } %result.i.i87, 0
  %102 = extractvalue { i64, i64 } %result.i.i87, 1
  %103 = urem i64 16, %102
  %104 = icmp eq i64 %103, 0
  %105 = sub i64 %102, %103
  %106 = select i1 %104, i64 0, i64 %105
  %107 = add i64 %101, 16
  %108 = add i64 %107, %106
  %109 = load ptr, ptr %81, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = getelementptr i8, ptr %110, i64 72
  %112 = load ptr, ptr %111, align 8
  %result.i1.i88 = call { i64, i64 } %112(ptr nocapture nofree nonnull readonly %109) #5
  %113 = extractvalue { i64, i64 } %result.i1.i88, 1
  %114 = urem i64 %108, %113
  %115 = icmp eq i64 %114, 0
  %116 = sub i64 %113, %114
  %117 = select i1 %115, i64 0, i64 %116
  %118 = getelementptr i8, ptr %result.i64, i64 %108
  %119 = getelementptr i8, ptr %118, i64 %117
  %120 = getelementptr i8, ptr %110, i64 64
  %121 = load ptr, ptr %120, align 8
  call void %121({ ptr, i160 } %38, ptr nocapture nofree nonnull readonly %109, ptr nocapture nofree writeonly %119) #1
  %122 = ptrtoint ptr %result.i64 to i64
  %.sroa.344.8.insert.ext = zext i64 %122 to i160
  %.sroa.344.8.insert.insert = or disjoint i160 %.sroa.344.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.thread

.thread:                                          ; preds = %3, %43, %47
  %.reg2mem41.sroa.3.085 = phi i160 [ %.sroa.344.8.insert.insert, %47 ], [ poison, %43 ], [ poison, %3 ]
  %123 = phi ptr [ @Pair, %47 ], [ @nil_typ, %43 ], [ @nil_typ, %3 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %123, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem41.sroa.3.085, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterable_field_InterleaveIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !791
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !791
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !791
  %product.i.i.i = mul i64 %hash_coef.i.i, 4936782714255954462
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !791
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 3037712219555723519
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !794
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 3037712219555723519
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !797
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @InterleaveIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !800
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !800
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !800
  %product.i.i.i = mul i64 %hash_coef.i.i, 4936782714255954462
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !800
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #37
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #41
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #37
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #16
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %result.i114 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i112, ptr %result.i114, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i114)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #37
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i115 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %4) #16
  %56 = call { ptr, ptr, ptr, i32 } %result.i115({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i117 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i118 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #37
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i130 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #16
  %71 = call { ptr, ptr, ptr, i32 } %result.i130({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i132 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i133 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i149 = load i64, ptr %hash_coef_ptr.i.i117, align 4, !noalias !22
  %tbl_size.i.i150 = load i64, ptr %tbl_size_ptr.i.i118, align 4, !noalias !22
  %offset_tbl.i.i151 = load ptr, ptr %offset_tbl_ptr.i.i119, align 8, !noalias !22
  %product.i.i.i152 = mul i64 %hash_coef.i.i149, 8673632051301757104
  %shifted.i.i.i153 = lshr i64 %product.i.i.i152, 32
  %xored.i.i.i154 = xor i64 %shifted.i.i.i153, %product.i.i.i152
  %hash.i.i.i155 = and i64 %xored.i.i.i154, %tbl_size.i.i150
  %offset_ptr.i.i156 = getelementptr i32, ptr %offset_tbl.i.i151, i64 %hash.i.i.i155
  %offset.i.i157 = load i32, ptr %offset_ptr.i.i156, align 4, !noalias !22
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i114, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @InterleaveIterator) #35
  %77 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %.fca.0.extract5, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %.fca.1.extract7, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i114, i64 24
  store ptr %.fca.2.extract9, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i114, i64 32
  store i32 %offset.i.i157, ptr %80, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i132, align 4, !noalias !22
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i133, align 4, !noalias !22
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i134, align 8, !noalias !22
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 8673632051301757104
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !803
  %81 = getelementptr inbounds i8, ptr %result.i114, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i114, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i114, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i114, i64 64
  store i32 %offset.i.i71.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @InterleaveIterator) #35
  %86 = getelementptr inbounds i8, ptr %result.i114, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterator_field_InterleaveIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !806
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !806
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !806
  %product.i.i.i = mul i64 %hash_coef.i.i, -3924664358248524505
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !806
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 8673632051301757104
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !809
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 8673632051301757104
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !812
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #36
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract10, i1 true) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @InterleaveIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !815
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !815
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !815
  %product.i.i.i = mul i64 %hash_coef.i.i, -3924664358248524505
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !815
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract3, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract4) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract3) #41
  %13 = getelementptr i8, ptr %9, i64 8
  %14 = load ptr, ptr %13, align 8
  %not. = xor i1 %11, true
  %.62 = select i1 %11, i64 8, i64 16
  tail call void %14(ptr %.fca.1.extract4, i1 %not.) #36
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract3) #41
  %16 = getelementptr i8, ptr %7, i64 %.62
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call { ptr, ptr, ptr, i32 } %18(ptr %.fca.1.extract4) #37
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %19, 3
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract10, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract11, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %.fca.3.extract12, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract9) #41
  %26 = sext i32 %.fca.3.extract12 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract9, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %result.i30 = call ptr %29({ ptr, ptr, ptr, i32 } %23, ptr nocapture nofree noundef nonnull readonly %4) #16
  %30 = call { ptr, i160 } %result.i30({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull align 8 %4) #7
  ret { ptr, i160 } %30
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @InterleaveIterator_getter_on_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterable_field_ChainIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterable_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !818
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !818
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !818
  %product.i.i.i = mul i64 %hash_coef.i.i, -2370247058431047815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !818
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 3037712219555723519
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !821
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 3037712219555723519
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !824
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ChainIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !827
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !827
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !827
  %product.i.i.i = mul i64 %hash_coef.i.i, -2370247058431047815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !827
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #37
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #41
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #37
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #16
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %result.i114 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i112, ptr %result.i114, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i114)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #37
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i115 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %4) #16
  %56 = call { ptr, ptr, ptr, i32 } %result.i115({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i117 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i118 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #37
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i130 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #16
  %71 = call { ptr, ptr, ptr, i32 } %result.i130({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i132 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i133 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i149 = load i64, ptr %hash_coef_ptr.i.i117, align 4, !noalias !22
  %tbl_size.i.i150 = load i64, ptr %tbl_size_ptr.i.i118, align 4, !noalias !22
  %offset_tbl.i.i151 = load ptr, ptr %offset_tbl_ptr.i.i119, align 8, !noalias !22
  %product.i.i.i152 = mul i64 %hash_coef.i.i149, 8673632051301757104
  %shifted.i.i.i153 = lshr i64 %product.i.i.i152, 32
  %xored.i.i.i154 = xor i64 %shifted.i.i.i153, %product.i.i.i152
  %hash.i.i.i155 = and i64 %xored.i.i.i154, %tbl_size.i.i150
  %offset_ptr.i.i156 = getelementptr i32, ptr %offset_tbl.i.i151, i64 %hash.i.i.i155
  %offset.i.i157 = load i32, ptr %offset_ptr.i.i156, align 4, !noalias !22
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i114, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @ChainIterator) #35
  %77 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %.fca.0.extract5, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %.fca.1.extract7, ptr %78, align 8
  %79 = getelementptr inbounds i8, ptr %result.i114, i64 24
  store ptr %.fca.2.extract9, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i114, i64 32
  store i32 %offset.i.i157, ptr %80, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i132, align 4, !noalias !22
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i133, align 4, !noalias !22
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i134, align 8, !noalias !22
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 8673632051301757104
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !830
  %81 = getelementptr inbounds i8, ptr %result.i114, i64 40
  store ptr %.fca.0.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i114, i64 48
  store ptr %.fca.1.extract, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i114, i64 56
  store ptr %.fca.2.extract, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i114, i64 64
  store i32 %offset.i.i71.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @ChainIterator) #35
  %86 = getelementptr inbounds i8, ptr %result.i114, i64 72
  store i1 true, ptr %86, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %87
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterator_field_ChainIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterator_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !833
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !833
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !833
  %product.i.i.i = mul i64 %hash_coef.i.i, 6043157723929225452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !833
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !22
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !22
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !22
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 8673632051301757104
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !836
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !22
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !22
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !22
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 8673632051301757104
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !839
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #36
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #35
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract10, i1 true) #36
  ret void
}

define { ptr, i160 } @ChainIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6043157723929225452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract5) #39
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract5, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract6) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  br i1 %11, label %29, label %13

13:                                               ; preds = %3
  %14 = getelementptr i8, ptr %7, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = tail call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract6) #37
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract30 = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract24, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract26, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract28, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract30, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract24)
  %24 = sext i32 %.fca.3.extract30 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract24, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %4) #16
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4) #7
  %.fca.0.extract18 = extractvalue { ptr, i160 } %28, 0
  br label %52

29:                                               ; preds = %3
  %30 = getelementptr i8, ptr %7, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = tail call { ptr, ptr, ptr, i32 } %32(ptr %.fca.1.extract6) #37
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract15, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract16, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %.fca.3.extract17, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %39 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract14)
  %40 = sext i32 %.fca.3.extract17 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract14, i64 %40
  %42 = getelementptr i8, ptr %41, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i35 = call ptr %43({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly %4) #16
  %44 = call { ptr, i160 } %result.i35({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %4) #7
  %.fca.0.extract10 = extractvalue { ptr, i160 } %44, 0
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %46 = icmp eq ptr %.fca.0.extract10, @nil_typ
  %47 = icmp eq ptr %.fca.0.extract10, null
  %.not33.not = or i1 %46, %47
  br i1 %.not33.not, label %._crit_edge.preheader, label %52

._crit_edge.preheader:                            ; preds = %29
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %._crit_edge
  %49 = load ptr, ptr %8, align 8
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  call void %51(ptr %.fca.1.extract6, i1 false) #36
  br label %._crit_edge

52:                                               ; preds = %29, %13
  %.reg2mem29.sroa.0.0 = phi ptr [ %.fca.0.extract18, %13 ], [ %.fca.0.extract10, %29 ]
  %.pn = phi { ptr, i160 } [ %28, %13 ], [ %44, %29 ]
  %.reload30.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem29.sroa.0.0, 0
  %.reg2mem29.sroa.3.0 = extractvalue { ptr, i160 } %.pn, 1
  %.reload30.fca.1.insert = insertvalue { ptr, i160 } %.reload30.fca.0.insert, i160 %.reg2mem29.sroa.3.0, 1
  ret { ptr, i160 } %.reload30.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @ChainIterator_getter_on_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterable_field_FilterIterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_init_iterableIterableT_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterable_init_iterableIterableT_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !842
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !842
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !842
  %product.i.i.i = mul i64 %hash_coef.i.i, 8498466713076104350
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !842
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !22
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !22
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !22
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 3037712219555723519
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !845
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #36
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @FilterIterable_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !848
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !848
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !848
  %product.i.i.i = mul i64 %hash_coef.i.i, 8498466713076104350
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !848
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #37
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract27) #41
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr %.fca.1.extract37) #37
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i61 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %result.i63 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i61, ptr %result.i63, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i63)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract37) #37
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract3, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract4, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %.fca.3.extract5, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract2)
  %41 = sext i32 %.fca.3.extract5 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract2, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i64 = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly %4) #16
  %45 = call { ptr, ptr, ptr, i32 } %result.i64({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %hash_coef_ptr.i.i66 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i69 = load i64, ptr %hash_coef_ptr.i.i66, align 4, !noalias !22
  %tbl_size.i.i70 = load i64, ptr %tbl_size_ptr.i.i67, align 4, !noalias !22
  %offset_tbl.i.i71 = load ptr, ptr %offset_tbl_ptr.i.i68, align 8, !noalias !22
  %product.i.i.i72 = mul i64 %hash_coef.i.i69, 8673632051301757104
  %shifted.i.i.i73 = lshr i64 %product.i.i.i72, 32
  %xored.i.i.i74 = xor i64 %shifted.i.i.i73, %product.i.i.i72
  %hash.i.i.i75 = and i64 %xored.i.i.i74, %tbl_size.i.i70
  %offset_ptr.i.i76 = getelementptr i32, ptr %offset_tbl.i.i71, i64 %hash.i.i.i75
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract37) #37
  %offset.i.i91 = load i32, ptr %offset_ptr.i.i76, align 4, !noalias !22
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i63, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %54 = getelementptr inbounds i8, ptr %result.i63, i64 8
  store ptr %.fca.0.extract1, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i63, i64 16
  store ptr %.fca.1.extract, ptr %55, align 8
  %56 = getelementptr inbounds i8, ptr %result.i63, i64 24
  store ptr %.fca.2.extract, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %result.i63, i64 32
  store i32 %offset.i.i91, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @FilterIterator) #35
  %59 = getelementptr inbounds i8, ptr %result.i63, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %49, 0
  store ptr %.fca.0.extract.i, ptr %59, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %60
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterator_field_FilterIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator_B_init_iteratorIteratorT_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterator_init_iteratorIteratorT_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !851
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !851
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !851
  %product.i.i.i = mul i64 %hash_coef.i.i, -1221365496900303883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !851
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !22
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !22
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !22
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 8673632051301757104
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !854
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #36
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #36
  ret void
}

define { ptr, i160 } @FilterIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !857
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !857
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !857
  %product.i.i.i = mul i64 %hash_coef.i.i, -1221365496900303883
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !857
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract14) #39
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract16) #37
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  %.sroa.0.081 = extractvalue { ptr, i160 } %22, 0
  %24 = icmp ne ptr %.sroa.0.081, @nil_typ
  %25 = icmp ne ptr %.sroa.0.081, null
  %.not5083 = and i1 %24, %25
  br i1 %.not5083, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  %27 = getelementptr i8, ptr %7, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr } %29(ptr %.fca.1.extract16) #37
  %.fca.0.extract3791 = extractvalue { ptr } %30, 0
  %31 = call i1 %.fca.0.extract3791({ ptr, i160 } %22)
  br i1 %31, label %._crit_edge.loopexit, label %.lr.ph93.preheader

.lr.ph93.preheader:                               ; preds = %.lr.ph
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  br label %.lr.ph93

33:                                               ; preds = %.lr.ph93
  %34 = load ptr, ptr %27, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract16) #37
  %.fca.0.extract37 = extractvalue { ptr } %36, 0
  %37 = call i1 %.fca.0.extract37({ ptr, i160 } %51)
  br i1 %37, label %._crit_edge.loopexit, label %.lr.ph93

.lr.ph93:                                         ; preds = %.lr.ph93.preheader, %33
  %.pn8492 = phi { ptr, i160 } [ %51, %33 ], [ %22, %.lr.ph93.preheader ]
  %38 = load ptr, ptr %8, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract16) #37
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract34 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract30, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract32, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract34, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract28)
  %47 = sext i32 %.fca.3.extract34 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract28, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %result.i51 = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %4) #16
  %51 = call { ptr, i160 } %result.i51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4) #7
  %.sroa.0.0 = extractvalue { ptr, i160 } %51, 0
  %52 = icmp ne ptr %.sroa.0.0, @nil_typ
  %53 = icmp ne ptr %.sroa.0.0, null
  %.not50 = and i1 %52, %53
  br i1 %.not50, label %33, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph93, %33, %.lr.ph
  %.pn84.lcssa = phi { ptr, i160 } [ %22, %.lr.ph ], [ %.pn8492, %.lr.ph93 ], [ %51, %33 ]
  %.ph = phi ptr [ %.sroa.0.081, %.lr.ph ], [ @nil_typ, %.lr.ph93 ], [ %.sroa.0.0, %33 ]
  %.sroa.3.086.le = extractvalue { ptr, i160 } %.pn84.lcssa, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.1.ph78 = phi i160 [ undef, %3 ], [ %.sroa.3.086.le, %._crit_edge.loopexit ]
  %54 = phi ptr [ @nil_typ, %3 ], [ %.ph, %._crit_edge.loopexit ]
  %.reload31.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %54, 0
  %.reload31.fca.1.insert = insertvalue { ptr, i160 } %.reload31.fca.0.insert, i160 %.1.ph78, 1
  ret { ptr, i160 } %.reload31.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterator_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterator_getter_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator_setter_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterable_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterable_getter_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable_setter_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator_field_MapIterator_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator_B_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterator_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !860
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !860
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !860
  %product.i.i.i = mul i64 %hash_coef.i.i, -146553482626734782
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !860
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !22
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !22
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !22
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 8673632051301757104
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !863
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #36
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #36
  ret void
}

define { ptr, i160 } @MapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !866
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !866
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !866
  %product.i.i.i = mul i64 %hash_coef.i.i, -146553482626734782
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !866
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract12) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract12, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract14) #37
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #41
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract12)
  %24 = icmp ne ptr %.fca.0.extract, @nil_typ
  %25 = icmp ne ptr %.fca.0.extract, null
  %.not36 = and i1 %24, %25
  br i1 %.not36, label %26, label %33

26:                                               ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %.fca.1.extract14) #37
  %.fca.0.extract28 = extractvalue { ptr } %31, 0
  %32 = call { ptr, i160 } %.fca.0.extract28({ ptr, i160 } %22)
  %.fca.0.extract22 = extractvalue { ptr, i160 } %32, 0
  %.fca.1.extract24 = extractvalue { ptr, i160 } %32, 1
  br label %33

33:                                               ; preds = %3, %26
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract22, %26 ], [ @nil_typ, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract24, %26 ], [ undef, %3 ]
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem15.sroa.0.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.reg2mem15.sroa.3.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterator_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterator_getter_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator_setter_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterable_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterable_getter_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable_setter_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Iterator_field_Iterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 96
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Iterable_field_Iterable_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Math(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Math_B__Self_sqrt_xPtrf64(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  ret ptr @Math__Self_sqrt_xPtrf64
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define ptr @Math_B__Self_abs_xPtrf64__Self_abs_xPtri32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  %3 = load ptr, ptr %0, align 8
  %4 = icmp eq ptr %3, @i32_typ
  %5 = select i1 %4, i64 9, i64 8
  %6 = getelementptr [17 x ptr], ptr @Math, i64 0, i64 %5
  %7 = getelementptr i8, ptr %6, i64 80
  %8 = load ptr, ptr %7, align 8
  ret ptr %8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define ptr @Math_B__Self_max_aPtrf64_bPtrf64__Self_max_aPtri32_bPtri32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #35
  %3 = load ptr, ptr %0, align 8
  %4 = icmp eq ptr %3, @i32_typ
  %5 = select i1 %4, i64 11, i64 10
  %6 = getelementptr [17 x ptr], ptr @Math, i64 0, i64 %5
  %7 = getelementptr i8, ptr %6, i64 80
  %8 = load ptr, ptr %7, align 8
  ret ptr %8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define ptr @Math_B__Self_min_aPtrf64_bPtrf64__Self_min_aPtri32_bPtri32(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #35
  %3 = load ptr, ptr %0, align 8
  %4 = icmp eq ptr %3, @i32_typ
  %5 = select i1 %4, i64 13, i64 12
  %6 = getelementptr [17 x ptr], ptr @Math, i64 0, i64 %5
  %7 = getelementptr i8, ptr %6, i64 80
  %8 = load ptr, ptr %7, align 8
  ret ptr %8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Math_B__Self_round_xPtrf64(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  ret ptr @Math__Self_round_xPtrf64
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Math_B__Self_floor_xPtrf64(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  ret ptr @Math__Self_floor_xPtrf64
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Math_B__Self_ceiling_xPtrf64(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  ret ptr @Math__Self_ceiling_xPtrf64
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define nofpclass(ninf nsub nnorm) double @Math__Self_sqrt_xPtrf64(ptr nocapture nofree readnone %0, double %1) #0 {
  %3 = tail call nofpclass(ninf nsub nnorm) double @llvm.sqrt.f64(double %1) #43
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i64 } @Math__Self_abs_xPtrf64(ptr nocapture nofree readnone %0, { ptr, i64 } %1) #0 {
  %.fca.1.extract8 = extractvalue { ptr, i64 } %1, 1
  %3 = bitcast i64 %.fca.1.extract8 to double
  %4 = fcmp ult double %3, 0.000000e+00
  %5 = fneg double %3
  %6 = bitcast double %5 to i64
  %.reg2mem5.sroa.3.0 = select i1 %4, i64 %6, i64 %.fca.1.extract8
  %.reload6.fca.1.insert = insertvalue { ptr, i64 } { ptr @f64_typ, i64 undef }, i64 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i64 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i64 } @Math__Self_abs_xPtri32(ptr nocapture nofree readnone %0, { ptr, i64 } %1) #0 {
  %.fca.1.extract7 = extractvalue { ptr, i64 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i64 %.fca.1.extract7 to i32
  %.sroa.013.0.insert.ext = and i64 %.fca.1.extract7, 2147483647
  %3 = sub i32 0, %.sroa.1.8.extract.trunc
  %.sroa.09.0.insert.ext = zext i32 %3 to i64
  %4 = icmp slt i32 %.sroa.1.8.extract.trunc, 0
  %.reg2mem5.sroa.3.0 = select i1 %4, i64 %.sroa.09.0.insert.ext, i64 %.sroa.013.0.insert.ext
  %.reload6.fca.1.insert = insertvalue { ptr, i64 } { ptr @i32_typ, i64 undef }, i64 %.reg2mem5.sroa.3.0, 1
  ret { ptr, i64 } %.reload6.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i64 } @Math__Self_max_aPtrf64_bPtrf64(ptr nocapture nofree readnone %0, { ptr, i64 } %1, { ptr, i64 } %2) #0 {
.cont:
  %.fca.1.extract4 = extractvalue { ptr, i64 } %1, 1
  %3 = bitcast i64 %.fca.1.extract4 to double
  %.fca.1.extract = extractvalue { ptr, i64 } %2, 1
  %4 = bitcast i64 %.fca.1.extract to double
  %5 = fcmp ogt double %3, %4
  %.sroa.speculated = select i1 %5, double %3, double %4
  %6 = bitcast double %.sroa.speculated to i64
  %7 = insertvalue { ptr, i64 } { ptr @f64_typ, i64 undef }, i64 %6, 1
  ret { ptr, i64 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i64 } @Math__Self_max_aPtri32_bPtri32(ptr nocapture nofree readnone %0, { ptr, i64 } %1, { ptr, i64 } %2) #0 {
.cont:
  %.fca.1.extract6 = extractvalue { ptr, i64 } %1, 1
  %.sroa.18.8.extract.trunc = trunc i64 %.fca.1.extract6 to i32
  %.fca.1.extract = extractvalue { ptr, i64 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i64 %.fca.1.extract to i32
  %.sroa.speculated = tail call i32 @llvm.smax.i32(i32 %.sroa.18.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  %.sroa.2.8.insert.ext = zext i32 %.sroa.speculated to i64
  %3 = insertvalue { ptr, i64 } { ptr @i32_typ, i64 undef }, i64 %.sroa.2.8.insert.ext, 1
  ret { ptr, i64 } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i64 } @Math__Self_min_aPtrf64_bPtrf64(ptr nocapture nofree readnone %0, { ptr, i64 } %1, { ptr, i64 } %2) #0 {
.cont:
  %.fca.1.extract4 = extractvalue { ptr, i64 } %1, 1
  %3 = bitcast i64 %.fca.1.extract4 to double
  %.fca.1.extract = extractvalue { ptr, i64 } %2, 1
  %4 = bitcast i64 %.fca.1.extract to double
  %5 = fcmp olt double %3, %4
  %.sroa.speculated = select i1 %5, double %3, double %4
  %6 = bitcast double %.sroa.speculated to i64
  %7 = insertvalue { ptr, i64 } { ptr @f64_typ, i64 undef }, i64 %6, 1
  ret { ptr, i64 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i64 } @Math__Self_min_aPtri32_bPtri32(ptr nocapture nofree readnone %0, { ptr, i64 } %1, { ptr, i64 } %2) #0 {
.cont:
  %.fca.1.extract6 = extractvalue { ptr, i64 } %1, 1
  %.sroa.18.8.extract.trunc = trunc i64 %.fca.1.extract6 to i32
  %.fca.1.extract = extractvalue { ptr, i64 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i64 %.fca.1.extract to i32
  %.sroa.speculated = tail call i32 @llvm.smin.i32(i32 %.sroa.18.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  %.sroa.2.8.insert.ext = zext i32 %.sroa.speculated to i64
  %3 = insertvalue { ptr, i64 } { ptr @i32_typ, i64 undef }, i64 %.sroa.2.8.insert.ext, 1
  ret { ptr, i64 } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define nofpclass(sub) double @Math__Self_round_xPtrf64(ptr nocapture nofree readnone %0, double %1) #0 {
  %3 = tail call nofpclass(sub) double @llvm.round.f64(double %1) #43
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define nofpclass(sub) double @Math__Self_floor_xPtrf64(ptr nocapture nofree readnone %0, double %1) #0 {
  %3 = tail call nofpclass(sub) double @llvm.floor.f64(double %1) #43
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define nofpclass(sub) double @Math__Self_ceiling_xPtrf64(ptr nocapture nofree readnone %0, double %1) #0 {
  %3 = tail call nofpclass(sub) double @llvm.ceil.f64(double %1) #43
  ret double %3
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.ceil.f64(double) #18

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.floor.f64(double) #18

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.round.f64(double) #18

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.sqrt.f64(double) #18

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Range(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 12, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @Range_field_Range_0(ptr nocapture nofree readnone %0) #0 {
  ret ptr @_parameterization_Ptri32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_init_endPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_init_startPtri32_endPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_step_stepPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Range_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Range_init_endPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !869
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !869
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !869
  %product.i.i.i = mul i64 %hash_coef.i.i, 5490049236840671069
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !869
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract, i32 %3) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %13 = load ptr, ptr %7, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 0) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, i32 1) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Range_init_startPtri32_endPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !872
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !872
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !872
  %product.i.i.i = mul i64 %hash_coef.i.i, 5490049236840671069
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !872
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract, i32 %3) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  tail call void %16(ptr %.fca.1.extract, i32 %4) #36
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract, i32 1) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Range_step_stepPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !875
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !875
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !875
  %product.i.i.i = mul i64 %hash_coef.i.i, 5490049236840671069
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !875
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract, i32 %3) #36
  %hash_coef.i.i5 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !878
  %tbl_size.i.i6 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !878
  %offset_tbl.i.i7 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !878
  %product.i.i.i8 = mul i64 %hash_coef.i.i5, 5490049236840671069
  %shifted.i.i.i9 = lshr i64 %product.i.i.i8, 32
  %xored.i.i.i10 = xor i64 %shifted.i.i.i9, %product.i.i.i8
  %hash.i.i.i11 = and i64 %xored.i.i.i10, %tbl_size.i.i6
  %offset_ptr.i.i12 = getelementptr i32, ptr %offset_tbl.i.i7, i64 %hash.i.i.i11
  %offset.i.i13 = load i32, ptr %offset_ptr.i.i12, align 4, !noalias !878
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i13, 3
  ret { ptr, ptr, ptr, i32 } %15
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @Range_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !881
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !881
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !881
  %product.i.i.i = mul i64 %hash_coef.i.i, 5490049236840671069
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !881
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i32 %8(ptr %.fca.1.extract) #37
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %11 = getelementptr i8, ptr %6, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = tail call i32 %13(ptr %.fca.1.extract) #37
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %16 = getelementptr i8, ptr %6, i64 16
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call i32 %18(ptr %.fca.1.extract) #37
  %result.i10 = tail call noalias dereferenceable_or_null(12) ptr @bump_malloc_inner(i64 noundef 12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %21 = load ptr, ptr %6, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = tail call i32 %22(ptr %.fca.1.extract) #37
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %25 = load ptr, ptr %11, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = tail call i32 %26(ptr %.fca.1.extract) #37
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 440, ptr nocapture nofree noundef %.fca.0.extract) #35
  %29 = load ptr, ptr %16, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = tail call i32 %30(ptr %.fca.1.extract) #37
  %32 = insertvalue { ptr, ptr, ptr, i32 } { ptr @RangeIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr undef, 2
  store i32 %23, ptr %result.i10, align 4
  %34 = getelementptr i8, ptr %result.i10, i64 4
  store i32 %27, ptr %34, align 4
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @RangeIterator) #35
  %36 = getelementptr i8, ptr %result.i10, i64 8
  store i32 %31, ptr %36, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %37
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_RangeIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 12, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @RangeIterator_field_RangeIterator_0(ptr nocapture nofree readnone %0) #0 {
  ret ptr @_parameterization_Ptri32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @RangeIterator_B_init_counterPtri32_endPtri32_stepPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @RangeIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @RangeIterator_init_counterPtri32_endPtri32_stepPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4, i32 %5) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !884
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !884
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !884
  %product.i.i.i = mul i64 %hash_coef.i.i, -913562485944406675
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !884
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, i32 %3) #36
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract) #35
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4) #36
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract) #35
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 %5) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @RangeIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !887
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !887
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !887
  %product.i.i.i = mul i64 %hash_coef.i.i, -913562485944406675
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !887
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract4) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract4, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i32 %8(ptr %.fca.1.extract5) #37
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract4) #35
  %11 = getelementptr i8, ptr %6, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = tail call i32 %13(ptr %.fca.1.extract5) #37
  %15 = icmp sgt i32 %9, %14
  br i1 %15, label %30, label %16

16:                                               ; preds = %3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %18 = tail call i32 %8(ptr %.fca.1.extract5) #37
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %20 = tail call i32 %8(ptr %.fca.1.extract5) #37
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %22 = getelementptr i8, ptr %6, i64 16
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = tail call i32 %24(ptr %.fca.1.extract5) #37
  %26 = add i32 %25, %20
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %28 = getelementptr i8, ptr %7, i64 8
  %29 = load ptr, ptr %28, align 8
  tail call void %29(ptr %.fca.1.extract5, i32 %26) #36
  %.sroa.07.0.insert.ext = zext i32 %18 to i160
  br label %30

30:                                               ; preds = %3, %16
  %.reg2mem21.sroa.0.0 = phi ptr [ @i32_typ, %16 ], [ @nil_typ, %3 ]
  %.reg2mem21.sroa.3.0 = phi i160 [ %.sroa.07.0.insert.ext, %16 ], [ undef, %3 ]
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem21.sroa.0.0, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %.reg2mem21.sroa.3.0, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_step(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_step(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_end(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_end(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @RangeIterator_getter_counter(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @RangeIterator_setter_counter(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_step(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_step(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_end(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_end(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 4
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Range_getter_start(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Range_setter_start(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IO(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @IO_B__Self_print_xString__Self_print_xPtri1__Self_print_xPtri32__Self_print_xCharacter__Self_print_xRepresentable__Self_print_xPtrf64__Self_print_xNil__Self_print_xPtri64__Self_print_xPtri8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #19 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  %3 = load ptr, ptr %0, align 8
  %4 = icmp eq ptr %3, @f64_typ
  br i1 %4, label %._crit_edge, label %5

5:                                                ; preds = %1
  %6 = icmp eq ptr %3, @i64_typ
  br i1 %6, label %._crit_edge, label %7

7:                                                ; preds = %5
  %8 = icmp eq ptr %3, @i32_typ
  br i1 %8, label %._crit_edge, label %9

9:                                                ; preds = %7
  %10 = icmp eq ptr %3, @bool_typ
  br i1 %10, label %._crit_edge, label %11

11:                                               ; preds = %9
  %12 = getelementptr i8, ptr %3, i64 8
  %13 = getelementptr i8, ptr %3, i64 16
  %14 = getelementptr i8, ptr %3, i64 24
  %15 = getelementptr i8, ptr %3, i64 32
  %16 = load i64, ptr %12, align 4
  %17 = load i64, ptr %13, align 4
  %18 = load ptr, ptr %14, align 8
  %19 = load ptr, ptr %15, align 8
  %result.i = tail call i1 %18(i64 %17, i64 %16, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %19) #5
  br i1 %result.i, label %20, label %.critedge

20:                                               ; preds = %11
  %result.i13 = tail call i1 %18(i64 %17, i64 %16, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %19) #5
  %result.i14 = tail call i1 %18(i64 %17, i64 %16, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %19) #5
  %.reg2mem43.0 = select i1 %result.i13, i1 true, i1 %result.i14
  br i1 %.reg2mem43.0, label %.critedge, label %._crit_edge

.critedge:                                        ; preds = %11, %20
  %21 = icmp eq ptr %3, @nil_typ
  %22 = icmp eq ptr %3, null
  %23 = or i1 %21, %22
  br i1 %23, label %._crit_edge, label %24

24:                                               ; preds = %.critedge
  %result.i15 = tail call i1 %18(i64 %17, i64 %16, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %19) #5
  %result.i16 = tail call i1 %18(i64 %17, i64 %16, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %19) #5
  %not.result.i15 = xor i1 %result.i15, true
  %.reg2mem39.0 = select i1 %not.result.i15, i1 true, i1 %result.i16
  br i1 %.reg2mem39.0, label %25, label %._crit_edge

25:                                               ; preds = %24
  %26 = icmp eq ptr %3, @i8_typ
  %27 = select i1 %26, i32 9, i32 4
  br label %._crit_edge

._crit_edge:                                      ; preds = %25, %5, %9, %20, %.critedge, %24, %7, %1
  %.reg2mem25.0 = phi i32 [ 6, %1 ], [ 8, %5 ], [ 3, %7 ], [ 2, %9 ], [ 7, %.critedge ], [ 1, %24 ], [ 5, %20 ], [ %27, %25 ]
  %28 = zext nneg i32 %.reg2mem25.0 to i64
  %29 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  ret ptr %31
}

; Function Attrs: nounwind
define void @IO__Self_print_xString(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !890
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !890
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !890
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !890
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #35
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract1, i64 %12
  %14 = getelementptr i8, ptr %13, i64 80
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #16
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri1(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %3 = trunc i160 %.fca.1.extract to i1
  br i1 %3, label %._crit_edge.lr.ph.i, label %._crit_edge.lr.ph.i84

._crit_edge.lr.ph.i:                              ; preds = %2
  %result.i.i = tail call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store i32 1702195828, ptr %result.i.i, align 1
  br label %String_c_string_.exit

._crit_edge.lr.ph.i84:                            ; preds = %2
  %result.i39 = tail call noalias align 8 dereferenceable_or_null(6) ptr @bump_malloc_inner(i64 noundef 6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <5 x i8> <i8 102, i8 97, i8 108, i8 115, i8 101>, ptr %result.i39, align 8
  %result.i.i83 = tail call noalias dereferenceable_or_null(6) ptr @bump_malloc_inner(i64 noundef 6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i.i83, ptr noundef nonnull align 8 dereferenceable(5) %result.i39, i64 5, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %._crit_edge.lr.ph.i84, %._crit_edge.lr.ph.i
  %4 = phi i32 [ 4, %._crit_edge.lr.ph.i ], [ 5, %._crit_edge.lr.ph.i84 ]
  %result.i.i83.sink = phi ptr [ %result.i.i, %._crit_edge.lr.ph.i ], [ %result.i.i83, %._crit_edge.lr.ph.i84 ]
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %6 = zext nneg i32 %4 to i64
  %7 = getelementptr i8, ptr %result.i.i83.sink, i64 %6
  store i8 0, ptr %7, align 1
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i83.sink)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri32(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.sroa.1.8.extract.trunc) #17
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xCharacter(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !893
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !893
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !893
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !893
  %result.i = tail call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #35
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #35
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i8 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #16
  %16 = call i8 %result.i8({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  store i8 %16, ptr %result.i, align 1
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %result.i)
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xRepresentable(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.322.8.extract.trunc = trunc i160 %.fca.1.extract3 to i64
  %4 = inttoptr i64 %.sroa.322.8.extract.trunc to ptr
  %.sroa.523.8.extract.shift = lshr i160 %.fca.1.extract3, 64
  %.sroa.523.8.extract.trunc = trunc i160 %.sroa.523.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.523.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !896
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !896
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !896
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260840641129990118
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !896
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #35
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract2, i64 %12
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #16
  %15 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %hash_coef_ptr.i.i7 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i8 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i10 = load i64, ptr %hash_coef_ptr.i.i7, align 4, !noalias !899
  %tbl_size.i.i11 = load i64, ptr %tbl_size_ptr.i.i8, align 4, !noalias !899
  %offset_tbl.i.i12 = load ptr, ptr %offset_tbl_ptr.i.i9, align 8, !noalias !899
  %product.i.i.i13 = mul i64 %hash_coef.i.i10, 6499063144389013426
  %shifted.i.i.i14 = lshr i64 %product.i.i.i13, 32
  %xored.i.i.i15 = xor i64 %shifted.i.i.i14, %product.i.i.i13
  %hash.i.i.i16 = and i64 %xored.i.i.i15, %tbl_size.i.i11
  %offset_ptr.i.i17 = getelementptr i32, ptr %offset_tbl.i.i12, i64 %hash.i.i.i16
  %offset.i.i18 = load i32, ptr %offset_ptr.i.i17, align 4, !noalias !899
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i.i18, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract1)
  %22 = sext i32 %offset.i.i18 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract1, i64 %22
  %24 = getelementptr i8, ptr %23, i64 80
  %25 = load ptr, ptr %24, align 8
  %result.i20 = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly %3) #16
  %26 = call { ptr } %result.i20({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr } %26, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtrf64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @float_string, double %3) #17
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xNil(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
._crit_edge.lr.ph.i:
  %result.i = tail call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <3 x i8> <i8 110, i8 105, i8 108>, ptr %result.i, align 4
  %result.i.i = tail call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i, i64 3, i1 false)
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String)
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.sroa.1.8.extract.trunc) #17
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri8(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  %3 = sext i8 %.sroa.1.8.extract.trunc to i32
  %4 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3) #17
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Blocking(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Blocking_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @Blocking_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Channel(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Channel_field_Channel_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Channel_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Channel_B_get_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Channel_B_put_new_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Channel_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !902
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !902
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !902
  %product.i.i.i = mul i64 %hash_coef.i.i, -3668118116639750450
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !902
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  tail call void %10(ptr %.fca.1.extract, { ptr, i160 } { ptr @nil_typ, i160 undef }) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @Channel_get_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !905
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !905
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !905
  %product.i.i.i = mul i64 %hash_coef.i.i, -3668118116639750450
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !905
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef nonnull %.fca.0.extract2) #39
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract2, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract3) #37
  %.fca.0.extract1632 = extractvalue { ptr, i160 } %10, 0
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef nonnull %.fca.0.extract2) #39
  %12 = icmp ne ptr %.fca.0.extract1632, @nil_typ
  %13 = icmp ne ptr %.fca.0.extract1632, null
  %.not2333 = and i1 %12, %13
  br i1 %.not2333, label %.critedge, label %.lr.ph

.lr.ph:                                           ; preds = %3, %.lr.ph
  %result.i26 = tail call noalias ptr @bump_malloc_inner(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 16 dereferenceable(96) @Blocking)
  %15 = ptrtoint ptr %result.i26 to i64
  %.sroa.3.8.insert.ext = zext i64 %15 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %16 = insertvalue { ptr, i160 } { ptr @Blocking, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %17 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %16, ptr %17, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr, i160 } %19(ptr %.fca.1.extract3) #37
  %.fca.0.extract16 = extractvalue { ptr, i160 } %20, 0
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef nonnull %.fca.0.extract2) #39
  %22 = icmp ne ptr %.fca.0.extract16, @nil_typ
  %23 = icmp ne ptr %.fca.0.extract16, null
  %.not23 = and i1 %22, %23
  br i1 %.not23, label %.critedge, label %.lr.ph

.critedge:                                        ; preds = %.lr.ph, %3
  %.lcssa31 = phi ptr [ %8, %3 ], [ %18, %.lr.ph ]
  %.lcssa = phi { ptr, i160 } [ %10, %3 ], [ %20, %.lr.ph ]
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef nonnull %.fca.0.extract2)
  %25 = getelementptr i8, ptr %.lcssa31, i64 8
  %26 = load ptr, ptr %25, align 8
  tail call void %26(ptr %.fca.1.extract3, { ptr, i160 } { ptr @nil_typ, i160 undef }) #36
  ret { ptr, i160 } %.lcssa
}

; Function Attrs: nounwind
define void @Channel_put_new_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !908
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !908
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !908
  %product.i.i.i = mul i64 %hash_coef.i.i, -3668118116639750450
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !908
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef %.fca.0.extract5) #39
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract5, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, i160 } %10(ptr %.fca.1.extract6) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %.sroa.0.032 = extractvalue { ptr, i160 } %11, 0
  %13 = icmp ne ptr %.sroa.0.032, @nil_typ
  %14 = icmp ne ptr %.sroa.0.032, null
  %.not2333 = and i1 %13, %14
  br i1 %.not2333, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge:                                      ; preds = %4, %._crit_edge
  %result.i24 = tail call noalias ptr @bump_malloc_inner(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 16 dereferenceable(96) @Blocking)
  %16 = ptrtoint ptr %result.i24 to i64
  %.sroa.3.8.insert.ext = zext i64 %16 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %17 = insertvalue { ptr, i160 } { ptr @Blocking, i160 undef }, i160 %.sroa.3.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %18 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %17, ptr %18, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %20 = load ptr, ptr %8, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call { ptr, i160 } %21(ptr %.fca.1.extract6) #37
  %.sroa.0.0 = extractvalue { ptr, i160 } %22, 0
  %23 = icmp ne ptr %.sroa.0.0, @nil_typ
  %24 = icmp ne ptr %.sroa.0.0, null
  %.not23 = and i1 %23, %24
  br i1 %.not23, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %4
  %25 = phi ptr [ %9, %4 ], [ %20, %._crit_edge ]
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %27 = getelementptr i8, ptr %25, i64 8
  %28 = load ptr, ptr %27, align 8
  tail call void %28(ptr %.fca.1.extract6, { ptr, i160 } %3) #36
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @Channel_getter_value(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i160, ptr %5, align 4
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Channel_setter_value(ptr nocapture nofree writeonly %0, { ptr, i160 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store i160 %.fca.1.extract, ptr %4, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Array(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterableT(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  ret ptr @Array__Self_from_iterable_iterableIterableT
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_bufferBufferT_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_extend_otherArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__set_index_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_throw_oob_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_insert_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 496
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 504
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 512
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 520
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 528
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 536
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterableT(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !911
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !911
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !911
  %product.i.i.i = mul i64 %hash_coef.i.i, 3037712219555723519
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !911
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract26) #39
  %5 = sext i32 %.fca.3.extract29 to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract26, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract27) #5
  %result.i73 = tail call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i73, align 8
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i73) #39
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #35
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #35
  %11 = load ptr, ptr %result.i, align 8
  %12 = getelementptr i8, ptr %11, i64 72
  %13 = load ptr, ptr %12, align 8
  %result.i3.i = tail call { i64, i64 } %13(ptr nocapture nofree nonnull readonly %result.i) #5
  %14 = extractvalue { i64, i64 } %result.i3.i, 0
  %result.i4.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %15 = getelementptr inbounds i8, ptr %result.i73, i64 8
  store ptr %result.i4.i, ptr %15, align 8
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %17 = getelementptr inbounds i8, ptr %result.i73, i64 20
  store i32 1, ptr %17, align 4
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract27, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract28, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract26)
  %24 = sext i32 %offset.i.i to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract26, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i89 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %3) #16
  %28 = call { ptr, ptr, ptr, i32 } %result.i89({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 2
  %hash_coef_ptr.i.i91 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i92 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i93 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i94 = load i64, ptr %hash_coef_ptr.i.i91, align 4, !noalias !22
  %tbl_size.i.i95 = load i64, ptr %tbl_size_ptr.i.i92, align 4, !noalias !22
  %offset_tbl.i.i96 = load ptr, ptr %offset_tbl_ptr.i.i93, align 8, !noalias !22
  %product.i.i.i97 = mul i64 %hash_coef.i.i94, 8673632051301757104
  %shifted.i.i.i98 = lshr i64 %product.i.i.i97, 32
  %xored.i.i.i99 = xor i64 %shifted.i.i.i98, %product.i.i.i97
  %hash.i.i.i100 = and i64 %xored.i.i.i99, %tbl_size.i.i95
  %offset_ptr.i.i101 = getelementptr i32, ptr %offset_tbl.i.i96, i64 %hash.i.i.i100
  %offset.i.i116 = load i32, ptr %offset_ptr.i.i101, align 4, !noalias !914
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.1.extract, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.2.extract, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i116, 3
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %35 = sext i32 %offset.i.i116 to i64
  %36 = getelementptr ptr, ptr %.fca.0.extract, i64 %35
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %result.i118164 = call ptr %38({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %3) #16
  %39 = call { ptr, i160 } %result.i118164({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 %3) #7
  %.fca.0.extract63165 = extractvalue { ptr, i160 } %39, 0
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %41 = icmp ne ptr %.fca.0.extract63165, @nil_typ
  %42 = icmp ne ptr %.fca.0.extract63165, null
  %.not71166 = and i1 %41, %42
  br i1 %.not71166, label %._crit_edge.lr.ph, label %.critedge

._crit_edge.lr.ph:                                ; preds = %2
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %44 = getelementptr inbounds i8, ptr %result.i73, i64 16
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %Array_append_xT.exit
  %45 = phi ptr [ %result.i4.i, %._crit_edge.lr.ph ], [ %74, %Array_append_xT.exit ]
  %.pre168 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %86, %Array_append_xT.exit ]
  %46 = phi { ptr, i160 } [ %39, %._crit_edge.lr.ph ], [ %89, %Array_append_xT.exit ]
  %47 = load i32, ptr %17, align 4
  %.not.i = icmp slt i32 %.pre168, %47
  br i1 %.not.i, label %Array_append_xT.exit, label %48

48:                                               ; preds = %._crit_edge
  %49 = shl i32 %47, 1
  %.not.i169 = icmp sgt i32 %49, %47
  %.pre.pre = load ptr, ptr %15, align 8
  br i1 %.not.i169, label %50, label %Array_append_xT.exit

50:                                               ; preds = %48
  store i32 %49, ptr %17, align 4
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array)
  %52 = load ptr, ptr %result.i, align 8
  %53 = getelementptr i8, ptr %52, i64 72
  %54 = load ptr, ptr %53, align 8
  %result.i25.i = call { i64, i64 } %54(ptr nocapture nofree nonnull readonly %result.i) #5
  %55 = extractvalue { i64, i64 } %result.i25.i, 0
  %56 = sext i32 %49 to i64
  %57 = mul i64 %55, %56
  %result.i26.i = call noalias ptr @bump_malloc_inner(i64 noundef %57, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i26.i, ptr %15, align 8
  %58 = icmp sgt i32 %.pre168, 0
  br i1 %58, label %._crit_edge.lr.ph.i, label %Array_append_xT.exit

._crit_edge.lr.ph.i:                              ; preds = %50
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i, %._crit_edge.lr.ph.i
  %.057.i = phi i32 [ 0, %._crit_edge.lr.ph.i ], [ %72, %._crit_edge.i ]
  %60 = load ptr, ptr %result.i, align 8
  %61 = getelementptr i8, ptr %60, i64 72
  %62 = load ptr, ptr %61, align 8
  %result.i28.i = call { i64, i64 } %62(ptr nocapture nofree nonnull readonly %result.i) #5
  %63 = extractvalue { i64, i64 } %result.i28.i, 0
  %64 = zext nneg i32 %.057.i to i64
  %65 = mul i64 %63, %64
  %66 = getelementptr i8, ptr %.pre.pre, i64 %65
  %67 = getelementptr i8, ptr %60, i64 56
  %68 = load ptr, ptr %67, align 8
  %result.i29.i = call { ptr, i160 } %68(ptr nocapture nofree readonly %66, ptr nocapture nofree nonnull readonly %result.i) #5
  %69 = getelementptr i8, ptr %result.i26.i, i64 %65
  %70 = getelementptr i8, ptr %60, i64 64
  %71 = load ptr, ptr %70, align 8
  call void %71({ ptr, i160 } %result.i29.i, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %69) #1
  %72 = add nuw nsw i32 %.057.i, 1
  %73 = icmp slt i32 %72, %.pre168
  br i1 %73, label %._crit_edge.i, label %Array_append_xT.exit

Array_append_xT.exit:                             ; preds = %._crit_edge.i, %50, %48, %._crit_edge
  %74 = phi ptr [ %45, %._crit_edge ], [ %.pre.pre, %48 ], [ %result.i26.i, %50 ], [ %result.i26.i, %._crit_edge.i ]
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  %76 = load ptr, ptr %result.i, align 8
  %77 = getelementptr i8, ptr %76, i64 72
  %78 = load ptr, ptr %77, align 8
  %result.i20.i = call { i64, i64 } %78(ptr nocapture nofree nonnull readonly %result.i) #5
  %79 = extractvalue { i64, i64 } %result.i20.i, 0
  %80 = sext i32 %.pre168 to i64
  %81 = mul i64 %79, %80
  %82 = getelementptr i8, ptr %74, i64 %81
  %83 = getelementptr i8, ptr %76, i64 64
  %84 = load ptr, ptr %83, align 8
  call void %84({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %82) #1
  %85 = load i32, ptr %44, align 8
  %86 = add i32 %85, 1
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull @Array) #41
  store i32 %86, ptr %44, align 8
  %88 = load ptr, ptr %37, align 8
  %result.i118 = call ptr %88({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %3) #16
  %89 = call { ptr, i160 } %result.i118({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 %3) #7
  %.fca.0.extract63 = extractvalue { ptr, i160 } %89, 0
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %91 = icmp ne ptr %.fca.0.extract63, @nil_typ
  %92 = icmp ne ptr %.fca.0.extract63, null
  %.not71 = and i1 %91, %92
  br i1 %.not71, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %Array_append_xT.exit, %2
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i73, 1
  %93 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %94
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !917
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !917
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !917
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !917
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %8 = load ptr, ptr %result.i, align 8
  %9 = getelementptr i8, ptr %8, i64 72
  %10 = load ptr, ptr %9, align 8
  %result.i3 = tail call { i64, i64 } %10(ptr nocapture nofree nonnull readonly %result.i) #5
  %11 = extractvalue { i64, i64 } %result.i3, 0
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %13 = getelementptr i8, ptr %6, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %16(ptr %.fca.1.extract, { ptr } %17) #36
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %19 = getelementptr i8, ptr %6, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 0) #36
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #41
  %24 = getelementptr i8, ptr %6, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  tail call void %27(ptr %.fca.1.extract, i32 1) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !920
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !920
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !920
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !920
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract, i32 %3) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #37
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %17 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %18 = load ptr, ptr %result.i, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %result.i3 = tail call { i64, i64 } %20(ptr nocapture nofree nonnull readonly %result.i) #5
  %21 = extractvalue { i64, i64 } %result.i3, 0
  %22 = sext i32 %15 to i64
  %23 = mul i64 %21, %22
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %25 = getelementptr i8, ptr %7, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %28(ptr %.fca.1.extract, { ptr } %29) #36
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %31 = getelementptr i8, ptr %7, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  tail call void %34(ptr %.fca.1.extract, i32 0) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !923
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !923
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !923
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !923
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, i32 %3) #36
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4) #36
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %19 = load ptr, ptr %14, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call i32 %20(ptr %.fca.1.extract) #37
  %22 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %23 = load ptr, ptr %8, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %23(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %24 = load ptr, ptr %result.i, align 8
  %25 = getelementptr i8, ptr %24, i64 72
  %26 = load ptr, ptr %25, align 8
  %result.i3 = tail call { i64, i64 } %26(ptr nocapture nofree nonnull readonly %result.i) #5
  %27 = extractvalue { i64, i64 } %result.i3, 0
  %28 = sext i32 %21 to i64
  %29 = mul i64 %27, %28
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %29, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %31 = getelementptr i8, ptr %8, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %34(ptr %.fca.1.extract, { ptr } %35) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_bufferBufferT_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !926
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !926
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !926
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !926
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract2, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  tail call void %13(ptr %.fca.1.extract, { ptr } %3) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %15 = getelementptr i8, ptr %9, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract, i32 %4) #36
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract2) #35
  %20 = getelementptr i8, ptr %9, i64 24
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  tail call void %23(ptr %.fca.1.extract, i32 %5) #36
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !929
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !929
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !929
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !929
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #37
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !932
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !932
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !932
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !932
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #37
  ret i32 %10
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !935
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !935
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !935
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !935
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract4) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract4, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract5) #37
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract4) #35
  %15 = getelementptr i8, ptr %9, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract5) #37
  %.not = icmp slt i32 %13, %18
  br i1 %.not, label %.._crit_edge_crit_edge, label %19

.._crit_edge_crit_edge:                           ; preds = %4
  %.pre65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %.pre66 = insertvalue { ptr, ptr, ptr, i32 } %.pre65, ptr %.fca.1.extract5, 1
  %.pre68 = insertvalue { ptr, ptr, ptr, i32 } %.pre66, ptr %.fca.2.extract, 2
  br label %._crit_edge

19:                                               ; preds = %4
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %21 = tail call i32 %17(ptr %.fca.1.extract5) #37
  %22 = shl i32 %21, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract5, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #41
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %29 = getelementptr i8, ptr %9, i64 104
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %22) #7
  %.pre = load ptr, ptr %10, align 8
  %.pre64 = load ptr, ptr %.pre, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %.._crit_edge_crit_edge, %19
  %.pre-phi69 = phi { ptr, ptr, ptr, i32 } [ %.pre68, %.._crit_edge_crit_edge ], [ %25, %19 ]
  %31 = phi ptr [ %12, %.._crit_edge_crit_edge ], [ %.pre64, %19 ]
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %33 = getelementptr i8, ptr %9, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract5) #37
  %.fca.0.extract14 = extractvalue { ptr } %36, 0
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %38 = call i32 %31(ptr %.fca.1.extract5) #37
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %40 = load ptr, ptr %9, align 8
  %result.i19 = call nonnull align 8 dereferenceable(8) ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #5
  %41 = load ptr, ptr %result.i19, align 8
  %42 = getelementptr i8, ptr %41, i64 72
  %43 = load ptr, ptr %42, align 8
  %result.i20 = call { i64, i64 } %43(ptr nocapture nofree nonnull readonly %result.i19) #5
  %44 = extractvalue { i64, i64 } %result.i20, 0
  %45 = sext i32 %38 to i64
  %46 = mul i64 %44, %45
  %47 = getelementptr i8, ptr %.fca.0.extract14, i64 %46
  %48 = getelementptr i8, ptr %41, i64 64
  %49 = load ptr, ptr %48, align 8
  call void %49({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly %result.i19, ptr nocapture nofree writeonly %47) #1
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %51 = load ptr, ptr %10, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr %.fca.1.extract5) #37
  %54 = add i32 %53, 1
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #41
  %56 = getelementptr i8, ptr %51, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr %.fca.1.extract5, i32 %54) #36
  %hash_coef.i.i25 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !938
  %tbl_size.i.i26 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !938
  %offset_tbl.i.i27 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !938
  %product.i.i.i28 = mul i64 %hash_coef.i.i25, -5261542750394134544
  %shifted.i.i.i29 = lshr i64 %product.i.i.i28, 32
  %xored.i.i.i30 = xor i64 %shifted.i.i.i29, %product.i.i.i28
  %hash.i.i.i31 = and i64 %xored.i.i.i30, %tbl_size.i.i26
  %offset_ptr.i.i32 = getelementptr i32, ptr %offset_tbl.i.i27, i64 %hash.i.i.i31
  %offset.i.i33 = load i32, ptr %offset_ptr.i.i32, align 4, !noalias !938
  %58 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi69, i32 %offset.i.i33, 3
  ret { ptr, ptr, ptr, i32 } %58
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array_extend_otherArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !941
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !941
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !941
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !941
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !944
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !944
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !944
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, -5261542750394134544
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i41 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !944
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %.fca.1.extract, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.2.extract, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %offset.i.i41, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #39
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #39
  %16 = sext i32 %offset.i.i41 to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract, i64 %16
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i = call ptr %19({ ptr, ptr, ptr, i32 } %13, ptr nocapture nofree noundef nonnull readonly %5) #16
  %20 = call i32 %result.i({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 %5) #7
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract10)
  %22 = sext i32 %offset.i.i to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract10, i64 %22
  %24 = getelementptr i8, ptr %23, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %.fca.1.extract11) #37
  %28 = add i32 %27, %20
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.1.extract11, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.2.extract12, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i, 3
  %33 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %33)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract10)
  %36 = getelementptr i8, ptr %23, i64 104
  %37 = load ptr, ptr %36, align 8
  %38 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %38, align 8
  %result.i43 = call ptr %37({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %38) #16
  call void %result.i43({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 dereferenceable(8) %33, i32 %28) #7
  %39 = icmp sgt i32 %20, 0
  br i1 %39, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %4
  %40 = getelementptr i8, ptr %17, i64 136
  %41 = getelementptr inbounds i8, ptr %8, i64 8
  %42 = getelementptr i8, ptr %23, i64 144
  %43 = getelementptr inbounds i8, ptr %9, i64 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.084 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %54, %._crit_edge ]
  %44 = add i32 %.084, %27
  store ptr @_parameterization_Ptri32, ptr %6, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %47 = load ptr, ptr %40, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i44 = call ptr %47({ ptr, ptr, ptr, i32 } %13, ptr nocapture nofree noundef nonnull readonly %7) #16
  %48 = call { ptr, i160 } %result.i44({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 dereferenceable(8) %6, i32 %.084) #7
  %.fca.0.extract23 = extractvalue { ptr, i160 } %48, 0
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %50 = load ptr, ptr %23, align 8
  %result.i45 = call ptr %50(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract11) #5
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  store ptr %result.i45, ptr %41, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %53 = load ptr, ptr %42, align 8
  store ptr @i32_typ, ptr %9, align 8
  store ptr %.fca.0.extract23, ptr %43, align 8
  %result.i46 = call ptr %53({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %9) #16
  call void %result.i46({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 dereferenceable(16) %8, i32 %44, { ptr, i160 } %48) #7
  %54 = add nuw nsw i32 %.084, 1
  %55 = icmp slt i32 %54, %20
  br i1 %55, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %4
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %57 = load ptr, ptr %24, align 8
  %58 = getelementptr i8, ptr %57, i64 8
  %59 = load ptr, ptr %58, align 8
  call void %59(ptr %.fca.1.extract11, i32 %28) #36
  %hash_coef.i.i51 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !947
  %tbl_size.i.i52 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !947
  %offset_tbl.i.i53 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !947
  %product.i.i.i54 = mul i64 %hash_coef.i.i51, -5261542750394134544
  %shifted.i.i.i55 = lshr i64 %product.i.i.i54, 32
  %xored.i.i.i56 = xor i64 %shifted.i.i.i55, %product.i.i.i54
  %hash.i.i.i57 = and i64 %xored.i.i.i56, %tbl_size.i.i52
  %offset_ptr.i.i58 = getelementptr i32, ptr %offset_tbl.i.i53, i64 %hash.i.i.i57
  %offset.i.i59 = load i32, ptr %offset_ptr.i.i58, align 4, !noalias !947
  %60 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i59, 3
  ret { ptr, ptr, ptr, i32 } %60
}

define void @Array_reserve_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #39
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract) #37
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %._crit_edge.thread

12:                                               ; preds = %4
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 %3) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #37
  %.fca.0.extract22 = extractvalue { ptr } %20, 0
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %22 = load ptr, ptr %8, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = tail call i32 %23(ptr %.fca.1.extract) #37
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %26 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %26(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %27 = load ptr, ptr %result.i, align 8
  %28 = getelementptr i8, ptr %27, i64 72
  %29 = load ptr, ptr %28, align 8
  %result.i25 = tail call { i64, i64 } %29(ptr nocapture nofree nonnull readonly %result.i) #5
  %30 = extractvalue { i64, i64 } %result.i25, 0
  %31 = sext i32 %24 to i64
  %32 = mul i64 %30, %31
  %result.i26 = tail call noalias ptr @bump_malloc_inner(i64 noundef %32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %33 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %34 = load ptr, ptr %17, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %result.i26, 0
  tail call void %36(ptr %.fca.1.extract, { ptr } %37) #36
  %38 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = tail call i32 %41(ptr %.fca.1.extract) #37
  %43 = icmp sgt i32 %42, 0
  br i1 %43, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %12
  %44 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %45 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.057 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %63, %._crit_edge ]
  %46 = load ptr, ptr %7, align 8
  %result.i27 = tail call align 8 ptr %46(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %47 = load ptr, ptr %result.i27, align 8
  %48 = getelementptr i8, ptr %47, i64 72
  %49 = load ptr, ptr %48, align 8
  %result.i28 = tail call { i64, i64 } %49(ptr nocapture nofree nonnull readonly %result.i27) #5
  %50 = extractvalue { i64, i64 } %result.i28, 0
  %51 = zext nneg i32 %.057 to i64
  %52 = mul i64 %50, %51
  %53 = getelementptr i8, ptr %.fca.0.extract22, i64 %52
  %54 = getelementptr i8, ptr %47, i64 56
  %55 = load ptr, ptr %54, align 8
  %result.i29 = tail call { ptr, i160 } %55(ptr nocapture nofree readonly %53, ptr nocapture nofree nonnull readonly %result.i27) #5
  %56 = load ptr, ptr %17, align 8
  %57 = load ptr, ptr %56, align 8
  %58 = tail call { ptr } %57(ptr nonnull %.fca.1.extract) #37
  %.fca.0.extract7 = extractvalue { ptr } %58, 0
  %59 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %60 = getelementptr i8, ptr %.fca.0.extract7, i64 %52
  %61 = getelementptr i8, ptr %47, i64 64
  %62 = load ptr, ptr %61, align 8
  tail call void %62({ ptr, i160 } %result.i29, ptr nocapture nofree nonnull readonly %result.i27, ptr nocapture nofree writeonly %60) #1
  %63 = add nuw nsw i32 %.057, 1
  %64 = load ptr, ptr %39, align 8
  %65 = load ptr, ptr %64, align 8
  %66 = tail call i32 %65(ptr %.fca.1.extract) #37
  %67 = icmp slt i32 %63, %66
  br i1 %67, label %._crit_edge, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %12, %4
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @Array__index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !950
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !950
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !950
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !950
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #37
  %16 = add i32 %15, -1
  %17 = icmp sgt i32 %3, %16
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %19 = tail call i32 %14(ptr %.fca.1.extract) #37
  %20 = add i32 %19, %3
  %21 = icmp slt i32 %20, 0
  %.0 = select i1 %17, i1 true, i1 %21
  br i1 %.0, label %22, label %._crit_edge

22:                                               ; preds = %4
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #41
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %29 = getelementptr i8, ptr %11, i64 128
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %3) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %22
  %31 = icmp slt i32 %3, 0
  br i1 %31, label %32, label %._crit_edge1

32:                                               ; preds = %._crit_edge
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %34 = load ptr, ptr %12, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %.fca.1.extract) #37
  %37 = add i32 %36, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %32
  %.027 = phi i32 [ %37, %32 ], [ %3, %._crit_edge ]
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %.fca.1.extract, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.2.extract, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %7, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7) #41
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %44 = getelementptr i8, ptr %11, i64 136
  %45 = load ptr, ptr %44, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i30 = call ptr %45({ ptr, ptr, ptr, i32 } %41, ptr nocapture nofree noundef nonnull readonly %8) #16
  %46 = call { ptr, i160 } %result.i30({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull align 8 dereferenceable(8) %7, i32 %.027) #7
  ret { ptr, i160 } %46
}

; Function Attrs: nounwind
define void @Array__set_index_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #7 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !953
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !953
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !953
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !953
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract16) #35
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract16, i64 %11
  %13 = getelementptr i8, ptr %12, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract17) #37
  %17 = add i32 %16, -1
  %18 = icmp sgt i32 %3, %17
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract16) #35
  %20 = tail call i32 %15(ptr %.fca.1.extract17) #37
  %21 = add i32 %20, %3
  %22 = icmp slt i32 %21, 0
  %.0 = select i1 %18, i1 true, i1 %22
  br i1 %.0, label %23, label %._crit_edge

23:                                               ; preds = %5
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract17, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %6, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #41
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #41
  %30 = getelementptr i8, ptr %12, i64 128
  %31 = load ptr, ptr %30, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i = call ptr %31({ ptr, ptr, ptr, i32 } %27, ptr nocapture nofree noundef nonnull readonly %7) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 dereferenceable(8) %6, i32 %3) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %5, %23
  %32 = icmp slt i32 %3, 0
  br i1 %32, label %33, label %._crit_edge1

33:                                               ; preds = %._crit_edge
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #41
  %35 = load ptr, ptr %13, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call i32 %36(ptr %.fca.1.extract17) #37
  %38 = add i32 %37, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %33
  %.027 = phi i32 [ %38, %33 ], [ %3, %._crit_edge ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract17, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %offset.i.i, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #41
  %44 = load ptr, ptr %12, align 8
  %result.i30 = call ptr %44(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract17) #5
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %45 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %result.i30, ptr %45, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8) #41
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #41
  %48 = getelementptr i8, ptr %12, i64 144
  %49 = load ptr, ptr %48, align 8
  store ptr @i32_typ, ptr %9, align 8
  %50 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.0.extract, ptr %50, align 8
  %result.i31 = call ptr %49({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly %9) #16
  call void %result.i31({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 dereferenceable(16) %8, i32 %.027, { ptr, i160 } %4) #7
  ret void
}

; Function Attrs: nounwind
define void @Array_throw_oob_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %result.i26 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %5 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %5, align 4
  %6 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %6, align 4
  %7 = getelementptr i8, ptr %result.i26, i64 40
  store ptr @String, ptr %7, align 8
  %8 = getelementptr i8, ptr %result.i26, i64 48
  store ptr %result.i29.i, ptr %8, align 8
  %9 = getelementptr i8, ptr %result.i26, i64 64
  store i32 10, ptr %9, align 4
  %10 = getelementptr i8, ptr %result.i26, i64 8
  %11 = getelementptr i8, ptr %result.i26, i64 16
  %12 = getelementptr i8, ptr %result.i26, i64 32
  %result.i28 = tail call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 97, i8 114, i8 114, i8 97, i8 121, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i28, align 16
  %result.i30 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i28, ptr %result.i30, align 8
  %13 = getelementptr i8, ptr %result.i30, i64 8
  store i32 10, ptr %13, align 4
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %15 = getelementptr i8, ptr %result.i30, i64 12
  store i32 11, ptr %15, align 4
  store i32 89, ptr %result.i26, align 4
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @Exception) #35
  store ptr @String, ptr %10, align 8
  store ptr %result.i30, ptr %11, align 8
  store i32 10, ptr %12, align 4
  %17 = ptrtoint ptr %result.i26 to i64
  %.sroa.4.8.insert.ext = zext i64 %17 to i160
  %.sroa.4.8.insert.insert = or disjoint i160 %.sroa.4.8.insert.ext, 3402823669209384634633746074317682114560
  %18 = insertvalue { ptr, i160 } { ptr @Exception, i160 undef }, i160 %.sroa.4.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %19 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %18, ptr %19, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Array_unchecked_index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !956
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !956
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !956
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !956
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract4) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr } %10(ptr %.fca.1.extract5) #37
  %.fca.0.extract1 = extractvalue { ptr } %11, 0
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract4) #41
  %13 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #5
  %14 = load ptr, ptr %result.i, align 8
  %15 = getelementptr i8, ptr %14, i64 72
  %16 = load ptr, ptr %15, align 8
  %result.i8 = tail call { i64, i64 } %16(ptr nocapture nofree nonnull readonly %result.i) #5
  %17 = extractvalue { i64, i64 } %result.i8, 0
  %18 = sext i32 %3 to i64
  %19 = mul i64 %17, %18
  %20 = getelementptr i8, ptr %.fca.0.extract1, i64 %19
  %21 = getelementptr i8, ptr %14, i64 56
  %22 = load ptr, ptr %21, align 8
  %result.i9 = tail call { ptr, i160 } %22(ptr nocapture nofree readonly %20, ptr nocapture nofree nonnull readonly %result.i) #5
  ret { ptr, i160 } %result.i9
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_unchecked_insert_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !959
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !959
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !959
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !959
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract6) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract6, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr } %11(ptr %.fca.1.extract7) #37
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract6) #41
  %14 = load ptr, ptr %8, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %14(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract7) #5
  %15 = load ptr, ptr %result.i, align 8
  %16 = getelementptr i8, ptr %15, i64 72
  %17 = load ptr, ptr %16, align 8
  %result.i10 = tail call { i64, i64 } %17(ptr nocapture nofree nonnull readonly %result.i) #5
  %18 = extractvalue { i64, i64 } %result.i10, 0
  %19 = sext i32 %3 to i64
  %20 = mul i64 %18, %19
  %21 = getelementptr i8, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %15, i64 64
  %23 = load ptr, ptr %22, align 8
  tail call void %23({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %21) #1
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !962
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !962
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !962
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !962
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i8 = tail call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i8, align 8
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i8) #35
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i21 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !22
  %9 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr undef, 2
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %12 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %.fca.0.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %.fca.1.extract, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.2.extract, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store i32 %offset.i.i21, ptr %15, align 8
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @ArrayIterator) #35
  %17 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #13 {
  %result.i = tail call noalias align 8 dereferenceable_or_null(6) ptr @bump_malloc_inner(i64 noundef 6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <5 x i8> <i8 65, i8 114, i8 114, i8 97, i8 121>, ptr %result.i, align 8
  %result.i15 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i15, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i, ptr %result.i15, align 8
  %7 = getelementptr i8, ptr %result.i15, i64 8
  store i32 5, ptr %7, align 4
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %9 = getelementptr i8, ptr %result.i15, i64 12
  store i32 6, ptr %9, align 4
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ArrayIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !965
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !965
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !965
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !965
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !968
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i35, 3
  tail call void %11(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %15) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract2, i32 0) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !971
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !971
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !971
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !971
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract10) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract10, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract12) #37
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract10) #35
  %15 = getelementptr i8, ptr %9, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract12) #37
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #35
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract) #35
  %25 = sext i32 %.fca.3.extract to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 72
  %28 = load ptr, ptr %27, align 8
  %result.i = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly %4) #16
  %29 = call i32 %result.i({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4) #7
  %.not = icmp slt i32 %13, %29
  br i1 %.not, label %30, label %59

30:                                               ; preds = %3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %32 = load ptr, ptr %10, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract12) #37
  %35 = add i32 %34, 1
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %37 = getelementptr i8, ptr %32, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %.fca.1.extract12, i32 %35) #36
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %40 = load ptr, ptr %10, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr %.fca.1.extract12) #37
  %43 = add i32 %42, -1
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %45 = load ptr, ptr %15, align 8
  %46 = load ptr, ptr %45, align 8
  %47 = call { ptr, ptr, ptr, i32 } %46(ptr %.fca.1.extract12) #37
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %47, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %47, 1
  %.fca.2.extract30 = extractvalue { ptr, ptr, ptr, i32 } %47, 2
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %47, 3
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.1.extract28, 1
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.2.extract30, 2
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %.fca.3.extract32, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 664, ptr nocapture nofree noundef %.fca.0.extract26)
  %54 = sext i32 %.fca.3.extract32 to i64
  %55 = getelementptr ptr, ptr %.fca.0.extract26, i64 %54
  %56 = getelementptr i8, ptr %55, i64 136
  %57 = load ptr, ptr %56, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i42 = call ptr %57({ ptr, ptr, ptr, i32 } %51, ptr nocapture nofree noundef nonnull readonly %6) #16
  %58 = call { ptr, i160 } %result.i42({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull align 8 dereferenceable(8) %5, i32 %43) #7
  %.fca.0.extract20 = extractvalue { ptr, i160 } %58, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %58, 1
  br label %59

59:                                               ; preds = %3, %30
  %.reg2mem21.sroa.0.0 = phi ptr [ %.fca.0.extract20, %30 ], [ @nil_typ, %3 ]
  %.reg2mem21.sroa.3.0 = phi i160 [ %.fca.1.extract22, %30 ], [ undef, %3 ]
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem21.sroa.0.0, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %.reg2mem21.sroa.3.0, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FileSystemError(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileSystemError_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileSystemError_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileSystemError_B_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileSystemError_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileSystemError_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FileSystemError_getter_message(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FileSystemError_setter_message(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FileSystemError_getter_file_name(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FileSystemError_setter_file_name(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @FileSystemError_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FileSystemError_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_File(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @File_B_init_nameString_modeString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @File_B__set_mode_modeString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @File_B_reopen_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @File_B_close_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @File_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @File_B_read_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @File_B_read_byte_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @File_B_write_textString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

define void @File_init_nameString_modeString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract39 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract39, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract39, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract39, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !974
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !974
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !974
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !974
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i52 = getelementptr i8, ptr %.fca.0.extract27, i64 8
  %tbl_size_ptr.i.i53 = getelementptr i8, ptr %.fca.0.extract27, i64 16
  %offset_tbl_ptr.i.i54 = getelementptr i8, ptr %.fca.0.extract27, i64 40
  %hash_coef.i.i55 = load i64, ptr %hash_coef_ptr.i.i52, align 4, !noalias !22
  %tbl_size.i.i56 = load i64, ptr %tbl_size_ptr.i.i53, align 4, !noalias !22
  %offset_tbl.i.i57 = load ptr, ptr %offset_tbl_ptr.i.i54, align 8, !noalias !22
  %product.i.i.i58 = mul i64 %hash_coef.i.i55, 6499063144389013426
  %shifted.i.i.i59 = lshr i64 %product.i.i.i58, 32
  %xored.i.i.i60 = xor i64 %shifted.i.i.i59, %product.i.i.i58
  %hash.i.i.i61 = and i64 %xored.i.i.i60, %tbl_size.i.i56
  %offset_ptr.i.i62 = getelementptr i32, ptr %offset_tbl.i.i57, i64 %hash.i.i.i61
  %offset.i.i77 = load i32, ptr %offset_ptr.i.i62, align 4, !noalias !977
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract39) #35
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract39, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract29, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract31, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i77, 3
  tail call void %12(ptr %.fca.1.extract41, { ptr, ptr, ptr, i32 } %16) #36
  %.fca.0.extract19 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract21 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i80 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %tbl_size_ptr.i.i81 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %offset_tbl_ptr.i.i82 = getelementptr i8, ptr %.fca.0.extract19, i64 40
  %hash_coef.i.i83 = load i64, ptr %hash_coef_ptr.i.i80, align 4, !noalias !22
  %tbl_size.i.i84 = load i64, ptr %tbl_size_ptr.i.i81, align 4, !noalias !22
  %offset_tbl.i.i85 = load ptr, ptr %offset_tbl_ptr.i.i82, align 8, !noalias !22
  %product.i.i.i86 = mul i64 %hash_coef.i.i83, 6499063144389013426
  %shifted.i.i.i87 = lshr i64 %product.i.i.i86, 32
  %xored.i.i.i88 = xor i64 %shifted.i.i.i87, %product.i.i.i86
  %hash.i.i.i89 = and i64 %xored.i.i.i88, %tbl_size.i.i84
  %offset_ptr.i.i90 = getelementptr i32, ptr %offset_tbl.i.i85, i64 %hash.i.i.i89
  %offset.i.i105 = load i32, ptr %offset_ptr.i.i90, align 4, !noalias !980
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract39) #35
  %18 = getelementptr i8, ptr %9, i64 8
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract19, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract21, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract23, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i105, 3
  tail call void %21(ptr %.fca.1.extract41, { ptr, ptr, ptr, i32 } %25) #36
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract39) #35
  %27 = getelementptr i8, ptr %9, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract41, i1 false) #36
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract39) #35
  %32 = load ptr, ptr %9, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract41) #37
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.3.extract16 = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract12, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract14, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %.fca.3.extract16, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #35
  %40 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract10) #35
  %41 = sext i32 %.fca.3.extract16 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract10, i64 %41
  %43 = getelementptr i8, ptr %42, i64 80
  %44 = load ptr, ptr %43, align 8
  %result.i = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly %6) #16
  %45 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %6) #7
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract39)
  %47 = load ptr, ptr %18, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr, ptr, ptr, i32 } %48(ptr %.fca.1.extract41) #37
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 3
  %50 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract6, 0
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %.fca.1.extract, 1
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %.fca.2.extract, 2
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %.fca.3.extract, 3
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract6)
  %56 = sext i32 %.fca.3.extract to i64
  %57 = getelementptr ptr, ptr %.fca.0.extract6, i64 %56
  %58 = getelementptr i8, ptr %57, i64 80
  %59 = load ptr, ptr %58, align 8
  %result.i107 = call ptr %59({ ptr, ptr, ptr, i32 } %53, ptr nocapture nofree noundef nonnull readonly %6) #16
  %60 = call { ptr } %result.i107({ ptr, ptr, ptr, i32 } %53, { ptr, ptr, ptr, i32 } %53, ptr nonnull align 8 %6) #7
  %61 = call { ptr } @fopen({ ptr } %45, { ptr } %60)
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract39)
  %63 = getelementptr i8, ptr %9, i64 16
  %64 = load ptr, ptr %63, align 8
  %65 = getelementptr i8, ptr %64, i64 8
  %66 = load ptr, ptr %65, align 8
  call void %66(ptr %.fca.1.extract41, { ptr } %61) #36
  %67 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract39)
  %68 = load ptr, ptr %63, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = call { ptr } %69(ptr %.fca.1.extract41) #37
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract39)
  %72 = load ptr, ptr %27, align 8
  %73 = getelementptr i8, ptr %72, i64 8
  %74 = load ptr, ptr %73, align 8
  call void %74(ptr %.fca.1.extract41, i1 true) #36
  ret void
}

; Function Attrs: nounwind
define void @File__set_mode_modeString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !983
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !983
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !983
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !983
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i14 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i15 = load i64, ptr %hash_coef_ptr.i.i12, align 4, !noalias !22
  %tbl_size.i.i16 = load i64, ptr %tbl_size_ptr.i.i13, align 4, !noalias !22
  %offset_tbl.i.i17 = load ptr, ptr %offset_tbl_ptr.i.i14, align 8, !noalias !22
  %product.i.i.i18 = mul i64 %hash_coef.i.i15, 6499063144389013426
  %shifted.i.i.i19 = lshr i64 %product.i.i.i18, 32
  %xored.i.i.i20 = xor i64 %shifted.i.i.i19, %product.i.i.i18
  %hash.i.i.i21 = and i64 %xored.i.i.i20, %tbl_size.i.i16
  %offset_ptr.i.i22 = getelementptr i32, ptr %offset_tbl.i.i17, i64 %hash.i.i.i21
  %offset.i.i37 = load i32, ptr %offset_ptr.i.i22, align 4, !noalias !986
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract3, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i37, 3
  tail call void %12(ptr %.fca.1.extract4, { ptr, ptr, ptr, i32 } %16) #36
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call i1 %20(ptr %.fca.1.extract4) #37
  br i1 %21, label %22, label %31

22:                                               ; preds = %4
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract4, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract5, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #41
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract3) #41
  %29 = getelementptr i8, ptr %8, i64 48
  %30 = load ptr, ptr %29, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %5) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %5) #7
  br label %31

31:                                               ; preds = %4, %22
  ret void
}

define void @File_reopen_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract20 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract18, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract18, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract18, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !989
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !989
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !989
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !989
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract18, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.1.extract20, 1
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.2.extract22, 2
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, i32 %offset.i.i, 3
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #35
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract18) #35
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract18, i64 %11
  %13 = getelementptr i8, ptr %12, i64 56
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %8, ptr nocapture nofree noundef nonnull readonly %4) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %8, { ptr, ptr, ptr, i32 } %8, ptr nonnull align 8 %4) #7
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract18)
  %16 = load ptr, ptr %12, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract20) #37
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract16 = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract12, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract14, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract16, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract10)
  %25 = sext i32 %.fca.3.extract16 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract10, i64 %25
  %27 = getelementptr i8, ptr %26, i64 80
  %28 = load ptr, ptr %27, align 8
  %result.i26 = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly %4) #16
  %29 = call { ptr } %result.i26({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4) #7
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract18)
  %31 = getelementptr i8, ptr %12, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract20) #37
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract6, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %.fca.3.extract, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract6)
  %41 = sext i32 %.fca.3.extract to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract6, i64 %41
  %43 = getelementptr i8, ptr %42, i64 80
  %44 = load ptr, ptr %43, align 8
  %result.i27 = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly %4) #16
  %45 = call { ptr } %result.i27({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4) #7
  %46 = call { ptr } @fopen({ ptr } %29, { ptr } %45)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract18)
  %48 = getelementptr i8, ptr %12, i64 16
  %49 = load ptr, ptr %48, align 8
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  call void %51(ptr %.fca.1.extract20, { ptr } %46) #36
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract18)
  %53 = load ptr, ptr %48, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call { ptr } %54(ptr %.fca.1.extract20) #37
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract18)
  %57 = getelementptr i8, ptr %12, i64 24
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr i8, ptr %58, i64 8
  %60 = load ptr, ptr %59, align 8
  call void %60(ptr %.fca.1.extract20, i1 true) #36
  ret void
}

define void @File_close_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !992
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !992
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !992
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !992
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i1 %9(ptr %.fca.1.extract) #37
  br i1 %10, label %11, label %._crit_edge

11:                                               ; preds = %3
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %13 = getelementptr i8, ptr %6, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call { ptr } %15(ptr %.fca.1.extract) #37
  %17 = tail call i32 @fclose({ ptr } %16)
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %19 = load ptr, ptr %7, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract, i1 false) #36
  %22 = icmp eq i32 %17, -1
  br i1 %22, label %23, label %._crit_edge

23:                                               ; preds = %11
  %result.i35 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %24 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %24, align 4
  %25 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %25, align 4
  %26 = getelementptr i8, ptr %result.i35, i64 40
  store ptr @String, ptr %26, align 8
  %27 = getelementptr i8, ptr %result.i35, i64 48
  store ptr %result.i29.i, ptr %27, align 8
  %28 = getelementptr i8, ptr %result.i35, i64 64
  store i32 10, ptr %28, align 4
  %29 = getelementptr i8, ptr %result.i35, i64 8
  %30 = getelementptr i8, ptr %result.i35, i64 16
  %31 = getelementptr i8, ptr %result.i35, i64 32
  %result.i37 = tail call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i37, align 16
  %result.i39 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i37, ptr %result.i39, align 8
  %32 = getelementptr i8, ptr %result.i39, i64 8
  store i32 10, ptr %32, align 4
  %33 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %34 = getelementptr i8, ptr %result.i39, i64 12
  store i32 11, ptr %34, align 4
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError)
  store i32 47, ptr %result.i35, align 4
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %29, align 8
  store ptr %result.i39, ptr %30, align 8
  store i32 10, ptr %31, align 4
  %37 = ptrtoint ptr %result.i35 to i64
  %.sroa.424.8.insert.ext = zext i64 %37 to i160
  %.sroa.424.8.insert.insert = or disjoint i160 %.sroa.424.8.insert.ext, 3402823669209384634633746074317682114560
  %38 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.424.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %39 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %38, ptr %39, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge

._crit_edge:                                      ; preds = %23, %11, %3
  ret void
}

define i64 @File_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !995
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !995
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !995
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !995
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i1 %9(ptr %.fca.1.extract) #37
  br i1 %10, label %._crit_edge, label %11

11:                                               ; preds = %3
  %result.i42 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %12 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %12, align 4
  %13 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %13, align 4
  %14 = getelementptr i8, ptr %result.i42, i64 40
  store ptr @String, ptr %14, align 8
  %15 = getelementptr i8, ptr %result.i42, i64 48
  store ptr %result.i29.i, ptr %15, align 8
  %16 = getelementptr i8, ptr %result.i42, i64 64
  store i32 10, ptr %16, align 4
  %17 = getelementptr i8, ptr %result.i42, i64 8
  %18 = getelementptr i8, ptr %result.i42, i64 16
  %19 = getelementptr i8, ptr %result.i42, i64 32
  %result.i44 = tail call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i44, align 16
  %result.i46 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i44, ptr %result.i46, align 8
  %20 = getelementptr i8, ptr %result.i46, i64 8
  store i32 10, ptr %20, align 4
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %22 = getelementptr i8, ptr %result.i46, i64 12
  store i32 11, ptr %22, align 4
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError) #41
  store i32 50, ptr %result.i42, align 4
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %17, align 8
  store ptr %result.i46, ptr %18, align 8
  store i32 10, ptr %19, align 4
  %25 = ptrtoint ptr %result.i42 to i64
  %.sroa.437.8.insert.ext = zext i64 %25 to i160
  %.sroa.437.8.insert.insert = or disjoint i160 %.sroa.437.8.insert.ext, 3402823669209384634633746074317682114560
  %26 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.437.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %27 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %26, ptr %27, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge

._crit_edge:                                      ; preds = %3, %11
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %29 = getelementptr i8, ptr %6, i64 16
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = tail call { ptr } %31(ptr %.fca.1.extract) #37
  %33 = tail call i64 @ftell({ ptr } %32)
  %34 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %35 = load ptr, ptr %29, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = tail call { ptr } %36(ptr %.fca.1.extract) #37
  %38 = tail call i32 @fseek({ ptr } %37, i64 noundef 0, i32 noundef 2)
  %39 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %40 = load ptr, ptr %29, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = tail call { ptr } %41(ptr %.fca.1.extract) #37
  %43 = tail call i64 @ftell({ ptr } %42)
  %44 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %45 = load ptr, ptr %29, align 8
  %46 = load ptr, ptr %45, align 8
  %47 = tail call { ptr } %46(ptr %.fca.1.extract) #37
  %48 = tail call i32 @fseek({ ptr } %47, i64 %33, i32 noundef 0)
  ret i64 %43
}

define { ptr, ptr, ptr, i32 } @File_read_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !998
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !998
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !998
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !998
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract) #37
  br i1 %11, label %._crit_edge, label %12

12:                                               ; preds = %3
  %result.i89 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %4) #35
  %result.i.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %15 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %15, align 4
  %16 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %16, align 4
  %17 = getelementptr i8, ptr %result.i89, i64 40
  store ptr @String, ptr %17, align 8
  %18 = getelementptr i8, ptr %result.i89, i64 48
  store ptr %result.i29.i, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i89, i64 64
  store i32 10, ptr %19, align 4
  %20 = getelementptr i8, ptr %result.i89, i64 8
  %21 = getelementptr i8, ptr %result.i89, i64 16
  %22 = getelementptr i8, ptr %result.i89, i64 32
  %result.i91 = tail call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i91, align 16
  %result.i93 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i91, ptr %result.i93, align 8
  %23 = getelementptr i8, ptr %result.i93, i64 8
  store i32 10, ptr %23, align 4
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %25 = getelementptr i8, ptr %result.i93, i64 12
  store i32 11, ptr %25, align 4
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError) #41
  store i32 60, ptr %result.i89, align 4
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %20, align 8
  store ptr %result.i93, ptr %21, align 8
  store i32 10, ptr %22, align 4
  %28 = ptrtoint ptr %result.i89 to i64
  %.sroa.482.8.insert.ext = zext i64 %28 to i160
  %.sroa.482.8.insert.insert = or disjoint i160 %.sroa.482.8.insert.ext, 3402823669209384634633746074317682114560
  %29 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.482.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %30 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %29, ptr %30, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge

._crit_edge:                                      ; preds = %3, %12
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %32 = getelementptr i8, ptr %7, i64 16
  %33 = load ptr, ptr %32, align 8
  %34 = load ptr, ptr %33, align 8
  %35 = tail call { ptr } %34(ptr %.fca.1.extract) #37
  %36 = tail call i32 @fseek({ ptr } %35, i64 noundef 0, i32 noundef 0)
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.1.extract, 1
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %.fca.2.extract, 2
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %offset.i.i, 3
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #41
  %42 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %43 = getelementptr i8, ptr %7, i64 64
  %44 = load ptr, ptr %43, align 8
  %result.i110 = call ptr %44({ ptr, ptr, ptr, i32 } %40, ptr nocapture nofree noundef nonnull readonly %4) #16
  %45 = call i64 %result.i110({ ptr, ptr, ptr, i32 } %40, { ptr, ptr, ptr, i32 } %40, ptr nonnull align 8 %4) #7
  %46 = trunc i64 %45 to i32
  %47 = add i32 %46, 1
  %48 = sext i32 %47 to i64
  %result.i111 = call noalias ptr @bump_malloc_inner(i64 noundef %48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %50 = load ptr, ptr %32, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = call { ptr } %51(ptr %.fca.1.extract) #37
  %53 = insertvalue { ptr } undef, ptr %result.i111, 0
  %54 = call i64 @fread({ ptr } %53, i64 noundef 1, i64 %45, { ptr } %52)
  %55 = icmp slt i64 %54, %45
  br i1 %55, label %56, label %._crit_edge1

56:                                               ; preds = %._crit_edge
  %result.i113 = call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %4) #35
  %result.i.i212 = call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i212, align 8
  %result.i29.i213 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i212, ptr %result.i29.i213, align 8
  %59 = getelementptr i8, ptr %result.i29.i213, i64 8
  store i32 6, ptr %59, align 4
  %60 = getelementptr i8, ptr %result.i29.i213, i64 12
  store i32 7, ptr %60, align 4
  %61 = getelementptr i8, ptr %result.i113, i64 40
  store ptr @String, ptr %61, align 8
  %62 = getelementptr i8, ptr %result.i113, i64 48
  store ptr %result.i29.i213, ptr %62, align 8
  %63 = getelementptr i8, ptr %result.i113, i64 64
  store i32 10, ptr %63, align 4
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %65 = getelementptr i8, ptr %result.i113, i64 8
  %66 = getelementptr i8, ptr %result.i113, i64 16
  %67 = getelementptr i8, ptr %result.i113, i64 32
  %result.i115 = call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i115, align 16
  %result.i117 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i115, ptr %result.i117, align 8
  %68 = getelementptr i8, ptr %result.i117, i64 8
  store i32 10, ptr %68, align 4
  %69 = getelementptr i8, ptr %result.i117, i64 12
  store i32 11, ptr %69, align 4
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError)
  store i32 68, ptr %result.i113, align 4
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %65, align 8
  store ptr %result.i117, ptr %66, align 8
  store i32 10, ptr %67, align 4
  %72 = ptrtoint ptr %result.i113 to i64
  %.sroa.433.8.insert.ext = zext i64 %72 to i160
  %.sroa.433.8.insert.insert = or disjoint i160 %.sroa.433.8.insert.ext, 3402823669209384634633746074317682114560
  %73 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.433.8.insert.insert, 1
  %current_coroutine.i134 = load ptr, ptr @current_coroutine, align 8
  %74 = getelementptr i8, ptr %current_coroutine.i134, i64 48
  store { ptr, i160 } %73, ptr %74, align 8
  %into_callee_buf.i135 = getelementptr i8, ptr %current_coroutine.i134, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i135, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %56
  %result.i137 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %75 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i137, 1
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr undef, 2
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 10, 3
  store ptr %result.i111, ptr %result.i137, align 8
  %78 = getelementptr i8, ptr %result.i137, i64 8
  store i32 %46, ptr %78, align 4
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %80 = getelementptr i8, ptr %result.i137, i64 12
  store i32 %47, ptr %80, align 4
  ret { ptr, ptr, ptr, i32 } %77
}

define { ptr, i8 } @File_read_byte_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1001
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1001
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1001
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1001
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract5) #35
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract5, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i1 %9(ptr %.fca.1.extract6) #37
  br i1 %10, label %._crit_edge, label %11

11:                                               ; preds = %3
  %result.i79 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %12 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %12, align 4
  %13 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %13, align 4
  %14 = getelementptr i8, ptr %result.i79, i64 40
  store ptr @String, ptr %14, align 8
  %15 = getelementptr i8, ptr %result.i79, i64 48
  store ptr %result.i29.i, ptr %15, align 8
  %16 = getelementptr i8, ptr %result.i79, i64 64
  store i32 10, ptr %16, align 4
  %17 = getelementptr i8, ptr %result.i79, i64 8
  %18 = getelementptr i8, ptr %result.i79, i64 16
  %19 = getelementptr i8, ptr %result.i79, i64 32
  %result.i81 = tail call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i81, align 16
  %result.i83 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i81, ptr %result.i83, align 8
  %20 = getelementptr i8, ptr %result.i83, i64 8
  store i32 10, ptr %20, align 4
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %22 = getelementptr i8, ptr %result.i83, i64 12
  store i32 11, ptr %22, align 4
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError) #41
  store i32 72, ptr %result.i79, align 4
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %17, align 8
  store ptr %result.i83, ptr %18, align 8
  store i32 10, ptr %19, align 4
  %25 = ptrtoint ptr %result.i79 to i64
  %.sroa.472.8.insert.ext = zext i64 %25 to i160
  %.sroa.472.8.insert.insert = or disjoint i160 %.sroa.472.8.insert.ext, 3402823669209384634633746074317682114560
  %26 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.472.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %27 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %26, ptr %27, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge

._crit_edge:                                      ; preds = %3, %11
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract5) #41
  %29 = getelementptr i8, ptr %6, i64 16
  %30 = load ptr, ptr %29, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = tail call { ptr } %31(ptr %.fca.1.extract6) #37
  %33 = tail call i32 @fgetc({ ptr } %32)
  %34 = icmp eq i32 %33, -1
  br i1 %34, label %35, label %58

35:                                               ; preds = %._crit_edge
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %37 = load ptr, ptr %29, align 8
  %38 = load ptr, ptr %37, align 8
  %39 = tail call { ptr } %38(ptr %.fca.1.extract6) #37
  %40 = tail call i32 @ferror({ ptr } %39)
  %.not = icmp eq i32 %40, 0
  br i1 %.not, label %._crit_edge1, label %41

41:                                               ; preds = %35
  %result.i101 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i178 = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i178, align 8
  %result.i29.i179 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i178, ptr %result.i29.i179, align 8
  %42 = getelementptr i8, ptr %result.i29.i179, i64 8
  store i32 6, ptr %42, align 4
  %43 = getelementptr i8, ptr %result.i29.i179, i64 12
  store i32 7, ptr %43, align 4
  %44 = getelementptr i8, ptr %result.i101, i64 40
  store ptr @String, ptr %44, align 8
  %45 = getelementptr i8, ptr %result.i101, i64 48
  store ptr %result.i29.i179, ptr %45, align 8
  %46 = getelementptr i8, ptr %result.i101, i64 64
  store i32 10, ptr %46, align 4
  %47 = getelementptr i8, ptr %result.i101, i64 8
  %48 = getelementptr i8, ptr %result.i101, i64 16
  %49 = getelementptr i8, ptr %result.i101, i64 32
  %result.i103 = tail call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i103, align 16
  %result.i105 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i103, ptr %result.i105, align 8
  %50 = getelementptr i8, ptr %result.i105, i64 8
  store i32 10, ptr %50, align 4
  %51 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %52 = getelementptr i8, ptr %result.i105, i64 12
  store i32 11, ptr %52, align 4
  %53 = tail call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError)
  store i32 75, ptr %result.i101, align 4
  %54 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %47, align 8
  store ptr %result.i105, ptr %48, align 8
  store i32 10, ptr %49, align 4
  %55 = ptrtoint ptr %result.i101 to i64
  %.sroa.433.8.insert.ext = zext i64 %55 to i160
  %.sroa.433.8.insert.insert = or disjoint i160 %.sroa.433.8.insert.ext, 3402823669209384634633746074317682114560
  %56 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.433.8.insert.insert, 1
  %current_coroutine.i122 = load ptr, ptr @current_coroutine, align 8
  %57 = getelementptr i8, ptr %current_coroutine.i122, i64 48
  store { ptr, i160 } %56, ptr %57, align 8
  %into_callee_buf.i123 = getelementptr i8, ptr %current_coroutine.i122, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i123, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge1

58:                                               ; preds = %._crit_edge
  %59 = trunc i32 %33 to i8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %41, %35, %58
  %.reg2mem16.sroa.0.0 = phi ptr [ @i8_typ, %58 ], [ @nil_typ, %35 ], [ @nil_typ, %41 ]
  %.reg2mem16.sroa.3.0 = phi i8 [ %59, %58 ], [ undef, %35 ], [ undef, %41 ]
  %.reload17.fca.0.insert = insertvalue { ptr, i8 } poison, ptr %.reg2mem16.sroa.0.0, 0
  %.reload17.fca.1.insert = insertvalue { ptr, i8 } %.reload17.fca.0.insert, i8 %.reg2mem16.sroa.3.0, 1
  ret { ptr, i8 } %.reload17.fca.1.insert
}

define i64 @File_write_textString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1004
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1004
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1004
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1004
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i79 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i80 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i81 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i82 = load i64, ptr %hash_coef_ptr.i.i79, align 4, !noalias !1007
  %tbl_size.i.i83 = load i64, ptr %tbl_size_ptr.i.i80, align 4, !noalias !1007
  %offset_tbl.i.i84 = load ptr, ptr %offset_tbl_ptr.i.i81, align 8, !noalias !1007
  %product.i.i.i85 = mul i64 %hash_coef.i.i82, 6499063144389013426
  %shifted.i.i.i86 = lshr i64 %product.i.i.i85, 32
  %xored.i.i.i87 = xor i64 %shifted.i.i.i86, %product.i.i.i85
  %hash.i.i.i88 = and i64 %xored.i.i.i87, %tbl_size.i.i83
  %offset_ptr.i.i89 = getelementptr i32, ptr %offset_tbl.i.i84, i64 %hash.i.i.i88
  %offset.i.i90 = load i32, ptr %offset_ptr.i.i89, align 4, !noalias !1007
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract3, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call i1 %11(ptr %.fca.1.extract4) #37
  br i1 %12, label %._crit_edge, label %13

13:                                               ; preds = %4
  %result.i92 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #41
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %5) #35
  %result.i.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %16 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %16, align 4
  %17 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %17, align 4
  %18 = getelementptr i8, ptr %result.i92, i64 40
  store ptr @String, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i92, i64 48
  store ptr %result.i29.i, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i92, i64 64
  store i32 10, ptr %20, align 4
  %21 = getelementptr i8, ptr %result.i92, i64 8
  %22 = getelementptr i8, ptr %result.i92, i64 16
  %23 = getelementptr i8, ptr %result.i92, i64 32
  %result.i94 = tail call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i94, align 16
  %result.i96 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i94, ptr %result.i96, align 8
  %24 = getelementptr i8, ptr %result.i96, i64 8
  store i32 10, ptr %24, align 4
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %26 = getelementptr i8, ptr %result.i96, i64 12
  store i32 11, ptr %26, align 4
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError) #41
  store i32 81, ptr %result.i92, align 4
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %21, align 8
  store ptr %result.i96, ptr %22, align 8
  store i32 10, ptr %23, align 4
  %29 = ptrtoint ptr %result.i92 to i64
  %.sroa.471.8.insert.ext = zext i64 %29 to i160
  %.sroa.471.8.insert.insert = or disjoint i160 %.sroa.471.8.insert.ext, 3402823669209384634633746074317682114560
  %30 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.471.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %31 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %30, ptr %31, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %13
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.1.extract, 1
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %.fca.2.extract, 2
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %offset.i.i90, 3
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #41
  %37 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %38 = sext i32 %offset.i.i90 to i64
  %39 = getelementptr ptr, ptr %.fca.0.extract, i64 %38
  %40 = getelementptr i8, ptr %39, i64 56
  %41 = load ptr, ptr %40, align 8
  %result.i113 = call ptr %41({ ptr, ptr, ptr, i32 } %35, ptr nocapture nofree noundef nonnull readonly %5) #16
  %42 = call i32 %result.i113({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull align 8 %5) #7
  %43 = sext i32 %42 to i64
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #41
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull %.fca.0.extract) #41
  %46 = getelementptr i8, ptr %39, i64 80
  %47 = load ptr, ptr %46, align 8
  %result.i114 = call ptr %47({ ptr, ptr, ptr, i32 } %35, ptr nocapture nofree noundef nonnull readonly %5) #16
  %48 = call { ptr } %result.i114({ ptr, ptr, ptr, i32 } %35, { ptr, ptr, ptr, i32 } %35, ptr nonnull align 8 %5) #7
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull %.fca.0.extract3) #41
  %50 = getelementptr i8, ptr %8, i64 16
  %51 = load ptr, ptr %50, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr %.fca.1.extract4) #37
  %54 = call i64 @fwrite({ ptr } %48, i64 noundef 1, i64 %43, { ptr } %53)
  %55 = icmp slt i64 %54, %43
  br i1 %55, label %56, label %._crit_edge1

56:                                               ; preds = %._crit_edge
  %result.i116 = call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %5) #35
  %result.i.i194 = call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i194, align 8
  %result.i29.i195 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i194, ptr %result.i29.i195, align 8
  %59 = getelementptr i8, ptr %result.i29.i195, i64 8
  store i32 6, ptr %59, align 4
  %60 = getelementptr i8, ptr %result.i29.i195, i64 12
  store i32 7, ptr %60, align 4
  %61 = getelementptr i8, ptr %result.i116, i64 40
  store ptr @String, ptr %61, align 8
  %62 = getelementptr i8, ptr %result.i116, i64 48
  store ptr %result.i29.i195, ptr %62, align 8
  %63 = getelementptr i8, ptr %result.i116, i64 64
  store i32 10, ptr %63, align 4
  %64 = getelementptr i8, ptr %result.i116, i64 8
  %65 = getelementptr i8, ptr %result.i116, i64 16
  %66 = getelementptr i8, ptr %result.i116, i64 32
  %result.i118 = call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i118, align 16
  %result.i120 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i118, ptr %result.i120, align 8
  %67 = getelementptr i8, ptr %result.i120, i64 8
  store i32 10, ptr %67, align 4
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %69 = getelementptr i8, ptr %result.i120, i64 12
  store i32 11, ptr %69, align 4
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError)
  store i32 85, ptr %result.i116, align 4
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %64, align 8
  store ptr %result.i120, ptr %65, align 8
  store i32 10, ptr %66, align 4
  %72 = ptrtoint ptr %result.i116 to i64
  %.sroa.432.8.insert.ext = zext i64 %72 to i160
  %.sroa.432.8.insert.insert = or disjoint i160 %.sroa.432.8.insert.ext, 3402823669209384634633746074317682114560
  %73 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.432.8.insert.insert, 1
  %current_coroutine.i137 = load ptr, ptr @current_coroutine, align 8
  %74 = getelementptr i8, ptr %current_coroutine.i137, i64 48
  store { ptr, i160 } %73, ptr %74, align 8
  %into_callee_buf.i138 = getelementptr i8, ptr %current_coroutine.i137, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i138, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %56
  ret i64 %54
}

declare i64 @fwrite({ ptr }, i64, i64, { ptr }) local_unnamed_addr

declare i32 @fgetc({ ptr }) local_unnamed_addr

declare i32 @ferror({ ptr }) local_unnamed_addr

declare i32 @fseek({ ptr }, i64, i32) local_unnamed_addr

declare i64 @fread({ ptr }, i64, i64, { ptr }) local_unnamed_addr

declare i64 @ftell({ ptr }) local_unnamed_addr

declare i32 @fclose({ ptr }) local_unnamed_addr

declare { ptr } @fopen({ ptr }, { ptr }) local_unnamed_addr

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @File_getter_open(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @File_setter_open(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @File_getter_handle(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 64
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @File_setter_handle(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 64
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @File_getter_mode(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 40
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 56
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @File_setter_mode(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 56
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @File_getter_name(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @File_setter_name(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FileProcessor(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FileReader(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @FileReader_field_FileReader_0(ptr nocapture nofree readnone %0) #0 {
  ret ptr @_parameterization_String
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileReader_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileReader_B_process_fileFile({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @FileReader_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #0 {
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @FileReader_process_fileFile({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i21 = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i22 = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i23 = load i64, ptr %hash_coef_ptr.i.i20, align 4, !noalias !1010
  %tbl_size.i.i24 = load i64, ptr %tbl_size_ptr.i.i21, align 4, !noalias !1010
  %offset_tbl.i.i25 = load ptr, ptr %offset_tbl_ptr.i.i22, align 8, !noalias !1010
  %product.i.i.i26 = mul i64 %hash_coef.i.i23, -2227788838181535664
  %shifted.i.i.i27 = lshr i64 %product.i.i.i26, 32
  %xored.i.i.i28 = xor i64 %shifted.i.i.i27, %product.i.i.i26
  %hash.i.i.i29 = and i64 %xored.i.i.i28, %tbl_size.i.i24
  %offset_ptr.i.i30 = getelementptr i32, ptr %offset_tbl.i.i25, i64 %hash.i.i.i29
  %offset.i.i31 = load i32, ptr %offset_ptr.i.i30, align 4, !noalias !1010
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i31, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #35
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract3) #35
  %12 = sext i32 %offset.i.i31 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract3, i64 %12
  %14 = getelementptr i8, ptr %13, i64 72
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i34 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i35 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i36 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i37 = load i64, ptr %hash_coef_ptr.i.i34, align 4, !noalias !1013
  %tbl_size.i.i38 = load i64, ptr %tbl_size_ptr.i.i35, align 4, !noalias !1013
  %offset_tbl.i.i39 = load ptr, ptr %offset_tbl_ptr.i.i36, align 8, !noalias !1013
  %product.i.i.i40 = mul i64 %hash_coef.i.i37, 6499063144389013426
  %shifted.i.i.i41 = lshr i64 %product.i.i.i40, 32
  %xored.i.i.i42 = xor i64 %shifted.i.i.i41, %product.i.i.i40
  %hash.i.i.i43 = and i64 %xored.i.i.i42, %tbl_size.i.i38
  %offset_ptr.i.i44 = getelementptr i32, ptr %offset_tbl.i.i39, i64 %hash.i.i.i43
  %offset.i.i45 = load i32, ptr %offset_ptr.i.i44, align 4, !noalias !1013
  %17 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %18 = ptrtoint ptr %.fca.1.extract to i64
  %19 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.3.0.insert.ext = zext i32 %offset.i.i45 to i160
  %.sroa.3.0.insert.shift = shl nuw i160 %.sroa.3.0.insert.ext, 128
  %.sroa.2.0.insert.ext = zext i64 %19 to i160
  %.sroa.2.0.insert.shift = shl nuw nsw i160 %.sroa.2.0.insert.ext, 64
  %.sroa.2.0.insert.insert = or disjoint i160 %.sroa.3.0.insert.shift, %.sroa.2.0.insert.shift
  %.sroa.0.0.insert.ext = zext i64 %18 to i160
  %.sroa.0.0.insert.insert = or disjoint i160 %.sroa.2.0.insert.insert, %.sroa.0.0.insert.ext
  %20 = insertvalue { ptr, i160 } %17, i160 %.sroa.0.0.insert.insert, 1
  ret { ptr, i160 } %20
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FileWriter(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull align 8 dereferenceable(16) ptr @FileWriter_field_FileWriter_0(ptr nocapture nofree readnone %0) #0 {
  ret ptr @_parameterization_Ptri64
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileWriter_B_init_textString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileWriter_B_process_fileFile({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FileWriter_init_textString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1016
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1016
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1016
  %product.i.i.i = mul i64 %hash_coef.i.i, 2522433070607690589
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1016
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !22
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !22
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !22
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !1019
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 72, ptr nocapture nofree noundef %.fca.0.extract1) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i.i35, 3
  tail call void %10(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %14) #36
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @FileWriter_process_fileFile({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1022
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1022
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1022
  %product.i.i.i = mul i64 %hash_coef.i.i, 2522433070607690589
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1022
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i23 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i24 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i25 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i23, align 4, !noalias !1025
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i24, align 4, !noalias !1025
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i25, align 8, !noalias !1025
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, -2227788838181535664
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i34 = load i32, ptr %offset_ptr.i.i33, align 4, !noalias !1025
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 72, ptr nocapture nofree noundef %.fca.0.extract10) #35
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, ptr, ptr, i32 } %9(ptr %.fca.1.extract12) #37
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %10, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %10, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %10, 2
  %hash_coef_ptr.i.i37 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i38 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i40 = load i64, ptr %hash_coef_ptr.i.i37, align 4, !noalias !1028
  %tbl_size.i.i41 = load i64, ptr %tbl_size_ptr.i.i38, align 4, !noalias !1028
  %offset_tbl.i.i42 = load ptr, ptr %offset_tbl_ptr.i.i39, align 8, !noalias !1028
  %product.i.i.i43 = mul i64 %hash_coef.i.i40, 6499063144389013426
  %shifted.i.i.i44 = lshr i64 %product.i.i.i43, 32
  %xored.i.i.i45 = xor i64 %shifted.i.i.i44, %product.i.i.i43
  %hash.i.i.i46 = and i64 %xored.i.i.i45, %tbl_size.i.i41
  %offset_ptr.i.i47 = getelementptr i32, ptr %offset_tbl.i.i42, i64 %hash.i.i.i46
  %offset.i.i48 = load i32, ptr %offset_ptr.i.i47, align 4, !noalias !1028
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i.i48, 3
  %15 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.1.extract3, 1
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.2.extract5, 2
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, i32 %offset.i.i34, 3
  %19 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %19) #41
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef %.fca.0.extract1) #41
  %22 = sext i32 %offset.i.i34 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract1, i64 %22
  %24 = getelementptr i8, ptr %23, i64 88
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %26, align 8
  %result.i = call ptr %25({ ptr, ptr, ptr, i32 } %18, ptr nocapture nofree noundef nonnull readonly %26) #16
  %27 = call i64 %result.i({ ptr, ptr, ptr, i32 } %18, { ptr, ptr, ptr, i32 } %18, ptr nonnull align 8 dereferenceable(8) %19, { ptr, ptr, ptr, i32 } %14) #7
  %.sroa.0.0.insert.ext = zext i64 %27 to i160
  %28 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FileWriter_getter_text(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FileWriter_setter_text(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FileSystem(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define ptr @FileSystem_B__Self_process_file_file_nameString_modeString_processorFunctionFile_to_T__Self_process_file_file_nameString_modeString_processorFileProcessorT(ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %0) #35
  %3 = getelementptr inbounds i8, ptr %0, i64 16
  %4 = load ptr, ptr %3, align 8
  %5 = icmp eq ptr %4, @function_typ
  %6 = select i1 %5, i64 3, i64 4
  %7 = getelementptr [7 x ptr], ptr @FileSystem, i64 0, i64 %6
  %8 = getelementptr i8, ptr %7, i64 80
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @FileSystem_B__Self_read_file_file_nameString(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #35
  ret ptr @FileSystem__Self_read_file_file_nameString
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @FileSystem_B__Self_write_file_file_nameString_textString(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #12 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0) #35
  ret ptr @FileSystem__Self_write_file_file_nameString_textString
}

define { ptr, i160 } @FileSystem__Self_process_file_file_nameString_modeString_processorFunctionFile_to_T(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1, { ptr, ptr, ptr, i32 } %2, { ptr, i160 } %3) {
._crit_edge:
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract32 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract33 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract32, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract32, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract32, i64 40
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %2, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %2, 1
  %.fca.2.extract26 = extractvalue { ptr, ptr, ptr, i32 } %2, 2
  %hash_coef_ptr.i.i57 = getelementptr i8, ptr %.fca.0.extract24, i64 8
  %tbl_size_ptr.i.i58 = getelementptr i8, ptr %.fca.0.extract24, i64 16
  %offset_tbl_ptr.i.i59 = getelementptr i8, ptr %.fca.0.extract24, i64 40
  %.fca.1.extract21 = extractvalue { ptr, i160 } %3, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract21 to i64
  %5 = inttoptr i64 %.sroa.1.8.extract.trunc to ptr
  %result.i70 = tail call noalias dereferenceable_or_null(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %hash_coef.i.i75 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i76 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i77 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i78 = mul i64 %hash_coef.i.i75, 6499063144389013426
  %shifted.i.i.i79 = lshr i64 %product.i.i.i78, 32
  %xored.i.i.i80 = xor i64 %shifted.i.i.i79, %product.i.i.i78
  %hash.i.i.i81 = and i64 %xored.i.i.i80, %tbl_size.i.i76
  %offset_ptr.i.i82 = getelementptr i32, ptr %offset_tbl.i.i77, i64 %hash.i.i.i81
  %offset.i.i83 = load i32, ptr %offset_ptr.i.i82, align 4, !noalias !22
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract32, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract33, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract34, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } { ptr @File, ptr undef, ptr undef, i32 undef }, ptr %result.i70, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr undef, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 10, 3
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %4)
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  store ptr %.fca.0.extract32, ptr %result.i70, align 8
  %13 = getelementptr inbounds i8, ptr %result.i70, i64 8
  store ptr %.fca.1.extract33, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i70, i64 16
  store ptr %.fca.2.extract34, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i70, i64 24
  store i32 %offset.i.i83, ptr %15, align 4
  %hash_coef.i.i83.i = load i64, ptr %hash_coef_ptr.i.i57, align 4, !noalias !22
  %tbl_size.i.i84.i = load i64, ptr %tbl_size_ptr.i.i58, align 4, !noalias !22
  %offset_tbl.i.i85.i = load ptr, ptr %offset_tbl_ptr.i.i59, align 8, !noalias !22
  %product.i.i.i86.i = mul i64 %hash_coef.i.i83.i, 6499063144389013426
  %shifted.i.i.i87.i = lshr i64 %product.i.i.i86.i, 32
  %xored.i.i.i88.i = xor i64 %shifted.i.i.i87.i, %product.i.i.i86.i
  %hash.i.i.i89.i = and i64 %xored.i.i.i88.i, %tbl_size.i.i84.i
  %offset_ptr.i.i90.i = getelementptr i32, ptr %offset_tbl.i.i85.i, i64 %hash.i.i.i89.i
  %offset.i.i105.i = load i32, ptr %offset_ptr.i.i90.i, align 4, !noalias !1031
  %16 = getelementptr i8, ptr %result.i70, i64 32
  store ptr %.fca.0.extract24, ptr %16, align 8
  %17 = getelementptr i8, ptr %result.i70, i64 40
  store ptr %.fca.1.extract25, ptr %17, align 8
  %18 = getelementptr i8, ptr %result.i70, i64 48
  store ptr %.fca.2.extract26, ptr %18, align 8
  %19 = getelementptr i8, ptr %result.i70, i64 56
  store i32 %offset.i.i105.i, ptr %19, align 4
  %20 = getelementptr i8, ptr %result.i70, i64 72
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  %22 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i83, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #35
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract32) #35
  %25 = sext i32 %offset.i.i83 to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract32, i64 %25
  %27 = getelementptr i8, ptr %26, i64 80
  %28 = load ptr, ptr %27, align 8
  %result.i.i = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly %4) #16
  %29 = call { ptr } %result.i.i({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4) #7
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File)
  %31 = load ptr, ptr %16, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = load ptr, ptr %17, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 1
  %35 = load ptr, ptr %18, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 2
  %37 = load i32, ptr %19, align 4
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %37, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %31)
  %41 = sext i32 %37 to i64
  %42 = getelementptr ptr, ptr %31, i64 %41
  %43 = getelementptr i8, ptr %42, i64 80
  %44 = load ptr, ptr %43, align 8
  %result.i107.i = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly %4) #16
  %45 = call { ptr } %result.i107.i({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4) #7
  %46 = call { ptr } @fopen({ ptr } %29, { ptr } %45) #7
  %47 = getelementptr i8, ptr %result.i70, i64 64
  %.fca.0.extract.i = extractvalue { ptr } %46, 0
  store ptr %.fca.0.extract.i, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File)
  store i1 true, ptr %20, align 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %4)
  %stack.i = tail call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #44
  store ptr %5, ptr %stack.i, align 8
  %stack_top.i = getelementptr inbounds i8, ptr %stack.i, i64 8388608
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr inbounds i8, ptr %stack.i, i64 8
  %arg_passer_slot.i = getelementptr inbounds i8, ptr %stack.i, i64 32
  %into_callee_second_word.i = getelementptr inbounds i8, ptr %stack.i, i64 16
  %into_callee_third_word.i = getelementptr inbounds i8, ptr %stack.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 8
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 8
  store ptr @coroutine_uppkywgipx_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr inbounds i8, ptr %stack.i, i64 40
  store i1 false, ptr %is_finished.i, align 8
  tail call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word.i)
  %49 = getelementptr inbounds i8, ptr %stack.i, i64 80
  store { ptr, ptr, ptr, i32 } %11, ptr %49, align 8
  %old_into_caller.unpack.i = load ptr, ptr @into_caller_buf, align 8
  %old_into_caller.unpack1.i = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  %old_into_caller.unpack2.i = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine.i = load ptr, ptr @current_coroutine, align 8
  store ptr %stack.i, ptr @current_coroutine, align 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr nonnull %into_callee_buf.i) #42
  store ptr %old_coroutine.i, ptr @current_coroutine, align 8
  store ptr %old_into_caller.unpack.i, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack1.i, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %old_into_caller.unpack2.i, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %4) #35
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  %53 = load i1, ptr %20, align 1
  br i1 %53, label %54, label %File_close_.exit

54:                                               ; preds = %._crit_edge
  %55 = load ptr, ptr %47, align 8
  %56 = insertvalue { ptr } undef, ptr %55, 0
  %57 = call i32 @fclose({ ptr } %56) #7
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #41
  store i1 false, ptr %20, align 1
  %59 = icmp eq i32 %57, -1
  br i1 %59, label %60, label %File_close_.exit

60:                                               ; preds = %54
  %result.i35.i = call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i.i = call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i.i, align 8
  %result.i29.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i.i, ptr %result.i29.i.i, align 8
  %61 = getelementptr i8, ptr %result.i29.i.i, i64 8
  store i32 6, ptr %61, align 4
  %62 = getelementptr i8, ptr %result.i29.i.i, i64 12
  store i32 7, ptr %62, align 4
  %63 = getelementptr i8, ptr %result.i35.i, i64 40
  store ptr @String, ptr %63, align 8
  %64 = getelementptr i8, ptr %result.i35.i, i64 48
  store ptr %result.i29.i.i, ptr %64, align 8
  %65 = getelementptr i8, ptr %result.i35.i, i64 64
  store i32 10, ptr %65, align 4
  %66 = getelementptr i8, ptr %result.i35.i, i64 8
  %67 = getelementptr i8, ptr %result.i35.i, i64 16
  %68 = getelementptr i8, ptr %result.i35.i, i64 32
  %result.i37.i = call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i37.i, align 16
  %result.i39.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i37.i, ptr %result.i39.i, align 8
  %69 = getelementptr i8, ptr %result.i39.i, i64 8
  store i32 10, ptr %69, align 4
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %71 = getelementptr i8, ptr %result.i39.i, i64 12
  store i32 11, ptr %71, align 4
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError)
  store i32 47, ptr %result.i35.i, align 4
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %66, align 8
  store ptr %result.i39.i, ptr %67, align 8
  store i32 10, ptr %68, align 4
  %74 = ptrtoint ptr %result.i35.i to i64
  %.sroa.424.8.insert.ext.i = zext i64 %74 to i160
  %.sroa.424.8.insert.insert.i = or disjoint i160 %.sroa.424.8.insert.ext.i, 3402823669209384634633746074317682114560
  %75 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.424.8.insert.insert.i, 1
  %current_coroutine.i.i = load ptr, ptr @current_coroutine, align 8
  %76 = getelementptr i8, ptr %current_coroutine.i.i, i64 48
  store { ptr, i160 } %75, ptr %76, align 8
  %into_callee_buf.i.i = getelementptr i8, ptr %current_coroutine.i.i, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %File_close_.exit

File_close_.exit:                                 ; preds = %._crit_edge, %54, %60
  %77 = getelementptr inbounds i8, ptr %stack.i, i64 48
  %78 = load { ptr, i160 }, ptr %77, align 8
  ret { ptr, i160 } %78
}

define { ptr, i160 } @FileSystem__Self_process_file_file_nameString_modeString_processorFileProcessorT(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1, { ptr, ptr, ptr, i32 } %2, { ptr, i160 } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract31 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract33 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract31, i64 40
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %2, 0
  %.fca.1.extract25 = extractvalue { ptr, ptr, ptr, i32 } %2, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %2, 2
  %hash_coef_ptr.i.i60 = getelementptr i8, ptr %.fca.0.extract24, i64 8
  %tbl_size_ptr.i.i61 = getelementptr i8, ptr %.fca.0.extract24, i64 16
  %offset_tbl_ptr.i.i62 = getelementptr i8, ptr %.fca.0.extract24, i64 40
  %.fca.0.extract21 = extractvalue { ptr, i160 } %3, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %3, 1
  %.sroa.3156.8.extract.trunc = trunc i160 %.fca.1.extract22 to i64
  %6 = inttoptr i64 %.sroa.3156.8.extract.trunc to ptr
  %.sroa.5157.8.extract.shift = lshr i160 %.fca.1.extract22, 64
  %.sroa.5157.8.extract.trunc = trunc i160 %.sroa.5157.8.extract.shift to i64
  %7 = inttoptr i64 %.sroa.5157.8.extract.trunc to ptr
  %hash_coef_ptr.i.i74 = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i75 = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i76 = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i77 = load i64, ptr %hash_coef_ptr.i.i74, align 4, !noalias !1034
  %tbl_size.i.i78 = load i64, ptr %tbl_size_ptr.i.i75, align 4, !noalias !1034
  %offset_tbl.i.i79 = load ptr, ptr %offset_tbl_ptr.i.i76, align 8, !noalias !1034
  %product.i.i.i80 = mul i64 %hash_coef.i.i77, 4146660827496349788
  %shifted.i.i.i81 = lshr i64 %product.i.i.i80, 32
  %xored.i.i.i82 = xor i64 %shifted.i.i.i81, %product.i.i.i80
  %hash.i.i.i83 = and i64 %xored.i.i.i82, %tbl_size.i.i78
  %offset_ptr.i.i84 = getelementptr i32, ptr %offset_tbl.i.i79, i64 %hash.i.i.i83
  %offset.i.i85 = load i32, ptr %offset_ptr.i.i84, align 4, !noalias !1034
  %result.i87 = tail call noalias dereferenceable_or_null(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract31, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract32, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract33, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } { ptr @File, ptr undef, ptr undef, i32 undef }, ptr %result.i87, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr undef, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 10, 3
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull align 16 dereferenceable(240) @File) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %5)
  %hash_coef.i.i55.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i56.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i57.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i58.i = mul i64 %hash_coef.i.i55.i, 6499063144389013426
  %shifted.i.i.i59.i = lshr i64 %product.i.i.i58.i, 32
  %xored.i.i.i60.i = xor i64 %shifted.i.i.i59.i, %product.i.i.i58.i
  %hash.i.i.i61.i = and i64 %xored.i.i.i60.i, %tbl_size.i.i56.i
  %offset_ptr.i.i62.i = getelementptr i32, ptr %offset_tbl.i.i57.i, i64 %hash.i.i.i61.i
  %offset.i.i77.i = load i32, ptr %offset_ptr.i.i62.i, align 4, !noalias !1037
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  store ptr %.fca.0.extract31, ptr %result.i87, align 8
  %16 = getelementptr inbounds i8, ptr %result.i87, i64 8
  store ptr %.fca.1.extract32, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i87, i64 16
  store ptr %.fca.2.extract33, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i87, i64 24
  store i32 %offset.i.i77.i, ptr %18, align 4
  %hash_coef.i.i83.i = load i64, ptr %hash_coef_ptr.i.i60, align 4, !noalias !22
  %tbl_size.i.i84.i = load i64, ptr %tbl_size_ptr.i.i61, align 4, !noalias !22
  %offset_tbl.i.i85.i = load ptr, ptr %offset_tbl_ptr.i.i62, align 8, !noalias !22
  %product.i.i.i86.i = mul i64 %hash_coef.i.i83.i, 6499063144389013426
  %shifted.i.i.i87.i = lshr i64 %product.i.i.i86.i, 32
  %xored.i.i.i88.i = xor i64 %shifted.i.i.i87.i, %product.i.i.i86.i
  %hash.i.i.i89.i = and i64 %xored.i.i.i88.i, %tbl_size.i.i84.i
  %offset_ptr.i.i90.i = getelementptr i32, ptr %offset_tbl.i.i85.i, i64 %hash.i.i.i89.i
  %offset.i.i105.i = load i32, ptr %offset_ptr.i.i90.i, align 4, !noalias !1040
  %19 = getelementptr i8, ptr %result.i87, i64 32
  store ptr %.fca.0.extract24, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i87, i64 40
  store ptr %.fca.1.extract25, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i87, i64 48
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr i8, ptr %result.i87, i64 56
  store i32 %offset.i.i105.i, ptr %22, align 4
  %23 = getelementptr i8, ptr %result.i87, i64 72
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  %25 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i.i77.i, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract31) #35
  %28 = sext i32 %offset.i.i77.i to i64
  %29 = getelementptr ptr, ptr %.fca.0.extract31, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  %result.i.i = call ptr %31({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly %5) #16
  %32 = call { ptr } %result.i.i({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %5) #7
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File)
  %34 = load ptr, ptr %19, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %34, 0
  %36 = load ptr, ptr %20, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 1
  %38 = load ptr, ptr %21, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 2
  %40 = load i32, ptr %22, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %40, 3
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %34)
  %44 = sext i32 %40 to i64
  %45 = getelementptr ptr, ptr %34, i64 %44
  %46 = getelementptr i8, ptr %45, i64 80
  %47 = load ptr, ptr %46, align 8
  %result.i107.i = call ptr %47({ ptr, ptr, ptr, i32 } %41, ptr nocapture nofree noundef nonnull readonly %5) #16
  %48 = call { ptr } %result.i107.i({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull align 8 %5) #7
  %49 = call { ptr } @fopen({ ptr } %32, { ptr } %48) #7
  %50 = getelementptr i8, ptr %result.i87, i64 64
  %.fca.0.extract.i = extractvalue { ptr } %49, 0
  store ptr %.fca.0.extract.i, ptr %50, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File)
  store i1 true, ptr %23, align 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %5)
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %6, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %7, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %offset.i.i85, 3
  %stack.i = tail call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #44
  store ptr @_functionliteral_ujbvsloqoy, ptr %stack.i, align 8
  %stack_top.i = getelementptr inbounds i8, ptr %stack.i, i64 8388608
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr inbounds i8, ptr %stack.i, i64 8
  %arg_passer_slot.i = getelementptr inbounds i8, ptr %stack.i, i64 32
  %into_callee_second_word.i = getelementptr inbounds i8, ptr %stack.i, i64 16
  %into_callee_third_word.i = getelementptr inbounds i8, ptr %stack.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 8
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 8
  store ptr @coroutine_muarwmssow_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr inbounds i8, ptr %stack.i, i64 40
  store i1 false, ptr %is_finished.i, align 8
  tail call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word.i)
  %56 = getelementptr inbounds i8, ptr %stack.i, i64 80
  %57 = getelementptr inbounds i8, ptr %stack.i, i64 112
  store { ptr, ptr, ptr, i32 } %55, ptr %56, align 8
  store { ptr, ptr, ptr, i32 } %13, ptr %57, align 8
  %old_into_caller.unpack.i = load ptr, ptr @into_caller_buf, align 8
  %old_into_caller.unpack1.i = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  %old_into_caller.unpack2.i = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine.i = load ptr, ptr @current_coroutine, align 8
  store ptr %stack.i, ptr @current_coroutine, align 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr nonnull %into_callee_buf.i) #42
  store ptr %old_coroutine.i, ptr @current_coroutine, align 8
  store ptr %old_into_caller.unpack.i, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack1.i, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %old_into_caller.unpack2.i, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %58 = getelementptr inbounds i8, ptr %stack.i, i64 48
  %59 = load { ptr, i160 }, ptr %58, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %59, 0
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %5) #35
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  %63 = load i1, ptr %23, align 1
  br i1 %63, label %64, label %File_close_.exit

64:                                               ; preds = %4
  %65 = load ptr, ptr %50, align 8
  %66 = insertvalue { ptr } undef, ptr %65, 0
  %67 = call i32 @fclose({ ptr } %66) #7
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #41
  store i1 false, ptr %23, align 1
  %69 = icmp eq i32 %67, -1
  br i1 %69, label %70, label %File_close_.exit

70:                                               ; preds = %64
  %result.i35.i = call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i.i = call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i.i, align 8
  %result.i29.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i.i, ptr %result.i29.i.i, align 8
  %71 = getelementptr i8, ptr %result.i29.i.i, i64 8
  store i32 6, ptr %71, align 4
  %72 = getelementptr i8, ptr %result.i29.i.i, i64 12
  store i32 7, ptr %72, align 4
  %73 = getelementptr i8, ptr %result.i35.i, i64 40
  store ptr @String, ptr %73, align 8
  %74 = getelementptr i8, ptr %result.i35.i, i64 48
  store ptr %result.i29.i.i, ptr %74, align 8
  %75 = getelementptr i8, ptr %result.i35.i, i64 64
  store i32 10, ptr %75, align 4
  %76 = getelementptr i8, ptr %result.i35.i, i64 8
  %77 = getelementptr i8, ptr %result.i35.i, i64 16
  %78 = getelementptr i8, ptr %result.i35.i, i64 32
  %result.i37.i = call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i37.i, align 16
  %result.i39.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i37.i, ptr %result.i39.i, align 8
  %79 = getelementptr i8, ptr %result.i39.i, i64 8
  store i32 10, ptr %79, align 4
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %81 = getelementptr i8, ptr %result.i39.i, i64 12
  store i32 11, ptr %81, align 4
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError)
  store i32 47, ptr %result.i35.i, align 4
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %76, align 8
  store ptr %result.i39.i, ptr %77, align 8
  store i32 10, ptr %78, align 4
  %84 = ptrtoint ptr %result.i35.i to i64
  %.sroa.424.8.insert.ext.i = zext i64 %84 to i160
  %.sroa.424.8.insert.insert.i = or disjoint i160 %.sroa.424.8.insert.ext.i, 3402823669209384634633746074317682114560
  %85 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.424.8.insert.insert.i, 1
  %current_coroutine.i.i = load ptr, ptr @current_coroutine, align 8
  %86 = getelementptr i8, ptr %current_coroutine.i.i, i64 48
  store { ptr, i160 } %85, ptr %86, align 8
  %into_callee_buf.i.i = getelementptr i8, ptr %current_coroutine.i.i, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %File_close_.exit

File_close_.exit:                                 ; preds = %4, %64, %70
  %87 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %88 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %89 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %90 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %91 = load i64, ptr %87, align 4
  %92 = load i64, ptr %88, align 4
  %93 = load ptr, ptr %89, align 8
  %94 = load ptr, ptr %90, align 8
  %result.i133 = call i1 %93(i64 %92, i64 %91, i64 9027164862567808692, i64 ptrtoint (ptr @Exception to i64), ptr readonly %94) #5
  br i1 %result.i133, label %95, label %._crit_edge

95:                                               ; preds = %File_close_.exit
  %.fca.1.extract = extractvalue { ptr, i160 } %59, 1
  %offset_tbl_ptr.i.i137 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %offset_tbl.i.i140 = load ptr, ptr %offset_tbl_ptr.i.i137, align 8, !noalias !1043
  %product.i.i.i141 = mul i64 %91, 9027164862567808692
  %shifted.i.i.i142 = lshr i64 %product.i.i.i141, 32
  %xored.i.i.i143 = xor i64 %shifted.i.i.i142, %product.i.i.i141
  %hash.i.i.i144 = and i64 %xored.i.i.i143, %92
  %offset_ptr.i.i145 = getelementptr i32, ptr %offset_tbl.i.i140, i64 %hash.i.i.i144
  %offset.i.i146 = load i32, ptr %offset_ptr.i.i145, align 4, !noalias !1043
  %96 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %.sroa.5168.8.insert.ext = zext i32 %offset.i.i146 to i160
  %.sroa.5168.8.insert.shift = shl nuw i160 %.sroa.5168.8.insert.ext, 128
  %.sroa.3167.8.insert.ext = and i160 %.fca.1.extract, 340282366920938463463374607431768211455
  %.sroa.3167.8.insert.insert = or disjoint i160 %.sroa.5168.8.insert.shift, %.sroa.3167.8.insert.ext
  %97 = insertvalue { ptr, i160 } %96, i160 %.sroa.3167.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %98 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %97, ptr %98, align 8
  %into_callee_buf.i148 = getelementptr i8, ptr %current_coroutine.i, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i148, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %._crit_edge

._crit_edge:                                      ; preds = %File_close_.exit, %95
  %99 = load { ptr, i160 }, ptr %58, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 56, ptr nocapture nofree noundef nonnull %.fca.0.extract21)
  ret { ptr, i160 } %99
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @FileSystem__Self_read_file_file_nameString(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %result.i = tail call noalias align 2 dereferenceable_or_null(3) ptr @bump_malloc_inner(i64 noundef 3, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <2 x i8> <i8 114, i8 98>, ptr %result.i, align 2
  %result.i23 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i23, align 8
  %4 = getelementptr i8, ptr %result.i23, i64 8
  store i32 2, ptr %4, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %6 = getelementptr i8, ptr %result.i23, i64 12
  store i32 3, ptr %6, align 4
  %result.i26 = tail call noalias ptr @bump_malloc_inner(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 64, ptr nocapture nofree noundef nonnull align 16 dereferenceable(144) @FileReader)
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract18, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract, 2
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 56, ptr nocapture nofree noundef nonnull align 16 dereferenceable(136) @FileSystem)
  %result.i87.i = tail call noalias dereferenceable_or_null(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %12 = insertvalue { ptr, ptr, ptr, i32 } { ptr @File, ptr undef, ptr undef, i32 undef }, ptr %result.i87.i, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr undef, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 10, 3
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull align 16 dereferenceable(240) @File) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %3)
  %hash_coef.i.i55.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i56.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i57.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i58.i.i = mul i64 %hash_coef.i.i55.i.i, 6499063144389013426
  %shifted.i.i.i59.i.i = lshr i64 %product.i.i.i58.i.i, 32
  %xored.i.i.i60.i.i = xor i64 %shifted.i.i.i59.i.i, %product.i.i.i58.i.i
  %hash.i.i.i61.i.i = and i64 %xored.i.i.i60.i.i, %tbl_size.i.i56.i.i
  %offset_ptr.i.i62.i.i = getelementptr i32, ptr %offset_tbl.i.i57.i.i, i64 %hash.i.i.i61.i.i
  %offset.i.i77.i.i = load i32, ptr %offset_ptr.i.i62.i.i, align 4, !noalias !1046
  store ptr %.fca.0.extract17, ptr %result.i87.i, align 8
  %16 = getelementptr inbounds i8, ptr %result.i87.i, i64 8
  store ptr %.fca.1.extract18, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i87.i, i64 16
  store ptr %.fca.2.extract, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i87.i, i64 24
  store i32 %offset.i.i77.i.i, ptr %18, align 4
  %19 = getelementptr i8, ptr %result.i87.i, i64 32
  store ptr @String, ptr %19, align 8
  %20 = getelementptr i8, ptr %result.i87.i, i64 40
  store ptr %result.i23, ptr %20, align 8
  %21 = getelementptr i8, ptr %result.i87.i, i64 48
  %22 = getelementptr i8, ptr %result.i87.i, i64 56
  store i32 10, ptr %22, align 4
  %23 = getelementptr i8, ptr %result.i87.i, i64 72
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  %25 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i.i77.i.i, 3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract17) #35
  %28 = sext i32 %offset.i.i77.i.i to i64
  %29 = getelementptr ptr, ptr %.fca.0.extract17, i64 %28
  %30 = getelementptr i8, ptr %29, i64 80
  %31 = load ptr, ptr %30, align 8
  %result.i.i.i = call ptr %31({ ptr, ptr, ptr, i32 } %25, ptr nocapture nofree noundef nonnull readonly %3) #16
  %32 = call { ptr } %result.i.i.i({ ptr, ptr, ptr, i32 } %25, { ptr, ptr, ptr, i32 } %25, ptr nonnull align 8 %3) #7
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File)
  %34 = load ptr, ptr %19, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %34, 0
  %36 = load ptr, ptr %20, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 1
  %38 = load ptr, ptr %21, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 2
  %40 = load i32, ptr %22, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %40, 3
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %34)
  %44 = sext i32 %40 to i64
  %45 = getelementptr ptr, ptr %34, i64 %44
  %46 = getelementptr i8, ptr %45, i64 80
  %47 = load ptr, ptr %46, align 8
  %result.i107.i.i = call ptr %47({ ptr, ptr, ptr, i32 } %41, ptr nocapture nofree noundef nonnull readonly %3) #16
  %48 = call { ptr } %result.i107.i.i({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull align 8 %3) #7
  %49 = call { ptr } @fopen({ ptr } %32, { ptr } %48) #7
  %50 = getelementptr i8, ptr %result.i87.i, i64 64
  %.fca.0.extract.i.i = extractvalue { ptr } %49, 0
  store ptr %.fca.0.extract.i.i, ptr %50, align 8
  store i1 true, ptr %23, align 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %3)
  %51 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FileReader, ptr undef, ptr undef, i32 undef }, ptr %result.i26, 1
  %52 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr null, 2
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 15, 3
  %stack.i.i = call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #44
  store ptr @_functionliteral_ujbvsloqoy, ptr %stack.i.i, align 8
  %stack_top.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 8388608
  %stack_top_i64.i.i = ptrtoint ptr %stack_top.i.i to i64
  %stack_top_aligned.i.i = and i64 %stack_top_i64.i.i, -16
  %into_callee_buf.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 8
  %arg_passer_slot.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 32
  %into_callee_second_word.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 16
  %into_callee_third_word.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 24
  store i64 %stack_top_aligned.i.i, ptr %into_callee_buf.i.i, align 8
  store i64 %stack_top_aligned.i.i, ptr %into_callee_third_word.i.i, align 8
  store ptr @coroutine_muarwmssow_passer, ptr %arg_passer_slot.i.i, align 8
  %is_finished.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 40
  store i1 false, ptr %is_finished.i.i, align 8
  call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word.i.i) #7
  %54 = getelementptr inbounds i8, ptr %stack.i.i, i64 80
  %55 = getelementptr inbounds i8, ptr %stack.i.i, i64 112
  store { ptr, ptr, ptr, i32 } %53, ptr %54, align 8
  store { ptr, ptr, ptr, i32 } %14, ptr %55, align 8
  %old_into_caller.unpack.i.i = load ptr, ptr @into_caller_buf, align 8
  %old_into_caller.unpack1.i.i = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  %old_into_caller.unpack2.i.i = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine.i.i = load ptr, ptr @current_coroutine, align 8
  store ptr %stack.i.i, ptr @current_coroutine, align 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr nonnull %into_callee_buf.i.i) #42
  store ptr %old_coroutine.i.i, ptr @current_coroutine, align 8
  store ptr %old_into_caller.unpack.i.i, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack1.i.i, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %old_into_caller.unpack2.i.i, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %56 = getelementptr inbounds i8, ptr %stack.i.i, i64 48
  %57 = load { ptr, i160 }, ptr %56, align 8
  %.fca.0.extract.i = extractvalue { ptr, i160 } %57, 0
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #35
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  %61 = load i1, ptr %23, align 1
  br i1 %61, label %62, label %File_close_.exit.i

62:                                               ; preds = %2
  %63 = load ptr, ptr %50, align 8
  %64 = insertvalue { ptr } undef, ptr %63, 0
  %65 = call i32 @fclose({ ptr } %64) #7
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #41
  store i1 false, ptr %23, align 1
  %67 = icmp eq i32 %65, -1
  br i1 %67, label %68, label %File_close_.exit.i

68:                                               ; preds = %62
  %result.i35.i.i = call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i.i.i = call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i.i.i, align 8
  %result.i29.i.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i.i.i, ptr %result.i29.i.i.i, align 8
  %69 = getelementptr i8, ptr %result.i29.i.i.i, i64 8
  store i32 6, ptr %69, align 4
  %70 = getelementptr i8, ptr %result.i29.i.i.i, i64 12
  store i32 7, ptr %70, align 4
  %71 = getelementptr i8, ptr %result.i35.i.i, i64 40
  store ptr @String, ptr %71, align 8
  %72 = getelementptr i8, ptr %result.i35.i.i, i64 48
  store ptr %result.i29.i.i.i, ptr %72, align 8
  %73 = getelementptr i8, ptr %result.i35.i.i, i64 64
  store i32 10, ptr %73, align 4
  %74 = getelementptr i8, ptr %result.i35.i.i, i64 8
  %75 = getelementptr i8, ptr %result.i35.i.i, i64 16
  %76 = getelementptr i8, ptr %result.i35.i.i, i64 32
  %result.i37.i.i = call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i37.i.i, align 16
  %result.i39.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i37.i.i, ptr %result.i39.i.i, align 8
  %77 = getelementptr i8, ptr %result.i39.i.i, i64 8
  store i32 10, ptr %77, align 4
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %79 = getelementptr i8, ptr %result.i39.i.i, i64 12
  store i32 11, ptr %79, align 4
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError)
  store i32 47, ptr %result.i35.i.i, align 4
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %74, align 8
  store ptr %result.i39.i.i, ptr %75, align 8
  store i32 10, ptr %76, align 4
  %82 = ptrtoint ptr %result.i35.i.i to i64
  %.sroa.424.8.insert.ext.i.i = zext i64 %82 to i160
  %.sroa.424.8.insert.insert.i.i = or disjoint i160 %.sroa.424.8.insert.ext.i.i, 3402823669209384634633746074317682114560
  %83 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.424.8.insert.insert.i.i, 1
  %current_coroutine.i.i.i = load ptr, ptr @current_coroutine, align 8
  %84 = getelementptr i8, ptr %current_coroutine.i.i.i, i64 48
  store { ptr, i160 } %83, ptr %84, align 8
  %into_callee_buf.i.i.i = getelementptr i8, ptr %current_coroutine.i.i.i, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i.i.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %File_close_.exit.i

File_close_.exit.i:                               ; preds = %68, %62, %2
  %85 = getelementptr i8, ptr %.fca.0.extract.i, i64 8
  %86 = getelementptr i8, ptr %.fca.0.extract.i, i64 16
  %87 = getelementptr i8, ptr %.fca.0.extract.i, i64 24
  %88 = getelementptr i8, ptr %.fca.0.extract.i, i64 32
  %89 = load i64, ptr %85, align 4
  %90 = load i64, ptr %86, align 4
  %91 = load ptr, ptr %87, align 8
  %92 = load ptr, ptr %88, align 8
  %result.i133.i = call i1 %91(i64 %90, i64 %89, i64 9027164862567808692, i64 ptrtoint (ptr @Exception to i64), ptr readonly %92) #5
  br i1 %result.i133.i, label %93, label %FileSystem__Self_process_file_file_nameString_modeString_processorFileProcessorT.exit

93:                                               ; preds = %File_close_.exit.i
  %.fca.1.extract.i = extractvalue { ptr, i160 } %57, 1
  %offset_tbl_ptr.i.i137.i = getelementptr i8, ptr %.fca.0.extract.i, i64 40
  %offset_tbl.i.i140.i = load ptr, ptr %offset_tbl_ptr.i.i137.i, align 8, !noalias !1049
  %product.i.i.i141.i = mul i64 %89, 9027164862567808692
  %shifted.i.i.i142.i = lshr i64 %product.i.i.i141.i, 32
  %xored.i.i.i143.i = xor i64 %shifted.i.i.i142.i, %product.i.i.i141.i
  %hash.i.i.i144.i = and i64 %xored.i.i.i143.i, %90
  %offset_ptr.i.i145.i = getelementptr i32, ptr %offset_tbl.i.i140.i, i64 %hash.i.i.i144.i
  %offset.i.i146.i = load i32, ptr %offset_ptr.i.i145.i, align 4, !noalias !1049
  %94 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract.i, 0
  %.sroa.5168.8.insert.ext.i = zext i32 %offset.i.i146.i to i160
  %.sroa.5168.8.insert.shift.i = shl nuw i160 %.sroa.5168.8.insert.ext.i, 128
  %.sroa.3167.8.insert.ext.i = and i160 %.fca.1.extract.i, 340282366920938463463374607431768211455
  %.sroa.3167.8.insert.insert.i = or disjoint i160 %.sroa.5168.8.insert.shift.i, %.sroa.3167.8.insert.ext.i
  %95 = insertvalue { ptr, i160 } %94, i160 %.sroa.3167.8.insert.insert.i, 1
  %current_coroutine.i.i = load ptr, ptr @current_coroutine, align 8
  %96 = getelementptr i8, ptr %current_coroutine.i.i, i64 48
  store { ptr, i160 } %95, ptr %96, align 8
  %into_callee_buf.i148.i = getelementptr i8, ptr %current_coroutine.i.i, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i148.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %FileSystem__Self_process_file_file_nameString_modeString_processorFileProcessorT.exit

FileSystem__Self_process_file_file_nameString_modeString_processorFileProcessorT.exit: ; preds = %File_close_.exit.i, %93
  %97 = load { ptr, i160 }, ptr %56, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 noundef 56, ptr nocapture nofree noundef nonnull @FileReader)
  %.fca.0.extract = extractvalue { ptr, i160 } %97, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %97, 1
  %.sroa.386.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %99 = inttoptr i64 %.sroa.386.8.extract.trunc to ptr
  %.sroa.587.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.587.8.extract.trunc = trunc i160 %.sroa.587.8.extract.shift to i64
  %100 = inttoptr i64 %.sroa.587.8.extract.trunc to ptr
  %hash_coef_ptr.i.i58 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i59 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i60 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i61 = load i64, ptr %hash_coef_ptr.i.i58, align 4, !noalias !22
  %tbl_size.i.i62 = load i64, ptr %tbl_size_ptr.i.i59, align 4, !noalias !22
  %offset_tbl.i.i63 = load ptr, ptr %offset_tbl_ptr.i.i60, align 8, !noalias !22
  %product.i.i.i64 = mul i64 %hash_coef.i.i61, 6499063144389013426
  %shifted.i.i.i65 = lshr i64 %product.i.i.i64, 32
  %xored.i.i.i66 = xor i64 %shifted.i.i.i65, %product.i.i.i64
  %hash.i.i.i67 = and i64 %xored.i.i.i66, %tbl_size.i.i62
  %offset_ptr.i.i68 = getelementptr i32, ptr %offset_tbl.i.i63, i64 %hash.i.i.i67
  %offset.i.i83 = load i32, ptr %offset_ptr.i.i68, align 4, !noalias !1052
  %101 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %102 = insertvalue { ptr, ptr, ptr, i32 } %101, ptr %99, 1
  %103 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %100, 2
  %104 = insertvalue { ptr, ptr, ptr, i32 } %103, i32 %offset.i.i83, 3
  ret { ptr, ptr, ptr, i32 } %104
}

; Function Attrs: nounwind
define void @FileSystem__Self_write_file_file_nameString_textString(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1, { ptr, ptr, ptr, i32 } %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract23 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %2, 0
  %.fca.1.extract18 = extractvalue { ptr, ptr, ptr, i32 } %2, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %2, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract17, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract17, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract17, i64 40
  %result.i = tail call noalias align 2 dereferenceable_or_null(3) ptr @bump_malloc_inner(i64 noundef 3, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <2 x i8> <i8 119, i8 98>, ptr %result.i, align 2
  %result.i44 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i, ptr %result.i44, align 8
  %5 = getelementptr i8, ptr %result.i44, i64 8
  store i32 2, ptr %5, align 4
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %7 = getelementptr i8, ptr %result.i44, i64 12
  store i32 3, ptr %7, align 4
  %result.i47 = tail call noalias dereferenceable_or_null(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 72, ptr nocapture nofree noundef nonnull align 16 dereferenceable(152) @FileWriter)
  %hash_coef.i.i13.i = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !22
  %tbl_size.i.i14.i = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !22
  %offset_tbl.i.i15.i = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !22
  %product.i.i.i16.i = mul i64 %hash_coef.i.i13.i, 6499063144389013426
  %shifted.i.i.i17.i = lshr i64 %product.i.i.i16.i, 32
  %xored.i.i.i18.i = xor i64 %shifted.i.i.i17.i, %product.i.i.i16.i
  %hash.i.i.i19.i = and i64 %xored.i.i.i18.i, %tbl_size.i.i14.i
  %offset_ptr.i.i20.i = getelementptr i32, ptr %offset_tbl.i.i15.i, i64 %hash.i.i.i19.i
  %offset.i.i35.i = load i32, ptr %offset_ptr.i.i20.i, align 4, !noalias !1055
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 72, ptr nocapture nofree noundef nonnull @FileWriter) #35
  store ptr %.fca.0.extract17, ptr %result.i47, align 8
  %10 = getelementptr inbounds i8, ptr %result.i47, i64 8
  store ptr %.fca.1.extract18, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i47, i64 16
  store ptr %.fca.2.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i47, i64 24
  store i32 %offset.i.i35.i, ptr %12, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract22, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract23, 2
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 56, ptr nocapture nofree noundef nonnull align 16 dereferenceable(136) @FileSystem)
  %result.i87.i = tail call noalias dereferenceable_or_null(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %17 = insertvalue { ptr, ptr, ptr, i32 } { ptr @File, ptr undef, ptr undef, i32 undef }, ptr %result.i87.i, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr undef, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 10, 3
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull align 16 dereferenceable(240) @File) #35
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %4)
  %hash_coef.i.i55.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !22
  %tbl_size.i.i56.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !22
  %offset_tbl.i.i57.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !22
  %product.i.i.i58.i.i = mul i64 %hash_coef.i.i55.i.i, 6499063144389013426
  %shifted.i.i.i59.i.i = lshr i64 %product.i.i.i58.i.i, 32
  %xored.i.i.i60.i.i = xor i64 %shifted.i.i.i59.i.i, %product.i.i.i58.i.i
  %hash.i.i.i61.i.i = and i64 %xored.i.i.i60.i.i, %tbl_size.i.i56.i.i
  %offset_ptr.i.i62.i.i = getelementptr i32, ptr %offset_tbl.i.i57.i.i, i64 %hash.i.i.i61.i.i
  %offset.i.i77.i.i = load i32, ptr %offset_ptr.i.i62.i.i, align 4, !noalias !1058
  store ptr %.fca.0.extract21, ptr %result.i87.i, align 8
  %21 = getelementptr inbounds i8, ptr %result.i87.i, i64 8
  store ptr %.fca.1.extract22, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i87.i, i64 16
  store ptr %.fca.2.extract23, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i87.i, i64 24
  store i32 %offset.i.i77.i.i, ptr %23, align 4
  %24 = getelementptr i8, ptr %result.i87.i, i64 32
  store ptr @String, ptr %24, align 8
  %25 = getelementptr i8, ptr %result.i87.i, i64 40
  store ptr %result.i44, ptr %25, align 8
  %26 = getelementptr i8, ptr %result.i87.i, i64 48
  %27 = getelementptr i8, ptr %result.i87.i, i64 56
  store i32 10, ptr %27, align 4
  %28 = getelementptr i8, ptr %result.i87.i, i64 72
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  %30 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i77.i.i, 3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #35
  %32 = tail call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %.fca.0.extract21) #35
  %33 = sext i32 %offset.i.i77.i.i to i64
  %34 = getelementptr ptr, ptr %.fca.0.extract21, i64 %33
  %35 = getelementptr i8, ptr %34, i64 80
  %36 = load ptr, ptr %35, align 8
  %result.i.i.i = call ptr %36({ ptr, ptr, ptr, i32 } %30, ptr nocapture nofree noundef nonnull readonly %4) #16
  %37 = call { ptr } %result.i.i.i({ ptr, ptr, ptr, i32 } %30, { ptr, ptr, ptr, i32 } %30, ptr nonnull align 8 %4) #7
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File)
  %39 = load ptr, ptr %24, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %39, 0
  %41 = load ptr, ptr %25, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 1
  %43 = load ptr, ptr %26, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %43, 2
  %45 = load i32, ptr %27, align 4
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %45, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef %39)
  %49 = sext i32 %45 to i64
  %50 = getelementptr ptr, ptr %39, i64 %49
  %51 = getelementptr i8, ptr %50, i64 80
  %52 = load ptr, ptr %51, align 8
  %result.i107.i.i = call ptr %52({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly %4) #16
  %53 = call { ptr } %result.i107.i.i({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 %4) #7
  %54 = call { ptr } @fopen({ ptr } %37, { ptr } %53) #7
  %55 = getelementptr i8, ptr %result.i87.i, i64 64
  %.fca.0.extract.i.i = extractvalue { ptr } %54, 0
  store ptr %.fca.0.extract.i.i, ptr %55, align 8
  store i1 true, ptr %28, align 1
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %4)
  %56 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FileWriter, ptr undef, ptr undef, i32 undef }, ptr %result.i47, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr null, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 16, 3
  %stack.i.i = call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #44
  store ptr @_functionliteral_ujbvsloqoy, ptr %stack.i.i, align 8
  %stack_top.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 8388608
  %stack_top_i64.i.i = ptrtoint ptr %stack_top.i.i to i64
  %stack_top_aligned.i.i = and i64 %stack_top_i64.i.i, -16
  %into_callee_buf.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 8
  %arg_passer_slot.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 32
  %into_callee_second_word.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 16
  %into_callee_third_word.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 24
  store i64 %stack_top_aligned.i.i, ptr %into_callee_buf.i.i, align 8
  store i64 %stack_top_aligned.i.i, ptr %into_callee_third_word.i.i, align 8
  store ptr @coroutine_muarwmssow_passer, ptr %arg_passer_slot.i.i, align 8
  %is_finished.i.i = getelementptr inbounds i8, ptr %stack.i.i, i64 40
  store i1 false, ptr %is_finished.i.i, align 8
  call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word.i.i) #7
  %59 = getelementptr inbounds i8, ptr %stack.i.i, i64 80
  %60 = getelementptr inbounds i8, ptr %stack.i.i, i64 112
  store { ptr, ptr, ptr, i32 } %58, ptr %59, align 8
  store { ptr, ptr, ptr, i32 } %19, ptr %60, align 8
  %old_into_caller.unpack.i.i = load ptr, ptr @into_caller_buf, align 8
  %old_into_caller.unpack1.i.i = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  %old_into_caller.unpack2.i.i = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine.i.i = load ptr, ptr @current_coroutine, align 8
  store ptr %stack.i.i, ptr @current_coroutine, align 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr nonnull %into_callee_buf.i.i) #42
  store ptr %old_coroutine.i.i, ptr @current_coroutine, align 8
  store ptr %old_into_caller.unpack.i.i, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack1.i.i, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %old_into_caller.unpack2.i.i, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %61 = getelementptr inbounds i8, ptr %stack.i.i, i64 48
  %62 = load { ptr, i160 }, ptr %61, align 8
  %.fca.0.extract.i = extractvalue { ptr, i160 } %62, 0
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %4) #35
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #35
  %66 = load i1, ptr %28, align 1
  br i1 %66, label %67, label %File_close_.exit.i

67:                                               ; preds = %3
  %68 = load ptr, ptr %55, align 8
  %69 = insertvalue { ptr } undef, ptr %68, 0
  %70 = call i32 @fclose({ ptr } %69) #7
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 160, ptr nocapture nofree noundef nonnull @File) #41
  store i1 false, ptr %28, align 1
  %72 = icmp eq i32 %70, -1
  br i1 %72, label %73, label %File_close_.exit.i

73:                                               ; preds = %67
  %result.i35.i.i = call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  %result.i.i.i.i = call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i.i.i, align 8
  %result.i29.i.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i.i.i.i, ptr %result.i29.i.i.i, align 8
  %74 = getelementptr i8, ptr %result.i29.i.i.i, i64 8
  store i32 6, ptr %74, align 4
  %75 = getelementptr i8, ptr %result.i29.i.i.i, i64 12
  store i32 7, ptr %75, align 4
  %76 = getelementptr i8, ptr %result.i35.i.i, i64 40
  store ptr @String, ptr %76, align 8
  %77 = getelementptr i8, ptr %result.i35.i.i, i64 48
  store ptr %result.i29.i.i.i, ptr %77, align 8
  %78 = getelementptr i8, ptr %result.i35.i.i, i64 64
  store i32 10, ptr %78, align 4
  %79 = getelementptr i8, ptr %result.i35.i.i, i64 8
  %80 = getelementptr i8, ptr %result.i35.i.i, i64 16
  %81 = getelementptr i8, ptr %result.i35.i.i, i64 32
  %result.i37.i.i = call noalias align 16 dereferenceable_or_null(11) ptr @bump_malloc_inner(i64 noundef 11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store <10 x i8> <i8 102, i8 105, i8 108, i8 101, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i37.i.i, align 16
  %result.i39.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  store ptr %result.i37.i.i, ptr %result.i39.i.i, align 8
  %82 = getelementptr i8, ptr %result.i39.i.i, i64 8
  store i32 10, ptr %82, align 4
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 632, ptr nocapture nofree noundef nonnull @String) #35
  %84 = getelementptr i8, ptr %result.i39.i.i, i64 12
  store i32 11, ptr %84, align 4
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 208, ptr nocapture nofree noundef nonnull align 16 dereferenceable(288) @FileSystemError)
  store i32 47, ptr %result.i35.i.i, align 4
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @FileSystemError) #35
  store ptr @String, ptr %79, align 8
  store ptr %result.i39.i.i, ptr %80, align 8
  store i32 10, ptr %81, align 4
  %87 = ptrtoint ptr %result.i35.i.i to i64
  %.sroa.424.8.insert.ext.i.i = zext i64 %87 to i160
  %.sroa.424.8.insert.insert.i.i = or disjoint i160 %.sroa.424.8.insert.ext.i.i, 3402823669209384634633746074317682114560
  %88 = insertvalue { ptr, i160 } { ptr @FileSystemError, i160 undef }, i160 %.sroa.424.8.insert.insert.i.i, 1
  %current_coroutine.i.i.i = load ptr, ptr @current_coroutine, align 8
  %89 = getelementptr i8, ptr %current_coroutine.i.i.i, i64 48
  store { ptr, i160 } %88, ptr %89, align 8
  %into_callee_buf.i.i.i = getelementptr i8, ptr %current_coroutine.i.i.i, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i.i.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %File_close_.exit.i

File_close_.exit.i:                               ; preds = %73, %67, %3
  %90 = getelementptr i8, ptr %.fca.0.extract.i, i64 8
  %91 = getelementptr i8, ptr %.fca.0.extract.i, i64 16
  %92 = getelementptr i8, ptr %.fca.0.extract.i, i64 24
  %93 = getelementptr i8, ptr %.fca.0.extract.i, i64 32
  %94 = load i64, ptr %90, align 4
  %95 = load i64, ptr %91, align 4
  %96 = load ptr, ptr %92, align 8
  %97 = load ptr, ptr %93, align 8
  %result.i133.i = call i1 %96(i64 %95, i64 %94, i64 9027164862567808692, i64 ptrtoint (ptr @Exception to i64), ptr readonly %97) #5
  br i1 %result.i133.i, label %98, label %FileSystem__Self_process_file_file_nameString_modeString_processorFileProcessorT.exit

98:                                               ; preds = %File_close_.exit.i
  %.fca.1.extract.i = extractvalue { ptr, i160 } %62, 1
  %offset_tbl_ptr.i.i137.i = getelementptr i8, ptr %.fca.0.extract.i, i64 40
  %offset_tbl.i.i140.i = load ptr, ptr %offset_tbl_ptr.i.i137.i, align 8, !noalias !1061
  %product.i.i.i141.i = mul i64 %94, 9027164862567808692
  %shifted.i.i.i142.i = lshr i64 %product.i.i.i141.i, 32
  %xored.i.i.i143.i = xor i64 %shifted.i.i.i142.i, %product.i.i.i141.i
  %hash.i.i.i144.i = and i64 %xored.i.i.i143.i, %95
  %offset_ptr.i.i145.i = getelementptr i32, ptr %offset_tbl.i.i140.i, i64 %hash.i.i.i144.i
  %offset.i.i146.i = load i32, ptr %offset_ptr.i.i145.i, align 4, !noalias !1061
  %99 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract.i, 0
  %.sroa.5168.8.insert.ext.i = zext i32 %offset.i.i146.i to i160
  %.sroa.5168.8.insert.shift.i = shl nuw i160 %.sroa.5168.8.insert.ext.i, 128
  %.sroa.3167.8.insert.ext.i = and i160 %.fca.1.extract.i, 340282366920938463463374607431768211455
  %.sroa.3167.8.insert.insert.i = or disjoint i160 %.sroa.5168.8.insert.shift.i, %.sroa.3167.8.insert.ext.i
  %100 = insertvalue { ptr, i160 } %99, i160 %.sroa.3167.8.insert.insert.i, 1
  %current_coroutine.i.i = load ptr, ptr @current_coroutine, align 8
  %101 = getelementptr i8, ptr %current_coroutine.i.i, i64 48
  store { ptr, i160 } %100, ptr %101, align 8
  %into_callee_buf.i148.i = getelementptr i8, ptr %current_coroutine.i.i, i64 8
  call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i148.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  br label %FileSystem__Self_process_file_file_nameString_modeString_processorFileProcessorT.exit

FileSystem__Self_process_file_file_nameString_modeString_processorFileProcessorT.exit: ; preds = %File_close_.exit.i, %98
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 56, ptr nocapture nofree noundef nonnull @FileWriter)
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @_functionliteral_ujbvsloqoy({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %.fca.3.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 3
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1064
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1064
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1064
  %product.i.i.i = mul i64 %hash_coef.i.i, -2227788838181535664
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1064
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract4, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i, 3
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract7, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract8, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract9, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %.fca.3.extract10, 3
  %11 = alloca [1 x ptr], align 8
  store ptr @_parameterization_File, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract7) #35
  %14 = sext i32 %.fca.3.extract10 to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract7, i64 %14
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = alloca { ptr }, align 8
  store ptr %.fca.0.extract3, ptr %18, align 8
  %result.i = call ptr %17({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %18) #16
  %19 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %6) #7
  ret { ptr, i160 } %19
}

define void @coroutine_muarwmssow_passer(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) {
  %2 = getelementptr i8, ptr %0, i64 80
  %3 = getelementptr i8, ptr %0, i64 112
  %4 = load { ptr, ptr, ptr, i32 }, ptr %2, align 8
  %5 = load { ptr, ptr, ptr, i32 }, ptr %3, align 8
  %6 = load ptr, ptr %0, align 8
  %7 = tail call { ptr, i160 } %6({ ptr, ptr, ptr, i32 } %4, { ptr, ptr, ptr, i32 } %5)
  %8 = getelementptr i8, ptr %0, i64 48
  store { ptr, i160 } %7, ptr %8, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @coroutine_muarwmssow_buffer_filler(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1, { ptr, ptr, ptr, i32 } %2) local_unnamed_addr #6 {
  %4 = getelementptr i8, ptr %0, i64 80
  %5 = getelementptr i8, ptr %0, i64 112
  store { ptr, ptr, ptr, i32 } %1, ptr %4, align 8
  store { ptr, ptr, ptr, i32 } %2, ptr %5, align 8
  ret void
}

define void @coroutine_uppkywgipx_passer(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) {
  %2 = getelementptr i8, ptr %0, i64 80
  %3 = load { ptr, ptr, ptr, i32 }, ptr %2, align 8
  %4 = load ptr, ptr %0, align 8
  %5 = tail call { ptr, i160 } %4({ ptr, ptr, ptr, i32 } %3)
  %6 = getelementptr i8, ptr %0, i64 48
  store { ptr, i160 } %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @coroutine_uppkywgipx_buffer_filler(ptr nocapture nofree writeonly align 8 %0, { ptr, ptr, ptr, i32 } %1) local_unnamed_addr #6 {
  %3 = getelementptr i8, ptr %0, i64 80
  store { ptr, ptr, ptr, i32 } %1, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FileProcessor_field_FileProcessor_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FileProcessor_B_process_fileFile({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #35
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 96
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define ptr @typegetter_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #20 {
  %result = tail call ptr %f(ptr nocapture nofree noundef nonnull readonly %0) #5
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { i64, i64 } @size_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0) local_unnamed_addr #20 {
  %result = tail call { i64, i64 } %f(ptr nocapture nofree readonly %0) #5
  ret { i64, i64 } %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { ptr, i160 } @box_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) local_unnamed_addr #20 {
  %result = tail call { ptr, i160 } %f(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5
  ret { ptr, i160 } %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @unbox_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) local_unnamed_addr #21 {
  tail call void %f({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull readonly %1) local_unnamed_addr #22 {
  %result = tail call ptr %f({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #16
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @class_behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #22 {
  %result = tail call ptr %f(ptr nocapture nofree noundef nonnull %0) #16
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @adjust_trampoline(ptr nofree readonly %tramp) local_unnamed_addr #5 {
  %ret = tail call ptr @llvm.adjust.trampoline(ptr nofree readonly %tramp) #40
  ret ptr %ret
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #23

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none)
define noalias ptr @bump_malloc(i64 noundef %size) local_unnamed_addr #24 {
  %result = tail call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #38
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %current_ptr) local_unnamed_addr #25 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  ret ptr %current
}

define { i64, i64 } @_data_size_tuple_typ(ptr nocapture nofree readonly align 4 %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %1, %.lr.ph
  %.reg2mem20.010.reg2mem.0 = phi i64 [ %12, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011.reg2mem.0 = phi i64 [ %18, %.lr.ph ], [ 0, %1 ]
  %.reg2mem14.0 = phi i64 [ %19, %.lr.ph ], [ 1, %1 ]
  %.in.reg2mem.0 = phi i64 [ %21, %.lr.ph ], [ %3, %1 ]
  %5 = inttoptr i64 %.in.reg2mem.0 to ptr
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr i8, ptr %6, i64 72
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { i64, i64 } %8(ptr nonnull align 8 %5)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = extractvalue { i64, i64 } %9, 1
  %12 = tail call i64 @llvm.umax.i64(i64 %11, i64 %.reg2mem20.010.reg2mem.0)
  %13 = urem i64 %.reg2mem22.011.reg2mem.0, %11
  %14 = icmp eq i64 %13, 0
  %15 = sub i64 %11, %13
  %16 = select i1 %14, i64 0, i64 %15
  %17 = add i64 %10, %.reg2mem22.011.reg2mem.0
  %18 = add i64 %17, %16
  %19 = add i64 %.reg2mem14.0, 1
  %20 = getelementptr ptr, ptr %0, i64 %19
  %21 = load i64, ptr %20, align 4
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem22.0.lcssa.reg2mem.0 = phi i64 [ 0, %1 ], [ %18, %.lr.ph ]
  %.reg2mem20.0.lcssa.reg2mem.0 = phi i64 [ 1, %1 ], [ %12, %.lr.ph ]
  %23 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0, %.reg2mem20.0.lcssa.reg2mem.0
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = add i64 %26, %.reg2mem22.0.lcssa.reg2mem.0
  %28 = insertvalue { i64, i64 } undef, i64 %27, 0
  %29 = insertvalue { i64, i64 } %28, i64 %.reg2mem20.0.lcssa.reg2mem.0, 1
  ret { i64, i64 } %29
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #18

define { i64, i64 } @_data_size_union_typ(ptr nocapture nofree readonly align 4 %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge.thread, label %.lr.ph

.lr.ph:                                           ; preds = %1, %.lr.ph
  %.reg2mem20.010.reg2mem.0 = phi i64 [ %12, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011.reg2mem.0 = phi i64 [ %18, %.lr.ph ], [ 0, %1 ]
  %.reg2mem14.0 = phi i64 [ %19, %.lr.ph ], [ 1, %1 ]
  %.in.reg2mem.0 = phi i64 [ %21, %.lr.ph ], [ %3, %1 ]
  %5 = inttoptr i64 %.in.reg2mem.0 to ptr
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr i8, ptr %6, i64 72
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { i64, i64 } %8(ptr nonnull align 8 %5)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = extractvalue { i64, i64 } %9, 1
  %12 = tail call i64 @llvm.umax.i64(i64 noundef %11, i64 noundef %.reg2mem20.010.reg2mem.0)
  %13 = urem i64 %.reg2mem22.011.reg2mem.0, %11
  %14 = icmp eq i64 %13, 0
  %15 = sub i64 %11, %13
  %16 = select i1 %14, i64 0, i64 %15
  %17 = add i64 %10, %.reg2mem22.011.reg2mem.0
  %18 = tail call i64 @llvm.umax.i64(i64 noundef %17, i64 noundef %16)
  %19 = add i64 %.reg2mem14.0, 1
  %20 = getelementptr ptr, ptr %0, i64 %19
  %21 = load i64, ptr %20, align 4
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph
  %right_size = icmp eq i64 %18, 32
  %spec.select12 = select i1 %right_size, i64 0, i64 8
  %23 = add i64 %spec.select12, %18
  br label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %1
  %.reg2mem20.0.lcssa.reg2mem.011 = phi i64 [ 1, %1 ], [ %12, %._crit_edge ]
  %final_size = phi i64 [ 8, %1 ], [ %23, %._crit_edge ]
  %24 = urem i64 %final_size, %.reg2mem20.0.lcssa.reg2mem.011
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %.reg2mem20.0.lcssa.reg2mem.011, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %27, %final_size
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa.reg2mem.011, 1
  ret { i64, i64 } %30
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr nocapture nofree readonly align 4 %1, ptr nocapture nofree writeonly %2) {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %3, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %3 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %3 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 noundef %14, i64 noundef %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = tail call i64 @llvm.umax.i64(i64 noundef %20, i64 noundef %19)
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %21, 32
  %spec.select12.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select12.i, %21
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %3, %._crit_edge.i
  %.reg2mem20.0.lcssa.reg2mem.011.i = phi i64 [ 1, %3 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %3 ], [ %26, %._crit_edge.i ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %final_size.i, %.reg2mem20.0.lcssa.reg2mem.011.i
  %30 = icmp eq i64 %29, 0
  %31 = sub i64 %.reg2mem20.0.lcssa.reg2mem.011.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add i64 %32, %final_size.i
  %34 = icmp slt i64 %33, 17
  %35 = icmp eq i64 %33, 32
  %36 = select i1 %34, ptr %.fca.1.gep, ptr %28
  %37 = select i1 %35, ptr %4, ptr %36
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %37, i64 %33, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Default(ptr nocapture nofree readnone %parameterization) #0 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_Default(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %fat_ptr, ptr nocapture nofree readnone %parameterization) #5 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr inbounds i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr nocapture nofree readnone %parameterization, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %destination) #6 {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr inbounds i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 8
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr nofree %tramp) local_unnamed_addr #26 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr nofree %tramp, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect) #26
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) local_unnamed_addr #26

define noundef nonnull align 8 dereferenceable(16) ptr @coroutine_create(ptr nofree %func, ptr nofree %arg_passer) local_unnamed_addr {
  %stack = tail call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #44
  store ptr %func, ptr %stack, align 8
  %stack_top = getelementptr inbounds i8, ptr %stack, i64 8388608
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr inbounds i8, ptr %stack, i64 8
  %arg_passer_slot = getelementptr inbounds i8, ptr %stack, i64 32
  %into_callee_second_word = getelementptr inbounds i8, ptr %stack, i64 16
  %into_callee_third_word = getelementptr inbounds i8, ptr %stack, i64 24
  store i64 %stack_top_aligned, ptr %into_callee_buf, align 8
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 8
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr inbounds i8, ptr %stack, i64 40
  store i1 false, ptr %is_finished, align 8
  tail call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word)
  ret ptr %stack
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare noalias ptr @VirtualAlloc(ptr, i64, i32, i32) local_unnamed_addr #27

declare void @coroutine_trampoline(ptr) local_unnamed_addr

define void @setup_landing_pad() {
  %region = tail call noalias dereferenceable_or_null(5368709120) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 5368709120, i32 noundef 12288, i32 noundef 4) #44
  store ptr %region, ptr @current_ptr, align 8
  %sp = tail call ptr @llvm.stacksave.p0() #9
  store ptr %sp, ptr @into_caller_buf, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %sp, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %stack.i = tail call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #44
  store ptr @setup_landing_pad, ptr %stack.i, align 8
  %stack_top.i = getelementptr inbounds i8, ptr %stack.i, i64 8388608
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr inbounds i8, ptr %stack.i, i64 8
  %arg_passer_slot.i = getelementptr inbounds i8, ptr %stack.i, i64 32
  %into_callee_second_word.i = getelementptr inbounds i8, ptr %stack.i, i64 16
  %into_callee_third_word.i = getelementptr inbounds i8, ptr %stack.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 8
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 8
  store ptr @arg_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr inbounds i8, ptr %stack.i, i64 40
  store i1 false, ptr %is_finished.i, align 8
  tail call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word.i)
  store ptr %stack.i, ptr @current_coroutine, align 8
  %retval.i = load i1, ptr @always_one, align 1
  br i1 %retval.i, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = tail call i32 @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @string_string.113, ptr nofree noundef nonnull align 16 dereferenceable(45) @exception_message) #7
  %cc.unpack = load ptr, ptr @current_coroutine, align 8
  %cc1 = insertvalue { ptr } poison, ptr %cc.unpack, 0
  tail call void @report_exception({ ptr } %cc1) #7
  tail call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #28

define void @arg_passer(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %current_coroutine) {
  %func = load ptr, ptr %current_coroutine, align 8
  tail call void %func()
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define i1 @returns_one() local_unnamed_addr #29 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

declare void @exit() local_unnamed_addr

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define i32 @get_offset(ptr nocapture nofree readonly align 8 %vptr, ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(8) %id_ptr) local_unnamed_addr #16 {
  %id = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr = getelementptr i8, ptr %vptr, i64 40
  %hash_coef = load i64, ptr %hash_coef_ptr, align 8
  %tbl_size = load i64, ptr %tbl_size_ptr, align 8
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %product.i = mul i64 %hash_coef, %id
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %hash.i
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) local_unnamed_addr #0 {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %shifted, %product
  %hash = and i64 %xored, %tbl_size
  ret i64 %hash
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @assume_offset(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readonly align 4 %id_ptr) local_unnamed_addr #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @set_offset(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readonly align 4 %id_ptr) local_unnamed_addr #1 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id.i = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr.i = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %vptr, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, %id.i
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %destination = getelementptr i8, ptr %fat_ptr, i64 24
  store i32 %offset.i, ptr %destination, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nocapture nofree readonly %supertype_tbl) #20 {
  %product.i = mul i64 %cand_id, %hash_coef
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash.i
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr nocapture nofree noundef nonnull readonly %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nofree readonly %supertype_tbl) local_unnamed_addr #20 {
  %result = tail call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #5
  ret i1 %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @arg_buffer_filler(ptr nocapture nofree readnone %coroutine) local_unnamed_addr #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define ptr @get_current_coroutine() local_unnamed_addr #29 {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %from_buf, ptr %to_buf) #30 {
  %from_buf_second_word = getelementptr inbounds i8, ptr %from_buf, i64 8
  %from_buf_third_word = getelementptr inbounds i8, ptr %from_buf, i64 16
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = tail call ptr @llvm.stacksave.p0() #9
  store ptr %sp, ptr %from_buf, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %retval.i = load i1, ptr @always_one, align 1
  br i1 %retval.i, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  tail call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #31
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #31

; Function Attrs: nounwind
define void @coroutine_yield(ptr nocapture nofree writeonly align 8 %current_coroutine) local_unnamed_addr #7 {
  %into_callee_buf = getelementptr i8, ptr %current_coroutine, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #42
  ret void
}

; Function Attrs: nounwind
define void @coroutine_call(ptr %coroutine) local_unnamed_addr #7 {
  %old_into_caller.unpack = load ptr, ptr @into_caller_buf, align 8
  %old_into_caller.unpack1 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  %old_into_caller.unpack2 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr i8, ptr %coroutine, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr %into_callee_buf) #42
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store ptr %old_into_caller.unpack, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack1, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %old_into_caller.unpack2, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #17

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #32

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #32

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #33

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #33

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #34

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #2 = { mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none) }
attributes #3 = { mustprogress nounwind willreturn }
attributes #4 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
attributes #7 = { nounwind }
attributes #8 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #9 = { mustprogress nofree nosync nounwind willreturn }
attributes #10 = { mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #11 = { mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) }
attributes #12 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) }
attributes #13 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) }
attributes #14 = { nofree norecurse nosync nounwind memory(readwrite, argmem: read, inaccessiblemem: none) }
attributes #15 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: read, inaccessiblemem: none) }
attributes #16 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #17 = { nofree nounwind }
attributes #18 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #19 = { mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #20 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) }
attributes #21 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #22 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none) }
attributes #23 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #24 = { mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none) "alloc-family"="malloc" }
attributes #25 = { mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite) "alloc-family"="malloc" }
attributes #26 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #27 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #28 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #29 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) }
attributes #30 = { noinline nounwind memory(readwrite) }
attributes #31 = { noreturn nounwind }
attributes #32 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #33 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #34 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #35 = { nofree willreturn }
attributes #36 = { nounwind willreturn memory(argmem: readwrite) }
attributes #37 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #38 = { mustprogress nofree nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #39 = { nofree }
attributes #40 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #41 = { willreturn }
attributes #42 = { nounwind memory(readwrite) }
attributes #43 = { nofree nosync willreturn }
attributes #44 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(1) "alloc-family"="malloc" }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{!2}
!2 = distinct !{!2, !3, !"set_offset: %fat_ptr"}
!3 = distinct !{!3, !"set_offset"}
!4 = !{!5}
!5 = distinct !{!5, !6, !"set_offset: %fat_ptr"}
!6 = distinct !{!6, !"set_offset"}
!7 = !{!8}
!8 = distinct !{!8, !9, !"set_offset: %fat_ptr"}
!9 = distinct !{!9, !"set_offset"}
!10 = !{!11}
!11 = distinct !{!11, !12, !"set_offset: %fat_ptr"}
!12 = distinct !{!12, !"set_offset"}
!13 = !{!14}
!14 = distinct !{!14, !15, !"size_wrapper: argument 0"}
!15 = distinct !{!15, !"size_wrapper"}
!16 = !{!17}
!17 = distinct !{!17, !18, !"set_offset: %fat_ptr"}
!18 = distinct !{!18, !"set_offset"}
!19 = !{!20}
!20 = distinct !{!20, !21, !"size_wrapper: argument 0"}
!21 = distinct !{!21, !"size_wrapper"}
!22 = !{}
!23 = !{!24}
!24 = distinct !{!24, !25, !"set_offset: %fat_ptr"}
!25 = distinct !{!25, !"set_offset"}
!26 = !{!27}
!27 = distinct !{!27, !28, !"set_offset: %fat_ptr"}
!28 = distinct !{!28, !"set_offset"}
!29 = !{!30}
!30 = distinct !{!30, !31, !"set_offset: %fat_ptr"}
!31 = distinct !{!31, !"set_offset"}
!32 = !{!33}
!33 = distinct !{!33, !34, !"set_offset: %fat_ptr"}
!34 = distinct !{!34, !"set_offset"}
!35 = !{!36}
!36 = distinct !{!36, !37, !"set_offset: %fat_ptr"}
!37 = distinct !{!37, !"set_offset"}
!38 = !{!39}
!39 = distinct !{!39, !40, !"set_offset: %fat_ptr"}
!40 = distinct !{!40, !"set_offset"}
!41 = !{!42}
!42 = distinct !{!42, !43, !"set_offset: %fat_ptr"}
!43 = distinct !{!43, !"set_offset"}
!44 = !{!45}
!45 = distinct !{!45, !46, !"set_offset: %fat_ptr"}
!46 = distinct !{!46, !"set_offset"}
!47 = !{!48}
!48 = distinct !{!48, !49, !"set_offset: %fat_ptr"}
!49 = distinct !{!49, !"set_offset"}
!50 = !{!51}
!51 = distinct !{!51, !52, !"set_offset: %fat_ptr"}
!52 = distinct !{!52, !"set_offset"}
!53 = !{!54}
!54 = distinct !{!54, !55, !"size_wrapper: argument 0"}
!55 = distinct !{!55, !"size_wrapper"}
!56 = !{!57}
!57 = distinct !{!57, !58, !"set_offset: %fat_ptr"}
!58 = distinct !{!58, !"set_offset"}
!59 = !{!60}
!60 = distinct !{!60, !61, !"size_wrapper: argument 0"}
!61 = distinct !{!61, !"size_wrapper"}
!62 = !{!63}
!63 = distinct !{!63, !64, !"set_offset: %fat_ptr"}
!64 = distinct !{!64, !"set_offset"}
!65 = !{!66}
!66 = distinct !{!66, !67, !"set_offset: %fat_ptr"}
!67 = distinct !{!67, !"set_offset"}
!68 = !{!69}
!69 = distinct !{!69, !70, !"set_offset: %fat_ptr"}
!70 = distinct !{!70, !"set_offset"}
!71 = !{!72}
!72 = distinct !{!72, !73, !"set_offset: %fat_ptr"}
!73 = distinct !{!73, !"set_offset"}
!74 = !{!75}
!75 = distinct !{!75, !76, !"set_offset: %fat_ptr"}
!76 = distinct !{!76, !"set_offset"}
!77 = !{!78}
!78 = distinct !{!78, !79, !"set_offset: %fat_ptr"}
!79 = distinct !{!79, !"set_offset"}
!80 = !{!81}
!81 = distinct !{!81, !82, !"set_offset: %fat_ptr"}
!82 = distinct !{!82, !"set_offset"}
!83 = !{!84}
!84 = distinct !{!84, !85, !"set_offset: %fat_ptr"}
!85 = distinct !{!85, !"set_offset"}
!86 = !{!87}
!87 = distinct !{!87, !88, !"size_wrapper: argument 0"}
!88 = distinct !{!88, !"size_wrapper"}
!89 = !{!90}
!90 = distinct !{!90, !91, !"set_offset: %fat_ptr"}
!91 = distinct !{!91, !"set_offset"}
!92 = !{!93}
!93 = distinct !{!93, !94, !"size_wrapper: argument 0"}
!94 = distinct !{!94, !"size_wrapper"}
!95 = !{!96}
!96 = distinct !{!96, !97, !"set_offset: %fat_ptr"}
!97 = distinct !{!97, !"set_offset"}
!98 = !{!99}
!99 = distinct !{!99, !100, !"set_offset: %fat_ptr"}
!100 = distinct !{!100, !"set_offset"}
!101 = !{!102}
!102 = distinct !{!102, !103, !"set_offset: %fat_ptr"}
!103 = distinct !{!103, !"set_offset"}
!104 = !{!105}
!105 = distinct !{!105, !106, !"set_offset: %fat_ptr"}
!106 = distinct !{!106, !"set_offset"}
!107 = !{!108}
!108 = distinct !{!108, !109, !"set_offset: %fat_ptr"}
!109 = distinct !{!109, !"set_offset"}
!110 = !{!111}
!111 = distinct !{!111, !112, !"set_offset: %fat_ptr"}
!112 = distinct !{!112, !"set_offset"}
!113 = !{!114}
!114 = distinct !{!114, !115, !"set_offset: %fat_ptr"}
!115 = distinct !{!115, !"set_offset"}
!116 = !{!117}
!117 = distinct !{!117, !118, !"set_offset: %fat_ptr"}
!118 = distinct !{!118, !"set_offset"}
!119 = !{!120}
!120 = distinct !{!120, !121, !"set_offset: %fat_ptr"}
!121 = distinct !{!121, !"set_offset"}
!122 = !{!123}
!123 = distinct !{!123, !124, !"set_offset: %fat_ptr"}
!124 = distinct !{!124, !"set_offset"}
!125 = !{!126}
!126 = distinct !{!126, !127, !"size_wrapper: argument 0"}
!127 = distinct !{!127, !"size_wrapper"}
!128 = !{!129}
!129 = distinct !{!129, !130, !"set_offset: %fat_ptr"}
!130 = distinct !{!130, !"set_offset"}
!131 = !{!132}
!132 = distinct !{!132, !133, !"size_wrapper: argument 0"}
!133 = distinct !{!133, !"size_wrapper"}
!134 = !{!135}
!135 = distinct !{!135, !136, !"set_offset: %fat_ptr"}
!136 = distinct !{!136, !"set_offset"}
!137 = !{!138}
!138 = distinct !{!138, !139, !"set_offset: %fat_ptr"}
!139 = distinct !{!139, !"set_offset"}
!140 = !{!141}
!141 = distinct !{!141, !142, !"set_offset: %fat_ptr"}
!142 = distinct !{!142, !"set_offset"}
!143 = !{!144}
!144 = distinct !{!144, !145, !"set_offset: %fat_ptr"}
!145 = distinct !{!145, !"set_offset"}
!146 = !{!147}
!147 = distinct !{!147, !148, !"set_offset: %fat_ptr"}
!148 = distinct !{!148, !"set_offset"}
!149 = !{!150}
!150 = distinct !{!150, !151, !"set_offset: %fat_ptr"}
!151 = distinct !{!151, !"set_offset"}
!152 = !{!153}
!153 = distinct !{!153, !154, !"set_offset: %fat_ptr"}
!154 = distinct !{!154, !"set_offset"}
!155 = !{!156}
!156 = distinct !{!156, !157, !"set_offset: %fat_ptr"}
!157 = distinct !{!157, !"set_offset"}
!158 = !{!159}
!159 = distinct !{!159, !160, !"set_offset: %fat_ptr"}
!160 = distinct !{!160, !"set_offset"}
!161 = !{!162}
!162 = distinct !{!162, !163, !"set_offset: %fat_ptr"}
!163 = distinct !{!163, !"set_offset"}
!164 = !{!165}
!165 = distinct !{!165, !166, !"set_offset: %fat_ptr"}
!166 = distinct !{!166, !"set_offset"}
!167 = !{!168}
!168 = distinct !{!168, !169, !"set_offset: %fat_ptr"}
!169 = distinct !{!169, !"set_offset"}
!170 = !{!171}
!171 = distinct !{!171, !172, !"size_wrapper: argument 0"}
!172 = distinct !{!172, !"size_wrapper"}
!173 = !{!174}
!174 = distinct !{!174, !175, !"set_offset: %fat_ptr"}
!175 = distinct !{!175, !"set_offset"}
!176 = !{!177}
!177 = distinct !{!177, !178, !"size_wrapper: argument 0"}
!178 = distinct !{!178, !"size_wrapper"}
!179 = !{!180}
!180 = distinct !{!180, !181, !"set_offset: %fat_ptr"}
!181 = distinct !{!181, !"set_offset"}
!182 = !{!183}
!183 = distinct !{!183, !184, !"set_offset: %fat_ptr"}
!184 = distinct !{!184, !"set_offset"}
!185 = !{!186}
!186 = distinct !{!186, !187, !"set_offset: %fat_ptr"}
!187 = distinct !{!187, !"set_offset"}
!188 = !{!189}
!189 = distinct !{!189, !190, !"set_offset: %fat_ptr"}
!190 = distinct !{!190, !"set_offset"}
!191 = !{!192}
!192 = distinct !{!192, !193, !"set_offset: %fat_ptr"}
!193 = distinct !{!193, !"set_offset"}
!194 = !{!195}
!195 = distinct !{!195, !196, !"set_offset: %fat_ptr"}
!196 = distinct !{!196, !"set_offset"}
!197 = !{!198}
!198 = distinct !{!198, !199, !"set_offset: %fat_ptr"}
!199 = distinct !{!199, !"set_offset"}
!200 = !{!201}
!201 = distinct !{!201, !202, !"set_offset: %fat_ptr"}
!202 = distinct !{!202, !"set_offset"}
!203 = !{!204}
!204 = distinct !{!204, !205, !"size_wrapper: argument 0"}
!205 = distinct !{!205, !"size_wrapper"}
!206 = !{!207}
!207 = distinct !{!207, !208, !"set_offset: %fat_ptr"}
!208 = distinct !{!208, !"set_offset"}
!209 = !{!210}
!210 = distinct !{!210, !211, !"size_wrapper: argument 0"}
!211 = distinct !{!211, !"size_wrapper"}
!212 = !{!213}
!213 = distinct !{!213, !214, !"set_offset: %fat_ptr"}
!214 = distinct !{!214, !"set_offset"}
!215 = !{!216}
!216 = distinct !{!216, !217, !"set_offset: %fat_ptr"}
!217 = distinct !{!217, !"set_offset"}
!218 = !{!219}
!219 = distinct !{!219, !220, !"set_offset: %fat_ptr"}
!220 = distinct !{!220, !"set_offset"}
!221 = !{!222}
!222 = distinct !{!222, !223, !"set_offset: %fat_ptr"}
!223 = distinct !{!223, !"set_offset"}
!224 = !{!225}
!225 = distinct !{!225, !226, !"set_offset: %fat_ptr"}
!226 = distinct !{!226, !"set_offset"}
!227 = !{!228}
!228 = distinct !{!228, !229, !"set_offset: %fat_ptr"}
!229 = distinct !{!229, !"set_offset"}
!230 = !{!231}
!231 = distinct !{!231, !232, !"set_offset: %fat_ptr"}
!232 = distinct !{!232, !"set_offset"}
!233 = !{!234}
!234 = distinct !{!234, !235, !"set_offset: %fat_ptr"}
!235 = distinct !{!235, !"set_offset"}
!236 = !{!237}
!237 = distinct !{!237, !238, !"set_offset: %fat_ptr"}
!238 = distinct !{!238, !"set_offset"}
!239 = !{!240}
!240 = distinct !{!240, !241, !"set_offset: %fat_ptr"}
!241 = distinct !{!241, !"set_offset"}
!242 = !{!243}
!243 = distinct !{!243, !244, !"set_offset: %fat_ptr"}
!244 = distinct !{!244, !"set_offset"}
!245 = !{!246}
!246 = distinct !{!246, !247, !"set_offset: %fat_ptr"}
!247 = distinct !{!247, !"set_offset"}
!248 = !{!249}
!249 = distinct !{!249, !250, !"size_wrapper: argument 0"}
!250 = distinct !{!250, !"size_wrapper"}
!251 = !{!252}
!252 = distinct !{!252, !253, !"set_offset: %fat_ptr"}
!253 = distinct !{!253, !"set_offset"}
!254 = !{!255}
!255 = distinct !{!255, !256, !"size_wrapper: argument 0"}
!256 = distinct !{!256, !"size_wrapper"}
!257 = !{!258}
!258 = distinct !{!258, !259, !"set_offset: %fat_ptr"}
!259 = distinct !{!259, !"set_offset"}
!260 = !{!261}
!261 = distinct !{!261, !262, !"set_offset: %fat_ptr"}
!262 = distinct !{!262, !"set_offset"}
!263 = !{!264}
!264 = distinct !{!264, !265, !"set_offset: %fat_ptr"}
!265 = distinct !{!265, !"set_offset"}
!266 = !{!267}
!267 = distinct !{!267, !268, !"set_offset: %fat_ptr"}
!268 = distinct !{!268, !"set_offset"}
!269 = !{!270}
!270 = distinct !{!270, !271, !"set_offset: %fat_ptr"}
!271 = distinct !{!271, !"set_offset"}
!272 = !{!273}
!273 = distinct !{!273, !274, !"set_offset: %fat_ptr"}
!274 = distinct !{!274, !"set_offset"}
!275 = !{!276}
!276 = distinct !{!276, !277, !"set_offset: %fat_ptr"}
!277 = distinct !{!277, !"set_offset"}
!278 = !{!279}
!279 = distinct !{!279, !280, !"set_offset: %fat_ptr"}
!280 = distinct !{!280, !"set_offset"}
!281 = !{!282}
!282 = distinct !{!282, !283, !"size_wrapper: argument 0"}
!283 = distinct !{!283, !"size_wrapper"}
!284 = !{!285}
!285 = distinct !{!285, !286, !"set_offset: %fat_ptr"}
!286 = distinct !{!286, !"set_offset"}
!287 = !{!288}
!288 = distinct !{!288, !289, !"size_wrapper: argument 0"}
!289 = distinct !{!289, !"size_wrapper"}
!290 = !{!291}
!291 = distinct !{!291, !292, !"set_offset: %fat_ptr"}
!292 = distinct !{!292, !"set_offset"}
!293 = !{!294}
!294 = distinct !{!294, !295, !"set_offset: %fat_ptr"}
!295 = distinct !{!295, !"set_offset"}
!296 = !{!297}
!297 = distinct !{!297, !298, !"set_offset: %fat_ptr"}
!298 = distinct !{!298, !"set_offset"}
!299 = !{!300}
!300 = distinct !{!300, !301, !"set_offset: %fat_ptr"}
!301 = distinct !{!301, !"set_offset"}
!302 = !{!303}
!303 = distinct !{!303, !304, !"set_offset: %fat_ptr"}
!304 = distinct !{!304, !"set_offset"}
!305 = !{!306}
!306 = distinct !{!306, !307, !"set_offset: %fat_ptr"}
!307 = distinct !{!307, !"set_offset"}
!308 = !{!309}
!309 = distinct !{!309, !310, !"set_offset: %fat_ptr"}
!310 = distinct !{!310, !"set_offset"}
!311 = !{!312}
!312 = distinct !{!312, !313, !"set_offset: %fat_ptr"}
!313 = distinct !{!313, !"set_offset"}
!314 = !{!315}
!315 = distinct !{!315, !316, !"set_offset: %fat_ptr"}
!316 = distinct !{!316, !"set_offset"}
!317 = !{!318}
!318 = distinct !{!318, !319, !"set_offset: %fat_ptr"}
!319 = distinct !{!319, !"set_offset"}
!320 = !{!321}
!321 = distinct !{!321, !322, !"set_offset: %fat_ptr"}
!322 = distinct !{!322, !"set_offset"}
!323 = !{!324}
!324 = distinct !{!324, !325, !"set_offset: %fat_ptr"}
!325 = distinct !{!325, !"set_offset"}
!326 = !{!327}
!327 = distinct !{!327, !328, !"set_offset: %fat_ptr"}
!328 = distinct !{!328, !"set_offset"}
!329 = !{!330}
!330 = distinct !{!330, !331, !"set_offset: %fat_ptr"}
!331 = distinct !{!331, !"set_offset"}
!332 = !{!333}
!333 = distinct !{!333, !334, !"size_wrapper: argument 0"}
!334 = distinct !{!334, !"size_wrapper"}
!335 = !{!336}
!336 = distinct !{!336, !337, !"set_offset: %fat_ptr"}
!337 = distinct !{!337, !"set_offset"}
!338 = !{!339}
!339 = distinct !{!339, !340, !"size_wrapper: argument 0"}
!340 = distinct !{!340, !"size_wrapper"}
!341 = !{!342}
!342 = distinct !{!342, !343, !"set_offset: %fat_ptr"}
!343 = distinct !{!343, !"set_offset"}
!344 = !{!345}
!345 = distinct !{!345, !346, !"set_offset: %fat_ptr"}
!346 = distinct !{!346, !"set_offset"}
!347 = !{!348}
!348 = distinct !{!348, !349, !"set_offset: %fat_ptr"}
!349 = distinct !{!349, !"set_offset"}
!350 = !{!351}
!351 = distinct !{!351, !352, !"set_offset: %fat_ptr"}
!352 = distinct !{!352, !"set_offset"}
!353 = !{!354}
!354 = distinct !{!354, !355, !"set_offset: %fat_ptr"}
!355 = distinct !{!355, !"set_offset"}
!356 = !{!357}
!357 = distinct !{!357, !358, !"set_offset: %fat_ptr"}
!358 = distinct !{!358, !"set_offset"}
!359 = !{!360}
!360 = distinct !{!360, !361, !"set_offset: %fat_ptr"}
!361 = distinct !{!361, !"set_offset"}
!362 = !{!363}
!363 = distinct !{!363, !364, !"set_offset: %fat_ptr"}
!364 = distinct !{!364, !"set_offset"}
!365 = !{!366}
!366 = distinct !{!366, !367, !"size_wrapper: argument 0"}
!367 = distinct !{!367, !"size_wrapper"}
!368 = !{!369}
!369 = distinct !{!369, !370, !"set_offset: %fat_ptr"}
!370 = distinct !{!370, !"set_offset"}
!371 = !{!372}
!372 = distinct !{!372, !373, !"size_wrapper: argument 0"}
!373 = distinct !{!373, !"size_wrapper"}
!374 = !{!375}
!375 = distinct !{!375, !376, !"set_offset: %fat_ptr"}
!376 = distinct !{!376, !"set_offset"}
!377 = !{!378}
!378 = distinct !{!378, !379, !"set_offset: %fat_ptr"}
!379 = distinct !{!379, !"set_offset"}
!380 = !{!381}
!381 = distinct !{!381, !382, !"set_offset: %fat_ptr"}
!382 = distinct !{!382, !"set_offset"}
!383 = !{!384}
!384 = distinct !{!384, !385, !"set_offset: %fat_ptr"}
!385 = distinct !{!385, !"set_offset"}
!386 = !{!387}
!387 = distinct !{!387, !388, !"set_offset: %fat_ptr"}
!388 = distinct !{!388, !"set_offset"}
!389 = !{!390}
!390 = distinct !{!390, !391, !"set_offset: %fat_ptr"}
!391 = distinct !{!391, !"set_offset"}
!392 = !{!393}
!393 = distinct !{!393, !394, !"set_offset: %fat_ptr"}
!394 = distinct !{!394, !"set_offset"}
!395 = !{!396}
!396 = distinct !{!396, !397, !"set_offset: %fat_ptr"}
!397 = distinct !{!397, !"set_offset"}
!398 = !{!399}
!399 = distinct !{!399, !400, !"set_offset: %fat_ptr"}
!400 = distinct !{!400, !"set_offset"}
!401 = !{!402}
!402 = distinct !{!402, !403, !"set_offset: %fat_ptr"}
!403 = distinct !{!403, !"set_offset"}
!404 = !{!405}
!405 = distinct !{!405, !406, !"set_offset: %fat_ptr"}
!406 = distinct !{!406, !"set_offset"}
!407 = !{!408}
!408 = distinct !{!408, !409, !"set_offset: %fat_ptr"}
!409 = distinct !{!409, !"set_offset"}
!410 = !{!411}
!411 = distinct !{!411, !412, !"size_wrapper: argument 0"}
!412 = distinct !{!412, !"size_wrapper"}
!413 = !{!414}
!414 = distinct !{!414, !415, !"set_offset: %fat_ptr"}
!415 = distinct !{!415, !"set_offset"}
!416 = !{!417}
!417 = distinct !{!417, !418, !"size_wrapper: argument 0"}
!418 = distinct !{!418, !"size_wrapper"}
!419 = !{!420}
!420 = distinct !{!420, !421, !"set_offset: %fat_ptr"}
!421 = distinct !{!421, !"set_offset"}
!422 = !{!423}
!423 = distinct !{!423, !424, !"set_offset: %fat_ptr"}
!424 = distinct !{!424, !"set_offset"}
!425 = !{!426}
!426 = distinct !{!426, !427, !"set_offset: %fat_ptr"}
!427 = distinct !{!427, !"set_offset"}
!428 = !{!429}
!429 = distinct !{!429, !430, !"set_offset: %fat_ptr"}
!430 = distinct !{!430, !"set_offset"}
!431 = !{!432}
!432 = distinct !{!432, !433, !"set_offset: %fat_ptr"}
!433 = distinct !{!433, !"set_offset"}
!434 = !{!435}
!435 = distinct !{!435, !436, !"set_offset: %fat_ptr"}
!436 = distinct !{!436, !"set_offset"}
!437 = !{!438}
!438 = distinct !{!438, !439, !"set_offset: %fat_ptr"}
!439 = distinct !{!439, !"set_offset"}
!440 = !{!441}
!441 = distinct !{!441, !442, !"set_offset: %fat_ptr"}
!442 = distinct !{!442, !"set_offset"}
!443 = !{!444}
!444 = distinct !{!444, !445, !"set_offset: %fat_ptr"}
!445 = distinct !{!445, !"set_offset"}
!446 = !{!447}
!447 = distinct !{!447, !448, !"set_offset: %fat_ptr"}
!448 = distinct !{!448, !"set_offset"}
!449 = !{!450}
!450 = distinct !{!450, !451, !"size_wrapper: argument 0"}
!451 = distinct !{!451, !"size_wrapper"}
!452 = !{!453}
!453 = distinct !{!453, !454, !"set_offset: %fat_ptr"}
!454 = distinct !{!454, !"set_offset"}
!455 = !{!456}
!456 = distinct !{!456, !457, !"size_wrapper: argument 0"}
!457 = distinct !{!457, !"size_wrapper"}
!458 = !{!459}
!459 = distinct !{!459, !460, !"set_offset: %fat_ptr"}
!460 = distinct !{!460, !"set_offset"}
!461 = !{!462}
!462 = distinct !{!462, !463, !"set_offset: %fat_ptr"}
!463 = distinct !{!463, !"set_offset"}
!464 = !{!465}
!465 = distinct !{!465, !466, !"set_offset: %fat_ptr"}
!466 = distinct !{!466, !"set_offset"}
!467 = !{!468}
!468 = distinct !{!468, !469, !"set_offset: %fat_ptr"}
!469 = distinct !{!469, !"set_offset"}
!470 = !{!471}
!471 = distinct !{!471, !472, !"set_offset: %fat_ptr"}
!472 = distinct !{!472, !"set_offset"}
!473 = !{!474}
!474 = distinct !{!474, !475, !"set_offset: %fat_ptr"}
!475 = distinct !{!475, !"set_offset"}
!476 = !{!477}
!477 = distinct !{!477, !478, !"set_offset: %fat_ptr"}
!478 = distinct !{!478, !"set_offset"}
!479 = !{!480}
!480 = distinct !{!480, !481, !"set_offset: %fat_ptr"}
!481 = distinct !{!481, !"set_offset"}
!482 = !{!483}
!483 = distinct !{!483, !484, !"set_offset: %fat_ptr"}
!484 = distinct !{!484, !"set_offset"}
!485 = !{!486}
!486 = distinct !{!486, !487, !"set_offset: %fat_ptr"}
!487 = distinct !{!487, !"set_offset"}
!488 = !{!489}
!489 = distinct !{!489, !490, !"set_offset: %fat_ptr"}
!490 = distinct !{!490, !"set_offset"}
!491 = !{!492}
!492 = distinct !{!492, !493, !"set_offset: %fat_ptr"}
!493 = distinct !{!493, !"set_offset"}
!494 = !{!495}
!495 = distinct !{!495, !496, !"set_offset: %fat_ptr"}
!496 = distinct !{!496, !"set_offset"}
!497 = !{!498}
!498 = distinct !{!498, !499, !"set_offset: %fat_ptr"}
!499 = distinct !{!499, !"set_offset"}
!500 = !{!501}
!501 = distinct !{!501, !502, !"size_wrapper: argument 0"}
!502 = distinct !{!502, !"size_wrapper"}
!503 = !{!504}
!504 = distinct !{!504, !505, !"set_offset: %fat_ptr"}
!505 = distinct !{!505, !"set_offset"}
!506 = !{!507}
!507 = distinct !{!507, !508, !"set_offset: %fat_ptr"}
!508 = distinct !{!508, !"set_offset"}
!509 = !{!510}
!510 = distinct !{!510, !511, !"set_offset: %fat_ptr"}
!511 = distinct !{!511, !"set_offset"}
!512 = !{!513}
!513 = distinct !{!513, !514, !"set_offset: %fat_ptr"}
!514 = distinct !{!514, !"set_offset"}
!515 = !{!516}
!516 = distinct !{!516, !517, !"set_offset: %fat_ptr"}
!517 = distinct !{!517, !"set_offset"}
!518 = !{!519}
!519 = distinct !{!519, !520, !"set_offset: %fat_ptr"}
!520 = distinct !{!520, !"set_offset"}
!521 = !{!522}
!522 = distinct !{!522, !523, !"set_offset: %fat_ptr"}
!523 = distinct !{!523, !"set_offset"}
!524 = !{!525}
!525 = distinct !{!525, !526, !"set_offset: %fat_ptr"}
!526 = distinct !{!526, !"set_offset"}
!527 = !{!528}
!528 = distinct !{!528, !529, !"set_offset: %fat_ptr"}
!529 = distinct !{!529, !"set_offset"}
!530 = !{!531}
!531 = distinct !{!531, !532, !"set_offset: %fat_ptr"}
!532 = distinct !{!532, !"set_offset"}
!533 = !{!534}
!534 = distinct !{!534, !535, !"set_offset: %fat_ptr"}
!535 = distinct !{!535, !"set_offset"}
!536 = !{!537}
!537 = distinct !{!537, !538, !"size_wrapper: argument 0"}
!538 = distinct !{!538, !"size_wrapper"}
!539 = !{!540}
!540 = distinct !{!540, !541, !"set_offset: %fat_ptr"}
!541 = distinct !{!541, !"set_offset"}
!542 = !{!543}
!543 = distinct !{!543, !544, !"set_offset: %fat_ptr"}
!544 = distinct !{!544, !"set_offset"}
!545 = !{!546}
!546 = distinct !{!546, !547, !"set_offset: %fat_ptr"}
!547 = distinct !{!547, !"set_offset"}
!548 = !{!549}
!549 = distinct !{!549, !550, !"set_offset: %fat_ptr"}
!550 = distinct !{!550, !"set_offset"}
!551 = !{!552}
!552 = distinct !{!552, !553, !"set_offset: %fat_ptr"}
!553 = distinct !{!553, !"set_offset"}
!554 = !{!555}
!555 = distinct !{!555, !556, !"set_offset: %fat_ptr"}
!556 = distinct !{!556, !"set_offset"}
!557 = !{!558}
!558 = distinct !{!558, !559, !"set_offset: %fat_ptr"}
!559 = distinct !{!559, !"set_offset"}
!560 = !{!561}
!561 = distinct !{!561, !562, !"set_offset: %fat_ptr"}
!562 = distinct !{!562, !"set_offset"}
!563 = !{!564}
!564 = distinct !{!564, !565, !"set_offset: %fat_ptr"}
!565 = distinct !{!565, !"set_offset"}
!566 = !{!567}
!567 = distinct !{!567, !568, !"set_offset: %fat_ptr"}
!568 = distinct !{!568, !"set_offset"}
!569 = !{!570}
!570 = distinct !{!570, !571, !"set_offset: %fat_ptr"}
!571 = distinct !{!571, !"set_offset"}
!572 = !{!573}
!573 = distinct !{!573, !574, !"set_offset: %fat_ptr"}
!574 = distinct !{!574, !"set_offset"}
!575 = !{!576}
!576 = distinct !{!576, !577, !"set_offset: %fat_ptr"}
!577 = distinct !{!577, !"set_offset"}
!578 = !{!579}
!579 = distinct !{!579, !580, !"set_offset: %fat_ptr"}
!580 = distinct !{!580, !"set_offset"}
!581 = !{!582}
!582 = distinct !{!582, !583, !"set_offset: %fat_ptr"}
!583 = distinct !{!583, !"set_offset"}
!584 = !{!585}
!585 = distinct !{!585, !586, !"set_offset: %fat_ptr"}
!586 = distinct !{!586, !"set_offset"}
!587 = !{!588}
!588 = distinct !{!588, !589, !"set_offset: %fat_ptr"}
!589 = distinct !{!589, !"set_offset"}
!590 = !{!591}
!591 = distinct !{!591, !592, !"set_offset: %fat_ptr"}
!592 = distinct !{!592, !"set_offset"}
!593 = !{!594}
!594 = distinct !{!594, !595, !"set_offset: %fat_ptr"}
!595 = distinct !{!595, !"set_offset"}
!596 = !{!597}
!597 = distinct !{!597, !598, !"set_offset: %fat_ptr"}
!598 = distinct !{!598, !"set_offset"}
!599 = !{!600}
!600 = distinct !{!600, !601, !"set_offset: %fat_ptr"}
!601 = distinct !{!601, !"set_offset"}
!602 = !{!603}
!603 = distinct !{!603, !604, !"set_offset: %fat_ptr"}
!604 = distinct !{!604, !"set_offset"}
!605 = !{!606}
!606 = distinct !{!606, !607, !"set_offset: %fat_ptr"}
!607 = distinct !{!607, !"set_offset"}
!608 = !{!609}
!609 = distinct !{!609, !610, !"set_offset: %fat_ptr"}
!610 = distinct !{!610, !"set_offset"}
!611 = !{!612}
!612 = distinct !{!612, !613, !"set_offset: %fat_ptr"}
!613 = distinct !{!613, !"set_offset"}
!614 = !{!615}
!615 = distinct !{!615, !616, !"set_offset: %fat_ptr"}
!616 = distinct !{!616, !"set_offset"}
!617 = !{!618}
!618 = distinct !{!618, !619, !"set_offset: %fat_ptr"}
!619 = distinct !{!619, !"set_offset"}
!620 = !{!621}
!621 = distinct !{!621, !622, !"set_offset: %fat_ptr"}
!622 = distinct !{!622, !"set_offset"}
!623 = !{!624}
!624 = distinct !{!624, !625, !"set_offset: %fat_ptr"}
!625 = distinct !{!625, !"set_offset"}
!626 = !{!627}
!627 = distinct !{!627, !628, !"set_offset: %fat_ptr"}
!628 = distinct !{!628, !"set_offset"}
!629 = !{!630}
!630 = distinct !{!630, !631, !"set_offset: %fat_ptr"}
!631 = distinct !{!631, !"set_offset"}
!632 = !{!633}
!633 = distinct !{!633, !634, !"set_offset: %fat_ptr"}
!634 = distinct !{!634, !"set_offset"}
!635 = !{!636}
!636 = distinct !{!636, !637, !"set_offset: %fat_ptr"}
!637 = distinct !{!637, !"set_offset"}
!638 = !{!639}
!639 = distinct !{!639, !640, !"set_offset: %fat_ptr"}
!640 = distinct !{!640, !"set_offset"}
!641 = !{!642}
!642 = distinct !{!642, !643, !"set_offset: %fat_ptr"}
!643 = distinct !{!643, !"set_offset"}
!644 = !{!645}
!645 = distinct !{!645, !646, !"set_offset: %fat_ptr"}
!646 = distinct !{!646, !"set_offset"}
!647 = !{!648}
!648 = distinct !{!648, !649, !"set_offset: %fat_ptr"}
!649 = distinct !{!649, !"set_offset"}
!650 = !{!651}
!651 = distinct !{!651, !652, !"set_offset: %fat_ptr"}
!652 = distinct !{!652, !"set_offset"}
!653 = !{!654}
!654 = distinct !{!654, !655, !"set_offset: %fat_ptr"}
!655 = distinct !{!655, !"set_offset"}
!656 = !{!657}
!657 = distinct !{!657, !658, !"set_offset: %fat_ptr"}
!658 = distinct !{!658, !"set_offset"}
!659 = !{!660}
!660 = distinct !{!660, !661, !"set_offset: %fat_ptr"}
!661 = distinct !{!661, !"set_offset"}
!662 = !{!663}
!663 = distinct !{!663, !664, !"set_offset: %fat_ptr"}
!664 = distinct !{!664, !"set_offset"}
!665 = !{!666}
!666 = distinct !{!666, !667, !"set_offset: %fat_ptr"}
!667 = distinct !{!667, !"set_offset"}
!668 = !{!669}
!669 = distinct !{!669, !670, !"set_offset: %fat_ptr"}
!670 = distinct !{!670, !"set_offset"}
!671 = !{!672}
!672 = distinct !{!672, !673, !"set_offset: %fat_ptr"}
!673 = distinct !{!673, !"set_offset"}
!674 = !{!675}
!675 = distinct !{!675, !676, !"set_offset: %fat_ptr"}
!676 = distinct !{!676, !"set_offset"}
!677 = !{!678}
!678 = distinct !{!678, !679, !"set_offset: %fat_ptr"}
!679 = distinct !{!679, !"set_offset"}
!680 = !{!681}
!681 = distinct !{!681, !682, !"set_offset: %fat_ptr"}
!682 = distinct !{!682, !"set_offset"}
!683 = !{!684}
!684 = distinct !{!684, !685, !"set_offset: %fat_ptr"}
!685 = distinct !{!685, !"set_offset"}
!686 = !{!687}
!687 = distinct !{!687, !688, !"set_offset: %fat_ptr"}
!688 = distinct !{!688, !"set_offset"}
!689 = !{!690}
!690 = distinct !{!690, !691, !"set_offset: %fat_ptr"}
!691 = distinct !{!691, !"set_offset"}
!692 = !{!693}
!693 = distinct !{!693, !694, !"set_offset: %fat_ptr"}
!694 = distinct !{!694, !"set_offset"}
!695 = !{!696}
!696 = distinct !{!696, !697, !"set_offset: %fat_ptr"}
!697 = distinct !{!697, !"set_offset"}
!698 = !{!699}
!699 = distinct !{!699, !700, !"set_offset: %fat_ptr"}
!700 = distinct !{!700, !"set_offset"}
!701 = !{!702}
!702 = distinct !{!702, !703, !"set_offset: %fat_ptr"}
!703 = distinct !{!703, !"set_offset"}
!704 = !{!705}
!705 = distinct !{!705, !706, !"set_offset: %fat_ptr"}
!706 = distinct !{!706, !"set_offset"}
!707 = !{!708}
!708 = distinct !{!708, !709, !"set_offset: %fat_ptr"}
!709 = distinct !{!709, !"set_offset"}
!710 = !{!711}
!711 = distinct !{!711, !712, !"set_offset: %fat_ptr"}
!712 = distinct !{!712, !"set_offset"}
!713 = !{!714}
!714 = distinct !{!714, !715, !"set_offset: %fat_ptr"}
!715 = distinct !{!715, !"set_offset"}
!716 = !{!717}
!717 = distinct !{!717, !718, !"set_offset: %fat_ptr"}
!718 = distinct !{!718, !"set_offset"}
!719 = !{!720}
!720 = distinct !{!720, !721, !"set_offset: %fat_ptr"}
!721 = distinct !{!721, !"set_offset"}
!722 = !{!723}
!723 = distinct !{!723, !724, !"set_offset: %fat_ptr"}
!724 = distinct !{!724, !"set_offset"}
!725 = !{!726}
!726 = distinct !{!726, !727, !"set_offset: %fat_ptr"}
!727 = distinct !{!727, !"set_offset"}
!728 = !{!729}
!729 = distinct !{!729, !730, !"set_offset: %fat_ptr"}
!730 = distinct !{!730, !"set_offset"}
!731 = !{!732}
!732 = distinct !{!732, !733, !"set_offset: %fat_ptr"}
!733 = distinct !{!733, !"set_offset"}
!734 = !{!735}
!735 = distinct !{!735, !736, !"set_offset: %fat_ptr"}
!736 = distinct !{!736, !"set_offset"}
!737 = !{!738}
!738 = distinct !{!738, !739, !"set_offset: %fat_ptr"}
!739 = distinct !{!739, !"set_offset"}
!740 = !{!741}
!741 = distinct !{!741, !742, !"set_offset: %fat_ptr"}
!742 = distinct !{!742, !"set_offset"}
!743 = !{!744}
!744 = distinct !{!744, !745, !"set_offset: %fat_ptr"}
!745 = distinct !{!745, !"set_offset"}
!746 = !{!747}
!747 = distinct !{!747, !748, !"set_offset: %fat_ptr"}
!748 = distinct !{!748, !"set_offset"}
!749 = !{!750}
!750 = distinct !{!750, !751, !"set_offset: %fat_ptr"}
!751 = distinct !{!751, !"set_offset"}
!752 = !{!753}
!753 = distinct !{!753, !754, !"set_offset: %fat_ptr"}
!754 = distinct !{!754, !"set_offset"}
!755 = !{!756}
!756 = distinct !{!756, !757, !"set_offset: %fat_ptr"}
!757 = distinct !{!757, !"set_offset"}
!758 = !{!759}
!759 = distinct !{!759, !760, !"set_offset: %fat_ptr"}
!760 = distinct !{!760, !"set_offset"}
!761 = !{!762}
!762 = distinct !{!762, !763, !"set_offset: %fat_ptr"}
!763 = distinct !{!763, !"set_offset"}
!764 = !{!765}
!765 = distinct !{!765, !766, !"set_offset: %fat_ptr"}
!766 = distinct !{!766, !"set_offset"}
!767 = !{!768}
!768 = distinct !{!768, !769, !"set_offset: %fat_ptr"}
!769 = distinct !{!769, !"set_offset"}
!770 = !{!771}
!771 = distinct !{!771, !772, !"set_offset: %fat_ptr"}
!772 = distinct !{!772, !"set_offset"}
!773 = !{!774}
!774 = distinct !{!774, !775, !"set_offset: %fat_ptr"}
!775 = distinct !{!775, !"set_offset"}
!776 = !{!777}
!777 = distinct !{!777, !778, !"set_offset: %fat_ptr"}
!778 = distinct !{!778, !"set_offset"}
!779 = !{!780}
!780 = distinct !{!780, !781, !"set_offset: %fat_ptr"}
!781 = distinct !{!781, !"set_offset"}
!782 = !{!783}
!783 = distinct !{!783, !784, !"set_offset: %fat_ptr"}
!784 = distinct !{!784, !"set_offset"}
!785 = !{!786}
!786 = distinct !{!786, !787, !"set_offset: %fat_ptr"}
!787 = distinct !{!787, !"set_offset"}
!788 = !{!789}
!789 = distinct !{!789, !790, !"size_wrapper: argument 0"}
!790 = distinct !{!790, !"size_wrapper"}
!791 = !{!792}
!792 = distinct !{!792, !793, !"set_offset: %fat_ptr"}
!793 = distinct !{!793, !"set_offset"}
!794 = !{!795}
!795 = distinct !{!795, !796, !"set_offset: %fat_ptr"}
!796 = distinct !{!796, !"set_offset"}
!797 = !{!798}
!798 = distinct !{!798, !799, !"set_offset: %fat_ptr"}
!799 = distinct !{!799, !"set_offset"}
!800 = !{!801}
!801 = distinct !{!801, !802, !"set_offset: %fat_ptr"}
!802 = distinct !{!802, !"set_offset"}
!803 = !{!804}
!804 = distinct !{!804, !805, !"set_offset: %fat_ptr"}
!805 = distinct !{!805, !"set_offset"}
!806 = !{!807}
!807 = distinct !{!807, !808, !"set_offset: %fat_ptr"}
!808 = distinct !{!808, !"set_offset"}
!809 = !{!810}
!810 = distinct !{!810, !811, !"set_offset: %fat_ptr"}
!811 = distinct !{!811, !"set_offset"}
!812 = !{!813}
!813 = distinct !{!813, !814, !"set_offset: %fat_ptr"}
!814 = distinct !{!814, !"set_offset"}
!815 = !{!816}
!816 = distinct !{!816, !817, !"set_offset: %fat_ptr"}
!817 = distinct !{!817, !"set_offset"}
!818 = !{!819}
!819 = distinct !{!819, !820, !"set_offset: %fat_ptr"}
!820 = distinct !{!820, !"set_offset"}
!821 = !{!822}
!822 = distinct !{!822, !823, !"set_offset: %fat_ptr"}
!823 = distinct !{!823, !"set_offset"}
!824 = !{!825}
!825 = distinct !{!825, !826, !"set_offset: %fat_ptr"}
!826 = distinct !{!826, !"set_offset"}
!827 = !{!828}
!828 = distinct !{!828, !829, !"set_offset: %fat_ptr"}
!829 = distinct !{!829, !"set_offset"}
!830 = !{!831}
!831 = distinct !{!831, !832, !"set_offset: %fat_ptr"}
!832 = distinct !{!832, !"set_offset"}
!833 = !{!834}
!834 = distinct !{!834, !835, !"set_offset: %fat_ptr"}
!835 = distinct !{!835, !"set_offset"}
!836 = !{!837}
!837 = distinct !{!837, !838, !"set_offset: %fat_ptr"}
!838 = distinct !{!838, !"set_offset"}
!839 = !{!840}
!840 = distinct !{!840, !841, !"set_offset: %fat_ptr"}
!841 = distinct !{!841, !"set_offset"}
!842 = !{!843}
!843 = distinct !{!843, !844, !"set_offset: %fat_ptr"}
!844 = distinct !{!844, !"set_offset"}
!845 = !{!846}
!846 = distinct !{!846, !847, !"set_offset: %fat_ptr"}
!847 = distinct !{!847, !"set_offset"}
!848 = !{!849}
!849 = distinct !{!849, !850, !"set_offset: %fat_ptr"}
!850 = distinct !{!850, !"set_offset"}
!851 = !{!852}
!852 = distinct !{!852, !853, !"set_offset: %fat_ptr"}
!853 = distinct !{!853, !"set_offset"}
!854 = !{!855}
!855 = distinct !{!855, !856, !"set_offset: %fat_ptr"}
!856 = distinct !{!856, !"set_offset"}
!857 = !{!858}
!858 = distinct !{!858, !859, !"set_offset: %fat_ptr"}
!859 = distinct !{!859, !"set_offset"}
!860 = !{!861}
!861 = distinct !{!861, !862, !"set_offset: %fat_ptr"}
!862 = distinct !{!862, !"set_offset"}
!863 = !{!864}
!864 = distinct !{!864, !865, !"set_offset: %fat_ptr"}
!865 = distinct !{!865, !"set_offset"}
!866 = !{!867}
!867 = distinct !{!867, !868, !"set_offset: %fat_ptr"}
!868 = distinct !{!868, !"set_offset"}
!869 = !{!870}
!870 = distinct !{!870, !871, !"set_offset: %fat_ptr"}
!871 = distinct !{!871, !"set_offset"}
!872 = !{!873}
!873 = distinct !{!873, !874, !"set_offset: %fat_ptr"}
!874 = distinct !{!874, !"set_offset"}
!875 = !{!876}
!876 = distinct !{!876, !877, !"set_offset: %fat_ptr"}
!877 = distinct !{!877, !"set_offset"}
!878 = !{!879}
!879 = distinct !{!879, !880, !"set_offset: %fat_ptr"}
!880 = distinct !{!880, !"set_offset"}
!881 = !{!882}
!882 = distinct !{!882, !883, !"set_offset: %fat_ptr"}
!883 = distinct !{!883, !"set_offset"}
!884 = !{!885}
!885 = distinct !{!885, !886, !"set_offset: %fat_ptr"}
!886 = distinct !{!886, !"set_offset"}
!887 = !{!888}
!888 = distinct !{!888, !889, !"set_offset: %fat_ptr"}
!889 = distinct !{!889, !"set_offset"}
!890 = !{!891}
!891 = distinct !{!891, !892, !"set_offset: %fat_ptr"}
!892 = distinct !{!892, !"set_offset"}
!893 = !{!894}
!894 = distinct !{!894, !895, !"set_offset: %fat_ptr"}
!895 = distinct !{!895, !"set_offset"}
!896 = !{!897}
!897 = distinct !{!897, !898, !"set_offset: %fat_ptr"}
!898 = distinct !{!898, !"set_offset"}
!899 = !{!900}
!900 = distinct !{!900, !901, !"set_offset: %fat_ptr"}
!901 = distinct !{!901, !"set_offset"}
!902 = !{!903}
!903 = distinct !{!903, !904, !"set_offset: %fat_ptr"}
!904 = distinct !{!904, !"set_offset"}
!905 = !{!906}
!906 = distinct !{!906, !907, !"set_offset: %fat_ptr"}
!907 = distinct !{!907, !"set_offset"}
!908 = !{!909}
!909 = distinct !{!909, !910, !"set_offset: %fat_ptr"}
!910 = distinct !{!910, !"set_offset"}
!911 = !{!912}
!912 = distinct !{!912, !913, !"set_offset: %fat_ptr"}
!913 = distinct !{!913, !"set_offset"}
!914 = !{!915}
!915 = distinct !{!915, !916, !"set_offset: %fat_ptr"}
!916 = distinct !{!916, !"set_offset"}
!917 = !{!918}
!918 = distinct !{!918, !919, !"set_offset: %fat_ptr"}
!919 = distinct !{!919, !"set_offset"}
!920 = !{!921}
!921 = distinct !{!921, !922, !"set_offset: %fat_ptr"}
!922 = distinct !{!922, !"set_offset"}
!923 = !{!924}
!924 = distinct !{!924, !925, !"set_offset: %fat_ptr"}
!925 = distinct !{!925, !"set_offset"}
!926 = !{!927}
!927 = distinct !{!927, !928, !"set_offset: %fat_ptr"}
!928 = distinct !{!928, !"set_offset"}
!929 = !{!930}
!930 = distinct !{!930, !931, !"set_offset: %fat_ptr"}
!931 = distinct !{!931, !"set_offset"}
!932 = !{!933}
!933 = distinct !{!933, !934, !"set_offset: %fat_ptr"}
!934 = distinct !{!934, !"set_offset"}
!935 = !{!936}
!936 = distinct !{!936, !937, !"set_offset: %fat_ptr"}
!937 = distinct !{!937, !"set_offset"}
!938 = !{!939}
!939 = distinct !{!939, !940, !"set_offset: %fat_ptr"}
!940 = distinct !{!940, !"set_offset"}
!941 = !{!942}
!942 = distinct !{!942, !943, !"set_offset: %fat_ptr"}
!943 = distinct !{!943, !"set_offset"}
!944 = !{!945}
!945 = distinct !{!945, !946, !"set_offset: %fat_ptr"}
!946 = distinct !{!946, !"set_offset"}
!947 = !{!948}
!948 = distinct !{!948, !949, !"set_offset: %fat_ptr"}
!949 = distinct !{!949, !"set_offset"}
!950 = !{!951}
!951 = distinct !{!951, !952, !"set_offset: %fat_ptr"}
!952 = distinct !{!952, !"set_offset"}
!953 = !{!954}
!954 = distinct !{!954, !955, !"set_offset: %fat_ptr"}
!955 = distinct !{!955, !"set_offset"}
!956 = !{!957}
!957 = distinct !{!957, !958, !"set_offset: %fat_ptr"}
!958 = distinct !{!958, !"set_offset"}
!959 = !{!960}
!960 = distinct !{!960, !961, !"set_offset: %fat_ptr"}
!961 = distinct !{!961, !"set_offset"}
!962 = !{!963}
!963 = distinct !{!963, !964, !"set_offset: %fat_ptr"}
!964 = distinct !{!964, !"set_offset"}
!965 = !{!966}
!966 = distinct !{!966, !967, !"set_offset: %fat_ptr"}
!967 = distinct !{!967, !"set_offset"}
!968 = !{!969}
!969 = distinct !{!969, !970, !"set_offset: %fat_ptr"}
!970 = distinct !{!970, !"set_offset"}
!971 = !{!972}
!972 = distinct !{!972, !973, !"set_offset: %fat_ptr"}
!973 = distinct !{!973, !"set_offset"}
!974 = !{!975}
!975 = distinct !{!975, !976, !"set_offset: %fat_ptr"}
!976 = distinct !{!976, !"set_offset"}
!977 = !{!978}
!978 = distinct !{!978, !979, !"set_offset: %fat_ptr"}
!979 = distinct !{!979, !"set_offset"}
!980 = !{!981}
!981 = distinct !{!981, !982, !"set_offset: %fat_ptr"}
!982 = distinct !{!982, !"set_offset"}
!983 = !{!984}
!984 = distinct !{!984, !985, !"set_offset: %fat_ptr"}
!985 = distinct !{!985, !"set_offset"}
!986 = !{!987}
!987 = distinct !{!987, !988, !"set_offset: %fat_ptr"}
!988 = distinct !{!988, !"set_offset"}
!989 = !{!990}
!990 = distinct !{!990, !991, !"set_offset: %fat_ptr"}
!991 = distinct !{!991, !"set_offset"}
!992 = !{!993}
!993 = distinct !{!993, !994, !"set_offset: %fat_ptr"}
!994 = distinct !{!994, !"set_offset"}
!995 = !{!996}
!996 = distinct !{!996, !997, !"set_offset: %fat_ptr"}
!997 = distinct !{!997, !"set_offset"}
!998 = !{!999}
!999 = distinct !{!999, !1000, !"set_offset: %fat_ptr"}
!1000 = distinct !{!1000, !"set_offset"}
!1001 = !{!1002}
!1002 = distinct !{!1002, !1003, !"set_offset: %fat_ptr"}
!1003 = distinct !{!1003, !"set_offset"}
!1004 = !{!1005}
!1005 = distinct !{!1005, !1006, !"set_offset: %fat_ptr"}
!1006 = distinct !{!1006, !"set_offset"}
!1007 = !{!1008}
!1008 = distinct !{!1008, !1009, !"set_offset: %fat_ptr"}
!1009 = distinct !{!1009, !"set_offset"}
!1010 = !{!1011}
!1011 = distinct !{!1011, !1012, !"set_offset: %fat_ptr"}
!1012 = distinct !{!1012, !"set_offset"}
!1013 = !{!1014}
!1014 = distinct !{!1014, !1015, !"set_offset: %fat_ptr"}
!1015 = distinct !{!1015, !"set_offset"}
!1016 = !{!1017}
!1017 = distinct !{!1017, !1018, !"set_offset: %fat_ptr"}
!1018 = distinct !{!1018, !"set_offset"}
!1019 = !{!1020}
!1020 = distinct !{!1020, !1021, !"set_offset: %fat_ptr"}
!1021 = distinct !{!1021, !"set_offset"}
!1022 = !{!1023}
!1023 = distinct !{!1023, !1024, !"set_offset: %fat_ptr"}
!1024 = distinct !{!1024, !"set_offset"}
!1025 = !{!1026}
!1026 = distinct !{!1026, !1027, !"set_offset: %fat_ptr"}
!1027 = distinct !{!1027, !"set_offset"}
!1028 = !{!1029}
!1029 = distinct !{!1029, !1030, !"set_offset: %fat_ptr"}
!1030 = distinct !{!1030, !"set_offset"}
!1031 = !{!1032}
!1032 = distinct !{!1032, !1033, !"set_offset: %fat_ptr"}
!1033 = distinct !{!1033, !"set_offset"}
!1034 = !{!1035}
!1035 = distinct !{!1035, !1036, !"set_offset: %fat_ptr"}
!1036 = distinct !{!1036, !"set_offset"}
!1037 = !{!1038}
!1038 = distinct !{!1038, !1039, !"set_offset: %fat_ptr"}
!1039 = distinct !{!1039, !"set_offset"}
!1040 = !{!1041}
!1041 = distinct !{!1041, !1042, !"set_offset: %fat_ptr"}
!1042 = distinct !{!1042, !"set_offset"}
!1043 = !{!1044}
!1044 = distinct !{!1044, !1045, !"set_offset: %fat_ptr"}
!1045 = distinct !{!1045, !"set_offset"}
!1046 = !{!1047}
!1047 = distinct !{!1047, !1048, !"set_offset: %fat_ptr"}
!1048 = distinct !{!1048, !"set_offset"}
!1049 = !{!1050}
!1050 = distinct !{!1050, !1051, !"set_offset: %fat_ptr"}
!1051 = distinct !{!1051, !"set_offset"}
!1052 = !{!1053}
!1053 = distinct !{!1053, !1054, !"set_offset: %fat_ptr"}
!1054 = distinct !{!1054, !"set_offset"}
!1055 = !{!1056}
!1056 = distinct !{!1056, !1057, !"set_offset: %fat_ptr"}
!1057 = distinct !{!1057, !"set_offset"}
!1058 = !{!1059}
!1059 = distinct !{!1059, !1060, !"set_offset: %fat_ptr"}
!1060 = distinct !{!1060, !"set_offset"}
!1061 = !{!1062}
!1062 = distinct !{!1062, !1063, !"set_offset: %fat_ptr"}
!1063 = distinct !{!1063, !"set_offset"}
!1064 = !{!1065}
!1065 = distinct !{!1065, !1066, !"set_offset: %fat_ptr"}
!1066 = distinct !{!1066, !"set_offset"}
